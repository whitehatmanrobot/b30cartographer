er, EventArgs e)
        {
            Type t = (Type) cmbScheduler.SelectedItem;

            // shut down the old scheduler
            if (_scheduler != null)
            {
                // determine if we actually need to change
                if (_scheduler.GetType() == t)
                {
                    return;
                }

                grpScheduler.Controls.Clear();
                _scheduler.Shutdown();
                _scheduler = null;
            }

            // attempt to get the default constructor
            ConstructorInfo ci = t.GetConstructor(Type.EmptyTypes);

            if (ci == null)
            {
                _report.Error(t.FullName + " does not contain a default constructor.");
                return;
            }

            _scheduler = (StressTestScheduler) ci.Invoke(null);

            if (_scheduler == null)
            {
                _report.Error("Constructor for {0} returned null.", t.FullName);
                return;
            }

            // since we changed schedulers we need to init it
            _scheduler.Initialize(null, JobList, null);
            SyncSchedulerSettingsToUI();

            Control c = _scheduler.SchedulerControl;

            if (c == null)
            {
                _report.Warn("The scheduler ({0}) did not return a control.", t.FullName);
                return;
            }

            c.Dock = DockStyle.Fill;
            grpScheduler.MinimumSize = c.MinimumSize;
            grpScheduler.Controls.Add(_scheduler.SchedulerControl);

            // update scale text values
            string scale = _scheduler.ScaleName;
            _scale_column.Header.Text = scale;
            lblDetailsScaleName.Text = scale + ":";
            _scale_menu.Text = _scheduler.ScaleName;

            foreach (ListViewItem item in lstJobs.Items)
            {
                ReloadScaleColumnForItem(item);
            }
        }

        private void btnStartStop_Click(object sender, EventArgs e)
        {
            lock (btnStartStop)
            {
                if (_running) //need to stop
                {
                    _running = false;
                    btnStartStop.Text = "Start";
                    btnStartStop.Enabled=false;
                    cmbScheduler.Enabled = true;
                    _stress_thread = ThreadMaker.CreateThread(StopStress);
                    _stress_thread.Start();
                }
                else //need to start
                {
                    _running = true;
                    btnStartStop.Text = "Stop";
                    cmbScheduler.Enabled = false;
                    if (_gui_hooks != null) { _gui_hooks.LimitOutput(100000); }
                    _stress_thread = ThreadMaker.CreateThread(RunStress);
                    _stress_thread.Start();
                }
            }
        }

        //runs stress
        protected void RunStress()
        {
            StressSchedulerHelpers.RunScheduler(_scheduler, JobList);
        }

        //stops running stress
        protected void StopStress()
        {
            StressSchedulerHelpers.StopScheduler(_scheduler);

            if (_gui_hooks.MainForm.IsHandleCreated && !_gui_hooks.MainForm.IsDisposed && !_gui_hooks.MainForm.Disposing && _gui_hooks.MainForm.Created && _gui_hooks.MainForm.Visible) //There is a bug where if the main gui closes, .NET will deadlock itself on the Invoke call.  Adding checks here to make sure the main form is actually in a good state before Invoking, to avoid that condition.
            {
                btnStartStop.Invoke(new InvokeCode(delegate
                {
                    btnStartStop.Enabled=true;
                }));
            }
        }

        public delegate void InvokeCode();

        private void tmrTick_Tick(object sender, EventArgs e)
        {
            try
            {
                _scheduler.Tick();
            }
            catch (Exception exc)
            {
                _report.Debug("Error calling the scheduler's Tick fucntion:\n" + exc.ToString());
            }
            
            lstJobs.BeginUpdate();

            try
            {
                foreach (ListViewItem item in lstJobs.Items)
                {
                    // I'd like to not have to do this here, or anywhere
                    ((StressJob)item.Tag).Results.TakeSample();

                    RefreshSubItems(item);
                }
            }
            finally
            {
                lstJobs.EndUpdate();
            }

            UpdateDetailsPane();

            if (chkStopTime.Checked && dtpStopTime.Value < DateTime.Now)
            {
                Stop();
            }

            if (PerfCountersEnabled)
            {
                UpdatePerfCounters();
            }
        }

        private void chkStopTime_CheckedChanged(object sender, EventArgs e)
        {
            dtpStopTime.Enabled = chkStopTime.Checked;
        }

        private void lstJobs_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (_tempscale)
            {
                // if the change fails to take, we can't do much about this
                ApplyTempScale(_tempjob, txtScale.Text);
            }

            if (JobsSingleSelected)
            {
                _lastkey = DateTime.MinValue;
                _tempjob = lstJobs.SelectedItems[0];
                SetScaleTagAndText(_scheduler.GetScaleValue((StressJob)_tempjob.Tag).ToString());
                txtScale.Enabled = true;
            }
            else
            {
                SetScaleTagAndText("");
                txtScale.Enabled = false;
            }

            UpdateDetailsPane();
        }

        private void lstJobs_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (JobsSingleSelected)
            {
                if (char.IsDigit(e.KeyChar) || e.KeyChar == '.')
                {
                    e.Handled = true;

                    DateTime now = DateTime.Now;

                    if ((now - _lastkey).TotalSeconds > 3)
                    {
                        txtScale.Text = e.KeyChar.ToString();
                    }
                    else
                    {
                        txtScale.Text += e.KeyChar.ToString();
                    }

                    _lastkey = now;
                }
                else if (e.KeyChar == '\b')
                {
                    e.Handled = true;

                    DateTime now = DateTime.Now;

                    if ((now - _lastkey).TotalSeconds > 3)
                    {
                        txtScale.Text = "";
                    }
                    else
                    {
                        int l = txtScale.Text.Length;
                        txtScale.Text = (l > 1 ? txtScale.Text.Substring(0, l - 1) : "");
                    }

                    _lastkey = now;
                }
                else if (e.KeyChar == '\r')
                {
                    if (_tempscale)
                    {
                        ApplyTempScale(_tempjob, txtScale.Text);
                    }

                    if (!_tempscale)
                    {
                        int selected = lstJobs.SelectedIndices[0];

                        if (lstJobs.Items.Count > selected + 1)
                        {
                            lstJobs.Items[selected].Selected = false;
                            lstJobs.Items[selected].Focused = false;
                            lstJobs.Items[selected + 1].Selected = true;
                            lstJobs.Items[selected + 1].Focused = true;
                        }
                    }

                    e.Handled = true;
                }
                else if (e.KeyChar == ((char)27))
                {
                    if (_tempscale)
                    {
                        _lastkey = DateTime.MinValue;
                        SetScaleTagAndText(_scheduler.GetScaleValue((StressJob)_tempjob.Tag).ToString());
                    }

                    e.Handled = true;
                }
            }
        }

        private void txtScale_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (e.KeyChar == '\r')
            {
                if (_tempscale)
                {
                    ApplyTempScale(_tempjob, txtScale.Text);
                }
            }
            else if (e.KeyChar == ((char)27))
            {
                if (_tempscale)
                {
                    _lastkey = DateTime.MinValue;
                    SetScaleTagAndText(_scheduler.GetScaleValue((StressJob)_tempjob.Tag).ToString());
                }
            }
            else
            {
                return;
            }

            e.Handled = true;
        }

        private void txtScale_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Down)
            {
                if (_tempscale)
                {
                    ApplyTempScale(_tempjob, txtScale.Text);
                }

                if (!_tempscale)
                {
                    int selected = lstJobs.SelectedIndices[0];

                    if (lstJobs.Items.Count > selected + 1)
                    {
                        lstJobs.Items[selected].Selected = false;
                        lstJobs.Items[selected].Focused = false;
                        lstJobs.Items[selected + 1].Selected = true;
                        lstJobs.Items[selected + 1].Focused = true;
                    }
                }

                txtScale.Focus();
            }
            else if (e.KeyCode == Keys.Up)
            {
                if (_tempscale)
                {
                    ApplyTempScale(_tempjob, txtScale.Text);
                }

                if (!_tempscale)
                {
                    int selected = lstJobs.SelectedIndices[0];

                    if (selected > 0)
                    {
                        lstJobs.Items[selected].Selected = false;
                        lstJobs.Items[selected].Focused = false;
                        lstJobs.Items[selected - 1].Selected = true;
                        lstJobs.Items[selected - 1].Focused = true;
                    }
                }

                txtScale.Focus();
            }
            else
            {
                return;
            }

            e.Handled = true;
        }

        private void txtScale_TextChanged(object sender, EventArgs e)
        {
            ChangeScaleColor();
        }

        private void ChangeScaleColor()
        {
            txtScale.BackColor = (_tempscale ? Color.LightPink : _oldcolor);
        }

        private DateTime _lastkey = DateTime.MinValue;
        private bool _tempscale
        {
            get { return (((string)txtScale.Tag) != txtScale.Text); }
            set { if (!value) { SetScaleTagAndText(txtScale.Text); } }
        }
        private ListViewItem _tempjob = null;
        private Color _oldcolor;

        private void mniSizeAllToFit_Click(object sender, EventArgs e)
        {
            lstJobs.AutoResizeColumns(ColumnHeaderAutoResizeStyle.ColumnContent);
        }

        private void mniMore_Click(object sender, EventArgs e)
        {
            StressColumnChooser scc = new StressColumnChooser();
            scc.Columns = _columns;
            if (scc.ShowDialog() == DialogResult.OK)
            {
                SyncColumns();
            }
        }

        #endregion

        #region Not Public

        #region Column Functions

        /// <summary>
        /// Populates the column list with the default values.
        /// </summary>
        protected void PopulateDefaultColumns()
        {
            _columns.Clear();
            _columns.Add(new StressColumn("Name", true, true, true, null));
            _scale_column = new StressColumn("Scale", false, true, true, null);
            _columns.Add(_scale_column);
            _columns.Add(new StressColumn("Passed", false, true, true, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.Passed.ToString();
            }));
            _columns.Add(new StressColumn("Failed", false, true, true, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.Failed.ToString();
            }));
            _columns.Add(new StressColumn("Rate", false, true, true, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = (job.Results.PassRate * 100).ToString("F2") + "%";
            }));
            _columns.Add(new StressColumn("TPS", false, true, true, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.RunningTPS.ToString("F2");
            }));
            _columns.Add(new StressColumn("Private TPS", false, true, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.RunningPrivateTPS.ToString("F2");
            }));
            _columns.Add(new StressColumn("In Progress", false, true, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.InProgress.ToString();
            }));
            _columns.Add(new StressColumn("Threads", false, true, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.Threads.ToString();
            }));
            _columns.Add(new StressColumn("Deadlocked", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.Deadlocked.ToString();
            }));
            _columns.Add(new StressColumn("Skipped", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.Skipped.ToString();
            }));
            _columns.Add(new StressColumn("TPS (5)", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.RunningShortTPS.ToString("F2");
            }));
            _columns.Add(new StressColumn("TPS (120)", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.RunningTPS120.ToString("F2");
            }));
            _columns.Add(new StressColumn("Total TPS", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.TotalTPS.ToString("F2");
            }));
            _columns.Add(new StressColumn("Min Latency (ms)", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = string.Format("{0:0.0}", job.Results.MinLatencyMs);
            }));
            _columns.Add(new StressColumn("Avg Latency (ms)", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = string.Format("{0:0.0}", job.Results.AvgLatencyMs);
            }));
            _columns.Add(new StressColumn("Max Latency (ms)", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = string.Format("{0:0.0}", job.Results.MaxLatencyMs);
            }));
            _columns.Add(new StressColumn("Passes (30s)", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.RunningPasses30.ToString();
            }));
            _columns.Add(new StressColumn("Fails (30s)", false, false, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.Results.RunningFails30.ToString();
            }));
            _columns.Add(new StressColumn("Status", false, true, false, delegate(ListViewItem item, int subitem, StressJob job)
            {
                item.SubItems[subitem].Text = job.BaseNode.StressData.RunStatus.ToString();
            }));

            SyncColumns();
        }

        /// <summary>
        /// Syncs the columns to all displayables.
        /// </summary>
        protected void SyncColumns()
        {
            SyncColumnsListView();
            SyncColumnsToolStrip();
        }

        /// <summary>
        /// Syncs the columns that should be visible with the list view.
        /// </summary>
        protected void SyncColumnsListView()
        {
            // columns in the list view
            foreach (StressColumn col in _columns)
            {
                if (col.Visible)
                {
                    if (col.Header.ListView == null)
                    {
                        lstJobs.Columns.Add(col.Header);
                    }
                }
                else
                {
                    if (col.Header.ListView != null)
                    {
                        lstJobs.Columns.Remove(col.Header);
                    }
                }
            }

            // update sub items
            foreach (ListViewItem item in lstJobs.Items)
            {
                ReloadSubItems(item);
            }
        }

        /// <summary>
        /// Syncs the columns that should be visible with the toolstrip.
        /// </summary>
        protected void SyncColumnsToolStrip()
        {
            // remove items in the context menu
            int first = -1, second = -1;

            for (int i = 0; i < cmsColumns.Items.Count; ++i)
            {
                if (cmsColumns.Items[i] is ToolStripSeparator)
                {
                    if (first == -1) { first = i; }
                    else if (second == -1) { second = i; }
                }
            }

            for (int i = first + 1; i < second; ++i)
            {
                cmsColumns.Items.RemoveAt(first + 1);
            }

            // columns in the context menu
            foreach (StressColumn col in _columns)
            {
                if (col.Special)
                {
                    ToolStripMenuItem menuitem = new ToolStripMenuItem(col.Name);
                    menuitem.Checked = col.Visible;
                    menuitem.Enabled = !col.Required;
                    menuitem.Tag = col;
                    menuitem.Click += new EventHandler(ColumnMenuItemClick);

                    // sad but true...
                    if (col.Name == "Scale")
                    {
                        _scale_menu = menuitem;

                        if (_scheduler != null)
                        {
                            menuitem.Text = _scheduler.ScaleName;
                        }
                    }

                    cmsColumns.Items.Insert(++first, menuitem);
                }
            }
        }

        private void ColumnMenuItemClick(object sender, EventArgs args)
        {
            ToolStripMenuItem tsmi = ((ToolStripMenuItem)sender);
            bool ischecked = !tsmi.Checked;
            ((StressColumn)tsmi.Tag).Visible = ischecked;
            tsmi.Checked = ischecked;

            SyncColumnsListView();
        }

        #endregion

        protected List<TestNode> Roots = new List<TestNode>();
        protected StressJobList JobList = new StressJobList();
        protected Dictionary<string, float> JobScaleSettings = new Dictionary<string, float>();

        /// <summary>
        /// Adds jobs to the list view.  The individual node is the root, and a group is created for it.
        /// </summary>
        /// <param name="root">The root node.</param>
        /// <param name="jobs">The jobs to add.</param>
        protected void AddJobsToListView(TestNode root, List<StressJob> jobs)
        {
            lstJobs.BeginUpdate();

            try
            {
                // add the root group
                ListViewGroup group = new ListViewGroup(root.Name);
                group.Tag = root;
                lstJobs.Groups.Add(group);

                // add each job under that group
                foreach (StressJob sj in jobs)
                {
                    // if we have some scale settings loaded, apply them now
                    string temp = sj.BaseNode.FullName;

                    if (JobScaleSettings.ContainsKey(temp))
                    {
                        _scheduler.SetScaleValue(sj, JobScaleSettings[temp]);
                    }

                    // get the name out
                    int firstdot = temp.IndexOf('.');

                    ListViewItem item = new ListViewItem(
                        (firstdot == -1 || firstdot >= temp.Length - 2 ? temp : temp.Substring(firstdot + 1)), group);
                    item.BackColor = AlternatingBackColor;
                    item.Tag = sj;
                    ReloadSubItems(item);

                    lstJobs.Items.Add(item);
                }
            }
            finally
            {
                lstJobs.EndUpdate();
            }
        }

        protected void RemoveJobsFromListView(TestNode root)
        {
            lstJobs.BeginUpdate();

            try
            {
                // remove the group from the listview
                foreach (ListViewGroup g in lstJobs.Groups)
                {
                    if (g.Header==root.Name)
                    {
                        g.Items.Clear();
                        lstJobs.Groups.Remove(g);
                        break;
                    }
                }

                // remove the individual items from the listview's list
                System.Collections.Generic.List<ListViewItem> itemsToRemove=new System.Collections.Generic.List<ListViewItem>();
                foreach (ListViewItem lvi in lstJobs.Items)
                {
                    if (((StressJob)(lvi.Tag)).BaseNode.FullName.StartsWith(root.Name+"."))
                    {
                        itemsToRemove.Add(lvi);
                    }
                }

                foreach (ListViewItem lvi in itemsToRemove)
                {
                    lstJobs.Items.Remove(lvi);
                }
            }
            finally
            {
                lstJobs.EndUpdate();
            }
        }

        private int _backcolor = 0;

        protected Color AlternatingBackColor
        {
            get
            {
                int prev = Interlocked.Increment(ref _backcolor);
                if ((prev & 1) == 0)
                {
                    return Color.Gainsboro;
                }
                else
                {
                    return Color.LightGray;
                }
            }
        }

        /// <summary>
        /// Loads the subitems based on the columns that exist.
        /// </summary>
        /// <param name="item">The item to reload.</param>
        protected void ReloadSubItems (ListViewItem item)
        {
            // determine how many columns we will have
            int total_subitems = item.Group.ListView.Columns.Count;

            // get to this number of items
            while (item.SubItems.Count > total_subitems)
            {
                item.SubItems.RemoveAt(item.SubItems.Count - 1);
            }

            while (item.SubItems.Count < total_subitems)
            {
                item.SubItems.Add("");
            }

            // special case the scale column
            ReloadScaleColumnForItem(item);

            RefreshSubItems(item);
        }

        /// <summary>
        /// Reloads the scale column for a list item.
        /// </summary>
        /// <param name="item">The item to reload.</param>
        protected void ReloadScaleColumnForItem(ListViewItem item)
        {
            if (_scale_column.Visible)
            {
                item.SubItems[_scale_column.Header.Index].Text = 
                    _scheduler.GetScaleValue((StressJob)item.Tag).ToString();
            }
        }

        /// <summary>
        /// Refreshes the values in the item to match the test results.
        /// </summary>
        /// <param name="item">The item to refresh.</param>
        protected void RefreshSubItems(ListViewItem item)
        {
            StressJob sj = (StressJob) item.Tag;

            foreach (StressColumn sc in _columns)
            {
                if (sc.Visible && sc.Updatable)
                {
                    sc.UpdateItem(item, sc.Header.Index, sj);
                }
            }
        }

        /// <summary>
        /// True if a single job is selected, false otherwise.
        /// </summary>
        protected bool JobsSingleSelected
        {
            get { return (lstJobs.SelectedIndices.Count == 1); }
        }

        /// <summary>
        /// Applies the value in the scale box to the job.
        /// </summary>
        protected void ApplyTempScale(ListViewItem job, string val)
        {
            if (job == null)
            {
                return;
            }

            float f;

            if (float.TryParse(val, out f))
            {
                ChangeScale(job, f);
            }
            else
            {
                _report.Error("Unable to parse value '{0}' as a float", val);
            }
        }

        /// <summary>
        /// Applies the value to the job.
        /// </summary>
        protected void ChangeScale(ListViewItem job, float val)
        {
            if (job == null)
            {
                return;
            }

            _scheduler.SetScaleValue((StressJob)job.Tag, val);
            SetScaleTagAndText(val.ToString());
            ReloadScaleColumnForItem(job);
        }
        
        /// <summary>
        /// Updates the details pane based on the items that are selected in the job list.
        /// </summary>
        protected void UpdateDetailsPane()
        {
            int count = lstJobs.SelectedIndices.Count;

            // reset everything to empty
            if (count == 0)
            {
                lblTests.Text = "-";

                lblPass.Text = "-";
                lblFail.Text = "-";
                lblDeadlock.Text = "-";
                lblSkip.Text = "-";
                lblRate.Text = "-";

                lblInProgress.Text = "-";
                lblThreads.Text = "-";

                lblTPS_5.Text = "-";
                lblTPS_20.Text = "-";
                lblTPS_120.Text = "-";
                lblPrivateTPS.Text = "-";
                lblTotalTPS.Text = "-";
            }
            else if (count == 1)
            {
                StressJob job = (StressJob) lstJobs.SelectedItems[0].Tag;
                TestResult tr = job.Results;

                lblTests.Text = job.BaseNode.Name;

                lblPass.Text = tr.Passed.ToString();
                lblFail.Text = tr.Failed.ToString();
                lblDeadlock.Text = tr.Deadlocked.ToString();
                lblSkip.Text = tr.Skipped.ToString();
                lblRate.Text = (tr.PassRate * 100).ToString("F2") + "%";

                lblInProgress.Text = tr.InProgress.ToString();
                lblThreads.Text = tr.Threads.ToString();

                lblTPS_5.Text = tr.RunningShortTPS.ToString("F2");
                lblTPS_20.Text = tr.RunningTPS.ToString("F2");
                lblTPS_120.Text = tr.RunningTPS120.ToString("F2");
                lblPrivateTPS.Text = tr.RunningPrivateTPS.ToString("F2");
                lblTotalTPS.Text = tr.TotalTPS.ToString("F2");
            }
            else
            {
                ListView.SelectedListViewItemCollection sel = lstJobs.SelectedItems;

                lblTests.Text = sel.Count.ToString() + " tests";

                int pass = 0, fail = 0, deadlock = 0, skip = 0, inprogress = 0, threads = 0;
                float tps5 = 0f, tps20 = 0f, tps120 = 0f, privatetps = 0f, totaltps = 0f;

                foreach (ListViewItem lvi in sel)
                {
                    TestResult tr = ((StressJob)lvi.Tag).Results;

                    pass += tr.Passed;
                    fail += tr.Failed;
                    deadlock += tr.Deadlocked;
                    skip += tr.Skipped;

                    inprogress += tr.InProgress;
                    threads += tr.Threads;

                    tps5 += tr.RunningShortTPS;
                    tps20 += tr.RunningTPS;
                    tps120 += tr.RunningTPS120;
                    privatetps += tr.RunningPrivateTPS;
                    totaltps += tr.TotalTPS;
                }

                int total = pass + fail + deadlock;

                lblPass.Text = pass.ToString();
                lblFail.Text = fail.ToString();
                lblDeadlock.Text = deadlock.ToString();
                lblSkip.Text = skip.ToString();
                lblRate.Text = ((total == 0 ? 0.0 : ((double) pass) / total) * 100).ToString("F2") + "%";

                lblInProgress.Text = inprogress.ToString();
                lblThreads.Text = threads.ToString();

                lblTPS_5.Text = tps5.ToString("F2");
                lblTPS_20.Text = tps20.ToString("F2");
                lblTPS_120.Text = tps120.ToString("F2");
                lblPrivateTPS.Text = privatetps.ToString("F2");
                lblTotalTPS.Text = totaltps.ToString("F2");
            }
        }

        /// <summary>
        /// Sets both the tag and the text values of the scale textbox.
        /// Use this to 'reset' the text box to a non-temp value.
        /// </summary>
        /// <param name="val">The value to set.</param>
        private void SetScaleTagAndText(string val)
        {
            txtScale.Tag = val;
            txtScale.Text = val;
        }

        /// <summary>
        /// Updates (creating if needed) the state of all perf counters.
        /// </summary>
        private void UpdatePerfCounters()
        {
            try
            {
                //for each test suite, recreate its category
                //if we made any at all, call it good for this update (due to buggy o/s delays with the actual creation)
                bool didCatCreate=false;
                lock (Roots)
                {
                    foreach (TestNode root in Roots)
                    {
                        //if we haven't done this suite yet, wipe old cat for it and recreate it
                        object didSuiteCreate=root.GetContextData("StressPlugin Perf Counters Initialized");
                        if (didSuiteCreate==null || !(bool)didSuiteCreate)
                        {
                            didCatCreate=true;

                            try
                            {
                                PerformanceCounterCategory.Delete("STFTests."+root.Name);
                            }
                            catch (Exception) //we don't care if delete fails; it probably doesn't exist then which is good
                            {
                            }

                            //create the category and all counters
                            CounterCreationDataCollection catCollection=new CounterCreationDataCollection();

                            CounterCreationData ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.RateOfCountsPerSecond32;
                            ccd.CounterName="TPS";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.RateOfCountsPerSecond32;
                            ccd.CounterName="Pass Per Second";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.RateOfCountsPerSecond32;
                            ccd.CounterName="Fail Per Second";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.NumberOfItems64;
                            ccd.CounterName="Pass Total";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.NumberOfItems64;
                            ccd.CounterName="Fail Total";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.NumberOfItems32;
                            ccd.CounterName="Min Latency (ms)";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.NumberOfItems32;
                            ccd.CounterName="Avg Latency (ms)";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.NumberOfItems32;
                            ccd.CounterName="Max Latency (ms)";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.NumberOfItems32;
                            ccd.CounterName="Threads Used";
                            catCollection.Add(ccd);

                            ccd=new CounterCreationData();
                            ccd.CounterType=PerformanceCounterType.NumberOfItems32;
                            ccd.CounterName="Number In Progress";
                            catCollection.Add(ccd);

                            PerformanceCounterCategory.Create("STFTests."+root.Name,
                                                              "Stress counters for test suite "+root.Name,
                                                              PerformanceCounterCategoryType.MultiInstance,
                                                              catCollection);

                            root.SetContextData("StressPlugin Perf Counters Initialized", true);
                        }
                    }
                }
                
                if (didCatCreate)
                {
                    return;
                }

                //update the counters for each job
                foreach (StressJob job in JobList)
                {
                    int dotInd=job.BaseNode.FullName.IndexOf('.');
                    string suiteName=job.BaseNode.FullName.Substring(0,dotInd);
                    string instName=job.BaseNode.FullName.Substring(dotInd+1, job.BaseNode.FullName.Length-suiteName.Length-1);

                    PerformanceCounter cnt=new PerformanceCounter("STFTests."+suiteName, "TPS", instName, false);
                    cnt.RawValue=job.Results.Total;

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Pass Per Second", instName, false);
                    cnt.RawValue=job.Results.Passed;

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Fail Per Second", instName, false);
                    cnt.RawValue=job.Results.Failed;

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Pass Total", instName, false);
                    cnt.RawValue=job.Results.Passed;

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Fail Total", instName, false);
                    cnt.RawValue=job.Results.Failed;

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Min Latency (ms)", instName, false);
                    cnt.RawValue=(int)(job.Results.MinLatencyMs+0.5f);

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Avg Latency (ms)", instName, false);
                    cnt.RawValue=(int)(job.Results.AvgLatencyMs+0.5f);

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Max Latency (ms)", instName, false);
                    cnt.RawValue=(int)(job.Results.MaxLatencyMs+0.5f);

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Threads Used", instName, false);
                    cnt.RawValue=job.Results.Threads;

                    cnt=new PerformanceCounter("STFTests."+suiteName, "Number In Progress", instName, false);
                    cnt.RawValue=job.Results.InProgress;
                }
            }
            catch (Exception e)
            {
                Report.Error("Unexpected Exception in Stress Plugin's UpdatePerfCounters: "+e);
            }
        }

        #endregion

        #region Not Used

        /// <summary>
        /// Empties out the list view control of jobs.
        /// </summary>
        protected void ClearJobsListView()
        {
            lstJobs.Items.Clear();
            lstJobs.Groups.Clear();
        }

        /// <summary>
        /// Recreates the job list from scratch.
        /// </summary>
        protected void ReloadJobList()
        {
            JobList = new StressJobList();

            foreach (TestNode node in Roots)
            {
                AddJobsToListView(node, JobList.AddNode(node));
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\WireDataFuzzer\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\WireDataFuzzer\WireFuzzPlugin.cs ===
using System;
using System.Windows.Forms;

using ServerTestFramework;

namespace STFGui.Plugins
{
    /// <summary>
    /// WireData fuzzer plugin
    /// </summary>
    public class WireDataFuzzerPlugin: STFGui.Plugins.IPluginGui
    {
        //Returns the TabPage to add to the gui.
        public TabPage GetNewTabPage()
        {
            ServerTestFramework.Utilities.WireDataFuzzForm f=new ServerTestFramework.Utilities.WireDataFuzzForm();
            TabPage page=f.GetMyTabPage();
            page.Text="WireDataFuzzer";

            return page;
        }

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public MenuItem GetNewMenu ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\WireDataFuzzer\WireDataFuzzForm.Designer.cs ===
using System.Windows.Forms;

namespace ServerTestFramework.Utilities
{
    partial class WireDataFuzzForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose ( bool disposing )
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            this.components = new System.ComponentModel.Container();
            this.tip = new System.Windows.Forms.ToolTip(this.components);
            this.SelectAll = new System.Windows.Forms.Button();
            this.checkOverallFuzz = new System.Windows.Forms.CheckBox();
            this.button1 = new System.Windows.Forms.Button();
            this.saveFileDialog1 = new System.Windows.Forms.SaveFileDialog();
            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.button_LoadConfig = new System.Windows.Forms.Button();
            this.button_SaveConfig = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.button_FuzzToggle = new System.Windows.Forms.Button();
            this.checkedListBoxDerivedClasses = new System.Windows.Forms.CheckedListBox();
            this.button7 = new System.Windows.Forms.Button();
            this.label4 = new System.Windows.Forms.Label();
            this.comboNamespaces = new System.Windows.Forms.ComboBox();
            this.panel1 = new System.Windows.Forms.Panel();
            this.label3 = new System.Windows.Forms.Label();
            this.labelClassCount = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage2.SuspendLayout();
            this.panel1.SuspendLayout();
            this.tabControl1.SuspendLayout();
            this.SuspendLayout();
            // 
            // SelectAll
            // 
            this.SelectAll.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.SelectAll.Location = new System.Drawing.Point(153, 397);
            this.SelectAll.Name = "SelectAll";
            this.SelectAll.Size = new System.Drawing.Size(75, 20);
            this.SelectAll.TabIndex = 16;
            this.SelectAll.Text = "Select All";
            this.tip.SetToolTip(this.SelectAll, "Goes through all derived classes and turns fuzzing on in each one\'s FuzzDataAttri" +
                    "bute.");
            this.SelectAll.UseVisualStyleBackColor = true;
            this.SelectAll.Click += new System.EventHandler(this.button1_Unclick);
            // 
            // checkOverallFuzz
            // 
            this.checkOverallFuzz.AccessibleDescription = "";
            this.checkOverallFuzz.AutoSize = true;
            this.checkOverallFuzz.BackColor = System.Drawing.Color.Transparent;
            this.checkOverallFuzz.Location = new System.Drawing.Point(6, 6);
            this.checkOverallFuzz.Name = "checkOverallFuzz";
            this.checkOverallFuzz.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.checkOverallFuzz.Size = new System.Drawing.Size(104, 17);
            this.checkOverallFuzz.TabIndex = 12;
            this.checkOverallFuzz.Text = "Fuzzing Enabled";
            this.tip.SetToolTip(this.checkOverallFuzz, "Toggles fuzzing for ALL classes derived from WireData.");
            this.checkOverallFuzz.UseVisualStyleBackColor = false;
            this.checkOverallFuzz.CheckedChanged += new System.EventHandler(this.checkOverallFuzz_CheckedChanged);
            // 
            // button1
            // 
            this.button1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.button1.Location = new System.Drawing.Point(153, 418);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(75, 20);
            this.button1.TabIndex = 24;
            this.button1.Text = "Clear All";
            this.tip.SetToolTip(this.button1, "Goes through all derived classes and turns fuzzing off in each one\'s FuzzDataAttr" +
                    "ibute.");
            this.button1.UseVisualStyleBackColor = true;
            // 
            // saveFileDialog1
            // 
            this.saveFileDialog1.DefaultExt = "FCD";
            this.saveFileDialog1.Filter = "Fuzz Config Data|*.FCD";
            this.saveFileDialog1.RestoreDirectory = true;
            this.saveFileDialog1.SupportMultiDottedExtensions = true;
            // 
            // openFileDialog1
            // 
            this.openFileDialog1.FileName = "openFileDialog1";
            this.openFileDialog1.Filter = "Fuzz Config Data|*.FCD";
            this.openFileDialog1.RestoreDirectory = true;
            // 
            // tabPage2
            // 
            this.tabPage2.Controls.Add(this.button1);
            this.tabPage2.Controls.Add(this.checkOverallFuzz);
            this.tabPage2.Controls.Add(this.button_LoadConfig);
            this.tabPage2.Controls.Add(this.button_SaveConfig);
            this.tabPage2.Controls.Add(this.label1);
            this.tabPage2.Controls.Add(this.button_FuzzToggle);
            this.tabPage2.Controls.Add(this.checkedListBoxDerivedClasses);
            this.tabPage2.Controls.Add(this.button7);
            this.tabPage2.Controls.Add(this.label4);
            this.tabPage2.Controls.Add(this.comboNamespaces);
            this.tabPage2.Controls.Add(this.panel1);
            this.tabPage2.Controls.Add(this.labelClassCount);
            this.tabPage2.Controls.Add(this.SelectAll);
            this.tabPage2.Controls.Add(this.label2);
            this.tabPage2.Location = new System.Drawing.Point(4, 22);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage2.Size = new System.Drawing.Size(732, 438);
            this.tabPage2.TabIndex = 1;
            this.tabPage2.Text = "tabPage2";
            this.tabPage2.UseVisualStyleBackColor = true;
            // 
            // button_LoadConfig
            // 
            this.button_LoadConfig.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.button_LoadConfig.Location = new System.Drawing.Point(74, 418);
            this.button_LoadConfig.Name = "button_LoadConfig";
            this.button_LoadConfig.Size = new System.Drawing.Size(62, 20);
            this.button_LoadConfig.TabIndex = 23;
            this.button_LoadConfig.Text = "Load";
            this.button_LoadConfig.UseVisualStyleBackColor = true;
            this.button_LoadConfig.Click += new System.EventHandler(this.button_LoadConfig_Click);
            // 
            // button_SaveConfig
            // 
            this.button_SaveConfig.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.button_SaveConfig.Location = new System.Drawing.Point(74, 397);
            this.button_SaveConfig.Name = "button_SaveConfig";
            this.button_SaveConfig.Size = new System.Drawing.Size(62, 20);
            this.button_SaveConfig.TabIndex = 22;
            this.button_SaveConfig.Text = "Save";
            this.button_SaveConfig.UseVisualStyleBackColor = true;
            this.button_SaveConfig.Click += new System.EventHandler(this.button_SaveConfig_Click);
            // 
            // label1
            // 
            this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.label1.AutoSize = true;
            this.label1.BackColor = System.Drawing.Color.Transparent;
            this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label1.Location = new System.Drawing.Point(-1, 411);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(40, 13);
            this.label1.TabIndex = 11;
            this.label1.Text = "Total:";
            // 
            // button_FuzzToggle
            // 
            this.button_FuzzToggle.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.button_FuzzToggle.Location = new System.Drawing.Point(655, 2);
            this.button_FuzzToggle.Name = "button_FuzzToggle";
            this.button_FuzzToggle.Size = new System.Drawing.Size(71, 23);
            this.button_FuzzToggle.TabIndex = 21;
            this.button_FuzzToggle.Text = "Toggle All";
            this.button_FuzzToggle.UseVisualStyleBackColor = true;
            this.button_FuzzToggle.Click += new System.EventHandler(this.button_FuzzToggle_Click);
            // 
            // checkedListBoxDerivedClasses
            // 
            this.checkedListBoxDerivedClasses.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)));
            this.checkedListBoxDerivedClasses.FormattingEnabled = true;
            this.checkedListBoxDerivedClasses.IntegralHeight = false;
            this.checkedListBoxDerivedClasses.Location = new System.Drawing.Point(3, 57);
            this.checkedListBoxDerivedClasses.Name = "checkedListBoxDerivedClasses";
            this.checkedListBoxDerivedClasses.ScrollAlwaysVisible = true;
            this.checkedListBoxDerivedClasses.Size = new System.Drawing.Size(284, 334);
            this.checkedListBoxDerivedClasses.Sorted = true;
            this.checkedListBoxDerivedClasses.TabIndex = 0;
            this.checkedListBoxDerivedClasses.SelectedIndexChanged += new System.EventHandler(this.checkedListBoxDerivedClasses_SelectedIndexChanged);
            this.checkedListBoxDerivedClasses.ItemCheck += new System.Windows.Forms.ItemCheckEventHandler(this.checkedListBoxDerivedClasses_ItemCheck);
            // 
            // button7
            // 
            this.button7.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.button7.Location = new System.Drawing.Point(580, 403);
            this.button7.Name = "button7";
            this.button7.Size = new System.Drawing.Size(146, 27);
            this.button7.TabIndex = 8;
            this.button7.Text = "Apply";
            this.button7.UseVisualStyleBackColor = true;
            this.button7.Click += new System.EventHandler(this.button7_Click);
            // 
            // label4
            // 
            this.label4.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.label4.AutoSize = true;
            this.label4.BackColor = System.Drawing.Color.Transparent;
            this.label4.Location = new System.Drawing.Point(290, 12);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(82, 13);
            this.label4.TabIndex = 18;
            this.label4.Text = "Fuzzable Fields:";
            // 
            // comboNamespaces
            // 
            this.comboNamespaces.DropDownHeight = 350;
            this.comboNamespaces.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.comboNamespaces.FormattingEnabled = true;
            this.comboNamespaces.IntegralHeight = false;
            this.comboNamespaces.Location = new System.Drawing.Point(3, 29);
            this.comboNamespaces.Name = "comboNamespaces";
            this.comboNamespaces.Size = new System.Drawing.Size(284, 21);
            this.comboNamespaces.Sorted = true;
            this.comboNamespaces.TabIndex = 9;
            this.comboNamespaces.SelectedIndexChanged += new System.EventHandler(this.comboNamespaces_SelectedIndexChanged);
            // 
            // panel1
            // 
            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.panel1.AutoScroll = true;
            this.panel1.BackColor = System.Drawing.SystemColors.Control;
            this.panel1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.panel1.Controls.Add(this.label3);
            this.panel1.Location = new System.Drawing.Point(293, 29);
            this.panel1.Name = "panel1";
            this.panel1.Size = new System.Drawing.Size(438, 364);
            this.panel1.TabIndex = 1;
            // 
            // label3
            // 
            this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(33, 340);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(35, 13);
            this.label3.TabIndex = 17;
            this.label3.Text = "label3";
            // 
            // labelClassCount
            // 
            this.labelClassCount.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.labelClassCount.AutoSize = true;
            this.labelClassCount.BackColor = System.Drawing.Color.Transparent;
            this.labelClassCount.Location = new System.Drawing.Point(36, 411);
            this.labelClassCount.Name = "labelClassCount";
            this.labelClassCount.Size = new System.Drawing.Size(13, 13);
            this.labelClassCount.TabIndex = 10;
            this.labelClassCount.Text = "0";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.BackColor = System.Drawing.Color.Transparent;
            this.label2.Location = new System.Drawing.Point(281, 7);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(40, 13);
            this.label2.TabIndex = 15;
            this.label2.Text = "           ";
            this.label2.Click += new System.EventHandler(this.label2_Click);
            // 
            // tabControl1
            // 
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tabControl1.Location = new System.Drawing.Point(0, 0);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(740, 464);
            this.tabControl1.TabIndex = 24;
            // 
            // WireDataFuzzForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;
            this.ClientSize = new System.Drawing.Size(740, 464);
            this.Controls.Add(this.tabControl1);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "WireDataFuzzForm";
            this.ShowIcon = false;
            this.ShowInTaskbar = false;
            this.Text = "WireData Fuzzing";
            this.Load += new System.EventHandler(this.WireDataFuzzForm_Load);
            this.tabPage2.ResumeLayout(false);
            this.tabPage2.PerformLayout();
            this.panel1.ResumeLayout(false);
            this.panel1.PerformLayout();
            this.tabControl1.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private ToolTip tip;
        private SaveFileDialog saveFileDialog1;
        private OpenFileDialog openFileDialog1;
        private TabPage tabPage2;
        private CheckBox checkOverallFuzz;
        private Button button_LoadConfig;
        private Label label3;
        private Button button_SaveConfig;
        private Label label1;
        private Button button_FuzzToggle;
        private CheckedListBox checkedListBoxDerivedClasses;
        private Button button7;
        private Label label4;
        private ComboBox comboNamespaces;
        private Panel panel1;
        private Label labelClassCount;
        private Button SelectAll;
        private Label label2;
        private TabControl tabControl1;
        private Button button1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_storagetestui_none_12.4.56.0_none_317a183785f6555e
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=storagetestui
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724.manifest
XP_MANIFEST_PATH=manifests\msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724.cat
XP_CATALOG_PATH=manifests\msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724.cat
XP_PAYLOAD_PATH=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=storagetestui,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\Program.cs ===
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace StorageTestUI
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\Form1.Designer.cs ===
namespace StorageTestUI
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.richTextBox1 = new System.Windows.Forms.RichTextBox();
            this.button2 = new System.Windows.Forms.Button();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.button1 = new System.Windows.Forms.Button();
            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            this.button3 = new System.Windows.Forms.Button();
            this.label2 = new System.Windows.Forms.Label();
            this.label1 = new System.Windows.Forms.Label();
            this.textBox3 = new System.Windows.Forms.TextBox();
            this.textBox2 = new System.Windows.Forms.TextBox();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.SuspendLayout();
            // 
            // richTextBox1
            // 
            this.richTextBox1.Location = new System.Drawing.Point(156, 85);
            this.richTextBox1.Name = "richTextBox1";
            this.richTextBox1.Size = new System.Drawing.Size(386, 100);
            this.richTextBox1.TabIndex = 10;
            this.richTextBox1.Text = "";
            // 
            // button2
            // 
            this.button2.Location = new System.Drawing.Point(32, 85);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(108, 23);
            this.button2.TabIndex = 9;
            this.button2.Text = "Write to storage";
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.button2_Click_1);
            // 
            // pictureBox1
            // 
            this.pictureBox1.Location = new System.Drawing.Point(32, 212);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(949, 602);
            this.pictureBox1.TabIndex = 8;
            this.pictureBox1.TabStop = false;
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(32, 30);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(208, 20);
            this.textBox1.TabIndex = 7;
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(267, 30);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(56, 20);
            this.button1.TabIndex = 6;
            this.button1.Text = "Browse";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Click += new System.EventHandler(this.button1_Click);
            // 
            // openFileDialog1
            // 
            this.openFileDialog1.FileName = "openFileDialog1";
            // 
            // button3
            // 
            this.button3.Location = new System.Drawing.Point(32, 123);
            this.button3.Name = "button3";
            this.button3.Size = new System.Drawing.Size(108, 25);
            this.button3.TabIndex = 11;
            this.button3.Text = "Read from storage";
            this.button3.UseVisualStyleBackColor = true;
            this.button3.Click += new System.EventHandler(this.button3_Click);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(567, 137);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(51, 13);
            this.label2.TabIndex = 19;
            this.label2.Text = "FileName";
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(567, 83);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(71, 13);
            this.label1.TabIndex = 18;
            this.label1.Text = "NPDB Server";
            // 
            // textBox3
            // 
            this.textBox3.Location = new System.Drawing.Point(570, 99);
            this.textBox3.Name = "textBox3";
            this.textBox3.Size = new System.Drawing.Size(122, 20);
            this.textBox3.TabIndex = 17;
            this.textBox3.Text = "65.52.235.58";
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(570, 153);
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(122, 20);
            this.textBox2.TabIndex = 16;
            this.textBox2.Text = "avatar-body.png";
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(1026, 855);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.textBox3);
            this.Controls.Add(this.textBox2);
            this.Controls.Add(this.button3);
            this.Controls.Add(this.richTextBox1);
            this.Controls.Add(this.button2);
            this.Controls.Add(this.pictureBox1);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.button1);
            this.Name = "Form1";
            this.Text = "Form1";
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.RichTextBox richTextBox1;
        private System.Windows.Forms.Button button2;
        private System.Windows.Forms.PictureBox pictureBox1;
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.Button button1;
        private System.Windows.Forms.OpenFileDialog openFileDialog1;
        private System.Windows.Forms.Button button3;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox textBox3;
        private System.Windows.Forms.TextBox textBox2;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_storagetestui_none_12.4.56.0_none_317a183785f6555e
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=storagetestui
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724.manifest
XP_MANIFEST_PATH=manifests\msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724.cat
XP_CATALOG_PATH=manifests\msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724.cat
XP_PAYLOAD_PATH=msil_storagetestui_no-public-key_12.4.56.0_x-ww_f3b77724
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=storagetestui,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\WireDataFuzzer\WireDataFuzzForm.cs ===
using System;
using System.IO;
using System.Xml;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Reflection;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Utilities
{
    public partial class WireDataFuzzForm : Form
    {
        // Array of types that are currently going to be
        // displayed in the checklistbox
        private Dictionary<string, List<Type>> MasterTypeCache;
        private List<FuzzAttribDisplay> CurrentFields;
        private Hashtable fieldCache;
        OpenFileDialog ofd;

        public WireDataFuzzForm ()
        {
            InitializeComponent();
            WireDataFuzzForm_Load(null,null);
        }

        public TabPage GetMyTabPage()
        {
            return tabControl1.TabPages[0];
        }
       
        private void WireDataFuzzForm_Load ( object sender, EventArgs e )
        {
            BuildMasterTypeCache(typeof(WireData));
            fieldCache = WireData.GetFieldCache();
            PopulateNamespaceList();
            CurrentFields = new List<FuzzAttribDisplay>();
            ofd = new OpenFileDialog();
            checkOverallFuzz.Checked = WireData.Fuzz;

            // Hook the close method to hide instead
            this.Closing += new CancelEventHandler(this.FuzzForm_Closing);
        }

        //
        // Utitlity functions
        // 
        /// <summary>
        /// Builds the internal structure to keep track of all the classes and namespaces
        /// that derive in some way from the baseClass you pass in. This structure is 
        /// later used to do list population and is private to the form.
        /// </summary>
        /// <param name="baseClass">The base class from which you want the derived types.</param>
        private void BuildMasterTypeCache ( Type baseClass )
        {
            MasterTypeCache = new Dictionary<string, List<Type>>();
            List<Type> typeList = new List<Type>();

            ReflectionUtils.GetDerivedTypes(typeList, typeof(WireData));

            // Loop through all of the types and pull out the specific
            // information we are looking for.
            foreach (Type currentType in typeList)
            {
                // Safety check, shouldn't ever happen.
                if (currentType.BaseType == null)
                    continue;

                // If the namespace isn't in the MasterTypeCache, add it
                // and then add the current type to that namespaces
                // list of classes.
                if (!MasterTypeCache.ContainsKey(currentType.Namespace))
                {
                    MasterTypeCache.Add(currentType.Namespace, new List<Type>());
                }
                MasterTypeCache[currentType.Namespace].Add(currentType);
            }
        }

        /// <summary>
        /// Uses the master cache member that was populated on form create
        /// looks through the master cache and fills in the pulldown menu with
        /// the list of appropriate namespaces and an extra item for ALL
        /// </summary>
        /// <param name="myForm"></param>
        public void PopulateNamespaceList ()
        {
            comboNamespaces.Items.Add("All Namespaces");
            foreach (KeyValuePair<string, List<Type>> namespaceKey in MasterTypeCache)
            {
                comboNamespaces.Items.Add(namespaceKey.Key);
            }
        }

        /// <summary>
        /// Uses the master cache member to populate the checklistbox with
        /// the names of the classes that are covered under tha passed in
        /// namespace.
        ///  
        /// If the namespace passed in it "All Namespaces" then it displays
        /// all of them.
        /// </summary>
        /// <param name="szNamespace"></param>
        public void PopulateClassList ( string szNamespace )
        {
            if (szNamespace == "All Namespaces")
            {
                // Loop through and add all of the classes for each namespace to the checkbox
                foreach (KeyValuePair<string, List<Type>> NameSpacePair in MasterTypeCache)
                {
                    List<Type> typeList = MasterTypeCache[NameSpacePair.Key];
                    foreach (Type type in typeList)
                    {
                        try
                        {
                            WireData.FieldCache fc = WireData.GetFieldCacheLine(type);
                            if (fc == null)
                                continue;
                            checkedListBoxDerivedClasses.Items.Add(type.Name, fc.FuzzClass);
                        }
                        catch (Exception omg)
                        {
                            Global.RO.Warn("Unexpected exception: "+omg);
                        }
                    }
                }
            }
            else
            {
                // Only add the classes that fall under the specific namespace
                // passed in.
                List<Type> typeList = MasterTypeCache[szNamespace];
                foreach (Type type in typeList)
                {
                    WireData.FieldCache fc = WireData.GetFieldCacheLine(type);
                    if (fc == null)
                        continue;
                    checkedListBoxDerivedClasses.Items.Add(type.Name, fc.FuzzClass);
                }
            }
            // Update the total class count.
            labelClassCount.Text = checkedListBoxDerivedClasses.Items.Count.ToString();
        }

        /// <summary>
        /// Helper function used to add a new default panel to the member lists. This will
        /// init all the pieces, and handle getting everything lined up.
        /// </summary>
        /// <param name="panel">Parent Panel</param>
        /// <param name="fi">Field info to be filled in.</param>
        /// <param name="fda">FuzzDataAttribute associated with that field.</param>
        /// <param name="yPos">Location in the Y direction to place the new panel.</param>
        private void AddNewField ( Panel panel, FieldInfo fi, FuzzDataAttribute fda, int yPos )
        {
            FuzzAttribDisplay FuzzDisplay = new FuzzAttribDisplay(panel, fi, fda, yPos);
            CurrentFields.Add(FuzzDisplay);
        }
        

        /// <summary>
        /// Handles changes to the namespace pulldown box. This will automatically
        /// repopulate the class list box with the new classes within the selected
        /// namespace.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void comboNamespaces_SelectedIndexChanged ( object sender, EventArgs e )
        {
            CurrentFields.Clear();
            panel1.Controls.Clear();

            checkedListBoxDerivedClasses.BeginUpdate();
            checkedListBoxDerivedClasses.Items.Clear();
            // Get the list of classes from the master cache
            PopulateClassList(comboNamespaces.GetItemText(comboNamespaces.SelectedItem));
            checkedListBoxDerivedClasses.EndUpdate();
        }
        //
        // End Utitlity functions
        // 

        //
        // Control handlers
        //

        /// <summary>
        /// Takes care of updating the main field panel when a new class is chosen. 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void checkedListBoxDerivedClasses_SelectedIndexChanged ( object sender, EventArgs e )
        {
            int tempPanelHeight = panel1.Height;
            panel1.Height = 0;

            while (panel1.Controls.Count > 0)
            {
                KillControl(panel1.Controls[0]);
            }
            foreach (FuzzAttribDisplay fad in CurrentFields)
            {
                fad.Dispose();
            }
            CurrentFields.Clear();

            if (checkedListBoxDerivedClasses.SelectedIndex>=0 && checkedListBoxDerivedClasses.GetItemChecked(checkedListBoxDerivedClasses.SelectedIndex))
            {
                updateFieldsList();
            }
            
            panel1.Height = tempPanelHeight;
        }

        private void updateFieldsList ()
        {
            int yPos = 2;
            List<Type> typeList = null;

            // Handle populating the field list.
            if (comboNamespaces.GetItemText(comboNamespaces.SelectedItem) == "All Namespaces")
            {
                foreach (KeyValuePair<string, List<Type>> kvPair in MasterTypeCache)
                {
                    foreach (Type type in kvPair.Value)
                    {
                        if (type.Name == checkedListBoxDerivedClasses.GetItemText(checkedListBoxDerivedClasses.SelectedItem))
                        {
                            typeList = MasterTypeCache[type.Namespace];
                        }
                    }
                }
            }
            else
            {
                typeList = MasterTypeCache[comboNamespaces.GetItemText(comboNamespaces.SelectedItem)];
            }

            foreach (Type type in typeList)
            {
                if (type.Name == checkedListBoxDerivedClasses.GetItemText(checkedListBoxDerivedClasses.SelectedItem))
                {
                    WireData.FieldCache fc = null;

                    fc = WireData.GetFieldCacheLine(type);

                    if (fc == null)
                    {
                        continue;
                    }
                    fc.FuzzClass = checkedListBoxDerivedClasses.GetItemChecked(checkedListBoxDerivedClasses.SelectedIndex);

                    // If the class has no fields let the user know.
                    if (fc.Fields.Length == 0)
                    {
                        Label NoFields = new Label();
                        NoFields.AutoSize = true;
                        NoFields.Font = new Font("Courier", 11);
                        NoFields.Text = "   No Fields Exist for Currently Selected Class.";
                        NoFields.Location = new Point(4, 10);
                        panel1.Controls.Add(NoFields);
                    }

                    for (int i = 0; i < fc.Fields.Length; i++)
                    {
                        if (!fc.WireInfo[i].Serialize)
                        {
                            continue;
                        }

                        if (fc.FuzzInfo[i] == null)
                            fc.CreateFuzzData(i);
                        AddNewField(panel1, fc.Fields[i], fc.FuzzInfo[i], yPos);
                        yPos += CurrentFields[CurrentFields.Count - 1].GetHeight() + 2;
                    }
                    break;
                }
            }
        }

        // APPLY button, this loops through all the Attrib Displays currently in 
        // the main panel and updated the ifo within wiredatas field cache.
        private void button7_Click ( object sender, EventArgs e )
        {
            foreach (FuzzAttribDisplay fa in CurrentFields)
            {

                // Loop through all the controls on the form that have a tag value associated.
                // If the value cannot be parsed to the correct type, kick up a failure 
                // message box, and do not continue to writing.
                for (int i = 0; i < fa._thisPanel.Controls.Count; i++)
                {
                   if (fa._thisPanel.Controls[i].Tag != null)
                    {
                        FuzzAttribChildPair facp = (FuzzAttribChildPair)((Control)fa._thisPanel.Controls[i]).Tag;

                        if (fa._thisPanel.Controls[i].GetType() == typeof(TextBox))
                        {
                            string szText = ((TextBox)fa._thisPanel.Controls[i]).Text;
                            
                            // no point in doing a check if there is no data there.
                            if (szText == "")
                                continue;

                            bool goodAnswer = true;
                            switch (facp.fieldInfo.FieldType.Name)
                            {
                                case "Int16":
                                    Int16 tempInt16 = 0;
                                    goodAnswer = Int16.TryParse(szText, out tempInt16);
                                    break;
                                case "Int32":
                                    Int32 tempInt32 = 0;
                                    goodAnswer = Int32.TryParse(szText, out tempInt32);
                                    break;
                                case "Int64":
                                    Int64 tempInt64 = 0;
                                    goodAnswer = Int64.TryParse(szText, out tempInt64);
                                    break;
                                case "UInt16":
                                    UInt16 tempUInt16 = 0;
                                    goodAnswer = UInt16.TryParse(szText, out tempUInt16);
                                    break;
                                case "UInt32":
                                    UInt32 tempUInt32 = 0;
                                    goodAnswer = UInt32.TryParse(szText, out tempUInt32);
                                    break;
                                case "UInt64":
                                    UInt64 tempUInt64 = 0;
                                    goodAnswer = UInt64.TryParse(szText, out tempUInt64);
                                    break;
                                case "Double":
                                    Double tempDouble = 0;
                                    goodAnswer = Double.TryParse(szText, out tempDouble);
                                    break;
                            };

                            if (!goodAnswer && szText != "")
                            {
                                MessageBox.Show("Bad Value: " + fa._thisPanel.Controls[i].Name + " : " + facp.fieldInfo.Name);
                                return;
                            }
                        }
                    }
                }


                // Loop through all the commands on the panel, if it has a tag associated with it
                // that means we specifically set it up to write back to the fuzzdataattribute
                // Take that value and set it in the attribute. We need to switch on the type to 
                // allow type casting to the correct type.
                for (int i = 0; i < fa._thisPanel.Controls.Count; i++)
                {
                    if (!fa._thisPanel.Controls[i].Enabled)
                        continue;

                    if (fa._thisPanel.Controls[i].Tag != null)
                    {
                        FuzzAttribChildPair facp = (FuzzAttribChildPair)((Control)fa._thisPanel.Controls[i]).Tag;
                        string szText = "";

                        if (fa._thisPanel.Controls[i].GetType() == typeof(TextBox))
                        {
                            szText = ((TextBox)fa._thisPanel.Controls[i]).Text;
                            if (szText == "")
                                continue;
                        }

                        switch (facp.fieldInfo.FieldType.Name)
                        {
                            case "Int16":
                                facp.fieldInfo.SetValue(facp.fuzzAttribute, Convert.ToInt16(szText));
                                break;
                            case "int":
                            case "Int32":
                                facp.fieldInfo.SetValue(facp.fuzzAttribute, Convert.ToInt32(szText));
                                break;
                            case "Int64":
                                facp.fieldInfo.SetValue(facp.fuzzAttribute, Convert.ToInt64(szText));
                                break;
                            case "UInt16":
                                facp.fieldInfo.SetValue(facp.fuzzAttribute, Convert.ToUInt16(szText));
                                break;
                            case "uint":
                            case "UInt32":
                                break;
                            case "UInt64":
                                facp.fieldInfo.SetValue(facp.fuzzAttribute, Convert.ToUInt64(szText));
                                break;
                            case "double":
                            case "Double":
                                facp.fieldInfo.SetValue(facp.fuzzAttribute, Convert.ToDouble(szText));
                                break;
                            case "bool":
                            case "Boolean":
                                facp.fieldInfo.SetValue(facp.fuzzAttribute, ((CheckBox)fa._thisPanel.Controls[i]).Checked);
                                break;
                            case "String":
                                facp.fieldInfo.SetValue(facp.fuzzAttribute, szText);
                                break;
                        };

                    }
                }
            }
        }

        /// <summary>
        /// Toggles the static fuzz boolean in the wiredata class to enable
        /// or disable fuzzing for everything.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void checkOverallFuzz_CheckedChanged ( object sender, EventArgs e )
        {
            checkedListBoxDerivedClasses_SelectedIndexChanged(null, null);
            WireData.Fuzz = ((CheckBox)sender).Checked;
        }

        /// <summary>
        /// Brings up the open file dialog box that can be used to load a background 
        /// image for the form
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void label2_Click ( object sender, EventArgs e )
        {
            Image imageToUse = null;
            string oldDirectory = Directory.GetCurrentDirectory();
            if (ofd.ShowDialog() == DialogResult.OK)
            {
                // A file was selected
                if (ofd.FileName != null)
                {
                    if (BackgroundImage != null)
                        BackgroundImage.Dispose();
                    if (panel1.BackgroundImage != null)
                        panel1.BackgroundImage.Dispose();

                    // Wrap an exception around this, because Luke will try to break
                    // it because he is a trouble maker.
                    try
                    {
                        imageToUse = Image.FromFile(ofd.FileName);
                    }
                    catch (System.OutOfMemoryException ex)
                    {
                        Global.RO.Error("Image format invalid.");
                        Global.RO.Error(ex.Message);
                    }
                    catch (System.IO.FileNotFoundException ex)
                    {
                        Global.RO.Error("Image not found.");
                        Global.RO.Error(ex.Message);
                    }
                    
                    BackgroundImage = panel1.BackgroundImage = imageToUse;
                }
            }
            else
            {
                // The Dialog box closed without OK
            }
            Directory.SetCurrentDirectory(oldDirectory);
        }

        /// <summary>
        /// Loops through all of the current classes in the mastercache
        /// and dissables fuzzing on all of them without modifying the static
        /// fuzz field in WireData
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void button1_Click ( object sender, EventArgs e )
        {
            // Loop through and add all of the classes for each namespace to the checkbox
            foreach (KeyValuePair<string, List<Type>> NameSpacePair in MasterTypeCache)
            {
                List<Type> typeList = MasterTypeCache[NameSpacePair.Key];
                foreach (Type type in typeList)
                {
                    try
                    {
                        WireData.FieldCache fc = WireData.GetFieldCacheLine(type);
                        if (fc == null)
                            continue;
                        fc.FuzzClass = false;
                    }
                    catch (Exception omg)
                    {
                        Global.RO.Warn("Unexpected exception: "+omg);
                    }
                }
            }
            checkedListBoxDerivedClasses.BeginUpdate();
            for (int i = 0; i < checkedListBoxDerivedClasses.Items.Count; i++)
            {
                checkedListBoxDerivedClasses.SetItemChecked(i, false);
            }
            checkedListBoxDerivedClasses.EndUpdate();
        }

        //does the opposite of button1_Click
        private void button1_Unclick ( object sender, EventArgs e )
        {
            // Loop through and add all of the classes for each namespace to the checkbox
            foreach (KeyValuePair<string, List<Type>> NameSpacePair in MasterTypeCache)
            {
                List<Type> typeList = MasterTypeCache[NameSpacePair.Key];
                foreach (Type type in typeList)
                {
                    try
                    {
                        WireData.FieldCache fc = WireData.GetFieldCacheLine(type);
                        if (fc == null)
                            continue;
                        fc.FuzzClass = true;
                    }
                    catch (Exception omg)
                    {
                        Global.RO.Warn("Unexpected exception: "+omg);
                    }
                }
            }
            checkedListBoxDerivedClasses.BeginUpdate();
            for (int i = 0; i < checkedListBoxDerivedClasses.Items.Count; i++)
            {
                checkedListBoxDerivedClasses.SetItemChecked(i, true);
            }
            checkedListBoxDerivedClasses.EndUpdate();
        }

        /// <summary>
        /// Close the form.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void button1_Click_1 ( object sender, EventArgs e )
        {
            Hide();
        }
        private void FuzzForm_Closing ( Object sender, CancelEventArgs e )
        {
            e.Cancel = true;
            Hide();
        }

        /// <summary>
        /// Toggle all Fuzzing for each field within the current class.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void button_FuzzToggle_Click ( object sender, EventArgs e )
        {
            if (CurrentFields.Count > 0)
            {
                bool check = !CurrentFields[0].checkFuzz.Checked;
                for (int i = 0; i < CurrentFields.Count; i++)
                {
                    CurrentFields[i].checkFuzz.Checked = check;
                }
            }
        }
        //
        // End Control Handlers
        //

        /// <summary>
        /// Class used to display information about fuzzing controls 
        /// for a specified field. This handles all updating and will display all 
        /// custom attribute fields per field.
        /// </summary>
        private class FuzzAttribDisplay : IDisposable
        {
            public Panel _parentPanel;
            public Panel _thisPanel;
            public FieldInfo _field;
            public FuzzDataAttribute _fuzzAttrib;

            // Base class controls
            // These are available for all fuzzable objects;
            public CheckBox checkFuzz;
            public CheckBox checkRandom;
            public CheckBox checkDeterministic;
            public TrackBar trackProbability;
            public TextBox textProbablility;
            public TextBox textRandomSeed;
            public Label labelProbability;
            public Label labelRandomSeed;
            
            public FuzzAttribDisplay ( Panel parentPanel, FieldInfo field, FuzzDataAttribute fuzzAttrib, int yPos )
            {
                ToolTip tip = new ToolTip() ;
                int controlY = 4;
                _parentPanel = parentPanel;
                _field = field;
                _fuzzAttrib = fuzzAttrib;


                // Create the panel that will contain all the attribute fields
                // related to the field.
                _thisPanel = new Panel();
                _thisPanel.Name = field.Name;
                _thisPanel.Location = new Point(2, yPos + 2);
                _thisPanel.BorderStyle = BorderStyle.FixedSingle;
                _thisPanel.AutoSize = true;

                // Create the description information so the user knows which 
                // field they are changing attributes for
                //
                // Name
                Label tempName = new Label();
                tempName.Location = new Point(4, controlY);
                tempName.Text = "Name: " + field.Name;
                tempName.Height = 15;
                tempName.Width = 200;
                
                tip.SetToolTip(tempName, "Name of the field to be fuzzed.");
                _thisPanel.Controls.Add(tempName);
                controlY += tempName.Height + 2;
                // Type
                Label tempType = new Label();
                tempType.Location = new Point(4, controlY);
                tempType.Text = "Type: " + field.FieldType.Name;
                tempType.Height = 15;
                tempType.Width = 200;
                
                tip.SetToolTip(tempType, "Type of the field to be fuzzed.");
                _thisPanel.Controls.Add(tempType);

                // Overall fuzz on/off this is the supreme commander of all
                // other options.
                checkFuzz = new CheckBox();
                checkFuzz.Text = "Fuzz";
                checkFuzz.Location = new Point(_thisPanel.Width, controlY - 20);
                checkFuzz.RightToLeft = RightToLeft.Yes;
                checkFuzz.Checked = _fuzzAttrib.Fuzz;
                checkFuzz.Tag = new FuzzAttribChildPair(_fuzzAttrib, _fuzzAttrib.GetFieldInfoByName("Fuzz"));
                checkFuzz.CheckedChanged += check_CheckChange;
                
                
                tip.SetToolTip(checkFuzz, "If checked fuzzing will be turned on.");
                _thisPanel.Controls.Add(checkFuzz);

                // When fuzzing is on, this controls if it is completely 
                // random or if it uses the attribute fields.
                checkRandom = new CheckBox();
                checkRandom.Text = "Random Bytes";
                checkRandom.Location = new Point(_thisPanel.Width, controlY);
                checkRandom.RightToLeft = RightToLeft.Yes;
                checkRandom.Enabled = false;
                checkRandom.Checked = _fuzzAttrib.RandomBytes;
                checkRandom.CheckedChanged += check_CheckChange;
                checkRandom.Tag = new FuzzAttribChildPair(_fuzzAttrib, _fuzzAttrib.GetFieldInfoByName("RandomBytes"));
                
                tip.SetToolTip(checkRandom, "If checked fuzzing will be completely random.");
                _thisPanel.Controls.Add(checkRandom);
                controlY += tempName.Height + 10;

                // Probablility that the object will be fuzzed label, slider, and textbox
                labelProbability = new Label();
                labelProbability.Text = "Probablility";
                labelProbability.Location = new Point(4, controlY + 5);
                labelProbability.Width = 60;
                labelProbability.Height = 15;
                labelProbability.Enabled = false;
                
                tip.SetToolTip(labelProbability, "The chance that a given field will be fuzzed");
                _thisPanel.Controls.Add(labelProbability);

                trackProbability = new TrackBar();
                trackProbability.Location = new Point(65, controlY);
                trackProbability.TickStyle = TickStyle.None;
                trackProbability.AutoSize = false;
                trackProbability.Maximum = 100;
                trackProbability.Minimum = 0;
                trackProbability.Width = 200;
                trackProbability.Height = 22;
                trackProbability.TickFrequency = 1;
                trackProbability.Value = (int)(_fuzzAttrib.Probability * 100);
                trackProbability.ValueChanged += trackProbability_ProbabilityValueChanged;
                trackProbability.Enabled = false;
                
                tip.SetToolTip(trackProbability, "The chance that a given field will be fuzzed");
                _thisPanel.Controls.Add(trackProbability);

                textProbablility = new TextBox();
                textProbablility.Text = Convert.ToString((double)trackProbability.Value / 100.0);
                textProbablility.Location = new Point(270, controlY);
                textProbablility.Width = 35;
                textProbablility.Text = Convert.ToString(_fuzzAttrib.Probability);
                textProbablility.LostFocus += textProbablility_ProbabilityValueChanged;
                textProbablility.KeyUp += TextBoxKeyDown;
                textProbablility.Tag = new FuzzAttribChildPair(_fuzzAttrib, _fuzzAttrib.GetFieldInfoByName("Probability"));
                textProbablility.Enabled = false;
                textProbablility.Name = "Probability";
                
                tip.SetToolTip(textProbablility, "The chance that a given field will be fuzzed");
                _thisPanel.Controls.Add(textProbablility);
                controlY += 25;

                // Deterministic / Random Seed
                checkDeterministic = new CheckBox();
                checkDeterministic.Text = "Deterministic";
                checkDeterministic.Width = 90;
                checkDeterministic.Location = new Point(20, controlY);
                checkDeterministic.Enabled = false;
                checkDeterministic.Checked = _fuzzAttrib.Deterministic;
                checkDeterministic.CheckedChanged += check_CheckChange;
                checkDeterministic.Tag = new FuzzAttribChildPair(_fuzzAttrib, _fuzzAttrib.GetFieldInfoByName("Deterministic"));
                
                tip.SetToolTip(checkDeterministic, "If selected, this field will be fuzzed using a recorded or given seed value, and the iterations tracked. Useful for recreating past events.");
                _thisPanel.Controls.Add(checkDeterministic);

                labelRandomSeed = new Label();
                labelRandomSeed.Text = "Random Seed";
                labelRandomSeed.Location = new Point(140, controlY + 4);
                labelRandomSeed.AutoSize = true;
                labelRandomSeed.Height = 15;
                labelRandomSeed.Enabled = false;
                
                tip.SetToolTip(labelRandomSeed, "Value used to seed the random number generator");
                _thisPanel.Controls.Add(labelRandomSeed);

                textRandomSeed = new TextBox();
                textRandomSeed.Text = Convert.ToString(0);
                textRandomSeed.Location = new Point(225, controlY);
                textRandomSeed.Width = 55;
                textRandomSeed.Text = Convert.ToString(_fuzzAttrib.RandomSeed);
                textRandomSeed.KeyUp += TextBoxKeyDown;
                textRandomSeed.Tag = new FuzzAttribChildPair(_fuzzAttrib, _fuzzAttrib.GetFieldInfoByName("RandomSeed"));
                textRandomSeed.Enabled = false;
                textRandomSeed.Name = "Random Seed";
                
                tip.SetToolTip(textRandomSeed, "Value used to seed the random number generator");
                _thisPanel.Controls.Add(textRandomSeed);
                
                controlY += 25;

                // Remove the base class fields from the list of fields.
                FuzzDataAttribute fda = new FuzzDataAttribute();
                FieldInfo[] baseClass = fda.Fields;
                FieldInfo[] derivedClass = fuzzAttrib.Fields;
                FieldInfo[] fields = new FieldInfo[derivedClass.Length - baseClass.Length];
                for(int i = 0; i <derivedClass.Length - baseClass.Length;  i++)
                {
                    fields[i] = derivedClass[i];
                }
                
                if (fields.Length > 0)
                {
                    Label divider = new Label();
                    divider.Text = "";
                    divider.Height = 3;
                    divider.Width = 285;
                    divider.Location = new Point(12, controlY);
                    divider.BorderStyle = BorderStyle.Fixed3D;
                    _thisPanel.Controls.Add(divider);
                    controlY += 20;
                }

                foreach (FieldInfo currentField in fields)
                {
                    switch (currentField.FieldType.Name)
                    {
                        case "Int32": 
                        case "Double":
                        case "UInt16": 
                        case "UInt32":
                        case "UInt64": 
                        case "Byte":
                        case "String":
                            AddNewControlTextBox(_thisPanel, controlY, currentField, fuzzAttrib);
                            break;
                        case "Boolean":
                            AddNewContolCheckBox(_thisPanel, controlY, currentField, fuzzAttrib);
                            break;
                        
                        default:
                            Global.RO.Warn("Unhandled FuzzAttrib Field Type: " + currentField.FieldType.Name);
                            break;
                    };
                    controlY += 25;
                }
                //}
                
                parentPanel.Controls.Add(_thisPanel);
                check_CheckChange(null, null);
            }

            //
            // Utilities
            // 

            private void AddNewControlTextBox ( Panel panel, int yPos, FieldInfo field, FuzzDataAttribute fuzzAttrib )
            {
                FuzzAttribChildPair facp = new FuzzAttribChildPair(fuzzAttrib, field);

                TextBox tempTextBox = new TextBox();
                tempTextBox.Width = 100;
                tempTextBox.Location = new Point(10, yPos);
                tempTextBox.Tag = facp;
                tempTextBox.Text = Convert.ToString(field.GetValue(fuzzAttrib));
                panel.Controls.Add(tempTextBox);

                // Label discription
                Label tempIntLabel = new Label();
                tempIntLabel.Location = new Point(115, yPos + 3);
                tempIntLabel.AutoSize = true;
                tempIntLabel.Text = field.FieldType.Name + " " + field.Name;
                panel.Controls.Add(tempIntLabel);

                tempTextBox.KeyUp += TextBoxKeyDown;

                yPos += 25;
            }

            public static void TextBoxKeyDown ( object sender, KeyEventArgs e )
            {
                FuzzAttribChildPair facp = ((FuzzAttribChildPair)((TextBox)sender).Tag);
                String szText = ((TextBox)sender).Text;

                bool goodAnswer = true;
                switch (facp.fieldInfo.FieldType.Name)
                {
                    case "Int16":
                        Int16 tempInt16 = 0;
                        goodAnswer = Int16.TryParse(szText, out tempInt16);
                        break;
                    case "Int32":
                        Int32 tempInt32 = 0;
                        goodAnswer = Int32.TryParse(szText, out tempInt32);
                        break;
                    case "Int64":
                        Int64 tempInt64 = 0;
                        goodAnswer = Int64.TryParse(szText, out tempInt64);
                        break;
                    case "UInt16":
                        UInt16 tempUInt16 = 0;
                        goodAnswer = UInt16.TryParse(szText, out tempUInt16);
                        break;
                    case "UInt32":
                        UInt32 tempUInt32 = 0;
                        goodAnswer = UInt32.TryParse(szText, out tempUInt32);
                        break;
                    case "UInt64":
                        UInt64 tempUInt64 = 0;
                        goodAnswer = UInt64.TryParse(szText, out tempUInt64);
                        break;
                    case "Double":
                        Double tempDouble = 0;
                        goodAnswer = Double.TryParse(szText, out tempDouble);
                        break;
                }
                // If the answer is bad, change the BG color of the text box.
                if(!goodAnswer && szText != "")
                    ((TextBox)sender).BackColor = Color.Salmon;
                else
                    ((TextBox)sender).BackColor = Color.White;

            }

            private void AddNewContolCheckBox ( Panel panel, int yPos, FieldInfo field, FuzzDataAttribute fuzzAttrib )
            {
                FuzzAttribChildPair facp = new FuzzAttribChildPair(fuzzAttrib, field);

                CheckBox tempCheckBox = new CheckBox();
                tempCheckBox.Location = new Point(100, yPos);
                tempCheckBox.Tag = facp;
                tempCheckBox.Text = field.FieldType.Name + " " + field.Name;
                tempCheckBox.AutoSize = true;
                panel.Controls.Add(tempCheckBox);

                yPos += 25;
            }

            public int GetHeight ()
            {
                return _thisPanel.Height;
            }
            //
            // End Utilities
            //

            // 
            // Control Handlers
            //
            /// <summary>
            /// Handles check box changes to make sure the correct controls are
            /// enabled and dissabled when a change is made.
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void check_CheckChange ( object sender, EventArgs e )
            {
                if (checkFuzz.Checked == false)
                {
                    // Dissable everything.
                    checkRandom.Enabled = false;
                    checkDeterministic.Enabled = false;
                    trackProbability.Enabled = false;
                    textProbablility.Enabled = false;
                    textRandomSeed.Enabled = false;
                    labelProbability.Enabled = false;
                    labelRandomSeed.Enabled = false;
                }
                else
                {
                    // Enable everything.
                    checkRandom.Enabled = true;
                   
                        checkDeterministic.Enabled = true;
                        trackProbability.Enabled = true;
                        textProbablility.Enabled = true;
                        labelProbability.Enabled = true;

                        if (checkDeterministic.Checked == true)
                        {
                            labelRandomSeed.Enabled = true;
                            textRandomSeed.Enabled = true;
                        }
                        else
                        {
                            labelRandomSeed.Enabled = false;
                            textRandomSeed.Enabled = false;
                        }
                }
            }

            /// <summary>
            /// Called when the slider for probability changes, this converts it to a string
            /// between 0 and 1
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void trackProbability_ProbabilityValueChanged ( object sender, EventArgs e )
            {
                textProbablility.Text = Convert.ToString(trackProbability.Value / 100.0);

                // If you moved the slider, that means the value in the textbox must 
                // be valid. So make sure the BG color is white.
                textProbablility.BackColor = Color.White;
            }
            
            /// <summary>
            /// Called when focus to the text box for probablility is lost, this takes the number
            /// and converts it to a number between 0 and 100 and sets the slider to that value.
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            private void textProbablility_ProbabilityValueChanged ( object sender, EventArgs e )
            { 
                double probability = 0;

                if (double.TryParse(((TextBox)sender).Text, out probability))
                {
                    if (probability < 0)
                        probability = 0;
                    else if (probability > 1)
                        probability = 1;

                    trackProbability.Value = (int)(probability * 100);
                    ((TextBox)sender).Text = Convert.ToString(probability);
                }
            }
            //
            // End Control Handlers
            //


            private bool disposed = false;

            public void Dispose ()
            {
                Dispose(true);
                GC.SuppressFinalize(this);
            }


            private void Dispose ( bool disposeManagedResources )
            {
                if (!this.disposed)
                {
                    if (disposeManagedResources)
                    {
                        _parentPanel = null;
                        _thisPanel = null;
                        _field = null;
                        _fuzzAttrib = null;

                        checkFuzz.CheckedChanged -= check_CheckChange;
                        checkFuzz.Dispose();

                        checkRandom.CheckedChanged -= check_CheckChange;
                        checkRandom.Dispose();
                        
                        checkDeterministic.CheckedChanged -= check_CheckChange;
                        checkDeterministic.Dispose();
                        
                        trackProbability.ValueChanged -= trackProbability_ProbabilityValueChanged;
                        trackProbability.Dispose();
                        
                        textProbablility.LostFocus -= textProbablility_ProbabilityValueChanged;
                        textProbablility.KeyUp -= TextBoxKeyDown;
                        textProbablility.Dispose();

                        textRandomSeed.KeyUp -= TextBoxKeyDown;
                        textRandomSeed.Dispose();

                        labelProbability.Dispose();
                        labelRandomSeed.Dispose();
                    }
                }
                disposed = true;
            }
        }

        private class FuzzAttribChildPair
        {
            public FuzzDataAttribute fuzzAttribute;
            public FieldInfo fieldInfo;

            public FuzzAttribChildPair ( FuzzDataAttribute fda, FieldInfo field )
            {
                fuzzAttribute = fda;
                fieldInfo = field;
            }
        }



        private void button_SaveConfig_Click ( object sender, EventArgs e )
        {
            try
            {
                // Bring up the save file box, and allow the user to pick a name
                // Default files should be Fuzz Config Data *.FCD
                DialogResult result = saveFileDialog1.ShowDialog();

                // Make sure the user didn't cancel the save window.
                if (result != DialogResult.Cancel && result != DialogResult.Abort)
                {
                    XmlTextWriter writer = new XmlTextWriter(saveFileDialog1.FileName, null);
                    writer.Formatting = Formatting.Indented;
                    writer.WriteStartDocument();
                    writer.WriteComment("Comment:: Field Cache Data Backup");
                    writer.WriteStartElement("WireDataInfo");
                    //Loop through all the information and write it out to file.
                    IDictionaryEnumerator Enumerator;
                    Enumerator = fieldCache.GetEnumerator();
                    while (Enumerator.MoveNext())
                    {
                        Type type = Type.GetType(Enumerator.Key.ToString());
                        WireData.FieldCache fc = ((WireData.FieldCache)Enumerator.Value);


                        if (fc.Fields.Length == 0 || fc.FuzzInfo[0] == null)
                        {
                            // Don't bother writing anything for a class that has
                            // no fuzz data.
                            continue;
                        }

                        writer.WriteStartElement("Class");
                        writer.WriteAttributeString("Name", Enumerator.Key.ToString());
                        writer.WriteAttributeString("Selected", fc.FuzzClass.ToString());
                        for (int i = 0; i < fc.Fields.Length; i++)
                        {
                            FieldInfo field = fc.Fields[i];
                            FuzzDataAttribute fuzzInfo = fc.FuzzInfo[i];
                            WireInfoAttribute wireInfo = fc.WireInfo[i];

                            // No point in writing it out if the field isn't even serialized.                         
                            if (wireInfo.Serialize == false)
                                continue;
                          
                            // No point in writing it out if nothing was touched yet.
                            if (fuzzInfo == null)
                                continue;

                            writer.WriteStartElement("Field");
                            writer.WriteAttributeString("Name", field.Name);
                            writer.WriteAttributeString("Type", field.FieldType.Name);

                            //Write out the data for the fuzz data attribute
                            writer.WriteStartElement("FuzzInfo");
                            if (fuzzInfo != null)
                            {
                                foreach (FieldInfo f in fuzzInfo.Fields)
                                {
                                    writer.WriteAttributeString(f.Name, Convert.ToString(f.GetValue(fuzzInfo)));
                                }
                            }
                            writer.WriteEndElement(); // FuzzInfo

                            //Write out the data for the wire data attribute
                            //writer.WriteStartElement("WireInfo");
                            //    if (wireInfo != null)
                            //    {
                            //        writer.WriteAttributeString("ArraySize", wireInfo.ArraySize.ToString());
                            //        writer.WriteAttributeString("Serialize",  wireInfo.Serialize.ToString());
                            //        writer.WriteAttributeString("SizeParam",  wireInfo.SizeParam == null ? "null":wireInfo.SizeParam.ToString());
                            //        writer.WriteAttributeString("Unicode",  wireInfo.UnicodeEncoded.ToString());
                            //        writer.WriteAttributeString("WriteOnlyVarsLength", wireInfo.WriteOnlyVarLenString.ToString());
                            //    }
                            //writer.WriteEndElement(); // WireInfo
                            writer.WriteEndElement(); // Field
                        }
                        writer.WriteEndElement(); // Class
                    }
                    writer.WriteEndElement(); // WireDataInfo
                    writer.WriteEndDocument();
                    writer.Flush();
                    writer.Close();
                }
            }
            catch (Exception ex)
            {
                Global.RO.Error("Fuzzer Save Threw an Exception: " + ex.Message);
            }
        }

        private void button_LoadConfig_Click ( object sender, EventArgs e )
        {
            WireData.FieldCache tempFc = null;
            int currentFieldIndex = -1;
            int currentAttribCount = 0;
            
            try
            {
                
                DialogResult result = openFileDialog1.ShowDialog();
                
                if (result != DialogResult.Cancel && result != DialogResult.Abort)
                {
                    if (!openFileDialog1.FileName.EndsWith("FCD"))
                    {
                        MessageBox.Show("Could not open file (" + openFileDialog1.FileName + "). Please choose a valid File Type *.FCD");
                        return;
                    }
                    XmlTextReader reader = new XmlTextReader(openFileDialog1.FileName);
                    // Continue to read file until all of it is read in
                    while (reader.Read())
                    {
                        switch (reader.NodeType)
                        {
                            case XmlNodeType.Element:
                                switch (reader.Name)
                                {
                                    case "Class":
                                        currentAttribCount = reader.AttributeCount;
                                        for (int i = 0; i < currentAttribCount; i++)
                                        {
                                            reader.MoveToAttribute(i);
                                            switch (reader.Name)
                                            {
                                                case "Name":
                                                    tempFc = WireData.GetFieldCacheLine(Type.GetType(reader.Value));
                                                    break;
                                                case "Selected":
                                                    tempFc.FuzzClass = Convert.ToBoolean(reader.Value);
                                                    break;
                                            };
                                        }
                                        break;
                                    case "Field":
                                        currentAttribCount = reader.AttributeCount;
                                        for (int i = 0; i < currentAttribCount; i++)
                                        {
                                            reader.MoveToAttribute(i);
                                            switch (reader.Name)
                                            {
                                                case "Name":
                                                    currentFieldIndex = (int)tempFc.GetFieldIndex(reader.Value);
                                                    break;
                                            };
                                        }
                                        break;
                                    case "FuzzInfo":
                                        currentAttribCount = reader.AttributeCount;
                                        tempFc.CreateFuzzData(currentFieldIndex);
                                        for (int i = 0; i < currentAttribCount; i++)
                                        {
                                            reader.MoveToAttribute(i);
                                            FieldInfo tempField = tempFc.FuzzInfo[currentFieldIndex].GetFieldInfoByName(reader.Name);

                                            switch (tempField.FieldType.Name)
                                            {
                                                case "Int16":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToInt16(reader.Value));
                                                    break;
                                                case "int":
                                                case "Int32":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToInt32(reader.Value));
                                                    break;
                                                case "Int64":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToInt64(reader.Value));
                                                    break;
                                                case "UInt16":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToUInt16(reader.Value));
                                                    break;
                                                case "uint":
                                                case "UInt32":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToUInt32(reader.Value));
                                                    break;
                                                case "UInt64":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToUInt64(reader.Value));
                                                    break;
                                                case "double":
                                                case "Double":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToDouble(reader.Value));
                                                    break;
                                                case "bool":
                                                case "Boolean":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToBoolean(reader.Value));
                                                    break;
                                                case "String":
                                                    tempField.SetValue(tempFc.FuzzInfo[currentFieldIndex], Convert.ToString(reader.Value));
                                                    break;
                                            };

                                                //case "Deterministic":
                                                //    tempFc.FuzzInfo[currentFieldIndex].Deterministic = Convert.ToBoolean(reader.Value);
                                                //    break;
                                                //case "Fuzz":
                                                //    tempFc.FuzzInfo[currentFieldIndex].Fuzz = Convert.ToBoolean(reader.Value);
                                                //    break;
                                                //case "Probability":
                                                //    tempFc.FuzzInfo[currentFieldIndex].Probability = Convert.ToDouble(reader.Value);
                                                //    break;
                                                //case "RandomBytes":
                                                //    tempFc.FuzzInfo[currentFieldIndex].RandomBytes = Convert.ToBoolean(reader.Value);
                                                //    break;
                                                //case "RandomSeed":
                                                //    tempFc.FuzzInfo[currentFieldIndex].RandomSeed = Convert.ToInt32(reader.Value);
                                                //    break;
                                        }
                                        break;
                                };
                                break;
                            case XmlNodeType.EndElement:
                                break;
                        };

                    }
                    reader.Close();

                    // Clear everything
                    CurrentFields.Clear();
                    panel1.Controls.Clear();
                    comboNamespaces.Text = "Loaded... Select Namespace";
                    checkedListBoxDerivedClasses.Items.Clear();
                }
            }
            catch (Exception ex)
            {
                Global.RO.Error("Fuzzer Load Threw an Exception: " + ex.Message);
            }

        }

        private void checkedListBoxDerivedClasses_ItemCheck ( object sender, ItemCheckEventArgs e )
        {
            if (e.NewValue == CheckState.Checked)
            {
                updateFieldsList();
            }
        }

        private WireData.FieldCache GetFieldCacheLineByName ( string name )
        {
            foreach (KeyValuePair<string, List<Type>> kvpair in MasterTypeCache)
            {
                List<Type> typeList = kvpair.Value;
                foreach (Type type in typeList)
                {
                    if (type.Name == name)
                    {
                        return WireData.GetFieldCacheLine(type);
                    }
                }
            }
            return null;
        }

        private void KillControl ( Control c )
        {
            while (c.Controls.Count > 0)
            {
                KillControl(c.Controls[0]);
            }
            Type type = c.GetType();

            if (type == typeof(TextBox))
            {
                c.KeyUp -= ServerTestFramework.Utilities.WireDataFuzzForm.FuzzAttribDisplay.TextBoxKeyDown;
            }
            
            c.Dispose();
        }

        private void checkedListBoxDerivedClasses_DoubleClick ( object sender, EventArgs e )
        {
            checkedListBoxDerivedClasses_SelectedIndexChanged(null, null);

        }
    }// WireDataFuzzForm
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\Form1.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

using XStoreTest;
using System.Diagnostics;

namespace StorageTestUI
{
    public partial class Form1 : Form
    {

        string fileName="";
        string url = "";

        public Form1()
        {
            InitializeComponent();
        }


        private void button1_Click(object sender, System.EventArgs e)
        {
            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {

                fileName = openFileDialog1.FileName;
                textBox1.Text = fileName;
            }

            pictureBox1.ImageLocation = fileName;

        }

        private void button2_Click_1(object sender, EventArgs e)
        {
            CallSTFTestCase();

        }

        private void CallSTFTestCase()
        {
            try
            {


                richTextBox1.Clear();
                richTextBox1.Text = "Connecting to Storage .........";
                button2.Enabled = false;

                ServerTestFramework.CoreGlobal.Initialize();
                ServerTestFramework.Global.CurrentEnvironment = new ServerTestFramework.EnvironmentSetting("xblob", textBox3.Text, "npdb", "", true);



                //xonline.common.config.Config.N
                ServerTestFramework.TEST_RESULTS a = UnitTestsAvatarWriteFiles.PWFAvatarE2E.ExecuteTestCase(fileName, textBox2.Text, out url);

                richTextBox1.Text = "WriteFile succeeded. \n\n\nUrl for Read is: \n" + url;
                button2.Enabled = true;

            }
            catch (Exception exception)
            {
                richTextBox1.Text = exception.ToString();
            }
            finally
            {
                button2.Enabled = true;

            }


        }


        private void CallSTFConsoleTestCase()
        {
            try
            {
                string command = "STFConsoleLive.exe ";
                string args = " /run:*avatarx* /env:xblob /filelog XStoreTest.dll";

                Process.Start(command, args);
            }
            catch (Exception exception)
            {
                richTextBox1.Text = exception.ToString();
            }
        }

        private void button3_Click(object sender, EventArgs e)
        {
            AvatarHelper.LaunchIE(url);
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\Properties\Settings.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace StorageTestUI.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "8.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\Properties\AssemblyInfo.cs ===
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("StorageTestUI")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("MS")]
[assembly: AssemblyProduct("StorageTestUI")]
[assembly: AssemblyCopyright("Copyright © MS 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("d84f2896-e3de-4929-9889-09010dc56a6d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageGateway\HttpGatewayTests.cs ===
﻿using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using System.Net;
using System.Net.Cache;
using live.common;
using live.lfm;
using live.server;
using ServerTestFramework.LiveService.Storage;
using System.IO;

namespace StorageGateway
{
    public static class TestUser
    {
        public static string XUID;
        public static string GamerTag;
        public static Xbox360 xbox360;
        public static XblUser user;
        
        public static void Create()
        {
            XblUserSettings settings;

            xbox360 = new Xbox360();
            xbox360.Client.BypassKDC = true;
            settings = new XblUserSettings(XblUserTier.Gold, PassportType.Real);
            GamerAge age = GamerAge.FromBirthDate(settings.PersonalInfo.BirthDate);
            CountryInfo countryInfo = Countries.CountryInfo(settings.PersonalInfo.CountryId);
            settings.UserPassportInfo.BirthDate = settings.PersonalInfo.BirthDate;
            settings.UserPassportInfo.CountryId = settings.PersonalInfo.CountryId;
                if (age.AgeInYears >= (int)countryInfo.Billing)
                {
                    PassportUtils.CreatePassportAccounts(xbox360.Client, settings, true);
                }
                else
                {
                    if (settings.UserPassportInfo.MemberName == settings.OwnerPassportInfo.MemberName)
                    {
                        settings.OwnerPassportInfo.MemberName = settings.OwnerPassportInfo.MemberName.Replace("@", "_owner@");
                    }
                    PassportUtils.CreatePassportAccounts(xbox360.Client, settings, false);
                }
                uint hr = UACS.XeCreateLiveAccount(xbox360.Client, settings, out user);
                if (hr != 0)
                {
                    throw new Exception("Failed to create user; hr = " + hr);
                }
                XUID = user.Puid.ToString();
            
                GamerTag = user.Gamertag;
        }
    }

    /// <summary>
    /// Base class that holds the methods for opening a site and receiving data
    /// </summary>
    internal abstract class HttpTestBase : TestBase
    {

        public string Gateway = "http://10.198.102.154/";
        public string ImagePath = @"C:\temp\avatar.png";
        public WebRequest request=null;
        public WebResponse response=null;

        public HttpTestBase()
        {
            
        }

        public bool WriteStorageFile(string fileName, string storagePath)
        {
            XRLWriteFile upload = new XRLWriteFile("ServiceAddr", storagePath);

            FileStream fs = new FileStream(fileName, FileMode.Open);
            byte[] blob = new byte[fs.Length];
            fs.Read(blob, 0, Convert.ToInt32(fs.Length));
            upload.blobData = blob;
            upload.blobDataLen = Convert.ToUInt32(fs.Length);
            upload.uiBlobSizeCompressed = (uint)fs.Length;
            fs.Close();

            bool fPassed = upload.Execute();
            if (!fPassed)
            {
                Global.RO.Warn("Failed to send WriteFile request ");
                return false;
            }
            
            /*
            XRLReadFileResponse ReadFileResp;
            XRLReadFile ReadFileReq = new XRLReadFile(upload.accessToken.baseAT.pathName);
            ReadFileReq.Slot.titleId = ReadFileReq.uiTitleId = upload.uiTitleId;
            ReadFileReq.Slot.titleVersion = ReadFileReq.uiTitleVersion = upload.uiTitleVersion;
            if (ReadFileReq.Execute(Global.XEnv.GetVirtualInterface(VirtualInterface.stfd_storage), out ReadFileResp))
            {
                if (!ReadFileResp.Compare(WriteFileReq))
                {
                    Global.RO.Warn("ReadFileResp.Compare failed.  WriteFile request is not set correctly in the db");
                    return false;
                }
                else if (!WriteFileReq.Verify())
                {
                    Global.RO.Warn("WriteFileReq.Verify failed.  WriteFile request is not set correctly in the db");
                    return false;
                }
            }
            else
            {
                Global.RO.Warn("Failed to send ReadFile request");
                return false;
            }
             */
            return true;
        }

        public string CreateAvatarPath(string puid, string imageName)
        {
            return String.Format("//avatar/u:{0}/{1}", puid, imageName);
        }

        public string CreateWebPath(string gamerTag, string imageName)
        {
            return String.Format("{0}avatar/{1}/{2}", Gateway, gamerTag, imageName);
        }
    }

    [TestGroup, Description("Tests the web gateway directly with a predetermined file that is put into storage.")]
    public class HttpGatewayTests : TestNode 
    {
        [TestCase, Description("Read a file from the gateway without modified date")]
        class Read_NoMod : HttpTestBase  
        {
            
            override protected void Execute()
            {
                if (TestUser.user == null)
                    TestUser.Create();

                Global.RO.Info(string.Format("Gamertag: {0} XUID: {1}", TestUser.GamerTag, TestUser.XUID));
                string storagePath = CreateAvatarPath(TestUser.XUID, "avatar-l.png");
                WriteStorageFile(ImagePath, storagePath);
                string webPath = CreateWebPath(TestUser.GamerTag, "avatar-l.png");
                
                RequestCachePolicy policy = new RequestCachePolicy( RequestCacheLevel.BypassCache);
                request = WebRequest.Create(webPath);
                request.CachePolicy = policy;

                response = request.GetResponse();
                Stream rcvStrm = response.GetResponseStream();

                // did we get text.  Problem here that we are currently getting "text/html" for the returned image instead of 'image/png'.
                if (response.ContentType.Contains("html"))
                {
                    char[] strBuff = new char[81];
                    StreamReader reader = new StreamReader(rcvStrm);
                    while (reader.Read(strBuff, 0, 80) > 0)
                    {
                        string strLine = new string(strBuff);
                        Global.RO.Info(strLine);
                    }
                }
                else  // or the image
                {
                    FileStream fs = new FileStream(ImagePath,FileMode.Open,FileAccess.Read);
                    int orig = fs.ReadByte();
                    int copy = rcvStrm.ReadByte();

                    while (orig > 0 && copy > 0)
                    {
                        if (orig != copy)
                        {
                            Global.RO.Fatal("Return image does not match!");
                            ResultCode = TEST_RESULTS.FAILED;
                            return;
                        }
                        orig = fs.ReadByte();
                        copy = rcvStrm.ReadByte();
                    }

                    /*
                    FileStream fs = new FileStream(@"C:\temp\result.png", FileMode.Create, FileAccess.Write);
                    int val=rcvStrm.ReadByte();
                    while (val > 0)
                    {
                        fs.WriteByte((byte)val);
                        val = rcvStrm.ReadByte();
                    }
                     */
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StorageTestUI\Properties\Resources.Designer.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace StorageTestUI.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("StorageTestUI.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\CTitleId.cs ===
using System;
using System.Globalization;

using xonline.common.service;

namespace STUtilTest 
{
    /// <summary>
    /// A utiltiy class to make working with title IDs simpler.
    /// Today, a title ID is a 32 bit integer.
    /// This class is immutable once constructed
    /// </summary>
    public class CTitleId
    {
        /// <summary> The title id as a 32 bit unsigned integer </summary>
        protected uint _uiTitleId;
        /// <summary>
        /// The title id as an 8 character hex string, including leading zeros,
        /// but with no "0x" prefix
        /// </summary>
        protected string _sTitleIdHexNoPrefix;

        /// <summary>
        /// Constructs a CTitleId object from a 32 bit unsigned integer value
        /// </summary>
        /// <param name="uiTitleId">
        /// The title id as a 32 bit unsigned integer
        ///.</param>
        public CTitleId(uint uiTitleId)
        {
            CtorHelper(uiTitleId);
        }

        /// <summary>
        /// Constructs a CTitleId object from a string value
        /// </summary>
        /// <param name="sTitleId">
        /// The title id as a string. Leading or trailing whitespace is ignored.
        /// if the string begins with "0x" or "0X" it will be interpreted as a hexadecimal
        /// value. Otherwise, it is interpreted as a decimal value. Only the decimal or
        /// hex digits and the hex prefix are permitted.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// sTitleId is a null reference
        /// </exception>
        /// <exception cref="FormatException">
        /// sTitleId could not be parsed as either a decimal or hexadecimal integer
        /// </exception>
        /// <exception cref="OverflowException">
        /// sTitleId represents a number smaller than 0 or larger than 0xFFFFFFFF
        /// </exception>
        public CTitleId(string sTitleId)
        {
            if (sTitleId == null)
            {
                throw new ArgumentNullException("null string passed to CTitleId(string)");
            }

            uint tid = SafeConvert.ToUInt32(sTitleId);
            if (tid == 0)
            {
                throw new ApplicationException("Invalid title id '" + sTitleId + "'");
            }

            CtorHelper(tid);
        }

        // need this because I don't want to duplicate logic, and it's illegal to call CTitleId(uint) from the
        // body of CTitleId(string)
        private void CtorHelper(uint uiTitleId)
        {
            _uiTitleId = uiTitleId;
            _sTitleIdHexNoPrefix = String.Format("{0,8:X8}", uiTitleId);
        }

        /// <summary>
        /// Gets the title id represented by this object as a 32 bit unsigned integer value
        /// </summary>
        public uint uiTitleId
        {
            get
            {
                return _uiTitleId;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// that contains the title id in hex format, e.g. "0x1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public string sTitleIdHex
        {
            get
            {
                return "0x" + _sTitleIdHexNoPrefix;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// the contains the title id in hex format, but with no hex prefix
        /// e.g. "1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public string sTitleIdHexNoPrefix
        {
            get
            {
                return _sTitleIdHexNoPrefix;
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// the contains the title id in decimal format e.g. "305441741"
        /// (equvalient to a hex value of 0x1234ABCD).
        /// No leading zeros will be prepended
        /// </summary>
        public string sTitleIdDecimal
        {
            get
            {
                return _uiTitleId.ToString("d");
            }
        }

        /// <summary>
        /// Gets the title id represented by this object as a string
        /// that contains the title id in hex format, e.g. "0x1234ABCD"
        /// Leading zeros will be prepended such that eight hex digits
        /// are provided
        /// </summary>
        public override string ToString()
        {
            return sTitleIdHex;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\PositiveActionCases.cs ===
using System;
using ServerTestFramework;
using System.IO;

namespace STUtilTest
{
    [TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
    public class PositiveActionCases : TestNode
    {
        public static string sActionWriteTestFile = "FFFFAB28.xlast";
        public static string sActionReadTestFile = "FFFFAB28out.xlast";
        public static int uActionEnumMaxResults = 0;

        [TestCase, DVT, TestCasePriority(0)]
        public class ActionWrite : STUtilTest
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                
                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionWriteTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionReadTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch {}

                Global.RO.Info(String.Format("Path={0}", STUtilTest.sToolPath));
                Global.RO.Info(String.Format("Storage={0}", STUtilTest.sRemotePath));
                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath, STUtilTest.uTitleID);
            }
        }

        [TestCase]
        public class ActionRead : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionWriteTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionReadTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch { }

                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath, STUtilTest.uTitleID);

            }
        }

        [TestCase]
        public class ActionRemove : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionWriteTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionReadTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                }
                catch {}

                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath, STUtilTest.uTitleID);

                // Because data is replicated to mutliple titledb's, add a 10 sec wait to let it do it's thing.
                System.Threading.Thread.Sleep(10000);

                try
                {
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionReadTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    Global.RO.Info("Read Succeeded, therefore Remove either failed, or SQL replication took to long to remove it");
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, DVT, TestCasePriority(0)]
        public class ActionEnum : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionWriteTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sActionReadTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    UtilityTestFunctions.EnumerateFilesFromStorage(STUtilTest.sRemotePath, uActionEnumMaxResults, STUtilTest.uTitleID);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch {}

                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath, STUtilTest.uTitleID);

            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\PositiveLocalFileCases.cs ===
using System;
using ServerTestFramework;
using System.IO;

namespace STUtilTest
{
    [TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
    public class PositiveLocalFileCases : TestNode
    {
        public static string sTestFile = "itembox.png";
        public static string sDataTestFile = "FFFFAB28.spa";
        public static string sTextTestFile = "FFFFAB28.spa.h";
        public static string sImageTestFile = "Halo2.png";
        public static string sLargeTestFile = "dolphin.png";
        public static string sSmallTestFile = "smallfile.txt";

        [TestCase]
        public class FileRelativePath : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    STUtilTest.sRemotePath + "/" + sTestFile,
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "out" + sTestFile), 
                    STUtilTest.sRemotePath + "/" + sTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath + "/" + sTestFile,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class FileFullPath : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileAbsolutePath, sTestFile),
                    STUtilTest.sRemotePath + "/" + sTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileAbsolutePath, "out" + sTestFile),
                    STUtilTest.sRemotePath + "/" + sTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath + "/" + sTestFile,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class FileData : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sDataTestFile),
                    STUtilTest.sRemotePath + "/" + sDataTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "out" + sDataTestFile), 
                    STUtilTest.sRemotePath + "/" + sDataTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath + "/" + sDataTestFile,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class FileText : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTextTestFile),
                    STUtilTest.sRemotePath + "/" + sTextTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "out" + sTextTestFile), 
                    STUtilTest.sRemotePath + "/" + sTextTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath + "/" + sTextTestFile,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class FileImage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sImageTestFile),
                    STUtilTest.sRemotePath + "/" + sImageTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "out" + sImageTestFile), 
                    STUtilTest.sRemotePath + "/" + sImageTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath + "/" + sImageTestFile,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// t_storage_domains domain Title bi_file_bytes_max size is 5242880
        /// </summary>
        [TestCase]
        public class FileLarge : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sLargeTestFile),
                    STUtilTest.sRemotePath + "/" + sLargeTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "out" + sLargeTestFile), 
                    STUtilTest.sRemotePath + "/" + sLargeTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath + "/" + sLargeTestFile,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class FileSmall : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sSmallTestFile),
                    STUtilTest.sRemotePath + "/" + sSmallTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "out" + sSmallTestFile), 
                    STUtilTest.sRemotePath + "/" + sSmallTestFile, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath + "/" + sSmallTestFile,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\InputFiles\FFFFAB28.spa.h ===
////////////////////////////////////////////////////////////////////
//
// FFFFAB28.spa.h
//
// Auto-generated on Friday, 12 May 2006 at 15:29:23
// XLAST project version 1.0.12.0
// SPA Compiler version 2.0.2732.0
//
////////////////////////////////////////////////////////////////////

#ifndef __BOB_S_CHEESE_ADVENTURE_SPA_H__
#define __BOB_S_CHEESE_ADVENTURE_SPA_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Title info
//

#define TITLEID_BOB_S_CHEESE_ADVENTURE              0xFFFFAB28

//
// Context ids
//
// These values are passed as the dwContextId to XUserSetContext.
//


//
// Context values
//
// These values are passed as the dwContextValue to XUserSetContext.
//

// Values for X_CONTEXT_PRESENCE

#define CONTEXT_PRESENCE_RP1                        0

// Values for X_CONTEXT_GAME_MODE

#define CONTEXT_GAME_MODE_GM1                       0

//
// Property ids
//
// These values are passed as the dwPropertyId value to XUserSetProperty
// and as the dwPropertyId value in the XUSER_PROPERTY structure.
//

#define PROPERTY_P1                                 0x20000001

//
// Achievement ids
//
// These values are used in the dwAchievementId member of the
// XUSER_ACHIEVEMENT structure that is used with
// XUserWriteAchievements and XUserCreateAchievementEnumerator.
//

#define ACHIEVEMENT_A1                              1
#define ACHIEVEMENT_A2                              2
#define ACHIEVEMENT_A3                              3
#define ACHIEVEMENT_A4                              4
#define ACHIEVEMENT_A5                              5

//
// Stats view ids
//
// These are used in the dwViewId member of the XUSER_STATS_SPEC structure
// passed to the XUserReadStats* and XUserCreateStatsEnumerator* functions.
//

// Skill leaderboards for ranked game modes

#define STATS_VIEW_SKILL_RANKED_GM1                 0xFFFF0000

// Skill leaderboards for unranked (standard) game modes

#define STATS_VIEW_SKILL_STANDARD_GM1               0xFFFE0000

// Title defined leaderboards

#define STATS_VIEW_LEADER1                          1

//
// Stats view column ids
//
// These ids are used to read columns of stats views.  They are specified in
// the rgwColumnIds array of the XUSER_STATS_SPEC structure.  Rank, rating
// and gamertag are not retrieved as custom columns and so are not included
// in the following definitions.  They can be retrieved from each row's
// header (e.g., pStatsResults->pViews[x].pRows[y].dwRank, etc.).
//

// Column ids for LEADER1

#define STATS_COLUMN_LEADER1_COL1                   1

//
// Matchmaking queries
//
// These values are passed as the dwProcedureIndex parameter to
// XSessionSearch to indicate which matchmaking query to run.
//


//
// Gamer pictures
//
// These ids are passed as the dwPictureId parameter to XUserAwardGamerTile.
//



#ifdef __cplusplus
}
#endif

#endif // __BOB_S_CHEESE_ADVENTURE_SPA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_stutiltest_none_12.4.56.0_none_26b1f951046c6c9c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=stutiltest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8.manifest
XP_MANIFEST_PATH=manifests\msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8.cat
XP_CATALOG_PATH=manifests\msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8.cat
XP_PAYLOAD_PATH=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=stutiltest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\PositiveAdditionalOptionsCases.cs ===
using System;
using ServerTestFramework;
using System.IO;

namespace STUtilTest
{
    [TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
    public class PositiveAdditionalOptionsCases : TestNode
    {
        public static string sTestFile = "FFFFAB28.xlast";
        public static string sTestTempFile = "FFFFAB28out.xlast";

        /// <summary>
        /// Signing is for Xbox 1 games
        /// </summary>
        [TestCase]
        public class ParameterSign : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID, false, true);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestTempFile), 
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch {}

                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath, STUtilTest.uTitleID);
            }
        }

        /// <summary>
        /// With -y on, the tool calls for a remove first before it writes, but if the remove fails
        /// it will just overwrite the data in there
        /// </summary>
        [TestCase]
        public class ParameterYOn : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID, true, false);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestTempFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch {}

                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath, STUtilTest.uTitleID);
            }
        }

        /// <summary>
        /// With -y off, it still overwrites, it just doesn't do the remove before overwriting
        /// </summary>
        [TestCase]
        public class ParameterYOff : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID, false, false);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestTempFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch {}

                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath, STUtilTest.uTitleID);
            }
        }

        /// <summary>
        /// -t parameter should always be used anyway, otherwise the title is written to the default
        /// titleid of XENON_DASH_TITLE_ID
        /// </summary>
        [TestCase]
        public class ParameterTOn : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestTempFile),
                        STUtilTest.sRemotePath,
                        STUtilTest.uTitleID);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch {}

                UtilityTestFunctions.RemoveFileFromStorage(STUtilTest.sRemotePath, STUtilTest.uTitleID);
            }
        }
        /* Removed due to won't fix bug...
        /// <summary>
        /// With no -t Parameter, TitleID used will be XENON_DASH_TITLE_ID of 0xFFFE07D1
        /// but we are also reading with the -t so it should find that title
        /// Also changing the -p://title/t:FFFE07D1 because if you use the same t: but don't use the 
        /// -t option, it will overwrite the value in the db
        /// </summary>
        [TestCase]
        public class ParameterTOff : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                // Grab the remote path and also find what the TitleID will be
                string strRemotePath = STUtilTest.sRemotePath;
                string strHexTitleID = String.Format("{0,8:X8}", STUtilTest.uTitleID);

                // Replace the TitleID with the XENON_DASH_TITLE_ID which is used
                // when you supply no -t:<TitleID> parameter.
                strRemotePath = strRemotePath.Replace(strHexTitleID, "FFFE07D1");

                try
                {
                    UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                        strRemotePath,
                        0);
                    UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestTempFile),
                        strRemotePath,
                        0);
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch {}

                UtilityTestFunctions.RemoveFileFromStorage(strRemotePath, 0);
            }
        }
         */
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_stutiltest_none_12.4.56.0_none_26b1f951046c6c9c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=stutiltest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8.manifest
XP_MANIFEST_PATH=manifests\msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8.cat
XP_CATALOG_PATH=manifests\msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8.cat
XP_PAYLOAD_PATH=msil_stutiltest_no-public-key_12.4.56.0_x-ww_6bbb55b8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=stutiltest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\PositiveStoragePathCases.cs ===
using System;
using ServerTestFramework;
using System.IO;

namespace STUtilTest
{
    [TestGroup, Owner("trevorm"), TestFrequency("Regression"), TestCasePriority(1)]
    public class PositiveStoragePathCases : TestNode
    {
        public static string sStoragePathTitle = "//title";
        public static string sStoragePathGlobal = "//global";
        public static string sStoragePathStats = "//stats";
        public static string sStoragePathMsg = "//msg";
        public static string sStoragePathXeStat = "//xestats";
        public static string sStoragePathTUser = "//tuser";
        public static string sStoragePathTTeam = "//tteam";
        public static string sStoragePathPics = "//pics";
        public static string sStoragePathVid = "//vid";
        public static string sTestFile = "itembox.png";
        public static string strHexTitleID = String.Format("{0,8:X8}", STUtilTest.uTitleID);

        /// <summary>
        /// -p full storage path requirements:  -p://title/t:FFFFAB28/<any text>
        /// title has no text restrictions in t_storage_domains
        /// </summary>
        [TestCase]
        public class TitleDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathTitle + STUtilTest.sRemotePathWithoutDB, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "title" + sTestFile), 
                    sStoragePathTitle + STUtilTest.sRemotePathWithoutDB, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathTitle + STUtilTest.sRemotePathWithoutDB,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// -p full storage path requirements:  -p://global/t:FFFFAB28/<ach|tile|icon|marketplace>/<1-8 hex char>/<1-16 hex char>
        /// e.g. -p://global/t:FFFFAB28/tile/FFFFAB28/11111111
        /// </summary>
        [TestCase]
        public class GlobalDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                Global.RO.Info(String.Format("Path={0}", STUtilTest.sInputFileRelativePath));
                Global.RO.Info(String.Format("File={0}", sTestFile));

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathGlobal + "/t:" + strHexTitleID + "/tile/" + strHexTitleID + "/11111111", 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "global" + sTestFile),
                    sStoragePathGlobal + "/t:" + strHexTitleID + "/tile/" + strHexTitleID + "/11111111",  
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathGlobal + "/t:" + strHexTitleID + "/tile/" + strHexTitleID + "/11111111", 
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// -p full storage path requirements: -p://stats/t:FFFFAB28/<1-8 hex char>/<8 hex char>-<4 hex>-<4 hex>-<4 hex>-<12 hex>
        /// or /Hex Title/GUID   e.g. -p://stats/t:FFFFAB28/FFFFAB28/11111111-1111-1111-1111-111111111111
        /// </summary>
        [TestCase]
        public class StatsDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathStats + "/t:" + strHexTitleID + "/" + strHexTitleID + "/11111111-1111-1111-1111-111111111111", 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "stats" + sTestFile),
                    sStoragePathStats + "/t:" + strHexTitleID + "/" + strHexTitleID + "/11111111-1111-1111-1111-111111111111",
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathStats + "/t:" + strHexTitleID + "/" + strHexTitleID + "/11111111-1111-1111-1111-111111111111",
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// -p full storage path requirements:  -p://msg/t:FFFFAB28/<any text>
        /// msg has no text restrictions in t_storage_domains
        /// </summary>
        [TestCase]
        public class MsgDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathMsg + STUtilTest.sRemotePathWithoutDB, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "msg" + sTestFile), 
                    sStoragePathMsg + STUtilTest.sRemotePathWithoutDB,  
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathMsg + STUtilTest.sRemotePathWithoutDB, 
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        /* Removing test cases because of won't fix on bug...
        /// <summary>
        /// -p full storage path requirements:  -p://xestats/t:FFFFAB28/<1-8 hex char>/<1-8 hex char>
        /// Bug 72500 - this currently does not work, client does not have rights to upload file 
        /// </summary>
        [TestCase]
            public class XeStatDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathXeStat + "/t:" + strHexTitleID + "/" + strHexTitleID + "/" + strHexTitleID, 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "xestats" + sTestFile),
                    sStoragePathXeStat + "/t:" + strHexTitleID + "/" + strHexTitleID + "/" + strHexTitleID,   
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathXeStat + "/t:" + strHexTitleID + "/" + strHexTitleID + "/" + strHexTitleID,  
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// -p full storage path requirements:  -p://tuser/t:FFFFAB28/<1-8 hex char>/<any non control chars>
        /// Bug 72500 - this currently does not work, client does not have rights to upload file 
        /// </summary>
        [TestCase]
        public class TUserDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathTUser + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001",
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "tuser" + sTestFile),
                    sStoragePathTUser + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001", 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathTUser + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001",
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// -p full storage path requirements:  -p://tteam/t:FFFFAB28/<1-8 hex char>/<1-16 hex>/<any non control chars>
        /// Bug 72500 - this currently does not work, client does not have rights to upload file 
        /// </summary>
        [TestCase]
        public class TTeamDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathTTeam + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001/00000001",
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "tteam" + sTestFile),
                    sStoragePathTTeam + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001/00000001", 
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathTTeam + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001/00000001",
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
        */

        /// <summary>
        /// -p full storage path requirements:  -p://pics/t:FFFFAB28/<1-8 hex char>/<any non control chars>
        /// e.g. -p://pics/t:FFFFAB28/FFFFAB28/00000001
        /// </summary>
        [TestCase]
        public class PicsDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathPics + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001",
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "pics" + sTestFile),
                    sStoragePathPics + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001",
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathPics + "/t:" + strHexTitleID + "/" + strHexTitleID + "/00000001",
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// -p full storage path requirements:  -p://vid/t:FFFFAB28/<any text>
        /// Video and Photo Message Attachments has no text restrictions in t_storage_domains
        /// </summary>
        [TestCase]
        public class VideoDBStorage : TestBase
        {
            override protected void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;

                UtilityTestFunctions.WriteFileToStorage(Path.Combine(STUtilTest.sInputFileRelativePath, sTestFile),
                    sStoragePathVid + STUtilTest.sRemotePathWithoutDB,
                    STUtilTest.uTitleID);
                UtilityTestFunctions.ReadFileFromStorage(Path.Combine(STUtilTest.sInputFileRelativePath, "vid" + sTestFile),
                    sStoragePathVid + STUtilTest.sRemotePathWithoutDB,
                    STUtilTest.uTitleID);
                UtilityTestFunctions.RemoveFileFromStorage(sStoragePathVid + STUtilTest.sRemotePathWithoutDB,
                    STUtilTest.uTitleID);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\Utility.cs ===
//#define UI


using System;
using System.ServiceProcess;
using System.Diagnostics;

namespace STUtilTest
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class UtilityTestFunctions
	{
		/// <summary>
		/// The Utility class to launch STUtil and pass parameters.
		/// </summary>
		
		public static void WriteFileToStorage(string localFileName, string storageFileName, ulong titleID)
		{
			string arguments;
			if (titleID == 0)
			{
				arguments = string.Format("-a:write -f:{0} -p:{1} -y", localFileName, storageFileName);
			}
			else
			{
				arguments = string.Format("-a:write -f:{0} -p:{1} -t:0x{2:x8} -y", localFileName, storageFileName, titleID);
			}
			WriteFileToStorage(arguments);
		}

		public static void WriteFileToStorage(string localFileName, string storageFileName, ulong titleID, bool overwrite, bool signparameter)
		{
			string arguments;
			if (titleID == 0)
			{
				arguments = string.Format("-a:write -f:{0} -p:{1}", localFileName, storageFileName);
			}
			else
			{
				arguments = string.Format("-a:write -f:{0} -p:{1} -t:0x{2:x8}", localFileName, storageFileName, titleID);
			}
			if(overwrite == true)
			{
				arguments += " -y";
			}
			if(signparameter == true)
			{
				arguments += " -sign";
			}
			WriteFileToStorage(arguments);
		}

		public static void WriteFileToStorage(string arguments)
		{
			Process stutil = new Process();
			stutil.StartInfo.FileName = STUtilTest.sToolPath;
			//stutil.StartInfo.FileName = "stutil.exe";
			stutil.StartInfo.Arguments = arguments;
			stutil.StartInfo.UseShellExecute = false;
			stutil.StartInfo.RedirectStandardOutput = true;

			stutil.Start();
			#if UI
			{
				StutilUIForm.WriteLog(stutil.StartInfo.FileName+ " " + stutil.StartInfo.Arguments);
				StutilUIForm.WriteLog(stutil.StandardOutput.ReadToEnd());
			}
			#endif
		
			Console.WriteLine();
			Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
			Console.WriteLine(stutil.StandardOutput.ReadToEnd());
		
			stutil.WaitForExit();
            
			if(stutil.ExitCode == 0) // success
			{
#if UI
				StutilUIForm.WriteLog("Success!!");
#endif
				Console.WriteLine("Success!!");
			}     
			else
			{
#if UI
				StutilUIForm.WriteLog("Failure!!");
#endif
				Console.WriteLine("Failure!!");
				throw new ApplicationException("Failure Writing to Storage");
			}
			System.Threading.Thread.Sleep(1000);
		}

		public static void ReadFileFromStorage(string localFileName, string storageFileName, ulong titleID)
		{
	            
			string arguments;
			if (titleID == 0)
			{
				arguments = string.Format("-a:read -f:{0} -p:{1} -y", localFileName, storageFileName);
			}
			else
			{
				arguments = string.Format("-a:read -f:{0} -p:{1} -t:0x{2:x8} -y", localFileName, storageFileName, titleID);
			}

			Process stutil = new Process();
			stutil.StartInfo.FileName = STUtilTest.sToolPath;
			//stutil.StartInfo.FileName = "stutil.exe";
			stutil.StartInfo.Arguments = arguments;
			stutil.StartInfo.UseShellExecute = false;
			stutil.StartInfo.RedirectStandardOutput = true;

			stutil.Start();
#if UI
		{
			StutilUIForm.WriteLog(stutil.StartInfo.FileName+ " " + stutil.StartInfo.Arguments);
			StutilUIForm.WriteLog(stutil.StandardOutput.ReadToEnd());
		}
#endif
			Console.WriteLine();
			Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
			Console.WriteLine(stutil.StandardOutput.ReadToEnd());

			stutil.WaitForExit();
            
			if(stutil.ExitCode == 0) // success
			{
#if UI
				StutilUIForm.WriteLog("Success!!");
#endif
				Console.WriteLine("Success!!");
			}     
			else
			{
#if UI
				StutilUIForm.WriteLog("Failure!!");
#endif
				Console.WriteLine("Failure!!");
				throw new ApplicationException("Failure Reading from Storage");
			}
			System.Threading.Thread.Sleep(1000);
		}

		public static void RemoveFileFromStorage(string storagePathName, ulong titleID)
		{
			string arguments;
			if (titleID == 0)
			{
				arguments = string.Format("-a:remove -p:{0} -y", storagePathName);
			}
			else
			{
				arguments = string.Format("-a:remove -p:{0} -t:0x{1:x8} -y", storagePathName, titleID);
			}

			Process stutil = new Process();
			stutil.StartInfo.FileName = STUtilTest.sToolPath;
			//stutil.StartInfo.FileName = "stutil.exe";
			stutil.StartInfo.Arguments = arguments;
			stutil.StartInfo.UseShellExecute = false;
			stutil.StartInfo.RedirectStandardOutput = true;

			stutil.Start();
#if UI
		{
			StutilUIForm.WriteLog(stutil.StartInfo.FileName+ " " + stutil.StartInfo.Arguments);
			StutilUIForm.WriteLog(stutil.StandardOutput.ReadToEnd());
		}
#endif
			Console.WriteLine();
			Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
			Console.WriteLine(stutil.StandardOutput.ReadToEnd());

			stutil.WaitForExit();
            
			if(stutil.ExitCode == 0) // success
			{
#if UI
				StutilUIForm.WriteLog("Success!!");
#endif
				Console.WriteLine("Success!!");
			}     
			else
			{
#if UI
				StutilUIForm.WriteLog("Failure!!");
#endif
				Console.WriteLine("Failure!!");
				throw new ApplicationException("Failure Removing from Storage");
			}
			System.Threading.Thread.Sleep(1000);
		}

		public static void EnumerateFilesFromStorage(string storagePathName, int maxResults, ulong titleID)
		{
			string arguments;
			if (titleID == 0 && maxResults == 0)
			{
				arguments = string.Format("-a:enum -p:{0}", storagePathName);
			}
			else if(maxResults == 0)
			{
				arguments = string.Format("-a:enum -p:{0} -t:0x{1:x8}", storagePathName, titleID);
			}
			else if(titleID == 0)
			{	
				arguments = string.Format("-a:enum -p:{0} -n:{1}", storagePathName, maxResults);
			}
			else
			{
				arguments = string.Format("-a:enum -p:{0} -t:0x{1:x8} -n:{2}", storagePathName, titleID, maxResults);
			}

			Process stutil = new Process();
			stutil.StartInfo.FileName = STUtilTest.sToolPath;
			//stutil.StartInfo.FileName = "stutil.exe";
			stutil.StartInfo.Arguments = arguments;
			stutil.StartInfo.UseShellExecute = false;
			stutil.StartInfo.RedirectStandardOutput = true;

			stutil.Start();
#if UI
		{
			StutilUIForm.WriteLog(stutil.StartInfo.FileName+ " " + stutil.StartInfo.Arguments);
			StutilUIForm.WriteLog(stutil.StandardOutput.ReadToEnd());
		}
#endif
			Console.WriteLine();
			Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
			Console.WriteLine(stutil.StandardOutput.ReadToEnd());

			stutil.WaitForExit();
            
			if(stutil.ExitCode == 0) // success
			{
#if UI
				StutilUIForm.WriteLog("Success!!");
#endif
				Console.WriteLine("Success!!");
			}     
			else
			{
#if UI
				StutilUIForm.WriteLog("Failure!!");
#endif
				Console.WriteLine("Failure!!");
				throw new ApplicationException("Failure Enumerating from Storage");
			}
			System.Threading.Thread.Sleep(1000);
		}

		protected static void Usage()
		{
			Console.Write(" \n Usage: stutil_test <action> <localFileName> <StoragePathName> \n" +
				          " where action - read/write, localFileName - file to be uploaded \n" + 
						  " StoragePathName - //title/t:fffe07d1/icon/0/800 & titleID - fffe07d1");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STUtilTest\STUtilTest.cs ===
using System;
using ServerTestFramework;
using System.Xml;
using System.IO;
using System.Reflection;

namespace STUtilTest
{
    // Should be renamed STUtilTestBase, but lots of references and not wanting to 
    // change the filename all over, it's staying STUTilTest
    abstract public class STUtilTest : TestBase
	{
		public static string sToolPath = "";
		public static string sInputFileRelativePath = "";
		public static string sInputFileAbsolutePath = "";
		public static string sRemoteStorage = "";
		public static string sRemotePath = "";
		public static string sRemotePathWithoutDB = "";
		public static ulong uTitleID;

        // Initializer, read config file information
		public STUtilTest()
		{
			if (sToolPath == "" || sRemotePath == "")
			{
				ReadConfig();
			}        
		}

		/// <summary>
		/// Fills the variables with the values from the STUtilTest.xml
		/// </summary>
		protected void ReadConfig()
		{
			XmlNode config = Global.Config.SelectSingleNode("descendant::STUtilTest");
			CTitleId tID;

			if (config != null)
			{
				XmlNode node = config.SelectSingleNode("DefaultToolPath");
				if (node != null)
				{
					sToolPath = System.IO.Path.Combine(node.InnerText, "STUtil.exe"); 
				}
				node = config.SelectSingleNode("InputFileRelativePath");
				if (node != null)
				{
					sInputFileRelativePath = node.InnerText;
				}
				node = config.SelectSingleNode("InputFileAbsolutePath");
				if (node != null)
				{
					//sInputFileAbsolutePath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), node.InnerText);
					sInputFileAbsolutePath = Path.Combine(Directory.GetCurrentDirectory(), node.InnerText);
				}
				node = config.SelectSingleNode("TitleID");
				if (node != null)
				{
					string title = node.InnerText;
					tID = new CTitleId(title);
					uTitleID = tID.uiTitleId;

					node = config.SelectSingleNode("RemoteStorage");
					if (node != null)
					{
						sRemoteStorage = node.InnerText;
					}
					node = config.SelectSingleNode("RemotePath");
					if (node != null)
					{
						sRemotePathWithoutDB = "/t:" + tID.sTitleIdHexNoPrefix + "/" + node.InnerText;
						sRemotePath =  "//" + sRemoteStorage + sRemotePathWithoutDB;
					}
					tID = null;
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\BuddyGroup.cs ===
// BuddyGroup.cs
//
//	A group of users used by widget functional tests
//

using System;
using System.Xml;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;


namespace svctunnelfunctional
{
	////////////////////////////////////////////////
	// Buddy Group
	//	Sets up and manipulate a user's group of buddies
	//
	class BuddyGroup
	{
		public enum Hash   { Same, Diff };
		public enum Status { Online, Offline };

		public PNUser   User;
		public PNUser[] BuddiesOnSame;
		public PNUser[] BuddiesOnDiff;


		public static void WaitCache()
		{
			new SleepInfo( 
				"Waiting for Cache to update",
				(uint)(1000 * (UserStore.CacheExpDelay + 15)));
		}

		/////////////////////////////////////////////
		// Total counts
		//	 Max buddies 
		byte Same
		{
			get{ return (byte)( BuddiesOnSame.Length ); }
		}
		byte Diff
		{
			get{ return (byte)( BuddiesOnDiff.Length ); }
		}

		/////////////////////////////////////////////
		// Deleted counts
		//	 Number deleted regardless of current onlline status
		byte SameDeleted = 0;
		byte DiffDeleted = 0;
		byte Deleted
		{ 
			get{ return (byte)( SameDeleted + DiffDeleted ); } 
		}

		/////////////////////////////////////////////
		// Online / Offline  counts
		//
		// ... Number online regardless of current buddy status
		byte SameOnline = 0;
		byte DiffOnline = 0;
		// ... Number offline regardless of current buddy status
		byte SameOffline
		{
			get{ return (byte)( BuddiesOnSame.Length - SameOnline ); }
		}
		byte DiffOffline
		{
			get{ return (byte)( BuddiesOnDiff.Length - DiffOnline ); }
		}
		// ... Total current buddies online
		public byte Online 
		{
			get{ return (byte)( (SameOnline + DiffOnline) - Deleted ); }
		}
		// ... Total current buddies offline
		public byte Offline
		{
			get{ return (byte)( (SameOffline + DiffOffline) - Deleted ); }
		}

		////////////////////////////////////////////////
		// Ctor
		//	Grabs a user and sets up buddy lists.  
		//	Everybody ends up logged off.
		//
		public BuddyGroup( Stack[] userPools, Stack[] buddyPools, int same, int other )
		{
			// Try to balance pool usage 
			int iPoolSame = (userPools[0].Count > userPools[1].Count) ? 0 : 1;
			int iPoolDiff = (iPoolSame == 0) ? 1 : 0;
	
			// Get the main linked user
			User = (PNUser) userPools[ iPoolSame ].Pop();
			UserStore.Friends.LogonUser( User );

			ConsoleX.WriteLine( "Creating buddy group for "+User.Name );

			// Add buddies from the same INH
			BuddiesOnSame = new PNUser[ same ];
			for( int i = 0; i < same; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Adding buddy "+(i+1)+"\r" );

				BuddiesOnSame[i] = (PNUser) buddyPools[ iPoolSame ].Pop();
				UserStore.Friends.LogonUser( BuddiesOnSame[i] );
				UserStore.Friends.MakeFriend( User, BuddiesOnSame[i] );
				UserStore.Friends.LogoffUser( BuddiesOnSame[i] );
			}
			ConsoleX.ClearLine();
			ConsoleX.WriteLine( "   Buddies with same hash: "+BuddiesOnSame.Length );

			// Add buddies from another INH
			BuddiesOnDiff = new PNUser[ other ];
			for( int i = 0; i < other; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Adding buddy "+(i+1)+"\r" );

				BuddiesOnDiff[i] = (PNUser) buddyPools[ iPoolDiff ].Pop();
				UserStore.Friends.LogonUser( BuddiesOnDiff[i] );
				UserStore.Friends.MakeFriend( User, BuddiesOnDiff[i] );
				UserStore.Friends.LogoffUser( BuddiesOnDiff[i] );
			}
			ConsoleX.ClearLine();
			ConsoleX.WriteLine( "   Buddies with different hash: "+BuddiesOnDiff.Length );
			
			// Logoff User
			UserStore.Friends.LogoffUser( User );
		}

		//////////////////////////////////////////////
		// Get Buddy 
		//	Returns the indexed non deleted budddy with the given status
		//	  from the specified list
		//
		public PNUser GetBuddy( int index, Hash hash, Status status )
		{
			PNUser[] buddyList = (hash==Hash.Same) ? BuddiesOnSame : BuddiesOnDiff;
			
			int i = index + ((hash==Hash.Same) ? SameDeleted : DiffDeleted);
			if( status == Status.Offline )
				i += ((hash==Hash.Same) ? SameOnline : DiffOnline);

			return buddyList[ i ];
		}

		////////////////////////////////////////////////
		// Check Web Friends 
		//	Validates the contents of a Web Freinds reply
		//
		public void CheckWebFriends( WebFriendData wf )
		{
			wf.CheckCount( Online, Offline );
			for( int i = 0; i < SameOnline; ++i )
			{
				wf.CheckUser( GetBuddy( i, Hash.Same, Status.Online ) );
			}
			for( int i = 0; i < DiffOnline; ++i )
			{
				wf.CheckUser( GetBuddy( i, Hash.Diff, Status.Online ) );
			}
			for( int i = 0; i < SameOffline; ++i )
			{
				wf.CheckUser( GetBuddy( i, Hash.Same, Status.Offline ) );
			}
			for( int i = 0; i < DiffOffline; ++i )
			{
				wf.CheckUser( GetBuddy( i, Hash.Diff, Status.Offline ) );
			}
		}

		////////////////////////////////////////////////
		// Logon All
		//
		public void LogonAll( bool waitForCache )
		{
			SetLoggedOn( Same, Diff, waitForCache );
		}

		////////////////////////////////////////////////
		// Logoff All
		//
		public void LogoffAll( bool waitForCache )
		{
			SetLoggedOn( 0, 0, waitForCache );
		}

		////////////////////////////////////////////////
		// Set Logged On
		//	Logs buddies on or off to match amounts given.
		//	starting from begining of buddy arrays and working up 
		//
		public void SetLoggedOn( byte same, byte other )                    { SetLoggedOn( same, other, 10, true ); }
		public void SetLoggedOn( byte same, byte other, bool waitForCache ) { SetLoggedOn( same, other, 10, waitForCache ); }
		public void SetLoggedOn( byte same, byte other, uint titleId, bool waitForCache )
		{
			// Check if anything is going to change and bail if it isn't
			if( (SameOnline == same) && (DiffOnline == other) )
				return;

			// Logon some from same
			while( SameOnline < same )
			{
				ConsoleX.ClearLine();
				Console.Write( "Logging on same hash buddy: "+(SameOnline+1)+", Target: "+same+"\r" );
				UserStore.Friends.LogonUser( BuddiesOnSame[ SameOnline ], titleId );
				BuddiesOnSame[ SameOnline ].SetTitleData( XonPresNoti.P_STATE_MASK_ONLINE );
				++SameOnline;
			}
			// ... or logoff some from same
			while( SameOnline > same )
			{
				--SameOnline;
				ConsoleX.ClearLine();
				Console.Write( "Logging off same hash buddy: "+(SameOnline+1)+", Target: "+same+"\r" );
				UserStore.Friends.LogoffUser( BuddiesOnSame[ SameOnline ] );
			}

			// Logon some from other
			while( DiffOnline < other )
			{
				ConsoleX.ClearLine();
				Console.Write( "Logging on different hash buddy: "+(DiffOnline+1)+", Target: "+other+"\r" );
				UserStore.Friends.LogonUser( BuddiesOnDiff[ DiffOnline ], titleId );
				BuddiesOnDiff[ DiffOnline ].SetTitleData( XonPresNoti.P_STATE_MASK_ONLINE );
				++DiffOnline;
			}
			// ... or logoff some from other
			while( DiffOnline > other )
			{
				--DiffOnline;
				ConsoleX.ClearLine();
				Console.Write( "Logging off different hash buddy: "+(DiffOnline+1)+", Target: "+other+"\r" );
				UserStore.Friends.LogoffUser( BuddiesOnDiff[ DiffOnline ] );
			}

			ConsoleX.ClearLine();

			if( waitForCache )
			{
				WaitCache();
			}
		}
	
		////////////////////////////////////////////////
		// Delete All Buddies
		//
		public void DeleteAllBuddies( bool waitForCache )
		{
			SetDeleted( Same, Diff, waitForCache );
		}

		////////////////////////////////////////////////
		// Restore All Buddies 
		//
		public void RestoreAllBuddies( bool waitForCache )
		{
			SetDeleted( 0, 0, waitForCache );
		}
		
		////////////////////////////////////////////////
		// Delete Buddy
		//	Deletes or fully accepts buddies to match amounts given
		//	starting from begining of buddy arrays and working up 
		//
		public void SetDeleted( byte same, byte other ) { SetDeleted( same, other, true ); }
		public void SetDeleted( byte same, byte other, bool waitForCache )
		{
			// Check if anything is going to change and bail if it isn't
			if( (SameDeleted == same) && (DiffDeleted == other) )
				return;

			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				UserStore.Friends.LogonUser( User );
			}

			// Delete some from same
			while( SameDeleted < same )
			{
				ConsoleX.ClearLine();
				Console.Write( "Deleting same hash buddy: "+(SameDeleted+1)+", Deleted Target: "+same+"\r" );
				UserStore.Friends.DeleteFriend( User, BuddiesOnSame[ SameDeleted ] );
				SameDeleted++;
			}
			// ... or Add back some from same
			while( SameDeleted > same )
			{
				--SameDeleted;
				ConsoleX.ClearLine();
				Console.Write( "Adding same hash buddy: "+(SameDeleted+1)+", Deleted Target: "+same+"\r" );
				UserStore.Friends.MakeFriend( User, BuddiesOnSame[ SameDeleted ] );
			}

			// Delete  some from other
			while( DiffDeleted < other )
			{
				ConsoleX.ClearLine();
				Console.Write( "Deleting same different buddy: "+(DiffDeleted+1)+", Deleted Target: "+other+"\r" );
				UserStore.Friends.DeleteFriend( User, BuddiesOnDiff[ DiffDeleted ] );
				DiffDeleted++;
			}
			// ... or add back some from other
			while( DiffDeleted > other )
			{
				--DiffDeleted;
				ConsoleX.ClearLine();
				Console.Write( "Adding different hash buddy: "+(DiffDeleted+1)+", Deleted Target: "+other+"\r" );
				UserStore.Friends.MakeFriend( User, BuddiesOnDiff[ DiffDeleted ] );
			}

			if( ! userLoggedOn )
			{
				UserStore.Friends.LogoffUser( User );
			}

			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}

		////////////////////////////////////////////////
		// Request to Deleted 
		//	Makes requests to specified number of deleted buddies 
		//	starting with last deleted buddy and working down
		//
		public void RequestToDeleted( byte same, byte other ) { RequestToDeleted( same, other, true ); }
		public void RequestToDeleted( byte same, byte other, bool waitForCache )
		{
			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				UserStore.Friends.LogonUser( User );
			}

			for( int i = 0; i < same; ++i )
			{
				--SameDeleted;					
				ConsoleX.ClearLine();
				Console.Write( "Requesting same hash buddy: "+(i+1)+", Target: "+same+"\r" );
				UserStore.Friends.RequestFriend( User, BuddiesOnSame[ SameDeleted ] );
			}

			for( int i = 0; i < other; ++i )
			{
				--DiffDeleted;					
				ConsoleX.ClearLine();
				Console.Write( "Requesting different hash buddy: "+(i+1)+", Target: "+same+"\r" );
				UserStore.Friends.RequestFriend( User, BuddiesOnDiff[ DiffDeleted ] );
			}
			
			if( ! userLoggedOn )
			{
				UserStore.Friends.LogoffUser( User );
			}

			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}

		////////////////////////////////////////////////
		// Request from Deleted 
		//	Gets requests from specified number of deleted buddies
		//	starting with last deleted buddy and working down
		//
		public void RequestFromDeleted( byte same, byte other ) { RequestFromDeleted( same, other, true ); }
		public void RequestFromDeleted( byte same, byte other, bool waitForCache )
		{
			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				UserStore.Friends.LogonUser( User );
			}

			for( int i = 0; i < same; ++i )
			{
				--SameDeleted;					
				ConsoleX.ClearLine();
				Console.Write( "Requesting same hash buddy: "+(i+1)+", Target: "+same+"\r" );
				UserStore.Friends.RequestFriend( BuddiesOnSame[ SameDeleted ], User );
			}

			for( int i = 0; i < other; ++i )
			{
				--DiffDeleted;					
				ConsoleX.ClearLine();
				Console.Write( "Requesting different hash buddy: "+(i+1)+", Target: "+same+"\r" );
				UserStore.Friends.RequestFriend( BuddiesOnDiff[ DiffDeleted ], User );
			}

			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}

		////////////////////////////////////////////////
		// Reject Requested 
		//	Rejects request from specified number of buddies 
		//	starting with first non deleted buddy and working up
		//
		public void RejectRequested( byte same, byte other ) { RejectRequested( same, other, true ); }
		public void RejectRequested( byte same, byte other, bool waitForCache )
		{
			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				UserStore.Friends.LogonUser( User );
			}

			for( int i = 0; i < same; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Rejecting ame hash buddy: "+(i+1)+", Target: "+same+"\r" );
				UserStore.Friends.RejectFriend( User, BuddiesOnSame[ SameDeleted ] );
				DiffDeleted++;					
			}

			for( int i = 0; i < other; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Rejecting different hash buddy: "+(i+1)+", Target: "+same+"\r" );
				UserStore.Friends.RejectFriend( User, BuddiesOnDiff[ DiffDeleted ] );
				DiffDeleted++;					
			}
			
			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}
	
		////////////////////////////////////////////////
		// Accept Requested 
		//	Accepts a request from specified number of buddies 
		//	starting with first non deleted buddy and working up
		//
		public void AcceptRequested( byte same, byte other ) { AcceptRequested( same, other, true ); }
		public void AcceptRequested( byte same, byte other, bool waitForCache )
		{
			bool userLoggedOn = User.LoggedOn;
			if( ! userLoggedOn )
			{
				UserStore.Friends.LogonUser( User );
			}

			for( int i = 0; i < same; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Accepting same hash buddy: "+(i+1)+", Target: "+same+"\r" );
				UserStore.Friends.AcceptFriend( User, BuddiesOnSame[ SameDeleted+i ] );
			}

			for( int i = 0; i < other; ++i )
			{
				ConsoleX.ClearLine();
				Console.Write( "Accepting different hash buddy: "+(i+1)+", Target: "+same+"\r" );
				UserStore.Friends.AcceptFriend( User, BuddiesOnDiff[ DiffDeleted+i ] );
			}
			
			ConsoleX.ClearLine();
			
			if( waitForCache )
			{
				WaitCache();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\makefile.inc ===
!if !defined(VSTUDIO_POSTBUILD)
!include $(INETROOT)\build\makefile.inc

!if defined(PASS2)

bin\$(TARGETNAME).exe: $(URTTARGET)
        copy $** $@
        copy $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb bin\$(TARGETNAME).pdb

$(O)\$(TARGETNAME).xml: $(O)\$(TARGETNAME).exe

!else

$(O)\$(TARGETNAME).xml:

bin\$(TARGETNAME).exe:

!endif
!endif

!if defined(VSTUDIO_POSTBUILD)

all: FakeSGService.exe stf.xml stf_dn2.xml

FakeSGService.exe: $(BASEDIR)\private\test\stftests\stfrunner\fakesgservice.exe
        -robocopy $(BASEDIR)\private\test\stftests\stfrunner . fakesgservice.exe /R:0 /NP /NJS /NJS /A-:R

stf.xml: $(BASEDIR)\private\test\stftests\stfrunner\stf.xml
        -robocopy $(BASEDIR)\private\test\stftests\stfrunner . stf.xml /R:0 /NP /NJS /NJS /A-:R

stf_dn2.xml: $(BASEDIR)\private\test\stftests\stfrunner\stf_dn2.xml
        -robocopy $(BASEDIR)\private\test\stftests\stfrunner . stf_dn2.xml /R:0 /NP /NJS /NJS /A-:R

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\Func_Health.cs ===
using System;
using ServerTestFramework;

namespace svctunnelfunctional
{
	/// <summary>
	/// Contains the basic functionality tests for the Health widget.
	/// </summary>
	/// <remarks>
	/// <API>public void Heartbeat()</API>
	/// <Component>Health</Component>
	/// </remarks>
	#region public class Func_Health_Heartbeat : TestNode
	public class Func_Health_Heartbeat : TestNode
	{
		/// <summary>
		///		Calls Heartbeat
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget succeeds on a heartbeat under normal circumstances.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Call Health.Heartbeat" )]
			class Health_Heartbeat : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				Widgets.Health(null).Heartbeat();
			}
		}
	}
	#endregion

	/// <summary>
	/// Contains the basic functionality tests for the VerifyConfig widget.
	/// </summary>
	/// <remarks>
	/// <API>public string VerifyConfig()</API>
	/// <Component>Health</Component>
	/// </remarks>
	#region public class Func_Health_VerifyConfig : TestNode
	public class Func_Health_VerifyConfig : TestNode
	{
		/// <summary>
		///		Calls VerifyConfig
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget succeeds on a heartbeat under normal circumstances.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Call Health.VerifyConfig" )]
			class Health_VerifyConfig : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				string s = Widgets.Health(null).VerifyConfig();
				if(s != "OK!")
					throw new Exception("Health.VerifyConfig returned: " + s);
			}
		}
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\SVCStress.cs ===
using System;
using System.Collections;
using System.Threading;
using Presence;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.PresNotiCommon;

namespace svctunnelfunctional
{
	//
	// GetFriends
	/// <summary>
	/// Gets the friends list for a given user
	/// </summary>
	[StressTest(Priority=1)]
    [StressInstantiate]
	public class GetFriends : TestBase
	{
		/// <summary>
		/// Execute code
		/// </summary>
		protected override void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			// Get a user
			uint modifier = ((uint)(new Random()).Next())%StressHelper.userSet.Count;
			System.UInt64 userID1 = StressHelper.userSet.IndexToPuid(modifier);

			try
			{
				Widgets.Presence(Widgets.GetAuthData(userID1)).GetFriendsFromList(userID1, new ulong [] {}, 1);
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	//
	// SetNotificationState
	/// <summary>
	/// Changes the notification state for a user from the list 
	/// </summary>
	[StressTest(Priority=1)]
    [StressInstantiate]
	public class SetNotificationState : TestBase
	{
		static byte [] sampleState = new byte [] {    0,  1,  2,  3,  4,  5,  6,  7,  
													 8,  9, 10, 11, 12, 13, 14, 15,
													 16, 17, 18, 19, 20, 21, 22, 23,
													 24, 25, 26, 27, 28, 29, 30, 31};
		/// <summary>
		/// Execute code
		/// </summary>
		protected override void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			// Get the users
			uint modifier = ((uint)(new Random()).Next())%StressHelper.userSet.Count;
			System.UInt64 userID1 = StressHelper.userSet.IndexToPuid(modifier);
			string gamertag = StressHelper.userSet.IndexToGamertag(modifier);

			try
			{
				PNUser u = new PNUser(gamertag, userID1);
				uint i = StressHelper.fc.LogonUser(u);
				Widgets.Presence(Widgets.GetAuthData(userID1)).SetNotificationState(userID1, 0x1b, 0xDEADBEEFBEADFEED, sampleState);
			}
			catch(Exception e)
			{
				Console.WriteLine(e.ToString());
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	//
	// GetUserId
	/// <summary>
	/// Verifies the PUID returned for a given gamertag is correct.
	/// </summary>
	[StressTest(Priority=1)]
    [StressInstantiate]
	public class GetUserId : TestBase
	{
		/// <summary>
		/// Execute code
		/// </summary>
		protected override void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;
				
			uint modifier = ((uint)(new Random()).Next())%StressHelper.userSet.Count;
			ulong userPuid = StressHelper.userSet.IndexToPuid(modifier);
			string agt = StressHelper.userSet.IndexToGamertag(modifier);
			ulong puid = Widgets.Accounts(null).GetUserId(agt);
			if(puid != userPuid)
				ResultCode = TEST_RESULTS.FAILED;
		}
	}

	//
	// HeartBeat
	/// <summary>
	/// One ping, one ping only.
	/// </summary>
	[StressTest(Priority=1)]
    [StressInstantiate]
	public class HeartBeat : TestBase
	{
		/// <summary>
		/// Execute code
		/// </summary>
		protected override void Execute()
		{
			// Heartbeat
			ResultCode=TEST_RESULTS.PASSED;
				
			Widgets.Health(null).Heartbeat();
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\Func_Accounts.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using System.Text;

namespace svctunnelfunctional
{
	/// <summary>
	/// This contains all the test cases for GetUserInfo.
	/// </summary>
	/// <remarks>
	/// <Component>Accounts</Component>
	/// </remarks>
	#region Accounts.GetUserInfo Tests
	public class Func_Accounts_GetUserInfo : TestNode
	{
		/// <summary>
		///		GetUserInfo valid user no auth data
		///	</summary>
		///	<remarks>
		///		<Description>
		///			Call GetUserInfo with a valid user puid, but no auth data
		///		</Description>
		///		<Verify>
		///			Failure
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo no auth data" )]
			class Accounts_GetUserInfo_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong puid = u.UserPuid;
				try
				{
					Accounts.UserInfo ui = Widgets.Accounts(null).GetUserInfo(puid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		GetUserInfo valid user mismatched auth data
		///	</summary>
		///	<remarks>
		///		<Description>
		///			Call GetUserInfo with a valid user puid, but mismatched auth data
		///		</Description>
		///		<Verify>
		///			Failure
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo mismatched auth data" )]
			class Accounts_GetUserInfo_Negative_MisMatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong puid = u.UserPuid;
				try
				{
					Accounts.UserInfo ui = Widgets.Accounts(Widgets.GetAuthData(1)).GetUserInfo(puid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a valid user can have GetUserInfo retrieve the correct information for the user
		///	</summary>
		///	<remarks>
		///		Takes a valid user that are within boundary constraints and retrieves the users information and
		///		validates it is correct against what was sent to the server.
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo basic positive test case" )]
		class Accounts_GetUserInfo_Positive : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong puid = u.UserPuid;
				Accounts.UserInfo ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);

				if(!u.Compare(ui))
					throw new Exception("Field mismatch between created user and returned information from GetUserInfo.");
			}
		}


		/// <summary>
		///		Verifies that a valid 360 user can have GetUserInfo retrieve the correct information for
		///		a user without a payment instrument.
		///	</summary>
		///	<remarks>
		///		Takes a valid user that are within boundary constraints and retrieves the users information and
		///		validates it is correct against what was sent to the server.
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo basic positive test case" )]
			class Accounts_GetUserInfo_No_Payment_Instrument : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				Accounts.UserInfo ui;

				XeUser x360 = new XeUser();
				ulong puid = x360.Create();

				if (puid == 0)
				{
					ResultCode=TEST_RESULTS.FAILED;
					throw new UnexpectedTestResultException("XeUser.Create() failed: " + x360.GetDumpString());
				}

				try
				{
					ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);
				}
				catch(Exception e)
				{
					Console.WriteLine(e.ToString());
					ResultCode=TEST_RESULTS.FAILED;
				}
			}
		}

		/// <summary>
		///		Verifies that a valid minor user can have GetUserInfo retrieve the correct information for the user
		///	</summary>
		///	<remarks>
		///		Takes a valid minor user that are within boundary constraints and retrieves the users information and
		///		validates it is correct against what was sent to the server.
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo minor account positive test case" )]
		class Accounts_GetUserInfo_Positive_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong puid = u.UserPuid;
				Accounts.UserInfo ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);

				if(!u.Compare(ui))
					throw new Exception("Field mismatch between created user and returned information from GetUserInfo.");
			}
		}

		/// <summary>
		///		Verifies that an invalid user puid results in an error
		///	</summary>
		///	<remarks>
		///		Takes a non-existent puid and attempts to get user info on it.
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo invalid user" )]
			class Accounts_GetUserInfo_Negative_InvalidPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				try
				{
					Accounts.UserInfo ui = Widgets.Accounts(Widgets.GetAuthData(1)).GetUserInfo(1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that an opted out user works
		///	</summary>
		///	<remarks>
		///		Takes a user that has opted out and verify the api returns all the data
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo opted out user works" )]
			class Accounts_GetUserInfo_Positive_OptedOut : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.OptedOut];
				ulong puid = u.UserPuid;
				Accounts.UserInfo ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);

				if(!u.Compare(ui))
					throw new Exception("Field mismatch between created user and returned information from GetUserInfo.");
			}
		}

		/// <summary>
		///		Verifies that an queued user fails
		///	</summary>
		///	<remarks>
		///		Takes a user that is queued and verify that an error is returned
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo queued user results in a failure" )]
			class Accounts_GetUserInfo_Negative_Queued : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				Accounts.UserInfo ui;

				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.Queued];
				ulong puid = u.UserPuid;
				try
				{
					ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);
				}
				catch // (System.Exception e)
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Reserved user name
		///	</summary>
		///	<remarks>
		///		Takes a puid for a reserved user and verify it fails
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo reserved user fails" )]
			class Accounts_GetUserInfo_Negative_Reserved : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				Accounts.UserInfo ui;

				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.Reserved];
				ulong puid = u.UserPuid;
				try
				{
					ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);
				}
				catch // (System.Exception e)
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a suspended user fails
		///	</summary>
		///	<remarks>
		///		Takes a user that is suspended (billing wise) and verify that an error is returned
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo suspended user results in a failure" )]
		[Ignore]
			class Accounts_GetUserInfo_Negative_Suspended : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				Accounts.UserInfo ui;

				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.Expired];
				ulong puid = u.UserPuid;
				try
				{
					ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}


		/// <summary>
		///		Verifies that a suspended user fails
		///	</summary>
		///	<remarks>
		///		Takes a user that is canceled (billing wise) and verify that an error is returned
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo canceled user results in a failure" )]
		[Ignore]
			class Accounts_GetUserInfo_Negative_Canceled : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				Accounts.UserInfo ui;

				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.Canceled];
				ulong puid = u.UserPuid;
				try
				{
					ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that user with a pending FNC succeeds
		///	</summary>
		///	<remarks>
		///		Success
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo fnc'd user results in a success" )]
			class Accounts_GetUserInfo_Positive_FNCPending : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				Accounts.UserInfo ui;

				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChangePending];
				ulong puid = u.UserPuid;
				ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);
				if(!u.Compare(ui))
					throw new Exception("Field mismatch between created user and returned information from GetUserInfo.");
			}
		}

		/// <summary>
		///		Verifies that a user that has changed their name succeeds
		///	</summary>
		///	<remarks>
		///		Success
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserInfo fnc'd user results in a success" )]
			class Accounts_GetUserInfo_Positive_FNC : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				Accounts.UserInfo ui;

				UserInfo u = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChanged];
				ulong puid = u.UserPuid;
				ui = Widgets.Accounts(Widgets.GetAuthData(puid)).GetUserInfo(puid);
				if(!u.Compare(ui))
					throw new Exception("Field mismatch between created user and returned information from GetUserInfo.");
			}
		}
	}
	#endregion

	/// <summary>
	/// This contains all the test cases for SendUserFeedback.
	/// </summary>
	/// <remarks>
	/// <Component>Accounts</Component>
	/// </remarks>
	#region Accounts.SendUserFeedback Tests
	public class Func_Accounts_SendUserFeedback : TestNode
	{
		/// <summary>
		///		SendUserFeedback, no auth data
		///	</summary>
		///	<remarks>
		///		<Description>
		///			Calls SendUserFeedback with entirely valid params, but no auth data in the headers
		///		</Description>
		///		<Verify>
		///			Failure
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback adult to minor" )]
			class Accounts_SendUserFeedback_Negative_Adult_To_Minor_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(null).SendUserFeedback(0xa7049955, apuid, bpuid, 1, "1234567890123456789012");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		SendUserFeedback, mismatched auth data (userid)
		///	</summary>
		///	<remarks>
		///		<Description>
		///			Calls SendUserFeedback with entirely valid params, but mismatched auth data (user id) in the headers
		///		</Description>
		///		<Verify>
		///			Failure
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback mismatched auth data (user id)" )]
			class Accounts_SendUserFeedback_Negative_MismatchAuthDataUserID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(1, 0xa7049955)).SendUserFeedback(0xa7049955, apuid, bpuid, 1, "123456789");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		SendUserFeedback, mismatched auth data (titleid)
		///	</summary>
		///	<remarks>
		///		<Description>
		///			Calls SendUserFeedback with entirely valid params, but mismatched auth data (titleid) in the headers
		///		</Description>
		///		<Verify>
		///			Failure
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback mismatched auth data (titleid)" )]
			class Accounts_SendUserFeedback_Negative_MismatchAuthDataTitleID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid, 1)).SendUserFeedback(0xa7049955, apuid, bpuid, 1, "123456789");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with valid params (adult to minor, max length string, existing title id) works
		///	</summary>
		///	<remarks>
		///		Passes an existing title id, a valid adult &amp; minor account, and a max length string for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback adult to minor" )]
			class Accounts_SendUserFeedback_Positive_Adult_To_Minor_NickName_HighBoundary : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xa704995, apuid, bpuid, 1, "1234567Foo123456789012");
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with valid params (adult to minor, empty string, existing title id) works
		///	</summary>
		///	<remarks>
		///		Passes an existing title id, a valid adult &amp; minor account, and an empty string for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback adult to minor" )]
			class Accounts_SendUserFeedback_Positive_Adult_To_Minor_NickName_Empty : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xa704995, apuid, bpuid, 1, "");
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with valid params (minor to adult, empty string, existing title id) works
		///	</summary>
		///	<remarks>
		///		Passes an existing title id, a valid adult &amp; minor account, and an empty string for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback minor to adult test case" )]
			class Accounts_SendUserFeedback_Positive_Minor_To_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xa704995, apuid, bpuid, 1, "");
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with only an invalid title id (nonexistent)
		///	</summary>
		///	<remarks>
		///		Passes an non-existent title id, a valid adult &amp; minor account, and an empty string for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback non-existent title id" )]
		[Ignore]
			class Accounts_SendUserFeedback_Negative_Nonexistent_TitleID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xF01111FE, apuid, bpuid, 1, "");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with only an invalid from user id (nonexistent)
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a non-existent from id, valid to userid, and an empty string for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback invalid from user id" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Nonexistent_FromUserID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = 1, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with only an invalid to user id (nonexistent)
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid from id, non-existent to userid, and an empty string for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback invalid to user id" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Nonexistent_ToUserID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = b.UserPuid, bpuid = 1;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with only an invalid feedbacktype (nonexistent)
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid from id, valid to userid, invalid feedback type, and an empty string for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback invalid feedback type" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Invalid_FeedbackType : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				// Feedback type was specifically chosen so if it is case to something shorter it will appear valid when it shouldn't
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 0x10001, "");
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with only an invalid nickname (null)
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid from id, valid to userid, valid feedback type, and null for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback null nickname" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Null_Nickname : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, null);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with only an invalid nickname (too long)
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid from id, valid to userid, invalid feedback type, and an too long string for a nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback too long nickname" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_TooLong_Nickname : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "12345678901234567890123");
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback to yourself
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid from id, valid to userid that is the same as the from, valid feedback type, and a valid nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback to self" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Self : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, apuid, 1, "1234567890123456789012");
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with a queued from user
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid but queued from id, valid to userid, valid feedback type, and valid nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback queued from user" )]
			class Accounts_SendUserFeedback_Positive_Queued_FromUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Queued];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "1234567890");
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with a suspended from user
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid but suspended from id, valid to userid, valid feedback type, and valid nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback suspended from user" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Suspended_FromUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Expired];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "1234567890");
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with a canceled from user
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid but canceled from id, valid to userid, valid feedback type, and valid nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback canceled from user" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Canceled_FromUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Canceled];
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "1234567890");
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with a queued to user
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid from id, valid but queued to userid, valid feedback type, and valid nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback queued to user" )]
			class Accounts_SendUserFeedback_Positive_Queued_ToUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.Queued];
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "1234567890");
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with a suspended to user
		///	</summary>
		///	<remarks>
		///		Passes an valid title id, a valid from id, valid but suspended to userid, valid feedback type, and valid nickname
		///		Expected success
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback suspended to user" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Suspended_ToUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.Expired];
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "1234567890");
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Verifies that a call to SendUserFeedback with a canceled to user
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gamertag for a canceled account as the to puid.
		///		</Description>
		///		<Verify>
		///		The service should log an event and return a properly formatted SOAP error to the client with an HRESULT indicating failure.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.SendUserFeedback canceled to user" )]
			[Ignore]
			class Accounts_SendUserFeedback_Negative_Canceled_ToUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo b = UserStore.SpecialUsers[(int) UserStore.Specials.Canceled];
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid, bpuid = b.UserPuid;
				try
				{
					Widgets.Accounts(Widgets.GetAuthData(apuid)).SendUserFeedback(0xA7049955, apuid, bpuid, 1, "1234567890");
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

	}
	#endregion

	/// <summary>
	/// This contains all the test cases for GetGamertag.
	/// </summary>
	/// <remarks>
	/// <Component>Accounts</Component>
	/// <API>public string GetGamertag(ulong userId)</API>
	/// </remarks>
	#region Accounts.GetGamertag Tests
	public class Func_Accounts_GetGamertag : TestNode
	{
		/// <summary>
		///		Adult account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for an adult account.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with adult puid" )]
			class Accounts_GetGamertag_Positive_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong apuid = a.UserPuid;
				string gt = Widgets.Accounts(null).GetGamertag(apuid);
				if(gt != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertag result and the user created.");
			}
		}

		/// <summary>
		///		Minor account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a minor account.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with minor puid" )]
			class Accounts_GetGamertag_Positive_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong apuid = a.UserPuid;
				string gt = Widgets.Accounts(null).GetGamertag(apuid);
				if(gt != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertag result and the user created.");
			}
		}
	
		/// <summary>
		///		Queued account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a queued account.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with queued puid" )]
			class Accounts_GetGamertag_Positive_Queued : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Queued];
				ulong apuid = a.UserPuid;
				string gt = Widgets.Accounts(null).GetGamertag(apuid);
				if(gt != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertag result and the user created.");
			}
		}
	
		/// <summary>
		///		Reserved account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a reserved gamertag.
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged on the server
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with reserved puid" )]
			[Ignore]
			class Accounts_GetGamertag_Negative_Reserved : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Reserved];
				ulong apuid = a.UserPuid;
				try
				{
					Widgets.Accounts(null).GetGamertag(apuid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	
		/// <summary>
		///		Force Name Change Pending account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for an account with an FNC pending.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with a puid with a pending fnc" )]
			class Accounts_GetGamertag_Positive_FNCPending : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChangePending];
				ulong apuid = a.UserPuid;
				string gt = Widgets.Accounts(null).GetGamertag(apuid);
				if(gt != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertag result and the user created.");
			}
		}
	
		/// <summary>
		///		Force Name Change account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for an account with an FNC.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with a puid with a fnc" )]
			class Accounts_GetGamertag_Positive_FNC : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChanged];
				ulong apuid = a.UserPuid;
				string gt = Widgets.Accounts(null).GetGamertag(apuid);
				if(gt != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertag result and the user created.");
			}
		}
	
		/// <summary>
		///		Expired account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for an expired account.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with expired puid" )]
			class Accounts_GetGamertag_Positive_Expired : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Expired];
				ulong apuid = a.UserPuid;
				string gt = Widgets.Accounts(null).GetGamertag(apuid);
				if(gt != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertag result and the user created.");
			}
		}

		/// <summary>
		///		Canceled account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a canceled account.
		///		</Description>
		///		<Verify>
		///		The service should log an event and return a properly formatted SOAP error to the client with an HRESULT indicating failure.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with canceled puid" )]
			[Ignore]
			class Accounts_GetGamertag_Negative_Canceled : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Canceled];
				ulong apuid = a.UserPuid;
				try
				{
					Widgets.Accounts(null).GetGamertag(apuid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Nonexistent User
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a nonexistent user.
		///		</Description>
		///		<Verify>
		///		The service should log an event and return a properly formatted SOAP error to the client with an HRESULT indicating failure.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertag with nonexistent puid" )]
			class Accounts_GetGamertag_Negative_NonexistentUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				try
				{
					Widgets.Accounts(null).GetGamertag(1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
	#endregion

	/// <summary>
	/// This contains all the test cases for GetUserId.
	/// </summary>
	/// <remarks>
	/// <Component>Accounts</Component>
	/// <API>ulong GetUserId(string gamertag)</API>
	/// </remarks>
	#region Accounts.GetUserId Tests
	public class Func_Accounts_GetUserId : TestNode
	{
		/// <summary>
		///		Adult account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for an adult account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with adult puid" )]
			class Accounts_GetUserId_Positive_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				string agt = a.User.gamertag;
				ulong puid = Widgets.Accounts(null).GetUserId(agt);
				if(puid != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserId result and the user created.");
			}
		}

		/// <summary>
		///		Minor account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a minor account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with minor puid" )]
			class Accounts_GetUserId_Positive_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				string agt = a.User.gamertag;
				ulong puid = Widgets.Accounts(null).GetUserId(agt);
				if(puid != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserId result and the user created.");
			}
		}
	
		/// <summary>
		///		Queued account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a queued account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with queued puid" )]
			class Accounts_GetUserId_Positive_Queued : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Queued];
				string agt = a.User.gamertag;
				ulong puid = Widgets.Accounts(null).GetUserId(agt);
				if(puid != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserId result and the user created.");
			}
		}
	
		/// <summary>
		///		Reserved account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a reserved account.
		///		</Description>
		///		<Verify>
		///		The call should fail with an HRESULT for a missing user and an event should be logged on the server
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with reserved puid" )]
			[Ignore]
			class Accounts_GetUserId_Negative_Reserved : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Reserved];
				string agt = a.User.gamertag;
				try
				{
					Widgets.Accounts(null).GetUserId(agt);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	
		/// <summary>
		///		Force Name Change Pending
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid with a force name change required.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with fnc pending puid" )]
			class Accounts_GetUserId_Positive_FNCPending : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChangePending];
				string agt = a.User.gamertag;
				ulong puid = Widgets.Accounts(null).GetUserId(agt);
				if(puid != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserId result and the user created.");
			}
		}
	
		/// <summary>
		///		Force Name Change
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid with a force name change required.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with fnc'd puid" )]
			class Accounts_GetUserId_Positive_FNC : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChanged];
				string agt = a.User.gamertag;
				ulong puid = Widgets.Accounts(null).GetUserId(agt);
				if(puid != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserId result and the user created.");
			}
		}
	
		/// <summary>
		///		Force Name Change Old Gamertag
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for the old gamertag from an FNC.
		///		</Description>
		///		<Verify>
		///		The call should fail with an HRESULT indicating the user wasn't found and an event logged on the server.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId using the old gamertag from an fnc" )]
			class Accounts_GetUserId_Positive_FNCOldGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChanged];
				string agt = a.OldGamertag;

				try
				{
					Widgets.Accounts(null).GetUserId(agt);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	
		/// <summary>
		///		Expired account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid from an expired account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with expired puid" )]
			class Accounts_GetUserId_Positive_Expired : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Expired];
				string agt = a.User.gamertag;
				ulong puid = Widgets.Accounts(null).GetUserId(agt);
				if(puid != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserId result and the user created.");
			}
		}

		/// <summary>
		///		Canceled account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid from a canceled account.
		///		</Description>
		///		<Verify>
		///		The service should log an event and return a properly formatted SOAP error to the client with an HRESULT indicating failure.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with canceled puid" )]
			[Ignore]
			class Accounts_GetUserId_Negative_Canceled : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Canceled];
				string agt = a.User.gamertag;
				try
				{
					Widgets.Accounts(null).GetUserId(agt);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Null string
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a null string as the parameter.
		///		</Description>
		///		<Verify>
		///		The service should log an event and return a properly formatted SOAP error to the client with an HRESULT indicating failure.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with canceled puid" )]
			class Accounts_GetUserId_Negative_NullString : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				try
				{
					Widgets.Accounts(null).GetUserId(null);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Nonexistent user
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a non-existent user.
		///		</Description>
		///		<Verify>
		///		The service should log an event and return a properly formatted SOAP error to the client with an HRESULT indicating failure.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with a nonexistent user" )]
			class Accounts_GetUserId_Negative_NonexistentUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				try
				{
					Widgets.Accounts(null).GetUserId("ZAAALSKDJASDF*DF");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Too long string
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a string too long.
		///		</Description>
		///		<Verify>
		///		The service should log an event and return a properly formatted SOAP error to the client with an HRESULT indicating failure.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserId with a nonexistent user" )]
			class Accounts_GetUserId_Negative_TooLongString : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				try
				{
					Widgets.Accounts(null).GetUserId("ZAAALSKDJASDFADA");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
	#endregion

	/// <summary>
	/// This contains all the test cases for GetUserIdsFromList.
	/// </summary>
	/// <remarks>
	/// <Component>Accounts</Component>
	/// <API>ulong [] GetUserIdsFromList(string [] gamertags)</API>
	/// </remarks>
	#region Accounts.GetUserIdsFromList Tests
	public class Func_Accounts_GetUserIdsFromList : TestNode
	{
		/// <summary>
		///		Adult account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for an adult account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with adult puid" )]
			class Accounts_GetUserIdsFromList_Positive_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				string [] agt = new string [] {a.User.gamertag};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserIdsFromList result and the user created.");
			}
		}

		/// <summary>
		///		Minor account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a minor account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with minor puid" )]
			class Accounts_GetUserIdsFromList_Positive_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				string [] agt = new string [] {a.User.gamertag};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserIdsFromList result and the user created.");
			}
		}
	
		/// <summary>
		///		Queued account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a queued account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with queued puid" )]
			class Accounts_GetUserIdsFromList_Positive_Queued : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Queued];
				string [] agt = new string [] {a.User.gamertag};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserIdsFromList result and the user created.");
			}
		}
	
		/// <summary>
		///		Reserved account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid for a reserved account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with reserved puid" )]
			[Ignore]
			class Accounts_GetUserIdsFromList_Positive_Reserved : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Reserved];
				string [] agt = new string [] {a.User.gamertag};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != 0)
					throw new Exception("Gamertag mismatch between Accounts.GetUserIdsFromList result and zero.");
			}
		}
	
		/// <summary>
		///		Force Name Change Pending
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid with a force name change required.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with fnc'd puid" )]
			class Accounts_GetUserIdsFromList_Positive_FNCPending : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChangePending];
				string [] agt = new string [] {a.User.gamertag};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserIdsFromList result and the user created.");
			}
		}
	
		/// <summary>
		///		Force Name Change
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid with a force name change required.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with fnc'd puid" )]
			class Accounts_GetUserIdsFromList_Positive_FNC : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChanged];
				string [] agt = new string [] {a.User.gamertag};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserIdsFromList result and the expected value.");
			}
		}
	
		/// <summary>
		///		Force Name Change Old Gamertag
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid with a force name change required.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with the old gamertag from an fnc" )]
			class Accounts_GetUserIdsFromList_Positive_FNCOldGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChanged];
				string [] agt = new string [] {a.OldGamertag};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != 0)
					throw new Exception("Gamertag mismatch between Accounts.GetUserIdsFromList result and the expected value of zero.");
			}
		}
	
		/// <summary>
		///		Expired account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid from an expired account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with expired puid" )]
			class Accounts_GetUserIdsFromList_Positive_Expired : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Expired];
				string [] agt = new string [] {a.User.gamertag};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != a.UserPuid)
					throw new Exception("Gamertag mismatch between Accounts.GetUserIdsFromList result and the user created.");
			}
		}

		/// <summary>
		///		Canceled account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a puid from a canceled account.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with canceled puid" )]
			[Ignore]
			class Accounts_GetUserIdsFromList_Positive_Canceled : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Canceled];
				string [] agt = new string [] {a.User.gamertag};
				
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != 0)
					throw new Exception("GetUserIdsFromList returned a non-zero puid for canceled user.");
			}
		}

		/// <summary>
		///		Null list
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a null string as the parameter.
		///		</Description>
		///		<Verify>
		///		An exception to be thrown with an appropriate HRESULT and an event logged on the server.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with a null list parameter" )]
			class Accounts_GetUserIdsFromList_Negative_NullList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				try
				{
					Widgets.Accounts(null).GetUserIdsFromList(null);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Empty list
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle an empty list as the parameter.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with an empty list parameter" )]
			[Ignore]
			class Accounts_GetUserIdsFromList_Positive_EmptyList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(new string [] {});
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length > 0)
					throw new Exception("GetUserIdsFromList returned at least one puid for an empty list.");
			}
		}

		/// <summary>
		///		Nonexistent user
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a non-existent user.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with a nonexistent user" )]
			[Ignore]
			class Accounts_GetUserIdsFromList_Positive_NonexistentUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(new string [] {"ZAAALSKDJASDF*DF"});
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != 0)
					throw new Exception("GetUserIdsFromList returned a non-zero puid for a non-existent user.");
			}
		}

		/// <summary>
		///		Null gamertag
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a null gamertag in the list.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with a null gamertag in the list" )]
			[Ignore]
			class Accounts_GetUserIdsFromList_Positive_NullGamertagInList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(new string [] {null});
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != 0)
					throw new Exception("GetUserIdsFromList returned a non-zero puid for a null gamertag.");
			}
		}

		/// <summary>
		///		Too long string
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a string too long.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with a string too long" )]
			[Ignore]
			class Accounts_GetUserIdsFromList_Positive_TooLongString : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(new string [] {"ZAAALSKDJASDFADA"});
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != 1)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");
				if(puid[0] != 0)
					throw new Exception("GetUserIdsFromList returned a non-zero puid for a gamertag that was too long.");
			}
		}

		/// <summary>
		///		List containing one bad element
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a list containing one bad element (should return a partial list).
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with a single gamertag that is invalid" )]
			[Ignore]
			class Accounts_GetUserIdsFromList_Positive_SingleInvalidGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				string [] agt = new string [(int) UserStore.Specials.Count + 1];
				for(int i = 0; i < (int) UserStore.Specials.Count; ++i)
					agt[i] = UserStore.SpecialUsers[i].User.gamertag;
				agt[(int) UserStore.Specials.Count] = "ZAAALSKDJASDFADA";
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != agt.Length)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");

				StringBuilder sb = new StringBuilder();
				for(int i = 0; i < (int) UserStore.Specials.Count; ++i)
				{
					if(i != (int) UserStore.Specials.Canceled && i != (int) UserStore.Specials.Reserved && puid[i] != UserStore.SpecialUsers[i].UserPuid)
						sb.Append("\tGamertag: '").Append(agt).Append("' Expected: 0x").Append(UserStore.SpecialUsers[i].UserPuid.ToString("X16")).Append(" Got: 0x").Append(puid[i].ToString("X16")).Append("\r\n");
					else if((i == (int) UserStore.Specials.Reserved || i == (int) UserStore.Specials.Canceled) && puid[i] != 0)
						sb.Append("\tCanceled/Reserved Gamertag: '").Append(agt).Append("' Expected: 0x0 Got: 0x").Append(puid[i].ToString("X16")).Append("\r\n");
				}
				if(puid[(int) UserStore.Specials.Count] != 0)
					sb.Append("\tGamertag: '").Append(agt).Append("' Expected: 0x0 Got: 0x").Append(puid[(int) UserStore.Specials.Count].ToString("X16")).Append("\r\n");
				if(sb.Length > 0)
					throw new Exception("GetUserIdsFromList returned puids other than expected for the following:\r\n" + sb.ToString());
			}
		}

		/// <summary>
		///		List containing duplicate elements
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a list containing duplicate elements.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with duplicate gamertags" )]
			class Accounts_GetUserIdsFromList_Positive_DuplicateGamertags : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				string [] agt = new string []
					{
						UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].User.gamertag,
						UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].User.gamertag
					};
				ulong [] puid = Widgets.Accounts(null).GetUserIdsFromList(agt);
				if(puid == null)
					throw new Exception("GetUserIdsFromList returned null!");
				if(puid.Length != agt.Length)
					throw new Exception("GetUserIdsFromList returned a different number of puids than gamertags sent.");

				StringBuilder sb = new StringBuilder();
				for(int i = 0; i < (int) agt.Length; ++i)
				{
					if(puid[i] != UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].UserPuid)
						sb.Append("\tGamertag: '").Append(agt).Append("' Expected: 0x").Append(UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].UserPuid.ToString("X16")).Append(" Got: 0x").Append(puid[i].ToString("X16")).Append("\r\n");
				}
				if(sb.Length > 0)
					throw new Exception("GetUserIdsFromList returned puids other than expected for the following:\r\n" + sb.ToString());
			}
		}

		/// <summary>
		///		List Too Long (101)
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a list containing too many elements.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetUserIdsFromList with too many entries (101)" )]
			[Ignore]
			class Accounts_GetUserIdsFromList_Negative_TooManyEntries : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				string [] agt = new string [101];
				for(int i = 0; i < agt.Length; ++i)
				{
					agt[i] =UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].User.gamertag;
				}

				try
				{
					Widgets.Accounts(null).GetUserIdsFromList(agt);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
	}
	#endregion

	/// <summary>
	/// This contains all the test cases for GetGamertagsFromList.
	/// </summary>
	/// <remarks>
	/// <Component>Accounts</Component>
	/// <API>string [] GetGamertagsFromList(ulong [] puids)</API>
	/// </remarks>
	#region Accounts.GetGamertagsFromList Tests
	public class Func_Accounts_GetGamertagsFromList : TestNode
	{
		/// <summary>
		///		Adult account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gts for an adult account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with adult gts" )]
			class Accounts_GetGamertagsFromList_Positive_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				ulong [] puids = new ulong [] {a.UserPuid};
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertagsFromList result and the user created.");
			}
		}

		/// <summary>
		///		Minor account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gts for a minor account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with minor gts" )]
			class Accounts_GetGamertagsFromList_Positive_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				ulong [] puids = new ulong [] {a.UserPuid};
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertagsFromList result and the user created.");
			}
		}
	
		/// <summary>
		///		Queued account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gts for a queued account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with queued gts" )]
			class Accounts_GetGamertagsFromList_Positive_Queued : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Queued];
				ulong [] puids = new ulong [] {a.UserPuid};
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertagsFromList result and the user created.");
			}
		}
	
		/// <summary>
		///		Reserved account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gts for a reserved account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with reserved gts" )]
			[Ignore]
			class Accounts_GetGamertagsFromList_Positive_Reserved : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Queued];
				ulong [] puids = new ulong [] {a.UserPuid};
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != null)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertagsFromList result and (null).");
			}
		}
	
		/// <summary>
		///		Force Name Change Pending
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gts with a force name change required.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with fnc'd gts" )]
			class Accounts_GetGamertagsFromList_Positive_FNCPending : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChangePending];
				ulong [] puids = new ulong [] {a.UserPuid};
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertagsFromList result and the user created.");
			}
		}
	
		/// <summary>
		///		Force Name Change
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gts with a force name change required.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with fnc'd gts" )]
			class Accounts_GetGamertagsFromList_Positive_FNC : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.ForceNameChanged];
				ulong [] puids = new ulong [] {a.UserPuid};
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertagsFromList result and the user created.");
			}
		}
	
		/// <summary>
		///		Expired account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gts from an expired account.
		///		</Description>
		///		<Verify>
		///		The call should succeed.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with expired gts" )]
			class Accounts_GetGamertagsFromList_Positive_Expired : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Expired];
				ulong [] puids = new ulong [] {a.UserPuid};
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != a.User.gamertag)
					throw new Exception("Gamertag mismatch between Accounts.GetGamertagsFromList result and the user created.");
			}
		}

		/// <summary>
		///		Canceled account
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a correctly formatted request with a gts from a canceled account.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with canceled gts" )]
			[Ignore]
			class Accounts_GetGamertagsFromList_Positive_Canceled : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				UserInfo a = UserStore.SpecialUsers[(int) UserStore.Specials.Canceled];
				ulong [] puids = new ulong [] {a.UserPuid};
				
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != null)
					throw new Exception("GetGamertagsFromList returned a non-zero gts for canceled user.");
			}
		}

		/// <summary>
		///		Null list
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a null string as the parameter.
		///		</Description>
		///		<Verify>
		///		An exception to be thrown with an appropriate HRESULT and an event logged on the server.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with a null list parameter" )]
			class Accounts_GetGamertagsFromList_Negative_NullList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				try
				{
					Widgets.Accounts(null).GetGamertagsFromList(null);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		///		Empty list
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle an empty list as the parameter.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with an empty list parameter" )]
			[Ignore]
			class Accounts_GetGamertagsFromList_Positive_EmptyList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(new ulong [] {});
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length > 0)
					throw new Exception("GetGamertagsFromList returned at least one gts for an empty list.");
			}
		}

		/// <summary>
		///		Nonexistent user
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a non-existent user.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with a nonexistent user" )]
			[Ignore]
			class Accounts_GetGamertagsFromList_Positive_NonexistentUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(new ulong [] {1});
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != 1)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");
				if(gts[0] != null)
					throw new Exception("GetGamertagsFromList returned a non-zero gts for a non-existent user.");
			}
		}

		/// <summary>
		///		List containing one bad element
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a list containing one bad element (should return a partial list).
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with a single puid that is invalid" )]
			[Ignore]
			class Accounts_GetGamertagsFromList_Positive_SingleInvalidPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				ulong [] puids = new ulong [(int) UserStore.Specials.Count + 1];
				for(int i = 0; i < (int) UserStore.Specials.Count; ++i)
					puids[i] = UserStore.SpecialUsers[i].UserPuid;
				puids[(int) UserStore.Specials.Count] = 1;
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != puids.Length)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");

				StringBuilder sb = new StringBuilder();
				for(int i = 0; i < (int) UserStore.Specials.Count; ++i)
				{
					if(i != (int) UserStore.Specials.Canceled && gts[i] != UserStore.SpecialUsers[i].User.gamertag)
						sb.Append("\tPuid: 0x").Append(puids[i].ToString("X8")).Append(" Expected: '").Append(UserStore.SpecialUsers[i].User.gamertag).Append("' Got: '").Append(gts[i]).Append("'\r\n");
					else if((i == (int) UserStore.Specials.Reserved || i == (int) UserStore.Specials.Canceled) && gts[i] != null)
						sb.Append("\tCanceled/Reserved Puid: 0x").Append(puids[i].ToString("X8")).Append(" Expected: '(null)' Got: '").Append(gts[i]).Append("'\r\n");
				}
				if(gts[(int) UserStore.Specials.Count] != null)
					sb.Append("\tPuid: 0x1 Expected: '(null)' Got: '").Append(gts[(int) UserStore.Specials.Count]).Append("'\r\n");
				if(sb.Length > 0)
					throw new Exception("GetGamertagsFromList returned gamertags other than expected for the following:\r\n" + sb.ToString());
			}
		}

		/// <summary>
		///		List containing duplicate elements
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a list containing duplicate elements.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with duplicate puids" )]
			class Accounts_GetGamertagsFromList_Positive_DuplicatePuids : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				
				ulong [] puids = new ulong []
					{
						UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].UserPuid,
						UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].UserPuid
					};
				string [] gts = Widgets.Accounts(null).GetGamertagsFromList(puids);
				if(gts == null)
					throw new Exception("GetGamertagsFromList returned null!");
				if(gts.Length != puids.Length)
					throw new Exception("GetGamertagsFromList returned a different number of gamertags than puids sent.");

				StringBuilder sb = new StringBuilder();
				for(int i = 0; i < (int) puids.Length; ++i)
				{
					if(gts[i] != UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].User.gamertag)
						sb.Append("\tPuid: 0x").Append(puids[i].ToString("X8")).Append(" Expected: '").Append(UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].User.gamertag).Append("/ Got: '").Append(gts[i]).Append("'\r\n");
				}
				if(sb.Length > 0)
					throw new Exception("GetGamertagsFromList returned gamertags other than expected for the following:\r\n" + sb.ToString());
			}
		}

		/// <summary>
		///		List Too Long (101)
		///	</summary>
		///	<remarks>
		///		<Description>
		///		This test will determine whether the widget can handle a list containing too many elements.
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Accounts.GetGamertagsFromList with too many entries (101)" )]
			[Ignore]
			class Accounts_GetGamertagsFromList_Negative_TooManyEntries : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				
				ulong [] puids = new ulong [101];
				for(int i = 0; i < puids.Length; ++i)
				{
					puids[i] = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields].UserPuid;
				}
				try
				{
					Widgets.Accounts(null).GetGamertagsFromList(puids);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
	}
	#endregion

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\SvcTunnelFunctional.cs ===
using System;
using System.Xml;
using xonline.common.config;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Presence;

[assembly: RootNode(typeof(svctunnelfunctional.SvcTunnelTests))]

namespace svctunnelfunctional
{
	////////////////////////////////////////////////
	// Pres Widget Test
	//
	//	STF Test Suite for Svc Tunnel (EA) Widget
	//
	/// <summary>
	///		<TestSuite>Checkers/SvcTunnel Functional Test Plan</TestSuite>
	///		<Tester>Brent Scriver</Tester>
	///		<Developer>Steve Lamb</Developer>
	///		<PM>Daniel McGillicuddy</PM>
	///	
	/// </summary>
	/// <remarks>
	///		<Description>
	///			<p>The checkers component is a connector between Electronic Arts' server environment and Xbox Live. 
	///			Connectivity between the two services is established through a VPN connecting their environment with strictly 
	///			the servers hosting this component.  The model is entirely pull: any requests to be made will be initiated by
	///			EA to our service to which they will receive a response.  There is no instance of requests being made from
	///			Xbox Live to EA.  The component is implemented as a set of SOAP objects that translate requests from EA to
	///			internal XRL requests and translates the responses back into SOAP.
	///			</p>
	///			<p>Accounts functionality description here.</p>
	///			<p>Health functionality description here.</p>
	///			<p>Presence functionality description here.</p>
	///		</Description>
	/// </remarks>
	public class SvcTunnelTests : TestNode
	{
        public SvcTunnelTests()
        {
            AddChild( new Func_Accounts_GetUserInfo() );
            AddChild( new Func_Accounts_SendUserFeedback() );
            AddChild( new Func_Accounts_GetGamertag() );
            AddChild( new Func_Accounts_GetUserId() );
            AddChild( new Func_Accounts_GetUserIdsFromList() );
            AddChild( new Func_Accounts_GetGamertagsFromList() );
            AddChild( new Func_Health_Heartbeat() );
            AddChild( new Func_Health_VerifyConfig() );
            AddChild( new Func_AuthDataChecks() );
            AddChild( new Func_Presence_GetFriends() );
            AddChild( new Func_Presence_SendFriendRequest() );
            AddChild( new Func_Presence_AnswerFriendRequest() );
            AddChild( new Func_Presence_RemoveFriend() );
            AddChild( new Func_Presence_SendGameInvite() );
            AddChild( new Func_Presence_RevokeGameInvite() );
            AddChild( new Func_Presence_GetFriendsFromList() );
            AddChild( new Func_Presence_GetFriendsFromListByGamertag() );
            AddChild( new Func_Presence_SendFriendsRequestByGamertag() );
            AddChild( new Func_Presence_AnswerFriendsRequestByGamertag() );
            AddChild( new Func_Presence_SetNotificationState() );
            AddChild( new Func_Presence_AddUserToMutelist() );
            AddChild( new Func_Presence_RemoveUserFromMutelist() );
            AddChild( new Func_Presence_Multiple_FriendRequests_0_And_1_Cases_Checkers_Initiated() );
            AddChild( new Func_Presence_Multiple_FriendRequests_0_And_1_Cases_Client_Initiated() );
            AddChild( new Func_Presence_Multiple_FriendRequests_99_And_100_Cases_Checkers_Initiated() );
            AddChild( new Func_Presence_Multiple_FriendRequests_99_And_100_Cases_Client_Initiated() );
        }

		#region Typical TestSuite setup

        public override void PreRun(RUN_TYPE runType)
        {
            if (runType==RUN_TYPE.FUNCTIONAL)
            {
                InitializeFuntional();
            }
            else if (runType==RUN_TYPE.STRESS)
            {
                InitializeStress();
            }
        }

		////////////////////////////////////////////////
		// InitializeStress
		//
		//	Setup for Stress Suite
		//
		/// <summary>
		/// This loads the user base from the XML line
		/// <bulkusers basepuid="0x90000001ecd58" count="1000000" prefix="bu" tag="BU" />
		/// </summary>
		public override void InitializeStress()
		{
			StressHelper.Init();
			// Let the fake SG know where to send state updates
			GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());

			Widgets.Initialize();
			//UserStore.Initialize();
			UserStore.InitializeExceptional();
			System.Threading.Thread.Sleep(10000);
		}

		////////////////////////////////////////////////
		// Initialize
		//
		//	Setup for Functional Suite
		//
		/// <summary>
		/// Creates the following types of users:
		///		Adult account with max field lengths used
		///		Minor accoutn with max field lengths used
		///		Queued account
		///		Account with Force Name Change pending
		///		Expired account (suspended)
		///		Canceled account (deprovisioned)
		///	Waits 10 seconds for XCache to pick up the created users before allowing tests to run.
		/// </summary>
		/// <param name="config">Ignored</param>
		public override void InitializeFunctional()
		{
			// Let the fake SG know where to send state updates
			GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence).ToString());

			Widgets.Initialize();
			//UserStore.Initialize();
			UserStore.InitializeExceptional();
			System.Threading.Thread.Sleep(10000);
		}
		#endregion
	}

	/// Stress Helper
	/// <summary>
	/// Holds our bulk users
	/// </summary>
	public class StressHelper
	{
		/// <summary>
		/// Friends Object for logging on users
		/// </summary>
		public static FriendsCommon fc;
		/// <summary>
		/// Bulk Users
		/// </summary>
		public static BulkUserSet userSet;

		/// <summary>
		/// Loads the 'BU' set of test users.  These are Xbox 1 users.
		/// </summary>
		public static bool Init()
		{
			bool bRet = true;
			try
			{
				fc = new FriendsCommon();
				userSet = Global.GetUserSet("BU");
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(CC.ERROR,"Error: "+e.Message);
				bRet = false;
			}
			return bRet;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\UserStore.cs ===
using System;
using System.Xml;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.CUST;

using System.IO;

namespace svctunnelfunctional
{
	// Notes: I need a store of users that satisfy the preconditions that these tests require.  The list of user types are:

	/// <summary>
	/// UserStore provides the following user types for the test cases:
	///		Adult account with minimum field length usage.
	///		Adult account with maximum field length usage.
	///		Minor account minimum field length usage.
	///		Minor account maximum field length usage.
	///		Different regions?
	///		User that has opted out (adult &amp; minor)
	///		User force name changed (adult &amp; minor)
	///		User expired
	///		User canceled
	/// I also need to log on these users as if on an xbox to get the actual friends list to compare results for friends
	/// </summary>

	
	// UserStore.cs
	//
	//	Stuff that is initialized with the suite and available to all cases
	//

	////////////////////////////////////////////////
	// UserStore
	//	Keeper of global test data
	//
	#region public class UserInfo
	class UserInfo
	{
		ServerTestFramework.LiveService.UserAccount.Owner owner;
		protected ulong ownerPuid;
		protected ulong userPuid;
		protected string oldGamertag;

		public ArrayList Friends = new ArrayList();
		public uint PendingFriends = 0;
		public UserInfo()
		{
			owner = new ServerTestFramework.LiveService.UserAccount.Owner("Obsolete");
			ownerPuid = 0;
			userPuid = 0;
		}

		public string OldGamertag
		{
			get{return oldGamertag;}
		}
		public ulong OwnerPuid
		{
			get{return ownerPuid;}
		}
		public ulong UserPuid
		{
			get{return userPuid;}
		}
		public ServerTestFramework.LiveService.UserAccount.Owner User
		{
			get{return owner;}
		}

		public bool ChangeName(string newgt)
		{
			ServerTestFramework.LiveService.UserAccount.XRLChangeGamerTag cgt = new ServerTestFramework.LiveService.UserAccount.XRLChangeGamerTag();
			cgt.newTag = newgt;
			cgt.userPuid = userPuid;

			ServerTestFramework.LiveService.FakeSG.CSGInfo slot = new ServerTestFramework.LiveService.FakeSG.CSGInfo();
			slot.AddService(ServerTestFramework.LiveService.XOService.User_Account);
			slot.AddService(ServerTestFramework.LiveService.XOService.Base_Subscription);
			slot.AddService(ServerTestFramework.LiveService.XOService.Billing_Offering);
			cgt.PopulateSlot(ref slot);

			if(!cgt.Execute())
				return false;
			oldGamertag = User.gamertag;
			User.gamertag = newgt;
			return true;
		}

		public bool Reserve()
		{
			ServerTestFramework.LiveService.UserAccount.XRLReserveName xrn = new ServerTestFramework.LiveService.UserAccount.XRLReserveName();
			xrn.CountryId = User.countryId;
			xrn.GamerName = User.gamertag;
			ServerTestFramework.LiveService.FakeSG.CSGInfo slot = new ServerTestFramework.LiveService.FakeSG.CSGInfo();
			slot.AddService(ServerTestFramework.LiveService.XOService.User_Account);
			slot.AddService(ServerTestFramework.LiveService.XOService.Base_Subscription);
			slot.AddService(ServerTestFramework.LiveService.XOService.Billing_Offering);
			xrn.PopulateSlot(ref slot);

			ServerTestFramework.LiveService.UserAccount.XRLReserveResponseHead head;
			ServerTestFramework.LiveService.UserAccount.XRLReserveResponseItem [] items;
			if(0 != xrn.Create(out head, out items))
				return false;
			userPuid = ownerPuid = xrn.MachinePuid;
			return userPuid != 0;
		}

		public bool Create()
		{
			ownerPuid = userPuid = owner.Create();
			return userPuid != 0;
		}

		public void ReadStream(BinaryReader br)
		{
			ownerPuid = br.ReadUInt64();
			userPuid = br.ReadUInt64();
			owner.ReadStream(br);
		}
		public void WriteStream(BinaryWriter bw)
		{
			bw.Write(ownerPuid);
			bw.Write(userPuid);
			owner.WriteStream(bw);
		}

		public bool Compare(Accounts.UserInfo ui)
		{
			if(ui.city != User.city)
				return false;
				
			if(ui.countryId != User.countryId)
				return false;
				
			if(ui.emailAddress != User.email)
				return false;
				
			if(ui.firstName != User.firstName)
				return false;
				
			if(ui.gamertag != User.gamertag)
				return false;
				
			if(ui.lastName != User.lastName)
				return false;
				
			if(ui.optOut != (User.partnerSpam == 0))
				return false;
				
			if(ui.postalCode != User.postalCode)
				return false;
				
			if(ui.state != User.state)
				return false;
				
			if(ui.streetAddress != User.street1 + (User.street2.Length == 0 ? "" : "\n" + User.street2 + (User.street3.Length == 0 ? "" : "\n" + User.street3)))
				return false;
				
			if(ui.userId != UserPuid)
				return false;
			
			return true;
		}
	}
	#endregion

	class UserStore
	{

		/// <summary>
		/// UserStore provides the following user types for the test cases:
		///		Adult account with minimum field length usage.
		///		Adult account with maximum field length usage.
		///		Minor account minimum field length usage.
		///		Minor account maximum field length usage.
		///		Different regions?
		///		User that has opted out (adult &amp; minor)
		///		User force name changed (adult &amp; minor)
		///		User expired
		///		User canceled
		/// I also need to log on these users as if on an xbox to get the actual friends list to compare results for friends
		/// </summary>
		public enum Specials : int
		{
			AdultMaxFields,
			MinorMaxFields,
			GT15CharNoSpace,
			OptedOut,
			ForceNameChangePending,
			ForceNameChanged,
			Queued, 
			Expired,
			Canceled,
			Reserved,
			Count
		};

		public static UserInfo [] SpecialUsers = new UserInfo[(int) Specials.Count];

		public static PNUser [] FriendsToBe;
		public static Hashtable FriendsLookup = new Hashtable();
		// Friend utility class
		public static FriendsCommon Friends = new FriendsCommon();

		static bool initializedexceptional = false;

		// Time it takes a presence cache entry to refresh 
		//	This should be the same as:
		//		FriendsCacheExpirationSeconds in wcpresence.ini on cache server
		public static uint CacheExpDelay = 0; // seconds

		///////////////////////////////////////////////////////////////////////
		// IntializeExceptional
		//	Initializes the set of accounts with unique characteristics
		#region public static void InitializeExceptional()
		public static void InitializeExceptional()
		{
			if(!initializedexceptional)
			{
                SvcProviderWrapper CUST = new SvcProviderWrapper();
				AccountInfo info;

				DateTime dt = DateTime.Now;
				ushort c = (ushort) (dt.Hour * 3600 + dt.Minute * 60 + dt.Second);
				string tm = c.ToString("X4");

				UserInfo o = new UserInfo();

				// Adult Max fields
				ConsoleX.Write("Creating an adult account with max fields.  ");
				o.User.gamertag = "EA FUNC AM " + tm;
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.city = "Stillwater";
				o.Create();
				ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				SpecialUsers[(int) Specials.AdultMaxFields] = o;

				// Minor Max fields
				ConsoleX.Write("Creating a minor account with max fields.  ");
				o = new UserInfo();
				o.User.gamertag = "EA FUNC MM " + tm;
				o.User.birthdate = DateTime.Now.Subtract(new TimeSpan(366 * 14, 0, 0, 0, 0)); // Subtract 14 years from now to get a minor account.
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.city = "Stillwater";
				o.Create();
				ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				SpecialUsers[(int) Specials.MinorMaxFields] = o;

				// Gamertag with 15 characters and no spaces
				ConsoleX.Write("Creating an account with 15 characters and no spaces.  ");
				o = new UserInfo();
				o.User.gamertag = "EAFUNC15CNS" + tm;
				o.User.birthdate = DateTime.Now.Subtract(new TimeSpan(366 * 14, 0, 0, 0, 0)); // Subtract 14 years from now to get a minor account.
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.city = "Stillwater";
				o.Create();
				ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				SpecialUsers[(int) Specials.GT15CharNoSpace] = o;

				// User opted out
				ConsoleX.Write("Creating a user who has opted out.  ");
				o = new UserInfo();
				o.User.gamertag = "EA FUNC UO " + tm;
				o.User.msSpam = 0;
				o.User.partnerSpam = 0;
				o.User.city = "Stillwater";
				o.Create();
				ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				SpecialUsers[(int) Specials.OptedOut] = o;

				// Force name change pending
				ConsoleX.Write("Creating a user with an fnc required.  ");
				o = new UserInfo();
				o.User.gamertag = "EA FUNC NC " + tm;
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.city = "Stillwater";
				o.Create();
				CUST.GetAccount(o.UserPuid, out info);
				info.mustChangeXName = true;
				CUST.ModifyAccount(o.UserPuid, info);
				/*
				ServerTestFramework.LiveService.UserAccount.XRLSetUserAccountStatus xuas = new ServerTestFramework.LiveService.UserAccount.XRLSetUserAccountStatus();
				xuas.userPuid = o.UserPuid;
				xuas.nameChangeRequired = 1;
				if(!xuas.Execute())
				{
					ConsoleX.WriteLine("\r\nFailed to set the force name change bit (0x" + xuas.XErr.ToString("X8") + ") for user: 0x" + o.UserPuid.ToString("X16"));
				}
				else
				*/
				{
					ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				}
				SpecialUsers[(int) Specials.ForceNameChangePending] = o;

				// Force name changed
				ConsoleX.Write("Creating a user with an fnc completed.  ");
				o = new UserInfo();
				o.User.gamertag = "EA FUNC ON " + tm;
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.city = "Stillwater";
				o.Create();
				/*
				xuas = new ServerTestFramework.LiveService.UserAccount.XRLSetUserAccountStatus();
				xuas.userPuid = o.UserPuid;
				xuas.nameChangeRequired = 1;
				if(!xuas.Execute())
				{
					ConsoleX.WriteLine("\r\nFailed set the FNC bit (0x" + xuas.XErr.ToString("X8") + ") for user: 0x" + o.UserPuid.ToString("X16"));
				}
				else */
				CUST.GetAccount(o.UserPuid, out info);
				info.mustChangeXName = true;
				CUST.ModifyAccount(o.UserPuid, info);

				if(!o.ChangeName("EA FUNC NN " + tm))
				{
					ConsoleX.WriteLine("\r\nFailed to change the name user: 0x" + o.UserPuid.ToString("X16"));
				}
				else
				{
						ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				}
				SpecialUsers[(int) Specials.ForceNameChanged] = o;

				// Queued
				ConsoleX.Write("Creating a queued user.  ");
				o = new UserInfo();
				o.User.gamertag = "EA FUNC QU " + tm;
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.cardNumber = "4111111111111111";
				o.User.city = "Stillwater";
				o.Create();
				if(!ServerTestFramework.Database.UodbWS.SetUserSubscriptionStatus(o.UserPuid, SubscriptionStatus.Queued))
				{
					ConsoleX.WriteLine("\r\nFailed to set the account for user: 0x" + o.UserPuid.ToString("X16") + " to queued");
				}
				else
				{
					ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				}
				SpecialUsers[(int) Specials.Queued] = o;
		
				// Expired (Suspended/disabled)
				ConsoleX.Write("Creating an expired (suspended/disabled) user.  ");
				o = new UserInfo();
				o.User.gamertag = "EA FUNC EX " + tm;
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.city = "Stillwater";
				o.Create();
				if(!ServerTestFramework.Database.UodbWS.SetUserSubscriptionStatus(o.UserPuid, SubscriptionStatus.Suspended))
				{
					ConsoleX.WriteLine("\r\nFailed to set the account for user: 0x" + o.UserPuid.ToString("X16") + " to suspended");
				}
				else
				{
					ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				}
				SpecialUsers[(int) Specials.Expired] = o;
		
				// Canceled
				ConsoleX.Write("Creating a canceled (deprovisioned) user.  ");
				o = new UserInfo();
				o.User.gamertag = "EA FUNC CA " + tm;
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.city = "Stillwater";
				o.Create();
				if(!ServerTestFramework.Database.UodbWS.SetUserSubscriptionStatus(o.UserPuid, SubscriptionStatus.Deprovisioned))
				{
					ConsoleX.WriteLine("\r\nFailed to set the account for user: 0x" + o.UserPuid.ToString("X16") + " to deprovisioned");
				}
				else
				{
					ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				}
				SpecialUsers[(int) Specials.Canceled] = o;

				// Reserved
				ConsoleX.Write("Reserving a name for validation.  ");
				o = new UserInfo();
				o.User.gamertag = "EA FUNC IP " + tm;
				o.User.msSpam = 1;
				o.User.partnerSpam = 1;
				o.User.city = "Stillwater";
				if(!o.Reserve())
				{
					ConsoleX.WriteLine("Failed to reserve the name for the user.");
				}
				else
				{
					ConsoleX.WriteLine("UserPuid: 0x" + o.UserPuid.ToString("X16"));
				}
				SpecialUsers[(int) Specials.Reserved] = o;

				FriendsToBe = new PNUser[100];
				UacsCommon UACS = new UacsCommon();
				CPUIDList puids = UACS.CreatePrivateUsers("EAB", 100, false);
				for(int i = 0; i < FriendsToBe.Length; ++i)
				{
					FriendsToBe[i] = new PNUser(puids[i]);
					Friends.LogonUser(FriendsToBe[i]);
					FriendsLookup[puids[i].Puid] = FriendsToBe[i];
					
				}
				initializedexceptional = true;
			}
		}
		#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\Widgets.cs ===
using System;
using ServerTestFramework.LiveService;
using ServerTestFramework;
using System.Web.Services;
using System.Web;
using System.Net;
using System.Web.Services.Protocols;

namespace svctunnelfunctional
{
	/// <summary>
	/// Summary description for Widgets.
	/// </summary>
	class Widgets
	{
		static LiveServer dstServer = null;

		#region HTTPAuthData GetAuthData(*)
		public static string GetAuthData(ServerTestFramework.LiveService.PresNotiCommon.PNUser user)
		{
			HTTPAuthData auth = GetAuthData2(user.UserId, user.Xbox.TitleId);
			auth.dwTitleRegion = user.Xbox.TitleRegion;
			auth.dwTitleVersion = user.Xbox.TitleVer;
			auth.qwXboxID = user.Xbox.XboxId;
			return auth.GetBase64EncodedString();
		}

		public static string GetAuthData(ulong puid, uint titleID)
		{
			return GetAuthData2(puid, titleID).GetBase64EncodedString();
		}

		public static HTTPAuthData GetAuthData2(ulong puid, uint titleID)
		{
			ulong	requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
			uint	ip = 0;
			byte [] addr = dstServer.EPDefault.Address.GetAddressBytes();
			for(int i = 0; i < addr.Length; i++)
				ip = (ip << 8) + addr[i];
			
			return new HTTPAuthData((ushort) dstServer.EPDefault.Port, ip, requestId, puid, titleID, (uint)XOService.User_Account, (uint)XOService.Presence);
		}

		public static string GetAuthData(ulong puid)
		{
			return GetAuthData(puid, 0xFFFE0000);
		}
		#endregion

		#region class AccountOverride : Accounts.Accounts
		class AccountOverride : Accounts.Accounts
		{
			string authdata = null;
			protected AccountOverride()
			{
			}

			public AccountOverride(LiveServer ls, string auth)
			{
				Url = "http://" + ls.EPDefault.ToString() + "/svctunnel/accounts.asmx";
				authdata = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(authdata != null)
					hwr.Headers.Add(XHttpHdr.HTTPAUTHDATA, authdata);
				return hwr;
			}
		}
		#endregion

		#region class PresenceOverride : Presence.Presence
		class PresenceOverride : Presence.Presence
		{
			string authdata = null;
			protected PresenceOverride()
			{
			}

			public PresenceOverride(LiveServer ls, string auth)
			{
				Url = "http://" + ls.EPDefault.ToString() + "/svctunnel/presence.asmx";
				authdata = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(authdata != null)
					hwr.Headers.Add(XHttpHdr.HTTPAUTHDATA, authdata);
				return hwr;
			}
		}
		#endregion

		#region class HealthOverride : Health.Health
		class HealthOverride : Health.Health
		{
			string authdata = null;
			protected HealthOverride()
			{
			}

			public HealthOverride(LiveServer ls, string auth)
			{
				Url = "http://" + dstServer.EPDefault.ToString() + "/svctunnel/health.asmx";
				authdata = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(authdata != null)
					hwr.Headers.Add(XHttpHdr.HTTPAUTHDATA, authdata);
				return hwr;
			}
		}
		#endregion

		public static Accounts.Accounts Accounts(string auth)
		{
			Accounts.Accounts a = new AccountOverride(dstServer, auth);
			return a;
		}

		public static Presence.Presence Presence(string auth)
		{
			Presence.Presence p = new PresenceOverride(dstServer, auth);
			return p;
		}

		public static Health.Health Health(string auth)
		{
			Health.Health h = new HealthOverride(dstServer, auth);
			return h;
		}

		static public void Initialize()
		{
			dstServer = Global.Env.Get("svctunnel");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\widget\Accounts.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Accounts {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AccountsSoap", Namespace="http://svctunnel.xboxlive.com/Accounts/")]
    public class Accounts : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Accounts() {
            this.Url = "http://10.10.2.36:4541/svctunnel/accounts.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserInfo", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserInfo GetUserInfo(System.UInt64 userId) {
            object[] results = this.Invoke("GetUserInfo", new object[] {
                        userId});
            return ((UserInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserInfo(System.UInt64 userId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserInfo", new object[] {
                        userId}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserInfo EndGetUserInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserInfo)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/SendUserFeedback", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendUserFeedback(System.UInt32 titleId, System.UInt64 userId, System.UInt64 toUserId, System.UInt32 feedbackType, string nickname) {
            this.Invoke("SendUserFeedback", new object[] {
                        titleId,
                        userId,
                        toUserId,
                        feedbackType,
                        nickname});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendUserFeedback(System.UInt32 titleId, System.UInt64 userId, System.UInt64 toUserId, System.UInt32 feedbackType, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendUserFeedback", new object[] {
                        titleId,
                        userId,
                        toUserId,
                        feedbackType,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendUserFeedback(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetGamertag(System.UInt64 userId) {
            object[] results = this.Invoke("GetGamertag", new object[] {
                        userId});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGamertag(System.UInt64 userId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGamertag", new object[] {
                        userId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserId", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64 GetUserId(string gamertag) {
            object[] results = this.Invoke("GetUserId", new object[] {
                        gamertag});
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserId(string gamertag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserId", new object[] {
                        gamertag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64 EndGetUserId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetGamertagsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] GetGamertagsFromList(System.UInt64[] userIds) {
            object[] results = this.Invoke("GetGamertagsFromList", new object[] {
                        userIds});
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGamertagsFromList(System.UInt64[] userIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGamertagsFromList", new object[] {
                        userIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public string[] EndGetGamertagsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserIdsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64[] GetUserIdsFromList(string[] gamertags) {
            object[] results = this.Invoke("GetUserIdsFromList", new object[] {
                        gamertags});
            return ((System.UInt64[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserIdsFromList(string[] gamertags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserIdsFromList", new object[] {
                        gamertags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64[] EndGetUserIdsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64[])(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://svctunnel.xboxlive.com/Accounts/")]
    public class UserInfo {
        
        /// <remarks/>
        public System.UInt64 userId;
        
        /// <remarks/>
        public string gamertag;
        
        /// <remarks/>
        public bool optOut;
        
        /// <remarks/>
        public string firstName;
        
        /// <remarks/>
        public string lastName;
        
        /// <remarks/>
        public string emailAddress;
        
        /// <remarks/>
        public string streetAddress;
        
        /// <remarks/>
        public string city;
        
        /// <remarks/>
        public string state;
        
        /// <remarks/>
        public string postalCode;
        
        /// <remarks/>
        public System.Byte countryId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\widget\Health.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Health {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="HealthSoap", Namespace="http://svctunnel.xboxlive.com/Health/")]
    public class Health : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Health() {
            this.Url = "http://10.10.2.36:4541/svctunnel/health.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Health/Heartbeat", RequestNamespace="http://svctunnel.xboxlive.com/Health/", ResponseNamespace="http://svctunnel.xboxlive.com/Health/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void Heartbeat() {
            this.Invoke("Heartbeat", new object[0]);
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginHeartbeat(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Heartbeat", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public void EndHeartbeat(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Health/VerifyConfig", RequestNamespace="http://svctunnel.xboxlive.com/Health/", ResponseNamespace="http://svctunnel.xboxlive.com/Health/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string VerifyConfig() {
            object[] results = this.Invoke("VerifyConfig", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginVerifyConfig(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("VerifyConfig", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndVerifyConfig(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelquickcheck\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

!if defined(PASS2)

bin\$(TARGETNAME).exe: $(URTTARGET)
        copy $** $@
        copy $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb bin\$(TARGETNAME).pdb

!else

bin\$(TARGETNAME).exe:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\widget\Presence.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Presence {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="PresenceSoap", Namespace="http://svctunnel.xboxlive.com/Presence/")]
    public class Presence : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Presence() {
            this.Url = "http://10.10.2.36:4541/svctunnel/presence.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriends", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriends(System.UInt64 userId, System.UInt32 language) {
            object[] results = this.Invoke("GetFriends", new object[] {
                        userId,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriends(System.UInt64 userId, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriends", new object[] {
                        userId,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriends(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriendsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriendsFromList(System.UInt64 userId, System.UInt64[] friendUserIds, System.UInt32 language) {
            object[] results = this.Invoke("GetFriendsFromList", new object[] {
                        userId,
                        friendUserIds,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriendsFromList(System.UInt64 userId, System.UInt64[] friendUserIds, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriendsFromList", new object[] {
                        userId,
                        friendUserIds,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriendsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriendsFromListByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriendsFromListByGamertag(System.UInt64 userId, string[] friendGamertags, System.UInt32 language) {
            object[] results = this.Invoke("GetFriendsFromListByGamertag", new object[] {
                        userId,
                        friendGamertags,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriendsFromListByGamertag(System.UInt64 userId, string[] friendGamertags, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriendsFromListByGamertag", new object[] {
                        userId,
                        friendGamertags,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriendsFromListByGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendFriendsRequest", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendFriendsRequest(System.UInt64 userId, System.UInt64 toUserId) {
            this.Invoke("SendFriendsRequest", new object[] {
                        userId,
                        toUserId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendFriendsRequest", new object[] {
                        userId,
                        toUserId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendFriendsRequest(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendFriendsRequestByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendFriendsRequestByGamertag(string user, string toUser) {
            this.Invoke("SendFriendsRequestByGamertag", new object[] {
                        user,
                        toUser});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendFriendsRequestByGamertag(string user, string toUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendFriendsRequestByGamertag", new object[] {
                        user,
                        toUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendFriendsRequestByGamertag(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AnswerFriendsRequest", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AnswerFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.UInt32 answer) {
            this.Invoke("AnswerFriendsRequest", new object[] {
                        userId,
                        toUserId,
                        answer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAnswerFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.UInt32 answer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AnswerFriendsRequest", new object[] {
                        userId,
                        toUserId,
                        answer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAnswerFriendsRequest(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AnswerFriendsRequestByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AnswerFriendsRequestByGamertag(string user, string toUser, System.UInt32 answer) {
            this.Invoke("AnswerFriendsRequestByGamertag", new object[] {
                        user,
                        toUser,
                        answer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAnswerFriendsRequestByGamertag(string user, string toUser, System.UInt32 answer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AnswerFriendsRequestByGamertag", new object[] {
                        user,
                        toUser,
                        answer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAnswerFriendsRequestByGamertag(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RemoveFriend", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveFriend(System.UInt64 userId, System.UInt64 removeUserId) {
            this.Invoke("RemoveFriend", new object[] {
                        userId,
                        removeUserId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveFriend(System.UInt64 userId, System.UInt64 removeUserId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveFriend", new object[] {
                        userId,
                        removeUserId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveFriend(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendGameInvite", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendGameInvite(System.UInt32 titleId, System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds) {
            this.Invoke("SendGameInvite", new object[] {
                        titleId,
                        userId,
                        sessionId,
                        toUserIds});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendGameInvite(System.UInt32 titleId, System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendGameInvite", new object[] {
                        titleId,
                        userId,
                        sessionId,
                        toUserIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendGameInvite(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RevokeGameInvite", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeGameInvite(System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds) {
            this.Invoke("RevokeGameInvite", new object[] {
                        userId,
                        sessionId,
                        toUserIds});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeGameInvite(System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeGameInvite", new object[] {
                        userId,
                        sessionId,
                        toUserIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeGameInvite(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SetNotificationState", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetNotificationState(System.UInt64 userId, System.UInt16 stateFlags, System.UInt64 sessionId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] stateData) {
            this.Invoke("SetNotificationState", new object[] {
                        userId,
                        stateFlags,
                        sessionId,
                        stateData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetNotificationState(System.UInt64 userId, System.UInt16 stateFlags, System.UInt64 sessionId, System.Byte[] stateData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetNotificationState", new object[] {
                        userId,
                        stateFlags,
                        sessionId,
                        stateData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetNotificationState(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AddUserToMutelist", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddUserToMutelist(System.UInt64 userId, System.UInt64 userIdToAdd) {
            this.Invoke("AddUserToMutelist", new object[] {
                        userId,
                        userIdToAdd});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddUserToMutelist(System.UInt64 userId, System.UInt64 userIdToAdd, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddUserToMutelist", new object[] {
                        userId,
                        userIdToAdd}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddUserToMutelist(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RemoveUserFromMutelist", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveUserFromMutelist(System.UInt64 userId, System.UInt64 userIdToRemove) {
            this.Invoke("RemoveUserFromMutelist", new object[] {
                        userId,
                        userIdToRemove});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveUserFromMutelist(System.UInt64 userId, System.UInt64 userIdToRemove, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveUserFromMutelist", new object[] {
                        userId,
                        userIdToRemove}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveUserFromMutelist(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://svctunnel.xboxlive.com/Presence/")]
    public class Friend {
        
        /// <remarks/>
        public System.UInt64 userId;
        
        /// <remarks/>
        public string gamertag;
        
        /// <remarks/>
        public System.UInt32 friendState;
        
        /// <remarks/>
        public System.DateTime gameinviteTime;
        
        /// <remarks/>
        public System.UInt64 sessionID;
        
        /// <remarks/>
        public System.UInt32 titleID;
        
        /// <remarks/>
        public string titleName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] StateData;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelquickcheck\Accounts.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Accounts {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AccountsSoap", Namespace="http://svctunnel.xboxlive.com/Accounts/")]
    public class Accounts : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Accounts() {
            this.Url = "http://10.10.2.36:4541/svctunnel/accounts.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserInfo", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserInfo GetUserInfo(System.UInt64 userId) {
            object[] results = this.Invoke("GetUserInfo", new object[] {
                        userId});
            return ((UserInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserInfo(System.UInt64 userId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserInfo", new object[] {
                        userId}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserInfo EndGetUserInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserInfo)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/SendUserFeedback", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendUserFeedback(System.UInt32 titleId, System.UInt64 userId, System.UInt64 toUserId, System.UInt32 feedbackType, string nickname) {
            this.Invoke("SendUserFeedback", new object[] {
                        titleId,
                        userId,
                        toUserId,
                        feedbackType,
                        nickname});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendUserFeedback(System.UInt32 titleId, System.UInt64 userId, System.UInt64 toUserId, System.UInt32 feedbackType, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendUserFeedback", new object[] {
                        titleId,
                        userId,
                        toUserId,
                        feedbackType,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendUserFeedback(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetGamertag(System.UInt64 userId) {
            object[] results = this.Invoke("GetGamertag", new object[] {
                        userId});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGamertag(System.UInt64 userId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGamertag", new object[] {
                        userId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserId", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64 GetUserId(string gamertag) {
            object[] results = this.Invoke("GetUserId", new object[] {
                        gamertag});
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserId(string gamertag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserId", new object[] {
                        gamertag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64 EndGetUserId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetGamertagsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] GetGamertagsFromList(System.UInt64[] userIds) {
            object[] results = this.Invoke("GetGamertagsFromList", new object[] {
                        userIds});
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGamertagsFromList(System.UInt64[] userIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGamertagsFromList", new object[] {
                        userIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public string[] EndGetGamertagsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserIdsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64[] GetUserIdsFromList(string[] gamertags) {
            object[] results = this.Invoke("GetUserIdsFromList", new object[] {
                        gamertags});
            return ((System.UInt64[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserIdsFromList(string[] gamertags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserIdsFromList", new object[] {
                        gamertags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64[] EndGetUserIdsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64[])(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://svctunnel.xboxlive.com/Accounts/")]
    public class UserInfo {
        
        /// <remarks/>
        public System.UInt64 userId;
        
        /// <remarks/>
        public string gamertag;
        
        /// <remarks/>
        public bool optOut;
        
        /// <remarks/>
        public string firstName;
        
        /// <remarks/>
        public string lastName;
        
        /// <remarks/>
        public string emailAddress;
        
        /// <remarks/>
        public string streetAddress;
        
        /// <remarks/>
        public string city;
        
        /// <remarks/>
        public string state;
        
        /// <remarks/>
        public string postalCode;
        
        /// <remarks/>
        public System.Byte countryId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\Health.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Health {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="HealthSoap", Namespace="http://svctunnel.xboxlive.com/Health/")]
    public class Health : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Health() {
            this.Url = "http://10.10.2.36:4541/svctunnel/health.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Health/Heartbeat", RequestNamespace="http://svctunnel.xboxlive.com/Health/", ResponseNamespace="http://svctunnel.xboxlive.com/Health/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void Heartbeat() {
            this.Invoke("Heartbeat", new object[0]);
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginHeartbeat(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Heartbeat", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public void EndHeartbeat(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Health/VerifyConfig", RequestNamespace="http://svctunnel.xboxlive.com/Health/", ResponseNamespace="http://svctunnel.xboxlive.com/Health/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string VerifyConfig() {
            object[] results = this.Invoke("VerifyConfig", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginVerifyConfig(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("VerifyConfig", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndVerifyConfig(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelquickcheck\quickcheck.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Threading;

namespace svctunnelquickcheck
{
	/// <summary>
	/// Summary description for CheckersCheck.
	/// </summary>
	public class CheckersCheck : System.Windows.Forms.Form
	{
		private System.Windows.Forms.ListView lstVIPs;
		private System.Windows.Forms.TextBox txtVIPIP;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Button btnAddVIPIP;
		private System.Windows.Forms.ColumnHeader clmVIPIP;
		private System.Windows.Forms.ColumnHeader clmPassed;
		private System.Windows.Forms.ColumnHeader clmFailed;
		private System.Windows.Forms.Button btnAddSvcIP;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.TextBox txtSvcIP;
		private System.Windows.Forms.ListView lstSvcs;
		private System.Windows.Forms.ColumnHeader columnHeader1;
		private System.Windows.Forms.ColumnHeader columnHeader2;
		private System.Windows.Forms.ColumnHeader columnHeader3;
		private System.Windows.Forms.ColumnHeader clmTest;
		private System.Windows.Forms.ColumnHeader clmTarget;
		private System.Windows.Forms.TextBox txtResults;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.TextBox txtUserPuid;
		private System.Windows.Forms.Button btnStart;
		private System.Windows.Forms.Button btnStop;
		private System.Windows.Forms.ColumnHeader clmStatus;
		private System.Windows.Forms.ListView lstTests;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public CheckersCheck()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//

			lstVIPs.KeyUp += new KeyEventHandler(lstVIPs_KeyUp);
			lstSvcs.KeyUp +=new KeyEventHandler(lstSvcs_KeyUp);
			log = new Logger(txtResults);
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			btnStop_Click(null, null);
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.lstVIPs = new System.Windows.Forms.ListView();
			this.clmVIPIP = new System.Windows.Forms.ColumnHeader();
			this.clmPassed = new System.Windows.Forms.ColumnHeader();
			this.clmFailed = new System.Windows.Forms.ColumnHeader();
			this.txtVIPIP = new System.Windows.Forms.TextBox();
			this.label1 = new System.Windows.Forms.Label();
			this.btnAddVIPIP = new System.Windows.Forms.Button();
			this.btnAddSvcIP = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.txtSvcIP = new System.Windows.Forms.TextBox();
			this.lstSvcs = new System.Windows.Forms.ListView();
			this.columnHeader1 = new System.Windows.Forms.ColumnHeader();
			this.columnHeader2 = new System.Windows.Forms.ColumnHeader();
			this.columnHeader3 = new System.Windows.Forms.ColumnHeader();
			this.lstTests = new System.Windows.Forms.ListView();
			this.clmTarget = new System.Windows.Forms.ColumnHeader();
			this.clmTest = new System.Windows.Forms.ColumnHeader();
			this.clmStatus = new System.Windows.Forms.ColumnHeader();
			this.txtResults = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.label4 = new System.Windows.Forms.Label();
			this.txtUserPuid = new System.Windows.Forms.TextBox();
			this.btnStart = new System.Windows.Forms.Button();
			this.btnStop = new System.Windows.Forms.Button();
			this.SuspendLayout();
			// 
			// lstVIPs
			// 
			this.lstVIPs.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																					  this.clmVIPIP,
																					  this.clmPassed,
																					  this.clmFailed});
			this.lstVIPs.FullRowSelect = true;
			this.lstVIPs.Location = new System.Drawing.Point(16, 128);
			this.lstVIPs.Name = "lstVIPs";
			this.lstVIPs.Size = new System.Drawing.Size(216, 64);
			this.lstVIPs.TabIndex = 0;
			this.lstVIPs.View = System.Windows.Forms.View.Details;
			// 
			// clmVIPIP
			// 
			this.clmVIPIP.Text = "IP Address";
			this.clmVIPIP.Width = 90;
			// 
			// clmPassed
			// 
			this.clmPassed.Text = "Pass";
			this.clmPassed.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmPassed.Width = 50;
			// 
			// clmFailed
			// 
			this.clmFailed.Text = "Failed";
			this.clmFailed.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmFailed.Width = 50;
			// 
			// txtVIPIP
			// 
			this.txtVIPIP.Location = new System.Drawing.Point(56, 96);
			this.txtVIPIP.Name = "txtVIPIP";
			this.txtVIPIP.Size = new System.Drawing.Size(120, 20);
			this.txtVIPIP.TabIndex = 1;
			this.txtVIPIP.Text = "0.0.0.0";
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(16, 96);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(39, 16);
			this.label1.TabIndex = 2;
			this.label1.Text = "VIP IP:";
			// 
			// btnAddVIPIP
			// 
			this.btnAddVIPIP.Location = new System.Drawing.Point(192, 96);
			this.btnAddVIPIP.Name = "btnAddVIPIP";
			this.btnAddVIPIP.Size = new System.Drawing.Size(40, 24);
			this.btnAddVIPIP.TabIndex = 3;
			this.btnAddVIPIP.Text = "Add";
			this.btnAddVIPIP.Click += new System.EventHandler(this.btnAddVIPIP_Click);
			// 
			// btnAddSvcIP
			// 
			this.btnAddSvcIP.Location = new System.Drawing.Point(192, 208);
			this.btnAddSvcIP.Name = "btnAddSvcIP";
			this.btnAddSvcIP.Size = new System.Drawing.Size(40, 24);
			this.btnAddSvcIP.TabIndex = 7;
			this.btnAddSvcIP.Text = "Add";
			this.btnAddSvcIP.Click += new System.EventHandler(this.btnAddSvcIP_Click);
			// 
			// label2
			// 
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(16, 208);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(40, 16);
			this.label2.TabIndex = 6;
			this.label2.Text = "Svc IP:";
			// 
			// txtSvcIP
			// 
			this.txtSvcIP.Location = new System.Drawing.Point(56, 208);
			this.txtSvcIP.Name = "txtSvcIP";
			this.txtSvcIP.Size = new System.Drawing.Size(120, 20);
			this.txtSvcIP.TabIndex = 5;
			this.txtSvcIP.Text = "0.0.0.0";
			// 
			// lstSvcs
			// 
			this.lstSvcs.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left)));
			this.lstSvcs.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																					  this.columnHeader1,
																					  this.columnHeader2,
																					  this.columnHeader3});
			this.lstSvcs.FullRowSelect = true;
			this.lstSvcs.Location = new System.Drawing.Point(16, 240);
			this.lstSvcs.Name = "lstSvcs";
			this.lstSvcs.Size = new System.Drawing.Size(216, 136);
			this.lstSvcs.TabIndex = 4;
			this.lstSvcs.View = System.Windows.Forms.View.Details;
			// 
			// columnHeader1
			// 
			this.columnHeader1.Text = "IP Address";
			this.columnHeader1.Width = 90;
			// 
			// columnHeader2
			// 
			this.columnHeader2.Text = "Pass";
			this.columnHeader2.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.columnHeader2.Width = 50;
			// 
			// columnHeader3
			// 
			this.columnHeader3.Text = "Failed";
			this.columnHeader3.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.columnHeader3.Width = 50;
			// 
			// lstTests
			// 
			this.lstTests.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.lstTests.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																					   this.clmTarget,
																					   this.clmTest,
																					   this.clmStatus});
			this.lstTests.FullRowSelect = true;
			this.lstTests.Location = new System.Drawing.Point(248, 96);
			this.lstTests.MultiSelect = false;
			this.lstTests.Name = "lstTests";
			this.lstTests.Size = new System.Drawing.Size(272, 280);
			this.lstTests.TabIndex = 8;
			this.lstTests.View = System.Windows.Forms.View.Details;
			// 
			// clmTarget
			// 
			this.clmTarget.Text = "Target IP";
			this.clmTarget.Width = 90;
			// 
			// clmTest
			// 
			this.clmTest.Text = "API Test";
			this.clmTest.Width = 100;
			// 
			// clmStatus
			// 
			this.clmStatus.Text = "Status";
			this.clmStatus.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			// 
			// txtResults
			// 
			this.txtResults.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.txtResults.BackColor = System.Drawing.Color.White;
			this.txtResults.Location = new System.Drawing.Point(24, 408);
			this.txtResults.Multiline = true;
			this.txtResults.Name = "txtResults";
			this.txtResults.ReadOnly = true;
			this.txtResults.Size = new System.Drawing.Size(496, 120);
			this.txtResults.TabIndex = 9;
			this.txtResults.Text = "";
			// 
			// label3
			// 
			this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.label3.AutoSize = true;
			this.label3.Location = new System.Drawing.Point(24, 392);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(45, 16);
			this.label3.TabIndex = 10;
			this.label3.Text = "Results:";
			// 
			// label4
			// 
			this.label4.AutoSize = true;
			this.label4.Location = new System.Drawing.Point(16, 32);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(82, 16);
			this.label4.TabIndex = 11;
			this.label4.Text = "Test User Puid:";
			// 
			// txtUserPuid
			// 
			this.txtUserPuid.Location = new System.Drawing.Point(104, 32);
			this.txtUserPuid.Name = "txtUserPuid";
			this.txtUserPuid.Size = new System.Drawing.Size(168, 20);
			this.txtUserPuid.TabIndex = 12;
			this.txtUserPuid.Text = "";
			// 
			// btnStart
			// 
			this.btnStart.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.btnStart.Location = new System.Drawing.Point(448, 24);
			this.btnStart.Name = "btnStart";
			this.btnStart.Size = new System.Drawing.Size(72, 24);
			this.btnStart.TabIndex = 13;
			this.btnStart.Text = "Start";
			this.btnStart.Click += new System.EventHandler(this.btnStart_Click);
			// 
			// btnStop
			// 
			this.btnStop.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.btnStop.Location = new System.Drawing.Point(448, 56);
			this.btnStop.Name = "btnStop";
			this.btnStop.Size = new System.Drawing.Size(72, 24);
			this.btnStop.TabIndex = 14;
			this.btnStop.Text = "Stop";
			this.btnStop.Click += new System.EventHandler(this.btnStop_Click);
			// 
			// CheckersCheck
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(544, 541);
			this.Controls.Add(this.btnStop);
			this.Controls.Add(this.btnStart);
			this.Controls.Add(this.txtUserPuid);
			this.Controls.Add(this.label4);
			this.Controls.Add(this.label3);
			this.Controls.Add(this.txtResults);
			this.Controls.Add(this.lstTests);
			this.Controls.Add(this.btnAddSvcIP);
			this.Controls.Add(this.label2);
			this.Controls.Add(this.txtSvcIP);
			this.Controls.Add(this.lstSvcs);
			this.Controls.Add(this.btnAddVIPIP);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.txtVIPIP);
			this.Controls.Add(this.lstVIPs);
			this.Name = "CheckersCheck";
			this.Text = "CheckersCheck";
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new CheckersCheck());
		}


		Hashtable VIPAddrs = new Hashtable();
		Hashtable SvcAddrs = new Hashtable();

		
		private void btnAddVIPIP_Click(object sender, System.EventArgs e)
		{
			string s = txtVIPIP.Text.ToLower();
			if(VIPAddrs[s] != null)
				return;
			IPData ip = new IPData(txtVIPIP.Text);
			VIPAddrs[s] = ip;
			lstVIPs.Items.Add(ip.ListViewEntry);
		}

		private void btnAddSvcIP_Click(object sender, System.EventArgs e)
		{
			string s = txtSvcIP.Text.ToLower();
			if(SvcAddrs[s] != null)
				return;
			IPData ip = new IPData(txtSvcIP.Text);
			SvcAddrs[s] = ip;
			lstSvcs.Items.Add(ip.ListViewEntry);
		}

		Logger log;

		private void RunTest(IPData ip, ITestCase test, ulong puid)
		{
			TestData td = new TestData(ip, test, log);
			lstTests.Items.Add(td.ListViewEntry);
			lstTests.Refresh();
			lstTests.Update();
			td.Run(puid);
		}

		ManualResetEvent mre = new ManualResetEvent(false);
		private void btnStart_Click(object sender, System.EventArgs e)
		{
			lstTests.Items.Clear();
			ulong puid = 0;

			if(txtUserPuid.Text.StartsWith("0x"))
				puid = Convert.ToUInt64(txtUserPuid.Text, 16);
			else
				puid = Convert.ToUInt64(txtUserPuid.Text, 10);

			foreach(IPData ip in SvcAddrs.Values)
			{
				RunTest(ip, new Accounts_GetGamertag(), puid);
				RunTest(ip, new Accounts_GetUserInfo(), puid);
				RunTest(ip, new Accounts_SendUserFeedback(), puid);
				RunTest(ip, new Health_VerifyConfig(), puid);
				RunTest(ip, new Presence_GetFriends(), puid);
			}

			log.AddText("Server verification complete.\r\n");
			log.AddText("Starting VIP verification.  Accounts.GetGamertags will run against each VIP listed until either it fails or \"Stop\" is pressed.\r\n");
			log.AddText("Please go to each service pointed to by the VIP and verify that XCache is consuming CPU in perfmon.\r\n");

			foreach(IPData ip in VIPAddrs.Values)
			{
				VIPCheck vc = new VIPCheck(ip, log, mre, puid);
			}
		}

		private void btnStop_Click(object sender, System.EventArgs e)
		{
			mre.Set();
		}

		private void lstVIPs_KeyUp(object sender, KeyEventArgs e)
		{
			if(e.KeyCode == Keys.Delete && e.KeyData == Keys.Delete)
			{
				for(int i = lstVIPs.SelectedItems.Count - 1; i >=0 ; --i)
				{
					ListViewItem lvi = lstVIPs.SelectedItems[i];
					VIPAddrs.Remove(lvi.SubItems[0].Text.ToLower());
					lstVIPs.Items.RemoveAt(i);
				}
			}
		}

		private void lstSvcs_KeyUp(object sender, KeyEventArgs e)
		{
			if(e.KeyCode == Keys.Delete && e.KeyData == Keys.Delete)
			{
				for(int i = lstSvcs.SelectedItems.Count - 1; i >=0 ; --i)
				{
					ListViewItem lvi = lstSvcs.SelectedItems[i];
					SvcAddrs.Remove(lvi.SubItems[0].Text.ToLower());
					lstSvcs.Items.RemoveAt(i);
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelquickcheck\Tests.cs ===
using System;
using System.Windows.Forms;
using System.Collections;
using System.Drawing;
using System.Threading;

namespace svctunnelquickcheck
{

	class Logger
	{
		TextBox log;

		protected Logger()
		{
		}

		public Logger(TextBox logger)
		{
			log = logger;
		}

		public void AddText(string t)
		{
			lock(log)
			{
				log.Text += t;
			}
			log.Update();
			log.Refresh();
			log.ScrollToCaret();
		}
	}
	
	class IPData
	{
		#region Private data
		ListViewItem lvi;
		string addr;
		uint pass = 0;
		uint fail = 0;

		protected IPData()
		{
		}
		#endregion

		#region public IPData(string address)
		public IPData(string address)
		{
			addr = address;
			lvi = new ListViewItem(new string [] {addr, "0", "0"});
		}
		#endregion

		#region public ListViewItem ListViewEntry // get
		public ListViewItem ListViewEntry
		{
			get{return lvi;}
		}
		#endregion

		#region public string Address // get
		public string Address
		{
			get{return addr;}
			// set{addr = value; if(lvi.SubItems[0].Text != addr) lvi.SubItems[0].Text = addr;}
		}
		#endregion

		#region public uint Pass // get & set
		public uint Pass
		{
			get{return pass;}
			set{pass = value; if(lvi.SubItems[1].Text != pass.ToString()) lvi.SubItems[1].Text = pass.ToString();}
		}
		#endregion

		#region public uint Fail // get & set
		public uint Fail
		{
			get{return fail;}
			set{fail = value; if(lvi.SubItems[2].Text != fail.ToString()) lvi.SubItems[2].Text = fail.ToString();}
		}
		#endregion

	}

	interface ITestCase
	{
		string Name
		{
			get;
		}
		string Run(IPData data, ulong puid);
	}

	class TestData 
	{
		#region Private data
		ListViewItem lvi;
		IPData tgt;
		ITestCase tst;
		Logger log;

		protected TestData()
		{
		}
		#endregion

		public ListViewItem ListViewEntry
		{
			get{return lvi;}
		}

		#region public TestData(IPData target, ITestCase test, Logger logdest)
		public TestData(IPData target, ITestCase test, Logger logdest)
		{
			tgt = target;
			lvi = new ListViewItem(new string [] {tgt.Address, test.Name, "Not Run"});
			tst = test;
			log = logdest;
		}
		#endregion

		#region public void Run(ulong puid)
		public void Run(ulong puid)
		{
			log.AddText("Running '" + tst.Name + "' against '" + tgt.Address + "...  ");
			try
			{
				tst.Run(tgt, puid);
				lvi.SubItems[2].Text = "Pass";
				lvi.BackColor = Color.Green;
				log.AddText("Pass\r\n");
				tgt.Pass++;
			}
			catch(System.Exception exc)
			{
				lvi.SubItems[2].Text = "Fail";
				lvi.BackColor = Color.Red;
				log.AddText("Fail\r\n");
				tgt.Fail++;
				System.Exception e = exc;
				while(e != null)
				{
					log.AddText("\t" + e.Message.Replace("\r\n", "\n").Replace("\n", "\r\n") + "\r\n");
					log.AddText(e.StackTrace.Replace("\r\n", "\n").Replace("\n", "\r\n") + "\r\n");
					e = e.InnerException;
				}
			}
		}
		#endregion
	}

	class Health_VerifyConfig : ITestCase
	{
		#region ITestCase Members

		public string Name
		{
			get
			{
				return "VerifyConfig (Health)";
			}
		}

		public string Run(IPData data, ulong puid)
		{
			// TODO:  Add Health_VerifyConfig.Run implementation
			string s = Widgets.Health(data, null).VerifyConfig();
			if(s != "OK!")
				throw new Exception("Health.VerifyConfig returned '" + s + "'");
			return null;
		}

		#endregion

	}


	class Accounts_GetGamertag : ITestCase
	{
		#region ITestCase Members

		public string Name
		{
			get
			{
				return "GetGamertag (Accounts)";
			}
		}

		public string Run(IPData data, ulong puid)
		{
			// TODO:  Add Accounts_GetGamertag.Run implementation
			string s = Widgets.Accounts(data, null).GetGamertag(puid);
			if(s == null || s.Length == 0 || s.IndexOf('?') >= 0)
				throw new Exception("Accounts.GetGamertag returned an gamertag for the puid 0x" + puid.ToString("X16") + " make sure this is a valid user puid.");
			return null;
		}

		#endregion

	}


	class Accounts_SendUserFeedback : ITestCase
	{
		#region ITestCase Members

		public string Name
		{
			get
			{
				return "SendUserFeedback (Accounts)";
			}
		}

		public string Run(IPData data, ulong puid)
		{
			Widgets.Accounts(data, Widgets.GetAuthData(data.Address, puid)).SendUserFeedback(0xA7049955, puid, puid, 1, "none");
			return null;
		}

		#endregion

	}


	class Presence_GetFriends : ITestCase
	{
		#region ITestCase Members

		public string Name
		{
			get
			{
				return "GetFriends (Presence)";
			}
		}

		public string Run(IPData data, ulong puid)
		{
			Widgets.Presence(data, Widgets.GetAuthData(data.Address, puid)).GetFriends(puid, 1);
			return null;
		}

		#endregion

	}


	class Accounts_GetUserInfo : ITestCase
	{
		#region ITestCase Members

		public string Name
		{
			get
			{
				return "GetUserInfo (Accounts)";
			}
		}

		public string Run(IPData data, ulong puid)
		{
			Accounts.UserInfo u = Widgets.Accounts(data, Widgets.GetAuthData(data.Address, puid)).GetUserInfo(puid);
			if(u == null)
				throw new Exception("Accounts.GetUserInfo returned null!");
			return null;
		}

		#endregion

	}


	class VIPCheck
	{
		IPData ip;
		Logger log;
		ManualResetEvent mre;
		ulong puid;
		Thread t;

		public VIPCheck(IPData targetip, Logger logdest, ManualResetEvent mrequit, ulong userpuid)
		{
			ip = targetip;
			log = logdest;
			mre = mrequit;
			puid = userpuid;

			t = new Thread(new ThreadStart(this.testThread));
			t.Start();
		}

		void testThread()
		{
			Accounts.Accounts a = Widgets.Accounts(ip, Widgets.GetAuthData(ip.Address, puid));

			lock(log)
			{
				log.AddText("Starting stress with Accounts.GetGamertag through the VIP at '" + ip.Address + "'\r\n");
			}

			while(!mre.WaitOne(0, false))
			{
				try
				{
					a.GetGamertag(puid);
				}
				catch(System.Exception exc)
				{
					lock(log)
					{
						log.AddText("Failed calling Accounts.GetGamertag through the VIP at '" + ip.Address + "'\r\n");
						System.Exception e = exc;
						while(e != null)
						{
							log.AddText("\t" + e.Message.Replace("\r\n", "\n").Replace("\n", "\r\n") + "\r\n");
							log.AddText(e.StackTrace.Replace("\r\n", "\n").Replace("\n", "\r\n") + "\r\n");
							e = e.InnerException;
						}
						return;
					}
				}
			}
			log.AddText("Finished stress with Accounts.GetGamertag through the VIP at '" + ip.Address + "'\r\n");

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelquickcheck\Widgets.cs ===
using System;
using ServerTestFramework.LiveService;
using ServerTestFramework;
using System.Web.Services;
using System.Web;
using System.Net;
using System.Web.Services.Protocols;

namespace svctunnelquickcheck
{
	/// <summary>
	/// Summary description for Widgets.
	/// </summary>
	class Widgets
	{
		#region HTTPAuthData GetAuthData(*)
		/*
		public static string GetAuthData(ServerTestFramework.LiveService.PresNotiCommon.PNUser user)
		{
			HTTPAuthData auth = GetAuthData2(user.UserId, user.Xbox.TitleId);
			auth.dwTitleRegion = user.Xbox.TitleRegion;
			auth.dwTitleVersion = user.Xbox.TitleVer;
			auth.qwXboxID = user.Xbox.XboxId;
			return auth.GetBase64EncodedString();
		}
		*/

		public static string GetAuthData(string tgt, ulong puid, uint titleID)
		{
			return GetAuthData2(tgt, puid, titleID).GetBase64EncodedString();
		}

		public static HTTPAuthData GetAuthData2(string tgt, ulong puid, uint titleID)
		{
			ulong	requestId = (ulong)new Random().NextDouble() * 0xffffffffffffffff;
			uint	ip = 0;
			IPHostEntry hst = System.Net.Dns.GetHostEntry(tgt);
			byte [] addr = hst.AddressList[0].GetAddressBytes();
			for(int i = 0; i < addr.Length; i++)
				ip = (ip << 8) + addr[i];
			
			return new HTTPAuthData(4541, ip, requestId, puid, titleID, (uint)XOService.User_Account, (uint)XOService.Presence);
		}

		public static string GetAuthData(string tgt, ulong puid)
		{
			return GetAuthData(tgt, puid, 0xFFFE0000);
		}
		#endregion

		#region class AccountOverride : Accounts.Accounts
		class AccountOverride : Accounts.Accounts
		{
			string authdata = null;
			protected AccountOverride()
			{
			}

			public AccountOverride(IPData ip, string auth)
			{
				Url = "http://" + ip.Address + ":4541/svctunnel/accounts.asmx";
				authdata = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(authdata != null)
					hwr.Headers.Add(HTTPAuthData.HTTP_HEADER_AUTH_DATA, authdata);
				return hwr;
			}
		}
		#endregion

		#region class PresenceOverride : Presence.Presence
		class PresenceOverride : Presence.Presence
		{
			string authdata = null;
			protected PresenceOverride()
			{
			}

			public PresenceOverride(IPData ip, string auth)
			{
				Url = "http://" + ip.Address + ":4541/svctunnel/presence.asmx";
				authdata = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(authdata != null)
					hwr.Headers.Add(HTTPAuthData.HTTP_HEADER_AUTH_DATA, authdata);
				return hwr;
			}
		}
		#endregion

		#region class HealthOverride : Health.Health
		class HealthOverride : Health.Health
		{
			string authdata = null;
			protected HealthOverride()
			{
			}

			public HealthOverride(IPData ip, string auth)
			{
				Url = "http://" + ip.Address + ":4541/svctunnel/health.asmx";
				authdata = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(authdata != null)
					hwr.Headers.Add(HTTPAuthData.HTTP_HEADER_AUTH_DATA, authdata);
				return hwr;
			}
		}
		#endregion

		public static Accounts.Accounts Accounts(IPData ip, string auth)
		{
			Accounts.Accounts a = new AccountOverride(ip, auth);
			return a;
		}

		public static Presence.Presence Presence(IPData ip, string auth)
		{
			Presence.Presence p = new PresenceOverride(ip, auth);
			return p;
		}

		public static Health.Health Health(IPData ip, string auth)
		{
			Health.Health h = new HealthOverride(ip, auth);
			return h;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelfunctional\Func_Presence.cs ===
using System;
using System.Text;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.FakeSG;
using System.IO;
using System.Collections;
using ServerTestFramework.LiveService.Auth;

namespace svctunnelfunctional
{
	enum ExpectFailure
	{
		No,
		Yes
	};

	enum WaitOperation
	{
		SendFriendRequest,
		AcceptFriendRequest,
		RemoveFriendRequest
	};

	/// <summary>
	/// Provides some basic tools for validating friends
	/// </summary>
	class PresUtils
	{
		static FriendsCommon fc = null;
		static ushort WaitOnMessageListChangeSec = 15;
		/// <summary>
		/// Uses a static FriendsCommon struct and ensures it is initialized properly
		/// </summary>
		#region public static FriendsCommon Friends
		public static FriendsCommon Friends
		{
			get{if(fc == null) fc = new FriendsCommon(); return fc;}
		}
		#endregion

		/// <summary>
		/// Takes a user and ensures that the friends list consists of users in the FriendsToBe list, 
		/// removes extraneous messages, and ensures there are count friends from the FriendsToBe list.
		/// </summary>
		/// <param name="user2">User to update the buddy list of</param>
		/// <param name="count">Number of buddies to have from the FriendsToBe list</param>
		#region public static void SetBuddies(PNUser user, uint count)
		public static void SetBuddies(PNUser user2, uint count)
		{

			RandomEx r = new RandomEx();
			if(count > 100)
				throw new ArgumentException("The count argument is out of range for SetBuddies.  It must be from 0 to 100.");
			ArrayList al = new ArrayList();
			bool fRepeat = true;

			#region Remove all friends in the buddy list that aren't in the FriendsToBe list
			while(!fRepeat)
			{
				fRepeat = false;
				IDictionaryEnumerator e = user2.BuddyEnumerator;
				while(e.MoveNext())
				{
					ulong u = (ulong)e.Key;

					if(UserStore.FriendsLookup[u] == null)
					{
						bool successful = false;
						PNUser del = PNUser.Find(u);
						if(del == null)
						{
							PNUser.BuddyInfo info = user2.GetBuddyInfo(u);
							del = new PNUser(info.Name, u);
						}
						while(!successful)
						{
							try
							{
								if(r.NextBool())
								{
									ClientRemoveFriend(user2, del, ExpectFailure.No);
								}
								else
								{
									CheckersRemoveFriend(user2, del, ExpectFailure.No);
								}
								user2.WaitForBuddyStatusDeleted(del);

								successful = true;
							}
							catch
							{
								System.Threading.Thread.Sleep(100);
							}
						}
					}
				}
				ComparePresenceCheckers(user2);
			}
			#endregion


			#region If there are more buddies than we should have, remove the excess
			while(user2.BuddiesAny > count)
			{
				al.Clear();
				PNUser del = null;
				long todel = user2.BuddiesAny - count;
				IDictionaryEnumerator e = user2.BuddyEnumerator;
				while(e.MoveNext())
				{
					ulong u = (ulong)e.Key;
					del = PNUser.Find(u);
					if(del == null)
					{
						PNUser.BuddyInfo info = user2.GetBuddyInfo(u);
						del = new PNUser(info.Name, u);
					}
					al.Add(del);
					--todel;
					if(todel == 0)
						break;
				}

				foreach(PNUser d in al)
				{
					bool successful = false;
					while(!successful)
					{
						try
						{
							if(r.NextBool())
							{
								user2.DeleteBuddy(d);
							}
							else
							{
								Widgets.Presence(Widgets.GetAuthData(user2.UserId)).RemoveFriend(user2.UserId, d.UserId);
							}
							user2.WaitForBuddyStatusDeleted(d);
							successful = true;
						}
						catch
						{
							System.Threading.Thread.Sleep(100);
						}
					}
				}

				ComparePresenceCheckers(user2);
			}
			#endregion


			#region Sends invites for the remaining people I need to to get them on the friends list.
			// Breaking this loop into two parts: one to send friend requests really quickly and the other loop
			// to answer them after syncing.  Then resync again after done.  So loop-sync, loop-sync.
			while(user2.BuddiesAny < count)
			{
				uint todo = ((uint) count) - ((uint) user2.BuddiesAny);
				uint i = 0;
				while(todo > 0 && i < UserStore.FriendsToBe.Length)
				{
					if(user2.GetBuddyInfo(UserStore.FriendsToBe[i].UserId) == null)
					{
						bool successful = false;
						while(!successful)
						{
							try
							{
								switch(r.Next(3))
								{
									case 0:
										user2.AddBuddy(UserStore.FriendsToBe[i]);
										break;
									case 1:
										Widgets.Presence(Widgets.GetAuthData(user2.UserId)).SendFriendsRequest(user2.UserId, UserStore.FriendsToBe[i].UserId);
										break;
									case 2:
										Widgets.Presence(Widgets.GetAuthData(user2.UserId)).SendFriendsRequestByGamertag(user2.Name, UserStore.FriendsToBe[i].Name);
										break;
								};
								user2.WaitForBuddyStatusPending(UserStore.FriendsToBe[i]);
								--todo;
								successful = true;
							}
							catch
							{
								System.Threading.Thread.Sleep(100);
							}
						}
					}
					++i;
				}
			}
			#endregion


			#region Replies to the invites until all friends are accepted
			fRepeat = true;
			while(fRepeat)
			{
				fRepeat = false;
				IDictionaryEnumerator en = user2.BuddyEnumerator;
				while(en.MoveNext())
				{
					ulong friendpuid = (ulong)en.Key;
					if(user2.GetBuddyInfo(friendpuid).Status == 1)
					{
						bool successful = false;
						while(!successful)
						{
							try
							{
								switch(r.Next(2))
								{
									case 0:
										((PNUser) UserStore.FriendsLookup[friendpuid]).AcceptBuddy(user2);
										break;
									case 1:
										Widgets.Presence(Widgets.GetAuthData(friendpuid)).AnswerFriendsRequest(friendpuid, user2.UserId, 1);
										break;
									case 2:
										Widgets.Presence(Widgets.GetAuthData(friendpuid)).AnswerFriendsRequestByGamertag(((PNUser) UserStore.FriendsLookup[friendpuid]).Name, user2.Name, 1);
										break;
								};
								user2.WaitForBuddyStatusOK((PNUser) UserStore.FriendsLookup[friendpuid]);
								successful = true;
							}
							catch(Exception e)
							{
								ConsoleX.WriteLine("SetBuddies exception: " + e.ToString());
                                System.Threading.Thread.Sleep(100);
								Friends.LogoffUser(user2);
								ConsoleX.WriteLine("Sleeping 30 seconds because AnswerFriendRequest notifications are voiding themselves.");
								System.Threading.Thread.Sleep(30000);
								Friends.LogonUser(user2);
							}
						}
					}
				}

				ComparePresenceCheckers(user2);
			}
			#endregion

			// Clear all the messaged I have generated.
			ClearMessages(user2);
		}
		#endregion

		/// <summary>
		/// Logs on user ui without deleting his buddies.
		/// </summary>
		/// <param name="ui">User to logon</param>
		/// <returns>PNUser--Presence-Notfication user</returns>
		#region public static PNUser LogonUser(UserInfo ui)
		public static PNUser LogonUser(UserInfo ui)
		{
			return LogonUser(ui, false, false);
		}
		#endregion

		/// <summary>
		/// Logs on user defined by UserInfo ui and optionally deletes all his buddies (for clean tests)
		/// </summary>
		/// <param name="ui">User to logon</param>
		/// <param name="DeleteAllBuddies">Whether to delete buddies</param>
		/// <param name="DeleteAllMessages">Whether to delete all messages</param>
		/// <returns>PNUser--Presence-Notification user</returns>
		#region public static PNUser LogonUser(UserInfo ui, bool DeleteAllBuddies, bool DeleteAllMessages)
		public static PNUser LogonUser(UserInfo ui, bool DeleteAllBuddies, bool DeleteAllMessages)
		{
			/*
			PNUser u = PNUser.Find(ui.UserPuid);
			if(u == null)
				u = new PNUser(ui.User.gamertag, ui.UserPuid);
			if(!u.LoggedOn)
			{
				uint i = PresUtils.Friends.LogonUser(u);
			}
			*/
			PNUser u = new PNUser(ui.User.gamertag, ui.UserPuid);
			uint i = PresUtils.Friends.LogonUser(u);

			if(DeleteAllBuddies || DeleteAllMessages)
			{
				ClearMessages(u);
			}

			if(DeleteAllBuddies && u.BuddiesAny > 0)
			{
				ArrayList al = new ArrayList();
				RandomEx r = new RandomEx();
				IDictionaryEnumerator e = u.BuddyEnumerator;
				while(e.MoveNext())
				{
					ulong x = (ulong)e.Key;
					PNUser del = PNUser.Find(x);
					if(del == null)
					{
						PNUser.BuddyInfo info = u.GetBuddyInfo(x);
						del = new PNUser(info.Name, x);
					}
					al.Add(del);
					if(r.NextBool())
					{
						u.DeleteBuddy(del);
					}
					else
					{
						Widgets.Presence(Widgets.GetAuthData(u.UserId)).RemoveFriend(u.UserId,x);
					}
				}
				foreach(PNUser del in al)
				{
					u.WaitForBuddyStatusDeleted(del);
				}
				u.GetListChangeNotifications();

				al.Clear();
				/*
				foreach(ulong x in u.Blocks)
				{
					PNUser del = PNUser.Find(x);
					if(del == null)
					{
						del = new PNUser("Blah", x);
					}
					al.Add(del);
					if(r.NextBool())
					{
						u.UnMute(del);
					}
					else
					{
						Widgets.Presence(null).RemoveUserFromMutelist(u.UserId, x);
					}
				}
				foreach(PNUser del in al)
				{
					u.GetNotifications(XonPresNoti.
				}
				*/
			}


			PresUtils.ComparePresenceCheckers(u);
			return u;
		}
		#endregion

		enum FilterTableType
		{
			None,
			Puids,
			Gamertags
		}

		#region static void ComparePresenceCheckersHelper(PNUser u, Presence.Friend [] fs, Hashtable usersSelected)
		static void ComparePresenceCheckersHelper(PNUser u, Presence.Friend [] fs, Hashtable usersSelected)
		{
			StringBuilder sb = new StringBuilder(); // Stores cumulative result for a potential exception
			Hashtable ht = new Hashtable();			// Stores the friends list in quick lookup form for the second loop

			FilterTableType tableType = FilterTableType.None;

			if(usersSelected == null)
				tableType = FilterTableType.None;
			else if(usersSelected.Count == 0)
				tableType = FilterTableType.Puids;
			else
			{
				tableType = FilterTableType.Gamertags;
				foreach(object o in usersSelected.Keys)
				{
					if(o == null)
						continue;
					if(o.GetType() == typeof(ulong))
						tableType = FilterTableType.Puids;
					else
						tableType = FilterTableType.Gamertags;
					break;
				}
			}

			// First make sure that every friend in the widget friends list matches what is in presence
			if(fs != null)
			{
				foreach(Presence.Friend f in fs)
				{
					// Verify I haven't returned more information than requested.
					if((FilterTableType.Puids == tableType && usersSelected[f.userId] == null) ||
						(FilterTableType.Gamertags == tableType && usersSelected[f.gamertag.ToLower()] == null))
					{
						sb.Append("\tCheckers returned friend information for a user not in my filtered list for user 0x").Append(f.userId.ToString("X16")).Append(".\r\n");
					}

					ht.Add(f.userId, f); // Ensures no duplicates
					PNUser.BuddyInfo bi = u.GetBuddyInfo(f.userId);
					if(bi == null && ((f.friendState & 0x80000000) != 0x80000000)) // There are cases where stray invite messages can be left over, skip them for error results
					{
						sb.Append("\tCheckers reported 0x").Append(f.userId.ToString("X16")).Append(" but the client doesn't.\r\n");
						continue;
					}
					else if(bi == null) // If this is still null, then continue (it's a messaging mismatch, known issue)
					{
						continue;
					}
					else if(bi.Name != f.gamertag)
						sb.Append("\tCheckers reported a different name than presence for '").Append(f.gamertag).Append("' and '").Append(bi.Name).Append("', respectively.\r\n");
					else if((bi.Status == 0 && ((f.friendState & 0xC0000000) != 0)) ||
						bi.Status == 2 && ((f.friendState & 0x80000000) != 0x80000000))
						sb.Append("\tCheckers reported a different state than presence for puid 0x").Append(f.userId.ToString("X16")).Append("\r\n");

					if(bi.Status == 0 && ((f.friendState & 0xC0000000) != 0) &&
						((bi.Invitation != null && ((f.friendState  & 0x08000000) != 0x08000000)) ||
						(bi.Invitation == null && ((f.friendState  & 0x08000000) == 0x08000000)) ||
						(bi.Invitation.MatchSessionID != f.sessionID) ||
						(bi.Invitation.TitleID != f.titleID) ||
						(bi.Invitation.TimeSent != f.gameinviteTime)))
					{	
						sb.Append("\tCheckers reported different game invitation data than presence from puid 0x").Append(f.userId.ToString("X16")).Append("\r\n");
					}

					if(		XonPresNoti.P_BUDDY_STATUS_OK == bi.Status 
							&& (f.friendState & 0x80000000) != 0x80000000 
							&& (f.friendState & 0x1) == 0x1)
					{
						// This line commented out since it isn't implemented yet.  Bug #36865
						// bi.Presence.MatchSessionID != f.sessionID || 
						if(bi.Presence == null)
						{
							sb.Append("\tCheckers reported 0x").Append(f.userId.ToString("X16")).Append(" with missing bi.Presence data.\r\n");
						} 

						if(bi.Presence.State != f.friendState)
						{
							sb.Append("\tCheckers reported 0x").Append(f.userId.ToString("X16")).Append(" with mismatch state: ");
							sb.Append(bi.Presence.State.ToString("x")).Append(" != " ).Append(f.friendState.ToString("x"));
							sb.Append("\r\n");
						}
					
						if(bi.Presence.TitleID != f.titleID)
						{
							sb.Append("\tCheckers reported 0x").Append(f.userId.ToString("X16")).Append(" with mismatch state: ");
							sb.Append(bi.Presence.TitleID.ToString("x")).Append(" != " ).Append(f.titleID.ToString("x"));
							sb.Append("\r\n");
						}
						
						if((bi.Presence.TitleStuffLen + bi.Presence.NicknameLen) != f.StateData.Length)
						{
							sb.Append("\tCheckers reported 0x").Append(f.userId.ToString("X16")).Append(" with mismatch total title stuff length: ");
							sb.Append((bi.Presence.TitleStuffLen + bi.Presence.NicknameLen)).Append(" != " ).Append(f.StateData.Length);
							sb.Append("\r\n");
						}

						if(f.StateData.Length > 32)
						{
							sb.Append("\tCheckers reported 0x").Append(f.userId.ToString("X16")).Append(" with title statedata length > 32: ");
							sb.Append(Hexer.tohex(f.StateData));
							sb.Append("\r\n");
						}

						if(bi.Presence.TitleStuffLen > 0 && !ArrayEx.SubArrayCompare(f.StateData, 0, bi.Presence.TitleStuffLen, bi.Presence.TitleStuff, 0, bi.Presence.TitleStuffLen))
						{
							byte []state	= new byte[8];
							Array.Copy(f.StateData, 0, state, 0, f.StateData.Length > 8 ? 8 : f.StateData.Length);

							sb.Append("\tCheckers reported 0x").Append(f.userId.ToString("X16")).Append(" with different title bytes data: ");
							sb.Append(Hexer.tohex(bi.Presence.TitleStuff));
							sb.Append(" != ");
							sb.Append(Hexer.tohex(state));
							sb.Append("\r\n");
						}

						if(bi.Presence.NicknameLen > 0 && !ArrayEx.SubArrayCompare(f.StateData, 8, 8 + bi.Presence.NicknameLen, bi.Presence.Nickname, 0, bi.Presence.NicknameLen))
						{
							byte []nickname	= new byte[24];
							Array.Copy(f.StateData, 8, nickname, 0, f.StateData.Length - 8);

							sb.Append("\tCheckers reported 0x").Append(f.userId.ToString("X16")).Append(" with different nickname bytes data: ");
							sb.Append(Hexer.tohex(bi.Presence.Nickname));
							sb.Append(" != ");
							sb.Append(Hexer.tohex(nickname));
							sb.Append("\r\n");
						}
					}
				}
			}
			// Then make sure that every fully accepted friend in presence is in the widget only if I'm not filtering or
			// the user was selected (when filtering)
			IDictionaryEnumerator e = u.BuddyEnumerator;
			while(e.MoveNext())
			{
				ulong i = (ulong)e.Key;
				PNUser.BuddyInfo bi = e.Value as PNUser.BuddyInfo;
				if(bi.Status != XonPresNoti.P_BUDDY_STATUS_OK)
					continue;
				Presence.Friend f = (Presence.Friend) ht[i];
				if(f == null &&
					(FilterTableType.None == tableType ||
					(FilterTableType.Puids == tableType && usersSelected[i] != null) ||
					(FilterTableType.Gamertags == tableType && usersSelected[bi.Name.ToLower()] != null)))
					sb.Append("\tPresence reports user 0x").Append(i.ToString("X16")).Append(" as a full friend, but Checkers doesn't list them.\r\n");
			}

			// There were errors, throw an exception.
			if(sb.Length > 0)
				throw new Exception("Checkers/Presence mismatch in the friends list for user 0x" + u.UserId.ToString("X16") + "\r\n" + sb.ToString());
		}
		#endregion

		#region public static void ComparePresenceCheckersFromList(PNUser u, ulong [] puidList)
		public static void ComparePresenceCheckersFromList(PNUser u, ulong [] puidList)
		{
			Hashtable ht = new Hashtable();
			foreach(ulong l in puidList)
				ht[l] = 1;
			Presence.Friend [] fs = Widgets.Presence(Widgets.GetAuthData(u.UserId)).GetFriendsFromList(u.UserId, puidList, 1);
			ComparePresenceCheckersHelper(u, fs, ht);
		}
		#endregion

		#region public static void ComparePresenceCheckersFromListByGamertag(PNUser u, string [] gtList)
		public static void ComparePresenceCheckersFromListByGamertag(PNUser u, string [] gtList)
		{
			Hashtable ht = new Hashtable();
			foreach(string s in gtList)
				if(s != null)
				{
					ht[s.ToLower()] = 1;
				}
			Presence.Friend [] fs = Widgets.Presence(Widgets.GetAuthData(u.UserId)).GetFriendsFromListByGamertag(u.UserId, gtList, 1);
			ComparePresenceCheckersHelper(u, fs, ht);
		}
		#endregion

		/// <summary>
		/// Retrieves checkers friends list and compares against the buddy list for the user in PNUser.
		/// </summary>
		/// <param name="u">The logged on user to compare against checkers friends</param>
		#region public static void ComparePresenceCheckers(PNUser u)
		public static void ComparePresenceCheckers(PNUser u)
		{
			Presence.Friend [] fs = Widgets.Presence(Widgets.GetAuthData(u.UserId)).GetFriends(u.UserId, 1);

			ComparePresenceCheckersHelper(u, fs, null);
		}
		#endregion

		/// <summary>
		/// Waits for the status change of the user's messaging and presence status.
		/// </summary>
		/// <param name="from">The intiator of the request</param>
		/// <param name="to">The user affected</param>
		/// <param name="op">Operation being performed (SendFriendRequest, AcceptFriendRequest, RemoveFriendRequest)</param>
		/// <param name="expectation">Whether failure is expected</param>
		#region public static void WaitOnStatusChange(PNUser from, PNUser to, WaitOperation op, ExpectFailure expectation)
		public static void WaitOnStatusChange(PNUser from, PNUser to, WaitOperation op, ExpectFailure expectation)
		{
			switch(op)
			{
				case WaitOperation.SendFriendRequest:
					if(expectation == ExpectFailure.No)
					{
						from.WaitForBuddyStatusPending(to);
						to.WaitForBuddyStatusRequested(from);

						DateTime dt = DateTime.Now;

						// Make sure we get the message too
						ServerTestFramework.LiveService.Notification.UserMsgFolder m = new ServerTestFramework.LiveService.Notification.UserMsgFolder(to);
						m.Load();

						while(m.FindBySender(2, from.UserId).Length == 0)
						{
							TimeSpan ts = DateTime.Now.Subtract(dt);
							if(ts.TotalMilliseconds > WaitOnMessageListChangeSec * 1000)
								throw new TimeOutException(WaitOnMessageListChangeSec, "Timed out waiting for the message from 0x" + from.UserId.ToString("X16") + " to 0x" + to.UserId.ToString("X16") + " to occur indicating a friends request.");
							System.Threading.Thread.Sleep(100);
							m.Load();
						}
					}
					else
					{
						bool res = false;
						try
						{
							from.WaitForBuddyStatusPending(to);
							from.GetNotifications(XonPresNoti.PQUEUE_LIST_CHANGE);
						}
						catch
						{
							res = true;
						}
						if(!res)
							throw new Exception("There was an expectation of failure sending a friend request from 0x" + from.UserId.ToString("X16") + " to 0x" + to.UserId.ToString("X16"));
					}

					break;
				case WaitOperation.AcceptFriendRequest:
					if(expectation == ExpectFailure.No)
					{
						from.WaitForBuddyStatusOK(to);
						to.WaitForBuddyStatusOK(from);

						// make sure we get announces before we continue so we are sure to have buddyinfo.Presence
						QValPacket qval = null;
						if(null == from.GetBuddyInfo(to.UserId).Presence)
						{
							qval = from.WaitForQFlags(XonPresNoti.QFLAG_MASK_PRESENCE);
							from.HandleQValPacket(qval);
						}

						if(null == to.GetBuddyInfo(from.UserId).Presence)
						{
							qval = to.WaitForQFlags(XonPresNoti.QFLAG_MASK_PRESENCE);
							to.HandleQValPacket(qval);
						}


						// Make sure the message is cleared
						DateTime dt = DateTime.Now;

						ServerTestFramework.LiveService.Notification.UserMsgFolder m = new ServerTestFramework.LiveService.Notification.UserMsgFolder(from);
						m.Load();

						while(m.FindBySender(2, to.UserId).Length > 0)
						{
							TimeSpan ts = DateTime.Now.Subtract(dt);
							if(ts.TotalMilliseconds > WaitOnMessageListChangeSec * 1000)
								throw new TimeOutException(WaitOnMessageListChangeSec, "Timed out waiting for the message from 0x" + to.UserId.ToString("X16") + " to 0x" + from.UserId.ToString("X16") + " to disappear.");
							System.Threading.Thread.Sleep(100);
							m.Load();
						}
					}
					else
					{
						bool res = false;
						try
						{
							from.WaitForBuddyStatusOK(to);
							from.GetNotifications(XonPresNoti.PQUEUE_LIST_CHANGE);
						}
						catch
						{
							res = true;
						}
						if(!res)
							throw new Exception("There was an expectation of failure answering a friend request from 0x" + from.UserId.ToString("X16") + " to 0x" + to.UserId.ToString("X16"));
					}

					break;
				case WaitOperation.RemoveFriendRequest:
					if(expectation == ExpectFailure.No)
					{
						from.WaitForBuddyStatusDeleted(to);
						to.WaitForBuddyStatusDeleted(from);

						// Make sure the message is cleared
					{
						DateTime dt = DateTime.Now;

						ServerTestFramework.LiveService.Notification.UserMsgFolder m = new ServerTestFramework.LiveService.Notification.UserMsgFolder(from);
						m.Load();

						while(m.FindBySender(2, to.UserId).Length > 0)
						{
							TimeSpan ts = DateTime.Now.Subtract(dt);
							if(ts.TotalMilliseconds > WaitOnMessageListChangeSec * 1000)
								throw new TimeOutException(WaitOnMessageListChangeSec, "Timed out waiting for the message from 0x" + to.UserId.ToString("X16") + " to 0x" + from.UserId.ToString("X16") + " to disappear.");
							System.Threading.Thread.Sleep(100);
							m.Load();
						}
					}
					{
						DateTime dt = DateTime.Now;

						ServerTestFramework.LiveService.Notification.UserMsgFolder m = new ServerTestFramework.LiveService.Notification.UserMsgFolder(to);
						m.Load();

						while(m.FindBySender(2, from.UserId).Length > 0)
						{
							TimeSpan ts = DateTime.Now.Subtract(dt);
							if(ts.TotalMilliseconds > WaitOnMessageListChangeSec * 1000)
								throw new TimeOutException(WaitOnMessageListChangeSec, "Timed out waiting for the message from 0x" + from.UserId.ToString("X16") + " to 0x" + to.UserId.ToString("X16") + " to disappear.");
							System.Threading.Thread.Sleep(100);
							m.Load();
						}
					}
					}
					else
					{
						bool res = false;
						try
						{
							from.WaitForBuddyStatusDeleted(to);
							from.GetNotifications(XonPresNoti.PQUEUE_LIST_CHANGE);
						}
						catch
						{
							res = true;
						}
						if(!res)
							throw new Exception("There was an expectation of failure removing a friend from 0x" + from.UserId.ToString("X16") + " to 0x" + to.UserId.ToString("X16"));
					}

					break;
			};

			PresUtils.ComparePresenceCheckers(from);
			PresUtils.ComparePresenceCheckers(to);
		}
		#endregion

		/// <summary>
		/// Sends a friends request through checkers from user "from" to user "to".  You can indicate whether failure is expected (Full list) by the third param.
		/// </summary>
		/// <param name="from">User to send friend request from</param>
		/// <param name="to">User to send friend request to</param>
		/// <param name="expectation">Whether the friend request is expected to fail</param>
		#region public static void CheckersSendFriendRequest(PNUser from, PNUser to, ExpectFailure expectation)
		public static void CheckersSendFriendRequest(PNUser from, PNUser to, ExpectFailure expectation)
		{
			Widgets.Presence(Widgets.GetAuthData(from.UserId)).SendFriendsRequest(from.UserId, to.UserId);

			WaitOnStatusChange(from, to, WaitOperation.SendFriendRequest, expectation);
		}
		#endregion

		/// <summary>
		/// Sends a friends request through checkers from user "from" to user "to".  You can indicate whether failure is expected (Full list) by the third param.
		/// </summary>
		/// <param name="from">User to send friend request from</param>
		/// <param name="to">User to send friend request to</param>
		/// <param name="expectation">Whether the friend request is expected to fail</param>
		#region public static void CheckersSendFriendsRequestByGamertag(PNUser from, PNUser to, ExpectFailure expectation)
		public static void CheckersSendFriendsRequestByGamertag(PNUser from, PNUser to, ExpectFailure expectation)
		{
			RandomEx rand = new RandomEx();
			string fromgt = null, togt = null;
			switch(rand.Next(3))
			{
				case 0:
					fromgt = from.Name;
					break;
				case 1:
					fromgt = from.Name.ToLower();
					break;
				case 2:
					fromgt = from.Name.ToUpper();
					break;
			};

			switch(rand.Next(3))
			{
				case 0:
					togt = to.Name;
					break;
				case 1:
					togt = to.Name.ToLower();
					break;
				case 2:
					togt = to.Name.ToUpper();
					break;
			};

			Widgets.Presence(Widgets.GetAuthData(from.UserId)).SendFriendsRequestByGamertag(fromgt, togt);

			WaitOnStatusChange(from, to, WaitOperation.SendFriendRequest, expectation);
		}
		#endregion

		/// <summary>
		/// Sends a friend request answer through checkers from user "from" to user "to".  You can indicate the answer and whether an error is expected.
		/// </summary>
		/// <param name="from">User to initiate the answer</param>
		/// <param name="to">User to answer to</param>
		/// <param name="answer">0 = No, 1 = Yes, 2 = Never</param>
		/// <param name="expectation">Indicates whether failure is expected</param>
		#region public static void CheckersAnswerFriendRequest(PNUser from, PNUser to, uint answer, ExpectFailure expectation)
		public static void CheckersAnswerFriendRequest(PNUser from, PNUser to, uint answer, ExpectFailure expectation)
		{
			Widgets.Presence(Widgets.GetAuthData(from.UserId)).AnswerFriendsRequest(from.UserId, to.UserId, answer);

			if(answer == 1)
				WaitOnStatusChange(from, to, WaitOperation.AcceptFriendRequest, expectation);
			else
				WaitOnStatusChange(from, to, WaitOperation.RemoveFriendRequest, expectation);
		}
		#endregion

		/// <summary>
		/// Sends a friend request answer through checkers from user "from" to user "to".  You can indicate the answer and whether an error is expected.
		/// </summary>
		/// <param name="from">User to initiate the answer</param>
		/// <param name="to">User to answer to</param>
		/// <param name="answer">0 = No, 1 = Yes, 2 = Never</param>
		/// <param name="expectation">Indicates whether failure is expected</param>
		#region public static void CheckersAnswerFriendsRequestByGamertag(PNUser from, PNUser to, uint answer, ExpectFailure expectation)
		public static void CheckersAnswerFriendsRequestByGamertag(PNUser from, PNUser to, uint answer, ExpectFailure expectation)
		{
			RandomEx rand = new RandomEx();
			string fromgt = null, togt = null;
			switch(rand.Next(3))
			{
				case 0:
					fromgt = from.Name;
					break;
				case 1:
					fromgt = from.Name.ToLower();
					break;
				case 2:
					fromgt = from.Name.ToUpper();
					break;
			};

			switch(rand.Next(3))
			{
				case 0:
					togt = to.Name;
					break;
				case 1:
					togt = to.Name.ToLower();
					break;
				case 2:
					togt = to.Name.ToUpper();
					break;
			};

			Widgets.Presence(Widgets.GetAuthData(from.UserId)).AnswerFriendsRequestByGamertag(fromgt, togt, answer);

			if(answer == 1)
				WaitOnStatusChange(from, to, WaitOperation.AcceptFriendRequest, expectation);
			else
				WaitOnStatusChange(from, to, WaitOperation.RemoveFriendRequest, expectation);
		}
		#endregion
		/// <summary>
		/// Removes a friend through the checkers widget from user "from" to user "to".  You can indicate whether an error is expected.
		/// </summary>
		/// <param name="from">User removing "to"</param>
		/// <param name="to">User to be removed from "from"'s friend list</param>
		/// <param name="expectation">Whether failure is expected</param>
		#region public static void CheckersRemoveFriend(PNUser from, PNUser to, ExpectFailure expectation)
		public static void CheckersRemoveFriend(PNUser from, PNUser to, ExpectFailure expectation)
		{
			Widgets.Presence(Widgets.GetAuthData(from.UserId)).RemoveFriend(from.UserId, to.UserId);

			WaitOnStatusChange(from, to, WaitOperation.RemoveFriendRequest, expectation);
		}
		#endregion

		/// <summary>
		/// Sends game invites to the list if users in tos (looks up the title id and session id for current logon session)
		/// </summary>
		/// <param name="from">user to send from</param>
		/// <param name="tos">user list to send to</param>
		/// <param name="expectation">Whether to expect success or failure.</param>
		#region public static void CheckersSendGameInvite(PNUser from, PNUser [] tos, ExpectFailure expectation)
		public static void CheckersSendGameInvite(PNUser from, PNUser [] tos, ExpectFailure expectation)
		{
			uint TitleID = 0;
			ulong sessionid = 0;
			ArrayList al = new ArrayList();
			ServerTestFramework.LiveService.PresNotiCommon.XSessionInfo sessInfo;
			from.GetPeerSession(from, out sessInfo);
			sessionid = sessInfo.XnKId.ab;
			TitleID = sessInfo.TitleId;
			foreach(PNUser to in tos)
			{
				to.ExpectInviteBlip();
				al.Add(to.UserId);
			}
			try
			{
				Widgets.Presence(Widgets.GetAuthData(from)).SendGameInvite(TitleID, from.UserId, sessionid, (ulong []) al.ToArray(typeof(ulong)));
				from.MatchSessionId = sessionid;
			}
			catch
			{
				if(ExpectFailure.Yes == expectation)
					return;
				throw;
			}

			ComparePresenceCheckers(from);
			bool fFailed=false;
			foreach(PNUser to in tos)
			{
				if(ExpectFailure.No == expectation)
				{
					to.GetInviteNotifications();
				}
				else
				{
					try
					{
						to.WaitForInviteBlip();
						to.GetInviteNotifications();
						ComparePresenceCheckers(to);
					}
					catch
					{
						fFailed = true;
					}
				}
			}

			if(ExpectFailure.Yes == expectation && !fFailed)
				throw new Exception("SendGameInvite was expected to fail, however, no failures occurred.");
		}
		#endregion

		/// <summary>
		/// Cancels a sent game invite to the list of users in the tos (looks up the session id from the current from logon session)
		/// </summary>
		/// <param name="from">User that sent the previous invite</param>
		/// <param name="tos">Users that the original invite was sent to</param>
		/// <param name="expectation">Whether failure is expected</param>
		#region public static void CheckersCancelGameInvite(PNUser from, PNUser [] tos, ExpectFailure expectation)
		public static void CheckersCancelGameInvite(PNUser from, PNUser [] tos, ExpectFailure expectation)
		{
			ulong sessionid = 0;
			ArrayList al = new ArrayList();
			ServerTestFramework.LiveService.PresNotiCommon.XSessionInfo sessInfo;
			from.GetPeerSession(from, out sessInfo);
			sessionid = sessInfo.XnKId.ab;
			foreach(PNUser to in tos)
			{
				al.Add(to.UserId);
			}
			try
			{
				Widgets.Presence(Widgets.GetAuthData(from.UserId)).RevokeGameInvite(from.UserId, sessionid, (ulong []) al.ToArray(typeof(ulong)));
			}
			catch
			{
				if(ExpectFailure.Yes == expectation)
					return;
				throw;
			}
			ComparePresenceCheckers(from);
			foreach(PNUser to in tos)
			{
				try
				{
					to.GetInviteNotifications();
					ComparePresenceCheckers(to);
				}
				catch
				{
					if(ExpectFailure.Yes == expectation)
						return;
					throw;
				}
			}
		}
		#endregion

		/// <summary>
		/// Sends a friends request through the client from user "from" to user "to".  You can indicate whether failure is expected (Full list) by the third param.
		/// </summary>
		/// <param name="from">User to send friend request from</param>
		/// <param name="to">User to send friend request to</param>
		/// <param name="expectation">Whether the friend request is expected to fail</param>
		#region public static void ClientSendFriendRequest(PNUser from, PNUser to, ExpectFailure expectation)
		public static void ClientSendFriendRequest(PNUser from, PNUser to, ExpectFailure expectation)
		{
			from.AddBuddy(to);

			WaitOnStatusChange(from, to, WaitOperation.SendFriendRequest, expectation);
		}
		#endregion

		/// <summary>
		/// Sends a friend request answer through the client from user "from" to user "to".  You can indicate the answer and whether an error is expected.
		/// </summary>
		/// <param name="from">User to initiate the answer</param>
		/// <param name="to">User to answer to</param>
		/// <param name="answer">0 = No, 1 = Yes, 2 = Never</param>
		/// <param name="expectation">Indicates whether failure is expected</param>
		#region public static void ClientAnswerFriendRequest(PNUser from, PNUser to, uint answer, ExpectFailure expectation)
		public static void ClientAnswerFriendRequest(PNUser from, PNUser to, uint answer, ExpectFailure expectation)
		{
			if(answer == 1)
			{
				from.AcceptBuddy(to);
				WaitOnStatusChange(from, to, WaitOperation.AcceptFriendRequest, expectation);
			}
			else
			{
				from.RejectBuddy(to, answer == 2);
				WaitOnStatusChange(from, to, WaitOperation.RemoveFriendRequest, expectation);
			}
		}
		#endregion

		/// <summary>
		/// Removes a friend through the client from user "from" to user "to".  You can indicate whether an error is expected.
		/// </summary>
		/// <param name="from">User removing "to"</param>
		/// <param name="to">User to be removed from "from"'s friend list</param>
		/// <param name="expectation">Whether failure is expected</param>
		#region public static void ClientRemoveFriend(PNUser from, PNUser to, ExpectFailure expectation)
		public static void ClientRemoveFriend(PNUser from, PNUser to, ExpectFailure expectation)
		{
			from.DeleteBuddy(to);
			WaitOnStatusChange(from, to, WaitOperation.RemoveFriendRequest, expectation);
		}
		#endregion

		/// <summary>
		/// Clears the list of messages for the user
		/// </summary>
		/// <param name="u">The user to clear the messages for</param>
		#region public static void ClearMessages(PNUser u)
		public static void ClearMessages(PNUser u)
		{
			ServerTestFramework.LiveService.Notification.UserMsgFolder m = new ServerTestFramework.LiveService.Notification.UserMsgFolder(u);
			m.Load();
			m.DeleteAllMessages(false);  // block means put on the never list
		}
		#endregion

		/// <summary>
		/// Sets the notification state for the user "changingUser" and uses "checkUser" to validate the change occurred.
		/// </summary>
		/// <param name="changingUser">The user to change the state for</param>
		/// <param name="checkUser">The user to verify the state was changed</param>
		/// <param name="stateFlags">The new state flags for the user</param>
		/// <param name="sessionId">The new session id</param>
		/// <param name="stateData">the 32 bytes of state data</param>
		/// <param name="expectation">Whether failure is expected</param>
		#region public static void CheckersSetNotificationState(PNUser changingUser, PNUser checkUser, ushort stateFlags, ulong sessionId, byte [] stateData, ExpectFailure expectation)
		public static void CheckersSetNotificationState(PNUser changingUser, PNUser checkUser, ushort stateFlags, ulong sessionId, byte [] stateData, ExpectFailure expectation)
		{
			try
			{
				Widgets.Presence(Widgets.GetAuthData(changingUser.UserId)).SetNotificationState(changingUser.UserId, stateFlags, sessionId, stateData);
			}
			catch
			{
				if(ExpectFailure.Yes == expectation)
					return;
				throw;
			}

			PNUser.PresenceFields pf = (PNUser.PresenceFields) 0x17;
			PresenceItem pi = new PresenceItem();
	
			pi.MatchSessionID = sessionId;
			pi.State = stateFlags;
			pi.Nickname = new byte[24];
			pi.TitleStuff = new byte[8];
			int l = stateData == null ? 0 : (stateData.Length < 8 ? stateData.Length : 8);
			for(int i = 0; i < l; ++i)
				pi.TitleStuff[i] = stateData[i];
			l = stateData == null ? 0 : (stateData.Length < 32 ? stateData.Length - 8 : 24);
			for(int i = 0; i < l; ++i)
				pi.Nickname[i] = stateData[i + 8];
			try
			{
				checkUser.WaitForBuddyPresence(changingUser, pf, pi);
			}
			catch
			{
				if(ExpectFailure.Yes == expectation)
					return;
				throw;
			}
			ComparePresenceCheckers(checkUser);
		}
		#endregion

		public static string GetFakeSGAuthData(UserInfo ui, uint dwRequestID)
		{
			FDTransaction.MyUdpClient localClient=new FDTransaction.MyUdpClient();
			IPAddress localHost = IPAddress.Parse("127.0.0.1");
			CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();
			slot.port=localClient.Bind();		// Get a port so we don't conflict
			slot.userPuid0 = ui.UserPuid;
            slot.ClearServices();
			slot.AddService(XOService.Base_Subscription);
			slot.AddService(XOService.Presence);
			slot.AddService(XOService.User_Account);
			GlobalFakeSG.FakeSG.PutSlot(ref slot, ((IPEndPoint)localClient.Client.LocalEndPoint).Address );

			SgMsgSpiReq req = new SgMsgSpiReq();
			req.Type = SgMsgHeader.SGMSG_TYPE_SPIDATA_REQ;
			req.cbEnt = 14;
			req.ClientPort = (ushort) slot.port;
			req.ClientAddr = new IpAddr("127.0.0.1");
			req.ReqNum = dwRequestID;
			MemoryStream ms = new MemoryStream();
			req.WriteStream(ms);
			ms.Position = 0;

			System.Net.IPEndPoint ep = new System.Net.IPEndPoint(localHost, 0xffff);
			
			localClient.Connect(ep);
			localClient.Send(ms.GetBuffer(), (int) ms.Length);
			byte [] res = localClient.Receive(ref ep);
			string auth = Convert.ToBase64String(res, 0, res.Length);
			localClient.Close();
			return auth;
		}
	}

	/// <summary>
	/// Covers test cases that affect multiple apis simultaneously.
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_Multiple_FriendRequests_0_And_1_Cases_Checkers_Initiated : TestNode
	public class Func_Presence_Multiple_FriendRequests_0_And_1_Cases_Checkers_Initiated : TestNode
	{
		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Accept
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Yes to A, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest Yes-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRYes_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Remove friend (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Decline
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with No to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest No, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRNo : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Never, then recover from Never
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Never to A, checks presence and checkers friends list for both
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest Never-SFR_RF" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRNever_SFR_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 2, ExpectFailure.No);

				// User A is now on B's never, so we send a friend request from A to B to verify
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.Yes);

				// User B now sends user A a friend request to clear A from B's never
				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			[Ignore]
			class Presence_GetFriends_Adult_to_Minor_SFR_RF_B_to_A : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B now deletes user A's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_RF_A_to_B : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, SendFriendRequest back
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Sends Friend Request to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-SendFriendRequest, 0 to 1" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_SFR : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B also happens to send a friend request to A, we don't expect failure, but it might fail since
				// I'm expecting a different result than what I wait for.
				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.Yes);

				// Make sure the friend request is now gone, otherwise wierd behaviour occurs (make sure I'm clean baby!)
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Accept
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Yes to A, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest Yes-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRYes_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Remove friend (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Decline
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with No to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest No, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRNo : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Never, then recover from Never
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Never to A, checks presence and checkers friends list for both
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest Never-SFR_RF" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRNever_SFR_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 2, ExpectFailure.No);

				// User A is now on B's never, so we send a friend request from A to B to verify
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.Yes);

				// User B now sends user A a friend request to clear A from B's never
				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			[Ignore]
			class Presence_GetFriends_Minor_to_Adult_SFR_RF_B_to_A : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B now deletes user A's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_RF_A_to_B : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, SendFriendRequest back
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Sends Friend Request to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-SendFriendRequest, 0 to 1" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_SFR : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B also happens to send a friend request to A, we don't expect failure, but it might fail since
				// I'm expecting a different result than what I wait for.
				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.Yes);

				// Make sure the friend request is now gone, otherwise wierd behaviour occurs (make sure I'm clean baby!)
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers test cases that affect multiple apis simultaneously.
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_Multiple_FriendRequests_0_And_1_Cases_Client_Initiated : TestNode
	public class Func_Presence_Multiple_FriendRequests_0_And_1_Cases_Client_Initiated : TestNode
	{
		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Accept
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Yes to A, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest Yes-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRYes_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Remove friend (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Decline
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with No to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest No, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRNo : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Never, then recover from Never
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Never to A, checks presence and checkers friends list for both
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest Never-SFR_RF" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRNever_SFR_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 2, ExpectFailure.No);

				// User A is now on B's never, so we send a friend request from A to B to verify
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.Yes);

				// User B now sends user A a friend request to clear A from B's never
				PresUtils.ClientSendFriendRequest(UB, UA, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			[Ignore]
			class Presence_GetFriends_Adult_to_Minor_SFR_RF_B_to_A : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B now deletes user A's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_RF_A_to_B : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, SendFriendRequest back
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Sends Friend Request to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-SendFriendRequest, 0 to 1" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_SFR : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B also happens to send a friend request to A, we don't expect failure, but it might fail since
				// I'm expecting a different result than what I wait for.
				PresUtils.ClientSendFriendRequest(UB, UA, ExpectFailure.Yes);

				// Make sure the friend request is now gone, otherwise wierd behaviour occurs (make sure I'm clean baby!)
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Accept
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Yes to A, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest Yes-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRYes_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Remove friend (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Decline
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with No to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest No, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRNo : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Never, then recover from Never
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Never to A, checks presence and checkers friends list for both
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest Never-SFR_RF" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRNever_SFR_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 2, ExpectFailure.No);

				// User A is now on B's never, so we send a friend request from A to B to verify
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.Yes);

				// User B now sends user A a friend request to clear A from B's never
				PresUtils.ClientSendFriendRequest(UB, UA, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			[Ignore]
			class Presence_GetFriends_Minor_to_Adult_SFR_RF_B_to_A : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B now deletes user A's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_RF_A_to_B : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, SendFriendRequest back
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Sends Friend Request to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-SendFriendRequest, 0 to 1" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_SFR : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B also happens to send a friend request to A, we don't expect failure, but it might fail since
				// I'm expecting a different result than what I wait for.
				PresUtils.ClientSendFriendRequest(UB, UA, ExpectFailure.Yes);

				// Make sure the friend request is now gone, otherwise wierd behaviour occurs (make sure I'm clean baby!)
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}
	}
	#endregion


	/// <summary>
	/// Covers test cases that affect multiple apis simultaneously.
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_Multiple_FriendRequests_99_And_100_Cases_Checkers_Initiated : TestNode
	public class Func_Presence_Multiple_FriendRequests_99_And_100_Cases_Checkers_Initiated : TestNode
	{
		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Accept
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Yes to A, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest Yes-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRYes_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Remove friend (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Decline
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with No to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest No, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRNo : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Never, then recover from Never
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Never to A, checks presence and checkers friends list for both
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest Never-SFR_RF" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRNever_SFR_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 2, ExpectFailure.No);

				// User A is now on B's never, so we send a friend request from A to B to verify
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.Yes);

				// User B now sends user A a friend request to clear A from B's never
				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			[Ignore]
			class Presence_GetFriends_Adult_to_Minor_SFR_RF_B_to_A : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B now deletes user A's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_RF_A_to_B : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, SendFriendRequest back
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Sends Friend Request to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-SendFriendRequest, 0 to 1" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_SFR : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B also happens to send a friend request to A, we don't expect failure, but it might fail since
				// I'm expecting a different result than what I wait for.
				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.Yes);

				// Make sure the friend request is now gone, otherwise wierd behaviour occurs (make sure I'm clean baby!)
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Accept
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Yes to A, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest Yes-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRYes_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Remove friend (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Decline
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with No to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest No, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRNo : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Never, then recover from Never
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Never to A, checks presence and checkers friends list for both
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest Never-SFR_RF" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRNever_SFR_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 2, ExpectFailure.No);

				// User A is now on B's never, so we send a friend request from A to B to verify
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.Yes);

				// User B now sends user A a friend request to clear A from B's never
				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			[Ignore]
			class Presence_GetFriends_Minor_to_Adult_SFR_RF_B_to_A : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B now deletes user A's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_RF_A_to_B : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, SendFriendRequest back
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Sends Friend Request to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-SendFriendRequest, 0 to 1" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_SFR : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B also happens to send a friend request to A, we don't expect failure, but it might fail since
				// I'm expecting a different result than what I wait for.
				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.Yes);

				// Make sure the friend request is now gone, otherwise wierd behaviour occurs (make sure I'm clean baby!)
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}
	}
	#endregion


	/// <summary>
	/// Covers test cases that affect multiple apis simultaneously.
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_Multiple_FriendRequests_99_And_100_Cases_Client_Initiated : TestNode
	public class Func_Presence_Multiple_FriendRequests_99_And_100_Cases_Client_Initiated : TestNode
	{
		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Accept
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Yes to A, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest Yes-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRYes_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Remove friend (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Decline
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with No to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest No, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRNo : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Never, then recover from Never
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Never to A, checks presence and checkers friends list for both
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-AnswerFriendRequest Never-SFR_RF" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_AFRNever_SFR_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 2, ExpectFailure.No);

				// User A is now on B's never, so we send a friend request from A to B to verify
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.Yes);

				// User B now sends user A a friend request to clear A from B's never
				PresUtils.ClientSendFriendRequest(UB, UA, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			[Ignore]
			class Presence_GetFriends_Adult_to_Minor_SFR_RF_B_to_A : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B now deletes user A's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_RF_A_to_B : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Adult To Minor, SendFriendRequest back
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Adult
		///		B = Minor
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Sends Friend Request to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Adult to Minor, SendFriendRequest-SendFriendRequest, 0 to 1" )]
			class Presence_GetFriends_Adult_to_Minor_SFR_SFR : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B also happens to send a friend request to A, we don't expect failure, but it might fail since
				// I'm expecting a different result than what I wait for.
				PresUtils.ClientSendFriendRequest(UB, UA, ExpectFailure.Yes);

				// Make sure the friend request is now gone, otherwise wierd behaviour occurs (make sure I'm clean baby!)
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Accept
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Yes to A, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest Yes-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRYes_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Remove friend (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Decline
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with No to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest No, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRNo : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Never, then recover from Never
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Answers Friend Request with Never to A, checks presence and checkers friends list for both
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-AnswerFriendRequest Never-SFR_RF" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_AFRNever_SFR_RF : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// Answer the friend request (1 to 0), wait for client to know, then compare checkers and pres
				PresUtils.ClientAnswerFriendRequest(UB, UA, 2, ExpectFailure.No);

				// User A is now on B's never, so we send a friend request from A to B to verify
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.Yes);

				// User B now sends user A a friend request to clear A from B's never
				PresUtils.ClientSendFriendRequest(UB, UA, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Removes Friend A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			[Ignore]
			class Presence_GetFriends_Minor_to_Adult_SFR_RF_B_to_A : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B now deletes user A's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, both with zero friends, Remove
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			A Removes Friend B, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-Remove Friend, 0 to 1 to 0" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_RF_A_to_B : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User A now deletes user B's friend request cause they had such a terrible falling out and this doesn't quite make up for it.
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		///		Send Friend Request from Minor To Adult, SendFriendRequest back
		///	</summary>
		///	<remarks>
		///		<Description>
		///		A = Minor
		///		B = Adult
		///		Covers:
		///			A Sends Friend Request to B, checks presence and checkers friends list for both
		///			B Sends Friend Request to A, checks presence and checkers friends list for both
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		///	</remarks>
		[TestCase, Description( "Minor to Adult, SendFriendRequest-SendFriendRequest, 0 to 1" )]
			class Presence_GetFriends_Minor_to_Adult_SFR_SFR : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				// Make sure their buddy lists are empty
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				// Make sure I have 99 users
				PresUtils.SetBuddies(UA, 99);
				PresUtils.SetBuddies(UB, 99);

				// Do the send friend request (0 to 1), wait for client to know, then compare checkers and pres
				PresUtils.ClientSendFriendRequest(UA, UB, ExpectFailure.No);

				// User B also happens to send a friend request to A, we don't expect failure, but it might fail since
				// I'm expecting a different result than what I wait for.
				PresUtils.ClientSendFriendRequest(UB, UA, ExpectFailure.Yes);

				// Make sure the friend request is now gone, otherwise wierd behaviour occurs (make sure I'm clean baby!)
				PresUtils.ClientRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}
	}
	#endregion

	/// <summary>
	/// Rigorous auth data checks
	/// </summary>
	/// <remarks>
	///	<Component>AuthData</Component>
	/// </remarks>
	public class Func_AuthDataChecks : TestNode
	{
		/// <summary>
		/// SG Auth Data: Zero Request ID
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but a zero request id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AuthDataChecks, sg auth data, zero request id" )]
			class AuthDataChecks_Positive_SGAuthData_ZeroRequestId : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				string auth = PresUtils.GetFakeSGAuthData(A, 0);

				Widgets.Presence(auth).GetFriends(A.UserPuid, 1);
			}
		}

		/// <summary>
		/// SG Auth Data: Non-zero Request ID
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but and a non-zero request id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AuthDataChecks, sg auth data non-zero request id" )]
			class AuthDataChecks_Positive_SGAuthData_NonZeroRequestId : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				string auth = PresUtils.GetFakeSGAuthData(A, 0x123);

				Widgets.Presence(auth).GetFriends(A.UserPuid, 1);
			}
		}

		/// <summary>
		/// Truncated auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but truncated auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AuthDataChecks, truncated auth data" )]
			class AuthDataChecks_Negative_TruncatedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				HTTPAuthData had = Widgets.GetAuthData2(A.UserPuid, 0);

				byte [] b = had.ConstructAuthData();

				string auth = Convert.ToBase64String(b, 0, b.Length >> 1);

				try
				{
					Widgets.Presence(auth).GetFriends(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
				
			}
		}

		/// <summary>
		/// Random auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but random auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AuthDataChecks, random auth data" )]
			class AuthDataChecks_Negative_RandomAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				HTTPAuthData had = Widgets.GetAuthData2(A.UserPuid, 0);

				byte [] b = had.ConstructAuthData();

				RandomEx r = new RandomEx();

				r.NextBytes(b);

				string auth = Convert.ToBase64String(b, 0, b.Length);

				try
				{
					Widgets.Presence(auth).GetFriends(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
				
			}
		}

		/// <summary>
		/// Too long auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but too long auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AuthDataChecks, too long auth data" )]
			class AuthDataChecks_Negative_TooLongAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				HTTPAuthData had = Widgets.GetAuthData2(A.UserPuid, 0);

				byte [] b = had.ConstructAuthData();
				byte [] b2 = new byte[b.Length << 1];
				for(int i = 0; i < b.Length; ++i)
				{
					b2[i] = b[i];
					b2[i + b.Length] = b[i];
				}

				string auth = Convert.ToBase64String(b2, 0, b2.Length);

				try
				{
					Widgets.Presence(auth).GetFriends(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
				
			}
		}

		/// <summary>
		/// Non base64 auth string
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but a non base64 auth string
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AuthDataChecks, non base64 auth data" )]
			class AuthDataChecks_Negative_NonBase64AuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				try
				{
					Widgets.Presence("This shouldn't work cause it isn't a valid base64 string.").GetFriends(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
				
			}
		}

		/// <summary>
		/// Bad auth data version
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but a bad auth data version
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AuthDataChecks, bad auth data version" )]
			class AuthDataChecks_Negative_BadAuthDataVersion : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				HTTPAuthData had = Widgets.GetAuthData2(A.UserPuid, 0);

				had.wAuthDataVersion = 30;

				try
				{
					Widgets.Presence(had.GetBase64EncodedString()).GetFriends(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Bad auth data size
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but a bad auth data size
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AuthDataChecks, bad auth data size" )]
		[Ignore]
			class AuthDataChecks_Negative_BadAuthDataSize : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				HTTPAuthData had = Widgets.GetAuthData2(A.UserPuid, 0);

				had.wAuthDataSize = (ushort) (had.wAuthDataSize - 10);

				try
				{
					Widgets.Presence(had.GetBase64EncodedString()).GetFriends(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

	}

	/// <summary>
	/// Covers some of the basic parameter checking functionality of GetFriends
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_GetFriends : TestNode
	public class Func_Presence_GetFriends : TestNode
	{
		/// <summary>
		/// GetFriends, missing auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but missing auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriends, missing auth data" )]
			class Presence_GetFriends_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(null).GetFriends(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
				
			}
		}

		/// <summary>
		/// GetFriends, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends with valid params but mismatched auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriends, mismatched auth data" )]
			class Presence_GetFriends_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).GetFriends(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
				
			}
		}

		/// <summary>
		/// Verifies that GetFriends with a bad language id returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends for a valid puid with an invalid language id
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriends, bad language id returns an error" )]
			class Presence_GetFriends_Negative_Invalid_LanguageId : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).GetFriends(A.UserPuid, 0x10001);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
				
			}
		}

		/// <summary>
		/// Verifies that GetFriends with a non-existent puid returns an error.
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriends for a non-existent puid and a valid language id
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriends, non-existent puid returns an error" )]
			class Presence_GetFriends_Negative_Nonexistent_UserPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).GetFriends(1, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

	}
	#endregion

	/// <summary>
	/// Covers some of the basic parameter checking functionality of SendFriendsRequest
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_SendFriendRequest : TestNode
	public class Func_Presence_SendFriendRequest : TestNode
	{
		/// <summary>
		/// SendFriendRequest, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendRequest with valid params, no auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendRequest, no auth data" )]
			class Presence_SendFriendRequest_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(null).SendFriendsRequest(A.UserPuid, B.UserPuid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// SendFriendRequest, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendRequest with valid params, mismatched auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendRequest, mismatched auth data" )]
			class Presence_SendFriendRequest_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(B.UserPuid)).SendFriendsRequest(A.UserPuid, B.UserPuid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendRequest with an invalid from puid returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendRequest with an invalid from puid and a valid to puid
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendRequest, invalid from puid returns an error" )]
			[Ignore]
			class Presence_SendFriendRequest_Negative_Nonexistent_FromPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).SendFriendsRequest(1, A.UserPuid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendRequest with an invalid to puid returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendRequest with an invalid to puid and a valid to puid
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendRequest, invalid to puid returns an error" )]
			class Presence_SendFriendRequest_Negative_Nonexistent_ToPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).SendFriendsRequest(A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendRequest for a user already in my list due to a previous sendfriendrequest results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendRequest for a user already in my list results in an error
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendRequest, user already in my list, I've already sent a friend request" )]
			[Ignore]
			class Presence_SendFriendRequest_Negative_UserInList_AlreadySent : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.Yes);
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendFriendRequest for a user already in my list due to a previous sendfriendrequest to me results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendRequest for a user already in my list results in an error
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendRequest, user already in my list, target already sent a friend request" )]
			[Ignore]
			class Presence_SendFriendRequest_Negative_UserInList_AlreadySentFromTarget : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.No);
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.Yes);
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendFriendRequest for a user already in my list fully accepted results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendRequest for a user already in my list results in an error
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendRequest, user already in my list, fully accepted" )]
			class Presence_SendFriendRequest_Negative_UserInList_FullyAccepted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);
				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.Yes);
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendFriendRequest for a user with a full friends list results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendRequest for a user with a full friends list
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendRequest, friends list full" )]
			class Presence_SendFriendRequest_Negative_FriendsListFull : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);
				PresUtils.SetBuddies(UA, 100);
				PresUtils.SetBuddies(UB, 100);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.Yes);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers some of the basic parameter checking functionality of AnswerFriendsRequest
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_AnswerFriendRequest : TestNode
	public class Func_Presence_AnswerFriendRequest : TestNode
	{
		/// <summary>
		/// AnswerFriendRequest, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendRequest with missing auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendRequest, missing auth data" )]
			class Presence_AnswerFriendRequest_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(null).AnswerFriendsRequest(A.UserPuid, B.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// AnswerFriendRequest, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendRequest with mismatched auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendRequest, mismatched auth data" )]
			class Presence_AnswerFriendRequest_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(B.UserPuid)).AnswerFriendsRequest(A.UserPuid, B.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendRequest with an invalid from puid returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendRequest with an invalid from puid and a valid to puid
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendRequest, invalid from puid returns an error" )]
			[Ignore]
			class Presence_AnswerFriendRequest_Negative_Nonexistent_FromPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).AnswerFriendsRequest(1, A.UserPuid, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendRequest with an invalid to puid returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendRequest with an invalid to puid and a valid to puid
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendRequest, invalid to puid returns an error" )]
			class Presence_AnswerFriendRequest_Negative_Nonexistent_ToPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).AnswerFriendsRequest(A.UserPuid, 1, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendRequest with an invalid response code
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendRequest with a valid from and to puid, but an invalid response code
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendRequest, invalid response code an error" )]
			class Presence_AnswerFriendRequest_Negative_Invalid_Response : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(UB.UserId)).AnswerFriendsRequest(UB.UserId, UA.UserId, 0x10001);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendRequest for a user with a sent friends request
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendRequest with a the same from and to as a sends friend request pending
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendRequest, accepting a sent friend request that I sent" )]
			class Presence_AnswerFriendRequest_Negative_Accept_Inverted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UA, UB, 1, ExpectFailure.Yes);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers cases for GetFriendsFromList
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_GetFriendsFromList : TestNode
	public class Func_Presence_GetFriendsFromList : TestNode
	{
		/// <summary>
		/// Verifies that GetFriendsFromList with a bad language id returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a valid puid with an invalid language id
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, bad language id returns an error" )]
			class Presence_GetFriendsFromList_Negative_Invalid_LanguageId : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).GetFriendsFromList(A.UserPuid, new ulong [] {A.UserPuid}, 0x10001);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromList with a full list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a valid puid, valid language id, and a full list
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, full friends list" )]
			class Presence_GetFriendsFromList_Positive_FullFriendsList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PresUtils.SetBuddies(UA, 100);

				ulong [] uls = new ulong [100];
				
				for(int i = 0; i < uls.Length; ++i)
				{
					uls[i] = UserStore.FriendsToBe[i].UserId;
				}

				PresUtils.ComparePresenceCheckersFromList(UA, uls);
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromList with an empty list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a valid puid, valid language id, and an empty list
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, empty list" )]
			class Presence_GetFriendsFromList_Positive_EmptyList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] uls = new ulong [0];
				
				PresUtils.ComparePresenceCheckersFromList(UA, uls);
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromList with a 1 entry list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a valid puid, valid language id, and a 1 entry list
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, 1 entry list" )]
			class Presence_GetFriendsFromList_Positive_1EntryList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PresUtils.SetBuddies(UA, 100);

				RandomEx r = new RandomEx();
				ulong [] uls = new ulong [1] {UserStore.FriendsToBe[r.Next(100)].UserId};
				
				PresUtils.ComparePresenceCheckersFromList(UA, uls);
			}
		}

		/// <summary>
		/// GetFriendsFromList, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a valid puid, valid language id, and a 1 entry list, no auth data
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, no auth data" )]
			class Presence_GetFriendsFromList_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] uls = new ulong [1] {B.UserPuid};
				
				try
				{
					Widgets.Presence(null).GetFriendsFromList(A.UserPuid, uls, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// GetFriendsFromList, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a valid puid, valid language id, and a 1 entry list, mismatched auth data
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, mismatched auth data" )]
			class Presence_GetFriendsFromList_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] uls = new ulong [1] {B.UserPuid};
				
				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).GetFriendsFromList(A.UserPuid, uls, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromList with a list mixed with friend and non-friend puids
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a valid puid, valid language id, and a mixed list of friends and non-friends
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, mixed list of friends & non-friends" )]
			[Ignore]
			class Presence_GetFriendsFromList_Positive_MixedList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PresUtils.SetBuddies(UA, 50);

				ulong [] uls = new ulong [100];
				
				for(int i = 0; i < uls.Length; ++i)
				{
					uls[i] = UserStore.FriendsToBe[i].UserId;
				}

				PresUtils.ComparePresenceCheckersFromList(UA, uls);
			}
		}


		/// <summary>
		/// Verifies that GetFriendsFromList with a null list fails
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a valid puid, valid language id, and a null list
		///		</Description>
		///		<Verify>
		///		An error is return and an event logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, null list" )]
			class Presence_GetFriendsFromList_Negative_NullList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).GetFriendsFromList(A.UserPuid, null, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromList with a non-existent puid returns an error.
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromList for a non-existent puid and a valid language id
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromList, non-existent puid returns an error" )]
			class Presence_GetFriendsFromList_Negative_Nonexistent_UserPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).GetFriendsFromList(1, new ulong [] {A.UserPuid}, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers cases for GetFriendsFromListByGamertag
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_GetFriendsFromListByGamertag : TestNode
	public class Func_Presence_GetFriendsFromListByGamertag : TestNode
	{
		/// <summary>
		/// Verifies that GetFriendsFromListByGamertag with a bad language id returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromListByGamertag for a valid puid with an invalid language id
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromListByGamertag, bad language id returns an error" )]
			class Presence_GetFriendsFromListByGamertag_Negative_Invalid_LanguageId : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).GetFriendsFromListByGamertag(A.UserPuid, new string [] {A.User.gamertag}, 0x10001);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromListByGamertag with a full list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromListByGamertag for a valid puid, valid language id, and a full list
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromListByGamertag, full friends list" )]
			class Presence_GetFriendsFromListByGamertag_Positive_FullFriendsList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PresUtils.SetBuddies(UA, 100);

				string [] uls = new string [100];
				RandomEx r = new RandomEx();

				for(int i = 0; i < uls.Length; ++i)
				{
					switch(r.Next(3))
					{
						case 0:
							uls[i] = UserStore.FriendsToBe[i].Name;
							break;
						case 1:
							uls[i] = UserStore.FriendsToBe[i].Name.ToLower();
							break;
						case 2:
							uls[i] = UserStore.FriendsToBe[i].Name.ToUpper();
							break;
					};
				}

				PresUtils.ComparePresenceCheckersFromListByGamertag(UA, uls);
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromListByGamertag with an empty list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromListByGamertag for a valid puid, valid language id, and an empty list
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromListByGamertag, empty list" )]
			class Presence_GetFriendsFromListByGamertag_Positive_EmptyList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				string [] uls = new string [0];
				
				PresUtils.ComparePresenceCheckersFromListByGamertag(UA, uls);
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromListByGamertag with a 1 entry list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromListByGamertag for a valid puid, valid language id, and a 1 entry list
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromListByGamertag, 1 entry list" )]
			class Presence_GetFriendsFromListByGamertag_Positive_1EntryList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PresUtils.SetBuddies(UA, 100);

				RandomEx r = new RandomEx();
				string [] uls = new string [1] {UserStore.FriendsToBe[r.Next(100)].Name};
				
				PresUtils.ComparePresenceCheckersFromListByGamertag(UA, uls);
			}
		}

		/// <summary>
		/// GetFriendsFromListByGamertag, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromListByGamertag for a valid puid, valid language id, and a 1 entry list, no auth data
		///		</Description>
		///		<Verify>
		///		Failure
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromListByGamertag, no auth data" )]
			class Presence_GetFriendsFromListByGamertag_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				RandomEx r = new RandomEx();
				string [] uls = new string [1] {UserStore.FriendsToBe[r.Next(100)].Name};
				
				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).GetFriendsFromListByGamertag(A.UserPuid, uls, 1);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromListByGamertag with a list mixed with friend and non-friend puids &amp; covers null
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromListByGamertag for a valid puid, valid language id, and a mixed list of friends and non-friends &amp; 1 null
		///		</Description>
		///		<Verify>
		///		Success
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromListByGamertag, mixed list of friends & non-friends" )]
			[Ignore]
			class Presence_GetFriendsFromListByGamertag_Positive_MixedList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PresUtils.SetBuddies(UA, 50);

				string [] uls = new string [101];
				RandomEx r = new RandomEx();
				
				for(int i = 0; i < uls.Length - 1; ++i)
				{
					switch(r.Next(3))
					{
						case 0:
							uls[i] = UserStore.FriendsToBe[i].Name;
							break;
						case 1:
							uls[i] = UserStore.FriendsToBe[i].Name.ToLower();
							break;
						case 2:
							uls[i] = UserStore.FriendsToBe[i].Name.ToUpper();
							break;
					};
				}
				uls[100] = null;

				PresUtils.ComparePresenceCheckersFromListByGamertag(UA, uls);
			}
		}


		/// <summary>
		/// Verifies that GetFriendsFromListByGamertag with a null list fails
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromListByGamertag for a valid puid, valid language id, and a null list
		///		</Description>
		///		<Verify>
		///		An error is return and an event logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromListByGamertag, null list" )]
			class Presence_GetFriendsFromListByGamertag_Negative_NullList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).GetFriendsFromListByGamertag(A.UserPuid, null, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that GetFriendsFromListByGamertag with a non-existent puid returns an error.
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls GetFriendsFromListByGamertag for a non-existent puid and a valid language id
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "GetFriendsFromListByGamertag, non-existent puid returns an error" )]
			class Presence_GetFriendsFromListByGamertag_Negative_Nonexistent_UserPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).GetFriendsFromListByGamertag(1, new string [] {A.User.gamertag}, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers cases for SendFriendsRequestByGamertag
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_SendFriendsRequestByGamertag : TestNode
	public class Func_Presence_SendFriendsRequestByGamertag : TestNode
	{
		/// <summary>
		/// SendFriendsRequestByGamertag, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag with a missing auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, no auth data" )]
			class Presence_SendFriendsRequestByGamertag_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(null).SendFriendsRequestByGamertag(A.User.gamertag, B.User.gamertag);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// SendFriendsRequestByGamertag, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag with mismatched auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, mismatched auth data" )]
			class Presence_SendFriendsRequestByGamertag_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(B.UserPuid)).SendFriendsRequestByGamertag(A.User.gamertag, B.User.gamertag);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag with a null from gamertag returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag with a null from gamertag and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, null from gamertag returns an error" )]
			class Presence_SendFriendsRequestByGamertag_Negative_Null_FromGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).SendFriendsRequestByGamertag(null, A.User.gamertag);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag with an invalid from gamertag returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag with an invalid from gamertag and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, invalid from gamertag returns an error" )]
			[Ignore]
			class Presence_SendFriendsRequestByGamertag_Negative_Nonexistent_FromGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).SendFriendsRequestByGamertag("123_1", A.User.gamertag);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag with a from gamertag that is too long returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag with a from gamertag that is too long and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, too long from gamertag returns an error" )]
			[Ignore]
			class Presence_SendFriendsRequestByGamertag_Negative_TooLong_FromGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).SendFriendsRequestByGamertag("ABCDEFGHIJKLMNOP", A.User.gamertag);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag with a null to gamertag returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag with a null to gamertag and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, null to gamertag returns an error" )]
			class Presence_SendFriendsRequestByGamertag_Negative_Null_ToGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).SendFriendsRequestByGamertag(A.User.gamertag, null);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag with an invalid to gamertag returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag with an invalid to gamertag and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, invalid to gamertag returns an error" )]
			[Ignore]
			class Presence_SendFriendsRequestByGamertag_Negative_Nonexistent_ToGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).SendFriendsRequestByGamertag(A.User.gamertag, "123_1");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag with a to gamertag that is too long returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag with to gamertag that is too long and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, too long to gamertag returns an error" )]
			[Ignore]
			class Presence_SendFriendsRequestByGamertag_Negative_TooLong_ToGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).SendFriendsRequestByGamertag(A.User.gamertag, "ABCDEFGHIJKLMNOP");
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag for a user already in my list due to a previous SendFriendsRequestByGamertag results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag for a user already in my list results in an error
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, user already in my list, I've already sent a friend request" )]
			[Ignore]
			class Presence_SendFriendsRequestByGamertag_Negative_UserInList_AlreadySent : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendsRequestByGamertag(UA, UB, ExpectFailure.No);
				PresUtils.CheckersSendFriendsRequestByGamertag(UA, UB, ExpectFailure.Yes);
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag for a user already in my list due to a previous SendFriendsRequestByGamertag to me results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag for a user already in my list results in an error
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, user already in my list, target already sent a friend request" )]
			class Presence_SendFriendsRequestByGamertag_Negative_UserInList_AlreadySentFromTarget : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendsRequestByGamertag(UB, UA, ExpectFailure.No);
				PresUtils.CheckersSendFriendsRequestByGamertag(UA, UB, ExpectFailure.Yes);
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag for a user already in my list fully accepted results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag for a user already in my list results in an error
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, user already in my list, fully accepted" )]
			class Presence_SendFriendsRequestByGamertag_Negative_UserInList_FullyAccepted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendsRequestByGamertag(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);
				PresUtils.CheckersSendFriendsRequestByGamertag(UA, UB, ExpectFailure.Yes);
				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendFriendsRequestByGamertag for a user with a full friends list results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendFriendsRequestByGamertag for a user with a full friends list
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendFriendsRequestByGamertag, friends list full" )]
			class Presence_SendFriendsRequestByGamertag_Negative_FriendsListFull : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);
				PresUtils.SetBuddies(UA, 100);
				PresUtils.SetBuddies(UB, 100);

				PresUtils.CheckersSendFriendsRequestByGamertag(UA, UB, ExpectFailure.Yes);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers AnswerFriendsRequestByGamertag
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_AnswerFriendsRequestByGamertag : TestNode
	public class Func_Presence_AnswerFriendsRequestByGamertag : TestNode
	{
		/// <summary>
		/// AnswerFriendsRequestByGamertag, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with no auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, no auth data" )]
			class Presence_AnswerFriendsRequestByGamertag_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(null).AnswerFriendsRequestByGamertag(A.User.gamertag, B.User.gamertag, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// AnswerFriendsRequestByGamertag, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with mismatched auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, mismatched auth data" )]
			class Presence_AnswerFriendsRequestByGamertag_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(B.UserPuid)).AnswerFriendsRequestByGamertag(A.User.gamertag, B.User.gamertag, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}
		/// <summary>
		/// Verifies that AnswerFriendsRequestByGamertag with a null from gamertag returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with a null from gamertag and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, null from gamertag returns an error" )]
			class Presence_AnswerFriendsRequestByGamertag_Negative_Null_FromGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).AnswerFriendsRequestByGamertag(null, A.User.gamertag, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendsRequestByGamertag with an invalid from gamertag returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with an invalid from gamertag and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, invalid from gamertag returns an error" )]
			[Ignore]
			class Presence_AnswerFriendsRequestByGamertag_Negative_Nonexistent_FromGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).AnswerFriendsRequestByGamertag("a1_1123", A.User.gamertag, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendsRequestByGamertag with a from gamertag that is too long returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with a from gamertag that is too long and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, too long from gamertag returns an error" )]
			[Ignore]
			class Presence_AnswerFriendsRequestByGamertag_Negative_TooLong_FromGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).AnswerFriendsRequestByGamertag("ABCDEFGHIJKLMNOP", A.User.gamertag, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendsRequestByGamertag with a null to gamertag returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with a null to gamertag and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, null to gamertag returns an error" )]
			class Presence_AnswerFriendsRequestByGamertag_Negative_Null_ToGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).AnswerFriendsRequestByGamertag(A.User.gamertag, null, 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendsRequestByGamertag with an invalid to gamertag returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with an invalid to gamertag and a valid to gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, invalid to gamertag returns an error" )]
			class Presence_AnswerFriendsRequestByGamertag_Negative_Nonexistent_ToGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).AnswerFriendsRequestByGamertag(A.User.gamertag, "a1_123", 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendsRequestByGamertag with a to gamertag that is too long returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with a to gamertag that is too long and a valid from gamertag
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, too long to gamertag returns an error" )]
			class Presence_AnswerFriendsRequestByGamertag_Negative_TooLong_ToGamertag : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).AnswerFriendsRequestByGamertag(A.User.gamertag, "ABCDEFGHIJKLMNOP", 1);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendsRequestByGamertag with an invalid response code
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with a valid from and to gamertag, but an invalid response code
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, invalid response code an error" )]
			class Presence_AnswerFriendsRequestByGamertag_Negative_Invalid_Response : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendsRequestByGamertag(UA, UB, ExpectFailure.No);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(B.UserPuid)).AnswerFriendsRequestByGamertag(B.User.gamertag, A.User.gamertag, 0x10001);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that AnswerFriendsRequestByGamertag for a user with a sent friends request
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AnswerFriendsRequestByGamertag with a the same from and to as a sends friend request pending
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AnswerFriendsRequestByGamertag, accepting a sent friend request that I sent" )]
			class Presence_AnswerFriendsRequestByGamertag_Negative_Accept_Inverted : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendsRequestByGamertag(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendsRequestByGamertag(UA, UB, 1, ExpectFailure.Yes);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers RemoveFriend
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_RemoveFriend : TestNode
	public class Func_Presence_RemoveFriend : TestNode
	{
		/// <summary>
		/// RemoveFriend, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveFriend with no auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveFriend, no auth data" )]
			class Presence_RemoveFriend_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(null).RemoveFriend(A.UserPuid, B.UserPuid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// RemoveFriend, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveFriend with mismatched auth data
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveFriend, mismatched auth data" )]
			class Presence_RemoveFriend_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(B.UserPuid)).RemoveFriend(A.UserPuid, B.UserPuid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Verifies that RemoveFriend with an invalid from puid returns an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveFriend with an invalid from puid and a valid to puid
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveFriend, invalid from puid returns an error" )]
			[Ignore]
			class Presence_RemoveFriend_Negative_Nonexistent_FromPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).RemoveFriend(1, A.UserPuid);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}


		/// <summary>
		/// Verifies that RemoveFriend with a puid for a user not in my friends list results in an error
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveFriend with a valid from puid and an invalid to puid
		///		</Description>
		///		<Verify>
		///		An error is returned and an event is logged.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveFriend, puid not in friends list triggers an error" )]
			[Ignore]
			class Presence_RemoveFriend_Negative_ToPuid_NotInFriendsList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.Yes);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers SendGameInvite
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_SendGameInvite : TestNode
	public class Func_Presence_SendGameInvite : TestNode
	{
		/// <summary>
		/// SendGameInvite, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with no auth data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, no auth data" )]
			class Presence_SendGameInvite_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				ulong [] tos = new ulong [] {UB.UserId};

				try
				{
					Widgets.Presence(null).SendGameInvite(UA.Xbox.TitleId, UA.UserId, UA.MatchSessionId, tos);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}

				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// SendGameInvite, mismatched auth data (userid)
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with mismatched auth data (userid)
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, mismatched auth data (userid)" )]
			class Presence_SendGameInvite_Negative_MismatchedAuthDataUserID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				ulong [] tos = new ulong [] {UB.UserId};

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1, UA.Xbox.TitleId)).SendGameInvite(UA.Xbox.TitleId, UA.UserId, UA.MatchSessionId, tos);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}

				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// SendGameInvite, mismatched auth data (titleid)
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with mismatched auth data (userid)
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, mismatched auth data (titleid)" )]
			class Presence_SendGameInvite_Negative_MismatchedAuthDataTitleID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				ulong [] tos = new ulong [] {UB.UserId};

				try
				{
					Widgets.Presence(Widgets.GetAuthData(UA.UserId, UA.Xbox.TitleId + 1)).SendGameInvite(UA.Xbox.TitleId, UA.UserId, UA.MatchSessionId, tos);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}

				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendGameInvite from Checkers works from Adult to Minor and is visible in Checkers
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a valid adult from puid and avalid minor to puid
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, adult to minor" )]
			class Presence_SendGameInvite_Positive_Checkers_Adult_To_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				PNUser [] tos = new PNUser [] {UB};

				PresUtils.CheckersSendGameInvite(UA, tos, ExpectFailure.No);
				PresUtils.CheckersCancelGameInvite(UA, tos, ExpectFailure.No);

				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendGameInvite from Checkers removes a nevered user from the never list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a valid adult from puid and avalid minor to puid to a user that has been nevered
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, adult to minor, nevered" )]
//			[Ignore /* Doesn't fucking work */]
			class Presence_SendGameInvite_Negative_Checkers_Adult_To_Minor_Nevered : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UA, UB, 2, ExpectFailure.No);

				PNUser [] tos = new PNUser [] {UB};
/*
				DateTime nw = DateTime.Now;
				bool fFound = false;
				while(DateTime.Now.Subtract(nw).TotalMilliseconds < 20000)
				{
					UA.GetListChangeNotifications();
					foreach(ulong puid in UA.Blocks)
					{
						if(puid == UB.UserId)
						{
							fFound = true;
							break;
						}
					}
				}
				if(!fFound)
					throw new Exception("Never'ed user not found on sender's block list.");
*/				
				// Call SendGameInvite to ensure they are removed from the never
				PresUtils.CheckersSendGameInvite(UA, tos, ExpectFailure.No);
/*
				nw = DateTime.Now;
				fFound = true;
				while(fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 20000)
				{
					fFound = false;
					UA.GetListChangeNotifications();
					foreach(ulong puid in UA.Blocks)
					{
						if(puid == UB.UserId)
						{
							fFound = true;
							break;
						}
					}
				}

				if(fFound)
				{
				*/
					PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
					PresUtils.CheckersAnswerFriendRequest(UB, UA, 0, ExpectFailure.No);
				/*
					throw new Exception("The user should have been removed from the never list using SendGameInvite, but we didn't see the user removed.");
				}
				*/
				
			}
		}

		/// <summary>
		/// Verifies that SendGameInvite from Checkers works from Minor to Adult and is visible in Checkers
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a valid minor from puid and a valid adult to puid
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, minor to adult" )]
			class Presence_SendGameInvite_Positive_Checkers_Minor_To_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				PNUser [] tos = new PNUser [] {UB};

				PresUtils.CheckersSendGameInvite(UA, tos, ExpectFailure.No);
				PresUtils.CheckersCancelGameInvite(UA, tos, ExpectFailure.No);

				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendGameInvite from Checkers fails appropriately for a valid puid not on my friends list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a valid minor from puid and a valid adult to puid
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, adult to minor, but minor not on friends list" )]
			class Presence_SendGameInvite_Negative_Checkers_TargetNotInFriendsList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PNUser [] tos = new PNUser [] {UB};

				PresUtils.CheckersSendGameInvite(UA, tos, ExpectFailure.Yes);
			}
		}

		/// <summary>
		/// Verifies that SendGameInvite from Checkers fails appropriately for a valid puid for a user that is only invited
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameIvnite with a valid minor from puid and a valid adult to puid
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, adult to minor, but minor is only invited, not a full friend" )]
			class Presence_SendGameInvite_Negative_Checkers_TargetIsOnlyInvited : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PNUser [] tos = new PNUser [] {UB};

				PresUtils.CheckersSendGameInvite(UA, tos, ExpectFailure.Yes);

				PresUtils.CheckersRemoveFriend(UA, UB, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Verifies that SendGameInvite from Checkers fails appropriately for a valid puid that has invited me to be a friend
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a valid minor from puid and a valid adult to puid
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, adult to minor, but minor is only invited, not a full friend" )]
			class Presence_SendGameInvite_Negative_Checkers_TargetHasInvitedMe : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UB, UA, ExpectFailure.No);
				PNUser [] tos = new PNUser [] {UB};

				PresUtils.CheckersSendGameInvite(UA, tos, ExpectFailure.Yes);

				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Target nonexistent puid
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a valid minor from puid and a valid adult to puid
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, target doesn't exist (nonexistent puid)" )]
			[Ignore]
			class Presence_SendGameInvite_Negative_Checkers_TargetNonexistentPuid : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				PNUser [] tos = new PNUser [] {new PNUser("Blah", 1)};

				PresUtils.CheckersSendGameInvite(UA, tos, ExpectFailure.Yes);
			}
		}

		/// <summary>
		/// Target Self
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a valid minor from puid and a valid adult to puid
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, target is self" )]
			class Presence_SendGameInvite_Negative_Checkers_TargetSelf : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				PNUser [] tos = new PNUser [] {UA};

				PresUtils.CheckersSendGameInvite(UA, tos, ExpectFailure.Yes);
			}
		}

		/// <summary>
		/// Empty List
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with an empty list
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, empty list" )]
			class Presence_SendGameInvite_Negative_Checkers_EmptyList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] tos = new ulong [0];
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				Widgets.Presence(Widgets.GetAuthData(UA)).SendGameInvite(sessInfo.TitleId, UA.UserId, sessInfo.XnKId.ab, tos);
			}
		}

		/// <summary>
		/// Null List
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with an empty list
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, null list" )]
			class Presence_SendGameInvite_Negative_Checkers_NullList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] tos = null;
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(UA)).SendGameInvite(sessInfo.TitleId, UA.UserId, sessInfo.XnKId.ab, tos);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Nonexistent Title ID
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a nonexistent title id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, nonexistent title id" )]
			[Ignore]
			class Presence_SendGameInvite_Negative_Checkers_NonexistentTitleID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);
				ulong [] tos = new ulong [] {UB.UserId};
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				bool fInviteWentThrough = false;
				try
				{
					Widgets.Presence(Widgets.GetAuthData(UA.UserId, 1)).SendGameInvite(1, UA.UserId, sessInfo.XnKId.ab, tos);
					UB.WaitForInviteBlip();
					UB.GetInviteNotifications();
					PNUser.BuddyInfo bi = UB.GetBuddyInfo(UA.UserId);
					if(bi.Invitation != null && bi.Invitation.TitleID == 1)
						fInviteWentThrough = true;
					else
						ResultCode = TEST_RESULTS.PASSED;
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
				if(fInviteWentThrough)
					throw new Exception("SendGameInvite for an invalid title id was successfully sent and the target user received the invite with the invalid title id!");
			}
		}

		/// <summary>
		/// Nonexistent User ID
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with a nonexistent user id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, nonexistent user id" )]
			[Ignore]
			class Presence_SendGameInvite_Negative_Checkers_NonexistentUserID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] tos = new ulong [] {UA.UserId};
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1, sessInfo.TitleId)).SendGameInvite(sessInfo.TitleId, 1, sessInfo.XnKId.ab, tos);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// 100 Users
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SendGameInvite with 100 Users
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SendGameInvite, 100 Users" )]
			class Presence_SendGameInvite_Positive_Checkers_100Users : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				PresUtils.SetBuddies(UA, 100);

				PresUtils.CheckersSendGameInvite(UA, UserStore.FriendsToBe, ExpectFailure.No);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers RevokeGameInvite
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_RevokeGameInvite : TestNode
	public class Func_Presence_RevokeGameInvite : TestNode
	{
		/// <summary>
		/// RevokeGameInvite, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RevokeGameInvite with no auth data
		///		</Description>
		///		<Verify>
		///		Failure
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RevokeGameInvite, no auth data" )]
			class Presence_RevokeGameInvite_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] tos = new ulong [] {B.UserPuid};
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				try
				{
					Widgets.Presence(null).RevokeGameInvite(UA.UserId, sessInfo.XnKId.ab, tos);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// RevokeGameInvite, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RevokeGameInvite with no auth data
		///		</Description>
		///		<Verify>
		///		Failure
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RevokeGameInvite, mismatched auth data" )]
			class Presence_RevokeGameInvite_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] tos = new ulong [] {B.UserPuid};
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(B.UserPuid)).RevokeGameInvite(UA.UserId, sessInfo.XnKId.ab, tos);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Nonexistent User ID
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RevokeGameInvite with a nonexistent user id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RevokeGameInvite, nonexistent user id" )]
			[Ignore]
			class Presence_RevokeGameInvite_Negative_Checkers_NonexistentUserID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] tos = new ulong [] {UA.UserId};
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).RevokeGameInvite(1, sessInfo.XnKId.ab, tos);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Empty list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RevokeGameInvite with an empty list
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RevokeGameInvite, empty list" )]
			class Presence_RevokeGameInvite_Negative_Checkers_EmptyList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] tos = new ulong [0];
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				Widgets.Presence(Widgets.GetAuthData(UA.UserId)).RevokeGameInvite(UA.UserId, sessInfo.XnKId.ab, tos);
			}
		}

		/// <summary>
		/// Null list
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RevokeGameInvite with a null list
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RevokeGameInvite, empty list" )]
			class Presence_RevokeGameInvite_Negative_Checkers_NullList : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				ulong [] tos = null;
				XSessionInfo sessInfo;
				UA.GetPeerSession(UA, out sessInfo);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(UA.UserId)).RevokeGameInvite(UA.UserId, sessInfo.XnKId.ab, tos);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Nonexistent Target ID
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RevokeGameInvite with a nonexistent user id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RevokeGameInvite, nonexistent target user id" )]
			class Presence_RevokeGameInvite_Negative_Checkers_NonexistentTargetUserID : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);

				PNUser [] tos = new PNUser [] {new PNUser("Blah", 1)};

				PresUtils.CheckersCancelGameInvite(UA, tos, ExpectFailure.Yes);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers SetNotificationState
	/// </summary>
	/// <remarks>
	/// <Component>Presence</Component>
	/// </remarks>
	#region public class Func_Presence_SetNotificationState : TestNode
	public class Func_Presence_SetNotificationState : TestNode
	{
		static byte [] sampleState = new byte [] {    0,  1,  2,  3,  4,  5,  6,  7,  
													  8,  9, 10, 11, 12, 13, 14, 15,
													 16, 17, 18, 19, 20, 21, 22, 23,
													 24, 25, 26, 27, 28, 29, 30, 31};
		static byte [] sampleStateSmall = new byte [] {   0,  1,  2,  3,  4,  5,  6,  7,  
														  8,  9, 10, 11, 12, 13, 14, 15};
		/// <summary>
		/// SetNotificationState, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with no auth data
		///		</Description>
		///		<Verify>
		///		Failure
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, no auth data" )]
			class Presence_SetNotificationState_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(null).SetNotificationState(A.UserPuid, 1, 0xDEADBEEFBEADFEED, sampleState);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// SetNotificationState, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with no auth data
		///		</Description>
		///		<Verify>
		///		Failure
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, mismatched auth data" )]
			class Presence_SetNotificationState_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).SetNotificationState(A.UserPuid, 1, 0xDEADBEEFBEADFEED, sampleState);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Adult
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with a nonexistent user id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, Adult" )]
			class Presence_SetNotificationState_Positive_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				PresUtils.CheckersSetNotificationState(UA, UB, 0x1b, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.No);
				
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Minor
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with a nonexistent user id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, Minor" )]
			class Presence_SetNotificationState_Positive_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				PresUtils.CheckersSetNotificationState(UA, UB, 0x1b, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.No);
				
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Nonexistent user
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with a nonexistent user id
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, nonexistent user" )]
			[Ignore]
			class Presence_SetNotificationState_Negative_NonexistentUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				PNUser UA = new PNUser("Blah", 1);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).SetNotificationState(1, 0x1b, 0xdeadbeefbeadfeed, sampleState);
				}
				catch
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// Invalid state
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with a invalid state
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, invalid state" )]
			class Presence_SetNotificationState_Negative_InvalidState : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				// Checks all invalid states individually to make sure that I don't miss any
				PresUtils.CheckersSetNotificationState(UA, UB, 0x0004, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x0020, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x0040, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x0080, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x0100, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x0200, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x0400, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x0800, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x1000, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x2000, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x4000, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				PresUtils.CheckersSetNotificationState(UA, UB, 0x8000, 0xDEADBEEFBEADFEED, sampleState, ExpectFailure.Yes);
				
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Null state data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with null for the state data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, null state data" )]
			class Presence_SetNotificationState_Negative_NullState : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				PresUtils.CheckersSetNotificationState(UA, UB, 0x1b, 0xDEADBEEFBEADFEED, null, ExpectFailure.Yes);
				
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Empty state data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with an empty array for the state data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, empty state data" )]
			class Presence_SetNotificationState_Negative_EmptyState : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				PresUtils.CheckersSetNotificationState(UA, UB, 0x1b, 0xDEADBEEFBEADFEED, new byte [0], ExpectFailure.Yes);
				
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// 16 bytes of state
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with 16 bytes of state data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, 16 bytes of state data" )]
			class Presence_SetNotificationState_Negative_16BytesState : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				PresUtils.CheckersSetNotificationState(UA, UB, 0x1b, 0xDEADBEEFBEADFEED, sampleStateSmall, ExpectFailure.Yes);
				
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}

		/// <summary>
		/// Too much state data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls SetNotificationState with too much state for the state data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "SetNotificationState, too much state data" )]
			class Presence_SetNotificationState_Negative_TooMuchState : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				PresUtils.CheckersSendFriendRequest(UA, UB, ExpectFailure.No);
				PresUtils.CheckersAnswerFriendRequest(UB, UA, 1, ExpectFailure.No);

				PresUtils.CheckersSetNotificationState(UA, UB, 0x1b, 0xDEADBEEFBEADFEED, new byte [33], ExpectFailure.Yes);
				
				PresUtils.CheckersRemoveFriend(UB, UA, ExpectFailure.No);
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers AddUserToMutelist (not implemented yet)
	/// </summary>
	/// <remarks>
	/// </remarks>
	#region public class Func_Presence_AddUserToMutelist : TestNode
	public class Func_Presence_AddUserToMutelist : TestNode
	{
		// adult to minor 0 - 1
		// minor to adult 0 - 1
		// nonexistent puid from
		// nonexistent puid to

		/// <summary>
		/// AddUserToMutelist, adult to minor
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AddUserToMutelist from an adult to a minor
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AddUserToMutelist positive, adult to minor" )]
			class Presence_AddUserToMutelist_Positive_Adult_To_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				DateTime nw = DateTime.Now;

				IEnumerator e = null;
				bool fFound = true;
				// Give it 15 seconds to run
				while(fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 15000)
				{
					fFound = false;
					e = UA.BlocksEnumerator;
					while(e.MoveNext())
					{
						ulong p = (ulong)e.Current;
						if(B.UserPuid == p)
						{
							UA.UnMute(UB);
							System.Threading.Thread.Sleep(100);		// Give it time to run on the backend
							fFound = true;
							break;
						}
					}
					// Get an updated block list
					UA.Alive();
				}

				if(fFound)
					throw new Exception("Failed to remove user 0x" + B.UserPuid.ToString("X16") + " from user 0x" + A.UserPuid.ToString("X16") + " mute list.");

				fFound = false;
				nw = DateTime.Now;
				// Give it 15 seconds to run
				while(!fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 15000)
				{
					Widgets.Presence(Widgets.GetAuthData(UA)).AddUserToMutelist(UA.UserId, UB.UserId);
					System.Threading.Thread.Sleep(100);			// Give it time to run on the backend
					UA.Alive();

					e = UA.BlocksEnumerator;
					while(e.MoveNext())
					{
						ulong p = (ulong)e.Current;
						if(B.UserPuid == p)
						{
							fFound = true;
							break;
						}
					}
				}

				if(!fFound)
					throw new Exception("Failed to add user 0x" + B.UserPuid.ToString("X16") + " from user 0x" + A.UserPuid.ToString("X16") + " mute list.");
			}
		}

		/// <summary>
		/// AddUserToMutelist, minor to adult
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AddUserToMutelist from an minor to a adult
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AddUserToMutelist positive, minor to adult" )]
			class Presence_AddUserToMutelist_Positive_Minor_To_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				DateTime nw = DateTime.Now;

				bool fFound = true;
				// Give it 15 seconds to run
				while(fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 15000)
				{
					fFound = false;
					IEnumerator e = UA.BlocksEnumerator;
					while(e.MoveNext())
					{
						ulong p = (ulong)e.Current;
						if(B.UserPuid == p)
						{
							UA.UnMute(UB);
							System.Threading.Thread.Sleep(100);		// Give it time to run on the backend
							fFound = true;
							break;
						}
					}
					// Get an updated block list
					UA.Alive();
				}

				if(fFound)
					throw new Exception("Failed to remove user 0x" + B.UserPuid.ToString("X16") + " from user 0x" + A.UserPuid.ToString("X16") + " mute list.");

				fFound = false;
				nw = DateTime.Now;
				// Give it 15 seconds to run
				while(!fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 15000)
				{
					Widgets.Presence(Widgets.GetAuthData(UA)).AddUserToMutelist(UA.UserId, UB.UserId);
					System.Threading.Thread.Sleep(100);			// Give it time to run on the backend
					UA.Alive();

					IEnumerator e = UA.BlocksEnumerator;
					while(e.MoveNext())
					{
						ulong p = (ulong)e.Current;
						if(B.UserPuid == p)
						{
							fFound = true;
							break;
						}
					}
				}

				if(!fFound)
					throw new Exception("Failed to add user 0x" + B.UserPuid.ToString("X16") + " from user 0x" + A.UserPuid.ToString("X16") + " mute list.");
			}
		}

		/// <summary>
		/// AddUserToMutelist, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AddUserToMutelist from an adult to a minor, no auth data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AddUserToMutelist negative, no auth data" )]
			class Presence_AddUserToMutelist_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(null).AddUserToMutelist(A.UserPuid, B.UserPuid);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// AddUserToMutelist, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AddUserToMutelist from an adult to a minor, mismatched auth data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AddUserToMutelist negative, mismatched auth data" )]
			class Presence_AddUserToMutelist_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).AddUserToMutelist(A.UserPuid, B.UserPuid);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// AddUserToMutelist, nonexistent from user
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AddUserToMutelist from an adult to a minor, nonexistent from user
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AddUserToMutelist negative, nonexistent from user" )]
			class Presence_AddUserToMutelist_Negative_NonexistentFromUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).AddUserToMutelist(1, B.UserPuid);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// AddUserToMutelist, nonexistent to user
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls AddUserToMutelist from an adult to a minor, nonexistent to user
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "AddUserToMutelist negative, nonexistent to user" )]
			class Presence_AddUserToMutelist_Negative_NonexistentToUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).AddUserToMutelist(A.UserPuid, 1);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
	}
	#endregion

	/// <summary>
	/// Covers RemoveUserFromMutelist (not implemented yet)
	/// </summary>
	/// <remarks>
	/// </remarks>
	public class Func_Presence_RemoveUserFromMutelist : TestNode
	{
		// adult to minor 0 - 1
		// minor to adult 0 - 1
		// nonexistent puid from
		// nonexistent puid to
		// auth data

		/// <summary>
		/// RemoveUserFromMutelist, adult to minor
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveUserFromMutelist from an adult to a minor
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveUserFromMutelist positive, adult to minor" )]
			class Presence_RemoveUserFromMutelist_Positive_Adult_To_Minor : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				DateTime nw = DateTime.Now;

				bool fFound = false;
				// Give it 15 seconds to run
				while(!fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 15000)
				{
					UA.Mute(UB);
					System.Threading.Thread.Sleep(100);		// Give it time to run on the backend
					UA.Alive();

					IEnumerator e = UA.BlocksEnumerator;
					while(e.MoveNext())
					{
						ulong p = (ulong)e.Current;
						if(B.UserPuid == p)
						{
							UA.UnMute(UB);
							fFound = true;
							break;
						}
					}
				}

				if(!fFound)
					throw new Exception("Failed to add user 0x" + B.UserPuid.ToString("X16") + " from user 0x" + A.UserPuid.ToString("X16") + " mute list.");

				fFound = true;
				nw = DateTime.Now;
				// Give it 15 seconds to run
				while(fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 15000)
				{
					fFound = false;
					Widgets.Presence(Widgets.GetAuthData(UA)).RemoveUserFromMutelist(UA.UserId, UB.UserId);
					System.Threading.Thread.Sleep(100);			// Give it time to run on the backend
					UA.Alive();

					IEnumerator e = UA.BlocksEnumerator;
					while(e.MoveNext())
					{
						ulong p = (ulong)e.Current;
						if(B.UserPuid == p)
						{
							fFound = true;
							break;
						}
					}
				}

				if(fFound)
					throw new Exception("Failed to remove user 0x" + B.UserPuid.ToString("X16") + " from user 0x" + A.UserPuid.ToString("X16") + " mute list.");
			}
		}

		/// <summary>
		/// RemoveUserFromMutelist, minor to adult
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveUserFromMutelist from an minor to a adult
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveUserFromMutelist positive, minor to adult" )]
			class Presence_RemoveUserFromMutelist_Positive_Minor_To_Adult : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];

				PNUser UA = PresUtils.LogonUser(A, true, true);
				PNUser UB = PresUtils.LogonUser(B, true, true);

				DateTime nw = DateTime.Now;

				bool fFound = false;
				// Give it 15 seconds to run
				while(!fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 15000)
				{
					UA.Mute(UB);
					System.Threading.Thread.Sleep(100);		// Give it time to run on the backend
					UA.Alive();

					IEnumerator e = UA.BlocksEnumerator;
					while(e.MoveNext())
					{
						ulong p = (ulong)e.Current;
						if(B.UserPuid == p)
						{
							UA.UnMute(UB);
							fFound = true;
							break;
						}
					}
				}

				if(!fFound)
					throw new Exception("Failed to add user 0x" + B.UserPuid.ToString("X16") + " from user 0x" + A.UserPuid.ToString("X16") + " mute list.");

				fFound = true;
				nw = DateTime.Now;
				// Give it 15 seconds to run
				while(fFound && DateTime.Now.Subtract(nw).TotalMilliseconds < 15000)
				{
					fFound = false;
					Widgets.Presence(Widgets.GetAuthData(UA)).RemoveUserFromMutelist(UA.UserId, UB.UserId);
					System.Threading.Thread.Sleep(100);			// Give it time to run on the backend
					UA.Alive();

					IEnumerator e = UA.BlocksEnumerator;
					while(e.MoveNext())
					{
						ulong p = (ulong)e.Current;
						if(B.UserPuid == p)
						{
							fFound = true;
							break;
						}
					}
				}

				if(fFound)
					throw new Exception("Failed to remove user 0x" + B.UserPuid.ToString("X16") + " from user 0x" + A.UserPuid.ToString("X16") + " mute list.");
			}
		}

		/// <summary>
		/// RemoveUserFromMutelist, no auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveUserFromMutelist from an adult to a minor, no auth data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveUserFromMutelist negative, no auth data" )]
			class Presence_RemoveUserFromMutelist_Negative_NoAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(null).RemoveUserFromMutelist(A.UserPuid, B.UserPuid);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// RemoveUserFromMutelist, mismatched auth data
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveUserFromMutelist from an adult to a minor, mismatched auth data
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveUserFromMutelist negative, mismatched auth data" )]
			class Presence_RemoveUserFromMutelist_Negative_MismatchedAuthData : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.AdultMaxFields];
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).RemoveUserFromMutelist(A.UserPuid, B.UserPuid);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// RemoveUserFromMutelist, nonexistent from user
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveUserFromMutelist from an adult to a minor, nonexistent from user
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveUserFromMutelist negative, nonexistent from user" )]
			class Presence_RemoveUserFromMutelist_Negative_NonexistentFromUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo B = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(1)).RemoveUserFromMutelist(1, B.UserPuid);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}

		/// <summary>
		/// RemoveUserFromMutelist, nonexistent to user
		/// </summary>
		/// <remarks>
		///		<Description>
		///		Calls RemoveUserFromMutelist from an adult to a minor, nonexistent to user
		///		</Description>
		///		<Verify>
		///		Success.
		///		</Verify>
		/// </remarks>
		[TestCase, Description( "RemoveUserFromMutelist negative, nonexistent to user" )]
			class Presence_RemoveUserFromMutelist_Negative_NonexistentToUser : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.FAILED;

				// Get the users
				UserInfo A = UserStore.SpecialUsers[(int) UserStore.Specials.MinorMaxFields];

				try
				{
					Widgets.Presence(Widgets.GetAuthData(A.UserPuid)).RemoveUserFromMutelist(A.UserPuid, 1);
				}
				catch
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelquickcheck\Presence.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Presence {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="PresenceSoap", Namespace="http://svctunnel.xboxlive.com/Presence/")]
    public class Presence : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Presence() {
            this.Url = "http://10.10.2.36:4541/svctunnel/presence.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriends", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriends(System.UInt64 userId, System.UInt32 language) {
            object[] results = this.Invoke("GetFriends", new object[] {
                        userId,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriends(System.UInt64 userId, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriends", new object[] {
                        userId,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriends(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriendsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriendsFromList(System.UInt64 userId, System.UInt64[] friendUserIds, System.UInt32 language) {
            object[] results = this.Invoke("GetFriendsFromList", new object[] {
                        userId,
                        friendUserIds,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriendsFromList(System.UInt64 userId, System.UInt64[] friendUserIds, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriendsFromList", new object[] {
                        userId,
                        friendUserIds,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriendsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriendsFromListByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriendsFromListByGamertag(System.UInt64 userId, string[] friendGamertags, System.UInt32 language) {
            object[] results = this.Invoke("GetFriendsFromListByGamertag", new object[] {
                        userId,
                        friendGamertags,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriendsFromListByGamertag(System.UInt64 userId, string[] friendGamertags, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriendsFromListByGamertag", new object[] {
                        userId,
                        friendGamertags,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriendsFromListByGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendFriendsRequest", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendFriendsRequest(System.UInt64 userId, System.UInt64 toUserId) {
            this.Invoke("SendFriendsRequest", new object[] {
                        userId,
                        toUserId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendFriendsRequest", new object[] {
                        userId,
                        toUserId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendFriendsRequest(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendFriendsRequestByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendFriendsRequestByGamertag(string user, string toUser) {
            this.Invoke("SendFriendsRequestByGamertag", new object[] {
                        user,
                        toUser});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendFriendsRequestByGamertag(string user, string toUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendFriendsRequestByGamertag", new object[] {
                        user,
                        toUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendFriendsRequestByGamertag(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AnswerFriendsRequest", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AnswerFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.UInt32 answer) {
            this.Invoke("AnswerFriendsRequest", new object[] {
                        userId,
                        toUserId,
                        answer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAnswerFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.UInt32 answer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AnswerFriendsRequest", new object[] {
                        userId,
                        toUserId,
                        answer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAnswerFriendsRequest(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AnswerFriendsRequestByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AnswerFriendsRequestByGamertag(string user, string toUser, System.UInt32 answer) {
            this.Invoke("AnswerFriendsRequestByGamertag", new object[] {
                        user,
                        toUser,
                        answer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAnswerFriendsRequestByGamertag(string user, string toUser, System.UInt32 answer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AnswerFriendsRequestByGamertag", new object[] {
                        user,
                        toUser,
                        answer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAnswerFriendsRequestByGamertag(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RemoveFriend", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveFriend(System.UInt64 userId, System.UInt64 removeUserId) {
            this.Invoke("RemoveFriend", new object[] {
                        userId,
                        removeUserId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveFriend(System.UInt64 userId, System.UInt64 removeUserId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveFriend", new object[] {
                        userId,
                        removeUserId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveFriend(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendGameInvite", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendGameInvite(System.UInt32 titleId, System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds) {
            this.Invoke("SendGameInvite", new object[] {
                        titleId,
                        userId,
                        sessionId,
                        toUserIds});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendGameInvite(System.UInt32 titleId, System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendGameInvite", new object[] {
                        titleId,
                        userId,
                        sessionId,
                        toUserIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendGameInvite(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RevokeGameInvite", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeGameInvite(System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds) {
            this.Invoke("RevokeGameInvite", new object[] {
                        userId,
                        sessionId,
                        toUserIds});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeGameInvite(System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeGameInvite", new object[] {
                        userId,
                        sessionId,
                        toUserIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeGameInvite(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SetNotificationState", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetNotificationState(System.UInt64 userId, System.UInt16 stateFlags, System.UInt64 sessionId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] stateData) {
            this.Invoke("SetNotificationState", new object[] {
                        userId,
                        stateFlags,
                        sessionId,
                        stateData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetNotificationState(System.UInt64 userId, System.UInt16 stateFlags, System.UInt64 sessionId, System.Byte[] stateData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetNotificationState", new object[] {
                        userId,
                        stateFlags,
                        sessionId,
                        stateData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetNotificationState(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AddUserToMutelist", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddUserToMutelist(System.UInt64 userId, System.UInt64 userIdToAdd) {
            this.Invoke("AddUserToMutelist", new object[] {
                        userId,
                        userIdToAdd});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddUserToMutelist(System.UInt64 userId, System.UInt64 userIdToAdd, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddUserToMutelist", new object[] {
                        userId,
                        userIdToAdd}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddUserToMutelist(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RemoveUserFromMutelist", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveUserFromMutelist(System.UInt64 userId, System.UInt64 userIdToRemove) {
            this.Invoke("RemoveUserFromMutelist", new object[] {
                        userId,
                        userIdToRemove});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveUserFromMutelist(System.UInt64 userId, System.UInt64 userIdToRemove, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveUserFromMutelist", new object[] {
                        userId,
                        userIdToRemove}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveUserFromMutelist(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://svctunnel.xboxlive.com/Presence/")]
    public class Friend {
        
        /// <remarks/>
        public System.UInt64 userId;
        
        /// <remarks/>
        public string gamertag;
        
        /// <remarks/>
        public System.UInt32 friendState;
        
        /// <remarks/>
        public System.DateTime gameinviteTime;
        
        /// <remarks/>
        public System.UInt64 sessionID;
        
        /// <remarks/>
        public System.UInt32 titleID;
        
        /// <remarks/>
        public string titleName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] StateData;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunnelquickcheck\Health.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Health {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="HealthSoap", Namespace="http://svctunnel.xboxlive.com/Health/")]
    public class Health : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Health() {
            this.Url = "http://10.10.2.36:4541/svctunnel/health.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Health/Heartbeat", RequestNamespace="http://svctunnel.xboxlive.com/Health/", ResponseNamespace="http://svctunnel.xboxlive.com/Health/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void Heartbeat() {
            this.Invoke("Heartbeat", new object[0]);
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginHeartbeat(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Heartbeat", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public void EndHeartbeat(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Health/VerifyConfig", RequestNamespace="http://svctunnel.xboxlive.com/Health/", ResponseNamespace="http://svctunnel.xboxlive.com/Health/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string VerifyConfig() {
            object[] results = this.Invoke("VerifyConfig", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginVerifyConfig(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("VerifyConfig", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndVerifyConfig(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\StressBase.cs ===
using System;
using System.Windows.Forms;
using System.Threading;
using System.Collections;
using System.Diagnostics;

namespace svctunneltest
{
	#region class timeData
	class timeData
	{
		#region Static members
		static object gidlock = new object();
		static ulong gid = 0;
		#endregion

		#region public timeData()
		public timeData()
		{
			lock(gidlock)
			{
				id = ++gid;
			}
		}
		#endregion

		#region public class KeyCompare : IComparable
		public class KeyCompare : IComparable
		{
			public DateTime dt;
			ulong id;

			protected KeyCompare()
			{
			}

			public KeyCompare(DateTime date, ulong entryid)
			{
				dt = date;
				id = entryid;
			}

			#region IComparable Members

			public int CompareTo(object y)
			{
				// TODO:  Add KeyStart.Compare implementation
				if(this == null)
					return -1;
				if(y == null)
					return 1;

				KeyCompare ksy = (KeyCompare) y;

				if(dt < ksy.dt)
					return -1;
				if(dt > ksy.dt)
					return 1;

				if(id < ksy.id)
					return -1;
				if(id > ksy.id)
					return 1;

				return 0;
			}

			#endregion
		}
		#endregion

		public KeyCompare StartKey
		{
			get{KeyCompare kc = new KeyCompare(start, id); return kc;}
		}
		public KeyCompare EndKey
		{
			get{KeyCompare kc = new KeyCompare(end, id); return kc;}
		}
		ulong id;
		public DateTime start;
		public DateTime end;
		public bool failed;
		public bool calced;

		#region public double Contribution(DateTime spanStart, DateTime spanEnd)
		public double Contribution(DateTime spanStart, DateTime spanEnd)
		{
			if(start >= spanEnd)
				return 0;
			if(end <= spanStart)
				return 0;

			if(start == end)
				return 1;

			DateTime s = (start > spanStart) ? start : spanStart;
			DateTime e = (end < spanEnd) ? end : spanEnd;

			double r = (e.Ticks - s.Ticks);
			r /= end.Ticks - start.Ticks;
			return r;
		}
		#endregion
	};
	#endregion

	/// <summary>
	/// Class to handle all the time processing statistics without getting tied up tightly in the UI.
	/// </summary>
	public class processTimes
	{
		#region Private data
		SortedList slStart = new SortedList();
		SortedList slEnd = new SortedList();
		DateTime dtLastMinMaxClear = DateTime.Now;
		TimeSpan tsMinMaxClearFreq = new TimeSpan(0, 0, 10, 0, 0);

		SortedList submissions = new SortedList();


		// Statistics exposed to the user
		TimeSpan avgTime;
		TimeSpan minTime;
		TimeSpan maxTime;
		double AvgReqPerSec = 0;
		double AvgFailPerSec = 0;

		// Internal tracking information
		DateTime LastUpdate;
		TimeSpan qSize;
		TimeSpan qStart;

		/// <summary>
		/// The name of the test (to be set by the derived class)
		/// </summary>
		protected string name = "name";
		/// <summary>
		/// Requests per second (inclusive of failures)
		/// </summary>
		protected PerformanceCounter rps = null;
		/// <summary>
		/// Failures per second
		/// </summary>
		protected PerformanceCounter fps = null;
		/// <summary>
		/// Request time (inclusive of failures)
		/// </summary>
		protected PerformanceCounter rtm = null;
		/// <summary>
		/// Failure time
		/// </summary>
		protected PerformanceCounter ftm = null;
		/// <summary>
		/// Total Requests (including failures)
		/// </summary>
		protected PerformanceCounter trq = null;
		/// <summary>
		/// Total Failures
		/// </summary>
		protected PerformanceCounter tfl = null;


		/// <summary>
		/// Total time spent creating widgets
		/// </summary>
		protected static PerformanceCounter widgettime = null;
		/// <summary>
		/// Total number of widgets created
		/// </summary>
		protected static PerformanceCounter widgettotal = null;

		string component = null;
		//static string req_str = "Requests";
		//static string fail_str = "Failures";
		static string rps_str = "Requests/Sec";
		static string fps_str = "Failures/Sec";
		static string trq_str = "Total Requests";
		static string tfl_str = "Total Failures";
		static string rtm_str = "Average Request Processing Time";
		static string ftm_str = "Average Failure Processing Time";

		static string [] str_lst = new string [] {rps_str, fps_str, trq_str, tfl_str, rtm_str, ftm_str};

		#endregion

		#region CheckPerfCounterSetup
		private bool VerifyCounterList()
		{
			PerformanceCounterCategory [] pccs = PerformanceCounterCategory.GetCategories();
			uint found = 0;
			// Go through each of the categories to find mine
			foreach(PerformanceCounterCategory pcc in pccs)
			{
				if(pcc.CategoryName == component)
				{
					// Verify that the two lists are identical.
					string instname = null;
					try
					{
						string [] instances = pcc.GetInstanceNames();
						instname = instances[0];
					}
					catch
					{
					}
					PerformanceCounter [] pcs = null;
					if(instname != null)
						pcs = pcc.GetCounters(instname);
					else
						pcs = pcc.GetCounters();
					foreach(PerformanceCounter pc in pcs)
					{
						bool matched = false;
						foreach(string s in str_lst)
						{
							if(pc.CounterName == s)
							{
								matched = true;
								found++;
								break;
							}
						}
						if(!matched)
							return false;
					}
					if(found != str_lst.Length)
						return false;
					return true;
				}
			}
            return true;
		}
		private void CheckPerfCounterSetup()
		{
			lock(component)
			{
				if(!VerifyCounterList())
					PerformanceCounterCategory.Delete(component);


				if(!PerformanceCounterCategory.Exists(component))
				{
					CounterCreationData ccd_rps = new CounterCreationData();
					ccd_rps.CounterName = rps_str;
					ccd_rps.CounterType = PerformanceCounterType.RateOfCountsPerSecond32;

					CounterCreationData ccd_fps = new CounterCreationData();
					ccd_fps.CounterName = fps_str;
					ccd_fps.CounterType = PerformanceCounterType.RateOfCountsPerSecond32;

					CounterCreationData ccd_rtm = new CounterCreationData();
					ccd_rtm.CounterName = rtm_str;
					ccd_rtm.CounterType = PerformanceCounterType.AverageCount64;
    
					// Add the base counter.
					CounterCreationData ccd_trq = new CounterCreationData();
					ccd_trq.CounterName = trq_str;
					ccd_trq.CounterType = PerformanceCounterType.AverageBase;

					CounterCreationData ccd_ftm = new CounterCreationData();
					ccd_ftm.CounterName = ftm_str;
					ccd_ftm.CounterType = PerformanceCounterType.AverageCount64;

					// Add the base counter.
					CounterCreationData ccd_tfl = new CounterCreationData();
					ccd_tfl.CounterName = tfl_str;
					ccd_tfl.CounterType = PerformanceCounterType.AverageBase;

					// Add the base counter.
					CounterCreationDataCollection ccds = new CounterCreationDataCollection();
					ccds.Add(ccd_rps);
					ccds.Add(ccd_fps);
					ccds.Add(ccd_rtm);
					ccds.Add(ccd_trq);
					ccds.Add(ccd_ftm);
					ccds.Add(ccd_tfl);
    
					PerformanceCounterCategory.Create(
                                            component,
                                            "SvcTunnel Stress Test Statistics",
                                            PerformanceCounterCategoryType.SingleInstance,
                                            ccds);
				}
			}
		}
		#endregion

		#region ctor
		private processTimes()
		{
		}

		/// <summary>
		/// Ctor
		/// </summary>
		/// <param name="componentname">name of the component/category for performance counters</param>
		/// <param name="myName">name to be tracking times for</param>
		/// <param name="QueueStart">The amount of time from the current time to start analysing the times submitted for stats</param>
		/// <param name="QueueSize">The amount of time to keep stats in the queue for analysis.</param>
		public processTimes(string componentname, string myName, TimeSpan QueueStart, TimeSpan QueueSize)
		{
			component = componentname;
			name = myName;
			CheckPerfCounterSetup();
			rps = new PerformanceCounter(component, rps_str, name, false);
			fps = new PerformanceCounter(component, fps_str, name, false);
			rtm = new PerformanceCounter(component, rtm_str, name, false);
			trq = new PerformanceCounter(component, trq_str, name, false);
			ftm = new PerformanceCounter(component, ftm_str, name, false);
			tfl = new PerformanceCounter(component, tfl_str, name, false);
			qStart = QueueStart;
			qSize = QueueSize;
			LastUpdate = DateTime.Now.Subtract(qStart);
			Clear();
		}
		#endregion

		#region dtor
		/// <summary>
		/// Destructor--closes perf counters
		/// </summary>
		~processTimes()
		{
			rps.Close();
			fps.Close();
			rtm.Close();
			ftm.Close();
		}
		#endregion

		#region Accessors
		/// <summary>
		/// The name of the test
		/// </summary>
		public string Name
		{
			get{return name;}
		}

		/// <summary>
		/// Number of seconds in the sample's span of time.  If the samples don't cover the whole queue span, then it is 
		/// determined based on what the samples indicate (up to the queue span).
		/// </summary>
		private double SampleSpanInSeconds
		{
			get
			{
				DateTime s = (slStart.Count > 0) ? ((timeData) slStart.GetByIndex(0)).start : DateTime.MinValue;
				s = (s > LastUpdate.Subtract(qSize)) ? s : LastUpdate.Subtract(qSize);
				DateTime e = (slEnd.Count > 0) ? ((timeData) slEnd.GetByIndex(slEnd.Count - 1)).end : DateTime.MaxValue;
				e = (e < LastUpdate) ? e : LastUpdate;
				double totalsecs = e.Ticks - s.Ticks;
				totalsecs /= 10 * 1000 * 1000;
				return totalsecs;
			}
		}

		/// <summary>
		/// Average number of requests per second (includes failures)
		/// </summary>
		public double AverageRequestsPerSecond
		{
			//get{return rps.NextValue();}
			get{double span = SampleSpanInSeconds; return (span == 0) ? double.NaN : AvgReqPerSec/SampleSpanInSeconds;}
		}

		/// <summary>
		/// Average number of failures per second
		/// </summary>
		public double AverageFailuresPerSecond
		{
			//get{return fps.NextValue();}
			get{double span = SampleSpanInSeconds; return (span == 0) ? double.NaN : AvgFailPerSec/SampleSpanInSeconds;}
		}

		/// <summary>
		/// Average amount of time per request.
		/// </summary>
		public double TimeAverage
		{
			// get{return rtm.NextValue();}
			get{ double d = avgTime.Ticks; return (slStart.Count == 0) ? double.NaN : d / slStart.Count / 10 / 1000;}
		}

		/// <summary>
		/// Minimum amount of time a request took
		/// </summary>
		public TimeSpan TimeMinimum
		{
			get{return minTime;}
		}

		/// <summary>
		/// Maximum amout of time a request took
		/// </summary>
		public TimeSpan TimeMaximum
		{
			get{return maxTime;}
		}
		#endregion

		/// <summary>
		/// Clears max and min times only.
		/// </summary>
		#region public void ClearTimes()
		public void ClearTimes()
		{
			minTime = TimeSpan.MaxValue;
			maxTime = TimeSpan.MinValue;
			dtLastMinMaxClear = DateTime.Now;
		}
		
		#endregion

		/// <summary>
		/// Clears all fields and lists.
		/// </summary>
		#region public void Clear()
		public void Clear()
		{
			ClearTimes();
			AvgReqPerSec = 0;
			AvgFailPerSec = 0;
			slStart.Clear();
			slEnd.Clear();
			lock(submissions)
			{
				submissions.Clear();
			}
		}
		#endregion


		/// <summary>
		/// This is the api that stress tests use to submit their running time.
		/// </summary>
		/// <param name="start">Start time of test</param>
		/// <param name="end">End time of test</param>
		/// <param name="failed">Whether the test failed</param>
		#region public void SubmitTime(DateTime start, DateTime end, bool failed)
		public void SubmitTime(DateTime start, DateTime end, bool failed)
		{
			TimeSpan diff = end.Subtract(start);
			rps.Increment();
			trq.Increment();
			rtm.IncrementBy((long) diff.TotalMilliseconds);
			if(failed)
			{
				fps.Increment();
				tfl.Increment();
				ftm.IncrementBy((long) diff.TotalMilliseconds);
			}

			timeData td = new timeData();
			td.start = start;
			td.end = end;
			td.failed = failed;
			lock(submissions)
			{
				submissions.Add(td.StartKey, td);
			}
		}
		#endregion

		#region timeData Dequeue(DateTime dt)
		timeData Dequeue(DateTime dt)
		{
			lock(submissions)
			{
				if(submissions.Count == 0)
					return null;
				timeData res = (timeData) submissions.GetByIndex(0);
				if(res == null)
					return res;
				if(res.start > dt)
					return null;
				submissions.RemoveAt(0);
				return res;
			}
		}
		#endregion
		
		#region void PullQueuedSubmissions(DateTime nw)
		void PullQueuedSubmissions(DateTime nw)
		{
			timeData td = null;
			while((td = Dequeue(nw)) != null)
			{
				// determine if I should bother pulling this entry off the submissions list yet.
				TimeSpan ts = td.end - td.start;

				// Update max and min times
				if(ts > maxTime)
					maxTime = ts;
				if(ts < minTime)
					minTime = ts;

				/* Six cases to manage in how a timeData fits over the end points of the time span for sampling:
					td.end <= LastUpdate.Subtract(qSpan) -- don't process, old record
					td.start >= LastUpdate -- add to the list, but no other work to do
					The other four follow the following steps:
						if(td.end != td.start)
						{
							TimeDate s = max(td.start, LastUpdate.Subtract(qSpan))
							TimeDate e = min(td.end, LastUpdate)
							TimeSpan x = (e - s) / (td.end - td.start)
							rps += x;
							if(failed) fps += x;
						}
						else
						{
							rps += 1;
							if(failed) fps += 1;
						}
				*/
				DateTime LastUpdateSpanStart = LastUpdate.Subtract(qSize);
				// Case 1, submission is really old
				if(td.end <= LastUpdateSpanStart)
					continue;

				avgTime += ts;

				// Case 2, submission is too new
				double contribution = td.Contribution(LastUpdateSpanStart, LastUpdate);

				AvgReqPerSec += contribution;
				AvgFailPerSec += td.failed ? contribution : 0;

				slStart.Add(td.StartKey, td);
				slEnd.Add(td.EndKey, td);
			}
		}
		#endregion

		#region bool UpdateRecord(timeData rec, DateTime nw, ArrayList mods)
		bool UpdateRecord(timeData rec, DateTime nw, ArrayList mods)
		{
			// covers some potential calculate twice scenarios.
			if(rec.calced)
				return false;

			// Calculate original contribution to reqpersec and failedpersec
			double oldContribution = rec.Contribution(LastUpdate.Subtract(qSize), LastUpdate);

			// Calculate new contribution to reqpersec and failedpersec
			double newContribution = rec.Contribution(nw.Subtract(qSize), nw);

			// If there is a change in contribution in any sense, set the calced flag and update values
			double diff = newContribution - oldContribution;
			if(diff != 0)
			{
				AvgReqPerSec += diff;
				AvgFailPerSec += (rec.failed) ? diff : 0;
				rec.calced = true;
			}

			// If the end time is less than the new span start time, return true to delete the record, otherwise return false
			// but update the average time on the caller's behalf (so they only have to delete)
			if(rec.end < nw.Subtract(qSize))
			{
				avgTime -= rec.end.Subtract(rec.start);
				return true;
			}
			mods.Add(rec);
			return false;
		}
		#endregion

		/// <summary>
		/// Processes the times in the submission list and the current queue in the queue time span updating the 
		/// stats based on the update in time.
		/// </summary>
		#region public void ProcessTimes()
		public void ProcessTimes()
		{
			if(DateTime.Now.Subtract(dtLastMinMaxClear) > tsMinMaxClearFreq)
				ClearTimes();

			DateTime NewSpanEnd = DateTime.Now.Subtract(qStart);
			DateTime NewSpanStart = NewSpanEnd.Subtract(qSize);
			PullQueuedSubmissions(NewSpanEnd);
			int i = 0;
			timeData td;
			DateTime LastUpdateSpanStart = LastUpdate.Subtract(qSize);

			// Used to track the entries that have been processed so that I can clear the calced flag which
			// is used to prevent double calculation of the same record between the two loops.
			ArrayList ModifiedEntries = new ArrayList();
			bool fDelete = false;
			// Process all records that overlap the end.
			for(i = slEnd.Count - 1; i >= 0; --i)
			{
				td = (timeData) slEnd.GetByIndex(i);
				if(td.end <= LastUpdate)
					break;

				fDelete = UpdateRecord(td, NewSpanEnd, ModifiedEntries);
				if(fDelete)
				{
					slEnd.RemoveAt(i);
					slStart.Remove(td.StartKey);
					++i;
				}
			}

			// Process all records that overlap the start.
			for(i = 0; i < slStart.Count; ++i)
			{
				td = (timeData) slStart.GetByIndex(i);
				if(td.start >= NewSpanStart)	// Remove this entry
					break;

				fDelete = UpdateRecord(td, NewSpanEnd, ModifiedEntries);
				if(fDelete)
				{
					slStart.RemoveAt(i);
					slEnd.Remove(td.EndKey);
					--i;
				}
			}

			// Clear the calced entry for all of the records
			foreach(timeData d in ModifiedEntries)
			{
				d.calced = false;
			}

			ModifiedEntries.Clear();

			LastUpdate = NewSpanEnd;
		}
		#endregion
	}

	/// <summary>
	/// StressBase provides basic functionality for tracking api call stats and updating the UI to reflect the changes.
	/// </summary>
	public class StressBase : processTimes
	{
		static int MinMSBetweenUpdates = 250;
		static DateTime LastLog = DateTime.Now;
		static TimeSpan LogFreq = new TimeSpan(0, 0, 10, 0, 0);

		/// <summary>
		/// Provides the list of available users for tests to run with, shared across all tests.
		/// </summary>
		public static UserMgmt Users;

		const int StressNameIndex = 0;
		const int ThreadsDesiredIndex = 1;
		const int CallDelayIndex = 2;
		const int CallsPerSecIndex = 3;
		const int FailuresPerSecIndex = 4;
		const int AverageTimeMSIndex = 5;
		const int MinTimeMSIndex = 6;
		const int MaxTimeMSIndex = 7;

		/// <summary>
		/// Order is:
		///		Stress name (typically the name of the API)
		///		Number of threads/sec
		///		Current number of calls/sec
		///		Number of failures in the last second
		///		Average call time
		///		Minimum call time
		///		Maximum call time
		/// </summary>
		ListViewItem lvi = null;
		uint threadsToRun = 0;
		bool Started = false;
		bool DialogRunning = true;
		uint callDelay = 0;

		object threadListLock = new object();
		ArrayList myThreads = new ArrayList();
		System.Threading.Thread uiThread = null;

		/// <summary>
		/// ctor:  Current defaults are stats are analysed after 2 seconds and kept in the queue for 10 minutes.
		/// </summary>
		public StressBase(string myName) : base("SvcTunnel Tests", myName, new TimeSpan(0, 0, 0, 2, 0), new TimeSpan(0, 0, 2, 0, 0))
		{
			lvi = new ListViewItem(new string[] {myName, "0", "0", "0.0", "0.0", "N/A", "N/A", "N/A"});
			uiThread = new Thread(new System.Threading.ThreadStart(this.UIThread));
			uiThread.Start();
		}

		/// <summary>
		/// Indicates the application is quiting and should stop all threads.
		/// </summary>
		public void Quit()
		{
			DialogRunning = false;
			Stop();
		}

		void UpdateUI(double val, int itemidx)
		{
			string t = (val == double.MinValue || val == double.MaxValue || val == double.NaN) ? "N/A" : val.ToString("0.0");
			if(lvi.SubItems[itemidx].Text != t)
				lvi.SubItems[itemidx].Text = t;
		}

		void UpdateUI(TimeSpan val, int itemidx)
		{
			string t = (val == TimeSpan.MinValue || val == TimeSpan.MaxValue) ? "N/A" : val.ToString();
			if(lvi.SubItems[itemidx].Text != t)
				lvi.SubItems[itemidx].Text = t;
		}
		void UpdateUI()
		{
			if(lvi.ListView != null)
			{
				lock(lvi.ListView)
				{
					UpdateUI(TimeAverage, AverageTimeMSIndex);
					UpdateUI(TimeMaximum, MaxTimeMSIndex);
					UpdateUI(TimeMinimum, MinTimeMSIndex);
					UpdateUI(AverageRequestsPerSecond, CallsPerSecIndex);
					UpdateUI(AverageFailuresPerSecond, FailuresPerSecIndex);
				}
			}
		}

		void UIThread()
		{
			while(DialogRunning)
			{
				ProcessTimes();
				UpdateUI();
				System.Threading.Thread.Sleep(MinMSBetweenUpdates);
			}
		}

		/// <summary>
		/// Called when the Start button is pressed, this triggers the start of calls to the API
		/// </summary>
		public void Start()
		{
			lvi.SubItems[AverageTimeMSIndex].Text = lvi.SubItems[MinTimeMSIndex].Text = lvi.SubItems[MaxTimeMSIndex].Text = "N/A";
			lvi.SubItems[CallsPerSecIndex].Text = lvi.SubItems[FailuresPerSecIndex].Text = "0.0";

			Clear();

			lock(threadListLock)
			{
				while(myThreads.Count < threadsToRun)
				{
					ThreadBase b = new ThreadBase(this);
					myThreads.Add(b);
				}
				Started = true;
			}
		}

		/// <summary>
		/// Stop ends the currently running tests
		/// </summary>
		public void Stop()
		{
			lock(threadListLock)
			{
				Started = false;
				while(myThreads.Count > 0)
				{
					ThreadBase b = (ThreadBase) myThreads[0];
					b.Stop();
					myThreads.RemoveAt(0);
				}
			}
		}

		/// <summary>
		/// Sets and gets the number of threads to run, properly handling changes while the tests are running
		/// </summary>
		public uint ThreadCount
		{
			get{return threadsToRun;}
			set
			{
				lock(threadListLock)
				{
					threadsToRun = value;
					lvi.SubItems[ThreadsDesiredIndex].Text = threadsToRun.ToString();
					if(Started)
					{
						while(myThreads.Count > threadsToRun)
						{
							ThreadBase b = (ThreadBase) myThreads[0];
							b.Stop();
							myThreads.RemoveAt(0);
						}
						while(myThreads.Count < threadsToRun)
						{
							ThreadBase b = new ThreadBase(this);
							myThreads.Add(b);
						}
					}
				}
			}
		}

		/// <summary>
		/// Returns the list view entry for display in the UI
		/// </summary>
		public ListViewItem ListViewEntry
		{
			get{return lvi;}
		}

		/// <summary>
		/// Indicates the amount of time between calls each thread should wait for.
		/// </summary>
		public uint CallDelay
		{
			get{return callDelay;}
			set{callDelay = value; string t = value.ToString(); if(lvi.SubItems[CallDelayIndex].Text != t) lvi.SubItems[CallDelayIndex].Text = t;}
		}

		/// <summary>
		/// Virtual function that needs to be implemented by the derived class to do anything useful.
		/// </summary>
		public virtual void CallAPI()
		{
		}

		/// <summary>
		/// Runs the tests
		/// </summary>
		/// <param name="state">Currently ignored</param>
		public void Run(object state)
		{
			CallAPI();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\makefile.inc ===
!if !defined(VSTUDIO_POSTBUILD)
!include $(INETROOT)\build\makefile.inc

!if defined(PASS2)

bin\$(TARGETNAME).exe: $(URTTARGET)
        copy $** $@
        copy $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb bin\$(TARGETNAME).pdb

!else

bin\$(TARGETNAME).exe:

!endif
!endif

!if defined(VSTUDIO_POSTBUILD)

all: FakeSGService.exe stf_tn.xml stf_dn2.xml stf_preprod.xml

FakeSGService.exe: $(BASEDIR)\private\test\stftests\stfrunner\fakesgservice.exe
        -robocopy $(BASEDIR)\private\test\stftests\stfrunner . fakesgservice.exe /R:0 /NP /NJH /NJS /A-:R

stf_tn.xml: $(BASEDIR)\private\test\stftests\stfrunner\stf_tn.xml
        -robocopy $(BASEDIR)\private\test\stftests\stfrunner . stf_tn.xml /R:0 /NP /NJH /NJS /A-:R

stf_dn2.xml: $(BASEDIR)\private\test\stftests\stfrunner\stf_dn2.xml
        -robocopy $(BASEDIR)\private\test\stftests\stfrunner . stf_dn2.xml /R:0 /NP /NJH /NJS /A-:R

stf_preprod.xml: $(BASEDIR)\private\test\stftests\stfrunner\stf_preprod.xml
        -robocopy $(BASEDIR)\private\test\stftests\stfrunner . stf_preprod.xml /R:0 /NP /NJH /NJS /A-:R

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\Accounts.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Accounts {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="AccountsSoap", Namespace="http://svctunnel.xboxlive.com/Accounts/")]
    public class Accounts : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Accounts() {
            this.Url = "http://10.10.2.36:4541/svctunnel/accounts.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserInfo", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserInfo GetUserInfo(System.UInt64 userId) {
            object[] results = this.Invoke("GetUserInfo", new object[] {
                        userId});
            return ((UserInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserInfo(System.UInt64 userId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserInfo", new object[] {
                        userId}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserInfo EndGetUserInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserInfo)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/SendUserFeedback", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendUserFeedback(System.UInt32 titleId, System.UInt64 userId, System.UInt64 toUserId, System.UInt32 feedbackType, string nickname) {
            this.Invoke("SendUserFeedback", new object[] {
                        titleId,
                        userId,
                        toUserId,
                        feedbackType,
                        nickname});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendUserFeedback(System.UInt32 titleId, System.UInt64 userId, System.UInt64 toUserId, System.UInt32 feedbackType, string nickname, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendUserFeedback", new object[] {
                        titleId,
                        userId,
                        toUserId,
                        feedbackType,
                        nickname}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendUserFeedback(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetGamertag(System.UInt64 userId) {
            object[] results = this.Invoke("GetGamertag", new object[] {
                        userId});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGamertag(System.UInt64 userId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGamertag", new object[] {
                        userId}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserId", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64 GetUserId(string gamertag) {
            object[] results = this.Invoke("GetUserId", new object[] {
                        gamertag});
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserId(string gamertag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserId", new object[] {
                        gamertag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64 EndGetUserId(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetGamertagsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] GetGamertagsFromList(System.UInt64[] userIds) {
            object[] results = this.Invoke("GetGamertagsFromList", new object[] {
                        userIds});
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetGamertagsFromList(System.UInt64[] userIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetGamertagsFromList", new object[] {
                        userIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public string[] EndGetGamertagsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Accounts/GetUserIdsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Accounts/", ResponseNamespace="http://svctunnel.xboxlive.com/Accounts/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64[] GetUserIdsFromList(string[] gamertags) {
            object[] results = this.Invoke("GetUserIdsFromList", new object[] {
                        gamertags});
            return ((System.UInt64[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserIdsFromList(string[] gamertags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserIdsFromList", new object[] {
                        gamertags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64[] EndGetUserIdsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64[])(results[0]));
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://svctunnel.xboxlive.com/Accounts/")]
    public class UserInfo {
        
        /// <remarks/>
        public System.UInt64 userId;
        
        /// <remarks/>
        public string gamertag;
        
        /// <remarks/>
        public bool optOut;
        
        /// <remarks/>
        public string firstName;
        
        /// <remarks/>
        public string lastName;
        
        /// <remarks/>
        public string emailAddress;
        
        /// <remarks/>
        public string streetAddress;
        
        /// <remarks/>
        public string city;
        
        /// <remarks/>
        public string state;
        
        /// <remarks/>
        public string postalCode;
        
        /// <remarks/>
        public System.Byte countryId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\ThreadBase.cs ===
using System;
using System.Threading;

namespace svctunneltest
{
	/// <summary>
	/// Summary description for ThreadBase.
	/// </summary>
	class ThreadBase
	{
		StressBase activeCase = null;
		bool fStop = false;
		System.Threading.Thread thread;

		public ThreadBase(StressBase sb)
		{
			activeCase = sb;
			thread = new Thread(new System.Threading.ThreadStart(this.ThreadMain));
			thread.Start();
		}

		public void Stop()
		{
			fStop = true;
		}

		void ThreadMain()
		{
			while(!fStop)
			{
				activeCase.CallAPI();
				if(activeCase.CallDelay > 0)
				{
					System.Threading.Thread.Sleep((int) activeCase.CallDelay);
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\StressCases.cs ===
using System;
using System.Collections;
using System.Threading;
using Presence;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace svctunneltest
{
	/// <summary>
	/// Summary description for StressCases.
	/// </summary>
	class StressCases
	{
		Hashtable ht = new Hashtable();

		public Hashtable Cases
		{
			get{return ht;}
		}

		public void Start()
		{
			foreach(StressBase sb in ht.Values)
			{
				sb.Start();
			}
		}

		public void Stop()
		{
			foreach(StressBase sb in ht.Values)
			{
				sb.Stop();
			}
		}

		public void Quit()
		{
			foreach(StressBase sb in ht.Values)
			{
				sb.Quit();
			}
		}

		public StressCases()
		{
			StressBase sb = new GetFriends();
			ht.Add(sb.Name, sb);
			sb = new SetNotificationState();
			ht.Add(sb.Name, sb);
			sb = new GetUserId();
			ht.Add(sb.Name, sb);
			sb = new Heartbeat();
			ht.Add(sb.Name, sb);
		}

		#region public class GetFriends : StressBase
		public class GetFriends : StressBase
		{
			public GetFriends() : base("Presence.GetFriends")
			{
			}

			public override void CallAPI()
			{
				bool failed = false;
				UserMgmt.UserInfo ui = Users.CheckoutUser();
				Presence.Presence pres = Widgets.Presence(UserMgmt.GetAuthData(ui.UserPuid));
				Presence.Friend [] fs = null;
				DateTime end, dt = new DateTime(DateTime.Now.Ticks);

				try
				{
					fs = pres.GetFriends(ui.UserPuid, 1);
				}
				catch //(System.Exception e)
				{
					failed = true;
				}
				end = new DateTime(DateTime.Now.Ticks);
				SubmitTime(dt, end, failed);
				Users.CheckinUser(ui);
			}
		}
		#endregion

		#region public class SetNotificationState : StressBase
		public class SetNotificationState : StressBase
		{
			public SetNotificationState() : base("Presence.SetNotificationState")
			{
			}

			public override void CallAPI()
			{
				bool failed = false;
				RandomEx r = new RandomEx();
				UserMgmt.UserInfo ui = Users.CheckoutUser();
				Presence.Presence pres = Widgets.Presence(UserMgmt.GetAuthData(ui.UserPuid));

				ushort state = (ushort) ((r.Next(2) << 4) + (r.Next(2) << 3) + (r.Next(2) << 1) + (r.Next(2)));
				ulong sessionid = (r.NextUlong());
				byte [] b = new byte[32];
				r.NextBytes(b);

				DateTime end, dt = new DateTime(DateTime.Now.Ticks);
				try
				{
					pres.SetNotificationState(ui.UserPuid, state, sessionid, b);
				}
				catch //(System.Exception e)
				{
					failed = true;
				}
				end = new DateTime(DateTime.Now.Ticks);
				SubmitTime(dt, end, failed);
				Users.CheckinUser(ui);
			}
		}
		#endregion

		#region public class GetUserId : StressBase
		public class GetUserId : StressBase
		{
			public GetUserId() : base("Accounts.GetUserId")
			{
			}

			public override void CallAPI()
			{
				bool failed = false;
				ulong puidchk = 0;
				UserMgmt.UserInfo ui = Users.CheckoutUser();
				Accounts.Accounts acct = Widgets.Accounts(UserMgmt.GetAuthData(ui.UserPuid));

				DateTime end, dt = new DateTime(DateTime.Now.Ticks);
				try
				{
					puidchk = acct.GetUserId(ui.User.gamertag);
					if(puidchk != ui.UserPuid)
						throw new Exception("Puid mismatch from GetUserId");
				}
				catch //(System.Exception e)
				{
					failed = true;
				}
				end = new DateTime(DateTime.Now.Ticks);
				SubmitTime(dt, end, failed);
				Users.CheckinUser(ui);
			}
		}
		#endregion

		#region public class Heartbeat : StressBase
		public class Heartbeat : StressBase
		{
			public Heartbeat() : base("Health.Heartbeat")
			{
			}

			public override void CallAPI()
			{
				bool failed = false;
				Health.Health hlth = Widgets.Health(null);

				DateTime end, dt = new DateTime(DateTime.Now.Ticks);
				try
				{
					hlth.Heartbeat();
				}
				catch //(System.Exception e)
				{
					failed = true;
				}
				end = new DateTime(DateTime.Now.Ticks);
				SubmitTime(dt, end, failed);
			}
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\SvcTunnelStress.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using ServerTestFramework;
using System.IO;
using System.Xml;
using System.Threading;

namespace svctunneltest
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	class SvcTunnelStress : System.Windows.Forms.Form
	{
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.TextBox txtEnv;
		private System.Windows.Forms.Button btnEnvLoad;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.ListView lstStress;
		private System.Windows.Forms.ColumnHeader clmName;
		private System.Windows.Forms.ColumnHeader clmAverageCallTime;
		private System.Windows.Forms.Button btnStart;
		private System.Windows.Forms.Button btnStop;
		private System.Windows.Forms.TextBox txtFreq;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Button btnUnload;
		UserMgmt userlist = new UserMgmt();
		StressCases cases = null;
		private string stfdoc = null;
		private System.Windows.Forms.ColumnHeader clmMinTime;
		private System.Windows.Forms.ColumnHeader clmMaxTime;
		private System.Windows.Forms.ColumnHeader clmThreads;
		private System.Windows.Forms.ColumnHeader clmFreq;
		private System.Windows.Forms.ColumnHeader clmFailures;
		private System.Windows.Forms.Button btnSetThreads;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.TextBox txtWait;
		private System.Windows.Forms.Button btnSetWait;
		private System.Windows.Forms.ColumnHeader clmWait;
		UserProgress userProgressBar = new UserProgress();
		public SvcTunnelStress()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
			cases = new StressCases();

			foreach(string s in cases.Cases.Keys)
			{
				lstStress.Items.Add(((StressBase) cases.Cases[s]).ListViewEntry);
			}

			btnUnload.Enabled = false;
			btnStart.Enabled = false;
			btnStop.Enabled = false;
			userProgressBar.Owner = this;
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			cases.Quit();
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.label1 = new System.Windows.Forms.Label();
			this.txtEnv = new System.Windows.Forms.TextBox();
			this.btnEnvLoad = new System.Windows.Forms.Button();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.btnSetWait = new System.Windows.Forms.Button();
			this.txtWait = new System.Windows.Forms.TextBox();
			this.label3 = new System.Windows.Forms.Label();
			this.btnSetThreads = new System.Windows.Forms.Button();
			this.label2 = new System.Windows.Forms.Label();
			this.txtFreq = new System.Windows.Forms.TextBox();
			this.btnStop = new System.Windows.Forms.Button();
			this.btnStart = new System.Windows.Forms.Button();
			this.lstStress = new System.Windows.Forms.ListView();
			this.clmName = new System.Windows.Forms.ColumnHeader();
			this.clmThreads = new System.Windows.Forms.ColumnHeader();
			this.clmFreq = new System.Windows.Forms.ColumnHeader();
			this.clmFailures = new System.Windows.Forms.ColumnHeader();
			this.clmAverageCallTime = new System.Windows.Forms.ColumnHeader();
			this.clmMinTime = new System.Windows.Forms.ColumnHeader();
			this.clmMaxTime = new System.Windows.Forms.ColumnHeader();
			this.btnUnload = new System.Windows.Forms.Button();
			this.clmWait = new System.Windows.Forms.ColumnHeader();
			this.groupBox1.SuspendLayout();
			this.SuspendLayout();
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(8, 24);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(54, 16);
			this.label1.TabIndex = 1;
			this.label1.Text = "Env Defn:";
			this.label1.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// txtEnv
			// 
			this.txtEnv.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.txtEnv.Location = new System.Drawing.Point(64, 24);
			this.txtEnv.Name = "txtEnv";
			this.txtEnv.ReadOnly = true;
			this.txtEnv.Size = new System.Drawing.Size(296, 20);
			this.txtEnv.TabIndex = 2;
			this.txtEnv.Text = "";
			// 
			// btnEnvLoad
			// 
			this.btnEnvLoad.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.btnEnvLoad.Location = new System.Drawing.Point(368, 24);
			this.btnEnvLoad.Name = "btnEnvLoad";
			this.btnEnvLoad.Size = new System.Drawing.Size(56, 24);
			this.btnEnvLoad.TabIndex = 3;
			this.btnEnvLoad.Text = "Load";
			this.btnEnvLoad.Click += new System.EventHandler(this.btnEnvLoad_Click);
			// 
			// groupBox1
			// 
			this.groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.groupBox1.Controls.Add(this.btnSetWait);
			this.groupBox1.Controls.Add(this.txtWait);
			this.groupBox1.Controls.Add(this.label3);
			this.groupBox1.Controls.Add(this.btnSetThreads);
			this.groupBox1.Controls.Add(this.label2);
			this.groupBox1.Controls.Add(this.txtFreq);
			this.groupBox1.Controls.Add(this.btnStop);
			this.groupBox1.Controls.Add(this.btnStart);
			this.groupBox1.Controls.Add(this.lstStress);
			this.groupBox1.Location = new System.Drawing.Point(8, 72);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(480, 352);
			this.groupBox1.TabIndex = 5;
			this.groupBox1.TabStop = false;
			this.groupBox1.Text = "Stress Status";
			// 
			// btnSetWait
			// 
			this.btnSetWait.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.btnSetWait.Location = new System.Drawing.Point(416, 280);
			this.btnSetWait.Name = "btnSetWait";
			this.btnSetWait.Size = new System.Drawing.Size(48, 24);
			this.btnSetWait.TabIndex = 13;
			this.btnSetWait.Text = "Set";
			this.btnSetWait.Click += new System.EventHandler(this.btnSetWait_Click);
			// 
			// txtWait
			// 
			this.txtWait.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.txtWait.Location = new System.Drawing.Point(328, 280);
			this.txtWait.Name = "txtWait";
			this.txtWait.Size = new System.Drawing.Size(80, 20);
			this.txtWait.TabIndex = 12;
			this.txtWait.Text = "0";
			// 
			// label3
			// 
			this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.label3.AutoSize = true;
			this.label3.Location = new System.Drawing.Point(240, 280);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(84, 16);
			this.label3.TabIndex = 11;
			this.label3.Text = "Wait Time (ms):";
			this.label3.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// btnSetThreads
			// 
			this.btnSetThreads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.btnSetThreads.Location = new System.Drawing.Point(176, 280);
			this.btnSetThreads.Name = "btnSetThreads";
			this.btnSetThreads.Size = new System.Drawing.Size(48, 24);
			this.btnSetThreads.TabIndex = 10;
			this.btnSetThreads.Text = "Set";
			this.btnSetThreads.Click += new System.EventHandler(this.btnSet_Click);
			// 
			// label2
			// 
			this.label2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.label2.AutoSize = true;
			this.label2.Location = new System.Drawing.Point(8, 280);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(76, 16);
			this.label2.TabIndex = 9;
			this.label2.Text = "Thread Count:";
			this.label2.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// txtFreq
			// 
			this.txtFreq.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
			this.txtFreq.Location = new System.Drawing.Point(88, 280);
			this.txtFreq.Name = "txtFreq";
			this.txtFreq.Size = new System.Drawing.Size(80, 20);
			this.txtFreq.TabIndex = 8;
			this.txtFreq.Text = "0";
			// 
			// btnStop
			// 
			this.btnStop.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
			this.btnStop.Location = new System.Drawing.Point(248, 312);
			this.btnStop.Name = "btnStop";
			this.btnStop.Size = new System.Drawing.Size(72, 24);
			this.btnStop.TabIndex = 7;
			this.btnStop.Text = "Stop";
			this.btnStop.Click += new System.EventHandler(this.btnStop_Click);
			// 
			// btnStart
			// 
			this.btnStart.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
			this.btnStart.Location = new System.Drawing.Point(160, 312);
			this.btnStart.Name = "btnStart";
			this.btnStart.Size = new System.Drawing.Size(72, 24);
			this.btnStart.TabIndex = 6;
			this.btnStart.Text = "Start";
			this.btnStart.Click += new System.EventHandler(this.btnStart_Click);
			// 
			// lstStress
			// 
			this.lstStress.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
				| System.Windows.Forms.AnchorStyles.Left) 
				| System.Windows.Forms.AnchorStyles.Right)));
			this.lstStress.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
																						this.clmName,
																						this.clmThreads,
																						this.clmWait,
																						this.clmFreq,
																						this.clmFailures,
																						this.clmAverageCallTime,
																						this.clmMinTime,
																						this.clmMaxTime});
			this.lstStress.FullRowSelect = true;
			this.lstStress.HideSelection = false;
			this.lstStress.Location = new System.Drawing.Point(16, 24);
			this.lstStress.Name = "lstStress";
			this.lstStress.Size = new System.Drawing.Size(448, 248);
			this.lstStress.TabIndex = 5;
			this.lstStress.View = System.Windows.Forms.View.Details;
			// 
			// clmName
			// 
			this.clmName.Text = "Name";
			this.clmName.Width = 80;
			// 
			// clmThreads
			// 
			this.clmThreads.Text = "Threads";
			this.clmThreads.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmThreads.Width = 55;
			// 
			// clmFreq
			// 
			this.clmFreq.Text = "Req/Sec";
			this.clmFreq.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			this.clmFreq.Width = 58;
			// 
			// clmFailures
			// 
			this.clmFailures.Text = "Fail/Sec";
			this.clmFailures.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			// 
			// clmAverageCallTime
			// 
			this.clmAverageCallTime.Text = "Avg Call Time (ms)";
			this.clmAverageCallTime.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
			this.clmAverageCallTime.Width = 100;
			// 
			// clmMinTime
			// 
			this.clmMinTime.Text = "Min Call Time (ms)";
			this.clmMinTime.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
			this.clmMinTime.Width = 100;
			// 
			// clmMaxTime
			// 
			this.clmMaxTime.Text = "Max Call Time (ms)";
			this.clmMaxTime.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
			this.clmMaxTime.Width = 100;
			// 
			// btnUnload
			// 
			this.btnUnload.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
			this.btnUnload.Location = new System.Drawing.Point(432, 24);
			this.btnUnload.Name = "btnUnload";
			this.btnUnload.Size = new System.Drawing.Size(56, 24);
			this.btnUnload.TabIndex = 6;
			this.btnUnload.Text = "Unload";
			this.btnUnload.Click += new System.EventHandler(this.btnUnload_Click);
			// 
			// clmWait
			// 
			this.clmWait.Text = "Wait Time";
			this.clmWait.TextAlign = System.Windows.Forms.HorizontalAlignment.Center;
			// 
			// SvcTunnelStress
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(496, 437);
			this.Controls.Add(this.btnUnload);
			this.Controls.Add(this.groupBox1);
			this.Controls.Add(this.btnEnvLoad);
			this.Controls.Add(this.txtEnv);
			this.Controls.Add(this.label1);
			this.Name = "SvcTunnelStress";
			this.Text = "SvcTunnel Stress";
			this.Load += new System.EventHandler(this.SvcTunnelStress_Load);
			this.groupBox1.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new SvcTunnelStress());
		}

		private void btnStart_Click(object sender, System.EventArgs e)
		{
			userProgressBar.Owner = this;
			if(!userlist.Load(stfdoc + ".users", userProgressBar))
				return;

			StressBase.Users = userlist;
            
			btnStop.Enabled = true;
			btnStart.Enabled = false;
			btnUnload.Enabled = false;
			cases.Start();
		}

		private void btnStop_Click(object sender, System.EventArgs e)
		{
			btnStop.Enabled = false;
			btnStart.Enabled = true;
			btnUnload.Enabled = true;
			cases.Stop();
		}

		private void btnEnvLoad_Click(object sender, System.EventArgs e)
		{
			OpenFileDialog ofd = new OpenFileDialog();
			ofd.CheckFileExists = true;
			ofd.DefaultExt = "xml";
			ofd.Multiselect = false;
			ofd.Filter = "STF Files (*.xml)|*.xml|All Files|*";
			ofd.FilterIndex = 0;
			if(ofd.ShowDialog(this) != DialogResult.OK)
				return;
			txtEnv.Text = ofd.FileName;

			XmlDocument doc = new XmlDocument();
			doc.Load(txtEnv.Text);
			ServerTestFramework.Global.Initialize(doc);
			ServerTestFramework.Global.Env.Add(doc.SelectSingleNode("/stf/servers"));

			Widgets.Initialize();

			btnEnvLoad.Enabled = false;
			btnUnload.Enabled = true;
			btnStart.Enabled = true;
			btnStop.Enabled = false;
			stfdoc = txtEnv.Text;
		}

		private void btnUnload_Click(object sender, System.EventArgs e)
		{
			ServerTestFramework.Global.UninitializeGlobalResources();
			btnEnvLoad.Enabled = true;
			btnUnload.Enabled = false;
			btnStart.Enabled = false;
			btnStop.Enabled = false;
		}

		private void btnSet_Click(object sender, System.EventArgs e)
		{
			if(lstStress.SelectedItems.Count == 0)
				return;
			StressBase sb = (StressBase) cases.Cases[lstStress.SelectedItems[0].SubItems[0].Text];
			if(sb == null)
				return;
            sb.ThreadCount = Convert.ToUInt32(txtFreq.Text, 10);
		}

		private void SvcTunnelStress_Load(object sender, System.EventArgs e)
		{
		
		}

		private void btnSetWait_Click(object sender, System.EventArgs e)
		{
			if(lstStress.SelectedItems.Count == 0)
				return;
			StressBase sb = (StressBase) cases.Cases[lstStress.SelectedItems[0].SubItems[0].Text];
			if(sb == null)
				return;
			sb.CallDelay = Convert.ToUInt32(txtWait.Text, 10);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\Presence.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
namespace Presence {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="PresenceSoap", Namespace="http://svctunnel.xboxlive.com/Presence/")]
    public class Presence : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public Presence() {
            this.Url = "http://10.10.2.36:4541/svctunnel/presence.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriends", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriends(System.UInt64 userId, System.UInt32 language) {
            object[] results = this.Invoke("GetFriends", new object[] {
                        userId,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriends(System.UInt64 userId, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriends", new object[] {
                        userId,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriends(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriendsFromList", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriendsFromList(System.UInt64 userId, System.UInt64[] friendUserIds, System.UInt32 language) {
            object[] results = this.Invoke("GetFriendsFromList", new object[] {
                        userId,
                        friendUserIds,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriendsFromList(System.UInt64 userId, System.UInt64[] friendUserIds, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriendsFromList", new object[] {
                        userId,
                        friendUserIds,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriendsFromList(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/GetFriendsFromListByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public Friend[] GetFriendsFromListByGamertag(System.UInt64 userId, string[] friendGamertags, System.UInt32 language) {
            object[] results = this.Invoke("GetFriendsFromListByGamertag", new object[] {
                        userId,
                        friendGamertags,
                        language});
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetFriendsFromListByGamertag(System.UInt64 userId, string[] friendGamertags, System.UInt32 language, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFriendsFromListByGamertag", new object[] {
                        userId,
                        friendGamertags,
                        language}, callback, asyncState);
        }
        
        /// <remarks/>
        public Friend[] EndGetFriendsFromListByGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((Friend[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendFriendsRequest", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendFriendsRequest(System.UInt64 userId, System.UInt64 toUserId) {
            this.Invoke("SendFriendsRequest", new object[] {
                        userId,
                        toUserId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendFriendsRequest", new object[] {
                        userId,
                        toUserId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendFriendsRequest(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendFriendsRequestByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendFriendsRequestByGamertag(string user, string toUser) {
            this.Invoke("SendFriendsRequestByGamertag", new object[] {
                        user,
                        toUser});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendFriendsRequestByGamertag(string user, string toUser, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendFriendsRequestByGamertag", new object[] {
                        user,
                        toUser}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendFriendsRequestByGamertag(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AnswerFriendsRequest", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AnswerFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.UInt32 answer) {
            this.Invoke("AnswerFriendsRequest", new object[] {
                        userId,
                        toUserId,
                        answer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAnswerFriendsRequest(System.UInt64 userId, System.UInt64 toUserId, System.UInt32 answer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AnswerFriendsRequest", new object[] {
                        userId,
                        toUserId,
                        answer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAnswerFriendsRequest(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AnswerFriendsRequestByGamertag", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AnswerFriendsRequestByGamertag(string user, string toUser, System.UInt32 answer) {
            this.Invoke("AnswerFriendsRequestByGamertag", new object[] {
                        user,
                        toUser,
                        answer});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAnswerFriendsRequestByGamertag(string user, string toUser, System.UInt32 answer, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AnswerFriendsRequestByGamertag", new object[] {
                        user,
                        toUser,
                        answer}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAnswerFriendsRequestByGamertag(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RemoveFriend", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveFriend(System.UInt64 userId, System.UInt64 removeUserId) {
            this.Invoke("RemoveFriend", new object[] {
                        userId,
                        removeUserId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveFriend(System.UInt64 userId, System.UInt64 removeUserId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveFriend", new object[] {
                        userId,
                        removeUserId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveFriend(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SendGameInvite", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SendGameInvite(System.UInt32 titleId, System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds) {
            this.Invoke("SendGameInvite", new object[] {
                        titleId,
                        userId,
                        sessionId,
                        toUserIds});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendGameInvite(System.UInt32 titleId, System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendGameInvite", new object[] {
                        titleId,
                        userId,
                        sessionId,
                        toUserIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendGameInvite(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RevokeGameInvite", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RevokeGameInvite(System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds) {
            this.Invoke("RevokeGameInvite", new object[] {
                        userId,
                        sessionId,
                        toUserIds});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRevokeGameInvite(System.UInt64 userId, System.UInt64 sessionId, System.UInt64[] toUserIds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RevokeGameInvite", new object[] {
                        userId,
                        sessionId,
                        toUserIds}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRevokeGameInvite(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/SetNotificationState", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetNotificationState(System.UInt64 userId, System.UInt16 stateFlags, System.UInt64 sessionId, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] stateData) {
            this.Invoke("SetNotificationState", new object[] {
                        userId,
                        stateFlags,
                        sessionId,
                        stateData});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetNotificationState(System.UInt64 userId, System.UInt16 stateFlags, System.UInt64 sessionId, System.Byte[] stateData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetNotificationState", new object[] {
                        userId,
                        stateFlags,
                        sessionId,
                        stateData}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetNotificationState(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/AddUserToMutelist", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddUserToMutelist(System.UInt64 userId, System.UInt64 userIdToAdd) {
            this.Invoke("AddUserToMutelist", new object[] {
                        userId,
                        userIdToAdd});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddUserToMutelist(System.UInt64 userId, System.UInt64 userIdToAdd, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddUserToMutelist", new object[] {
                        userId,
                        userIdToAdd}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddUserToMutelist(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://svctunnel.xboxlive.com/Presence/RemoveUserFromMutelist", RequestNamespace="http://svctunnel.xboxlive.com/Presence/", ResponseNamespace="http://svctunnel.xboxlive.com/Presence/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RemoveUserFromMutelist(System.UInt64 userId, System.UInt64 userIdToRemove) {
            this.Invoke("RemoveUserFromMutelist", new object[] {
                        userId,
                        userIdToRemove});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveUserFromMutelist(System.UInt64 userId, System.UInt64 userIdToRemove, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveUserFromMutelist", new object[] {
                        userId,
                        userIdToRemove}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveUserFromMutelist(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://svctunnel.xboxlive.com/Presence/")]
    public class Friend {
        
        /// <remarks/>
        public System.UInt64 userId;
        
        /// <remarks/>
        public string gamertag;
        
        /// <remarks/>
        public System.UInt32 friendState;
        
        /// <remarks/>
        public System.DateTime gameinviteTime;
        
        /// <remarks/>
        public System.UInt64 sessionID;
        
        /// <remarks/>
        public System.UInt32 titleID;
        
        /// <remarks/>
        public string titleName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] StateData;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\UserMgmt.cs ===
using System;
using ServerTestFramework;
using System.IO;
using System.Xml;
using System.Text;
using System.Collections;
using System.Threading;
using Accounts;
using Presence;
using System.Windows.Forms;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService;

namespace svctunneltest
{
	/// <summary>
	/// Summary description for UserMgmt.
	/// </summary>
	public class UserMgmt
	{
		static Hashtable htPuid = new Hashtable();
		static FriendsCommon fc;
			
		static UserInfo [] accounts = new UserInfo[0];
		string fileLoc = "";
		string destAddr = "";

		static int UserCount = 100;
		static int DesiredFriendCount = 13;

		ArrayList accountCheck;

		/// <summary>
		/// The list of users created
		/// </summary>
		public UserInfo [] Users
		{
			get{return accounts;}
		}

		/// <summary>
		/// Returns the HTTP Auth data for sending to the checkers widget
		/// </summary>
		/// <param name="puid">user puid</param>
		/// <returns>auth data</returns>
		static public HTTPAuthData GetAuthData(ulong puid)
		{
			PNUser u = GetUser(puid);
			return u.GetAuthData();
		}
		/// <summary>
		/// The UserInfo object that stores the STF Owner object and the user &amp; owner puid
		/// </summary>
		#region public class UserInfo
		public class UserInfo
		{
			ServerTestFramework.LiveService.UserAccount.Owner owner;
			ulong ownerPuid;
			ulong userPuid;

			/// <summary>
			/// Constructor
			/// </summary>
			public UserInfo()
			{
				owner = new ServerTestFramework.LiveService.UserAccount.Owner("Obsolete");
				ownerPuid = 0;
				userPuid = 0;
			}

			/// <summary>
			/// The owner puid for the account
			/// </summary>
			public ulong OwnerPuid
			{
				get{return ownerPuid;}
			}
			/// <summary>
			/// The user puid for the account
			/// </summary>
			public ulong UserPuid
			{
				get{return userPuid;}
			}
			/// <summary>
			/// The STF Owner account information used to create the user
			/// </summary>
			public ServerTestFramework.LiveService.UserAccount.Owner User
			{
				get{return owner;}
			}

			/// <summary>
			/// Creates the user
			/// </summary>
			public void Create()
			{
				ownerPuid = userPuid = owner.Create();
			}

			/// <summary>
			/// Reads the user from the stream
			/// </summary>
			/// <param name="br">The BinaryReader for a stream</param>
			public void ReadStream(BinaryReader br)
			{
				ownerPuid = br.ReadUInt64();
				userPuid = br.ReadUInt64();
				owner.ReadStream(br);
			}
			/// <summary>
			/// Writes the user to a stream
			/// </summary>
			/// <param name="bw">The BinaryWriter for the stream</param>
			public void WriteStream(BinaryWriter bw)
			{
				bw.Write(ownerPuid);
				bw.Write(userPuid);
				owner.WriteStream(bw);
			}
		}
		#endregion

		/// <summary>
		/// Checks out a user for a test to prevent other tests from using the same user at the same time
		/// </summary>
		/// <returns>A UserInfo object representing the user, or null if no users are available</returns>
		#region public UserInfo CheckoutUser()
		public UserInfo CheckoutUser()
		{
			Random r = new Random();
			lock(accountCheck)
			{
				if(accountCheck.Count == 0)
					return null;

				int sel = r.Next(accountCheck.Count);
				UserInfo ui = (UserInfo) accountCheck[sel];
				accountCheck.RemoveAt(sel);
				return ui;
			}
		}
		#endregion

		/// <summary>
		/// Returns the checked out user to the pool
		/// </summary>
		/// <param name="ui">The user previously checked out</param>
		#region public void CheckinUser(UserInfo ui)
		public void CheckinUser(UserInfo ui)
		{
			lock(accountCheck)
			{
				if(ui == null)
					return;
				accountCheck.Add(ui);
			}
		}
		#endregion
        
		static bool AreFriends(PNUser A, UserInfo ui2)
		{
			if(A.UserId == ui2.UserPuid)
				return true;

			if(A.GetBuddyInfo(ui2.UserPuid) != null)
				return true;

			return false;
		}

		static PNUser GetUser(ulong puid)
		{
			UserInfo ui = (UserInfo) htPuid[puid];
			if(ui == null)
				return new PNUser("blah", puid);
			return GetUser(ui);
		}

		static PNUser GetUser(UserInfo ui)
		{
			PNUser u = PNUser.Find(ui.UserPuid);
			if(u == null)
				u = new PNUser(ui.User.gamertag, ui.UserPuid);
			if(!u.LoggedOn)
			{
				uint unused = fc.LogonUser(u);
			}
			return u;
		}

		void DumpException(System.Exception exc)
		{
			System.Diagnostics.Debug.WriteLine(exc.GetType().ToString() + ": " + exc.Message);
			System.Diagnostics.Debug.WriteLine(exc.StackTrace);
			if(exc.InnerException != null)
			{
				System.Diagnostics.Debug.IndentLevel++;
				DumpException(exc.InnerException);
				System.Diagnostics.Debug.IndentLevel--;
			}
		}

		void DeleteFriends(PNUser u, ArrayList friends, ManualResetEvent mre)
		{
			foreach(ulong f in friends)
			{
				PNUser B = GetUser(f);
				bool successful = false;
				while(!successful)
				{
					try
					{
						Widgets.Presence(u.GetAuthData()).RemoveFriend(u.UserId, f);
						PNUser.MutualWaitForDelete(u, B);
						successful = true;
					}
					catch(System.Exception exc)
					{
						ArrayList al = new ArrayList();
						al.Add(u);
						al.Add(B);
						DumpException(exc);
						RefreshUsers(al);
						try
						{
							PNUser.MutualWaitForDelete(u, B);
							successful = true;
						}
						catch
						{
						}
					}
				}
			}
		}

		void MakeFriends(PNUser A, PNUser B, ManualResetEvent mre)
		{

			bool successful = false;
			while(!successful)
			{
				try
				{
					Widgets.Presence(A.GetAuthData()).SendFriendsRequest(A.UserId, B.UserId);
					PNUser.MutualWaitForSentRequest(A, B);
					successful = true;
				}
				catch(System.Exception exc)
				{
					ArrayList al = new ArrayList();
					al.Add(A);
					al.Add(B);
					DumpException(exc);
					RefreshUsers(al);
					try
					{
						PNUser.MutualWaitForSentRequest(A, B);
						successful = true;
					}
					catch
					{
					}
				}
			}

			successful = false;
			while(!successful)
			{
				try
				{
					Widgets.Presence(B.GetAuthData()).AnswerFriendsRequest(B.UserId, A.UserId, 1);
					PNUser.MutualWaitForFullFriend(A, B);
					successful = true;
				}
				catch(System.Exception exc)
				{
					ArrayList al = new ArrayList();
					al.Add(A);
					al.Add(B);
					DumpException(exc);
					RefreshUsers(al);
					try
					{
						PNUser.MutualWaitForFullFriend(A, B);
						successful = true;
					}
					catch
					{
					}
				}
			}
		}

		static int RefreshTime = 10000;
		void RefreshUsers(ArrayList users)
		{
			foreach(PNUser u in users)
			{
				System.Diagnostics.Debug.WriteLine("Logging off user: 0x" + u.UserId.ToString("X16"));
				fc.LogoffUser(u);
			}
			System.Diagnostics.Debug.WriteLine("Sleeping 2.5 minutes to clear user data.");
			System.Threading.Thread.Sleep(RefreshTime);
			foreach(PNUser u in users)
			{
				u.ClearState();
				fc.LogonUser(u);
			}
		}

		bool CreateFriends(UserProgress bar)
		{
			Random r = new Random();
			ManualResetEvent mre = new ManualResetEvent(false);
			// First go through the friends list for each user and verify that all the users belong to this user set.
			// If not, I remove them.
			if(bar != null)
			{
				bar.pbarProgress.Maximum = accounts.Length;
				bar.pbarProgress.Value = 0;
				bar.txtTasks.Text += "Ensuring all friends are this test's users.\r\n";
				bar.txtTasks.Select(bar.txtTasks.Text.Length, 0);
			}
			// Second pass here is for finding all users with less than DesiredFriendCount friends and makes people friends.
			// First get the list of users that are short friends.
			ArrayList usersShortFriends = new ArrayList();
			ArrayList al = new ArrayList();
			foreach(UserInfo ui in accounts)
			{
				PNUser A = GetUser(ui);
				if(bar != null)
				{
					bar.pbarProgress.Value++;
				}
				if(A.BuddiesAny == 0)
					continue;

				al.Clear();
				IDictionaryEnumerator e = null;

				e = A.BuddyEnumerator;
				while(e.MoveNext())
				{
					ulong f = (ulong)e.Key;
					if(htPuid[f] == null)
					{
						al.Add(f);
					}
				}
				DeleteFriends(A, al, mre);
				al.Clear();
				e = A.BuddyEnumerator;
				while(e.MoveNext())
				{
					ulong f = (ulong)e.Key;
					if(DesiredFriendCount + 2 >= A.BuddiesAny - al.Count)
						break;
					al.Add(f);
				}
				DeleteFriends(A, al, mre);

				e = A.BuddyEnumerator;
				while(e.MoveNext())
				{
					ulong f = (ulong)e.Key;
					PNUser.BuddyInfo bi = e.Value as PNUser.BuddyInfo;
					if(bi.Status == 0)
						continue;
					PNUser B = GetUser(f);
					bool successful = false;
					while(!successful)
					{
						try
						{
							if(bi.Status == 1)
								Widgets.Presence(B.GetAuthData()).AnswerFriendsRequest(f, ui.UserPuid, 1);
							else if(bi.Status == 2)
								Widgets.Presence(A.GetAuthData()).AnswerFriendsRequest(ui.UserPuid, f, 1);
							PNUser.MutualWaitForFullFriend(A, B);
							successful = true;
						}
						catch(System.Exception exc)
						{
							al.Clear();
							al.Add(A);
							al.Add(B);
							DumpException(exc);
							RefreshUsers(al);
							try
							{
								PNUser.MutualWaitForFullFriend(A, B);
								successful = true;
							}
							catch
							{
							}
						}
					}
				}

				if(A.BuddiesAny < DesiredFriendCount)
					usersShortFriends.Add(ui);
			}

			if(bar != null && usersShortFriends.Count > 0)
			{
				bar.pbarProgress.Maximum = usersShortFriends.Count;
				bar.pbarProgress.Value = 0;
				bar.txtTasks.Text += "Ensuring all users have at least " + DesiredFriendCount.ToString() + " friends.\r\n";
				bar.txtTasks.Select(bar.txtTasks.Text.Length, 0);
			}

			while(usersShortFriends.Count > 0)
			{
				UserInfo ui = (UserInfo) usersShortFriends[0];
				PNUser A = GetUser(ui);

				// If it turns out that this user now has at least the DesiredFriendCount, I can remove it from the list.
				if(A.BuddiesAny >= DesiredFriendCount)
				{
					usersShortFriends.RemoveAt(0);
					continue;
				}

				if(bar != null)
				{
					bar.pbarProgress.Value = bar.pbarProgress.Maximum - usersShortFriends.Count;
				}

				// Get a list of friends to make
				for(int j = 1; j < usersShortFriends.Count && A.BuddiesAny < DesiredFriendCount; ++j)
				{
					UserInfo possibleNewFriend = (UserInfo) usersShortFriends[j];
					PNUser B = GetUser(possibleNewFriend);
					if(B.BuddiesAny >= DesiredFriendCount || 
						AreFriends(A, possibleNewFriend))
						continue;

					MakeFriends(A, B, mre);
				}

				// If this condition is true, it means that we are near the end of the usersShortFriends list
				// and this user is friends with all of them but is still short people to be friends with so we
				// randomly sample the user space and try to pick enough users this guy isn't already friends with
				// to top him up.  This means the average # of friends per user will be slightly higher, but I'd rather
				// a conservative estimate than an optimistic one for stress.
				while(A.BuddiesAny < DesiredFriendCount)
				{
                    int pos = r.Next(accounts.Length);
					PNUser B = GetUser(accounts[pos]);
					if(!AreFriends(A, accounts[pos]) && 
						B.BuddiesAny < DesiredFriendCount + 2)
					{
						MakeFriends(A, B, mre);
					}
				}

			}

			if(bar != null)
			{
				bar.txtTasks.Text += "Friends processing complete!\r\n";
				bar.txtTasks.Select(bar.txtTasks.Text.Length, 0);
			}

			return true;
		}


		/// <summary>
		/// Saves the current user list to a file
		/// </summary>
		/// <param name="loc">The file to save to</param>
		/// <param name="bar">The progress ui to track save progress (can be null)</param>
		#region public void Save(string loc, UserProgress bar)
		public void Save(string loc, UserProgress bar)
		{
			if(bar != null)
			{
				bar.txtTasks.Text += "Saving users.\r\n";
				bar.pbarProgress.Maximum = accounts.Length;
				bar.pbarProgress.Value = 0;
			}
			FileStream s = System.IO.File.OpenWrite(loc);
			BinaryWriter bw = new BinaryWriter(s, Encoding.UTF8);
			foreach(UserInfo ui in accounts)
			{
                ui.WriteStream(bw);
				if(bar != null)
				{
					bar.pbarProgress.Value++;
				}
			}
			bw.Close();
			s.Close();
			if(bar != null)
			{
				bar.txtTasks.Text += "Save complete.\r\n";
			}
		}
		#endregion

		/// <summary>
		/// Loads a user list from a file, creating any necessary users to top up to the desired # of users
		/// </summary>
		/// <param name="loc">Location to load from</param>
		/// <param name="bar">The progress ui to track load progress (can be null)</param>
		/// <returns>true == success, false == failed</returns>
		#region public bool Load(string loc, UserProgress bar)
		public bool Load(string loc, UserProgress bar)
		{
			ManualResetEvent mre = new ManualResetEvent(false);
			Hashtable newHash = new Hashtable();

			fc = new FriendsCommon();
			Widgets.Initialize();

			int todo = 0;
			string dstServer;
			
			try
			{
				dstServer = ServerTestFramework.Global.Env.Get("svctunnel").EPDefault.ToString();
			}
			catch
			{
				MessageBox.Show(bar, "Failed to find a svctunnel default ip address in the server list.  Loading the user configuration failed.");
				return false;
			}
			string src = loc == null ? @"c:\svctunnel userlist.bin" : loc;
			// If there is a match, nothing to do.
			if(fileLoc.ToLower() == src.ToLower() && destAddr.ToLower() == dstServer.ToLower())
				return true;

			ArrayList al = new ArrayList();
			UserInfo o = null;

			// Read the list of users from the file
			FileStream s = (!File.Exists(src)) ? null : System.IO.File.OpenRead(src);
			BinaryReader br = (s != null) ? new BinaryReader(s, Encoding.UTF8) : null;

			if(bar != null)
			{
				bar.txtTasks.Text = "";
				bar.txtTasks.Select(bar.txtTasks.Text.Length, 0);
			}

			if(br != null)
			{
				if(bar != null)
				{
					bar.txtTasks.Text += "Loading user file: " + src + "\r\n";
					bar.txtTasks.Select(bar.txtTasks.Text.Length, 0);
					todo = (int) s.Length / 204;
					if(todo > UserCount)
						todo = UserCount;
					bar.pbarProgress.Value = 0;
					bar.pbarProgress.Maximum = todo;
					bar.Show();
				}
				while(s.Position < s.Length && al.Count < UserCount)
				{
					o = new UserInfo();
					o.ReadStream(br);
					// Validate the user to make sure it exists
					try
					{
						if(newHash[o.UserPuid] == null && Widgets.Accounts(null).GetUserId(o.User.gamertag) == o.UserPuid)
						{
							PNUser u = GetUser(o);
							al.Add(o);
							newHash[o.UserPuid] = o;
						}
					}
					catch
					{
					}
					if(bar != null)
					{
						int myEye = (int) (s.Position / 204);
						bar.pbarProgress.Value = (myEye > bar.pbarProgress.Maximum) ? bar.pbarProgress.Maximum : myEye;
					}
				}
				br.Close();
				s.Close();
				if(bar != null)
				{
					bar.txtTasks.Text += "File Load Complete.  " + al.Count.ToString() + " users found.\r\n";
					bar.txtTasks.Select(bar.txtTasks.Text.Length, 0);
				}
			}
			// If there was a shortfall of users then create more
			bool UsersCreated = false;
			if(bar != null && al.Count < UserCount)
			{
				UsersCreated = true;
				bar.txtTasks.Text += "Creating " + ((int) (UserCount - al.Count)).ToString() + " users.\r\n";
				bar.txtTasks.Select(bar.txtTasks.Text.Length, 0);
				bar.pbarProgress.Value = 0;
				bar.pbarProgress.Maximum = UserCount - al.Count;
				bar.Refresh();
			}

			ushort i = (ushort) al.Count;
			DateTime dt = DateTime.Now;
			ushort c = (ushort) (dt.Hour * 3600 + dt.Minute * 60 + dt.Second);
			string tm = c.ToString("X4") + " ";
			while(al.Count < UserCount)
			{
				o = new UserInfo();
				o.User.gamertag = "BSCHK " + tm + i.ToString("X4");
				o.Create();
				mre.WaitOne(50, false);
				if(o.UserPuid != 0)
				{
					al.Add(o);
					newHash[o.UserPuid] = o;
					if(bar != null)
					{
						bar.pbarProgress.Value++;
					}
					PNUser u = GetUser(o);
				}
				++i;
			}

			if(bar != null && UsersCreated)
			{
				bar.txtTasks.Text += "Account creation complete.\r\n";
				bar.txtTasks.Select(bar.txtTasks.Text.Length, 0);
			}

			accounts = (UserInfo []) al.ToArray(typeof(UserInfo));
			accountCheck = al;

			if(UsersCreated)
			{
				Save(src, bar);
			}
			htPuid = newHash;

			if(!CreateFriends(bar))
			{
			}

			if(bar != null)
			{
				bar.Refresh();
				mre.WaitOne(750, false);
				bar.Hide();
			}

			return true;
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\HealthURLs.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using System.Data.SqlClient;

namespace SysCheckTest
{
    public class HealthURLs
    {
        const string sqlHealthSelect =
                "SELECT DISTINCT TI.[vc_protocol] ,TS.[vc_server] ,TI.[i_port] ,TI.[vc_vdir] " +
                "FROM [npdb].[dbo].[t_servers] AS TS " +
                    "LEFT OUTER JOIN [npdb].[dbo].[t_server_interfaces] AS TT " +
                    "ON TS.[vc_server] = TT.[vc_server] " +
                    "INNER JOIN [npdb].[dbo].[t_interfaces] AS TI " +
                    "ON TT.[vc_interface] = TI.[vc_interface] " +
                "WHERE TS.[vc_server_state] = \'online\' " +
                    "AND TI.[i_port] IS NOT NULL " +
                    "AND TI.[vc_vdir] IS NOT NULL " +
                    "AND TS.[vc_environment] = \'{0}\' " +
                "ORDER BY TI.[vc_vdir], TS.[vc_server], TI.[i_port] ";
        static string [] invalidHealthInterfaces = { "XTOU", "xcbk", "authsg", "xcrypto" };
        static List<string> invalidHealthList = new List<string>(invalidHealthInterfaces);


        protected static Report _report = new Report("LiveStatsTest");

        public static string[] GetURLs()
        {
            return GetURLs(false, "");
        }

        public static string[] GetURLs(bool useDep, string depVal)
        {
            SqlDataReader sqlReader;
            string sqlHealthURLQuery;
            List<string> healthURLList = new List<string>();
            string protocol, server, vdir;
            uint port;

            sqlHealthURLQuery = string.Format(sqlHealthSelect, Config.Environment);
            _report.Debug("Health URL Query:\n{0}", sqlHealthURLQuery);

            Npdb npdb = new Npdb();
            npdb.ConnectToServer();

            try
            {
                npdb.ReadData(sqlHealthURLQuery, out sqlReader);
                try
                {
                    string tempURL;
                    while (sqlReader.Read())
                    {
                        protocol = sqlReader.GetString(sqlReader.GetOrdinal("vc_protocol"));
                        server = sqlReader.GetString(sqlReader.GetOrdinal("vc_server"));
                        port = (uint)sqlReader.GetInt32(sqlReader.GetOrdinal("i_port"));
                        vdir = sqlReader.GetString(sqlReader.GetOrdinal("vc_vdir"));
                        tempURL = string.Format("{0}://{1}:{2}/{3}/health.ashx", protocol, server, port, vdir);
                        if (useDep == true)
                        {
                            tempURL = string.Concat(tempURL, "?dep=" + depVal);
                        }
                        if (invalidHealthList.Contains(vdir))
                        {
                            // This is one of our invalid health urls so skip it and don't add to the array
                            _report.Debug("Skipping {0}", tempURL);
                        }
                        else
                        {
                            healthURLList.Add(tempURL);
                            //_report.Debug("Adding {0}", tempURL);
                        }
                    }
                }
                finally
                {
                    if (sqlReader != null)
                    {
                        sqlReader.Close();
                    }
                }
            }
            catch (DatabaseException de)
            {
                _report.Error("Error Reading Health URL Data from server. Error: " + de.ToString());
            }
            finally
            {
                npdb.Close();
            }

            string[] output = healthURLList.ToArray();
            return output;
        }

        public static void CreateSystemCheckInputFile(string [] healthurlList, string fileName)
        {
            if (null == fileName)
            {
                throw new ArgumentException(fileName);
            }

            using(StreamWriter scw = new StreamWriter(fileName))
            {
                foreach(string url in healthurlList)
                {
                    scw.WriteLine(url);
                }
            }
        }

        public static void CreateSystemCheckInputFile(string[] healthurlList, int urlCount, string fileName)
        {
            if (null == fileName)
            {
                throw new ArgumentException(fileName);
            }

            if (healthurlList.Length == 0)
            {
                // Create an empty file and return since 0 will break the division below
                using (StreamWriter scw = new StreamWriter(fileName))
                {
                    scw.Write("");
                }
                return;
            }

            using (StreamWriter scw = new StreamWriter(fileName))
            {
                int loopVar = 0;
                int fullLoops, loopRemainder;
                fullLoops = Math.DivRem(urlCount, healthurlList.Length, out loopRemainder);

                // If we need more than a full list, run the normal list multiple times
                if (urlCount > healthurlList.Length)
                {
                    for (loopVar = 0; loopVar < fullLoops; ++loopVar)
                    {
                        foreach (string url in healthurlList)
                        {
                            scw.WriteLine(url);
                        }
                    }
                }

                for (loopVar = 0; loopVar < loopRemainder; ++loopVar)
                {
                    scw.WriteLine(healthurlList.GetValue(loopVar));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\Positive.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;

namespace SysCheckTest
{
    /// <summary>
    /// Test group for running SystemCheck.
    /// Includes the following test cases:
    /// DefaultRun - Run SystemCheck with an input file containing every HealthCheck url with basic return information 
    /// DefaultMin - Run SystemCheck with an input file containing every HealthCheck url with minimum dependency information 
    /// DefaultMax - Run SystemCheck with an input file containing every HealthCheck url with all dependency information 
    /// Reloadfd - Run SystemCheck with the /reloadfd parameter 
    /// </summary>
    [TestGroup, Owner("TrevorM"), Description("Positive Test Cases for SystemCheck"), TestFrequency("Regression"), EnvRequirement("")]
    public class PositiveCases : TestNode
    {
        /// <summary>
        /// Basic health url test case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// DefaultRun - Run SystemCheck with an input file containing every HealthCheck url with basic return information 
        /// </remarks>
        [TestCase, DVT, Owner("TrevorM"), Description("Run SystemCheck with an input file containing every HealthCheck url with basic return information"), TestFrequency("Regression"), EnvRequirement("")]
        public class DefaultRun : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("DefaultRun");

                string inputFile = "DefaultRun" + "In.txt";
                string outputFile = "DefaultRun" + "Out.xml";
                ClearTempDirectory("DefaultRun");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl();

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }

        /// <summary>
        /// Basic health min url test case.
        /// </summary>
        /// <remarks>
        /// DEPRICATED
        /// Implemented Cases:
        /// DefaultMin - Run SystemCheck with an input file containing every HealthCheck url with minimum dependency information 
        /// </remarks>
        /*[TestCase, DVT, Owner("TrevorM"), Description("Run SystemCheck with an input file containing every HealthCheck url with minimum dependency information"), TestFrequency("Regression"), EnvRequirement("")]
        public class DefaultMin : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("DefaultMin");

                string inputFile = "DefaultMin" + "In.txt";
                string outputFile = "DefaultMin" + "Out.xml";
                ClearTempDirectory("DefaultMin");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs(true, "min");

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl((uint)healthURLs.Length, 180000);

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }*/

        /// <summary>
        /// Basic health max url test case.
        /// </summary>
        /// <remarks>
        /// DEPRICATED
        /// Implemented Cases:
        /// DefaultMax - Run SystemCheck with an input file containing every HealthCheck url with all dependency information 
        /// </remarks>
        /*[TestCase, DVT, Owner("TrevorM"), Description("Run SystemCheck with an input file containing every HealthCheck url with all dependency information"), TestFrequency("Regression"), EnvRequirement("")]
        public class DefaultMax : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("DefaultMax");

                string inputFile = "DefaultMax" + "In.txt";
                string outputFile = "DefaultMax" + "Out.xml";
                ClearTempDirectory("DefaultMax");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs(true, "max");

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                int oldTimeout = _sysCheckTool.Timeout;
                _sysCheckTool.Timeout = 600; // Set the timeout to 10 min. 60 * 10
                _sysCheckTool.CallUrl((uint)healthURLs.Length, 300000);
                _sysCheckTool.Timeout = oldTimeout;

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }*/

        /// <summary>
        /// Basic reloadfd test case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Reloadfd - Run SystemCheck with the /reloadfd parameter 
        /// </remarks>
        [TestCase, DVT, Owner("TrevorM"), Description("Run SystemCheck with the /reloadfd parameter"), TestFrequency("Regression"), EnvRequirement("")]
        public class ReloadFd : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("ReloadFd");
                ResultCode = TEST_RESULTS.PASSED;

                // Run SystemCheck
                int oldTimeout = _sysCheckTool.Timeout;
                _sysCheckTool.Timeout = 300; // Set the timeout to 5 min. 60 * 5
                _sysCheckTool.Reloadfd();
                _sysCheckTool.Timeout = oldTimeout;

                // Verify Output
                if (_sysCheckTool.Output.IndexOf("fail", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    _report.Error("SystemCheck failed to reload the front doors:\n{0}", _sysCheckTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\Boundary.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;

namespace SysCheckTest
{
    /// <summary>
    /// Test group for running SystemCheck.
    /// Includes the following test cases:
    /// EmptyList - Runs SystemCheck with an empty configfile
    /// ThreadMin - Runs SystemCheck with 1 Thread
    /// ThreadMax - Runs SystemCheck with #MaxThreads# (currently 32767 since the system can't support 2 billion)
    /// ThreadOverMax - Runs SystemCheck with Int32.MaxValue + 1
    /// TimeoutMin - Runs SystemCheck with 1 Timeout
    /// TimeoutMax - Runs SystemCheck with Int32.MaxValue
    /// TimeoutOverMax - Runs SystemCheck with Int32.MaxValue + 1
    /// TimeoutZero - Runs SystemCheck with 0 Timeout
    /// TimeoutNegative - Runs SystemCheck with -1 Timeout
    /// 
    /// Test Cases Not Implemented:
    /// ThreadZero - Runs SystemCheck with 0 Threads (Currently commented out due to bug #87047)
    /// ThreadNegative - Runs SystemCheck with -1 Threads (Currently commented out because the error creates a debug popup)
    /// </summary>
    [TestGroup, Owner("TrevorM"), Description("Boundary Test Cases for SystemCheck"), TestFrequency("Regression"), EnvRequirement("")]
    public class BoundaryCases : TestNode
    {
        protected static uint MaxThreads = (uint) Int16.MaxValue;
        protected static uint MaxTimeout = (uint) Int32.MaxValue;

        /// <summary>
        /// Runs SystemCheck with an empty configfile.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// EmptyList - Runs SystemCheck with an empty configfile
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with an empty configfile"), TestFrequency("Regression"), EnvRequirement("")]
        public class EmptyList : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("EmptyList");

                string inputFile = "EmptyList" + "In.txt";
                string outputFile = "EmptyList" + "Out.xml";
                ClearTempDirectory("EmptyList");

                // Query the npdb for the full list of health urls
                string[] healthURLs = new string [0];

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 0, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl(1, DefaultTimeout);

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }

        /// <summary>
        /// Runs SystemCheck with 1 Thread.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// ThreadMin - Runs SystemCheck with 1 Thread
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with 1 Thread"), TestFrequency("Regression"), EnvRequirement("")]
        public class ThreadMin : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("ThreadMin");

                string inputFile = "ThreadMin" + "In.txt";
                string outputFile = "ThreadMin" + "Out.xml";
                ClearTempDirectory("ThreadMin");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl(1, DefaultTimeout);

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }

        /// <summary>
        /// Runs SystemCheck with zero threads (commented out since systemcheck runs indefinately)
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// ThreadMax - Runs SystemCheck with zero threads
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with zero threads"), TestFrequency("Regression"), EnvRequirement("")]
        public class ThreadZero : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("ThreadZero");

                string inputFile = "ThreadZero" + "In.txt";
                string outputFile = "ThreadZero" + "Out.xml";
                ClearTempDirectory("ThreadZero");
                ResultCode = TEST_RESULTS.FAILED;

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                try
                {
                    _sysCheckTool.CallUrl(0, DefaultTimeout);
                }
                catch (SystemCheckException)
                {
                    // SystemCheck should return an error when 0 is passed in for threads, currently it runs indefinately
                    ResultCode = TEST_RESULTS.PASSED;
                }
                catch (ServerTestFramework.Utilities.ProcessException)
                {
                    // Exectute timed out waiting for systemcheck to finish
                    _report.Warn("SystemCheck timed out during execution Bug #87047");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        /// <summary>
        /// Runs SystemCheck with the maximum number of threads (reduced since the system can't support 2 billion threads).
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// ThreadMax - Runs SystemCheck with #MaxThreads#
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with #MaxThreads#"), TestFrequency("Regression"), EnvRequirement("")]
        public class ThreadMax : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("ThreadMax");

                string inputFile = "ThreadMax" + "In.txt";
                string outputFile = "ThreadMax" + "Out.xml";
                ClearTempDirectory("ThreadMax");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                // Int32.MaxValue is the max that systemcheck will support, however, the system will run out of 
                // resources long before 2 billion threads.
                _sysCheckTool.CallUrl(MaxThreads, DefaultTimeout);

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }

        /// <summary>
        /// Runs SystemCheck with max + 1.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Runs SystemCheck with Int32.MaxValue + 1
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with Int32.MaxValue + 1"), TestFrequency("Regression"), EnvRequirement("")]
        public class ThreadOverMax : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("ThreadOverMax");

                string inputFile = "ThreadOverMax" + "In.txt";
                string outputFile = "ThreadOverMax" + "Out.xml";
                ClearTempDirectory("ThreadOverMax");
                ResultCode = TEST_RESULTS.FAILED;

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    // Int32.MaxValue is the max that systemcheck will support
                    _sysCheckTool.CallUrl((uint)Int32.MaxValue + 1, DefaultTimeout);
                }
                catch (SystemCheckException sysEx)
                {
                    if (sysEx.ToString().IndexOf("System.OverflowException", StringComparison.CurrentCultureIgnoreCase) > -1)
                    {
                        // SystemCheck should fail with a System.OverflowException
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        /// <summary>
        /// Runs SystemCheck with -1 Threads
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Runs SystemCheck with -1 Threads
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with -1 Threads"), TestFrequency("Regression"), EnvRequirement("")]
        public class ThreadNegative : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("ThreadNegative");

                string inputFile = "ThreadNegative" + "In.txt";
                string outputFile = "ThreadNegative" + "Out.xml";
                ClearTempDirectory("ThreadNegative");
                ResultCode = TEST_RESULTS.FAILED;

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    // SystemCheck parses input as a signed int with no negative verification.
                    _sysCheckTool.CallUrl("-1", DefaultTimeout.ToString());
                }
                catch (SystemCheckException)
                {
                    // SystemCheck should fail with a System.OverflowException
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// <summary>
        /// Runs SystemCheck with a Timeout of 1ms.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Runs SystemCheck with 1ms Timeout
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with 1ms Timeout"), TestFrequency("Regression"), EnvRequirement("")]
        public class TimeoutMin : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("TimeoutMin");

                string inputFile = "TimeoutMin" + "In.txt";
                string outputFile = "TimeoutMin" + "Out.xml";
                ClearTempDirectory("TimeoutMin");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl(5, 1);

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }

        /// <summary>
        /// Runs SystemCheck with a Timeout of 0ms.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Runs SystemCheck with 0 Timeout
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with 0 Timeout"), TestFrequency("Regression"), EnvRequirement("")]
        public class TimeoutZero : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("TimeoutZero");

                string inputFile = "TimeoutZero" + "In.txt";
                string outputFile = "TimeoutZero" + "Out.xml";
                ClearTempDirectory("TimeoutZero");
                ResultCode = TEST_RESULTS.FAILED;

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl(5, 0);

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
                if (ResultCode == TEST_RESULTS.FAILED)
                {
                    // with a timeout of zero, it should have returned Error instead of OK
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// <summary>
        /// Runs SystemCheck with the max Timeout.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Runs SystemCheck with Timeout Int32.MaxValue
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with Timeout Int32.MaxValue"), TestFrequency("Regression"), EnvRequirement("")]
        public class TimeoutMax : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("TimeoutMax");

                string inputFile = "TimeoutMax" + "In.txt";
                string outputFile = "TimeoutMax" + "Out.xml";
                ClearTempDirectory("TimeoutMax");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                // Int32.MaxValue is the max that systemcheck will support, however, the system will run out of 
                // resources long before 2 billion Timeouts.
                _sysCheckTool.CallUrl(5, MaxTimeout);

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }

        /// <summary>
        /// Runs SystemCheck with max + 1 Timeout.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Runs SystemCheck with Int32.MaxValue + 1 Timeout
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with Int32.MaxValue + 1 Timeout"), TestFrequency("Regression"), EnvRequirement("")]
        public class TimeoutOverMax : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("TimeoutOverMax");

                string inputFile = "TimeoutOverMax" + "In.txt";
                string outputFile = "TimeoutOverMax" + "Out.xml";
                ClearTempDirectory("TimeoutOverMax");
                ResultCode = TEST_RESULTS.FAILED;

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    // Int32.MaxValue is the max that systemcheck will support
                    _sysCheckTool.CallUrl(5, (uint)Int32.MaxValue + 1);
                }
                catch (SystemCheckException sysEx)
                {
                    if (sysEx.ToString().IndexOf("System.OverflowException", StringComparison.CurrentCultureIgnoreCase) > -1)
                    {
                        // SystemCheck should fail with a System.OverflowException
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        /// <summary>
        /// Runs SystemCheck with a negative Timeout.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Runs SystemCheck with -1 Timeout
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Runs SystemCheck with -1 Timeout"), TestFrequency("Regression"), EnvRequirement("")]
        public class TimeoutNegative : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("TimeoutNegative");

                string inputFile = "TimeoutNegative" + "In.txt";
                string outputFile = "TimeoutNegative" + "Out.xml";
                ClearTempDirectory("TimeoutNegative");
                ResultCode = TEST_RESULTS.FAILED;

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 5, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    // SystemCheck parses input as a signed int with no negative verification.
                    _sysCheckTool.CallUrl("5", "-1");
                    // Verify Output
                    ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
                }
                catch (SystemCheckException sysEx)
                {
                    // SystemCheck should fail with a System.OverflowException
                    _report.Warn(sysEx.ToString());
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\Negative.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;

namespace SysCheckTest
{
    /// <summary>
    /// Test group for running SystemCheck.
    /// Includes the following test cases:
    /// MissingURLName - Run SystemCheck against a health url with the health.ashx removed 
    /// MissingPath - Run SystemCheck against a health url with the health.ashx and path removed 
    /// MissingPort - Run SystemCheck against a health url with the Port removed 
    /// Localhost - Run SystemCheck against http://localhost/ 
    /// InvalidThread Text - Run SystemCheck with invalid text passed to /thread 
    /// InvalidTimeout Text - Run SystemCheck with invalid text passed to /timeout 
    /// MissingOutput File - Run SystemCheck with the /outfile parameter but no file specified.
    /// 
    /// Cases not implemented:
    /// InvalidInput File - Run SystemCheck with a file that doesn't exist. (Commented Out in automation) 
    /// MissingInput File - Run SystemCheck with the /configfile parameter but no file specified. (Commented Out in automation) 
    /// </summary>
    [TestGroup, Owner("TrevorM"), Description("Negative Test Cases for SystemCheck"), TestFrequency("Regression"), EnvRequirement("")]
    public class NegativeCases : TestNode
    {
        /// <summary>
        /// Negative address case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// MissingURLName - Run SystemCheck against a health url with the health.ashx removed 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck against a health url with the health.ashx removed"), TestFrequency("Regression"), EnvRequirement("")]
        public class MissingURLName : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("MissingURLName");

                string inputFile = "MissingURLName" + "In.txt";
                string outputFile = "MissingURLName" + "Out.xml";
                ClearTempDirectory("MissingURLName");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Modify the first URL to remove the health.ashx
                healthURLs[0] = healthURLs[0].Substring(0, healthURLs[0].LastIndexOf("/")+1);
                _report.Debug("Querying: {0}", healthURLs[0]);

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 1, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl();

                try
                {
                    // Verify Output
                    ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
                }
                catch (System.InvalidOperationException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// <summary>
        /// Negative address case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// MissingPath - Run SystemCheck against a health url with the health.ashx and path removed 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck against a health url with the health.ashx and path removed"), TestFrequency("Regression"), EnvRequirement("")]
        public class MissingPath : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("MissingPath");

                string inputFile = "MissingPath" + "In.txt";
                string outputFile = "MissingPath" + "Out.xml";
                ClearTempDirectory("MissingPath");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Modify the first URL to remove the health.ashx
                healthURLs[0] = healthURLs[0].Substring(0, healthURLs[0].LastIndexOf("/"));
                healthURLs[0] = healthURLs[0].Substring(0, healthURLs[0].LastIndexOf("/") + 1);
                _report.Debug("Querying: {0}", healthURLs[0]);

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 1, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl();

                try
                {
                    // Verify Output
                    ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
                }
                catch (System.InvalidOperationException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// <summary>
        /// Negative address case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// MissingPort - Run SystemCheck against a health url with the Port removed 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck against a health url with the Port removed"), TestFrequency("Regression"), EnvRequirement("")]
        public class MissingPort : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("MissingPort");

                string inputFile = "MissingPort" + "In.txt";
                string outputFile = "MissingPort" + "Out.xml";
                ClearTempDirectory("MissingPort");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Modify the first URL to remove the health.ashx
                healthURLs[0] = healthURLs[0].Substring(0, healthURLs[0].LastIndexOf(":")) + "/";
                _report.Debug("Querying: {0}", healthURLs[0]);

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 1, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl();

                try
                {
                    // Verify Output
                    ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
                }
                catch (System.InvalidOperationException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// <summary>
        /// Negative address case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// Localhost - Run SystemCheck against http://localhost/ 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck against http://localhost/"), TestFrequency("Regression"), EnvRequirement("")]
        public class LocalHost : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("LocalHost");

                string inputFile = "LocalHost" + "In.txt";
                string outputFile = "LocalHost" + "Out.xml";
                ClearTempDirectory("LocalHost");

                // Create a file with just http://localhost/
                string[] healthURLs = new string[1];
                healthURLs[0] = "http://localhost/";
                _report.Debug("Querying: {0}", healthURLs[0]);

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 1, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                _sysCheckTool.CallUrl();

                try
                {
                    // Verify Output
                    ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
                }
                catch (System.InvalidOperationException)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        /// <summary>
        /// Negative parameter test case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// InvalidThread Text - Run SystemCheck with invalid text passed to /thread 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck with invalid text passed to /thread"), TestFrequency("Regression"), EnvRequirement("")]
        public class InvalidThreadText : SysCheckTestBase
        {
            protected override void Execute()
            {
                string thread = "";
                BeginCase("InvalidThreadText");

                string inputFile = "InvalidThreadText" + "In.txt";
                string outputFile = "InvalidThreadText" + "Out.xml";
                ClearTempDirectory("InvalidThreadText");
                ResultCode = TEST_RESULTS.PASSED;

                // Create a file with just http://localhost/
                string[] healthURLs = new string[1];
                healthURLs[0] = "http://localhost/";
                _report.Debug("Querying: {0}", healthURLs[0]);

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 1, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    thread = "aaaa";
                    _sysCheckTool.CallUrl(thread, DefaultTimeout.ToString());
                    _report.Error("SystemCheck /thread:{0} succeeded when it should have failed.\n{1}", thread, _sysCheckTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (SystemCheckException sysEx)
                {
                    // SystemCheck should fail with a System.OverflowException
                    if (sysEx.ToString().IndexOf("System.FormatException", StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Warn("SystemCheck /thread:{0} failed with an incorrect error.\n{1}", thread, _sysCheckTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                try
                {
                    thread = "*!@#$%&";
                    _sysCheckTool.CallUrl(thread, DefaultTimeout.ToString());
                    _report.Error("SystemCheck /thread:{0} succeeded when it should have failed.\n{1}", thread, _sysCheckTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (SystemCheckException sysEx)
                {
                    // SystemCheck should fail with a System.OverflowException
                    if (sysEx.ToString().IndexOf("System.FormatException", StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Warn("SystemCheck /thread:{0} failed with an incorrect error.\n{1}", thread, _sysCheckTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                try
                {
                    thread = "abc123";
                    _sysCheckTool.CallUrl(thread, DefaultTimeout.ToString());
                    _report.Error("SystemCheck /thread:{0} succeeded when it should have failed.\n{1}", thread, _sysCheckTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (SystemCheckException sysEx)
                {
                    // SystemCheck should fail with a System.OverflowException
                    if (sysEx.ToString().IndexOf("System.FormatException", StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Warn("SystemCheck /thread:{0} failed with an incorrect error.\n{1}", thread, _sysCheckTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
            }
        }

        /// <summary>
        /// Negative parameter test case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// InvalidTimeout Text - Run SystemCheck with invalid text passed to /timeout 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck with invalid text passed to /timeout"), TestFrequency("Regression"), EnvRequirement("")]
        public class InvalidTimeoutText : SysCheckTestBase
        {
            protected override void Execute()
            {
                string timeout = "";
                BeginCase("InvalidTimeoutText");

                string inputFile = "InvalidTimeoutText" + "In.txt";
                string outputFile = "InvalidTimeoutText" + "Out.xml";
                ClearTempDirectory("InvalidTimeoutText");
                ResultCode = TEST_RESULTS.PASSED;

                // Create a file with just http://localhost/
                string[] healthURLs = new string[1];
                healthURLs[0] = "http://localhost/";
                _report.Debug("Querying: {0}", healthURLs[0]);

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 1, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    timeout = "aaaa";
                    _sysCheckTool.CallUrl("1", timeout);
                    _report.Error("SystemCheck /timeout:{0} succeeded when it should have failed\n{1}", timeout, _sysCheckTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (SystemCheckException sysEx)
                {
                    // SystemCheck should fail with a System.FormatException
                    if (sysEx.ToString().IndexOf("System.FormatException", StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Warn("SystemCheck /timeout:{0} failed with an incorrect error\n{1}", timeout, _sysCheckTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                try
                {
                    timeout = "*!@#$%&";
                    _sysCheckTool.CallUrl("1", timeout);
                    _report.Error("SystemCheck /timeout:{0} succeeded when it should have failed\n{1}", timeout, _sysCheckTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (SystemCheckException sysEx)
                {
                    // SystemCheck should fail with a System.FormatException
                    if (sysEx.ToString().IndexOf("System.FormatException", StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Warn("SystemCheck /timeout:{0} failed with an incorrect error\n{1}", timeout, _sysCheckTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                try
                {
                    timeout = "abc123";
                    _sysCheckTool.CallUrl("1", timeout);
                    _report.Error("SystemCheck /timeout:{0} succeeded when it should have failed\n{1}", timeout, _sysCheckTool.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }
                catch (SystemCheckException sysEx)
                {
                    // SystemCheck should fail with a System.FormatException
                    if (sysEx.ToString().IndexOf("System.FormatException", StringComparison.CurrentCultureIgnoreCase) < 0)
                    {
                        _report.Warn("SystemCheck /timeout:{0} failed with an incorrect error\n{1}", timeout, _sysCheckTool.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

            }
        }

        /// <summary>
        /// Negative parameter test case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// InvalidInput File - Run SystemCheck with a file that doesn't exist. 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck with a file that doesn't exist."), TestFrequency("Regression"), EnvRequirement("")]
        public class InvalidFileName : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("InvalidFileName");

                string inputFile = "InvalidFileName" + "In.txt";
                string outputFile = "InvalidFileName" + "Out.xml";
                ClearTempDirectory("InvalidFileName");
                ResultCode = TEST_RESULTS.FAILED;

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    _sysCheckTool.CallUrl();
                }
                catch (SystemCheckException sysEx)
                {
                    if (sysEx.ToString().IndexOf("System.IO.FileNotFoundException", StringComparison.CurrentCultureIgnoreCase) > -1)
                    {
                        // SystemCheck should fail with a System.IO.FileNotFoundException
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        /// <summary>
        /// Negative parameter test case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// MissingInput File - Run SystemCheck with the /configfile parameter but no file specified. 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck with the /configfile parameter but no file specified."), TestFrequency("Regression"), EnvRequirement("")]
        public class MissingInputFile : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("MissingInputFile");

                string inputFile = "";
                string outputFile = "MissingInputFile" + "Out.xml";
                ClearTempDirectory("MissingInputFile");
                ResultCode = TEST_RESULTS.FAILED;

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    _sysCheckTool.CallUrl();
                }
                catch (SystemCheckException sysEx)
                {
                    if (sysEx.ToString().IndexOf("System.UnauthorizedAccessException", StringComparison.CurrentCultureIgnoreCase) > -1)
                    {
                        // SystemCheck should fail with a System.UnauthorizedAccessException
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }

        /// <summary>
        /// Negative parameter test case.
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// MissingOutput File - Run SystemCheck with the /outfile parameter but no file specified. 
        /// </remarks>
        [TestCase, Owner("TrevorM"), Description("Run SystemCheck with the /outfile parameter but no file specified."), TestFrequency("Regression"), EnvRequirement("")]
        public class MissingOutputFile : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("MissingOutputFile");

                string inputFile = "MissingOutputFile" + "In.xml";
                string outputFile = " ";
                ClearTempDirectory("MissingOutputFile");
                ResultCode = TEST_RESULTS.FAILED;

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, 1, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);

                try
                {
                    _sysCheckTool.CallUrl();
                }
                catch (SystemCheckException sysEx)
                {
                    if (sysEx.ToString().IndexOf("System.IO.DirectoryNotFoundException", StringComparison.CurrentCultureIgnoreCase) > -1)
                    {
                        // SystemCheck should fail with a System.OverflowException
                        ResultCode = TEST_RESULTS.PASSED;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\UserProgress.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace svctunneltest
{
	/// <summary>
	/// Summary description for UserProgress.
	/// </summary>
	public class UserProgress : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Label label1;
		/// <summary>
		/// Lists the currently active tasks
		/// </summary>
		public System.Windows.Forms.TextBox txtTasks;
		/// <summary>
		/// The current progress on the current task
		/// </summary>
		public System.Windows.Forms.ProgressBar pbarProgress;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		/// <summary>
		/// Constructor
		/// </summary>
		public UserProgress()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.pbarProgress = new System.Windows.Forms.ProgressBar();
			this.label1 = new System.Windows.Forms.Label();
			this.txtTasks = new System.Windows.Forms.TextBox();
			this.SuspendLayout();
			// 
			// pbarProgress
			// 
			this.pbarProgress.Location = new System.Drawing.Point(56, 8);
			this.pbarProgress.Name = "pbarProgress";
			this.pbarProgress.Size = new System.Drawing.Size(264, 16);
			this.pbarProgress.TabIndex = 0;
			// 
			// label1
			// 
			this.label1.AutoSize = true;
			this.label1.Location = new System.Drawing.Point(0, 8);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(53, 16);
			this.label1.TabIndex = 1;
			this.label1.Text = "Progress:";
			this.label1.TextAlign = System.Drawing.ContentAlignment.TopRight;
			// 
			// txtTasks
			// 
			this.txtTasks.BackColor = System.Drawing.Color.White;
			this.txtTasks.Location = new System.Drawing.Point(8, 32);
			this.txtTasks.Multiline = true;
			this.txtTasks.Name = "txtTasks";
			this.txtTasks.ReadOnly = true;
			this.txtTasks.ScrollBars = System.Windows.Forms.ScrollBars.Vertical;
			this.txtTasks.Size = new System.Drawing.Size(312, 56);
			this.txtTasks.TabIndex = 2;
			this.txtTasks.Text = "";
			// 
			// UserProgress
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(328, 93);
			this.Controls.Add(this.txtTasks);
			this.Controls.Add(this.label1);
			this.Controls.Add(this.pbarProgress);
			this.Name = "UserProgress";
			this.Text = "User Load & Creation Progress";
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\SysCheckTest.cs ===
using System;
using ServerTestFramework;

namespace SysCheckTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\Stress.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;

namespace SysCheckTest
{
    /// <summary>
    /// Test group for running SystemCheck.
    /// Includes the following test cases:
    /// FullListStress - Run SystemCheck with the complete list of HealthCheck URL's and loop the list to create a verly long list
    /// SingleURLStress - Run SystemCheck with a single HealthCheck URL and list the url many times to create a verly long list
    /// </summary>
    [TestGroup, Owner("TrevorM"), Description("Stress Test Cases for SystemCheck"), TestFrequency("Regression"), EnvRequirement("Stress")]
    public class StressCases : TestNode
    {
        const int StressURLCount = 5000;

        /// <summary>
        /// Stress health url test case using the full list of health URLs
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// </remarks>
        [TestCase, StressTest, Owner("TrevorM"), Description("Creates a very long list of URLs to call using SystemCheck"), TestFrequency("Regression"), EnvRequirement("Stress")]
        public class FullListStress : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("FullListStress");

                string inputFile = "FullListStress" + "In.txt";
                string outputFile = "FullListStress" + "Out.xml";
                ClearTempDirectory("FullListStress");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(healthURLs, StressURLCount, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                int oldTimeout = _sysCheckTool.Timeout;
                _sysCheckTool.Timeout = 600; // Set the timeout to 10 min. 60 * 10
                _sysCheckTool.CallUrl(100, 180000);
                _sysCheckTool.Timeout = oldTimeout;

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, Path.Combine(_tempPath, outputFile));
            }
        }

        /// <summary>
        /// Stress health url test case using one health URL
        /// </summary>
        /// <remarks>
        /// Implemented Cases:
        /// 
        /// </remarks>
        [TestCase, StressTest, Owner("TrevorM"), Description("Creates a very long list of one URLs to call using SystemCheck"), TestFrequency("Regression"), EnvRequirement("Stress")]
        public class SingleURLStress : SysCheckTestBase
        {
            protected override void Execute()
            {
                BeginCase("SingleURLStress");

                string inputFile = "SingleURLStress" + "In.txt";
                string outputFile = "SingleURLStress" + "Out.xml";
                ClearTempDirectory("SingleURLStress");

                // Query the npdb for the full list of health urls
                string[] healthURLs = HealthURLs.GetURLs();
                string[] stressURLs = new string[1];
                stressURLs[0] = healthURLs[0];

                // Create the text file from the list of urls
                HealthURLs.CreateSystemCheckInputFile(stressURLs, StressURLCount, Path.Combine(_tempPath, inputFile));

                // Run SystemCheck
                _sysCheckTool.ConfigFilePath = Path.Combine(_tempPath, inputFile);
                _sysCheckTool.OutFilePath = Path.Combine(_tempPath, outputFile);
                int oldTimeout = _sysCheckTool.Timeout;
                _sysCheckTool.Timeout = 600; // Set the timeout to 10 min. 60 * 10
                _sysCheckTool.CallUrl(100, 180000);
                _sysCheckTool.Timeout = oldTimeout;

                // Verify Output
                ResultCode = SystemCheckVerifier.VerifyValidHealthURLs(stressURLs, Path.Combine(_tempPath, outputFile));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\svctunneltest\Widgets.cs ===
using System;
using ServerTestFramework.LiveService;
using ServerTestFramework;
using System.Web.Services;
using System.Web;
using System.Net;
using System.Web.Services.Protocols;

namespace svctunneltest
{
	/// <summary>
	/// Summary description for Widgets.
	/// </summary>
	class Widgets
	{
		static LiveServer dstServer = null;
		#region class AccountOverride : Accounts.Accounts
		class AccountOverride : Accounts.Accounts
		{
			HTTPAuthData a = null;
			protected AccountOverride()
			{
			}

			public AccountOverride(LiveServer ls, HTTPAuthData auth)
			{
				Url = "http://" + ls.EPDefault.ToString() + "/svctunnel/accounts.asmx";
				a = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(a != null)
					hwr.Headers.Add(HTTPAuthData.HTTP_HEADER_AUTH_DATA, a.GetBase64EncodedString());
				return hwr;
			}
		}
		#endregion

		#region class PresenceOverride : Presence.Presence
		class PresenceOverride : Presence.Presence
		{
			HTTPAuthData a = null;
			protected PresenceOverride()
			{
			}

			public PresenceOverride(LiveServer ls, HTTPAuthData auth)
			{
				Url = "http://" + ls.EPDefault.ToString() + "/svctunnel/presence.asmx";
				a = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(a != null)
					hwr.Headers.Add(HTTPAuthData.HTTP_HEADER_AUTH_DATA, a.GetBase64EncodedString());
				return hwr;
			}
		}
		#endregion

		#region class HealthOverride : Health.Health
		class HealthOverride : Health.Health
		{
			HTTPAuthData a = null;
			protected HealthOverride()
			{
			}

			public HealthOverride(LiveServer ls, HTTPAuthData auth)
			{
				Url = "http://" + dstServer.EPDefault.ToString() + "/svctunnel/health.asmx";
				a = auth;
			}

			protected override WebRequest GetWebRequest(Uri uri)
			{
				HttpWebRequest hwr = (HttpWebRequest) base.GetWebRequest(uri);
				if(a != null)
					hwr.Headers.Add(HTTPAuthData.HTTP_HEADER_AUTH_DATA, a.GetBase64EncodedString());
				return hwr;
			}
		}
		#endregion

		public static Accounts.Accounts Accounts(HTTPAuthData auth)
		{
			DateTime start = DateTime.Now;
			Accounts.Accounts a = new AccountOverride(dstServer, auth);
			return a;
		}

		public static Presence.Presence Presence(HTTPAuthData auth)
		{
			DateTime start = DateTime.Now;
			Presence.Presence p = new PresenceOverride(dstServer, auth);
			return p;
		}

		public static Health.Health Health(HTTPAuthData auth)
		{
			DateTime start = DateTime.Now;
			Health.Health h = new HealthOverride(dstServer, auth);
			return h;
		}

		static public void Initialize()
		{
			dstServer = Global.Env.Get("svctunnel");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_syschecktest_none_12.4.56.0_none_3458b1b3ac86bdae
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=syschecktest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0.manifest
XP_MANIFEST_PATH=manifests\msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0.cat
XP_CATALOG_PATH=manifests\msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0.cat
XP_PAYLOAD_PATH=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=syschecktest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TeamCleaner\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\SCResultsParser.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.4.1
// Schema file: SystemCheckSchema.xsd
// Creation Date: 7/26/2007 7:12:33 PM
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace SysCheckTest
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://tempuri.org/SystemCheck.xsd";
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class HeaderCollection : ArrayList
	{
		public Header Add(Header obj)
		{
			base.Add(obj);
			return obj;
		}

		public Header Add()
		{
			return Add(new Header());
		}

		public void Insert(int index, Header obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Header obj)
		{
			base.Remove(obj);
		}

		new public Header this[int index]
		{
			get { return (Header) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class CheckResultCollection : ArrayList
	{
		public CheckResult Add(CheckResult obj)
		{
			base.Add(obj);
			return obj;
		}

		public CheckResult Add()
		{
			return Add(new CheckResult());
		}

		public void Insert(int index, CheckResult obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(CheckResult obj)
		{
			base.Remove(obj);
		}

		new public CheckResult this[int index]
		{
			get { return (CheckResult) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="Header",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Header
	{

		[XmlAttribute(AttributeName="key",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __key;
		
		[XmlIgnore]
		public string key
		{ 
			get { return __key; }
			set { __key = value; }
		}

		[XmlAttribute(AttributeName="value",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __value;
		
		[XmlIgnore]
		public string @value
		{ 
			get { return __value; }
			set { __value = value; }
		}

		public Header()
		{
		}
	}


	[XmlType(TypeName="Response",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Response
	{

		[XmlAttribute(AttributeName="httpResponseCode",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __httpResponseCode;
		
		[XmlIgnore]
		public string httpResponseCode
		{ 
			get { return __httpResponseCode; }
			set { __httpResponseCode = value; }
		}

		[XmlElement(Type=typeof(Header),ElementName="Header",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public HeaderCollection __HeaderCollection;
		
		[XmlIgnore]
		public HeaderCollection HeaderCollection
		{
			get
			{
				if (__HeaderCollection == null) __HeaderCollection = new HeaderCollection();
				return __HeaderCollection;
			}
			set {__HeaderCollection = value;}
		}

		[XmlElement(ElementName="ResponseText",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __ResponseText;
		
		[XmlIgnore]
		public string ResponseText
		{ 
			get { return __ResponseText; }
			set { __ResponseText = value; }
		}

		public Response()
		{
		}
	}


	[XmlType(TypeName="CheckResult",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class CheckResult
	{

		[XmlElement(ElementName="Url",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Url;
		
		[XmlIgnore]
		public string Url
		{ 
			get { return __Url; }
			set { __Url = value; }
		}

		[XmlElement(ElementName="TimeOut",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="int",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __TimeOut;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __TimeOutSpecified;
		
		[XmlIgnore]
		public int TimeOut
		{ 
			get { return __TimeOut; }
			set { __TimeOut = value; __TimeOutSpecified = true; }
		}

		[XmlElement(Type=typeof(Response),ElementName="Response",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Response __Response;
		
		[XmlIgnore]
		public Response Response
		{
			get
			{
				if (__Response == null) __Response = new Response();		
				return __Response;
			}
			set {__Response = value;}
		}

		public CheckResult()
		{
		}
	}


	[XmlRoot(ElementName="SystemCheckResults",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	[XmlType(TypeName="SystemCheckResults",Namespace=Declarations.SchemaVersion)]
	public class SystemCheckResults
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
            return CheckResultCollection.GetEnumerator();
		}

		public CheckResult Add(CheckResult obj)
		{
			return CheckResultCollection.Add(obj);
		}

		[XmlIgnore]
		public CheckResult this[int index]
		{
			get { return (CheckResult) CheckResultCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return CheckResultCollection.Count; }
        }

        public void Clear()
		{
			CheckResultCollection.Clear();
        }

		public CheckResult Remove(int index) 
		{ 
            CheckResult obj = CheckResultCollection[index];
            CheckResultCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            CheckResultCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="processingStart",DataType="dateTime")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __processingStart;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __processingStartSpecified;
		
		[XmlIgnore]
		public DateTime processingStart
		{ 
			get { return __processingStart; }
			set { __processingStart = value; __processingStartSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime processingStartUtc
		{ 
			get { return __processingStart.ToUniversalTime(); }
			set { __processingStart = value.ToLocalTime(); __processingStartSpecified = true; }
		}

		[XmlAttribute(AttributeName="processingEnd",DataType="dateTime")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __processingEnd;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __processingEndSpecified;
		
		[XmlIgnore]
		public DateTime processingEnd
		{ 
			get { return __processingEnd; }
			set { __processingEnd = value; __processingEndSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime processingEndUtc
		{ 
			get { return __processingEnd.ToUniversalTime(); }
			set { __processingEnd = value.ToLocalTime(); __processingEndSpecified = true; }
		}

		[XmlElement(Type=typeof(CheckResult),ElementName="CheckResult",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public CheckResultCollection __CheckResultCollection;
		
		[XmlIgnore]
		public CheckResultCollection CheckResultCollection
		{
			get
			{
				if (__CheckResultCollection == null) __CheckResultCollection = new CheckResultCollection();
				return __CheckResultCollection;
			}
			set {__CheckResultCollection = value;}
		}

		public SystemCheckResults()
		{
			__processingStart = DateTime.Now;
			__processingEnd = DateTime.Now;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_syschecktest_none_12.4.56.0_none_3458b1b3ac86bdae
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=syschecktest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0.manifest
XP_MANIFEST_PATH=manifests\msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0.cat
XP_CATALOG_PATH=manifests\msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0.cat
XP_PAYLOAD_PATH=msil_syschecktest_no-public-key_12.4.56.0_x-ww_cdf41ab0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=syschecktest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\SysCheckTestBase.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text.RegularExpressions;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using xonline.common.config;
using xonline.common.protocol;

namespace SysCheckTest
{
	/// <summary>
	/// Summary description for SysCheckTestBase.
	/// 
	/// </summary>
	public class SysCheckTestBase : TestBase
	{
        protected Report _report = new Report("SysCheckTest");
        protected SystemCheck _sysCheckTool;
        protected string _inputFilesPath = ".\\InputFiles\\SysCheck";
        protected string _tempPath = ".\\SysCheckTempFiles";
        protected uint DefaultTimeout = 60000;


		public SysCheckTestBase()
		{
            _sysCheckTool = new SystemCheck();

            // Query the Global object to get our test-specific data
            XmlNode sysCheckConfig = Global.Config.SelectSingleNode("descendant::SysCheckTest");
            if (sysCheckConfig != null)
            {
                foreach (XmlNode setting in sysCheckConfig.ChildNodes)
                {
                    if (String.Compare(setting.Name, "DefaultToolPath", true) == 0)
                    {
                        _sysCheckTool.SystemCheckPath = Path.Combine(
                            Path.GetFullPath(setting.InnerText), "SystemCheck.exe");
                    }
                    if (String.Compare(setting.Name, "InputFilePath", true) == 0)
                    {
                        _inputFilesPath = Path.GetFullPath(setting.InnerText);
                    }
                    if (String.Compare(setting.Name, "TempDirectoryPath", true) == 0)
                    {
                        _tempPath = Path.GetFullPath(setting.InnerText);
                        if (!Directory.Exists(_tempPath))
                        {
                            Directory.CreateDirectory(_tempPath);
                        }
                    }
                }
            }
            else
            {
                throw new StfException("Unable to read the SysCheckTest configuration settings.");
            }

            // Set the working directory for SysCheck to be in the temporary files location
            _sysCheckTool.WorkingDirectory = _tempPath;
        }

        protected override void Execute()
        {
            throw new StfException("Hey you! You forgot to override the Execute method!");
        }

        protected void CopyInputFiles(string fileName)
        {
            string[] files = Directory.GetFiles(_inputFilesPath, fileName + "*.*");

            foreach (string file in files)
            {
                File.Copy(file, Path.Combine(_tempPath, Path.GetFileName(file)), true);
            }
        }

        protected void BeginCase(string caseName)
        {
            _report.Info("Begin Case: " + caseName);
        }

        /// <summary>
        /// Verifies all HealthURL output from SystemCheck against an array of health URLs.
        /// </summary>
        /// <param name="healthURLs">Array of Health URLs</param>
        /// <param name="outputFile">Output from SystemCheck.</param>
        /// <returns></returns>
        protected TEST_RESULTS VerifySystemCheckData(string[] healthURLs, string outputFile)
        {
            TEST_RESULTS res;

            res = SystemCheckVerifier.VerifyValidHealthURLs(healthURLs, outputFile);

            return res;
        }

        /// <summary>
        /// Deletes all files for a given test case from the temporary directory.
        /// </summary>
        /// <param name="fileName">
        /// Filenames to be deleted including output.
        /// </param>
        protected void ClearTempDirectory(string fileName)
        {
            string[] tempFiles = Directory.GetFiles(_tempPath, fileName + "*.*");
            foreach (string file in tempFiles)
            {
                File.Delete(file);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SysCheckTest\XMLVerifier.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using xonline.common.config;
using System.Xml.Serialization;
using System.Xml;
using System.Xml.Schema;

namespace SysCheckTest
{
    /// <summary>
	/// Base class for the leaderboard verification classes. This class should not be used directly.
	/// </summary>
	public class SystemCheckVerifier
	{
        protected static Report report = new Report("SystemCheckVerifier");

        protected SystemCheckVerifier() { }

        public static TEST_RESULTS VerifyValidHealthURLs(string [] healthURLs, string syscheckOutputFile)
        {
            TEST_RESULTS result = TEST_RESULTS.PASSED;

            if (syscheckOutputFile == null)
            {
                report.Error("The SystemCheck Output File can't be NULL.");
                return TEST_RESULTS.FAILED;
            }

            SystemCheckResults syschkResults;
            XmlUtil.DeserializeFile(syscheckOutputFile, out syschkResults);
            List<string> healthList = new List<string>(healthURLs);

            // Error check syschckResults
            foreach (CheckResult checkResult in syschkResults.CheckResultCollection)
            {
                if (healthList.Contains(checkResult.Url))
                {
                    if (string.Compare(checkResult.Response.httpResponseCode, "InternalServerError", true) == 0)
                    {
                        // There were some failures in the health url but the health url did return
                        report.Warn("{0} returned response \"{1}\".",
                            checkResult.Url,
                            checkResult.Response.httpResponseCode);
                    }
                    else if (string.Compare(checkResult.Response.httpResponseCode, "NotFound", true) == 0)
                    {
                        // There were some failures in the health url but the health url did return
                        report.Warn("{0} returned response \"{1}\".",
                            checkResult.Url,
                            checkResult.Response.httpResponseCode);
                    }
                    else if (string.Compare(checkResult.Response.httpResponseCode, "Unauthorized", true) == 0)
                    {
                        // There were some failures in the health url but the health url did return
                        report.Info("{0} returned response \"{1}\".",
                            checkResult.Url,
                            checkResult.Response.httpResponseCode);
                    }
                    else if (string.Compare(checkResult.Response.httpResponseCode, "OK", true) != 0)
                    {
                        report.Error("{0} returned response \"{1}\".\n\t{2}",
                            checkResult.Url,
                            checkResult.Response.httpResponseCode,
                            checkResult.Response.ResponseText);
                    }
                }
                else
                {
                    report.Error("{0} was not found in the list of incoming passed in URLs", checkResult.Url);
                    result = TEST_RESULTS.FAILED;
                }
            }

            return result;
        }

        public static void ReportVerificationFailure(object expVal, object actVal, string message, params object[] args)
        {
            report.Error("Verification failure! {0}\r\n  Expected: |{1}|\r\n  Actual:   |{2}|",
                string.Format(message, args), expVal == null ? "null" : expVal.ToString(),
                actVal == null ? "null" : actVal.ToString());
        }
    }

    public class XmlUtil
    {
        #region Core XML Serialization Functions
        /// <summary>
        /// Serialize data into XML
        /// </summary>
        /// <param name="filename">XML file to write data to.</param>
        /// <param name="data">Object to serialize.</param>
        public static void Serialize<T>(TextWriter outstream, T data)
        {
            XmlSerializer serializer;
            XmlWriter writer;
            XmlWriterSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlWriterSettings();
            settings.Indent = true;

            writer = XmlTextWriter.Create(outstream, settings);
            serializer.Serialize(writer, data);
            writer.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, XmlReader xmlSchemaReader, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();
            settings.ValidationFlags = XmlSchemaValidationFlags.ReportValidationWarnings;
            settings.Schemas.Add(null, xmlSchemaReader);

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }

        /// <summary>
        /// Deserialize data from XML.
        /// </summary>
        /// <param name="filename">XML File to load data from.</param>
        /// <param name="data">Object to load data into.</param>
        public static void Deserialize<T>(TextReader instream, String schemaUri, out T data)
        {
            XmlSerializer serializer;
            XmlReader reader;
            XmlReaderSettings settings;

            serializer = new XmlSerializer(typeof(T));
            settings = new XmlReaderSettings();
            settings.ValidationFlags = XmlSchemaValidationFlags.ReportValidationWarnings;
            settings.Schemas.Add(null, schemaUri);

            reader = XmlTextReader.Create(instream, settings);
            data = (T)serializer.Deserialize(reader);
            reader.Close();
        }
        #endregion
        public static void SerializeFile<T>(string filename, T data)
        {
            using (StreamWriter writer = new StreamWriter(filename))
            {
                Serialize(writer, data);
                writer.Close();
            }
        }

        public static void DeserializeFile<T>(string filename, out T data)
        {
            using (StreamReader reader = new StreamReader(filename))
            {
                Deserialize(reader, out data);
                reader.Close();
            }
        }

        public static void SerializeString<T>(out string text, T data)
        {
            StringBuilder builder = new StringBuilder();
            StringWriter writer = new StringWriter(builder);
            Serialize(writer, data);
            writer.Close();
            text = builder.ToString();
        }

        public static void DeserializeString<T>(string text, out T data)
        {
            StringReader reader = new StringReader(text);
            Deserialize(reader, out data);
            reader.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Template\TestTemplate\ServiceStress.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace TEMPLATETest
{
    /// <summary>
    ///
    /// </summary>
    [StressTest, Description("")]
    public class StressTest1 : TestNode
    {
        public override void Run()
        {
            // Place your StressTest1 test logic here
        }
    }

    /// <summary>
    ///
    /// </summary>
    [StressTest, Description("")]
    public class StressTest2 : TestNode
    {
        public override void Run()
        {
            // Place your StressTest2 test logic here
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Template\TestTemplate\ServiceFunc.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

namespace TEMPLATETest
{
    /// <summary>
    ///
    /// </summary>
    [Owner("USERNAME")]
    [TestGroup, Description("")]
    public class TestGroup1_PostiveCases : TestNode
    {
        public override void PreRun()
        {
            // Put any setup code here which is needed for all TestGroup1_PositiveCases
        }
	
        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1), Description(""), EnvRequirement("")]
        public class Test1 : TestNode
        {
            public override void PreRun()
            {
                // Put any setup code here which is needed only for Test1
            }

            public override void Run()
            {
                // Main test code goes here
            }

            public override void PostRun()
            {
                // Put any cleanup code here which is needed only for Test1
            }
        }

        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Description(""), EnvRequirement("")]
        public class Test2 : TestNode
        {
            public override void Run()
            {
            }
        }

        public override void PostRun()
        {
            // Put any cleanup code here which is needed for all TestGroup1_PositiveCases
        }
    }

    /// <summary>
    /// 
    /// </summary>
    [Owner("USERNAME")]
    [TestGroup, Description("")]
    public class TestGroup1_NegativeCases : TestNode
    {
        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("Regression"), TestCasePriority(3), Description(""), EnvRequirement(""), Ignore]
        public class IgnoredTest : TestNode
        {
            public override void Run()
            {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\Template\TestTemplate\ServiceTest.cs ===
using System;
using System.Xml;
using System.Collections;
using ServerTestFramework;
using xonline.common.config;

[assembly: RootNode(typeof(TEMPLATETest.TEMPLATESuite))]

namespace TEMPLATETest
{
    /// <summary>
    ///   <TestSuite>TEMPLATE</TestSuite>
    ///   <Tester></Tester>
    ///   <Developer></Developer>
    ///   <PM></PM>
    ///   <Status></Status>
    /// </summary>
    /// <remarks>
    ///   <Goal></Goal>
    ///   <NonGoal></NonGoal>
    ///   <Description>
    ///   </Description>
    /// </remarks>
    [Owner("USERNAME"), Description("TEMPLATE Test Suite")]
    public class TEMPLATESuite : TestNode
    {
        // Initialize
        public override void PreRun(RUN_TYPE runType)
        {
            // Make sure you brush up on the best practices of STF: http://xblwiki/default.aspx/XboxLive/STFBestPractices.html
            //
            // See a list of test case attributes you can use here: http://xblwiki/default.aspx/XboxLive/STFAttributeList.html
            //
            // This page explains how to set the test case priorities: http://xblwiki/default.aspx/XboxLive/TestCasePriorityDefinitions.html 

            // Set the endpoint for FakeSG to your service, if needed
            //GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(VirtualInterface.xpnfd_presence_int).ToString());

            if (runType == RUN_TYPE.FUNCTIONAL)
            {
                // Functional initialization
            }
            else if (runType == RUN_TYPE.STRESS)
            {
                // Stress initialization
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\ConnectionBridge.cs ===
﻿using System;
using System.Collections.Generic;
using System.Net;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.FakeSG;

using xonline.common.config;

namespace TestThroughSG
{
    /// <summary>
    /// Contains the data that links the connections from the unencrypted side to the SG side.
    /// Also contains data for mapping ports from one side to the other.
    /// </summary>
    internal class ConnectionBridge : IFakeSGClient
    {
        #region Properties

        /// <summary>The amount of time (in seconds) to wait to reuse an SGConnection after releasing it.</summary>
        public double SGConnectionCooldown
        {
            get;
            set;
        }

        #endregion

        #region Contained Classes and Private Fields

        /// <summary>Contains all necessary data about a virtual interface.</summary>
        internal class VirtualInterface
        {
            public string Name;
            public int InternetPort;
            public int ServicePort;

            public VirtualInterface (string name, int inetPort, int servPort)
            {
                Name = name;
                InternetPort = inetPort;
                ServicePort = servPort;
            }

            public override string ToString ()
            {
                return string.Format("{0} [{1}->{2}]", Name, InternetPort, ServicePort);
            }
        }

        /// <summary>Maps the internet port to a VirtualInterface object.</summary>
        private Dictionary<int, VirtualInterface> _inetToVirtualInterface = null;

        /// <summary>Maps the service port to a VirtualInterface object.</summary>
        private Dictionary<int, VirtualInterface> _serviceToVirtualInterface = null;

        /// <summary>The list of all mapped VirtualInterface objects.</summary>
        private List<VirtualInterface> _mappedVirtualInterfaces = null;

        /// <summary>Contains the auth data and the association to a source connection.</summary>
        internal class SlotAuthAssociation
        {
            public IPEndPoint Source;
            public int SourceInteger;
            public CSGInfo SGInfo;
            public DateTime SGInfoSet = DateTime.MinValue;
            public bool SGInfoUseSGConnection = false;
            public LockFreeQueue<XspBuffer> OutboundQueue;
            public SGConnection Connection;
            public bool TcpSent = false;
            public int TcpHalfClosed = 0;
            public bool UdpSent = false;
            public DateTime LastActivity;
            public bool IsDead = false;
        }

        /// <summary>The mapping of source connection point to SG connection data.</summary>
        private Dictionary<IPEndPoint, SlotAuthAssociation> _epToAuth = null;

        /// <summary>The queue of outbound work that needs to done.</summary>
        private LockFreeQueue<SlotAuthAssociation> _outboundWork = null;

        /// <summary>An event that signals the presence of work on the outbound queue.</summary>
        private System.Threading.AutoResetEvent _outboundWorkARE = null;

        /// <summary>Container for an SGConnection.</summary>
        private class SGConnData
        {
            public SGConnection Conn;
            public DateTime Available;
        }

        /// <summary>The queue of free SG connections.</summary>
        private LockFreeQueue<SGConnData> _sgFreeConnections = null;

        /// <summary>The transport layer for use by the SGConnection s.</summary>
        private XspUdp _transport = null;

        /// <summary>A list of all SG connections, regardless of in use or not.</summary>
        private SGConnection[] _sgAllConnections = null;

        /// <summary>The number of connections in the _sgAllConnections array.</summary>
        private volatile int _sgAllConnectionsCount;

        /// <summary>The user data string identifier for the slot auth association.</summary>
        private const string _sgSlotAuthUserData = "ConnectionBridge SlotAuthAssociation";

        #endregion

        #region Initialize and Shutdown

        /// <summary>
        /// Prepares the bridge for connections.
        /// </summary>
        public void Initialize ()
        {
            // need to create the mapping(s) of virtual interface inet port to http port
            // do it like the SG does
            int my_site = Config.SiteId;
            IVirtualInterfaceInfo[] vints = Config.GetVirtualInterfaceInfoBySite(my_site);

            Dictionary<int, VirtualInterface> inet_dict = new Dictionary<int, VirtualInterface>();
            Dictionary<int, VirtualInterface> serv_dict = new Dictionary<int, VirtualInterface>();
            List<VirtualInterface> map_list = new List<VirtualInterface>();

            foreach (IVirtualInterfaceInfo vint in vints)
            {
                if (vint.InternetPort == 0) { continue; }

                VirtualInterface virt_int = new VirtualInterface(vint.VirtualInterface, 
                    vint.InternetPort, vint.Port);

                if (inet_dict.ContainsKey(virt_int.InternetPort))
                {
                    VirtualInterface pre_int = inet_dict[virt_int.InternetPort];

                    if (pre_int.ServicePort != virt_int.ServicePort)
                    {
                        throw new TestThroughSGException("Virtual interface " + virt_int + " conflicts with previously configured " + pre_int);
                    }
                }
                else
                {
                    inet_dict.Add(virt_int.InternetPort, virt_int);
                    serv_dict.Add(virt_int.ServicePort, virt_int);
                }

                map_list.Add(virt_int);
            }

            // replace dictionaries
            _inetToVirtualInterface = inet_dict;
            _serviceToVirtualInterface = serv_dict;
            _mappedVirtualInterfaces = map_list;

            // create auth association dictionary
            _epToAuth = new Dictionary<IPEndPoint, SlotAuthAssociation>();

            // create outbound work items
            _outboundWork = new LockFreeQueue<SlotAuthAssociation>();
            _outboundWorkARE = new System.Threading.AutoResetEvent(false);

            // create sg connection queue
            _sgFreeConnections = new LockFreeQueue<SGConnData>();
            _transport = new XspUdp();
            _sgAllConnections = new SGConnection[10];
            _sgAllConnectionsCount = 0;
        }

        /// <summary>
        /// Closes the bridge.
        /// </summary>
        public void Shutdown ()
        {
            // release any waiting worker thread, there should only be one...
            _outboundWorkARE.Set();
        }

        #endregion

        #region Virtual Interfaces

        /// <summary>
        /// Gets the list of virtual interfaces that we currently have mapped.
        /// </summary>
        public string[] GetMappedVirtualInterfaceNames ()
        {
            List<VirtualInterface> vints = _mappedVirtualInterfaces;
            if (vints == null) { return null; }

            string[] ans = new string[vints.Count];
            int i = 0;

            foreach (VirtualInterface vint in vints)
            {
                ans[i++] = vint.Name;
            }

            return ans;
        }

        /// <summary>
        /// Translates a service port to an inet port.
        /// </summary>
        /// <param name="servicePort">The service port to look up.</param>
        /// <returns>The inet port for the given service port, or 0 if not found.</returns>
        public ushort TranslateServicePortToInet (ushort servicePort)
        {
            int sp = (int)servicePort;
            Dictionary<int, VirtualInterface> stvi = _serviceToVirtualInterface;
            VirtualInterface ans;

            if (!stvi.TryGetValue(sp, out ans))
            {
                return 0;
            }

            return (ushort)(ans.InternetPort);
        }

        /// <summary>
        /// Translates an inet port to a service port.
        /// </summary>
        /// <param name="servicePort">The inet port to look up.</param>
        /// <returns>The service port for the given inet port, or 0 if not found.</returns>
        public ushort TranslateInetPortToService (ushort inetPort)
        {
            int inp = (int)inetPort;
            Dictionary<int, VirtualInterface> stvi = _inetToVirtualInterface;
            VirtualInterface ans;

            if (!stvi.TryGetValue(inp, out ans))
            {
                return 0;
            }

            return (ushort)(ans.ServicePort);
        }

        /// <summary>
        /// Gets the virtual interfaces that are mapped by the connection bridge.
        /// </summary>
        internal List<VirtualInterface> GetRedirectedInterfaces ()
        {
            return _mappedVirtualInterfaces;
        }

        #endregion

        #region Outbound Work

        /// <summary>
        /// Gets or creates a SlotAuthAssociation for the given source.
        /// </summary>
        /// <param name="source">The source IPEndPoint.</param>
        /// <param name="allowNew">If true, we will be allowed to add a new connection.</param>
        /// <returns>The SlotAuthAssociation for the given source; or null if one is not found/created.</returns>
        internal SlotAuthAssociation GetSAAFromSource (IPEndPoint source, bool allowNew)
        {
            SlotAuthAssociation authdata;
            bool ad_initialize = false;

            Dictionary<IPEndPoint, SlotAuthAssociation> epToAuth = _epToAuth;
            lock (epToAuth)
            {
                // attempt to get the value
                if (!epToAuth.TryGetValue(source, out authdata))
                {
                    // if we don't find it, maybe make a new one
                    if (allowNew)
                    {
                        authdata = new SlotAuthAssociation();
                        ad_initialize = true;
                        epToAuth.Add(source, authdata);
                    }
                    else
                    {
                        return null;
                    }
                }
            }

            // initialize the authdata if needed
            if (ad_initialize)
            {
                authdata.Source = source;
                authdata.SourceInteger = BitConverter.ToInt32(source.Address.GetAddressBytes(), 0);
                authdata.OutboundQueue = new LockFreeQueue<XspBuffer>();
                authdata.LastActivity = DateTime.UtcNow;
            }

            return authdata;
        }

        /// <summary>
        /// Appends the given packet to the output queue based on the source IPEndPoint.
        /// </summary>
        /// <param name="source">The source IPEndPoint.</param>
        /// <param name="packet">The packet to append.</param>
        /// <param name="allowNew">If true, we will be allowed to add a new connection.</param>
        /// <returns>True if success; false if the packet was dropped.</returns>
        public bool AppendPacketToOutboundQueue (IPEndPoint source, XspBuffer packet, bool allowNew)
        {
            SlotAuthAssociation authdata = GetSAAFromSource(source, allowNew);

            // if authdata is still null, we drop the packet
            if (authdata == null)
            {
                XspBufferManager.Free(packet);
                return false;
            }

            // add to the queue
            authdata.OutboundQueue.Enqueue(packet);

            // put in the queue of work items
            EnqueueOutboundWork(authdata);

            return true;
        }

        /// <summary>
        /// Blocks until work is added to the outbound queue.
        /// </summary>
        public void WaitForOutboundWork ()
        {
            _outboundWorkARE.WaitOne();
        }

        /// <summary>
        /// Adds a work item to the queue.  Locks, but this is necessary to protect the queue.
        /// </summary>
        /// <param name="work">The work to add.</param>
        public void EnqueueOutboundWork (SlotAuthAssociation work)
        {
            lock (_outboundWork)
            {
                _outboundWork.Enqueue(work);
            }
            _outboundWorkARE.Set();
        }

        /// <summary>
        /// Gets a work item from the outbound work queue.
        /// </summary>
        /// <returns>A SlotAuthAssociation that has work to be done.</returns>
        public SlotAuthAssociation DequeueOutboundWork ()
        {
            return _outboundWork.Dequeue();
        }

        #endregion

        #region SGConnection

        /// <summary>
        /// Gets an SGConnection off of the queue, or creates a new one.
        /// </summary>
        /// <param name="slotAuth">The slot auth object that the connection is to be associated with.</param>
        public void GetSGConnection (SlotAuthAssociation slotAuth)
        {
            SGConnData sgcd = _sgFreeConnections.Peek();

            // check the first connection for availability
            if (sgcd != null && DateTime.UtcNow >= sgcd.Available)
            {
                sgcd = _sgFreeConnections.Dequeue();
            }
            else
            {
                sgcd = null;
            }

            SGConnection ans = (sgcd == null ? null : sgcd.Conn);

            if (ans == null)
            {
                ans = new SGConnection();

                // create auth data and set transport
                ans.Context = new AuthContext(AuthContext.ClientTypes.Xenon, false);
                SgClient.SetupForFakeSignInXkdc(ans.Context);
                ans.Transport = _transport;

                // associate the two with each other
                slotAuth.Connection = ans;
                ans.SetUserData(_sgSlotAuthUserData, slotAuth);

                // add this connection to the list
                if (_sgAllConnections.Length == _sgAllConnectionsCount)
                {
                    SGConnection[] new_arr = new SGConnection[_sgAllConnectionsCount * 2];
                    Array.Copy(_sgAllConnections, new_arr, _sgAllConnectionsCount);
                    _sgAllConnections = new_arr;
                }

                _sgAllConnections[_sgAllConnectionsCount] = ans;
                ++_sgAllConnectionsCount;

                // set all services so we can get through the SG for this initial connection
                ans.Context.Authdata.EnableAllBaseServices();
            }
            else
            {
                // associate the two with each other
                slotAuth.Connection = ans;
                ans.SetUserData(_sgSlotAuthUserData, slotAuth);

                // we need to re-open all services as many tests tend to clear them out
                ans.Context.Authdata.EnableAllBaseServices();

                // if we are connected, do it now
                if (ans.State == SGConnection.ConnectionState.Connected)
                {
                    // we need a user change req sent, but we don't want to copy from our basically empty SGInfo object
                    slotAuth.SGInfoUseSGConnection = true;
                    slotAuth.SGInfoSet = DateTime.UtcNow;

                    // put it into the queue so that the privileges get opened up asap
                    EnqueueOutboundWork(slotAuth);
                }
            }
        }

        /// <summary>Lock object for GetSGConnectionWithLock.</summary>
        private object _GetSGConnectionWithLockLock = new object();

        /// <summary>
        /// Gets an SGConnection off of the queue, or creates a new one.
        /// Synchronizes callers by requiring a lock to call GetSGConnection.
        /// </summary>
        /// <param name="slotAuth">The slot auth object that the connection is to be associated with.</param>
        public void GetSGConnectionWithLock (SlotAuthAssociation slotAuth)
        {
            lock (_GetSGConnectionWithLockLock)
            {
                GetSGConnection(slotAuth);
            }
        }

        /// <summary>
        /// Gets a SlotAuthAssociation from the SGConnection.
        /// </summary>
        /// <param name="sgConn">The SGConnection to inspect.</param>
        /// <returns>The SlotAuthAssociation from the SGConnection.</returns>
        public static SlotAuthAssociation GetSlotAuthAssociationFromSGConnection (SGConnection sgConn)
        {
            return (sgConn.GetUserData(_sgSlotAuthUserData) as SlotAuthAssociation);
        }

        /// <summary>
        /// Gets the SGConnection at the specified (mod) index.  Increments the (mod) index.
        /// </summary>
        /// <param name="index">The index of the SGConnection to get.</param>
        /// <returns>The SGConnection at the specified index.</returns>
        public SGConnection GetSGConnectionByIndex (ref int index)
        {
            int count = _sgAllConnectionsCount;
            SGConnection[] arr = _sgAllConnections;

            if (count == 0)
            {
                return null;
            }

            index = index % count;
            SGConnection ans = arr[index];
            ++index;

            return ans;
        }

        #endregion

        #region SlotAuthAssociation Connection State

        /// <summary>
        /// Updates the connection state based on the flags.
        /// </summary>
        /// <param name="saa">The SlotAuthAssociation that saw the flags.</param>
        /// <param name="flags">The TCP flags.</param>
        public void HandleTcpFlags (SlotAuthAssociation saa, byte flags)
        {
            saa.TcpSent = true;
            saa.LastActivity = DateTime.UtcNow;

            if ((flags & RawSocket.TCPFlagFIN) == RawSocket.TCPFlagFIN ||
                (flags & RawSocket.TCPFlagRST) == RawSocket.TCPFlagRST)
            {
                System.Threading.Interlocked.Increment(ref saa.TcpHalfClosed);
            }
        }

        /// <summary>
        /// Marks activity on the connection.
        /// </summary>
        /// <param name="saa">The SlotAuthAssociation that saw the flags.</param>
        public void MarkUdpActivity (SlotAuthAssociation saa)
        {
            saa.UdpSent = true;
            saa.LastActivity = DateTime.UtcNow;
        }

        /// <summary>
        /// Destroys a SlotAuthAssociation, freeing all related resources.
        /// </summary>
        /// <param name="saa">The SlotAuthAssociation to destroy.</param>
        public void DestroySlotAuthAssociation (SlotAuthAssociation saa)
        {
            // any work items for this saa will get dropped
            saa.IsDead = true;

            // disconnect the connection from the saa
            SGConnection conn = saa.Connection;
            conn.SetUserData(_sgSlotAuthUserData, null);

            conn.FlushDataPackets();
            _sgFreeConnections.Enqueue(new SGConnData() {
                Conn = conn, Available = DateTime.UtcNow.AddSeconds(SGConnectionCooldown)
            });

            // remove from the association list
            Dictionary<IPEndPoint, SlotAuthAssociation> epToAuth = _epToAuth;
            lock (epToAuth)
            {
                epToAuth.Remove(saa.Source);
            }

            // this is the only thread that is allowed to drain the outbound queue
            EnqueueOutboundWork(saa);
        }

        #endregion

        #region IFakeSGClient Implemented Members

        /// <summary>
        /// Gets a new slot struct.
        /// </summary>
        public CSGInfo GetSlot ()
        {
            CSGInfo ans = new CSGInfo();
            ans.Initialize();
            return ans;
        }

        /// <summary>
        /// Sets the given authdata for the given IP.
        /// </summary>
        public void PutSlot (ref CSGInfo Slot, IPAddress srcIp)
        {
            if (Slot.machinePuid == 0)
            {
                throw new TestThroughSGException("Machine puid cannot be 0");
            }

            IPEndPoint ep = new IPEndPoint(srcIp, (int)(Slot.port));
            SlotAuthAssociation saa = null;
            
            Dictionary<IPEndPoint, SlotAuthAssociation> epToAuth = _epToAuth;
            lock (epToAuth)
            {
                if (!epToAuth.TryGetValue(ep, out saa))
                {
                    // We don't allow you to pre-set the authdata yet
                    // *_int calls still PutSlot and I don't want to dirty up the list
                    return;
                }
            }

            // copy the slot info over
            saa.SGInfo = Slot;

            // mark this as in need of authdata update
            saa.SGInfoSet = DateTime.UtcNow;

            // add to outbound work queue
            EnqueueOutboundWork(saa);
        }

        /// <summary>
        /// Does nothing currently, as we already have a state endpoint at the SG.
        /// </summary>
        /// <param name="endpoint">A string defining the state update endpoint.</param>
        public void SetStateEndpoint (string endpoint)
        {
            // Not sure what we would do with this, the SG already has the real one
        }

        #endregion

        #region IFakeSGClient Unimplemented Members

        public bool ConnectToService ()
        {
            throw new NotImplementedException();
        }

        public void AddUser (ulong xboxId, ulong userId, uint userFlags)
        {
            //throw new NotImplementedException();
            // Not throwing for now as I want to see what happens
        }

        public void AddXbox (uint sgIp, uint spi, ulong xboxId, uint titleId, uint titleVer, uint titleRegion, byte[] key, ulong clientVersion, CSGInfo.ClientType clientType, uint languageId)
        {
            //throw new NotImplementedException();
            // Not throwing for now as I want to see what happens
        }

        public void ClearXboxes ()
        {
            throw new NotImplementedException();
        }

        public void DeadXbox (ulong xboxId)
        {
            throw new NotImplementedException();
        }

        public byte GetUserCount (ulong xboxId)
        {
            throw new NotImplementedException();
        }

        public void LoadSlot (ref CSGInfo sgInfo, ulong xboxId)
        {
            throw new NotImplementedException();
        }

        public bool ReadUserQValPacket (ulong xboxId, ulong userId, out QValPacket packet)
        {
            //throw new NotImplementedException();
            // Not throwing for now as I want to see what happens
            packet = null;
            return false;
        }

        public void RemoveUser (ulong xboxId, ulong userId)
        {
            throw new NotImplementedException();
        }

        public void RemoveXbox (ulong xboxId)
        {
            throw new NotImplementedException();
        }

        public void SetAltTitle (ulong xboxId, uint titleId, int pos)
        {
            throw new NotImplementedException();
        }

        public void SetAltTitles (ulong xboxId, uint[] altTitleIds)
        {
            throw new NotImplementedException();
        }

        public void SetEnableStateBatching (bool enable, uint intervalSeconds)
        {
            throw new NotImplementedException();
        }

        public void SetKey (ulong xboxId, byte[] key)
        {
            throw new NotImplementedException();
        }

        public void SetTitle (ulong xboxId, uint titleId, uint titleVer, uint titleRegion)
        {
            //throw new NotImplementedException();
            // Not throwing for now as I want to see what happens
        }

        public void SetUserState (ulong xboxId, ulong userId, ulong matchSessionId, uint state, byte[] titleData, ushort titleDataLen)
        {
            //throw new NotImplementedException();
            // Not throwing for now as I want to see what happens
        }

        #endregion

        #region I*Client Related Members

        /// <summary>
        /// Gets an ITcpClient for use by FDTransaction.
        /// </summary>
        /// <param name="remote">The remote server.</param>
        /// <returns>An ITcpClient if the remote server is behind the SG; null if it is not.</returns>
        public ITcpClient AcquireTcpClient (IPEndPoint remote)
        {
            if (TranslateServicePortToInet((ushort)remote.Port) != 0)
            {
                return new BridgeTcpClient(this);
            }

            return null;
        }

        /// <summary>
        /// Gets an IUdpClient for use by FDTransaction.
        /// </summary>
        /// <param name="remote">The remote server.</param>
        /// <returns>An IUdpClient if the remote server is behind the SG; null if it is not.</returns>
        public IUdpClient AcquireUdpClient (IPEndPoint remote)
        {
            if (TranslateServicePortToInet((ushort)remote.Port) != 0)
            {
                return new BridgeUdpClient(this);
            }

            return null;
        }

        #endregion

        #region Debug Information

        /// <summary>
        /// Gets a collection of stats from the connection bridge.
        /// </summary>
        internal void FillStatsCollection (ref TestThroughSG.StatsCollection stats)
        {
            Dictionary<IPEndPoint, SlotAuthAssociation> epToAuth = _epToAuth;
            if (epToAuth != null)
            {
                lock (epToAuth)
                {
                    stats.BridgeSAACount = epToAuth.Count;
                }
            }
            stats.BridgeSGConnCount = _sgAllConnectionsCount;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\BridgeUdpClient.cs ===
﻿using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace TestThroughSG
{

internal class BridgeUdpClient : IUdpClient, IDisposable
{
    /// <summary>The connection bridge that we are associate with.</summary>
    protected ConnectionBridge _bridge;

    /// <summary>The local port used by this client.</summary>
    protected ushort _localPort = 0;
    /// <summary>The local EndPoint used by this client.</summary>
    protected IPEndPoint _localEP = null;

    /// <summary>The remote EndPoint used by this client.</summary>
    protected IPEndPoint _remoteEP = null;

    /// <summary>Our specific link to the bridge.</summary>
    protected ConnectionBridge.SlotAuthAssociation _bridgeConn = null;

    internal BridgeUdpClient (ConnectionBridge bridge)
    {
        _bridge = bridge;
    }

    ~BridgeUdpClient ()
    {
        try
        {
            Dispose(true);
        }
        catch (Exception e)
        {
            Global.RO.Error("Got exception in ~BridgeUdpClient:\n" + e);
        }
    }

    #region Statics

    /// <summary>Backing for GetNextPort.</summary>
    protected static int _portCounter = 0;

    /// <summary>
    /// Gets the next port number to be used.  Currently no protection from re-use.
    /// </summary>
    protected static ushort GetNextPort ()
    {
        return (ushort)((((uint)Interlocked.Increment(ref _portCounter)) % 0xFFFE + 1) & 0xFFFF);
    }

    #endregion

    #region Helpers

    public ushort Bind ()
    {
        if (_localPort == 0)
        {
            _localPort = GetNextPort();
            _localEP = new IPEndPoint(IPAddress.Any, _localPort);
        }

        return _localPort;
    }

    #endregion

    #region IUdpClient Members

    public void Close ()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    void IUdpClient.Connect (IPEndPoint endpoint)
    {
        if (_bridgeConn != null)
        {
            throw new BridgeTcpClientException("This client is already connected.");
        }

        // ensure that we have a local endpoint
        Bind();

        _bridgeConn = _bridge.GetSAAFromSource(_localEP, true);
         _bridge.GetSGConnectionWithLock(_bridgeConn);

        // ensure that we are connected to the SG
        if (_bridgeConn.Connection.State == SGConnection.ConnectionState.Disconnected)
        {
            _bridgeConn.Connection.Connect();
        }

        // continue connecting, this would be a VERY strange state for us to hit here, but handling it is easy
        while (_bridgeConn.Connection.State == SGConnection.ConnectionState.ConnectWait)
        {
            _bridgeConn.Connection.EndConnect();
        }

        // save the remote endpoint for future sending
        _remoteEP = endpoint;
    }

    public int ReceiveTimeout
    {
        get;
        set;
    }

    int IUdpClient.SendTimeout
    {
        set { }
    }

    IPEndPoint IUdpClient.LocalIPEndPoint
    {
        get
        {
            if (_localPort == 0)
            {
                throw new BridgeTcpClientException("Local endpoint has not been bound yet.");
            }

            return _localEP;
        }
    }

    int IUdpClient.Send (byte[] buffer, int length)
    {
        if (buffer == null)
        {
            throw new ArgumentNullException("buffer");
        }

        if (length > XspBuffer.PAYLOAD_MAXSAFESIZE)
        {
            throw new ArgumentOutOfRangeException("length",
                String.Format("Data is larger than the maximum payload size: {0} > {1}", length, XspBuffer.PAYLOAD_MAXSAFESIZE)
                );
        }

        SGConnection conn = _bridgeConn.Connection;

        if (conn.State != SGConnection.ConnectionState.Connected)
        {
            throw new BridgeUdpClientException("The SG connection has been lost.");
        }

        XspBuffer packet = conn.Session.EncodeUdp((uint)_localPort, (uint)_remoteEP.Port, buffer, (uint)length);
        conn.Send(packet);
        XspBufferManager.Free(packet);

        return length;
    }

    byte[] IUdpClient.Receive (ref IPEndPoint remote)
    {
        SGConnection conn = _bridgeConn.Connection;

        if (conn.State != SGConnection.ConnectionState.Connected)
        {
            throw new BridgeUdpClientException("The SG connection has been lost.");
        }

        DateTime start = DateTime.UtcNow;

        while ((DateTime.UtcNow - start).TotalSeconds < ReceiveTimeout)
        {
            conn.ProcessReceiveQueue();
            XspBuffer packet = conn.GetPacketOnPort(SGConnection.MapPortForIncoming(XspHeader.XSP_TYPE_UDP_0, _localPort));

            if (packet != null)
            {
                byte[] ans = packet.DataBuffer;
                remote = _remoteEP;
                XspBufferManager.Free(packet);

                return ans;
            }
        }

        throw new BridgeUdpClientException("Timeout expired for receiving a datagram.");
    }

    #endregion

    #region IDisposable Members

    void IDisposable.Dispose ()
    {
        Close();
    }

    protected void Dispose (bool disposeAll)
    {
        if (_bridgeConn != null)
        {
            _bridgeConn.IsDead = true;
        }
    }

    #endregion
}

public class BridgeUdpClientException : Exception
{
    public BridgeUdpClientException (string message) : base(message) { }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\BridgeTcpClient.cs ===
﻿using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace TestThroughSG
{

internal class BridgeTcpClient : ITcpClient, ISocket, IDisposable
{
    /// <summary>The connection bridge that we are associate with.</summary>
    protected ConnectionBridge _bridge;

    /// <summary>The local port used by this client.</summary>
    protected ushort _localPort = 0;
    /// <summary>The local EndPoint used by this client.</summary>
    protected IPEndPoint _localEP = null;

    /// <summary>Our specific link to the bridge.</summary>
    protected ConnectionBridge.SlotAuthAssociation _bridgeConn = null;

    /// <summary>Our direct TCP client.</summary>
    protected TcpForSGConnection _directTcp = null;

    internal BridgeTcpClient (ConnectionBridge bridge)
    {
        _bridge = bridge;
    }

    ~BridgeTcpClient ()
    {
        try
        {
            Dispose(true);
        }
        catch (Exception e)
        {
            Global.RO.Error("Got exception in ~BridgeTcpClient:\n" + e);
        }
    }

    #region Statics

    /// <summary>Backing for GetNextPort.</summary>
    protected static int _portCounter = 0;

    /// <summary>
    /// Gets the next port number to be used.  Currently no protection from re-use.
    /// </summary>
    protected static ushort GetNextPort ()
    {
        return (ushort)((((uint)Interlocked.Increment(ref _portCounter)) % 0xFFFE + 1) & 0xFFFF);
    }

    #endregion

    #region Internal Members

    /// <summary>
    /// True if there is data that is currently available for non-blocking receive; false otherwise.
    /// </summary>
    internal bool DataAvailable
    {
        get
        {
            return (_directTcp != null && _directTcp.DataAvailable);
        }
    }

    /// <summary>
    /// Pump the TCP streams to ensure that data keeps flowing even if we aren't trying to read/write actively.
    /// </summary>
    internal void PumpStreams ()
    {
        if (_directTcp != null)
        {
            _directTcp.PumpStreams();
        }
    }

    #endregion

    #region ITcpClient Members

    public ushort Bind ()
    {
        if (_localPort == 0)
        {
            _localPort = GetNextPort();
            _localEP = new IPEndPoint(IPAddress.Any, _localPort);
        }

        return _localPort;
    }

    ISocket ITcpClient.Client
    {
        get { return this; }
    }

    public void Close ()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    void ITcpClient.Connect (IPEndPoint endpoint)
    {
        if (_bridgeConn != null)
        {
            throw new BridgeTcpClientException("This client is already connected.");
        }

        // ensure that we have a local endpoint
        Bind();

        _bridgeConn = _bridge.GetSAAFromSource(_localEP, true);
        _bridge.GetSGConnectionWithLock(_bridgeConn);

        // ensure that we are connected to the SG
        if (_bridgeConn.Connection.State == SGConnection.ConnectionState.Disconnected)
        {
            _bridgeConn.Connection.Connect();
        }

        // continue connecting, this would be a VERY strange state for us to hit here, but handling it is easy
        while (_bridgeConn.Connection.State == SGConnection.ConnectionState.ConnectWait)
        {
            _bridgeConn.Connection.EndConnect();
        }

        // now we are connected to the SG, create a TCP connection through it
        _directTcp = new TcpForSGConnection(_bridgeConn.Connection);
        _directTcp.SendTimeout = _sendTimeout;
        _directTcp.ReceiveTimeout = _recvTimeout;
        _directTcp.Connect(_localPort, _bridge.TranslateServicePortToInet((ushort)endpoint.Port));
    }

    bool ITcpClient.ExclusiveAddressUse
    {
        set
        {
            // does not mean anything for us
        }
    }

    Stream ITcpClient.GetStream ()
    {
        return _directTcp;
    }

    int ITcpClient.ReceiveBufferSize
    {
        get { return TcpForSG.DefaultWindowSize; }
    }

    /// <summary>The timeout to wait for data to be read.</summary>
    protected int _recvTimeout = 0;

    int ITcpClient.ReceiveTimeout
    {
        set
        {
            _recvTimeout = value;

            if (_directTcp != null)
            {
                _directTcp.ReceiveTimeout = _recvTimeout;
            }
        }
    }

    /// <summary>The timeout to wait for a send to be acknowledged.</summary>
    protected int _sendTimeout = 0;

    int ITcpClient.SendTimeout
    {
        set
        {
            _sendTimeout = value;

            if (_directTcp != null)
            {
                _directTcp.SendTimeout = _sendTimeout;
            }
        }
    }

    #endregion

    #region ISocket Members

    EndPoint ISocket.LocalEndPoint
    {
        get
        {
            if (_localPort == 0)
            {
                throw new BridgeTcpClientException("Local endpoint has not been bound yet.");
            }

            return _localEP;
        }
    }

    int ISocket.Receive (byte[] buffer)
    {
        return _directTcp.Read(buffer, 0, buffer.Length);
    }

    void ISocket.Shutdown (SocketShutdown how)
    {
        //throw new NotImplementedException();
    }

    #endregion

    #region IDisposable Members

    void IDisposable.Dispose ()
    {
        Close();
    }

    protected void Dispose (bool disposeAll)
    {
        try
        {
            if (_directTcp != null)
            {
                _directTcp.Close();
                _directTcp = null;
            }
        }
        finally
        {
            if (_bridgeConn != null)
            {
                _bridgeConn.IsDead = true;
            }
        }
    }

    #endregion
}

public class BridgeTcpClientException : Exception
{
    public BridgeTcpClientException (string message) : base(message) { }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\DebugForm.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

namespace TestThroughSG
{
    public partial class DebugForm : Form
    {
        /// <summary>The plugin reference for removing ourself.</summary>
        public Plugin PluginRef = null;

        /// <summary>A tab update function.</summary>
        public delegate void TabUpdateFunction ();

        public DebugForm ()
        {
            InitializeComponent();

            tbpStats.Tag = new TabUpdateFunction(UpdateStatsTab);
            tbpCap.Tag = new TabUpdateFunction(UpdateCapTab);
        }

        /// <summary>
        /// Updates the current tab's information.
        /// </summary>
        public void UpdateCurrentTab ()
        {
            ((TabUpdateFunction)(tbcMain.TabPages[tbcMain.TabIndex].Tag))();
        }

        /// <summary>
        /// Updates the Statistics tab.
        /// </summary>
        public void UpdateStatsTab ()
        {
            // read in virtual interfaces, since it shouldn't change, we only do it once
            if (lstRedirected.Items.Count == 0)
            {
                List<ConnectionBridge.VirtualInterface> ris = TestThroughSG.GetRedirectedInterfaces();

                if (ris != null)
                {
                    lstRedirected.BeginUpdate();

                    try
                    {
                        foreach (ConnectionBridge.VirtualInterface vint in ris)
                        {
                            ListViewItem lvi = new ListViewItem(vint.Name);
                            lvi.SubItems.Add(vint.ServicePort.ToString());
                            lvi.SubItems.Add(vint.InternetPort.ToString());
                            lstRedirected.Items.Add(lvi);
                        }

                    }
                    finally
                    {
                        lstRedirected.EndUpdate();
                    }
                }
            }

            // get all stats
            TestThroughSG.StatsCollection stats = new TestThroughSG.StatsCollection();
            TestThroughSG.FillStatsCollection(ref stats);

            // Outbound Traffic - Raw Socket
            lblDroppedTooSmall.Text = stats.RawSocketDroppedTooSmall.ToString();
            lblDroppedNotOurAddress.Text = stats.RawSocketDroppedNotOurIP.ToString();
            lblDroppedSizeMismatch.Text = stats.RawSocketDroppedSizeMismatch.ToString();
            lblDroppedFragmented.Text = stats.RawSocketDroppedFragmented.ToString();
            lblDroppedBadProtocol.Text = stats.RawSocketDroppedProtocolNotSupported.ToString();
            lblDroppedTooLarge.Text = stats.RawSocketDroppedTooLarge.ToString();
            lblRawSocketReceived.Text = stats.RawSocketReceived.ToString();

            // Outbound Traffic - Bridge
            lblBridgeSAACount.Text = stats.BridgeSAACount.ToString();
            lblBridgeSGConnCount.Text = stats.BridgeSGConnCount.ToString();
            lblDroppedDeadSAA.Text = stats.TTSGDroppedDeadSAA.ToString();

            // Inbound Traffic
            lblDroppedNotSent.Text = stats.RawSocketDroppedNotSent.ToString();
            lblRawSocketSent.Text = stats.RawSocketSent.ToString();
        }

        /// <summary>
        /// Updates the Packet Capture tab.
        /// </summary>
        public void UpdateCapTab ()
        {
        }

        #region Events

        private void tmrUpdate_Tick (object sender, EventArgs e)
        {
            try
            {
                UpdateCurrentTab();
            }
            catch (Exception exc)
            {
                ServerTestFramework.Global.RO.Debug("Got exception in tmrUpdate_Tick:\n" + exc.ToString());
            }
        }

        private void DebugForm_Shown (object sender, EventArgs e)
        {
            tmrUpdate.Enabled = true;
            UpdateCurrentTab();
        }

        private void DebugForm_FormClosed (object sender, FormClosedEventArgs e)
        {
            if (PluginRef != null)
            {
                PluginRef.RemoveDebugForm(this);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\LockFreeQueue.cs ===
﻿using System;

namespace TestThroughSG
{
    /// <summary>
    /// This queue is safe as long as only 1 thread is enqueuing and only 1 thread is dequeuing at a time.
    /// Also known as single producer single consumer thread safe.
    /// 
    /// Yada yada ABA yada yada C# managed memory protects yada yada.
    /// </summary>
    internal class LockFreeQueue<T>
    {
        private class Node
        {
            public T Value;
            public Node Next;
        }

        private Node _head;
        private Node _tail;

        public LockFreeQueue ()
        {
            _head = new LockFreeQueue<T>.Node();
            _tail = _head;
        }

        public void Enqueue (T value)
        {
            Node new_hot = new LockFreeQueue<T>.Node();
            new_hot.Value = value;
            new_hot.Next = null;

            // here we need to do this in this order, or we aren't safe
            _tail.Next = new_hot;
            _tail = new_hot;
        }

        public T Dequeue ()
        {
            if (_head == _tail)
            {
                return default(T);
            }

            T ans = _head.Next.Value;
            _head = _head.Next;
            return ans;
        }

        public T Peek ()
        {
            if (_head == _tail)
            {
                return default(T);
            }

            return _head.Next.Value;
        }

        public bool Empty
        {
            get { return (_head == _tail); }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\IpHelper.cs ===
﻿using System;
using System.Net;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;

using ServerTestFramework;

namespace TestThroughSG
{
    public static class IpHelper
    {
        [DllImport("iphlpapi.dll")]
        private static extern UInt32 GetBestInterface (UInt32 dwDestAddr, out UInt32 pdwBestIfIndex);

        /// <summary>
        /// Determines the interface out which packets will be routed, given a destination address.
        /// </summary>
        /// <param name="destAddr">The destination address to route.</param>
        /// <returns>The IPAddress of the interface chosen as the routing target.</returns>
        public static IPAddress GetBestInterface (IPAddress destAddr)
        {
            // make a uint from bytes
            UInt32 saddr = BitConverter.ToUInt32(destAddr.GetAddressBytes(), 0);
            UInt32 index;

            UInt32 result = GetBestInterface(saddr, out index);

            if (result != 0)
            {
                throw new IpHelperException("GetBestInterface returned unexpected result: " + result);
            }

            // we are going to shortcut iphlpapi.dll here and grab this .net stuff (hopefully its the same)
            NetworkInterface[] interfaces = NetworkInterface.GetAllNetworkInterfaces();

            for (int i = 0; i < interfaces.Length; ++i)
            {
                NetworkInterface ni = interfaces[i];
                IPInterfaceProperties ipip = ni.GetIPProperties();
                IPv4InterfaceProperties ipv4ip = ipip.GetIPv4Properties();

                if (ipv4ip != null && ipv4ip.Index == index)
                {
                    foreach (UnicastIPAddressInformation uipai in ipip.UnicastAddresses)
                    {
                        if (uipai.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                        {
                            return uipai.Address;
                        }
                    }
                }
            }

            return null;
        }
    }

    /// <summary>
    /// An exception that is thrown by the IpHelper class.
    /// </summary>
    public class IpHelperException : Exception
    {
        public IpHelperException (string message) : base(message) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\NetmonAPI.cs ===
using System;
using System.Text;
using System.Runtime.InteropServices;

namespace Microsoft.NetworkMonitor
{
    #region Network Monitor API structs and defines

    /// <summary>
    /// Network Monitor API Constants
    /// </summary>
    public class NmConstant
    {
        /// <summary>
        /// 
        /// </summary>
        public const int MAC_ADDRESS_SIZE = 6;
        /// <summary>
        /// 
        /// </summary>
        public const int MAX_PATH = 260;
        /// <summary>
        /// 
        /// </summary>
        public const int NMAPI_GUID_SIZE = 16;
    }

    /// <summary>
    /// Network Monitor API return status code
    /// </summary>
    public class NmStatusCode
    {
        /// <summary>
        /// MessageId: NM_STATUS_FRAME_TOO_BIG_FOR_FILE
        ///
        /// MessageText:
        ///
        /// The file doesn't have enough space to hold this frame.
        /// </summary>
        public const UInt32 NM_STATUS_FRAME_TOO_BIG_FOR_FILE = 0xE1110001;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_FILE_TOO_SMALL
        ///
        /// MessageText:
        ///
        /// Capture file size too small. 
        ///
        /// </summary>
        public const UInt32 NM_STATUS_FILE_TOO_SMALL = 0xE1110002;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_FILE_TOO_LARGE
        ///
        /// MessageText:
        ///
        /// Capture file size too large. 
        ///
        /// </summary>
        public const UInt32 NM_STATUS_FILE_TOO_LARGE = 0xE1110003;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_FRAME_CONTINUES_INTO_NEXT_FRAME
        ///
        /// MessageText:
        ///
        /// The frame is corrupt. It overlaps with the next frame. 
        ///
        /// </summary>
        public const UInt32 NM_STATUS_FRAME_CONTINUES_INTO_NEXT_FRAME = 0xE1110004;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_FRAME_RANGE_OUT_OF_BOUNDS
        ///
        /// MessageText:
        ///
        /// The frame is corrupt. The dimensions of the frame are not in the range of the capture file. 
        ///
        /// </summary>
        public const UInt32 NM_STATUS_FRAME_RANGE_OUT_OF_BOUNDS = 0xE1110005;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_WRONG_ENDIAN
        ///
        /// MessageText:
        ///
        /// The data is in BigEndian and we support only Little Endian 
        ///
        /// </summary>
        public const UInt32 NM_STATUS_WRONG_ENDIAN = 0xE1110006;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_INVALID_PCAP_FILE
        ///
        /// MessageText:
        ///
        /// This file is not a valid PCAP file
        ///
        /// </summary>
        public const UInt32 NM_STATUS_INVALID_PCAP_FILE = 0xE1110007;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_WRONG_PCAP_VERSION
        ///
        /// MessageText:
        ///
        /// This file is not a supported PCAP version 
        ///
        /// </summary>
        public const UInt32 NM_STATUS_WRONG_PCAP_VERSION = 0xE1110008;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_UNSUPPORTED_FILE_TYPE
        ///
        /// MessageText:
        ///
        /// This file type is not supported.
        ///
        /// </summary>
        public const UInt32 NM_STATUS_UNSUPPORTED_FILE_TYPE = 0xE1110009;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_INVALID_NETMON_CAP_FILE
        ///
        /// MessageText:
        ///
        /// This file type is not a valid Network Monitor capture file.
        ///
        /// </summary>
        public const UInt32 NM_STATUS_INVALID_NETMON_CAP_FILE = 0xE111000A;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_UNSUPPORTED_PCAP_DLT
        ///
        /// MessageText:
        ///
        /// This Pcap data link type is not supported.
        ///
        /// </summary>
        public const UInt32 NM_STATUS_UNSUPPORTED_PCAP_DLT = 0xE111000B;

        /// <summary>
        ///
        /// MessageId: NM_STATUS_API_VERSION_MISMATCHED
        ///
        /// MessageText:
        ///
        /// The current NmApi DLL is different from the required version by the application. 
        ///
        /// </summary>
        public const UInt32 NM_STATUS_API_VERSION_MISMATCHED = 0xE111000C;
    }

    ///
    /// <summary><c>NmCaptureMode</c>Network Monitor capture mode</summary> 
    /// <remarks>
    /// </remarks>
    public enum NmCaptureMode : uint 
    {
        /// <summary>
        /// 
        /// </summary>
        LocalOnly,
        /// <summary>
        /// 
        /// </summary>
        Promiscuous
    }

    ///
    /// <summary><c>NmCaptureFileMode</c>Network Monitor capture file expansion mode</summary> 
    /// <remarks>
    /// </remarks>
    public enum NmCaptureFileFlag : uint
    {
        /// <summary>
        /// 
        /// </summary>
        WrapAround,
        /// <summary>
        /// 
        /// </summary>
        Chain,
        /// <summary>
        /// 
        /// </summary>
        LastFlag
    };

    ///
    /// <summary><c>NmCaptureCallbackExitMode</c>Capture callback function exit mode</summary> 
    /// <remarks>
    ///     NmCaptureStopAndDiscard - NmStopCapture/NmPauseCapture returns immediately user's capture callback function will not be called after
    ///                               NmStopCapture/NmPauseCapture returns
    /// </remarks>
    public enum NmCaptureCallbackExitMode : uint
    {
        /// <summary>
        /// 
        /// </summary>
        DiscardRemainFrames = 1,
        /// <summary>
        /// 
        /// </summary>
        ReturnRemainFrames = 2,
    };

    ///
    /// <summary><c>NmAdapterOpState</c>Network Monitor driver adapter operational states</summary> 
    /// <remarks>
    /// </remarks>
    public enum NmAdapterOpState : uint
    {
        /// <summary>
        /// 
        /// </summary>
        None = 0,
        /// <summary>
        /// 
        /// </summary>
        Bound,
        /// <summary>
        /// 
        /// </summary>
        Stopped,
        /// <summary>
        /// 
        /// </summary>
        Capturing,
        /// <summary>
        /// 
        /// </summary>
        Paused
    };


    ///
    /// <summary><c>NmCallbackMsgType</c>Status levels of the call back message</summary> 
    /// <remarks>
    /// </remarks>
    public enum NmCallbackMsgType : uint
    {
        /// <summary>
        /// 
        /// </summary>
        None,
        /// <summary>
        /// 
        /// </summary>
        Error,
        /// <summary>
        /// 
        /// </summary>
        Warning,
        /// <summary>
        /// 
        /// </summary>
        Information,
        /// <summary>
        /// 
        /// </summary>
        Last
    };

    ///
    /// <summary><c>NmNplParserLoadingOption</c>NPL loading option</summary> 
    /// <remarks>
    /// By default the NmLoadNplOptionNone is used.  Only the user specified NPL path(s) are loaded.
    /// If both NmAppendRegisteredNplSets and a NPL path are specified, the resulting NPL parser will include
    /// Both and the specified NPL path(s) are prefixed.
    /// </remarks>
    public enum NmNplParserLoadingOption : uint
    {
        NmLoadNplOptionNone,
        NmAppendRegisteredNplSets
    };

    ///
    /// <summary><c>NmFrameParserOptimizeOption</c>Frame parser optimization options</summary> 
    /// <remarks>
    /// Options used when create frame parser.
    /// </remarks>
    public enum NmFrameParserOptimizeOption : uint
    {
        ///
        /// Create frame parser without optimization according to the added filter
        ///
        ParserOptimizeNone = 0,
        ///
        /// Create frame parser optimized based on added filters, fields and properties
        ///
        ParserOptimizeFull = 1,

        ParserOptimizeLast

    };

    ///
    /// <summary><c>NmFrameParsingOption</c>Frame parser parsing options</summary> 
    /// <remarks>
    /// Options used by NmParseFrame function.
    /// </remarks>
    [Flags]
    public enum NmFrameParsingOption : uint
    {
        /// <summary>
        /// 
        /// </summary>
        None = 0,
        /// <summary>
        /// Provide full path name of the current field if specified
        /// </summary>
        FieldFullNameRequired = 1,
        /// <summary>
        /// Provide the name of the protocol that contains the current field if specified
        /// </summary>
        ContainingProtocolNameRequired = 2,
        /// <summary>
        /// Provide data type name of the fields
        /// </summary>
        DataTypeNameRequired = 4,
        /// <summary>
        /// Use caller specified frame number
        /// </summary>
        UseFrameNumberParameter = 8,
        ///
        /// Provide the display string of the field
        ///
        FieldDisplayStringRequired = 16,
        ///
        /// Provide the frame conversation information
        ///
        FrameConversationInfoRequired = 32,
        /// <summary>
        /// 
        /// </summary>
        ParsingOptionLast

    };


    ///
    /// <summary><c>FrameFragmentationType</c>Fragmentation types returned in parsed frames</summary> 
    /// <remarks>
    /// </remarks>
    public enum NmFrameFragmentationType : uint
    {
        /// <summary></summary>
        None,
        /// <summary></summary>
        Start,
        /// <summary></summary>
        Middle,
        /// <summary></summary>
        End

    }

    ///
    /// <summary><c>NmParsedFieldNames</c>The name string properties in parsed field</summary> 
    /// <remarks>
    /// </remarks>
    public enum NmParsedFieldNames : uint
    {
        /// <summary></summary>
        NamePath,
        /// <summary></summary>
        DataTypeName,
        /// <summary></summary>
        ContainingProtocolName,
        /// <summary></summary>
        FieldDisplayString
    };

    ///
    /// <summary><c>NmMvsKeyType</c>Key types of the multi storage property</summary> 
    /// <remarks>
    /// The MvsKeyTypeArrayIndex type is used for group property functions to specify the index parameter.
    /// </remarks>
    public enum NmMvsKeyType : uint
    {
        /// <summary></summary>
        MvsKeyTypeNone,
        /// <summary></summary>
        MvsKeyTypeNumber,
        /// <summary></summary>
        MvsKeyTypeString,
        /// <summary></summary>
        MvsKeyTypeByteArray,
        /// <summary></summary>
        MvsKeyTypeArrayIndex,
        /// <summary></summary>
        MvsKeyTypeLast

    };

    ///
    /// <summary>
    /// <c>NmPropertyScope</c>
    /// Scopes of properties.  It is reported in the property info.
    /// </summary> 
    /// <remarks>
    /// </remarks>
    ///
    public enum NmPropertyScope : uint
    {
        /// <summary></summary>
        PropertyScopeNone = 0,
        /// <summary></summary>
        PropertyScopeConversation = 1,
        /// <summary></summary>
        PropertyScopeGlobal = 2,
        /// <summary></summary>
        PropertyScopeFrame = 4

    };

    ///
    /// <summary>
    /// <c>NmPropertyContainerType</c>
    /// The property aggregation form, i.e., MVS with key, Array with index, etc.
    /// </summary> 
    /// <remarks>
    /// </remarks>
    ///
    public enum NmPropertyContainerType : uint
    {
        /// <summary></summary>
        PropertyTypeContainerNone = 0,
        /// <summary></summary>
        PropertyTypeContainerValue,
        /// <summary></summary>
        PropertyTypeContainerMvs,
        /// <summary></summary>
        PropertyTypeContainerArray

    };

    ///
    /// <summary>
    /// <c>NmPropertyValueType</c>
    /// Type of the property value.
    /// </summary> 
    /// <remarks>
    /// Number value is in signed or unsigned integer format
    /// String value is in wide char format
    /// Byte Blob is in byte array
    /// 
    /// The value type of properties, in the same multi value storage property addressed 
    /// By different keys or in the same property group by different indexes,
    /// Can be different.
    /// .
    /// </remarks>
    ///
    public enum NmPropertyValueType : uint
    {
        /// <summary></summary>
        PropertyValueNone,
        /// <summary></summary>
        PropertyValueSignedNumber,
        /// <summary></summary>
        PropertyValueUnsignedNumber,
        /// <summary></summary>
        PropertyValueString,
        /// <summary></summary>
        PropertyValueByteBlob

    };

    ///
    /// <summary><c>NmOlpActionFlags</c></summary> 
    /// <remarks>
    /// These flags are used when the OLP expressions, blocks and filters are created.  For filter creation, these
    /// flags are combined with NmFilterOptionFlags in the options parameter.  These flags override the 
    /// normal AND/OR operations that would occur for the conditions, blocks and filters following the current
    /// entity; OLP expression, block or filter.
    ///
    /// For example, if block type is AND and the NmOlpActionFlagsCopyOnFalse is specified at block creation, 
    /// the frames that fail the block are copied to user mode although they would have been dropped in the 
    /// normal AND operation.  These flags "short circuit" the rest of the evaluation.  If this evaluation is 
    /// true then the driver continues to evaluate the remaining blocks if they exist, or copies this frame to
    /// user mode if this is the only block.  This behavior is identical for all three levels: condition, block 
    /// and filter.
    ///
    /// The action flags are exclusive, i.e., they cannot be set at the same time that could be done by mistake 
    /// In NmCreateOlpFilter where the two flags are combined.
    /// </remarks>
    public enum NmOlpActionFlags : uint
    {
        /// <summary></summary>
        NmOlpActionFlagsNone,
        /// <summary></summary>
        NmOlpActionFlagsCopyOnFalse,
        /// <summary></summary>
        NmOlpActionFlagsDropOnFalse,
        /// <summary></summary>
        NmOlpActionFlagsLast

    };

    ///
    /// <summary><c>NmFilterOptionFlags</c></summary> 
    /// <remarks>
    /// Filter options are used for filter creation only.
    ///
    /// NmFilterOptionFlagsBlockTypeAnd specifies the logical operation among all blocks contained in the filter 
    /// and the opposite logical operation is performed among all the OLP conditions in each block.
    /// 
    /// NmFilterOptionFlagsAndToNext specifies the logical operation between this filter and the next. Note that 
    /// multiple filters are evaluated in the order that they are added.  If filter A is added first followed by 
    /// filter B, A is evaluated first.  By default, when this flag is not set, A is OR'd with B.
    /// 
    /// A is AND'd with B if NmFilterOptionFlagsAndToNext is set in filter A during creation.  The frames are dropped 
    /// if A fails; B will be evaluated if A passes.
    ///
    /// If there are filters A, B and C, and A has NmFilterOptionFlagsAndToNext set, the logic is A AND B OR C, i.e., it 
    /// Only affect the operation between the two adjacent filters, given they are added in order of A, B and C.
    ///
    /// NmFilterOptionFlagsBlockTypeAnd and NmFilterOptionFlagsAndToNext are not exclusive to each other.  They can 
    /// also be combined with NmOlpActionFlags during filter creation.  NmOlpActionFlags override NmFilterOptionFlags
    /// when the action criteria is met.  The NmOlpActionFlags are in the lower WORD of the combined flags.
    ///
    /// </remarks>
    public enum NmFilterOptionFlags : uint
    {
        /// <summary></summary>
        NmFilterOptionFlagsNone,
        /// <summary>
        /// If set, the blocks contained in the filter are AND together.
        /// </summary>
        NmFilterOptionFlagsBlockTypeAnd = 0x00010000,
        /// <summary>
        /// If set, the current filter is AND to the next filter if exist; otherwise 
        /// It is OR to the next filter
        /// </summary>
        NmFilterOptionFlagsAndToNext = 0x00020000,
        /// <summary></summary>
        NmFilterOptionFlagsLast

    };

    ///
    /// <summary><c>NmFilterMatchMode</c>Filter match mode for TRUE</summary> 
    /// <remarks>
    /// NmFilterMatchModeEqual:     return TRUE if pattern matches the frame data.
    /// NmFilterMatchModeNotEqual:  return TRUE if pattern does not match the frame data.
    /// NmFilterMatchModeGreater:   return TRUE if pattern is greater than the frame data.
    /// NmFilterMatchModeLesser:    return TRUE if pattern is less than the frame data.
    /// </remarks>
    public enum NmFilterMatchMode : uint
    {
        /// <summary></summary>
        NmFilterMatchModeNone,
        /// <summary></summary>
        NmFilterMatchModeEqual,
        /// <summary></summary>
        NmFilterMatchModeNotEqual,
        /// <summary></summary>
        NmFilterMatchModeGreater,
        /// <summary></summary>
        NmFilterMatchModeLesser,
        /// <summary></summary>
        NmFilterMatchModeLast

    };

    ///
    /// <summary><c>NM_CAPTURE_STATISTICS</c></summary> 
    /// <remarks>
    /// The statistics is per adapter in API.  To get that for the whole engine, caller can
    /// Sum up all capturing adapters.
    /// 
    /// The EngineDropCount is drop count caused by capture engine in user mode for each adapter.
    /// </remarks>
    public struct NM_CAPTURE_STATISTICS
    {
        /// <summary>
        /// For version control
        /// </summary>
        public System.UInt16 Size;
        /// <summary>
        /// The frame drop count in driver
        /// </summary>
        public System.UInt64 DriverDropCount;
        /// <summary>
        /// The count of frames that are filtered by driver.
        /// </summary>
        public System.UInt64 DriverFilteredCount;
        /// <summary>
        /// The count of frames that have be seen in driver.
        /// </summary>
        public System.UInt64 DriverSeenCount;
        /// <summary>
        /// The frame drop count in capture engine.
        /// </summary>
        public System.UInt64 EngineDropCount;

    };

    ///
    /// <summary><c>CNmPropertyStorageKey</c></summary> 
    /// <remarks>
    /// The top three fields are marshaled to native code.
    /// Create key using the provided methods according to the key types 
    /// (number, string or byte array.)
    /// </remarks>
    /// <example>
    /// <code>
    /// CNmPropertyStorageKey [] keyArray = new CNmPropertyStorageKey[3];
    /// CNmPropertyStorageKey key0 = new CNmPropertyStorageKey();
    /// CNmPropertyStorageKey key1 = new CNmPropertyStorageKey();
    /// CNmPropertyStorageKey key2 = new CNmPropertyStorageKey();
    /// NmPropertyValueType vType;
    /// int myInt;
    /// // Build a Number key
    /// key0.SetNumberKey(0x9a);
    /// // Build a string key
    /// key1.SetStringKey("MyKey");
    /// // build a blob key
    /// byte [] keyBuffer = new byte[16];
    /// for (int i = 0; i < 16; ++i)
    /// {
    ///    keyBuffer[i] = (byte)i;
    /// }
    /// key2.SetByteArrayKey(keyBuffer, 16);
    /// keyArray[0] = key0;
    /// keyArray[1] = key1;
    /// keyArray[2] = key2;
    /// </code>
    /// </example>
    public struct CNmPropertyStorageKey
    {
        public NmMvsKeyType KeyType;
        public int Length;
        public System.IntPtr ValuePointer;

        /// <summary>
        /// For multi-value storage key in string form
        /// </summary>
        public void SetStringKey(String KeyValue)
        {
            if (null != KeyValue)
            {
                KeyType = NmMvsKeyType.MvsKeyTypeString;
                ValuePointer = Marshal.StringToHGlobalUni(KeyValue);
                Length = KeyValue.Length;
            }
            else
            {
                throw new System.ArgumentNullException("NULL String pointer");
            }
        }

        /// <summary>
        /// For multi-value storage key in numeric form (64-bit)
        /// </summary>
        public void SetNumberKey(Int64 KeyValue)
        {
            KeyType = NmMvsKeyType.MvsKeyTypeNumber;
            ValuePointer = Marshal.AllocHGlobal(8);
            Marshal.WriteInt64(ValuePointer, KeyValue);
            Length = 8;
        }

        /// <summary>
        /// For property in Array
        /// </summary>
        public void SetIndexKey(Int64 KeyValue)
        {
            KeyType = NmMvsKeyType.MvsKeyTypeArrayIndex;
            ValuePointer = Marshal.AllocHGlobal(8);
            Marshal.WriteInt64(ValuePointer, KeyValue);
            Length = 8;
        }

        /// <summary>
        /// For multi-value storage key in byte array form
        /// </summary>
        public void SetByteArrayKey(byte[] KeyValue, Int32 KeyLength)
        {
            if (null != KeyValue)
            {
                KeyType = NmMvsKeyType.MvsKeyTypeByteArray;
                ValuePointer = Marshal.AllocHGlobal(KeyLength);
                for (int i = 0; i < KeyLength; ++i)
                {
                    Marshal.WriteByte(ValuePointer, i, KeyValue[i]);
                }
                Length = KeyLength;
            }
            else
            {
                throw new System.ArgumentNullException("NULL KeyValue Byte Array.");
            }
        }
    };

    ///
    /// <summary><c>NM_NPL_PROPERTY_INFO</c></summary> 
    /// <remarks>
    /// Contains runtime information for instantiated properties
    /// </remarks>
    ///
    public struct NM_NPL_PROPERTY_INFO
    {
        /// <summary>
        /// For version control
        /// </summary>
        public System.UInt16 Size;
        /// <summary>
        /// Property Scope
        /// </summary>
        public NmPropertyScope Scope;
        /// <summary>
        /// Property container type, e.g., MVS, Array.
        /// </summary>
        public NmPropertyContainerType ContainerType;
        /// <summary>
        /// The element count of the name excluding the terminator
        /// </summary>
        public System.UInt16 NameSize;
        /// <summary>
        /// Property string added by NmAddProperty
        /// </summary>
        [MarshalAs(UnmanagedType.LPWStr)]
        public System.String Name;
        /// <summary>
        /// The data type of the property
        /// </summary>
        public NmPropertyValueType ValueType;
        /// <summary>
        /// The size of the value.  If the value type is string, the terminator is not included.
        /// </summary>
        public System.UInt32 ValueSize;
        /// <summary>
        /// number of items in Array.
        /// </summary>
        public System.UInt32 ItemCount;

    };

    ///
    /// <summary><c>NmFragmentationInfo</c>Fragmentation information returned in parsed frames</summary> 
    /// <remarks>
    /// </remarks>
    public struct NmFragmentationInfo
    {
        /// <summary>
        /// </summary>
        public UInt16 Size;

        /// <summary>
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] FragmentedProtocolName;

        /// <summary>
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] PayloadProtocolName;

        /// <summary>
        /// </summary>
        public NmFrameFragmentationType FragmentType;
    };

    /// <summary>
    /// Callback function for frame receiving/retrieving
    /// </summary>
    public delegate void CaptureCallbackDelegate(IntPtr hCaptureEngine,
                                                 UInt32 ulAdapterIndex,
                                                 IntPtr pCallerContext,
                                                 IntPtr hFrame);



    ///
    /// <summary><c>NmConversationOption</c>Frame parser conversation configuration options</summary> 
    /// <remarks>
    /// </remarks>
    public enum NmConversationConfigOption : uint
    {
        /// <summary>
        /// </summary>
        None,
        /// <summary>
        /// </summary>
        Last
    };

    ///
    /// <summary><c>NmReassemblyOption</c>Frame parser reassembly configuration options</summary> 
    /// <remarks>
    /// </remarks>
    public enum NmReassemblyConfigOption : uint
    {
        /// <summary>
        /// </summary>
        None,
        /// <summary>
        /// </summary>
        Last
    };

    /// <summary>
    /// Callback function for parser compile/build process.
    /// </summary>
    public delegate void ParserCallbackDelegate(IntPtr pCallerContext,
                                                UInt32 ulStatusCode,
                                                [MarshalAs(UnmanagedType.LPWStr)] String lpDescription,
                                                NmCallbackMsgType ulType);

    /// <summary>
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NM_NIC_ADAPTER_INFO
    {
        /// <summary>
        /// </summary>
        public System.UInt16 Size;

        /// <summary>
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst = NmConstant.MAC_ADDRESS_SIZE)]
        public System.Byte[] PermanentAddr;
        /// <summary>
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U1, SizeConst = NmConstant.MAC_ADDRESS_SIZE)]
        public System.Byte[] CurrentAddr;

        /// <summary>
        /// </summary>
        public NDIS_MEDIUM MediaType;

        /// <summary>
        /// </summary>
        public NDIS_PHYSICAL_MEDIUM PhysicalMediaType;

        /// <summary>
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] ConnectionName;
        /// <summary>
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] FriendlyName;
        /// <summary>
        /// </summary>
        [MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.U2, SizeConst = NmConstant.MAX_PATH)]
        public System.Char[] Guid;

        ///
        /// Network adapter operational state. Indicates if the network adapter is bound, capturing, pause or stopped
        ///
        public NmAdapterOpState OpState;
        ///
        /// Indicates if the network adapter is enabled or disabled. It only can be enabled if it is bound to the Network Monitor driver
        ///
        public System.Int32 Enabled;

        /// <summary>
        /// </summary>
        public System.Int32 PModeEnabled;

        ///
        /// Frame indication callback is assigned by adapter
        ///
        [MarshalAs(UnmanagedType.FunctionPtr)]
        public CaptureCallbackDelegate CallBackFunction;
    };

    /// <summary>
    ///
    /// </summary>
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NM_API_CONFIGURATION
    {
        ///
        /// Configurable limits that overwrite default API settings 
        ///
        public System.UInt16 Size;
        /// <summary>
        /// </summary>
        public System.UInt32 RawFrameHandleCountLimit;
        /// <summary>
        /// </summary>
        public System.UInt32 ParsedFrameHandleCountLimit;
        /// <summary>
        /// </summary>
        public System.UInt32 CaptureEngineCountLimit;
        /// <summary>
        /// </summary>
        public System.UInt32 NplParserCountLimit;
        /// <summary>
        /// </summary>
        public System.UInt32 FrameParserConfigCountLimit;
        /// <summary>
        /// </summary>
        public System.UInt32 FrameParserCountLimit;
        /// <summary>
        /// </summary>
        public System.UInt32 CaptureFileCountLimit;

        ///
        /// API threading mode for COM initialization.  
        /// Only support COINIT_MULTITHREADED and COINIT_APARTMENTTHREADED
        ///
        public System.UInt16 ThreadingMode;

        ///
        /// Configurable default feature/behavior parameters
        ///
        public NmConversationConfigOption ConversationOption;
        /// <summary>
        /// </summary>
        public NmReassemblyConfigOption ReassemblyOption;
        /// <summary>
        /// </summary>
        public NmCaptureFileFlag CaptureFileMode;
        /// <summary>
        /// </summary>
        public NmFrameParsingOption FrameParsingOption;
        /// <summary>
        /// </summary>
        public NmCaptureCallbackExitMode CaptureCallbackExitMode;

        ///
        /// Hard limits the API enforce (not configurable)
        ///
        public System.UInt32 MaxCaptureFileSize;
        /// <summary>
        /// </summary>
        public System.UInt32 MinCaptureFileSize;

        /// Maximum number of handles per handle type  
        public System.UInt32 MaxApiHandleLimit;
    };

    ///
    /// <summary><c>NM_PROTOCOL_SEQUENCE_CONFIG</c>Data structure for API user to specify NPL properties and fields
    ///                                            For frame order correction support.
    /// </summary> 
    /// <remarks>
    /// </remarks>
    ///
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NM_PROTOCOL_SEQUENCE_CONFIG
    {
        ///
        /// API verifies the member 'Size' against the size of its version.  They must match.
        ///
        public UInt16 Size;

        ///
        /// The names of the properties containing the values to form the key 
        /// to identify the group of the frames to get in order.  If multiple names are used,
        /// They are separated by semicolons.  The string must be NULL terminated.
        ///
        [MarshalAs(UnmanagedType.LPWStr)]
        public String GroupKeyString;

        ///
        /// The name of the property containing the frame's sequence number.
        ///
        [MarshalAs(UnmanagedType.LPWStr)]
        public String SequencePropertyString;

        ///
        /// The name of the property containing the frame's next sequence number.
        ///
        [MarshalAs(UnmanagedType.LPWStr)]
        public String NextSequencePropertyString;

    };

    ///
    /// <summary><c>NM_ORDER_PARSER_PARAMETER</c>Data structure for calling NmOpCaptureFileInOrder</summary>
    /// 
    /// <remarks>
    /// </remarks>
    ///
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NM_ORDER_PARSER_PARAMETER
    {
        ///
        /// API verifies the member 'Size' against the size of its version.  They must match.
        ///
        public UInt16 Size;

        ///
        /// The frame parser used for handling out of order frames.  It must be built from a frame parser
        /// Configuration that has sequence information specified by NM_PROTOCOL_SEQUENCE_CONFIG.
        ///
        public IntPtr hFrameParser;

        ///
        /// For future option flags.
        ///
        public UInt32 Option;

    };

    /// <summary>
    /// </summary>
    public enum NDIS_MEDIUM
    {
        /// <summary>
        /// </summary>
        Ndis_802_3,
        /// <summary>
        /// </summary>
        Ndis_802_5,
        /// <summary>
        /// </summary>
        Ndis_Fddi,
        /// <summary>
        /// </summary>
        Ndis_Wan,
        /// <summary>
        /// </summary>
        Ndis_LocalTalk,
        /// <summary>
        /// </summary>
        Ndis_Dix,              // defined for convenience, not a real medium
        /// <summary>
        /// </summary>
        Ndis_ArcnetRaw,
        /// <summary>
        /// </summary>
        Ndis_Arcnet878_2,
        /// <summary>
        /// </summary>
        Ndis_Atm,
        /// <summary>
        /// </summary>
        Ndis_WirelessWan,
        /// <summary>
        /// </summary>
        Ndis_Irda,
        /// <summary>
        /// </summary>
        Ndis_Bpc,
        /// <summary>
        /// </summary>
        Ndis_CoWan,
        /// <summary>
        /// </summary>
        Ndis_1394,
        /// <summary>
        /// </summary>
        Ndis_InfiniBand,
        /// <summary>
        /// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
        /// </summary>
        Ndis_Tunnel,
        /// <summary>
        /// </summary>
        Ndis_Native802_11,
        /// <summary>
        /// </summary>
        Ndis_Loopback,
        /// <summary>
        /// #endif // (NTDDI_VERSION >= NTDDI_VISTA)
        /// </summary>
        NdisMediumMax               // Not a real medium, defined as an upper-bound
    };


    /// <summary>
    /// </summary>
    public enum NDIS_PHYSICAL_MEDIUM
    {
        /// <summary>
        /// </summary>
        Ndis_Unspecified,
        /// <summary>
        /// </summary>
        Ndis_WirelessLan,
        /// <summary>
        /// </summary>
        Ndis_CableModem,
        /// <summary>
        /// </summary>
        Ndis_PhoneLine,
        /// <summary>
        /// </summary>
        Ndis_PowerLine,
        /// <summary>
        /// includes ADSL and UADSL (G.Lite)
        /// </summary>
        Ndis_DSL,
        /// <summary>
        /// </summary>
        Ndis_FibreChannel,
        /// <summary>
        /// </summary>
        Ndis_1394,
        /// <summary>
        /// </summary>
        Ndis_WirelessWan,
        /// <summary>
        /// </summary>
        Ndis_Native802_11,
        /// <summary>
        /// </summary>
        Ndis_Bluetooth,
        /// <summary>
        /// </summary>
        Ndis_Infiniband,
        /// <summary>
        /// </summary>
        Ndis_WiMax,
        /// <summary>
        /// </summary>
        Ndis_UWB,
        /// <summary>
        /// </summary>
        Ndis_802_3,
        /// <summary>
        /// </summary>
        Ndis_802_5,
        /// <summary>
        /// </summary>
        Ndis_Irda,
        /// <summary>
        /// </summary>
        Ndis_WiredWAN,
        /// <summary>
        /// </summary>
        Ndis_WiredCoWan,
        /// <summary>
        /// </summary>
        Ndis_Other,
        /// <summary>
        /// </summary>
        NdisPhysicalMediumMax       // Not a real physical type, defined as an upper-bound
    };

    /// <summary>
    /// http://www.marin.clara.net/COM/variant_type_definitions.htm
    /// </summary>
    public class FieldType
    {
        /// <summary>
        /// </summary>
        public const UInt16 VT_EMPTY = 0;
        /// <summary>
        /// </summary>
        public const UInt16 VT_NULL = 1;
        /// <summary>
        /// </summary>
        public const UInt16 VT_I2 = 2;
        /// <summary>
        /// </summary>
        public const UInt16 VT_I4 = 3;
        /// <summary>
        /// </summary>
        public const UInt16 VT_R4 = 4;
        /// <summary>
        /// </summary>
        public const UInt16 VT_R8 = 5;
        /// <summary>
        /// </summary>
        public const UInt16 VT_CY = 6;
        /// <summary>
        /// </summary>
        public const UInt16 VT_DATE = 7;
        /// <summary>
        /// </summary>
        public const UInt16 VT_BSTR = 8;
        /// <summary>
        /// </summary>
        public const UInt16 VT_DISPATCH = 9;
        /// <summary>
        /// </summary>
        public const UInt16 VT_ERROR = 10;
        /// <summary>
        /// </summary>
        public const UInt16 VT_BOOL = 11;
        /// <summary>
        /// </summary>
        public const UInt16 VT_VARIANT = 12;
        /// <summary>
        /// </summary>
        /// <summary>
        /// </summary>
        public const UInt16 VT_UNKNOWN = 13;
        /// <summary>
        /// </summary>
        public const UInt16 VT_DECIMAL = 14;
        /// <summary>
        /// </summary>
        public const UInt16 VT_I1 = 16;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UI1 = 17;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UI2 = 18;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UI4 = 19;
        /// <summary>
        /// </summary>
        public const UInt16 VT_I8 = 20;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UI8 = 21;
        /// <summary>
        /// </summary>
        public const UInt16 VT_INT = 22;
        /// <summary>
        /// </summary>
        public const UInt16 VT_UINT = 23;
        /// <summary>
        /// </summary>
        public const UInt16 VT_VOID = 24;

        /// <summary>
        /// </summary>
        public const UInt16 VT_HRESULT = 25;
        /// <summary>
        /// </summary>
        public const UInt16 VT_PTR = 26;
        /// <summary>
        /// </summary>
        public const UInt16 VT_SAFEARRAY = 27;

        /// <summary>
        /// </summary>
        public const UInt16 VT_CARRAY = 28;
        /// <summary>
        /// </summary>
        public const UInt16 VT_USERDEFINED = 29;
        /// <summary>
        /// </summary>
        public const UInt16 VT_LPSTR = 30;

        /// <summary>
        /// </summary>
        public const UInt16 VT_LPWSTR = 31;
        /// <summary>
        /// </summary>
        public const UInt16 VT_FILETIME = 64;
        /// <summary>
        /// </summary>
        public const UInt16 VT_BLOB = 65;

        /// <summary>
        /// </summary>
        public const UInt16 VT_STREAM = 66;
        /// <summary>
        /// </summary>
        public const UInt16 VT_STORAGE = 67;
        /// <summary>
        /// </summary>
        public const UInt16 VT_STREAMED_OBJECT = 68;

        /// <summary>
        /// </summary>
        public const UInt16 VT_STORED_OBJECT = 69;
        /// <summary>
        /// </summary>
        public const UInt16 VT_BLOB_OBJECT = 70;
        /// <summary>
        /// </summary>
        public const UInt16 VT_CF = 71;

        /// <summary>
        /// </summary>
        public const UInt16 VT_CLSID = 72;
        /// <summary>
        /// </summary>
        public const UInt16 VT_VECTOR = 0x1000;
        /// <summary>
        /// </summary>
        public const UInt16 VT_ARRAY = 0x2000;

        /// <summary>
        /// </summary>
        public const UInt16 VT_BYREF = 0x4000;
        /// <summary>
        /// </summary>
        public const UInt16 VT_RESERVED = 0x8000;
        /// <summary>
        /// </summary>
        public const UInt16 VT_ILLEGAL = 0xffff;

        /// <summary>
        /// </summary>
        public const UInt16 VT_ILLEGALMASKED = 0xfff;
        /// <summary>
        /// </summary>
        public const UInt16 VT_TYPEMASK = 0xfff;
    }

    ///
    /// Returned to caller from NmGetParsedFieldInfo function
    ///     API set the member 'Size' when return for struct version checking purpose
    ///     Member 'NplDataTypeNameLength' and 'ProtocolNameLength' are 0 if not requested by caller when 
    ///     Invoke parsing function.  All string length parameters are in element, e.g., in Unicode here.
    ///
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NmParsedFieldInfo
    {
        ///
        /// API set the member 'Size' when return for struct version checking purpose
        ///
        public System.UInt16 Size;
        ///
        /// The relative level to the root protocol
        ///
        public System.UInt16 FieldIndent;
        ///
        /// The size of the string that holds the full path of the data field if the NmFrameParseOptions 
        /// FieldFullNameRequired is set, e.g., Frame.Ethernet.IPv4.SourceAddress;  Otherwise it is the size
        /// of the current field name only
        ///
        public System.UInt16 NamePathLength;
        ///
        /// The size of the string that contains the name of the NPL data type if the NmFrameParseOptions 
        /// DataTypeNameRequired is set, e.g., "UINT16";  Otherwise it is zero.
        ///
        public System.UInt16 NplDataTypeNameLength;
        ///
        /// The size of the string tht contains the protocol containing the field if the NmFrameParseOptions 
        /// ContainingProtocolNameRequired is set;  Otherwise it is zero
        ///
        public System.UInt16 ProtocolNameLength;
        ///
        /// The size of the display string of the field if the NmFrameParseOptions 
        /// FieldDisplayStringRequired is set;  Otherwise it is zero
        ///
        public System.UInt16 DisplayStringLength;
        ///
        /// Offset in current protocol
        ///
        public System.UInt32 ProtocolBitOffset;
        ///
        /// Field offset in frame
        ///
        public System.UInt32 FrameBitOffset;
        ///
        /// Length of the field
        ///
        public System.UInt32 FieldBitLength;
        ///
        /// The variant type defined as in VARENUM
        ///
        public System.UInt16 ValueType;
        ///
        /// The size of the buffer required to hold the field value represented in VARIANT struct including
        /// The length of the content if the VARIANT contains a pointer to ARRAY or string.
        ///
        public System.UInt16 ValueBufferLength;
    };

    ///
    /// Returned to caller from NmGetParsedFieldInfoEx function
    ///     API set the member 'Size' when return for struct version checking purpose
    ///     Member 'NplDataTypeNameLength' and 'ProtocolNameLength' are 0 if not requested by caller when 
    ///     Invoke parsing function.  All string length parameters are in element, e.g., in Unicode here.
    ///
    [StructLayout(LayoutKind.Sequential, Pack = 8)]
    public struct NmParsedFieldInfoEx
    {
        ///
        /// API set the member 'Size' when return for struct version checking purpose
        ///
        public System.UInt16 Size;
        ///
        /// The relative level to the root protocol
        ///
        public System.UInt16 FieldIndent;
        ///
        /// The size of the string that holds the full path of the data field if the NmFrameParseOptions 
        /// FieldFullNameRequired is set, e.g., Frame.Ethernet.IPv4.SourceAddress;  Otherwise it is the size
        /// of the current field name only
        ///
        public System.UInt16 NamePathLength;
        ///
        /// The size of the string that contains the name of the NPL data type if the NmFrameParseOptions 
        /// DataTypeNameRequired is set, e.g., "UINT16";  Otherwise it is zero.
        ///
        public System.UInt16 NplDataTypeNameLength;
        ///
        /// The size of the string tht contains the protocol containing the field if the NmFrameParseOptions 
        /// ContainingProtocolNameRequired is set;  Otherwise it is zero
        ///
        public System.UInt16 ProtocolNameLength;
        ///
        /// The size of the display string of the field if the NmFrameParseOptions 
        /// FieldDisplayStringRequired is set;  Otherwise it is zero
        ///
        public System.UInt16 DisplayStringLength;
        ///
        /// Offset in current protocol
        ///
        public System.UInt32 ProtocolBitOffset;
        ///
        /// Field offset in frame
        ///
        public System.UInt32 FrameBitOffset;
        ///
        /// Length of the field
        ///
        public System.UInt32 FieldBitLength;
        ///
        /// The variant type defined as in VARENUM
        ///
        public System.UInt16 ValueType;
        ///
        /// The size of the buffer required to hold the field value represented in VARIANT struct including
        /// The length of the content if the VARIANT contains a pointer to ARRAY or string.
        ///
        public System.UInt32 ValueBufferLength;
    };

    ///
    /// <summary><c>NmSystemTime</c>SYSTEMTIME structure in C++</summary>
    /// 
    /// <remarks>
    /// </remarks>
    ///
    [StructLayout(LayoutKind.Explicit, Size = 16, CharSet = CharSet.Ansi)]
    public class NmSystemTime
    {
        [FieldOffset(0)]
        public ushort wYear;
        [FieldOffset(2)]
        public ushort wMonth;
        [FieldOffset(4)]
        public ushort wDayOfWeek;
        [FieldOffset(6)]
        public ushort wDay;
        [FieldOffset(8)]
        public ushort wHour;
        [FieldOffset(10)]
        public ushort wMinute;
        [FieldOffset(12)]
        public ushort wSecond;
        [FieldOffset(14)]
        public ushort wMilliseconds;
    }

    ///
    /// <summary><c>TIME_ZONE_INFORMATION</c>Same data structure in C++</summary>
    /// 
    /// <remarks>
    /// </remarks>
    ///
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct TIME_ZONE_INFORMATION
    {
        [MarshalAs(UnmanagedType.I4)]
        public int Bias;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 0x20)]
        public string StandardName;
        public NmSystemTime StandardDate;
        [MarshalAs(UnmanagedType.I4)]
        public int StandardBias;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 0x20)]
        public string DaylightName;
        public NmSystemTime DaylightDate;
        [MarshalAs(UnmanagedType.I4)]
        public int DaylightBias;
    }


    ///
    /// <summary><c>NM_TIME</c>Data structure for NmGetFrameTimeStampEx and NmBuildRawFrameFromBufferEx function</summary>
    /// 
    /// <remarks>
    /// </remarks>
    ///
    [StructLayout(LayoutKind.Sequential, Pack = 4)]
    public struct NM_TIME
    {
        ///
        /// Size of structure that is set by the caller.
        ///
        public System.Int32 NmTimeStampSize;
        ///
        /// UTC Time Stamp.
        ///
        public System.Int64 TimeStamp;
        ///
        /// TRUE if the time is originally UTC. FALSE if the time was local and converted to UTC.
        ///
        public System.Boolean IsUTC;
        ///
        /// TRUE if the time zone information exists.
        ///
        public System.Boolean HasTZI;
        ///
        /// Time zone information for the frame.
        /// If TRUE == isUTC and TRUE == hasTZI, TZI contains correct time zone information
        /// If TRUE == isUTC and FALSE == hasTZI, TZI does not contain time zone information
        /// if FALSE == isUTC and FALSE == hasTZI, Time stamp is originally local time and converted to UTC using LocalFileTimeToFileTime(). TZI does not contain time zone information.
        /// If FALSE == isUTC and TRUE == hasTZI, At the moment, there is no scenario to be this case.
        ///
        public TIME_ZONE_INFORMATION TZI;
    };

    /// <summary><c>NmNplProfileAttribute</c></summary> 
    /// <remarks>
    /// The NmNplProfileAttribute enumeration is used to select which string the profile should return when
    /// using the SetNplProfileAttribute and GetNplProfileAttribute methods.
    /// </remarks>
    public enum NmNplProfileAttribute
    {
        NmNplProfileAttributeName,
        NmNplProfileAttributeGuid,
        NmNplProfileAttributeDescription,
        NmNplProfileAttributeIncludePath,
        NmNplProfileAttributeDirectory,
        NmNplProfileAttributePackageName,
        NmNplProfileAttributePackageVersion,
        NmNplProfileAttributePackageGuid,
        NmNplProfileAttributeDependencies,
        NmNplProfileAttributeTypeDescription,
    };



    #endregion

    /// <summary>
    /// PInvoke wrapper of Network Monitor API.
    ///     - managed/unmanaged data type mapping: http://msdn2.microsoft.com/en-us/library/ac7ay120.aspx
    ///     - the declaration in this class are strongly tied to nmapi.h
    /// </summary>
    public class NetmonAPI
    {
        #region API Operations

        /// <summary><c>NmGetApiVersion</c>Query current version</summary> 
        /// <remarks>
        /// The API version matches Network Monitor engine version.
        /// </remarks>
        /// <example>
        /// <code>
        ///     UInt16 majorNumber = 0;
        ///     UInt16 minorNumber = 0;
        ///     UInt16 BuildNumber = 0;
        ///     UInt16 RevisionNumber = 0;
        ///     NmGetApiVersion(out majorNumber, out minorNumber, out BuildNumber, out RevisionNumber);
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="Major">[out] Major version number</param>
        /// <param name="Minor">[out] Minor version number</param>
        /// <param name="Build">[out] Build number</param>
        /// <param name="Revision">[out] Revision number</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>Return nothing</returns>
        [DllImport("NmApi.Dll")]
        public static extern void NmGetApiVersion(out UInt16 Major, out UInt16 Minor, out UInt16 Build, out UInt16 Revision);

        /// <summary><c>NmGetApiConfiguration</c>Return current API configuration parameters</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        ///    NM_API_CONFIGURATION apiConfig = new NM_API_CONFIGURATION();
        ///    apiConfig.Size = (ushort)System.Runtime.InteropServices.Marshal.SizeOf(typeof(NM_API_CONFIGURATION));
        ///    uint status = NetmonAPI.NmGetApiConfiguration(ref apiConfig);
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ApiConfig">[out] Struct object for API to fill</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     NM_STATUS_API_VERSION_MISMATCHED: The version of NM_API_CONFIGURATION struct is different
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetApiConfiguration(ref NM_API_CONFIGURATION ApiConfig);

        /// <summary><c>NmApiInitialize</c>Overwrite default configuration.</summary> 
        /// <remarks>
        /// Caller needs to provide storage for NmApiConfiguration struct.
        /// </remarks>
        /// <example>
        /// <code>
        ///    NM_API_CONFIGURATION apiConfig = new NM_API_CONFIGURATION();
        ///    apiConfig.Size = (ushort)System.Runtime.InteropServices.Marshal.SizeOf(typeof(NM_API_CONFIGURATION));
        ///    uint status = NetmonAPI.NmGetApiConfiguration(ref apiConfig);
        ///    apiConfig.ThreadingMode = 0;
        ///    status = NetmonAPI.NmApiInitialize(ref apiConfig);
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ApiConfig">[in] Caller specified API configuration parameter struct</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     NM_STATUS_API_VERSION_MISMATCHED: The version of NM_API_CONFIGURATION struct is different
        ///     ERROR_INVALID_STATE: Cannot change API configuration
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmApiInitialize(ref NM_API_CONFIGURATION ApiConfig);

        /// <summary><c>NmApiClose</c>Release API resources</summary> 
        /// <remarks>
        /// Should be called when done with the API
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmApiClose();

        /// <summary><c>NmCloseHandle</c> Release the reference to the object by handle</summary> 
        /// <remarks>
        /// Callers need to close all the object handles returned from API after finish using them.
        /// </remarks>
        /// <exception>None</exception>
        /// <param name="hObjectHandle"> [in] Handle to the object to release </param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>Void</returns>
        [DllImport("NmApi.Dll")]
        public static extern void NmCloseHandle(IntPtr hObjectHandle);
        
        #endregion

        #region Capture Engine Operations

        /// <summary><c>NmOpenCaptureEngine</c>Open a capture engine</summary> 
        /// <remarks>
        /// 
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="phCaptureEngine">[out] The returned handle to the capture engine object on success</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_INVALID_STATE:     The operation is not available.
        ///     ERROR_ENOUGH_MEMORY: Fail to allocate memory for the object.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmOpenCaptureEngine(out IntPtr phCaptureEngine);

        /// <summary><c>NmGetAdapterCount</c>Return number of the adapters that the capture engine can access</summary> 
        /// <remarks>
        /// 
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ExitMode">[in] The callback function exit mode</param>
        /// <param name="hCaptureEngine">[in] The capture engine under query</param>
        /// <param name="ulCount">[out] The returned count of adapters</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetAdapterCount(IntPtr hCaptureEngine, out UInt32 ulCount);

        /// <summary><c>NmGetAdapter</c>Get adapter information from the capture engine</summary> 
        /// <remarks>
        /// Caller can use name, GUID etc. to select adapter to use.  The adapter index should be within the 
        /// Range returned by NmGetAdapterCount method.  Caller needs to provide the storage of the
        /// NmNicAdapterInfo struct.
        /// The fix sized name buffers in the NM_NIC_ADAPTER_INFO structure are marshal to System.char[]. 
        /// Use String nameStr = new String("e.g., whateverDefinedStructName.ConnectionName") to translate the char array to a string object.
        /// </remarks>
        /// <example>
        /// <code>
        ///    IntPtr hCaptureEngine = HandleReturnedByNmOpenCaptureEngine;
        ///    UInt32 ulIndex = 0;
        ///    NM_NIC_ADAPTER_INFO adapterInfo = new NM_NIC_ADAPTER_INFO();
        ///    adapterInfo.Size = (ushort)System.Runtime.InteropServices.Marshal.SizeOf(adapterInfo);
        ///    uint status = NetmonAPI.NmGetAdapter(hCaptureEngine, ulIndex, ref adapterInfo);
        ///    String nameStr = new String(adapterInfo.ConnectionName);
        /// </code>
        /// </example>
        /// <param name="ExitMode">[in] The callback function exit mode</param>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The handle of the capture engine object</param>
        /// <param name="ulIndex">[in] The index number of the adapter to retrieve</param>
        /// <param name="pNMAdapterInfo">[out] The returned adapter information struct</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     NM_STATUS_API_VERSION_MISMATCHED: The version of NM_NIC_ADAPTER_INFO struct is different
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetAdapter(IntPtr hCaptureEngine, UInt32 ulIndex, ref NM_NIC_ADAPTER_INFO pNMAdapterInfo);

        /// <summary><c>NmConfigAdapter</c>Configure the adapter with the frame indication callback and the caller context.</summary> 
        /// <remarks>
        /// The current callback function and context will overwrite the previous ones.  The adapter index number
        /// Must be in the range returned from NmGetAdapterCount method.
        /// </remarks>
        /// <example> Description
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The handle to the target capture engine</param>
        /// <param name="ulIndex">[in] The index number of the target adapter</param>
        /// <param name="CallbackFunction">[in] The frame indication callback function pointer to set</param>
        /// <param name="pCallerContext">[in] The caller context pointer</param>
        /// <param name="ExitMode">[in] The callback function exit mode</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmConfigAdapter(IntPtr hCaptureEngine, UInt32 ulIndex, CaptureCallbackDelegate CallbackFunction, IntPtr pCallerContext, NmCaptureCallbackExitMode ExitMode);
        
        /// <summary><c>NmStartCapture</c>Start capture on the specified capture engine and adapter</summary> 
        /// <remarks>
        /// Capture mode can be PMODE and LocalOnly.
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The handle to the target capture engine</param>
        /// <param name="ulAdapterIndex">[in] The index number of the target adapter</param>
        /// <param name="CaptureMode">[in] The capture mode, PMODE or LOCAL_ONLY</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found capture engine or adapter specified
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmStartCapture(IntPtr hCaptureEngine, UInt32 ulAdapterIndex, NmCaptureMode CaptureMode);

        /// <summary><c>NmPauseCapture</c>Pause the capture</summary> 
        /// <remarks>
        /// 
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The handle to the target capture engine</param>
        /// <param name="ulAdapterIndex">[in] The index number of the target adapter</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_INVALID_STATE: Cannot pause at current state
        ///     ERROR_NOT_FOUND: not found capture engine or adapter specified
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmPauseCapture(IntPtr hCaptureEngine, UInt32 ulAdapterIndex);


        /// <summary><c>NmResumeCapture</c>Resume the capture that is previously paused</summary> 
        /// <remarks>
        /// Cannot resume after NmStopCapture is called.  The frame indication callback is no longer invoked 
        /// Until NmResumeCapture method is called
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The handle to the target capture engine</param>
        /// <param name="ulAdapterIndex">[in] The index number of the target adapter</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_INVALID_STATE: Cannot resume at current state
        ///     ERROR_NOT_FOUND: not found capture engine or adapter specified
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmResumeCapture(IntPtr hCaptureEngine, UInt32 ulAdapterIndex);

        /// <summary><c>NmStopCapture</c>Stop capture on given capture engine and adapter</summary> 
        /// <remarks>
        /// The frame indication callback is no longer invoked after this function returns.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The handle to the target capture engine</param>
        /// <param name="ulAdapterIndex">[in] The index number of the target adapter</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_INVALID_STATE: Cannot stop at current state
        ///     ERROR_NOT_FOUND: not found capture engine or adapter specified
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmStopCapture(IntPtr hCaptureEngine, UInt32 ulAdapterIndex);
        #endregion
      
        #region Parsing Functions
        
        /// <summary><c>NmLoadNplParser</c>Load NPL scripts and create NPL parser</summary> 
        /// <remarks>
        /// Callback function is invoked for compile error/warning/info.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pFileName">[in] The start parser script file name</param>
        /// <param name="ulFlags">[in] Option flags</param>
        /// <param name="CallbackFunction">[in] The parser compiler error callback function pointer</param>
        /// <param name="pCallerContext">[in] The caller context pointer that will be passed back to the callback function</param>
        /// <param name="phNplParser">[Out] The returned handle to the NPL parser object</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_ENOUGH_MEMORY: Fail to create NPL parser object
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmLoadNplParser([MarshalAs(UnmanagedType.LPWStr)] String pFileName, NmNplParserLoadingOption ulFlags, ParserCallbackDelegate CallbackFunction, IntPtr pCallerContext, out IntPtr phNplParser);
        
        /// <summary><c>NmCreateFrameParserConfiguration</c>Create frame parser configuration that contains the filter and field configuration</summary> 
        /// <remarks>
        /// All the frame parser features including conversation and reassembly must be added in the configuration before creating the frame parser.
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hNplParser">[in] The handle of the NPL parser used for the frame parser</param>
        /// <param name="CallbackFunction">[in] The compiler error callback function pointer</param>
        /// <param name="pCallerContext">[in] The caller context pointer that will be passed back to the callback function</param>
        /// <param name="phFrameParserConfiguration">[out] The returned handle of the frame parser configuration object</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_ENOUGH_MEMORY: Fail to create frame parser configuration object.
        ///     ERROR_NOT_FOUND: not found specified NPL parser
        ///     
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateFrameParserConfiguration(IntPtr hNplParser, ParserCallbackDelegate CallbackFunction, IntPtr pCallerContext, out IntPtr phFrameParserConfiguration);
 
        /// <summary><c>NmAddFilter</c>Add filter for optimizing frame parser</summary> 
        /// <remarks>
        /// The filter id is used to evaluate the state of the filter on a parsed frame.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] The handle of the frame parser configuration object</param>
        /// <param name="pFilterString">[in] The text of the filter</param>
        /// <param name="ulFilterId">[out] The returned filter index in the frame parser</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddFilter(IntPtr hFrameParserConfiguration, [MarshalAs(UnmanagedType.LPWStr)] String pFilterString, out UInt32 ulFilterId);

        /// <summary><c>NmAddField</c>Add field for optimizing frame parser</summary> 
        /// <remarks>
        /// All the fields are enumerated in the parsed frame if no field is added.  The field id is used to retrieve the field 
        /// In the parsed frame.  Caller needs to provide unique fully qualified field name, e.g., TCP.Option.Ack.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] The handle of the frame parser configuration object</param>
        /// <param name="pFieldString">[in] The fully qualified name string of the field</param>
        /// <param name="ulFieldId">[out] The returned field index in the frame parser</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddField(IntPtr hFrameParserConfiguration, [MarshalAs(UnmanagedType.LPWStr)] String pFieldString, out UInt32 ulFieldId);

        /// <summary><c>NmAddProperty</c>Add a property to the configuration.</summary> 
        /// <remarks>
        /// The property name should have scope prefix such as Conversation, Global, etc.  If not specified, 
        /// The frame property is the default scope.
        /// </remarks>
        /// <example> This sample shows how to call the NmAddProperty method.
        /// <code>
        ///     IntPtr hFrameParserConfiguration;
        ///     UInt32 myPropID;
        ///     NetmonAPI.NmAddProperty(hFrameParserConfiguration, "Property.TCPPayloadLength", out myPropID);
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] Frame Parser Configuration Handle</param>
        /// <param name="pName">[in] Fully qualified name of the property.</param>
        /// <param name="pulPropertyId">[out] Returned ID used to reference the property.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration
        ///     ERROR_INVALID_PARAMETER: The specified property name is invalid
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddProperty(IntPtr hFrameParserConfiguration, [MarshalAs(UnmanagedType.LPWStr)] String pPropertyString, out UInt32 ulPropertyId);

        /// <summary><c>NmAddSequenceOrderConfig</c>Add protocol sequence order configurations</summary> 
        /// <remarks>
        /// </remarks>
        /// <example> Description
        /// <code>
        ///     
        ///     
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] The handle of the frame parser configuration object</param>
        /// <param name="SeqConfig">[in] Caller provided sequence configuration data</param>
        /// <param name="ulConfigId">[out] The retrieval ID of the configuration added to the frame parser configuration</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: NULL pointer
        ///     ERROR_NOT_ENOUGH_MEMORY: Fail to allocate memory to store the configuration.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddSequenceOrderConfig(IntPtr hFrameParserConfiguration, ref NM_PROTOCOL_SEQUENCE_CONFIG SeqConfig, out UInt32 ulConfigId);

        /// <summary><c>NmConfigReassembly</c>Enable or disable reassembly</summary> 
        /// <remarks>
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] The handle of the frame parser configuration object</param>
        /// <param name="Option">[in] Reassembly options</param>
        /// <param name="bEnable">[in] Action to take, enable or disable</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or option
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmConfigReassembly(IntPtr hFrameParserConfiguration, NmReassemblyConfigOption Option, Boolean bEnable);

        /// <summary><c>NmConfigConversation</c>Configure conversation options</summary> 
        /// <remarks>
        /// </remarks>
        /// <example> Description
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] The handle of the frame parser configuration object</param>
        /// <param name="Option">[in] conversation configuration options</param>
        /// <param name="bEnable">[in] Action to take, enable or disable</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or option
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmConfigConversation(IntPtr hFrameParserConfiguration, NmConversationConfigOption Option, Boolean bEnable);


        /// <summary><c>NmCreateFrameParser</c>Create frame parser with the given configuration</summary> 
        /// <remarks>
        /// The optimization option is set to NmParserOptimizeNone by default that no optimization is applied.
        /// The existing native applications do not need to recompile.  The new application can take advantage of this flag to 
        /// Force optimization in the scenario where no field is added.  Without this option, the caller can only get a non-optimized 
        /// Parser so that all the fields are included in the parsed frame.  With this option, an optimized frame parser can be
        /// generated to serve the dedicated filtering scenarios.
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] The handle of the source frame parser configuration object</param>
        /// <param name="phParser">[out] The frame parser</param>
        /// <param name="OptimizeOption">[in] The optimization flag</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateFrameParser(IntPtr hFrameParserConfiguration, out IntPtr phParser, NmFrameParserOptimizeOption OptimizeOption);


        /// <summary><c>NmConfigStartDataType</c>Configure start data type</summary> 
        /// <remarks>
        /// By default, the frame parser starts parsing a frame from the Network Monitor built-in protocol "Frame".
        /// This function lets the caller set the data type to start at.  This is useful for parsing an arbitrary
        /// Data buffer with a frame parser starting from the data type that is configured with this function.
        /// </remarks>
        /// <example> Description
        /// <code>
        ///     
        ///     
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] The handle of the target frame parser configuration object</param>
        /// <param name="StartDataTypeName">[in] The name of the data type that the created frame parser starts with</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration
        ///     ERROR_INSUFFICIENT_BUFFER: The given start type name is longer than 260 characters.
        /// </returns>
        /// 
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmConfigStartDataType(IntPtr hFrameParserConfiguration, [MarshalAs(UnmanagedType.LPWStr)] String StartDataTypeName);


        /// <summary><c>NmGetStartDataType</c>Return the start data type of the given frame parser configuration</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParserConfiguration">[in] The handle of the target frame parser configuration object</param>
        /// <param name="ulBufferLength">[in] The element length of the caller provided buffer</param>
        /// <param name="pBuffer">[out] The name of the data type that the created frame parser starts with</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser configuration
        ///     ERROR_INSUFFICIENT_BUFFER: The given buffer is not big enough to hold the start data type name string.
        /// </returns>
        /// 
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetStartDataType(IntPtr hFrameParserConfiguration, UInt32 ulBufferLength, char* pBuffer);


        #endregion

        #region Parsed Frame Operations
        /// <summary><c>NmParseFrame</c>Parse the raw Network Monitor frame and return it in parsed format</summary> 
        /// <remarks>
        /// The parsed frame contains the frame information, filter state and enumeration of field.  When reassembly is
        /// Enabled, the last fragment of the payload completing the reassembly process and insert the reasembled raw frame.
        /// The ulFrameNumber parameter is for conversation or global properties if using frame number as the key.  If the same
        /// Frame number is used for different frames, the properties' values may be overwritten by the last instance.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParser">[in] The handle of the frame parser used to parse the Given frame object</param>
        /// <param name="hRawFrame">[in] The handle of the target frame to parser</param>
        /// <param name="ulFrameNumber">[in] The frame number should be used in parsing process if enabled by option flag</param>
        /// <param name="Options">[in] See flag definition NmFrameParsingOption</param>
        /// <param name="phParsedFrame">[out] The handle to the result parsed frame object</param>
        /// <param name="phInsertedRawFrame">[out] the handle of inserted raw frame as the result of parsing, e.g., reassembly</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser or raw frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmParseFrame(IntPtr hFrameParser, IntPtr hRawFrame, UInt32 ulFrameNumber, NmFrameParsingOption Options, out IntPtr phParsedFrame, out IntPtr phInsertedRawFrame);

        
        /// <summary><c>NmParseBuffer</c>Parse the given data buffer and return it in parsed format</summary> 
        /// <remarks>
        /// The data buffer contains the byte array that can be a raw frame, part of raw frame or any arbitrary data.
        /// The parsed frame contains the fabricated frame information. The filter state and enumeration of field are supported.
        /// The inter frame reassembly is not supported since it requires multiple frames and conversation that are 
        /// Not available in buffer mode.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParser">[in] The handle of the frame parser used to parse the Given frame object</param>
        /// <param name="DataBuffer">[in] The pointer to the target data buffer</param>
        /// <param name="ulBufferLength">[in] length of the data buffer in previous parameter</param>
        /// <param name="ulFrameNumber">[in] The frame number should be used in parsing process if enabled by option flag</param>
        /// <param name="Options">[in] See flag definition NmFrameParsingOption</param>
        /// <param name="phParsedFrame">[out] The handle to the result parsed frame object</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser or raw frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmParseBuffer(IntPtr hParser, Byte[] DataBuffer, UInt32 ulBufferLength, UInt32 ulFrameNumber, NmFrameParsingOption Options, out IntPtr phParsedFrame);

        /// <summary><c>NmBuildRawFrameFromBuffer</c>Build a raw frame using a given data buffer</summary> 
        /// <remarks>
        /// The data buffer is transformed to a raw frame object.  The media type, time stamp are optional.  Their default
        /// Values are zero.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="DataBuffer">[in] The pointer to the target data buffer</param>
        /// <param name="ulBufferLength">[in] length of the data buffer in previous parameter</param>
        /// <param name="ulMedia">[in] Media type of the target raw frame</param>
        /// <param name="ullTimeStamp">[in] Capture time stamp of the target raw frame</param>
        /// <param name="phRawFrame">[out] The handle to the result parsed frame object</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_ENOUGH_MEMORY: No space to build the new frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmBuildRawFrameFromBuffer(IntPtr DataBuffer, UInt32 ulBufferLength, UInt32 ulMedia, UInt64 ullTimeStamp, out IntPtr phRawFrame);

        /// <summary><c>NmBuildRawFrameFromBufferEx</c>Build a raw frame using a given data buffer</summary> 
        /// <remarks>
        /// Same as NmBuildRawFrameFromBufferEx but stores time zone information
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pDataBuffer">[in] The pointer to the target data buffer</param>
        /// <param name="ulBufferLength">[in] length of the data buffer in previous parameter</param>
        /// <param name="ulMedia">[in] Media type of the target raw frame</param>
        /// <param name="pTime">[in] Capture time information of the target raw frame</param>
        /// <param name="phRawFrame">[out] The handle to the result parsed frame object</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_ENOUGH_MEMORY: No space to build the new frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmBuildRawFrameFromBufferEx(IntPtr DataBuffer, UInt32 ulBufferLength, UInt32 ulMedia, ref NM_TIME pTime, out IntPtr phRawFrame);

        /// <summary><c>NmGetFrameFragmentInfo</c>Return fragment information of the given parsed frame</summary> 
        /// <remarks>
        /// Raw frame does not aware of its fragment type. Only parsing the frame can tell when reassembly is enabled.
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="FragmentationInfo">[out] Caller provided struct pointer</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame
        ///     ERROR_INSUFFICIENT_BUFFER: If the protocol name length is longer than the buffer in PNmReassemblyInfo struct
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameFragmentInfo(IntPtr hParsedFrame, ref NmFragmentationInfo FragmentationInfo);

        /// <summary><c>NmGetFilterCount</c>Return configured filter count in the given frame parser</summary> 
        /// <remarks>
        /// 
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParser">[in] frame parser under inspection</param>
        /// <param name="ulFilterCount">[out] number of filters of the given frame parser.  It is zero if return code is not success</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFilterCount(IntPtr hFrameParser, out UInt32 ulFilterCount);

        /// <summary><c>NmEvaluateFilter</c>Return the state of specified filter in given parsed frame</summary> 
        /// <remarks>
        /// 
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame to evaluate</param>
        /// <param name="ulFilterId">[in] The identify number of the filter</param>
        /// <param name="bPassFilter">[out] The filter evaluation result.  TRUE means pass; FALSE means not pass</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmEvaluateFilter(IntPtr hParsedFrame, UInt32 ulFilterId, out Boolean bPassFilter);

        /// <summary><c>NmGetFieldCount</c>Return number of fields enumerated in the given parsed frame</summary> 
        /// <remarks>
        /// 
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target frame</param>
        /// <param name="ulFieldCount">[out] The number of fields returned in parsed frame</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldCount(IntPtr hParsedFrame, out UInt32 ulFieldCount);

        /// <summary><c>NmGetParsedFieldInfo</c>Return the field information of a parsed frame specified by field index number</summary> 
        /// <remarks>
        /// The pointer to field is valid until the parsed frame containing the field is closed.
        /// </remarks>
        /// <example>
        /// <code>
        ///     NmParsedFieldInfo parsedDataField = new NmParsedFieldInfo();
        ///     parsedDataField.Size = (ushort)System.Runtime.InteropServices.Marshal.SizeOf(typeof(NmParsedFieldInfo));
        ///     NetmonAPI.NmGetParsedFieldInfo(hParsedFrame, 0, 0, ref parsedDataField);
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field to get</param>
        /// <param name="ulOption">[in] The retrieve flag</param>
        /// <param name="pParsedFieldInfo">[out] The pointer to the parsed field</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        ///     ERROR_ARITHMETIC_OVERFLOW: The field length is greater than 65535
        ///     NM_STATUS_API_VERSION_MISMATCHED: The pParsedFieldInfo.Size is not initialized or it is different from the version of the API version.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetParsedFieldInfo(IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulOption, ref NmParsedFieldInfo pParsedFieldInfo);

        /// <summary><c>NmGetParsedFieldInfoEx</c>Return the field information of a parsed frame specified by field index number</summary> 
        /// <remarks>
        /// The pointer to field is valid until the parsed frame containing the field is closed.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field to get</param>
        /// <param name="ulOption">[in] The retrieve flag</param>
        /// <param name="pParsedFieldInfo">[out] The pointer to the parsed field buffer</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        ///     NM_STATUS_API_VERSION_MISMATCHED: The pParsedFieldInfo.Size is not initialized or it is different from the version of the API version.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetParsedFieldInfoEx(IntPtr hParsedFrame, IntPtr ulFieldId, IntPtr ulOption, ref NmParsedFieldInfoEx pParsedFieldInfoEx);

        /// <summary><c>NmGetFieldName</c>Return the name property of the parsed field specified by field id</summary> 
        /// <remarks>
        /// ulBufferLength is element count.
        /// </remarks>
        /// <example> Description
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field to get</param>
        /// <param name="RequestedName">[in] The enum to select intended name property</param>
        /// <param name="ulBufferLength">[in] The element length of caller provided buffer length</param>
        /// <param name="pBuffer">[out] The caller provided buffer</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        ///     ERROR_INSUFFICIENT_BUFFER: If ulBufferLength is shorted than the name length
        /// </returns>
        [DllImport("NmApi.Dll", CharSet=CharSet.Unicode ) ]
        unsafe public static extern UInt32 NmGetFieldName(IntPtr hParsedFrame, UInt32 ulFieldId, NmParsedFieldNames RequestedName, UInt32 ulBufferLength, char* pBuffer);

        /// <summary><c>NmGetFieldOffsetAndSize</c>Return the offset and size of the field specified by field id</summary> 
        /// <remarks>
        /// The returned field size is in unit of byte
        /// </remarks>
        /// <example> Description
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field</param>
        /// <param name="ulFieldOffset">[out] The pointer to the returned field offset</param>
        /// <param name="ulFieldSize">[out] The pointer to the returned field size</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldOffsetAndSize(IntPtr hParsedFrame, UInt32 ulFieldId, out UInt32 ulFieldOffset, out UInt32 ulFieldSize);

        /// <summary><c>NmGetFieldValueNumber8Bit</c>Return 8-bit field value</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field</param>
        /// <param name="ubNumber">[out] The value of the requested field</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldValueNumber8Bit(IntPtr hParsedFrame, UInt32 ulFieldId, out Byte ubNumber);

        /// <summary><c>NmGetFieldValueNumber16Bit</c>Return 16-bit field value</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field</param>
        /// <param name="uiNumber">[out] The value of the requested field</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldValueNumber16Bit(IntPtr hParsedFrame, UInt32 ulFieldId, out UInt16 uiNumber);

        /// <summary><c>NmGetFieldValueNumber32Bit</c>Return 32-bit field value</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field</param>
        /// <param name="ulNumber">[out] The value of the requested field</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldValueNumber32Bit(IntPtr hParsedFrame, UInt32 ulFieldId, out UInt32 ulNumber);

        /// <summary><c>NmGetFieldValueNumber64Bit</c>Return 64-bit field value</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field</param>
        /// <param name="ullNumber">[out] The value of the requested field</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFieldValueNumber64Bit(IntPtr hParsedFrame, UInt32 ulFieldId, out UInt64 ullNumber);

        /// <summary><c>NmGetFieldValueByteArray</c>Return byte array field value in buffer</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field</param>
        /// <param name="ulByteLength">[in] The length of the provided buffer in byte</param>
        /// <param name="pBuffer">[out] The value of the requested field</param>
        /// <param name="ulReturnLength">[out] The number of bytes actaully copied</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetFieldValueByteArray(IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulByteLength, byte* pBuffer, out UInt32 ulReturnLength);

        /// <summary><c>NmGetFieldValueString</c>Return string field value in buffer</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field</param>
        /// <param name="ulBufferLength">[in] The element length of the provided buffer</param>
        /// <param name="pValueBuffer">[out] The value of the requested field</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetFieldValueString(IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulBufferLength, char* pValueBuffer);

        /// <summary><c>NmGetFieldInBuffer</c>Get the field in user provided buffer</summary> 
        /// <remarks>
        /// Only the content up to the buffer length is copied.  Caller may call NmGetFieldOffsetAndSize to get the size 
        /// Before calling this function with proper buffer length.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] The handle of the target parsed frame</param>
        /// <param name="ulFieldId">[in] The identify number of the field</param>
        /// <param name="ulBufferLength">[in] The element length of caller provided buffer</param>
        /// <param name="pFieldBuffer">[out] caller provided buffer</param>
        /// <param name="ulReturnLength">[out] actual number of byte copied</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: not found specified parsed frame or field
        ///     ERROR_INSUFFICIENT_BUFFER: Not enough space in buffer, data is not copied.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetFieldInBuffer(IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulBufferLength, byte* pFieldBuffer, out UInt32 ulReturnLength);

        /// <summary><c>NmGetRequestedPropertyCount</c>Get the number of properties added to the parser.</summary> 
        /// <remarks>
        /// None.
        /// </remarks>
        /// <example> This sample shows how to call the NmGetRequestedPropertyCount method.
        /// <code>
        ///     IntPtr FrameParser;    // returned by NmCreateFrameParser
        ///     UInt32 PropertyCount = UInt32.Zero;
        ///     NetmonAPI.NmGetRequestedPropertyCount(FrameParser, out PropertyCount);
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParser">[in] Frame Parser Configuration Handle</param>
        /// <param name="ulCount">[out] Count of properties added to this frame configuration.</param>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified frame parser
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetRequestedPropertyCount(IntPtr hFrameParser, out UInt32 ulCount);

        /// <summary><c>NmGetPropertyInfo</c>Return info structure for a specific property by ID.</summary> 
        /// <remarks>
        /// When the property container type is multi-value storage, the value type and size may be unknown if the property name added does not contain the key.
        /// Since the size is unknown, the caller may need to call the retrieval function twice with the proper buffer of required size returned by the 
        /// Retrieval function which first returned ERROR_INSUFFICIENT_BUFFER.  The same is true for array properties when the index in not included in the property string.
        ///
        /// If the property container type is unknown, the property is not available for retrieval.
        /// </remarks>
        /// <example> This sample shows how to call the NmGetParsedPropertyInfo method.  The method returns
        ///           The property name string size in NM_NPL_PROPERTY_INFO.NameSize.
        /// <code>
        ///     IntPtr FrameParser;    // returned by NmCreateFrameParser
        ///     UInt32 PropertyId = 2; // returned by add property method
        ///     NM_NPL_PROPERTY_INFO PropertyInfo = new NM_NPL_PROPERTY_INFO();
        ///     PropertyInfo.Size = (ushort)Marshal.SizeOf(typeof(NM_NPL_PROPERTY_INFO));
        ///     PropertyInfo.Name = String.Empty;
        ///     NetmonAPI.NmGetPropertyInfo(FrameParser, PropertyId, ref PropertyInfo);
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParser">[in] Frame Parser Configuration Handle</param>
        /// <param name="ulPropertyId">[in] ID of the property returned from NmAddProperty</param>
        /// <param name="pInfo">[out] Information of the property specified by ID.</param>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: Not found specified property
        ///     ERROR_INSUFFICIENT_BUFFER: Buffer size is not sufficient.  The required size is returned in NameLength
        ///     NM_STATUS_API_VERSION_MISMATCHED: NM_PARSED_PROPERTY_INFO version mismatch
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetPropertyInfo(IntPtr hFrameParser, UInt32 ulPropertyId, ref NM_NPL_PROPERTY_INFO pInfo);

        /// <summary><c>NmGetPropertyById</c>Return property value by ID.</summary> 
        /// <remarks>
        /// The Key for multi-value storage properties or Index for array properties must not provide both the property name and key index array.
        /// The key type must match the type used in NPL parser.
        /// If no key is added, set ulKeyCount to zero.
        /// </remarks>
        /// <example>.
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParser">[in] Frame Parser Handle</param>
        /// <param name="ulPropertyId">[in] ID of the property returned from NmAddProperty</param>
        /// <param name="ulBufferSize">[in] Size of the buffer supplied in byte count.</param>
        /// <param name="pBuffer">[out] Buffer for returned data.</param>
        /// <param name="ulReturnLength">[out] Size of the data returned.</param>
        /// <param name="ulType">[out] Value type of the returned MVS property.</param>
        /// <param name="ulKeyCount">[in] Number of keys provided</param>
        /// <param name="pKeyArray">[in] key Array to look up in MVS and property group </param>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: not found specified property
        ///     ERROR_INSUFFICIENT_BUFFER: Not enough space in buffer, data is not copied.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetPropertyById(IntPtr hFrameParser, UInt32 ulPropertyId, UInt32 ulBufferSize, byte* pBuffer, out UInt32 ulReturnLength, out NmPropertyValueType ulType, UInt32 ulKeyCount, CNmPropertyStorageKey [] pKeyArray);

        /// <summary><c>NmGetPropertyByName</c>Return property value by Name.</summary> 
        /// <remarks>
        /// The property is not necessarily added to the frame parser configuration if a non-optimized frame parser is used.  In this case, the property id is not available and the
        /// The property name can be used.  The full qualified name must be used as to add the property to the frame parser configuration.
        /// The index or key must not provided by both name and key array. If no key to add, set ulKeyCount to zero.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrameParser">[in] Frame Parser Handle</param>
        /// <param name="pPropertyName">[in] full qualified name of the property </param>
        /// <param name="ulBufferSize">[in] Size of the buffer supplied in byte count.</param>
        /// <param name="pBuffer">[out] Buffer for returned data.</param>
        /// <param name="pulReturnLength">[out] Size of the data returned.</param>
        /// <param name="ulType">[out] Value type of the returned MVS property.</param>
        /// <param name="ulKeyCount">[in] Number of keys provided</param>
        /// <param name="pKeyArray">[in] key Array to look up in MVS and property group </param>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: not found specified property
        ///     ERROR_INSUFFICIENT_BUFFER: Not enough space in buffer, data is not copied.
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetPropertyByName(IntPtr hFrameParser, [MarshalAs(UnmanagedType.LPWStr)] String pPropertyName, UInt32 ulBufferSize, byte* pBuffer, out UInt32 pulReturnLength, out NmPropertyValueType ulType, UInt32 ulKeyCount, CNmPropertyStorageKey [] pKeyArray);

        #endregion

        #region Raw Frame Operations
        /// <summary><c>NmGetRawFrameLength</c>Return length of the raw frame</summary> 
        /// <remarks>
        /// 
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrame">[in] The handle of the target raw frame</param>
        /// <param name="pulLength">[out] Frame length</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified raw frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetRawFrameLength(IntPtr hFrame, out UInt32 pulLength);

        /// <summary><c>NmGetRawFrame</c>Return raw frame</summary> 
        /// <remarks>
        /// The frame buffer is valid until the raw frame is closed.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrame">[in] The handle of the target raw frame</param>
        /// <param name="ulLength">[in] Caller buffer length in byte element</param>
        /// <param name="pFrameBuffer"> [out] Buffer for raw frame data by caller</param>
        /// <param name="pulReturnLength">[out] Actual returned data length</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified raw frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetRawFrame(IntPtr hFrame, UInt32 ulLength, byte* pFrameBuffer, out UInt32 pulReturnLength);

        /// <summary><c>NmGetPartialRawFrame</c>Return partial frame data in caller provided buffer</summary> 
        /// <remarks>
        /// Use caller provided offset and buffer length to copy the frame data.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hRawFrame">[in] The handle of the target raw frame</param>
        /// <param name="ulFrameOffset">[in] Start offset to copy</param>
        /// <param name="ulBufferLength">[in] Caller buffer length, the Number of bytes to copy</param>
        /// <param name="pFrameBuffer">[out] Caller provided buffer</param>
        /// <param name="pulReturnLength">[out] Actual returned data length</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified raw frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetPartialRawFrame(IntPtr hRawFrame, UInt32 ulFrameOffset, UInt32 ulBufferLength, byte* pFrameBuffer, out UInt32 pulReturnLength);

        /// <summary><c>NmGetFrameMacType</c>Return MAC type of the frame</summary> 
        /// <remarks>
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrame">[in] The handle of a parsed or a raw frame object</param>
        /// <param name="pulMacType">[out] The pointer to the MAC type of the frame</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_INVALID_PARAMETER: hFrame is not a parsed or a raw frame handle.
        ///     ERROR_NOT_FOUND: not found specified frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameMacType(IntPtr hFrame, out UInt32 pulMacType);


        /// <summary><c>NmGetFrameTimeStamp</c>Return the local time stamp of the frame</summary> 
        /// <remarks>
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrame"> [in] The handle of a parsed or a raw frame object</param>
        /// <param name="pTimeStamp"> [out] The pointer to the local time stamp of the frame.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_INVALID_PARAMETER: hFrame is not a parsed or a raw frame handle.
        ///     ERROR_NOT_FOUND: not found specified frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameTimeStamp(IntPtr hFrame, out UInt64 pTimeStamp);

        /// <summary><c>NmGetFrameTimeStampEx</c>Return the extended time information of the capture</summary> 
        /// <remarks>
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrame"> [in] The handle of a parsed or a raw frame object</param>
        /// <param name="pTime"> [out] The pointer to the NM_TIME of the frame</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_INVALID_PARAMETER: hFrame is not a parsed or a raw frame handle.
        ///     ERROR_NOT_FOUND: not found specified frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameTimeStampEx(IntPtr hFrame, ref NM_TIME pTime);

        /// <summary><c>NmGetFrameCommentInfo</c>Return the frame comment title and description</summary>
        /// <remarks>
        /// If the buffer passed in is NULL, the buffer length arguments will indicate the required length.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hFrame"> [in] The handle of the raw frame object></param>
        /// <param name="ulCommentTitleBufferLength"> [inout] The pointer to the actual byte length that corresponds to the title buffer</param>
        /// <param name="pCommentTitleBuffer"> [in] Caller supplied buffer to hold the comment title</param>
        /// <param name="ulCommentDescriptionBufferLength"> [inout] The pointer to the actual byte length that corresponds to the description buffer</param>
        /// <param name="pCommentDescriptionBuffer"> [in] Caller supplied buffer to hold the comment description</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_FOUND: Specified parsed frame not found
        ///     ERROR_INSUFFICIENT_BUFFER: If either of the supplied buffers is NULL
        ///     ERROR_EMPTY: Frame comment information was not found
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetFrameCommentInfo(IntPtr hFrame, ref UInt32 ulCommentTitleBufferLength, byte* pCommentTitleBuffer, ref UInt32 ulCommentDescriptionBufferLength, byte* pCommentDescriptionBuffer);

        #endregion

        #region Capture File Operations

        /// <summary><c>NmCreateCaptureFile</c> Create a new Network Monitor capture file for adding frames.</summary> 
        /// <remarks>
        /// This is the capture file to write to. Close it by calling NmCloseObjHandle method.
        /// The file can be opened in 2 modes specified by Flags, wrap around (default) and chain capture.
        /// </remarks>
        /// <example> Description
        /// <code>
        ///     
        ///     
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pFileName"> [in] The name of the file to create</param>
        /// <param name="ulSize"> [in] The caller specified maximum size of the file in byte.  The hard limit is 500 MByte</param>
        /// <param name="ulFlags"> [in] Specify the file modes, wrap-round or chain capture</param>
        /// <param name="phCaptureFile"> [out] The returned handle to the capture file object if successful</param>
        /// <param name="ulReturnSize"> [out] The actual size of the file in byte.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: NULL pointer
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateCaptureFile([MarshalAs(UnmanagedType.LPWStr)] String pFileName, UInt32 ulSize, NmCaptureFileFlag ulFlags, out IntPtr phCaptureFile, out UInt32 ulReturnSize);

        /// <summary><c>NmOpenCaptureFile</c> Open a Network Monitor capture file to read</summary> 
        /// <remarks>
        /// The file is read only. Close capture file by calling NmCloseObjHandle method.
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pFileName"> [in] The name of the file to open</param>
        /// <param name="phCaptureFile"> [out]The returned handle of the capture file object if successful</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: NULL pointer
        ///     ERROR_NOT_FOUND: not found specified file
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmOpenCaptureFile([MarshalAs(UnmanagedType.LPWStr)] String pFileName, out IntPtr phCaptureFile);

        /// <summary><c>NmOpenCaptureFileInOrder</c> Open a Network Monitor capture file to read</summary> 
        /// <remarks>
        /// The frame in file are in the order of the sequence specified in the frame parser parameter
        /// The file is read only. Close capture file by calling NmCloseObjHandle method.
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pFileName"> [in] The name of the file to open</param>
        /// <param name="pOrderParser"> [in]The struct containing the frame parser configured with sequnece order instructions</param>
        /// <param name="phCaptureFile"> [out]The returned handle of the capture file object if successful</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: NULL pointer
        ///     ERROR_NOT_FOUND: not found specified file
        ///     ERROR_INVALID_PARAMETER: frame parser does not have sequence configuration.
        ///     ERROR_NOT_ENOUGH_MEMORY: not enough memory to build required objects.
        ///     NM_STATUS_API_VERSION_MISMATCHED: PNM_ORDER_PARSER_PARAMETER version does not match.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmOpenCaptureFileInOrder([MarshalAs(UnmanagedType.LPWStr)] String pFileName, ref NM_ORDER_PARSER_PARAMETER pOrderParser, out IntPtr phCaptureFile);

        /// <summary><c>NmAddFrame</c> Add a frame to the specified capture file.</summary> 
        /// <remarks>
        /// The target capture file must be opened with NmCreateCaptureFile method
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureFile"> [in] The destination capture file for the frame</param>
        /// <param name="hFrame"> [in] The handle of the frame to add</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified file or frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddFrame(IntPtr hCaptureFile, IntPtr hFrame);


        /// <summary><c>NmGetFrameCount</c> Get frame count in the specified capture file</summary> 
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception>None</exception>
        /// <param name="hCaptureFile"> [in] The target capture file under query</param>
        /// <param name="hFrameCount"> [out] Return frame count</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified capture file
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrameCount(IntPtr hCaptureFile, out UInt32 hFrameCount);

        /// <summary><c>NmGetFrame</c> Get frame by number from the specified capture file.</summary> 
        /// <remarks>
        /// The frame number is the index number in the capture file.
        /// </remarks>
        /// <exception>None</exception>
        /// <param name="hCaptureFile"> [in] Handle to the capture file</param>
        /// <param name="ulFrameNumber"> [in] Frame number in the capture file to retrieve</param>
        /// <param name="phFrame"> [out] The returned handle to the raw frame object if successful</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Frame handle is valid
        ///     ERROR_BAD_ARGUMENTS: Invalid handle
        ///     ERROR_NOT_FOUND: not found specified capture file or frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetFrame(IntPtr hCaptureFile, UInt32 ulFrameNumber, out IntPtr phFrame);
        #endregion

        #region NPL Property Extension

        /// <summary><c>NmGetTopConversation</c>Return the top level conversation and protocol name.</summary> 
        /// <remarks>
        /// The protocol name length is returned to caller.  So if the provided buffer is not enough, caller
        /// Can call again with the proper sized buffer.
        /// </remarks>
        /// <example> This sample shows how to call the NmGetTopConversation method.
        /// <code>
        ///     IntPtr hParsedFrame;
        ///     UInt32 returnLength;
        ///     UInt32 conversationId;
        ///     Char[] retName = null;
        ///     unsafe
        ///     {
        ///        retName = new Char[256];
        ///        fixed (char* buffer = retName)
        ///        {
        ///           NetmonAPI.NmGetTopConversation(
        ///                          hParsedFrame, 
        ///                          256, 
        ///                          buffer, 
        ///                          out returnLength,
        ///                          out conversationId);
        ///        }
        ///     }
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hParsedFrame">[in] Parsed Frame</param>
        /// <param name="ulBufferESize">[in] Size of the for protocol name in WCHAR.</param>
        /// <param name="pProtocolName">[out] Buffer for protocol name.</param>
        /// <param name="pulProtocolNameLength">[out] Not include terminator in WCHAR.</param>
        /// <param name="pulConversationID">[out] ID of the TOP Level Conversation</param>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_INSUFFICIENT_BUFFER: Insufficient buffer space
        ///     ERROR_NOT_FOUND: not found specified parsed frame
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetTopConversation(IntPtr hParsedFrame, UInt32 ulBufferESize, char* pProtocolName, out UInt32 pulProtocolNameLength, out UInt32 pulConversationID);

        /// <summary><c>NmGetParentConversation</c>Return parent conversation information of the given conversation.</summary> 
        /// <remarks>
        /// The parent protocol name length is returned to caller.  So if the provided buffer is not enough, caller
        /// Can call again with the proper sized buffer.
        /// </remarks>
        /// <example> This sample shows how to call the NmGetParentConversation method.
        /// <code>
        ///     IntPtr myParsedFrame;
        ///     UInt32 protocolId = 24;
        ///     UInt32 returnLength;
        ///     UInt32 parentConvID;
        ///     Char[] retName = null;
        ///     unsafe
        ///     {
        ///        retName = new Char[256];
        ///        fixed (char* buffer = retName)
        ///        {
        ///           NetmonAPI.NmGetParentConversation(
        ///                             myParsedFrame,
        ///                             protocolId,
        ///                             256, 
        ///                             buffer, 
        ///                             out returnLength,
        ///                             out parentConvID);
        ///        }
        ///     }
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="myParsedFrame">[in] Parsed Frame</param>
        /// <param name="ulConversationID">[in] ID of the Conversation you want the parent of.</param>
        /// <param name="ulBufferESize">[in] Buffer size for the Parent protocol name in WCHAR count.</param>
        /// <param name="pParentProtocolName">[out] Buffer for the Parent Protocol Name. </param>
        /// <param name="ulParentProtocolNameLength">[out] Returned Length of Parent Protocol Name in WCHAR.</param>
        /// <param name="ulParentConversationID">[out] Size of the for protocol name.</param>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_INSUFFICIENT_BUFFER: Insufficient buffer space
        ///     ERROR_NOT_FOUND: not found specified frame parser
        /// </returns>
        [DllImport("NmApi.Dll")]
        unsafe public static extern UInt32 NmGetParentConversation(IntPtr hParsedFrame, UInt32 ulConversationId, UInt32 ulBufferESize, char* pParentProtocolNameBuffer, out UInt32 ulParentProtocolNameLength, out UInt32 ulParentConversationID);

        #endregion

        #region Parser Profile Operations

        /// <summary><c>NmLoadWithNplProfile</c>Create frame parser using the provided Guid for an NPL profile</summary> 
        /// <remarks>
        /// The ulFlags is reserved for future options.
        /// </remarks>
        /// <example> 
        /// <code>
        /// </code>
        /// </example>
        /// <exception>None</exception>
        /// <param name="pProfileGuid">[in] The GUID of the profile to use.</param>
        /// <param name="ulFlags">[in] Option flags</param>
        /// <param name="CallbackFunction">[in] The compiler error callback function pointer</param>
        /// <param name="pCallerContext">[in] The caller context pointer that will be passed back to the callback function</param>
        /// <param name="phNplParser">[Out] The returned handle to the NPL parser object</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Successfully compiled NPL
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer
        ///     ERROR_NOT_ENOUGH_MEMORY: Fail to create frame parser configuration object.
        ///     ERROR_NOT_FOUND: The given profile GUID does not exist.
        ///     ERROR_NO_MATCH: the provided GUID does not exist.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmLoadWithNplProfile([MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid, NmNplParserLoadingOption ulFlags, ParserCallbackDelegate CallbackFunction, IntPtr pCallerContext, out IntPtr phNplParser);

        /// <summary><c>NmCreateNplProfile</c>adds a profile given using given parameters.</summary> 
        /// <remarks>
        /// This method allows developers to create profiles much like when the UI builds a profile.
        /// The simplest case does not provide the optional argument TemplateID.  In this case, a new profile is 
        /// created using the paths that have been provided.  No sparser is generated, and no directories are formed.
        ///
        /// The more complex case provides a TemplateID that corresponds to an existing profile.  The include path for
        /// the existing profile will be duplicated for the new profile (which is why the provided IncludePath is
        /// ignored in this case).  Profiles created in this way will have a directory created using the GUID of the 
        /// profile if successful. When these profiles are deleted, all files present in the created directory will 
        /// also be removed.  Template profiles gain an additional search path to the user's local APPDATA as well
        /// as an explicit include my_sparser.npl in the generated sparser.npl.
        /// </remarks>
        /// <example>
        /// <code>
        ///
        /// // Building a blank profile.
        /// NetmonAPI.NmCreateNplProfile( "ProfileTest00-1", "This profile is created, verified, and deleted.", 
        ///                                    "c:\\somePath", "MyGuid" );
        ///
        /// // Building a profile from a template using the GUID of a previously existing profile.
        /// NetmonAPI.NmCreateNplProfile( "ProfileTest00-2", "This profile is created from another profile.", 
        ///                                    NULL, "MyGuid2", "AD161723-4281-4d33-804E-5E43EE61D163" );
        ///
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="Name">[in] The name of the profile. </param>
        /// <param name="Description">[in] The description of the profile. </param>
        /// <param name="IncludePath">[in] A semicolon delimited list of the paths to search in when building parsers.
        ///  This argument is not used when a templateID is provided.</param>
        /// <param name="Guid">[in] The GUID for the profile.</param>
        /// <param name="TemplateID">[in] Optional. Defaults to NULL. If provided, the newly created profile will be 
        ///  built as a template of the given profile. </param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Successfully added the profile.
        ///     ERROR_ALREADY_ASSIGNED: The provided GUID is already present.
        ///     ERROR_NO_MATCH: The provided TemplateID does not exist.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateNplProfile([MarshalAs(UnmanagedType.LPWStr)] String Name, [MarshalAs(UnmanagedType.LPWStr)] String Description,
                                                             [MarshalAs(UnmanagedType.LPWStr)] String IncludePath, [MarshalAs(UnmanagedType.LPWStr)] String Guid,
                                                             [MarshalAs(UnmanagedType.LPWStr)] String templateID);

        /// <summary><c>NmGetNplProfileAttribute</c>Retrieves the profile attribute using the index of the profile.</summary> 
        /// <remarks>
        /// This method can be used to retrieve an attribute value as a string for a given profile.  If the given buffer is too small,
        /// the method will populate as much as it can, and then change the value of ulBufferLenth to the required number of bytes to 
        /// retrieve the entire string.
        /// </remarks>
        /// <example>
        /// <code>
        ///     String myBuffer = new String('0', 1024);
        ///     UInt32 myIndex = 1;
        ///     UInt32 myBufferSize = 1024;
        ///     NetmonAPI.NmGetNplProfileAttribute( myIndex, NmNplProfileAttributePackageGuid, ref myBufferSize, out myBuffer );
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pProfileGuid">[in] the index of the profile</param>
        /// <param name="attribute">[in] the attribute enum that corresponds to the string we are looking for</param>
        /// <param name="ulBufferELength">[inout] The length of the buffer we would like to fill</param>
        /// <param name="pAttributeBuffer">[out] The buffer to place the string in.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Successfully retrieved the attribute.
        ///     ERROR_NO_MATCH: The provided GUID does not match an existing profile's GUID.
        ///     ERROR_INSUFFICIENT_BUFFER: The provided buffer is too short.  The ulBufferELenth will be updated.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetNplProfileAttribute(UInt32 ulIndex, NmNplProfileAttribute attribute, ref UInt32 ulBufferELength, [MarshalAs(UnmanagedType.LPWStr)] String pAttributeBuffer);

        /// <summary><c>NmGetNplProfileAttributeByGuid</c>Retrieves the profile attribute using the GUID of the profile.</summary> 
        /// <remarks>
        /// This method can be used to retrieve an attribute value as a string for a given profile.  If the given buffer is too small,
        /// the method will populate as much as it can, and then change the value of ulBufferLenth to the required number of bytes to 
        /// retrieve the entire string.
        /// </remarks>
        /// <example>
        /// <code>
        ///     String guid = "AD161723-4281-4d33-804E-5E43EE61D163";
        ///     String myBuffer = new String('0', 1024);
        ///     UInt32 myBufferSize = 1024;
        ///     NetmonAPI.NmGetNplProfileAttributeByGuid( guid, NmNplProfileAttributePackageGuid, ref myBufferSize, out myBuffer );
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pProfileGuid">[in] the GUID of the profile</param>
        /// <param name="attribute">[in] the attribute enum that corresponds to the string we are looking for</param>
        /// <param name="ulBufferELength">[inout] The length of the buffer we would like to fill</param>
        /// <param name="pAttributeBuffer">[out] The buffer to place the string in.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Successfully retrieved the attribute.
        ///     ERROR_NO_MATCH: The provided GUID does not match an existing profile's GUID.
        ///     ERROR_INSUFFICIENT_BUFFER: The provided buffer is too short.  The ulBufferELenth will be updated.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetNplProfileAttributeByGuid([MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid, NmNplProfileAttribute attribute, ref UInt32 ulBufferELength, [MarshalAs(UnmanagedType.LPWStr)] String pAttributeBuffer);

        /// <summary><c>NmSetNplProfileAttribute</c>Sets the profile's attribute using the index of the profile.</summary> 
        /// <remarks>
        /// This method can be used to set an attribute on a profile.  There are only three attributes that can be 
        /// modified on an existing profile; the Name, the Description, and the Include Path.  This method accepts the index of
        /// profile to modify.  
        /// </remarks>
        /// <example>
        /// <code>
        /// // Load the first profile.
        /// NetmonAPI.NmSetNplProfileAttribute( 0, NmNplProfileAttributeDescription, "TestValue" );
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ulIndex">[in] the index of the profile to use..</param>
        /// <param name="attribute">[in] the enumeration item that corresponds to the desired attribute.</param>
        /// <param name="pAttributeBuffer">[in] The buffer to populate the attribute from.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: The attribute has been successfully updated.
        ///     ERROR_NO_MATCH: The provided index is not found in the Parser Profile Manager.
        ///     ERROR_INVALID_ACCESS: The profile is read only and cannot be modified.
        ///     ERROR_BAD_ARGUMENTS: The enumeration item was not Description, Name, or IncludePath.
        /// </returns>
        /// 
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmSetNplProfileAttribute( UInt32 ulIndex, NmNplProfileAttribute attribute, [MarshalAs(UnmanagedType.LPWStr)] String pAttributeBuffer );

        /// <summary><c>NmSetNplProfileAttributeByGuid</c>Sets the profile's attribute using the GUID of the profile.</summary> 
        /// <remarks>
        /// This method can be used to set an attribute on a profile.  There are only three attributes that can be 
        /// modified on an existing profile; the Name, the Description, and the Include Path.
        /// </remarks>
        /// <example>
        /// <code>
        /// NetmonAPI.NmSetNplProfileAttributeByGuid( "AD161723-4281-4d33-804E-5E43EE61D163", NmNplProfileAttributeDescription, "TestValue" );
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ulIndex">[in] the GUID of the profile to update.</param>
        /// <param name="attribute">[in] the enumeration item that corresponds to the desired attribute.</param>
        /// <param name="pAttributeBuffer">[in] The buffer to populate the attribute from.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: The attribute has been successfully updated.
        ///     ERROR_NO_MATCH: The provided GUID is not found in the Parser Profile Manager..
        ///     ERROR_INVALID_ACCESS: The profile is read only and cannot be modified.
        ///     ERROR_BAD_ARGUMENTS: The enumeration item was not Description, Name, or IncludePath.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmSetNplProfileAttributeByGuid( [MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid, NmNplProfileAttribute attribute, [MarshalAs(UnmanagedType.LPWStr)] String pAttributeBuffer );
        
        /// <summary><c>NmGetNplProfileCount</c>retrieves the number of profiles available</summary> 
        /// <remarks>
        /// The number of profiles includes the User Defined Profiles and the Installed Profiles.
        /// This number will always be greater than zero.  If no profiles are present, the parser engine
        /// will construct the pure capture profile when the ParserProfileManager is initialized which 
        /// will be done when this method is called.
        /// </remarks>
        /// <example>
        /// <code>
        /// UInt32 myProfileCount = 0;
        /// NetmonAPI.NmGetNplProfileCount( out myProfileCount );
        /// </code>
        /// </example>
        /// <exception>None</exception>
        /// <param name="pulCount">[out] Number of profiles in the ParserProfileManager.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: Method will always return success.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetNplProfileCount( out UInt32 pulCount );

        /// <summary><c>NmGetActiveNplProfileGuid</c>retrieves the GUID for the currently active profile</summary> 
        /// <remarks>
        /// If the provided buffer is not long enough to contain the active NPL Profile's Id, the method will return
        /// ERROR_INSUFFICIENT_BUFFER and the ulBufferELength will be assigned to the necessary size to read the buffer.
        /// </remarks>
        /// <example>
        /// <code>
        /// String myGuid = new String('0', 50);
        /// UInt32 myGuidLength = 50;
        /// NetmonAPI.NmGetActiveNplProfileGuid( ref myGuidLength, out myGuid );
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ulBufferELength">[in] The length of the provided buffer.</param>
        /// <param name="pProfileGuid">[out] The buffer to place the GUID of the active profile into. </param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: The GUID has been retrieved.
        ///     ERROR_NO_MATCH: There is no active Npl Profile assigned.
        ///     ERROR_INSUFFICIENT_BUFFER: the provided buffer is not long enough to contain the GUID.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetActiveNplProfileGuid( ref UInt32 ulBufferELength, [MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid );

        /// <summary><c>NmSetActiveNplProfile</c>Sets the active profile to the given ID</summary> 
        /// <remarks>
        /// Method will attempt to compile the provided profile. If compilation is not successful, then ERROR_CAN_NOT_COMPLETE will be
        /// returned. In this case, users should use NmLoadWithNplProfile to determine what errors were encountered.  When successful,
        /// the profile is set as active for all Microsoft Network Monitor clients that share the HKCU key. (netmon.exe/nmcap.exe/etc)
        /// </remarks>
        /// <example>
        /// <code>
        ///   String MicrosoftFasterNPLProfileID = "AD161723-4281-4d33-804E-5E43EE61D163";
        ///   NetmonAPI.NmSetActiveNplProfile( MicrosoftFasterNPLProfileID );
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pProfileGuid">[in] </param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: The profile has been set as active.
        ///     ERROR_NO_MATCH: The GUID is not present.
        ///     ERROR_CAN_NOT_COMPLETE: The provided profile cannot successfully compile.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmSetActiveNplProfile( [MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid );

        /// <summary><c>NmDeleteNplProfile</c></summary> 
        /// <remarks>
        /// Method will delete a profile if the profile can be deleted. Some profiles cannot be deleted.
        /// Profiles that cannot be deleted include: 
        ///            Installed Profiles from Microsoft/3rd party packages.
        ///            The currently active profile.
        /// </remarks>
        /// <example>
        /// <code>
        ///   String MicrosoftFasterNPLProfileID = "AD161723-4281-4d33-804E-5E43EE61D163";
        ///   NetmonAPI.NmDeleteNplProfile( MicrosoftFasterNPLProfileID );
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="pProfileGuid">[in] </param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS: The profile has been successfully deleted.
        ///     ERROR_NO_MATCH: The provided GUID is not available for deletion.
        ///     ERROR_ALREADY_ASSIGNED: The provided GUID could not be deleted because it is currently active.
        ///     ERROR_INVALID_ACCESS: The profile is read only.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmDeleteNplProfile([MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid);

        #endregion

        #region Driver Capture Filter Operations

        //////////////////////////////////////////////
        ///
        /// Driver capture filter
        ///
        /// OVERVIEW: You can specify a driver filter per adapter, per process.  The driver filtering consists of
        /// a set of filters where each filter contain a set blocks.  Each block contains a set of OLP,
        /// (Offset, Length, Pattern), expressions which also contain an operand.  The operation, AND or OR, is fixed 
        /// for each block of OLP expressions.  And the operation between blocks is the opposite of the operation 
        /// between each OLP.  So if you set the block operation to AND, the OLP operation is OR.  The operation 
        /// between filters can be AND or OR.  The order of the operations for filters occurs in the order you add 
        /// them.  The order of operations for blocks and OLP expressions depends on the index you specify when you 
        /// add them.
        ///
        /// OLP expressions, blocks and filters can also be "short circuited" using the NmOlpActionFlags.  This allows
        /// you to optimize an expression when you know the evaluation in the driver will not be sufficient to
        /// completely evaluate the intended filter operation accurately.  For instance, consider a filter where you are 
        /// looking for a TCP port. In some cases the port offset can change when IPv4 options exist.  This short circuit
        /// provides a way to return the frame early rather than evaluating the rest of the expression.
        /// 
        /// You must add a driver filter before the capture engine is started.  Driver filtering can affect your
        /// capturing performance as a larger delay in the driver doing these evaluations may cause you to drop
        /// frames.  You can use NmGetLiveCaptureFrameCounts to monitor dropped frames and other statistics.

        /// <summary><c>NmCreateOlp</c>Create OLP for the capture filter</summary> 
        /// <remarks>
        /// Build an OLP expression and return the OLP ID unique in process scope.
        ///
        /// The OLP pattern must be contained in the byte array as it should be in frames in terms of byte alignment.
        /// For example, if the bit offset is 34 and bit length is 17, the pattern is 0b10101010101010101, the
        /// Representation in the given buffer should be 0b00101010,10101010,10100000 or 0x2AAAA0 (3 bytes).
        ///                                                  -------------------
        /// Note the two leading zeros and five zeros on the back.  But the bits in front or rear of the pattern is not 
        /// Required to be set to zero.
        /// 
        /// Given bit offset BO an bit length BL, the byte array length should be:
        /// (((BO % 8) + BL)/8 + (((BO + BL) % 8) == 0)? 0:1)
        /// The byte array length in above example: 
        /// (((34 % 8) + 17)/8 + (((34 + 17) % 8) == 0)? 0:1) is 3
        /// 
        /// If the byte array passed in is shorter, the behavior is unpredictable or most likely an access violation.
        /// </remarks>
        /// <example>
        /// <code>
        /// Here is an example of TCP syn flag OLP that allows only TCP syn packets.  This assumes that the underlying 
        /// protocols match Frame.Ethernet.IPv4.TCP for the frame you evaluate.
        ///
        /// UInt32 BitOffset = 446; 
        /// UInt32 BitLength = 1; 
        /// System.Byte[] TcpFlagSyn = 0x02; // Syn flag bit is the 7th from the MSB (0b00000010).
        /// UInt32 OlpId;
        /// UInt32 status = NmCreateOlp(BitOffset, BitLength, TcpFlagSyn, 
        ///                             NmFilterMatchMode.NmFilterMatchModeEqual, 
        ///                             NmOlpActionFlags.NmOlpActionFlagsNone, out OlpId);
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="BitOffset">[in] The bit offset of the OLP</param>
        /// <param name="BitLength">[in] The bit length of the OLP</param>
        /// <param name="pPattern">[in] The pattern of the OLP.</param>
        /// <param name="OpMode">[in] The comparison operator type, e.g., EQ, NOT EQ, GREATER, LESS, etc.</param>
        /// <param name="Options">[in] The option configuration flags defined by NmOlpActionFlags</param>
        /// <param name="pulOlpId">[out] The process unique ID for the OLP.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: NULL pointers or zero BitLength.
        ///     ERROR_ARITHMETIC_OVERFLOW: If more than 4G OLP entities are created, the OLP id overflows.
        ///     ERROR_NOT_ENOUGH_MEMORY: Fail to allocate memory for the OLP entity object.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateOlp(UInt32 BitOffset, 
                                                UInt32 BitLength, 
                                                System.Byte[] pPattern, 
                                                NmFilterMatchMode OpMode, 
                                                NmOlpActionFlags Options, 
                                                out UInt32 pulOlpId);

        /// <summary><c>NmCreateOlpBlock</c>Create OLP block for the capture filter </summary> 
        /// <remarks>
        /// Create an OLP block and return it's ID which is unique in processes scope.  The ulConditionCount specifies 
        /// the maximum number of the OLP conditions the block can hold.  The ulConditionCount must be non-zero.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ulConditionCount">[in] The number of conditions the block can hold</param>
        /// <param name="ulOptions">[in] Opyional NmOlpActionFlags flags </param>
        /// <param name="pulOlpBlockId">[out] The unique ID of the OLP block</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: NULL pointer
        ///     ERROR_ARITHMETIC_OVERFLOW: If more than 4G OLP entities are created, the OLP id overflows.
        ///     ERROR_NOT_ENOUGH_MEMORY: Fail to allocate memory for the OLP entity object.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateOlpBlock(UInt32 ulConditionCount, NmOlpActionFlags ulOptions, out UInt32 pulOlpBlockId);

        /// <summary><c>NmAddOlpToBlock</c>Add the OLP to the OLP block </summary> 
        /// <remarks>
        /// Add the OLP condition to the OLP block.  The ulOlpBlockId must reference an OLP block entity that was
        /// created by NmCreateOlpBlock.  The ulOlpId must reference to an OLP condition entity created by NmCreateOlp.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ulOlpBlockId">[in] The target OLP block ID created by NmCreateOlpBlock</param>
        /// <param name="ulIndex">[in] The zero based index position of the OLP in the target block</param>
        /// <param name="ulOlpId">[in] The ID of the OLP to add returned from NmCreateOlpl</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: The specified index is invalid; or the OLP types referenced by the IDs are wrong.
        ///     ERROR_NOT_FOUND: The specified block or OLP are not found.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddOlpToBlock(UInt32 ulOlpBlockId, UInt32 ulIndex, UInt32 ulOlpId);

        /// <summary><c>NmCreateOlpFilter</c>Create the OLP driver capture filter</summary> 
        /// <remarks>
        /// Create an OLP filter entity and return its ID that is unique in processes scope.  
        /// The ulBlockCount specifies the maximum number of the OLP blocks the 
        /// filter created can hold.  The ulBlockCount must be non-zero.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ulBlockCount">[in] The number of OLP blocks the filter can hold</param>
        /// <param name="ulOptions">[in] The filter configuration flags.  NmFilterOptionFlags and NmOlpActionFlags can be combined</param>
        /// <param name="pulOlpFilterId">[out] The unique ID of the new OLP filter</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: NULL pointer.
        ///     ERROR_ARITHMETIC_OVERFLOW: If more than 4G OLP entities are created, the OLP id overflows.
        ///     ERROR_NOT_ENOUGH_MEMORY: Fail to allocate memory for the OLP entity object.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmCreateOlpFilter(UInt32 ulBlockCount, UInt32 ulOptions, out UInt32 pulOlpFilterId);

        /// <summary><c>NmAddOlpBlockToFilter</c>Add the OLP block to the OLP filter</summary> 
        /// <remarks>
        /// Add the OLP block to the OLP filter.  The ulOlpFilterId must reference to an OLP filter entity that is created by
        /// NmCreateOlpFilter.  The ulOlpBlockId must reference to an OLP block entity created by NmCreateOlpBlock.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ulOlpFilterId">[in] The ID of the target OLP filter created by NmCreateOlpFilter.</param>
        /// <param name="ulIndex">[in] The index position of the OLP block in the target OLP filter</param>
        /// <param name="ulOlpBlockId">[in] The ID of the OLP block to add created by NmCreateOlpBlock.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BAD_ARGUMENTS: The specified index is invalid; or the OLP types referenced by the ids are wrong.
        ///     ERROR_NOT_FOUND: The specified filter or block are not found.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddOlpBlockToFilter(UInt32 ulOlpFilterId, UInt32 ulIndex, UInt32 ulOlpBlockId);

        /// <summary><c>NmDeleteOlpEntity</c>Delete an OLP entity specified by its ID</summary> 
        /// <remarks>
        /// Delete the specified OLP entity, (filter, or block, or OLP expression), from API OLP entity pool so the deleted entity
        /// can no longer used to construct new driver filters. The OLP entity here is not the actual driver capture Filter but 
        /// the layered logical objects that can be added to the driver using NmAddDriverCaptureFilter, or deleted from the driver 
        /// using NmDeleteDriverCaptureFilter.
        ///
        /// Do not delete an OLP entity before the filter containing it has been added to the driver, otherwise 
        /// the filter will not be built correctly.
        ///
        /// All OLP entities (OLP condition, block and filter) can be deleted after the filter is added to the driver.
        ///
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="ulEntityId">[in] The unique ID of the OLP entity: OLP expression, block or filter.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_NOT_FOUND: The specified ulEntityId is invalid.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmDeleteOlpEntity(UInt32 ulEntityId);

        /// <summary><c>NmAddDriverCaptureFilter</c>Add capture filter to the adapter.</summary> 
        /// <remarks>
        /// Add the capture filter created with NmCreateOlpFilter to the driver. This function must be called when  
        /// the adapter is not actively capturing.
        /// 
        /// There is a limit to the number of OLP conditions that can be added to the driver.  This limit is per 
        /// adapter for each API process. The default limit is 16.  If the limit of OLP conditions are exceeded, 
        /// ERROR_INVALID_PARAMETER is returned.  The limit can be changed by modifying the DWORD in the registry, 
        /// HKLM\SYSTEM\CurrentControlSet\Services\nm3\OlpFilterConditionMaxCount. 
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The capture engine handle returned from NmOpenCaptureEngine.</param>
        /// <param name="ulAdapterIndex">[in] The adapter the filter was added to.</param>
        /// <param name="ulFilterId">[in] The filter id returned from NmCreateOlpFilter and used to reference the OLP Filter.</param>
        /// <param name="ulOption">[in] The option defined for filter configuration.  Reserved.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_INVALID_PARAMETER: Invalid handle, or driver parameter validation failed, or filter is invalid (no OLP inside).
        ///     ERROR_NOT_ENOUGH_MEMORY: No memory to construct filter.
        ///     ERROR_NO_SYSTEM_RESOURCES: Too many OLP in driver or not enough resource for the operation.
        ///     ERROR_BUSY: The driver is not in the proper state for this operation.
        ///     ERROR_OBJECT_ALREADY_EXISTS: The specified filter already exists in driver.
        ///     ERROR_NOT_FOUND: not found specified capture engine, adapter or filter
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmAddDriverCaptureFilter(IntPtr hCaptureEngine, UInt32 ulAdapterIndex, UInt32 ulFilterId, UInt32 ulOption);

        /// <summary><c>NmDeleteDriverCaptureFilter</c>Remove capture filter from the driver </summary> 
        /// <remarks>
        /// Removes the driver capture filter specified by filter ID created by NmCreateOlpFilter.
        /// The filter will no longer available afterwards.  All entities are also cleaned up and
        /// no longer available.
        ///
        /// This function must be called when the adapter is not actively capturing.
        ///
        /// All driver capture filters are deleted from driver when the application terminates.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The capture engine handle returned by NmOpenCaptureEngine.</param>
        /// <param name="ulAdapterIndex">[in] The adapter the filter is to be removed from</param>
        /// <param name="ulFilterId">[in] The capture filter id to delete, created by NmCreateOlpFilter.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_BUSY: The driver is not in the proper state for this operation.
        ///     ERROR_NOT_FOUND: not found specified capture engine, adapter or filter.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmDeleteDriverCaptureFilter(IntPtr hCaptureEngine, UInt32 ulAdapterIndex, UInt32 ulFilterId);

        /// <summary><c>NmGetLiveCaptureFrameCounts</c>Return the frame counters of the adapter</summary> 
        /// <remarks>
        ///     The counters in PNM_CAPTURE_STATISTICS are reported for the specified adapter.
        ///     If there are multiple capture engines capture on the same adapter, they share the same counter set.
        /// </remarks>
        /// <example>
        /// <code>
        /// </code>
        /// </example>
        ///
        /// <exception>None</exception>
        /// <param name="hCaptureEngine">[in] The capture engine handle returned by NmOpenCaptureEngine.</param>
        /// <param name="ulAdapterIndex">[in] The adapter index.</param>
        /// <param name="pCaptureStatistics">[out] The capture statistics of the specified adapter.</param>
        /// <permission cref="System.Security.PermissionSet">Everyone can access this method.</permission>
        /// <returns>
        ///     ERROR_SUCCESS:
        ///     ERROR_NOT_FOUND: not found specified adapter.
        ///     ERROR_BAD_ARGUMENTS: Invalid handle or NULL pointer.
        /// </returns>
        [DllImport("NmApi.Dll")]
        public static extern UInt32 NmGetLiveCaptureFrameCounts(IntPtr hCaptureEngine, UInt32 ulAdapterIndex, ref NM_CAPTURE_STATISTICS pCaptureStatistics);

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\DebugForm.Designer.cs ===
﻿namespace TestThroughSG
{
    partial class DebugForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose (bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.Label label1;
            System.Windows.Forms.ColumnHeader columnHeader1;
            System.Windows.Forms.ColumnHeader columnHeader2;
            System.Windows.Forms.ColumnHeader columnHeader3;
            System.Windows.Forms.GroupBox groupBox1;
            System.Windows.Forms.Label label8;
            System.Windows.Forms.Label label7;
            System.Windows.Forms.Label label6;
            System.Windows.Forms.Label label5;
            System.Windows.Forms.Label label4;
            System.Windows.Forms.Label label3;
            System.Windows.Forms.Label label2;
            System.Windows.Forms.GroupBox groupBox2;
            System.Windows.Forms.Label label12;
            System.Windows.Forms.Label label13;
            System.Windows.Forms.Label label14;
            System.Windows.Forms.GroupBox groupBox3;
            System.Windows.Forms.Label label11;
            System.Windows.Forms.Label label15;
            this.lblRawSocketReceived = new System.Windows.Forms.Label();
            this.lblDroppedTooLarge = new System.Windows.Forms.Label();
            this.lblDroppedBadProtocol = new System.Windows.Forms.Label();
            this.lblDroppedFragmented = new System.Windows.Forms.Label();
            this.lblDroppedSizeMismatch = new System.Windows.Forms.Label();
            this.lblDroppedNotOurAddress = new System.Windows.Forms.Label();
            this.lblDroppedTooSmall = new System.Windows.Forms.Label();
            this.tbcMain = new System.Windows.Forms.TabControl();
            this.tbpStats = new System.Windows.Forms.TabPage();
            this.lstRedirected = new System.Windows.Forms.ListView();
            this.tbpCap = new System.Windows.Forms.TabPage();
            this.tmrUpdate = new System.Windows.Forms.Timer(this.components);
            this.lblDroppedDeadSAA = new System.Windows.Forms.Label();
            this.lblBridgeSGConnCount = new System.Windows.Forms.Label();
            this.lblBridgeSAACount = new System.Windows.Forms.Label();
            this.lblRawSocketSent = new System.Windows.Forms.Label();
            this.lblDroppedNotSent = new System.Windows.Forms.Label();
            label1 = new System.Windows.Forms.Label();
            columnHeader1 = new System.Windows.Forms.ColumnHeader();
            columnHeader2 = new System.Windows.Forms.ColumnHeader();
            columnHeader3 = new System.Windows.Forms.ColumnHeader();
            groupBox1 = new System.Windows.Forms.GroupBox();
            label8 = new System.Windows.Forms.Label();
            label7 = new System.Windows.Forms.Label();
            label6 = new System.Windows.Forms.Label();
            label5 = new System.Windows.Forms.Label();
            label4 = new System.Windows.Forms.Label();
            label3 = new System.Windows.Forms.Label();
            label2 = new System.Windows.Forms.Label();
            groupBox2 = new System.Windows.Forms.GroupBox();
            label12 = new System.Windows.Forms.Label();
            label13 = new System.Windows.Forms.Label();
            label14 = new System.Windows.Forms.Label();
            groupBox3 = new System.Windows.Forms.GroupBox();
            label11 = new System.Windows.Forms.Label();
            label15 = new System.Windows.Forms.Label();
            groupBox1.SuspendLayout();
            groupBox2.SuspendLayout();
            this.tbcMain.SuspendLayout();
            this.tbpStats.SuspendLayout();
            groupBox3.SuspendLayout();
            this.SuspendLayout();
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new System.Drawing.Point(6, 3);
            label1.Name = "label1";
            label1.Size = new System.Drawing.Size(109, 13);
            label1.TabIndex = 0;
            label1.Text = "Redirected Interfaces";
            // 
            // columnHeader1
            // 
            columnHeader1.Text = "Virtual Interface";
            columnHeader1.Width = 110;
            // 
            // columnHeader2
            // 
            columnHeader2.Text = "Service Port";
            columnHeader2.Width = 80;
            // 
            // columnHeader3
            // 
            columnHeader3.Text = "Internet Port";
            columnHeader3.Width = 80;
            // 
            // groupBox1
            // 
            groupBox1.Controls.Add(this.lblRawSocketReceived);
            groupBox1.Controls.Add(this.lblDroppedTooLarge);
            groupBox1.Controls.Add(this.lblDroppedBadProtocol);
            groupBox1.Controls.Add(this.lblDroppedFragmented);
            groupBox1.Controls.Add(this.lblDroppedSizeMismatch);
            groupBox1.Controls.Add(this.lblDroppedNotOurAddress);
            groupBox1.Controls.Add(this.lblDroppedTooSmall);
            groupBox1.Controls.Add(label8);
            groupBox1.Controls.Add(label7);
            groupBox1.Controls.Add(label6);
            groupBox1.Controls.Add(label5);
            groupBox1.Controls.Add(label4);
            groupBox1.Controls.Add(label3);
            groupBox1.Controls.Add(label2);
            groupBox1.Location = new System.Drawing.Point(9, 157);
            groupBox1.Name = "groupBox1";
            groupBox1.Size = new System.Drawing.Size(320, 155);
            groupBox1.TabIndex = 3;
            groupBox1.TabStop = false;
            groupBox1.Text = "Outbound Traffic - Raw Socket";
            // 
            // lblRawSocketReceived
            // 
            this.lblRawSocketReceived.AutoSize = true;
            this.lblRawSocketReceived.Location = new System.Drawing.Point(147, 133);
            this.lblRawSocketReceived.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblRawSocketReceived.Name = "lblRawSocketReceived";
            this.lblRawSocketReceived.Size = new System.Drawing.Size(41, 13);
            this.lblRawSocketReceived.TabIndex = 13;
            this.lblRawSocketReceived.Text = "label15";
            // 
            // lblDroppedTooLarge
            // 
            this.lblDroppedTooLarge.AutoSize = true;
            this.lblDroppedTooLarge.Location = new System.Drawing.Point(147, 114);
            this.lblDroppedTooLarge.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblDroppedTooLarge.Name = "lblDroppedTooLarge";
            this.lblDroppedTooLarge.Size = new System.Drawing.Size(41, 13);
            this.lblDroppedTooLarge.TabIndex = 12;
            this.lblDroppedTooLarge.Text = "label14";
            // 
            // lblDroppedBadProtocol
            // 
            this.lblDroppedBadProtocol.AutoSize = true;
            this.lblDroppedBadProtocol.Location = new System.Drawing.Point(147, 95);
            this.lblDroppedBadProtocol.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblDroppedBadProtocol.Name = "lblDroppedBadProtocol";
            this.lblDroppedBadProtocol.Size = new System.Drawing.Size(41, 13);
            this.lblDroppedBadProtocol.TabIndex = 11;
            this.lblDroppedBadProtocol.Text = "label13";
            // 
            // lblDroppedFragmented
            // 
            this.lblDroppedFragmented.AutoSize = true;
            this.lblDroppedFragmented.Location = new System.Drawing.Point(147, 76);
            this.lblDroppedFragmented.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblDroppedFragmented.Name = "lblDroppedFragmented";
            this.lblDroppedFragmented.Size = new System.Drawing.Size(41, 13);
            this.lblDroppedFragmented.TabIndex = 10;
            this.lblDroppedFragmented.Text = "label12";
            // 
            // lblDroppedSizeMismatch
            // 
            this.lblDroppedSizeMismatch.AutoSize = true;
            this.lblDroppedSizeMismatch.Location = new System.Drawing.Point(147, 57);
            this.lblDroppedSizeMismatch.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblDroppedSizeMismatch.Name = "lblDroppedSizeMismatch";
            this.lblDroppedSizeMismatch.Size = new System.Drawing.Size(41, 13);
            this.lblDroppedSizeMismatch.TabIndex = 9;
            this.lblDroppedSizeMismatch.Text = "label11";
            // 
            // lblDroppedNotOurAddress
            // 
            this.lblDroppedNotOurAddress.AutoSize = true;
            this.lblDroppedNotOurAddress.Location = new System.Drawing.Point(147, 38);
            this.lblDroppedNotOurAddress.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblDroppedNotOurAddress.Name = "lblDroppedNotOurAddress";
            this.lblDroppedNotOurAddress.Size = new System.Drawing.Size(41, 13);
            this.lblDroppedNotOurAddress.TabIndex = 8;
            this.lblDroppedNotOurAddress.Text = "label10";
            // 
            // lblDroppedTooSmall
            // 
            this.lblDroppedTooSmall.AutoSize = true;
            this.lblDroppedTooSmall.Location = new System.Drawing.Point(147, 19);
            this.lblDroppedTooSmall.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblDroppedTooSmall.Name = "lblDroppedTooSmall";
            this.lblDroppedTooSmall.Size = new System.Drawing.Size(35, 13);
            this.lblDroppedTooSmall.TabIndex = 7;
            this.lblDroppedTooSmall.Text = "label9";
            // 
            // label8
            // 
            label8.Location = new System.Drawing.Point(6, 133);
            label8.Margin = new System.Windows.Forms.Padding(3);
            label8.Name = "label8";
            label8.Size = new System.Drawing.Size(135, 13);
            label8.TabIndex = 6;
            label8.Text = "Received";
            label8.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label7
            // 
            label7.Location = new System.Drawing.Point(6, 114);
            label7.Margin = new System.Windows.Forms.Padding(3);
            label7.Name = "label7";
            label7.Size = new System.Drawing.Size(135, 13);
            label7.TabIndex = 5;
            label7.Text = "Dropped Too Large";
            label7.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label6
            // 
            label6.Location = new System.Drawing.Point(6, 95);
            label6.Margin = new System.Windows.Forms.Padding(3);
            label6.Name = "label6";
            label6.Size = new System.Drawing.Size(135, 13);
            label6.TabIndex = 4;
            label6.Text = "Dropped Bad Protocol";
            label6.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label5
            // 
            label5.Location = new System.Drawing.Point(6, 76);
            label5.Margin = new System.Windows.Forms.Padding(3);
            label5.Name = "label5";
            label5.Size = new System.Drawing.Size(135, 13);
            label5.TabIndex = 3;
            label5.Text = "Dropped Fragmented";
            label5.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label4
            // 
            label4.Location = new System.Drawing.Point(6, 57);
            label4.Margin = new System.Windows.Forms.Padding(3);
            label4.Name = "label4";
            label4.Size = new System.Drawing.Size(135, 13);
            label4.TabIndex = 2;
            label4.Text = "Dropped Size Mismatch";
            label4.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label3
            // 
            label3.Location = new System.Drawing.Point(6, 38);
            label3.Margin = new System.Windows.Forms.Padding(3);
            label3.Name = "label3";
            label3.Size = new System.Drawing.Size(135, 13);
            label3.TabIndex = 1;
            label3.Text = "Dropped Not Our Address";
            label3.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label2
            // 
            label2.Location = new System.Drawing.Point(6, 19);
            label2.Margin = new System.Windows.Forms.Padding(3);
            label2.Name = "label2";
            label2.Size = new System.Drawing.Size(135, 13);
            label2.TabIndex = 0;
            label2.Text = "Dropped Too Small";
            label2.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // groupBox2
            // 
            groupBox2.Controls.Add(this.lblDroppedDeadSAA);
            groupBox2.Controls.Add(this.lblBridgeSGConnCount);
            groupBox2.Controls.Add(this.lblBridgeSAACount);
            groupBox2.Controls.Add(label12);
            groupBox2.Controls.Add(label13);
            groupBox2.Controls.Add(label14);
            groupBox2.Location = new System.Drawing.Point(9, 327);
            groupBox2.Name = "groupBox2";
            groupBox2.Size = new System.Drawing.Size(320, 79);
            groupBox2.TabIndex = 4;
            groupBox2.TabStop = false;
            groupBox2.Text = "Outbound Traffic - Bridge";
            // 
            // tbcMain
            // 
            this.tbcMain.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.tbcMain.Controls.Add(this.tbpStats);
            this.tbcMain.Controls.Add(this.tbpCap);
            this.tbcMain.Location = new System.Drawing.Point(5, 31);
            this.tbcMain.Name = "tbcMain";
            this.tbcMain.SelectedIndex = 0;
            this.tbcMain.Size = new System.Drawing.Size(374, 512);
            this.tbcMain.TabIndex = 0;
            // 
            // tbpStats
            // 
            this.tbpStats.AutoScroll = true;
            this.tbpStats.Controls.Add(groupBox3);
            this.tbpStats.Controls.Add(groupBox2);
            this.tbpStats.Controls.Add(groupBox1);
            this.tbpStats.Controls.Add(this.lstRedirected);
            this.tbpStats.Controls.Add(label1);
            this.tbpStats.Location = new System.Drawing.Point(4, 22);
            this.tbpStats.Name = "tbpStats";
            this.tbpStats.Padding = new System.Windows.Forms.Padding(3);
            this.tbpStats.Size = new System.Drawing.Size(366, 486);
            this.tbpStats.TabIndex = 0;
            this.tbpStats.Text = "Statistics";
            this.tbpStats.UseVisualStyleBackColor = true;
            // 
            // lstRedirected
            // 
            this.lstRedirected.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            columnHeader1,
            columnHeader2,
            columnHeader3});
            this.lstRedirected.FullRowSelect = true;
            this.lstRedirected.Location = new System.Drawing.Point(9, 19);
            this.lstRedirected.Name = "lstRedirected";
            this.lstRedirected.Size = new System.Drawing.Size(320, 123);
            this.lstRedirected.TabIndex = 1;
            this.lstRedirected.UseCompatibleStateImageBehavior = false;
            this.lstRedirected.View = System.Windows.Forms.View.Details;
            // 
            // tbpCap
            // 
            this.tbpCap.Location = new System.Drawing.Point(4, 22);
            this.tbpCap.Name = "tbpCap";
            this.tbpCap.Padding = new System.Windows.Forms.Padding(3);
            this.tbpCap.Size = new System.Drawing.Size(526, 603);
            this.tbpCap.TabIndex = 1;
            this.tbpCap.Text = "Packet Capture";
            this.tbpCap.UseVisualStyleBackColor = true;
            // 
            // tmrUpdate
            // 
            this.tmrUpdate.Interval = 1000;
            this.tmrUpdate.Tick += new System.EventHandler(this.tmrUpdate_Tick);
            // 
            // lblDroppedDeadSAA
            // 
            this.lblDroppedDeadSAA.AutoSize = true;
            this.lblDroppedDeadSAA.Location = new System.Drawing.Point(147, 57);
            this.lblDroppedDeadSAA.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblDroppedDeadSAA.Name = "lblDroppedDeadSAA";
            this.lblDroppedDeadSAA.Size = new System.Drawing.Size(41, 13);
            this.lblDroppedDeadSAA.TabIndex = 15;
            this.lblDroppedDeadSAA.Text = "label11";
            // 
            // lblBridgeSGConnCount
            // 
            this.lblBridgeSGConnCount.AutoSize = true;
            this.lblBridgeSGConnCount.Location = new System.Drawing.Point(147, 38);
            this.lblBridgeSGConnCount.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblBridgeSGConnCount.Name = "lblBridgeSGConnCount";
            this.lblBridgeSGConnCount.Size = new System.Drawing.Size(41, 13);
            this.lblBridgeSGConnCount.TabIndex = 14;
            this.lblBridgeSGConnCount.Text = "label10";
            // 
            // lblBridgeSAACount
            // 
            this.lblBridgeSAACount.AutoSize = true;
            this.lblBridgeSAACount.Location = new System.Drawing.Point(147, 19);
            this.lblBridgeSAACount.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblBridgeSAACount.Name = "lblBridgeSAACount";
            this.lblBridgeSAACount.Size = new System.Drawing.Size(35, 13);
            this.lblBridgeSAACount.TabIndex = 13;
            this.lblBridgeSAACount.Text = "label9";
            // 
            // label12
            // 
            label12.Location = new System.Drawing.Point(6, 57);
            label12.Margin = new System.Windows.Forms.Padding(3);
            label12.Name = "label12";
            label12.Size = new System.Drawing.Size(135, 13);
            label12.TabIndex = 12;
            label12.Text = "Dropped Dead Assoc";
            label12.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label13
            // 
            label13.Location = new System.Drawing.Point(6, 38);
            label13.Margin = new System.Windows.Forms.Padding(3);
            label13.Name = "label13";
            label13.Size = new System.Drawing.Size(135, 13);
            label13.TabIndex = 11;
            label13.Text = "SG Connections";
            label13.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label14
            // 
            label14.Location = new System.Drawing.Point(6, 19);
            label14.Margin = new System.Windows.Forms.Padding(3);
            label14.Name = "label14";
            label14.Size = new System.Drawing.Size(135, 13);
            label14.TabIndex = 10;
            label14.Text = "Active Associations";
            label14.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // groupBox3
            // 
            groupBox3.Controls.Add(this.lblRawSocketSent);
            groupBox3.Controls.Add(this.lblDroppedNotSent);
            groupBox3.Controls.Add(label11);
            groupBox3.Controls.Add(label15);
            groupBox3.Location = new System.Drawing.Point(9, 412);
            groupBox3.Name = "groupBox3";
            groupBox3.Size = new System.Drawing.Size(320, 61);
            groupBox3.TabIndex = 5;
            groupBox3.TabStop = false;
            groupBox3.Text = "Inbound Traffic";
            // 
            // lblRawSocketSent
            // 
            this.lblRawSocketSent.AutoSize = true;
            this.lblRawSocketSent.Location = new System.Drawing.Point(147, 38);
            this.lblRawSocketSent.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblRawSocketSent.Name = "lblRawSocketSent";
            this.lblRawSocketSent.Size = new System.Drawing.Size(41, 13);
            this.lblRawSocketSent.TabIndex = 18;
            this.lblRawSocketSent.Text = "label10";
            // 
            // lblDroppedNotSent
            // 
            this.lblDroppedNotSent.AutoSize = true;
            this.lblDroppedNotSent.Location = new System.Drawing.Point(147, 19);
            this.lblDroppedNotSent.Margin = new System.Windows.Forms.Padding(6, 0, 3, 0);
            this.lblDroppedNotSent.Name = "lblDroppedNotSent";
            this.lblDroppedNotSent.Size = new System.Drawing.Size(35, 13);
            this.lblDroppedNotSent.TabIndex = 17;
            this.lblDroppedNotSent.Text = "label9";
            // 
            // label11
            // 
            label11.Location = new System.Drawing.Point(6, 38);
            label11.Margin = new System.Windows.Forms.Padding(3);
            label11.Name = "label11";
            label11.Size = new System.Drawing.Size(135, 13);
            label11.TabIndex = 16;
            label11.Text = "Sent";
            label11.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label15
            // 
            label15.Location = new System.Drawing.Point(6, 19);
            label15.Margin = new System.Windows.Forms.Padding(3);
            label15.Name = "label15";
            label15.Size = new System.Drawing.Size(135, 13);
            label15.TabIndex = 15;
            label15.Text = "Dropped Not Sent";
            label15.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // DebugForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(384, 548);
            this.Controls.Add(this.tbcMain);
            this.MinimumSize = new System.Drawing.Size(400, 100);
            this.Name = "DebugForm";
            this.Text = "Test Through SG Debugging";
            this.Shown += new System.EventHandler(this.DebugForm_Shown);
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.DebugForm_FormClosed);
            groupBox1.ResumeLayout(false);
            groupBox1.PerformLayout();
            groupBox2.ResumeLayout(false);
            groupBox2.PerformLayout();
            this.tbcMain.ResumeLayout(false);
            this.tbpStats.ResumeLayout(false);
            this.tbpStats.PerformLayout();
            groupBox3.ResumeLayout(false);
            groupBox3.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TabControl tbcMain;
        private System.Windows.Forms.TabPage tbpStats;
        private System.Windows.Forms.TabPage tbpCap;
        private System.Windows.Forms.ListView lstRedirected;
        private System.Windows.Forms.Timer tmrUpdate;
        private System.Windows.Forms.Label lblRawSocketReceived;
        private System.Windows.Forms.Label lblDroppedTooLarge;
        private System.Windows.Forms.Label lblDroppedBadProtocol;
        private System.Windows.Forms.Label lblDroppedFragmented;
        private System.Windows.Forms.Label lblDroppedSizeMismatch;
        private System.Windows.Forms.Label lblDroppedNotOurAddress;
        private System.Windows.Forms.Label lblDroppedTooSmall;
        private System.Windows.Forms.Label lblDroppedDeadSAA;
        private System.Windows.Forms.Label lblBridgeSGConnCount;
        private System.Windows.Forms.Label lblBridgeSAACount;
        private System.Windows.Forms.Label lblRawSocketSent;
        private System.Windows.Forms.Label lblDroppedNotSent;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\NetmonAPIWrapper.cs ===
using System;
using System.Collections.Generic;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;

namespace Microsoft.NetworkMonitor.Wrapper
{
    #region Struct Wrappers

    /// <summary>
    /// The values that can be assigned to the API configuration's ThreadingMode.
    /// </summary>
    public enum NmThreadingMode : ushort
    {
        COINIT_MULTITHREADED = 0,
        COINIT_APARTMENTTHREADED = 2,
    }

    /// <summary>
    /// Wrapper for NM_API_CONFIGURATION.
    /// </summary>
    public class NmApiConfiguration
    {
        public NM_API_CONFIGURATION Value;

        public NmApiConfiguration ()
        {
            Value.Size = (ushort)Marshal.SizeOf(typeof(NM_API_CONFIGURATION));
        }

        /// <summary>The threading mode of the configuration.</summary>
        public NmThreadingMode ThreadingMode
        {
            get { return (NmThreadingMode)Value.ThreadingMode; }
            set { Value.ThreadingMode = (ushort)value; }
        }
    }

    /// <summary>
    /// Wrapper for NM_NIC_ADAPTER_INFO.
    /// </summary>
    public class NmNicAdapterInfo
    {
        public NM_NIC_ADAPTER_INFO Value;

        public NmNicAdapterInfo ()
        {
            Value.Size = (ushort)Marshal.SizeOf(typeof(NM_NIC_ADAPTER_INFO));
        }
    }

    /// <summary>
    /// Wrapper for NM_CAPTURE_STATISTICS.
    /// </summary>
    public class NmCaptureStatistics
    {
        public NM_CAPTURE_STATISTICS Value;

        public NmCaptureStatistics ()
        {
            Value.Size = (ushort)Marshal.SizeOf(typeof(NM_CAPTURE_STATISTICS));
        }
    }

    #endregion

    /// <summary>
    /// Contains globally accessible Netmon API functions.
    /// </summary>
    public static class Global
    {
        #region API Operations

        //public static extern void NmGetApiVersion (out UInt16 Major, out UInt16 Minor, out UInt16 Build, out UInt16 Revision);

        #endregion

        #region Capture Engine Operations

        //public static extern UInt32 NmPauseCapture (IntPtr hCaptureEngine, UInt32 ulAdapterIndex);

        //public static extern UInt32 NmResumeCapture (IntPtr hCaptureEngine, UInt32 ulAdapterIndex);

        #endregion

        #region Parsing Functions

        //public static extern UInt32 NmLoadNplParser ([MarshalAs(UnmanagedType.LPWStr)] String pFileName, NmNplParserLoadingOption ulFlags, ParserCallbackDelegate CallbackFunction, IntPtr pCallerContext, out IntPtr phNplParser);

        //public static extern UInt32 NmCreateFrameParserConfiguration (IntPtr hNplParser, ParserCallbackDelegate CallbackFunction, IntPtr pCallerContext, out IntPtr phFrameParserConfiguration);

        //public static extern UInt32 NmAddFilter (IntPtr hFrameParserConfiguration, [MarshalAs(UnmanagedType.LPWStr)] String pFilterString, out UInt32 ulFilterId);

        //public static extern UInt32 NmAddField (IntPtr hFrameParserConfiguration, [MarshalAs(UnmanagedType.LPWStr)] String pFieldString, out UInt32 ulFieldId);

        //public static extern UInt32 NmAddProperty (IntPtr hFrameParserConfiguration, [MarshalAs(UnmanagedType.LPWStr)] String pPropertyString, out UInt32 ulPropertyId);

        //public static extern UInt32 NmAddSequenceOrderConfig (IntPtr hFrameParserConfiguration, ref NM_PROTOCOL_SEQUENCE_CONFIG SeqConfig, out UInt32 ulConfigId);

        //public static extern UInt32 NmConfigReassembly (IntPtr hFrameParserConfiguration, NmReassemblyConfigOption Option, Boolean bEnable);

        //public static extern UInt32 NmConfigConversation (IntPtr hFrameParserConfiguration, NmConversationConfigOption Option, Boolean bEnable);

        //public static extern UInt32 NmCreateFrameParser (IntPtr hFrameParserConfiguration, out IntPtr phParser, NmFrameParserOptimizeOption OptimizeOption);

        //public static extern UInt32 NmConfigStartDataType (IntPtr hFrameParserConfiguration, [MarshalAs(UnmanagedType.LPWStr)] String StartDataTypeName);

        //unsafe public static extern UInt32 NmGetStartDataType (IntPtr hFrameParserConfiguration, UInt32 ulBufferLength, char* pBuffer);


        #endregion

        #region Parsed Frame Operations

        //public static extern UInt32 NmParseFrame (IntPtr hFrameParser, IntPtr hRawFrame, UInt32 ulFrameNumber, NmFrameParsingOption Options, out IntPtr phParsedFrame, out IntPtr phInsertedRawFrame);

        //public static extern UInt32 NmParseBuffer (IntPtr hParser, Byte[] DataBuffer, UInt32 ulBufferLength, UInt32 ulFrameNumber, NmFrameParsingOption Options, out IntPtr phParsedFrame);

        //public static extern UInt32 NmBuildRawFrameFromBuffer (IntPtr DataBuffer, UInt32 ulBufferLength, UInt32 ulMedia, UInt64 ullTimeStamp, out IntPtr phRawFrame);

        //public static extern UInt32 NmBuildRawFrameFromBufferEx (IntPtr DataBuffer, UInt32 ulBufferLength, UInt32 ulMedia, ref NM_TIME pTime, out IntPtr phRawFrame);

        //public static extern UInt32 NmGetFrameFragmentInfo (IntPtr hParsedFrame, ref NmFragmentationInfo FragmentationInfo);

        //public static extern UInt32 NmGetFilterCount (IntPtr hFrameParser, out UInt32 ulFilterCount);

        //public static extern UInt32 NmEvaluateFilter (IntPtr hParsedFrame, UInt32 ulFilterId, out Boolean bPassFilter);

        //public static extern UInt32 NmGetFieldCount (IntPtr hParsedFrame, out UInt32 ulFieldCount);

        //public static extern UInt32 NmGetParsedFieldInfo (IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulOption, ref NmParsedFieldInfo pParsedFieldInfo);

        //public static extern UInt32 NmGetParsedFieldInfoEx (IntPtr hParsedFrame, IntPtr ulFieldId, IntPtr ulOption, ref NmParsedFieldInfoEx pParsedFieldInfoEx);

        //unsafe public static extern UInt32 NmGetFieldName (IntPtr hParsedFrame, UInt32 ulFieldId, NmParsedFieldNames RequestedName, UInt32 ulBufferLength, char* pBuffer);

        //public static extern UInt32 NmGetFieldOffsetAndSize (IntPtr hParsedFrame, UInt32 ulFieldId, out UInt32 ulFieldOffset, out UInt32 ulFieldSize);

        //public static extern UInt32 NmGetFieldValueNumber8Bit (IntPtr hParsedFrame, UInt32 ulFieldId, out Byte ubNumber);

        //public static extern UInt32 NmGetFieldValueNumber16Bit (IntPtr hParsedFrame, UInt32 ulFieldId, out UInt16 uiNumber);

        //public static extern UInt32 NmGetFieldValueNumber32Bit (IntPtr hParsedFrame, UInt32 ulFieldId, out UInt32 ulNumber);

        //public static extern UInt32 NmGetFieldValueNumber64Bit (IntPtr hParsedFrame, UInt32 ulFieldId, out UInt64 ullNumber);

        //unsafe public static extern UInt32 NmGetFieldValueByteArray (IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulByteLength, byte* pBuffer, out UInt32 ulReturnLength);

        //unsafe public static extern UInt32 NmGetFieldValueString (IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulBufferLength, char* pValueBuffer);

        //unsafe public static extern UInt32 NmGetFieldInBuffer (IntPtr hParsedFrame, UInt32 ulFieldId, UInt32 ulBufferLength, byte* pFieldBuffer, out UInt32 ulReturnLength);

        //public static extern UInt32 NmGetRequestedPropertyCount (IntPtr hFrameParser, out UInt32 ulCount);

        //public static extern UInt32 NmGetPropertyInfo (IntPtr hFrameParser, UInt32 ulPropertyId, ref NM_NPL_PROPERTY_INFO pInfo);

        //unsafe public static extern UInt32 NmGetPropertyById (IntPtr hFrameParser, UInt32 ulPropertyId, UInt32 ulBufferSize, byte* pBuffer, out UInt32 ulReturnLength, out NmPropertyValueType ulType, UInt32 ulKeyCount, CNmPropertyStorageKey[] pKeyArray);

        //unsafe public static extern UInt32 NmGetPropertyByName (IntPtr hFrameParser, [MarshalAs(UnmanagedType.LPWStr)] String pPropertyName, UInt32 ulBufferSize, byte* pBuffer, out UInt32 pulReturnLength, out NmPropertyValueType ulType, UInt32 ulKeyCount, CNmPropertyStorageKey[] pKeyArray);

        #endregion

        #region Raw Frame Operations

        //public static extern UInt32 NmGetRawFrameLength (IntPtr hFrame, out UInt32 pulLength);

        //unsafe public static extern UInt32 NmGetRawFrame (IntPtr hFrame, UInt32 ulLength, byte* pFrameBuffer, out UInt32 pulReturnLength);

        //unsafe public static extern UInt32 NmGetPartialRawFrame (IntPtr hRawFrame, UInt32 ulFrameOffset, UInt32 ulBufferLength, byte* pFrameBuffer, out UInt32 pulReturnLength);

        //public static extern UInt32 NmGetFrameMacType (IntPtr hFrame, out UInt32 pulMacType);

        //public static extern UInt32 NmGetFrameTimeStamp (IntPtr hFrame, out UInt64 pTimeStamp);

        //public static extern UInt32 NmGetFrameTimeStampEx (IntPtr hFrame, ref NM_TIME pTime);

        //unsafe public static extern UInt32 NmGetFrameCommentInfo (IntPtr hFrame, ref UInt32 ulCommentTitleBufferLength, byte* pCommentTitleBuffer, ref UInt32 ulCommentDescriptionBufferLength, byte* pCommentDescriptionBuffer);

        #endregion

        #region Capture File Operations

        //public static extern UInt32 NmCreateCaptureFile ([MarshalAs(UnmanagedType.LPWStr)] String pFileName, UInt32 ulSize, NmCaptureFileFlag ulFlags, out IntPtr phCaptureFile, out UInt32 ulReturnSize);

        //public static extern UInt32 NmOpenCaptureFile ([MarshalAs(UnmanagedType.LPWStr)] String pFileName, out IntPtr phCaptureFile);

        //public static extern UInt32 NmOpenCaptureFileInOrder ([MarshalAs(UnmanagedType.LPWStr)] String pFileName, ref NM_ORDER_PARSER_PARAMETER pOrderParser, out IntPtr phCaptureFile);

        //public static extern UInt32 NmAddFrame (IntPtr hCaptureFile, IntPtr hFrame);

        //public static extern UInt32 NmGetFrameCount (IntPtr hCaptureFile, out UInt32 hFrameCount);

        //public static extern UInt32 NmGetFrame (IntPtr hCaptureFile, UInt32 ulFrameNumber, out IntPtr phFrame);
        #endregion

        #region NPL Property Extension

        //unsafe public static extern UInt32 NmGetTopConversation (IntPtr hParsedFrame, UInt32 ulBufferESize, char* pProtocolName, out UInt32 pulProtocolNameLength, out UInt32 pulConversationID);

        //unsafe public static extern UInt32 NmGetParentConversation (IntPtr hParsedFrame, UInt32 ulConversationId, UInt32 ulBufferESize, char* pParentProtocolNameBuffer, out UInt32 ulParentProtocolNameLength, out UInt32 ulParentConversationID);

        #endregion

        #region Parser Profile Operations

        //public static extern UInt32 NmLoadWithNplProfile ([MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid, NmNplParserLoadingOption ulFlags, ParserCallbackDelegate CallbackFunction, IntPtr pCallerContext, out IntPtr phNplParser);

        //public static extern UInt32 NmCreateNplProfile ([MarshalAs(UnmanagedType.LPWStr)] String Name, [MarshalAs(UnmanagedType.LPWStr)] String Description,
        //                                                      [MarshalAs(UnmanagedType.LPWStr)] String IncludePath, [MarshalAs(UnmanagedType.LPWStr)] String Guid,
        //                                                      [MarshalAs(UnmanagedType.LPWStr)] String templateID);

        //public static extern UInt32 NmGetNplProfileAttribute (UInt32 ulIndex, NmNplProfileAttribute attribute, ref UInt32 ulBufferELength, [MarshalAs(UnmanagedType.LPWStr)] String pAttributeBuffer);

        //public static extern UInt32 NmGetNplProfileAttributeByGuid ([MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid, NmNplProfileAttribute attribute, ref UInt32 ulBufferELength, [MarshalAs(UnmanagedType.LPWStr)] String pAttributeBuffer);

        //public static extern UInt32 NmSetNplProfileAttribute (UInt32 ulIndex, NmNplProfileAttribute attribute, [MarshalAs(UnmanagedType.LPWStr)] String pAttributeBuffer);

        //public static extern UInt32 NmSetNplProfileAttributeByGuid ([MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid, NmNplProfileAttribute attribute, [MarshalAs(UnmanagedType.LPWStr)] String pAttributeBuffer);

        //public static extern UInt32 NmGetNplProfileCount (out UInt32 pulCount);

        //public static extern UInt32 NmGetActiveNplProfileGuid (ref UInt32 ulBufferELength, [MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid);

        //public static extern UInt32 NmSetActiveNplProfile ([MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid);

        //public static extern UInt32 NmDeleteNplProfile ([MarshalAs(UnmanagedType.LPWStr)] String pProfileGuid);

        #endregion

        #region Driver Capture Filter Operations

        //public static extern UInt32 NmCreateOlp (UInt32 BitOffset,
        //                                        UInt32 BitLength,
        //                                        System.Byte[] pPattern,
        //                                        NmFilterMatchMode OpMode,
        //                                        NmOlpActionFlags Options,
        //                                        out UInt32 pulOlpId);

        //public static extern UInt32 NmCreateOlpBlock (UInt32 ulConditionCount, NmOlpActionFlags ulOptions, out UInt32 pulOlpBlockId);

        //public static extern UInt32 NmAddOlpToBlock (UInt32 ulOlpBlockId, UInt32 ulIndex, UInt32 ulOlpId);

        //public static extern UInt32 NmCreateOlpFilter (UInt32 ulBlockCount, UInt32 ulOptions, out UInt32 pulOlpFilterId);

        //public static extern UInt32 NmAddOlpBlockToFilter (UInt32 ulOlpFilterId, UInt32 ulIndex, UInt32 ulOlpBlockId);

        //public static extern UInt32 NmDeleteOlpEntity (UInt32 ulEntityId);

        //public static extern UInt32 NmAddDriverCaptureFilter (IntPtr hCaptureEngine, UInt32 ulAdapterIndex, UInt32 ulFilterId, UInt32 ulOption);

        //public static extern UInt32 NmDeleteDriverCaptureFilter (IntPtr hCaptureEngine, UInt32 ulAdapterIndex, UInt32 ulFilterId);

        #endregion

        #region Configuration

        /// <summary>
        /// Gets the current NetmonAPI configuration.
        /// </summary>
        /// <returns>The current NetmonAPI configuration.</returns>
        public static NmApiConfiguration GetApiConfiguration ()
        {
            NmApiConfiguration ans = new NmApiConfiguration();
            uint result = NetmonAPI.NmGetApiConfiguration(ref ans.Value);
            return ans;
        }

        #endregion

        #region CaptureEngine Refcounting/Initialization

        /// <summary>The number of CaptureEngine references that exist.</summary>
        private static int _CaptureEngineRefCount = 0;
        
        /// <summary>When true, the initialization has been done successfully.</summary>
        private static bool _initialized = false;

        /// <summary>Lock around initialization.</summary>
        private static object _initializationLock = new object();

        /// <summary>
        /// Add a CaptureEngine reference.  Also initializes the NetmonAPI if necessary.
        /// </summary>
        internal static void AddCaptureEngineRef ()
        {
            System.Threading.Interlocked.Increment(ref _CaptureEngineRefCount);

            if (!_initialized)
            {
                lock (_initializationLock)
                {
                    if (!_initialized)
                    {
                        NmApiConfiguration nmac = GetApiConfiguration();
                        // have to set the threading model appropriately
                        nmac.ThreadingMode = (System.Threading.Thread.CurrentThread.GetApartmentState() == System.Threading.ApartmentState.STA ? 
                            NmThreadingMode.COINIT_APARTMENTTHREADED : NmThreadingMode.COINIT_MULTITHREADED);
                        uint result = NetmonAPI.NmApiInitialize(ref nmac.Value);
                        if (result != 0)
                        {
                            throw new NetmonAPIWrapperException("NmApiInitialize failed", result);
                        }

                        _initialized = true;
                    }
                }
            }
        }

        /// <summary>
        /// Remove a CaptureEngine reference.  Also closes the NetmonAPI if necessary.
        /// </summary>
        internal static void RemoveCaptureEngineRef ()
        {
            if (System.Threading.Interlocked.Decrement(ref _CaptureEngineRefCount) == 0)
            {
                if (_initialized)
                {
                    lock (_initializationLock)
                    {
                        if (_initialized)
                        {
                            uint result = NetmonAPI.NmApiClose();
                            if (result != 0)
                            {
                                throw new NetmonAPIWrapperException("NmApiClose failed", result);
                            }

                            _initialized = false;
                        }
                    }
                }
            }
        }

        #endregion
    }

    /// <summary>
    /// The basic capture mechanic, analagous to a capture tab in Netmon.
    /// </summary>
    /// <remarks>
    /// Could add to Disposal:
    /// StopCapture if its currently going on any adapters
    /// </remarks>
    public class CaptureEngine : IDisposable
    {
        #region Handle

        /// <summary>The handle to the capture engine.</summary>
        private IntPtr _hCaptureEngine = IntPtr.Zero;

        /// <summary>Allows access to retrieve the handle for this capture engine.</summary>
        internal IntPtr hCaptureEngine
        {
            get
            {
                CheckState();
                return _hCaptureEngine;
            }
        }

        /// <summary>Ensures that the object is in a workable state.</summary>
        protected void CheckState ()
        {
            if (_hCaptureEngine == IntPtr.Zero)
            {
                throw new NetmonAPIWrapperException("CaptureEngine has already been disposed");
            }
        }

        #endregion

        public CaptureEngine ()
        {
            Global.AddCaptureEngineRef();

            uint result = NetmonAPI.NmOpenCaptureEngine(out _hCaptureEngine);
            if (result != 0)
            {
                throw new NetmonAPIWrapperException("NmOpenCaptureEngine failed", result);
            }
        }

        /// <summary>The number of adapters available to the capture engine.</summary>
        public uint AdapterCount
        {
            get
            {
                CheckState();

                uint ans;
                uint result = NetmonAPI.NmGetAdapterCount(_hCaptureEngine, out ans);
                if (result != 0)
                {
                    throw new NetmonAPIWrapperException("NmGetAdapterCount failed", result);
                }

                return ans;
            }
        }

        /// <summary>
        /// Gets the adapter at the given index.
        /// </summary>
        /// <param name="index">The index of the adapter to get; must be [0, AdapterCount).</param>
        /// <returns>An adapter object that represents the requested adapter.</returns>
        public Adapter GetAdapter (uint index)
        {
            return new Adapter(this, index);
        }

        #region Disposal

        ~CaptureEngine ()
        {
            Dispose(false);
        }

        public void Dispose ()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        public void Dispose (bool disposing)
        {
            try
            {
                try
                {
                    if (_hCaptureEngine != IntPtr.Zero)
                    {
                        NetmonAPI.NmCloseHandle(_hCaptureEngine);
                        _hCaptureEngine = IntPtr.Zero;
                    }
                }
                finally
                {
                    Global.RemoveCaptureEngineRef();
                }
            }
            catch
            {
                // we don't want to throw in the finalizer code
                if (disposing)
                {
                    throw;
                }
            }
        }

        #endregion
    }

    /// <summary>
    /// An adapter, analagous to a network interface, that is associated with a CaptureEngine.
    /// </summary>
    public class Adapter
    {
        /// <summary>The capture engine that owns this adapter.</summary>
        private CaptureEngine _captureEngine;

        /// <summary>The capture engine that owns this adapter.</summary>
        public CaptureEngine Owner
        {
            get { return _captureEngine; }
        }

        /// <summary>The index of the adapter.</summary>
        private uint _index;

        /// <summary>Adapter information.</summary>
        private NmNicAdapterInfo _nicAdapterInfo;

        internal Adapter (CaptureEngine owner, uint index)
        {
            _captureEngine = owner;
            _index = index;
            _nicAdapterInfo = new NmNicAdapterInfo();
            UpdateAdapterInfo();
        }

        /// <summary>
        /// Retrieve the current adapter info from the NetmonAPI.
        /// </summary>
        public void UpdateAdapterInfo ()
        {
            uint result = NetmonAPI.NmGetAdapter(_captureEngine.hCaptureEngine, _index, ref _nicAdapterInfo.Value);
            if (result != 0)
            {
                throw new NetmonAPIWrapperException("NmGetAdapter failed", result);
            }
        }

        /// <summary>
        /// Configures that adapter with the given values, which will overwrite all previous values.
        /// </summary>
        /// <param name="callbackFunction">The callback function for capture.</param>
        /// <param name="callerContext">User data that will be passed to the callback function.</param>
        /// <param name="exitMode">How remaining frames should be handled when pause/stop is called.</param>
        public void ConfigAdapter (CaptureCallbackDelegate callbackFunction, IntPtr callerContext, NmCaptureCallbackExitMode exitMode)
        {
            uint result = NetmonAPI.NmConfigAdapter(_captureEngine.hCaptureEngine, _index, callbackFunction, callerContext, exitMode);
            if (result != 0)
            {
                throw new NetmonAPIWrapperException("NmConfigAdapter failed", result);
            }
        }

        /// <summary>
        /// Starts capturing on this adapter.
        /// </summary>
        /// <param name="captureMode">The mode to capture in.</param>
        public void StartCapture (NmCaptureMode captureMode)
        {
            uint result = NetmonAPI.NmStartCapture(_captureEngine.hCaptureEngine, _index, captureMode);
            if (result != 0)
            {
                throw new NetmonAPIWrapperException("NmStartCapture failed", result);
            }
        }

        /// <summary>
        /// Stops capturing on this adapter.
        /// </summary>
        public void StopCapture ()
        {
            uint result = NetmonAPI.NmStopCapture(_captureEngine.hCaptureEngine, _index);
            if (result != 0)
            {
                throw new NetmonAPIWrapperException("NmStopCapture failed", result);
            }
        }

        /// <summary>
        /// Gets the capture statistics for this adapter.
        /// </summary>
        /// <returns>The capture statistics for this adapter.</returns>
        public NmCaptureStatistics GetCaptureStatistics ()
        {
            NmCaptureStatistics ans = new NmCaptureStatistics();
            uint result = NetmonAPI.NmGetLiveCaptureFrameCounts(_captureEngine.hCaptureEngine, _index, ref ans.Value);
            if (result != 0)
            {
                throw new NetmonAPIWrapperException("NmGetLiveCaptureFrameCounts failed", result);
            }
            return ans;
        }

        /// <summary>
        /// Gets the first Ipv4 address for this adapter.
        /// </summary>
        /// <returns>The first Ipv4 address for this adapter.</returns>
        public System.Net.IPAddress GetIpv4Address ()
        {
            NetworkInterface[] interfaces = NetworkInterface.GetAllNetworkInterfaces();

            for (int i = 0; i < interfaces.Length; ++i)
            {
                NetworkInterface ni = interfaces[i];

                byte[] mac = ni.GetPhysicalAddress().GetAddressBytes();
                byte[] ad_mac = _nicAdapterInfo.Value.PermanentAddr;

                if (mac.Length != ad_mac.Length)
                {
                    continue;
                }

                bool cont = false;
                for (int j = 0, k = mac.Length; j < k; ++j)
                {
                    if (mac[j] != ad_mac[j])
                    {
                        cont = true;
                        break;
                    }
                }
                if (cont)
                {
                    continue;
                }

                IPInterfaceProperties ipip = ni.GetIPProperties();
                IPv4InterfaceProperties ipv4ip = ipip.GetIPv4Properties();

                if (ipv4ip != null)
                {
                    foreach (UnicastIPAddressInformation uipai in ipip.UnicastAddresses)
                    {
                        if (uipai.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                        {
                            return uipai.Address;
                        }
                    }
                }
            }

            return System.Net.IPAddress.None;
        }
    }

    /// <summary>
    /// Status codes not included in NmStatusCode, but in the Netmon Help file.
    /// </summary>
    public enum ExtendedNmStatusCode : uint
    {
        /// <summary>Indicates an issue between the Network Monitor API and the ndisnapp object. See Working with Multi-Threaded Code.</summary>
        E_NOINTERFACE = 0x80004002,
        /// <summary>The object that you are trying to create already exists.</summary>
        ERROR_ALREADY_EXIST = 183,
        /// <summary>An invalid handle or pointer was provided.</summary>
        ERROR_BAD_ARGUMENTS = 160,
        /// <summary>The size of the buffer sent to retrieve the adapter information is not large enough.</summary>
        ERROR_BUFFER_OVERFLOW = 111,
        /// <summary>Frame comment information was not found.</summary>
        ERROR_EMPTY = 4306,
        /// <summary>The specified file was not found.</summary>
        ERROR_FILE_NOT_FOUND = 2,
        /// <summary>The size of the buffer sent is not large enough to handle the data to be returned.</summary>
        ERROR_INSUFFICIENT_BUFFER = 122,
        /// <summary> A specified parameter is invalid. For NmLoadNplParser calls, this can also indicate an error with the parser.</summary>
        ERROR_INVALID_PARAMETER = 87,
        /// <summary>The API or driver is in the wrong state for the requested operation.</summary>
        ERROR_INVALID_STATE = 5023,
        /// <summary>Failed to allocate memory for the request.</summary>
        ERROR_NOT_ENOUGH_MEMORY = 8,
        /// <summary>Reference to a file, file path, handle, or data field is incorrect.</summary>
        ERROR_NOT_FOUND = 1168,
        /// <summary>This function is not currently supported.
        ERROR_NOT_SUPPORTED = 50,
        /// <summary>The upper limit of a resource has been reached. This may indicate that a handle limit has been reached. Sometimes this is an indication that handles are being leaked. These resources can be read with the NmGetApiConfiguration function and set with the NmApiInitialize function.</summary>
        ERROR_PARAMETER_QUOTA_EXCEEDED = 1283,
        /// <summary>The field is a container, so the content is not available.</summary>
        ERROR_RESOURCE_NOT_AVAILABLE = 5006,
        /// <summary>Indicates success.</summary>
        ERROR_SUCCESS = 0,
        /// <summary>Indicates an issue between the application and the API. See Working with Multi-Threaded Code.</summary>
        RPC_E_CHANGED_MODE = 0x80010106,
        /// <summary>Not enough space in buffer. Partial string is copied.</summary>
        STRSAFE_E_INSUFFICIENT_BUFFER = 0x8007007A,
    }

    /// <summary>
    /// An exception thrown by the NetmonAPI wrapper classes.
    /// </summary>
    public class NetmonAPIWrapperException : Exception
    {
        public NetmonAPIWrapperException (string message) : base(message) { }

        public NetmonAPIWrapperException (string message, uint netmonStatus) : 
            base(string.Format("{0} : {1} [{2:X8}]", message, GetStatusCodeName(netmonStatus), netmonStatus)) { }

        /// <summary>Holds the conversion table to friendly names.</summary>
        private static Dictionary<uint, string> _statusCodes;

        static NetmonAPIWrapperException ()
        {
            _statusCodes = new Dictionary<uint, string>();
            LoadEnumTypeNames(typeof(NmStatusCode));
            LoadEnumTypeNames(typeof(ExtendedNmStatusCode));
        }

        private static void LoadEnumTypeNames (Type t)
        {
            foreach (System.Reflection.FieldInfo f in t.GetFields(System.Reflection.BindingFlags.Static |
                System.Reflection.BindingFlags.DeclaredOnly | System.Reflection.BindingFlags.Public))
            {
                if (f.IsLiteral)
                {
                    uint hr = Convert.ToUInt32(f.GetValue(null));
                    _statusCodes[hr] = f.Name;
                }
            }
        }

        public static string GetStatusCodeName (uint statusCode)
        {
            return _statusCodes[statusCode];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\NetmonRawSocket.cs ===
﻿using System;
using System.Net;
using System.Net.Sockets;
using System.Runtime.InteropServices;

using ServerTestFramework.LiveService.Auth;

using Microsoft.NetworkMonitor;
using Microsoft.NetworkMonitor.Wrapper;

namespace TestThroughSG
{
    /// <summary>
    /// Contains a raw socket and provides access to receiving and sending with it.
    /// </summary>
    internal class NetmonRawSocket : IRawSocket
    {
        #region Private Fields

        /// <summary>The socket we will use to listen and send on.</summary>
        private Socket _sock = null;

        /// <summary>The Netmon adapter for the target interface.</summary>
        private Adapter _adapter = null;

        /// <summary>Buffer that we use to receive with.</summary>
        private byte[] _buffer = null;

        /// <summary>Used in receive because we must pass one in.</summary>
        private IPEndPoint _any_ep = null;

        /// <summary>The interface that the raw socket will be attached to.</summary>
        private IPAddress _targetInterface = null;

        /// <summary>The IP that we are spoofing (filters the incoming, defines the outgoing).</summary>
        private IPAddress _spoofed = null;
        private int _spoofed_int = 0;

        // This collection of values keeps stats on things that happen to this socket
        private int _dropped_TooSmall = 0;
        private int _dropped_NotOurIP = 0;
        private int _dropped_SizeDoesNotMatchIPHeader = 0;
        private int _dropped_Fragmented = 0;
        private int _dropped_ProtocolNotSupported = 0;
        private int _dropped_TooLarge = 0;
        private int _received = 0;
        private int _dropped_NotSent = 0;
        private int _sent = 0;

        #endregion

        /// <summary>The spoofed IP address as an integer.</summary>
        public int SpoofedAddressInteger
        {
            get
            {
                return _spoofed_int;
            }
        }

        /// <summary>
        /// Creates the raw socket.
        /// </summary>
        /// <param name="targetInterface">The IPAddress of the interface that should be attached to.</param>
        /// <param name="spoofed">The IPAddress that we are spoofing.</param>
        public NetmonRawSocket (IPAddress targetInterface, IPAddress spoofed)
        {
            _targetInterface = targetInterface;
            _spoofed = spoofed;
            _spoofed_int = BitConverter.ToInt32(_spoofed.GetAddressBytes(), 0);

            _buffer = new byte[1500];
            _any_ep = new IPEndPoint(IPAddress.Any, 0);

            // create the magic socket
            _sock = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.IP);
            _sock.Bind((EndPoint)(new IPEndPoint(_targetInterface, 0)));
            _sock.IOControl(IOControlCode.ReceiveAll, new byte[] { 1, 0, 0, 0 }, _buffer);
            _sock.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.HeaderIncluded, true);

            // set up Netmon
            CaptureEngine ce = new CaptureEngine();
            _adapter = null;

            for (uint i = 0, j = ce.AdapterCount; i < j; ++i)
            {
                Adapter current = ce.GetAdapter(i);

                if (current.GetIpv4Address().Equals(targetInterface))
                {
                    _adapter = current;
                    break;
                }
            }

            if (_adapter == null)
            {
                throw new NetmonRawSocketException("Could not find Netmon adapter for the target interface: " + targetInterface.ToString());
            }

            _adapter.ConfigAdapter(CaptureCallbackDelegate, IntPtr.Zero, NmCaptureCallbackExitMode.DiscardRemainFrames);
            _adapter.StartCapture(NmCaptureMode.LocalOnly);
        }

        /// <summary>
        /// NetmonAPI capture callback.
        /// </summary>
        private unsafe void CaptureCallbackDelegate (IntPtr hCaptureEngine, uint ulAdapterIndex, IntPtr pCallerContext, IntPtr hFrame)
        {
            XspBuffer xspbuff = XspBufferManager.Allocate();
            byte[] xspbytes = xspbuff.RawBuffer;

            uint frameLength = 0;
            uint result = 0;

            try
            {
                result = NetmonAPI.NmGetRawFrameLength(hFrame, out frameLength);
                /*
                if (result == 0 && frameLength > (uint)xspbytes.Length)
                {
                    // too big for us
                    return;
                }

                fixed (byte* framePtr = xspbytes)
                {
                    result = NetmonAPI.NmGetRawFrame(hFrame, (uint)xspbytes.Length, framePtr, out frameLength);
                }

                if (result != 0)
                {
                    // failure
                    return;
                }

                // check size, if less than Ethernet header plus IP header plus UDP header, toss
                if (frameLength < 42)
                {
                    ++_dropped_TooSmall;
                    return;
                }

                // pull destination address from IP header
                int dest_addr = BitConverter.ToInt32(_buffer, 16);

                // not meant for us, carry on
                if (dest_addr != _spoofed_int)
                {
                    ++_dropped_NotOurIP;
                    continue;
                }

                // this shouldn't happen unless something bad happens to the packet
                int ip_ttl_len = (int)((ushort)IPAddress.NetworkToHostOrder(BitConverter.ToInt16(_buffer, 2)));

                if (ip_ttl_len != size)
                {
                    ++_dropped_SizeDoesNotMatchIPHeader;
                    continue;
                }

                // we don't handle fragmented packets
                byte flags = _buffer[6];

                if ((flags & RawSocket.IPHeaderMoreFragments) == RawSocket.IPHeaderMoreFragments)
                {
                    ++_dropped_Fragmented;
                    continue;
                }

                // pull out other fun stuffs
                int ip_hdr_len = (_buffer[0] & 0xF) * 4;
                byte protocol = _buffer[9];

                // only TCP and UDP
                if (protocol != RawSocket.ProtocolTCP && protocol != RawSocket.ProtocolUDP)
                {
                    ++_dropped_ProtocolNotSupported;
                    continue;
                }

                // check for a packet that is too big to fit into XSP
                if (size - ip_hdr_len > 1460)
                {
                    // could theoretically send an ICMP Fragmentation Needed packet
                    ++_dropped_TooLarge;
                    continue;
                }

                // now we are ready to copy the buffer out
                int data_offset = ip_hdr_len + (protocol == RawSocket.ProtocolTCP ? 20 : 8);
                int data_size = size - data_offset;

                XspBuffer xspbuff = XspBufferManager.Allocate();
                byte[] xspbytes = xspbuff.RawBuffer;

                // source IP into first 4 bytes (eventual location for XSP header)
                Buffer.BlockCopy(_buffer, 12, xspbytes, 0, 4);
                // body into the place that it will be in the XSP packet
                Buffer.BlockCopy(_buffer, data_offset, xspbytes, 4, data_size);
                // ports
                Buffer.BlockCopy(_buffer, ip_hdr_len, xspbytes, 4 + data_size, 4);
                // protocol
                xspbytes[4 + data_size + 4] = protocol;
                // if TCP, 12 byte proto-header
                if (protocol == RawSocket.ProtocolTCP)
                {
                    Buffer.BlockCopy(_buffer, ip_hdr_len + 4, xspbytes, 4 + data_size + 4 + 1, 12);
                }

                xspbuff.RawBufferLength = (uint)data_size;
                
                ++_received;
                return xspbuff;*/
            }
            catch
            {
                // this will be called on a thread that we don't control, no exceptions can escape
            }
            finally
            {
                if (xspbuff != null)
                {
                    // return the buffer to the pool
                    XspBufferManager.Free(xspbuff);
                }
            }
        }

        /// <summary>
        /// Attempts to receive a packet from the socket, filtering down to the specified IP.
        /// Not thread safe, as a single buffer is used for receiving.
        /// </summary>
        /// <returns>An XspBuffer, with specific data encoded into it.</returns>
        /// <remarks>
        /// The XspBuffer returned will have the important data from the packet copied into it in this format:
        /// Length|| 4              | RawBufferLength | 4     | 1        | 12 if Protocol is TCP, 0 if UDP
        /// Data  || Source Address | Packet Data     | Ports | Protocol | TCP Info (12 bytes of TCP header after ports)
        /// </remarks>
        public XspBuffer Receive ()
        {
            if (_sock == null)
            {
                throw new NetmonRawSocketException("The socket is closed.");
            }

            while (true)
            {
                // reset _any_ep
                _any_ep.Address = IPAddress.Any;
                _any_ep.Port = 0;
                EndPoint any_ep = (EndPoint)_any_ep;

                int size = _sock.ReceiveFrom(_buffer, ref any_ep);

                // check size, if less than IP header plus UDP header, toss
                if (size < 28)
                {
                    ++_dropped_TooSmall;
                    continue;
                }

                // pull destination address from IP header
                int dest_addr = BitConverter.ToInt32(_buffer, 16);

                // not meant for us, carry on
                if (dest_addr != _spoofed_int)
                {
                    ++_dropped_NotOurIP;
                    continue;
                }

                // this shouldn't happen unless something bad happens to the packet
                int ip_ttl_len = (int)((ushort)IPAddress.NetworkToHostOrder(BitConverter.ToInt16(_buffer, 2)));

                if (ip_ttl_len != size)
                {
                    ++_dropped_SizeDoesNotMatchIPHeader;
                    continue;
                }

                // we don't handle fragmented packets
                byte flags = _buffer[6];

                if ((flags & RawSocket.IPHeaderMoreFragments) == RawSocket.IPHeaderMoreFragments)
                {
                    ++_dropped_Fragmented;
                    continue;
                }

                // pull out other fun stuffs
                int ip_hdr_len = (_buffer[0] & 0xF) * 4;
                byte protocol = _buffer[9];
                
                // only TCP and UDP
                if (protocol != RawSocket.ProtocolTCP && protocol != RawSocket.ProtocolUDP)
                {
                    ++_dropped_ProtocolNotSupported;
                    continue;
                }

                // check for a packet that is too big to fit into XSP
                if (size - ip_hdr_len > 1460)
                {
                    // could theoretically send an ICMP Fragmentation Needed packet
                    ++_dropped_TooLarge;
                    continue;
                }

                // now we are ready to copy the buffer out
                int data_offset = ip_hdr_len + (protocol == RawSocket.ProtocolTCP ? 20 : 8);
                int data_size = size - data_offset;

                XspBuffer xspbuff = XspBufferManager.Allocate();
                byte[] xspbytes = xspbuff.RawBuffer;

                // source IP into first 4 bytes (eventual location for XSP header)
                Buffer.BlockCopy(_buffer, 12, xspbytes, 0, 4);
                // body into the place that it will be in the XSP packet
                Buffer.BlockCopy(_buffer, data_offset, xspbytes, 4, data_size);
                // ports
                Buffer.BlockCopy(_buffer, ip_hdr_len, xspbytes, 4 + data_size, 4);
                // protocol
                xspbytes[4 + data_size + 4] = protocol;
                // if TCP, 12 byte proto-header
                if (protocol == RawSocket.ProtocolTCP)
                {
                    Buffer.BlockCopy(_buffer, ip_hdr_len + 4, xspbytes, 4 + data_size + 4 + 1, 12);
                }

                xspbuff.RawBufferLength = (uint)data_size;

                ++_received;
                return xspbuff;
            }
        }

        /// <summary>
        /// Sends a packet to the specified location.
        /// </summary>
        /// <param name="buffer">The packet data to send.</param>
        /// <param name="size">The length, in bytes, of the data to send.</param>
        /// <param name="endPoint">The location to send to.</param>
        public void SendTo (byte[] buffer, uint size, IPEndPoint endPoint)
        {
            if (_sock == null)
            {
                throw new NetmonRawSocketException("The socket is closed.");
            }

            int sent = _sock.SendTo(buffer, (int)size, SocketFlags.None, (EndPoint)endPoint);

            if ((uint)(sent) != size)
            {
                ++_dropped_NotSent;
            }
            else
            {
                ++_sent;
            }
        }

        /// <summary>
        /// Closes the socket.
        /// </summary>
        public void Close ()
        {
            if (_sock != null)
            {
                _sock.Close();
                _sock = null;
            }
        }

        #region Debug Information

        /// <summary>
        /// Gets a collection of stats from the raw socket.
        /// </summary>
        public void FillStatsCollection (ref TestThroughSG.StatsCollection stats)
        {
            stats.RawSocketDroppedTooSmall = _dropped_TooSmall;
            stats.RawSocketDroppedNotOurIP = _dropped_NotOurIP;
            stats.RawSocketDroppedSizeMismatch = _dropped_SizeDoesNotMatchIPHeader;
            stats.RawSocketDroppedFragmented = _dropped_Fragmented;
            stats.RawSocketDroppedProtocolNotSupported = _dropped_ProtocolNotSupported;
            stats.RawSocketDroppedTooLarge = _dropped_TooLarge;
            stats.RawSocketReceived = _received;
            stats.RawSocketDroppedNotSent = _dropped_NotSent;
            stats.RawSocketSent = _sent;
        }

        #endregion
    }

    /// <summary>
    /// An exception thrown by NetmonRawSocket.
    /// </summary>
    public class NetmonRawSocketException : RawSocketException
    {
        public NetmonRawSocketException (string message) : base(message) { }

        public NetmonRawSocketException (string message, uint netmonStatus) : 
            base(string.Format("{0} : {1} [{2:X8}]", message, NetmonAPIWrapperException.GetStatusCodeName(netmonStatus), netmonStatus)) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\OptionsForm.Designer.cs ===
﻿namespace TestThroughSG
{
    partial class OptionsForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose (bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            this.lblTargetInterface = new System.Windows.Forms.Label();
            this.cmbTargetInterface = new System.Windows.Forms.ComboBox();
            this.lblSpoofedAddress = new System.Windows.Forms.Label();
            this.txtSpoofedAddress = new System.Windows.Forms.TextBox();
            this.btnCancel = new System.Windows.Forms.Button();
            this.btnOK = new System.Windows.Forms.Button();
            this.cmbMethod = new System.Windows.Forms.ComboBox();
            this.lblMethod = new System.Windows.Forms.Label();
            this.chkAutoRedirect = new System.Windows.Forms.CheckBox();
            this.SuspendLayout();
            // 
            // lblTargetInterface
            // 
            this.lblTargetInterface.AutoSize = true;
            this.lblTargetInterface.Location = new System.Drawing.Point(12, 52);
            this.lblTargetInterface.Name = "lblTargetInterface";
            this.lblTargetInterface.Size = new System.Drawing.Size(49, 13);
            this.lblTargetInterface.TabIndex = 0;
            this.lblTargetInterface.Text = "Interface";
            // 
            // cmbTargetInterface
            // 
            this.cmbTargetInterface.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.cmbTargetInterface.FormattingEnabled = true;
            this.cmbTargetInterface.Location = new System.Drawing.Point(67, 49);
            this.cmbTargetInterface.Name = "cmbTargetInterface";
            this.cmbTargetInterface.Size = new System.Drawing.Size(121, 22);
            this.cmbTargetInterface.TabIndex = 1;
            // 
            // lblSpoofedAddress
            // 
            this.lblSpoofedAddress.AutoSize = true;
            this.lblSpoofedAddress.Location = new System.Drawing.Point(17, 88);
            this.lblSpoofedAddress.Name = "lblSpoofedAddress";
            this.lblSpoofedAddress.Size = new System.Drawing.Size(44, 13);
            this.lblSpoofedAddress.TabIndex = 2;
            this.lblSpoofedAddress.Text = "Fake IP";
            // 
            // txtSpoofedAddress
            // 
            this.txtSpoofedAddress.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.txtSpoofedAddress.Location = new System.Drawing.Point(67, 85);
            this.txtSpoofedAddress.Name = "txtSpoofedAddress";
            this.txtSpoofedAddress.Size = new System.Drawing.Size(121, 20);
            this.txtSpoofedAddress.TabIndex = 3;
            this.txtSpoofedAddress.Text = "172.16.0.1";
            // 
            // btnCancel
            // 
            this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.btnCancel.Location = new System.Drawing.Point(197, 229);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(75, 23);
            this.btnCancel.TabIndex = 4;
            this.btnCancel.Text = "Cancel";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // btnOK
            // 
            this.btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.btnOK.Location = new System.Drawing.Point(116, 229);
            this.btnOK.Name = "btnOK";
            this.btnOK.Size = new System.Drawing.Size(75, 23);
            this.btnOK.TabIndex = 5;
            this.btnOK.Text = "OK";
            this.btnOK.UseVisualStyleBackColor = true;
            this.btnOK.Click += new System.EventHandler(this.btnOK_Click);
            // 
            // cmbMethod
            // 
            this.cmbMethod.Font = new System.Drawing.Font("Courier New", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.cmbMethod.FormattingEnabled = true;
            this.cmbMethod.Location = new System.Drawing.Point(67, 13);
            this.cmbMethod.Name = "cmbMethod";
            this.cmbMethod.Size = new System.Drawing.Size(121, 22);
            this.cmbMethod.TabIndex = 7;
            this.cmbMethod.SelectedIndexChanged += new System.EventHandler(this.cmbMethod_SelectedIndexChanged);
            // 
            // lblMethod
            // 
            this.lblMethod.AutoSize = true;
            this.lblMethod.Location = new System.Drawing.Point(18, 16);
            this.lblMethod.Name = "lblMethod";
            this.lblMethod.Size = new System.Drawing.Size(43, 13);
            this.lblMethod.TabIndex = 6;
            this.lblMethod.Text = "Method";
            // 
            // chkAutoRedirect
            // 
            this.chkAutoRedirect.AutoSize = true;
            this.chkAutoRedirect.Location = new System.Drawing.Point(20, 124);
            this.chkAutoRedirect.Name = "chkAutoRedirect";
            this.chkAutoRedirect.Size = new System.Drawing.Size(118, 17);
            this.chkAutoRedirect.TabIndex = 8;
            this.chkAutoRedirect.Text = "Redirect on Startup";
            this.chkAutoRedirect.UseVisualStyleBackColor = true;
            // 
            // OptionsForm
            // 
            this.AcceptButton = this.btnOK;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.btnCancel;
            this.ClientSize = new System.Drawing.Size(284, 264);
            this.Controls.Add(this.chkAutoRedirect);
            this.Controls.Add(this.cmbMethod);
            this.Controls.Add(this.lblMethod);
            this.Controls.Add(this.btnOK);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.txtSpoofedAddress);
            this.Controls.Add(this.lblSpoofedAddress);
            this.Controls.Add(this.cmbTargetInterface);
            this.Controls.Add(this.lblTargetInterface);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "OptionsForm";
            this.Text = "Test Through SG Options";
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lblTargetInterface;
        private System.Windows.Forms.ComboBox cmbTargetInterface;
        private System.Windows.Forms.Label lblSpoofedAddress;
        private System.Windows.Forms.TextBox txtSpoofedAddress;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.Button btnOK;
        private System.Windows.Forms.ComboBox cmbMethod;
        private System.Windows.Forms.Label lblMethod;
        private System.Windows.Forms.CheckBox chkAutoRedirect;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\OptionsForm.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Net;
using System.Text;
using System.Windows.Forms;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace TestThroughSG
{
    public partial class OptionsForm : Form
    {
        public OptionsForm ()
        {
            InitializeComponent();
            LoadPacketSources();
            LoadLocalInterfaces();
        }

        /// <summary>
        /// Loads the packet sources from the TestThroughSG.PacketSource enumeration.
        /// </summary>
        public void LoadPacketSources ()
        {
            cmbMethod.Items.Clear();

            foreach (string source in Enum.GetNames(typeof(TestThroughSG.PacketSource)))
            {
                if (source == "Default")
                {
                    continue;
                }

                cmbMethod.Items.Add(Enum.Parse(typeof(TestThroughSG.PacketSource), source));
            }

            cmbMethod.SelectedItem = TestThroughSG.PacketSource.Default;
            cmbMethod_SelectedIndexChanged(null, null);
        }

        /// <summary>
        /// Creates a list of local ips for the raw socket to be bound to.
        /// </summary>
        public void LoadLocalInterfaces ()
        {
            // clear old values
            cmbTargetInterface.Items.Clear();

            // get local interface ips
            IPAddress[] ips = Dns.GetHostAddresses("");

            foreach (IPAddress ip in ips)
            {
                // toss ipv6 addresses
                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6)
                {
                    continue;
                }

                // add to combobox
                cmbTargetInterface.Items.Add(ip);
            }

            try
            {
                // pick the default
                string first_server = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.xmgmtsrv)[0];
                IPAddress ipa = Global.XEnv.GetInterface(xonline.common.config.Interface.xmgmtsrv, first_server).Address;
                IPAddress default_interface = IpHelper.GetBestInterface(ipa);

                // attempt to set the default into the list
                cmbTargetInterface.SelectedItem = default_interface;
            }
            catch
            {
                // a failure here is likely due to a bad environment
                // if we don't pick the optimal interface it isn't the end of the world
            }
        }

        /// <summary>
        /// Access to the state of the RedirectOnStartup checkbox.
        /// </summary>
        public bool RedirectOnStartup
        {
            get { return chkAutoRedirect.Checked; }
            set { chkAutoRedirect.Checked = value; }
        }

        /// <summary>
        /// This method is used to update the form values after we load them from the settings XML.
        /// Because of this, we are only syncing values that are actually read in.
        /// </summary>
        /// <returns>True if the sync succeeded; false otherwise.</returns>
        internal bool SyncFromTestThroughSG ()
        {
            // packet source
            TestThroughSG.PacketSource source = TestThroughSG.Source;
            cmbMethod.SelectedItem = source;

            return true;
        }

        /// <summary>
        /// Syncs the options into the TestThroughSG class.
        /// </summary>
        /// <returns>True if the sync succeeded; false otherwise.</returns>
        public bool SyncToTestThroughSG ()
        {
            return SyncToTestThroughSG(false);
        }

        /// <summary>
        /// Syncs the options into the TestThroughSG class.
        /// </summary>
        /// <param name="throughUI">The sync is occuring because of UI interaction.</param>
        /// <returns>True if the sync succeeded; false otherwise.</returns>
        public bool SyncToTestThroughSG (bool throughUI)
        {
            // packet source
            TestThroughSG.PacketSource source = (TestThroughSG.PacketSource)cmbMethod.SelectedItem;
            TestThroughSG.Source = source;

            if (TestThroughSG.RequiresTargetInterface(source))
            {
                // target interface
                IPAddress target_interface = (IPAddress)cmbTargetInterface.SelectedItem;
                TestThroughSG.TargetInterface = target_interface;
            }
                
            if (TestThroughSG.RequiresSpoofedAddress(source))
            {
                // spoofed address
                IPAddress spoofed_address;
                if (IPAddress.TryParse(txtSpoofedAddress.Text, out spoofed_address))
                {
                    TestThroughSG.SpoofedAddress = spoofed_address;
                }
            }

            return true;
        }

        private void btnOK_Click (object sender, EventArgs e)
        {
            SyncToTestThroughSG(true);
            DialogResult = DialogResult.OK;
        }

        private void btnCancel_Click (object sender, EventArgs e)
        {
            DialogResult = DialogResult.Cancel;
        }

        private void cmbMethod_SelectedIndexChanged (object sender, EventArgs e)
        {
            TestThroughSG.PacketSource source = (TestThroughSG.PacketSource)cmbMethod.SelectedItem;
            cmbTargetInterface.Enabled = TestThroughSG.RequiresTargetInterface(source);
            txtSpoofedAddress.Enabled = TestThroughSG.RequiresSpoofedAddress(source);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\Plugin.cs ===
﻿using System;
using System.Threading;
using System.Windows.Forms;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Utilities;

namespace TestThroughSG
{
    /// <summary>
    /// This is a lightweight class that gives UI access from STFGui.
    /// </summary>
    public class Plugin : IPluginSetup, STFGui.Plugins.IPluginGui
    {
        /// <summary>The options form.</summary>
        private OptionsForm _optionsForm = null;

        /// <summary>A link to the currently active debug form.</summary>
        private DebugForm _debugForm = null;

        /// <summary>The traffic redirect menu item.</summary>
        private MenuItem _redirectTraffic = null;

        public Plugin ()
        {
            // create form and use it to set defaults
            _optionsForm = new OptionsForm();
            _optionsForm.SyncToTestThroughSG();
        }

        public System.Windows.Forms.MenuItem GetNewMenu ()
        {
            MenuItem menu = new MenuItem("Test Through SG");
            MenuItem next = null;

            _redirectTraffic = new MenuItem("Redirect Traffic");
            _redirectTraffic.Click += new EventHandler(redirect_Click);
            _redirectTraffic.Checked = TestThroughSG.IsRedirecting;
            menu.MenuItems.Add(_redirectTraffic);

            next = new MenuItem("Options...");
            next.Click += new EventHandler(options_Click);
            menu.MenuItems.Add(next);

            next = new MenuItem("Debug...");
            next.Click += new EventHandler(debug_Click);
            menu.MenuItems.Add(next);

            return menu;
        }

        private void redirect_Click (object sender, EventArgs e)
        {
            _redirectTraffic.Enabled = false;
            Thread t = null;

            if (TestThroughSG.IsRedirecting)
            {
                t = new Thread(EndRedir);
            }
            else
            {
                t = new Thread(BeginRedir);
            }

            t.IsBackground = true;
            t.Start();
        }

        private void BeginRedir ()
        {
            try
            {
                TestThroughSG.BeginRedirecting();
                _redirectTraffic.Checked = true;
            }
            catch (Exception e)
            {
                Global.RO.Debug("Got Exception in BeginRedir:\n" + e.ToString());
            }
            finally
            {
                _redirectTraffic.Enabled = true;
            }
        }

        private void EndRedir ()
        {
            try
            {
                TestThroughSG.EndRedirecting();
                _redirectTraffic.Checked = false;
            }
            catch (Exception e)
            {
                Global.RO.Debug("Got Exception in EndRedir:\n" + e.ToString());
            }
            finally
            {
                _redirectTraffic.Enabled = true;
            }
        }

        private void options_Click (object sender, EventArgs e)
        {
            _optionsForm.ShowDialog();
        }

        private void debug_Click (object sender, EventArgs e)
        {
            // needs an additional check to ensure that the form is actually good
            if (_debugForm != null)
            {
                //_debugForm.BringToFront();
                _debugForm.Activate();
                return;
            }

            _debugForm = new DebugForm();
            _debugForm.PluginRef = this;
            _debugForm.Show();
        }

        internal void RemoveDebugForm (DebugForm form)
        {
            if (form == _debugForm)
            {
                _debugForm = null;
            }
        }

        #region IPluginSetup Members

        protected const string XmlSettings_InitialRedirectionState = "InitialRedirectionState";
        protected const string XmlSettings_RedirectionMethod = "RedirectionMethod";

        public void Initialize (System.Xml.XmlNode pluginSettings, string[] commandlineParameters)
        {
            try
            {
                if (pluginSettings != null)
                {
                    string method = XmlUtil.GetChildNodeValue(pluginSettings, XmlSettings_RedirectionMethod, 
                        TestThroughSG.PacketSource.Default.ToString());
                    TestThroughSG.Source = (TestThroughSG.PacketSource)Enum.Parse(typeof(TestThroughSG.PacketSource), method, true);

                    // update the options form with values that we read in
                    _optionsForm.SyncFromTestThroughSG();
                    // now sync back as the values we sync in can change the values we sync back
                    _optionsForm.SyncToTestThroughSG();

                    _optionsForm.RedirectOnStartup = XmlUtil.GetChildNodeValue(pluginSettings, XmlSettings_InitialRedirectionState, false);
                    if (_optionsForm.RedirectOnStartup)
                    {
                        TestThroughSG.BeginRedirecting();
                    }
                }
            }
            catch (Exception e)
            {
                Global.RO.Debug("Got Exception in Initialize:\n" + e.ToString());
            }
        }

        public void Shutdown (System.Xml.XmlNode pluginSettings)
        {
            try
            {
                if (_debugForm != null)
                {
                    _debugForm.Close();
                }

                // save preserved settings
                XmlUtil.SetChildNodeValue(pluginSettings, XmlSettings_InitialRedirectionState, _optionsForm.RedirectOnStartup);
                XmlUtil.SetChildNodeValue(pluginSettings, XmlSettings_RedirectionMethod, TestThroughSG.Source.ToString());
            }
            catch (Exception e)
            {
                ServerTestFramework.Global.RO.Debug("Got an exception in Shutdown:\n" + e.ToString());
            }
        }

        #endregion

        #region IPluginGui Members

        public STFGui.Plugins.MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public System.Windows.Forms.TabPage GetNewTabPage ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\Proxy.cs ===
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;

using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Auth;

namespace TestThroughSG
{
    /// <summary>
    /// This class can be used to forward traffic from any source through to the SG.
    /// </summary>
    internal class Proxy
    {
        /// <summary>The connection bridge that we are associated with.</summary>
        protected ConnectionBridge _bridge;

        /// <summary>Our listen sockets for receiving TCP data.</summary>
        protected Dictionary<TcpListener, int> _listeners;

        /// <summary>When true, the proxy should continue running. When false, it should not.</summary>
        protected bool _running;

        /// <summary>A connection from an external source.</summary>
        protected class ConnectionInfo
        {
            public Socket Socket;
            public int Port;
            public BridgeTcpClient Client;
            public byte[] Buffer = new byte[1264];

            public ITcpClient ITcpClient { get { return (ITcpClient)Client; } }
            public ISocket ISocket { get { return (ISocket)Client; } }
            public Stream Stream { get { return ITcpClient.GetStream(); } }
        }

        /// <summary>The current connections.</summary>
        protected LinkedList<ConnectionInfo> _connections;

        /// <summary>Thread that accepts incoming connection requests.</summary>
        protected Thread _acceptConnectionsThread;

        /// <summary>Thread that processes stream data.</summary>
        protected Thread _processStreamsThread;

        /// <summary>
        /// Creates an instance of the proxy.
        /// </summary>
        public Proxy (ConnectionBridge bridge)
        {
            _bridge = bridge;
            _connections = new LinkedList<ConnectionInfo>();
        }

        /// <summary>
        /// Starts listening for traffic to forward on the given virtual interfaces.
        /// </summary>
        /// <param name="virtualInterfaces">The virtual interfaces to proxy.</param>
        /// <returns>A list of virtual interfaces and the endpoint that is proxying them.</returns>
        public Dictionary<string, IPEndPoint> Start (IEnumerable<string> virtualInterfaces)
        {
            if (TestThroughSG.TargetInterface == null)
            {
                throw new ProxyException("A value must be set for TargetInterface to begin proxying.");
            }

            _listeners = new Dictionary<TcpListener,int>();
            Dictionary<string, IPEndPoint> ans = new Dictionary<string, IPEndPoint>();

            foreach (string vi in virtualInterfaces)
            {
                IVirtualInterfaceInfo ivii = Config.GetVirtualInterface(vi);

                TcpListener listener = null;

                try
                {
                    listener = new TcpListener(new IPEndPoint(TestThroughSG.TargetInterface, ivii.Port));
                    listener.Start();
                }
                catch (SocketException se)
                {
                    // we expect AddressAlreadyInUse in some cases, don't report about them
                    if (se.SocketErrorCode != SocketError.AddressAlreadyInUse)
                    {
                        Global.RO.Error("Error creating TcpListener for " + vi + ":\n" + se.ToString());
                    }
                    listener = null;
                }

                // assume the port was already taken
                if (listener == null)
                {
                    try
                    {
                        // try again but let whatever port through
                        listener = new TcpListener(new IPEndPoint(TestThroughSG.TargetInterface, 0));
                        listener.Start();
                    }
                    catch (SocketException se)
                    {
                        Global.RO.Error("Error creating second chance TcpListener for " + vi + ":\n" + se.ToString());
                        listener = null;
                    }
                }

                if (listener != null)
                {
                    _listeners.Add(listener, ivii.Port);
                    ans.Add(vi, (IPEndPoint)listener.LocalEndpoint);
                }
            }

            // mark us as running
            _running = true;

            // start thread to accept connections
            _acceptConnectionsThread = new Thread(AcceptConnectionsThreadStart);
            _acceptConnectionsThread.IsBackground = true;
            _acceptConnectionsThread.Name = "TestThroughSG.Proxy AcceptConnections";
            _acceptConnectionsThread.Start();

            // start thread to process streams
            _processStreamsThread = new Thread(ProcessStreamsThreadStart);
            _processStreamsThread.IsBackground = true;
            _processStreamsThread.Name = "TestThroughSG.Proxy ProcessStreams";
            _processStreamsThread.Start();

            return ans;
        }

        /// <summary>
        /// Stops proxying.
        /// </summary>
        public void Stop ()
        {
            _running = false;

            if (_acceptConnectionsThread != null)
            {
                _acceptConnectionsThread.Join(10000);
                _acceptConnectionsThread = null;
            }

            if (_processStreamsThread != null)
            {
                _processStreamsThread.Join(10000);
                _processStreamsThread = null;
            }

            foreach (ConnectionInfo ci in _connections)
            {
                ci.Client.Close();
                ci.Socket.Close();
            }

            _connections.Clear();

            foreach (TcpListener listener in _listeners.Keys)
            {
                listener.Stop();
            }
        }

        protected void AcceptConnectionsThreadStart ()
        {
            while (_running)
            {
                try
                {
                    IEnumerable<TcpListener> listeners = _listeners.Keys;
                    bool gotOne = false;

                    foreach (TcpListener listener in listeners)
                    {
                        try
                        {
                            while (listener.Pending())
                            {
                                gotOne = true;

                                Socket socket = listener.AcceptSocket();
                                ConnectionInfo ci = new ConnectionInfo() { Socket = socket, Port = _listeners[listener] };

                                lock (_connections)
                                {
                                    _connections.AddLast(ci);
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            Global.RO.Error("Exception from TcpListener:\n" + e.ToString());
                        }
                    }

                    // sleep for a bit if we didn't receive and new connections
                    if (!gotOne && _running)
                    {
                        Thread.Sleep(20);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Unhandled exception in AcceptConnectionsThreadStart:\n" + e.ToString());
                }
            }
        }

        protected void ProcessStreamsThreadStart ()
        {
            while (_running)
            {
                try
                {
                    bool didWork = false;
                    ConnectionInfo current = null;

                    lock (_connections)
                    {
                        LinkedListNode<ConnectionInfo> first = _connections.First;
                        if (first != null)
                        {
                            current = first.Value;
                            _connections.RemoveFirst();
                            _connections.AddLast(first);
                        }
                    }

                    if (current != null)
                    {
                        bool killConn = false;

                        try
                        {
                            // do we need to get a tcp client?
                            if (current.Client == null)
                            {
                                current.Client = new BridgeTcpClient(_bridge);
                                current.ITcpClient.Connect(new IPEndPoint(IPAddress.Any, current.Port));
                            }

                            // make sure data keeps flowing
                            current.Client.PumpStreams();

                            // if we cannot read from the SG stream, no point in going on
                            if (!current.Stream.CanRead)
                            {
                                killConn = true;
                            }
                            else
                            {
                                // check for incoming data on the socket
                                while (current.Socket.Available != 0)
                                {
                                    // if we cannot write to the SG stream, no point in going on
                                    if (!current.Stream.CanWrite)
                                    {
                                        killConn = true;
                                        break;
                                    }

                                    int recv = current.Socket.Receive(current.Buffer);

                                    if (recv != 0)
                                    {
                                        didWork = true;
                                        current.Stream.Write(current.Buffer, 0, recv);
                                    }
                                }

                                // and now the other direction
                                while (current.Client.DataAvailable)
                                {
                                    int recv = current.ISocket.Receive(current.Buffer);

                                    if (recv != 0)
                                    {
                                        didWork = true;
                                        int offset = 0;
                                        while (offset < recv)
                                        {
                                            offset += current.Socket.Send(current.Buffer, offset, recv - offset, SocketFlags.None);
                                        }
                                    }
                                }
                            }
                        }
                        catch (Exception e)
                        {
                            Global.RO.Error("Exception encountered, killing connections:\n" + e.ToString());
                            killConn = true;
                        }

                        if (killConn)
                        {
                            // kill the tcp client
                            if (current.Client != null)
                            {
                                current.Client.Close();
                            }

                            // kill the remote socket
                            if (current.Socket != null)
                            {
                                current.Socket.Close();
                            }

                            // remove the socket from the connection pool
                            lock (_connections)
                            {
                                _connections.Remove(current);
                            }
                        }
                    }

                    if (!didWork)
                    {
                        Thread.Sleep(1);
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Error("Unhandled exception in ProcessStreamsThreadStart:\n" + e.ToString());
                }
            }
        }
    }

    public class ProxyException : Exception
    {
        public ProxyException (string message) : base(message) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\TestThroughSG.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Threading;

using xonline.common.config;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;

namespace TestThroughSG
{
    /// <summary>
    /// The main interface for access to the TestThroughSG functionality.
    /// </summary>
    public static class TestThroughSG
    {
        #region Public Types

        /// <summary>
        /// The source of packets being sent to the SG.
        /// </summary>
        public enum PacketSource
        {
            Direct,
            RawSocket,
            Netmon,
            Proxy,
            Default = Direct
        }

        /// <summary>
        /// Determines if a PacketSource requires a target interface.
        /// </summary>
        /// <param name="source">The PacketSource to check.</param>
        /// <returns>True if the PacketSource requires a target interface; false otherwise.</returns>
        public static bool RequiresTargetInterface (PacketSource source)
        {
            return (RequiresSpoofedAddress(source) || source == PacketSource.Proxy);
        }

        /// <summary>
        /// Determines if a PacketSource requires a spoofed address.
        /// </summary>
        /// <param name="source">The PacketSource to check.</param>
        /// <returns>True if the PacketSource requires a spoofed address; false otherwise.</returns>
        public static bool RequiresSpoofedAddress (PacketSource source)
        {
            return (source == PacketSource.RawSocket || source == PacketSource.Netmon);
        }

        #endregion

        #region Private Consts

        /// <summary>Amount of time before a connection times when there is no activity.</summary>
        private static readonly TimeSpan UserActivityTimeout = new TimeSpan(0, 1, 0);

        /// <summary>Amount of time a connection stays open when it is half closed.</summary>
        private static readonly TimeSpan TcpHalfClosedTimeout = new TimeSpan(0, 0, 10);

        /// <summary>Amount of time a connection stays open when it is half closed.</summary>
        private static readonly TimeSpan TcpClosedTimeout = new TimeSpan(0, 0, 2);

        /// <summary>The TCP time-wait delay setting for the target servers.</summary>
        private const uint TcpTimeWaitDelay = 0x90;

        /// <summary>A constant amount of time to wait on top of the time wait slice.</summary>
        private const double TcpTimeWaitConstantOffset = 1.0;

        #endregion

        #region Private Fields

        /// <summary>Backing for Source.</summary>
        private static PacketSource _packetSource = PacketSource.Default;

        /// <summary>The source of packets being sent to the SG.</summary>
        public static PacketSource Source
        {
            get { return _packetSource; }
            set { _packetSource = value; }
        }

        /// <summary>Backing for TargetInterface.</summary>
        private static IPAddress _targetInterface = null;

        /// <summary>The IP of the interface that will be listened on via raw sockets.</summary>
        public static IPAddress TargetInterface
        {
            get { return _targetInterface; }
            set { _targetInterface = value; }
        }

        /// <summary>Backing for SpoofedAddress.</summary>
        private static IPAddress _spoofedAddress = null;

        /// <summary>The fake IP address that will be used for raw socket communication.</summary>
        public static IPAddress SpoofedAddress
        {
            get { return _spoofedAddress; }
            set { _spoofedAddress = value; }
        }

        /// <summary>The TCP MSS value to enforce.</summary>
        private static ushort _tcpMss = 1264;

        /// <summary>The raw socket that will be used for redirection.</summary>
        private static IRawSocket _rawSocket = null;

        /// <summary>The proxy that will be used for redirection.</summary>
        private static Proxy _proxy = null;

        /// <summary>The bridge between connections.</summary>
        private static ConnectionBridge _bridge = null;

        /// <summary>The worker thread that will receive from the raw socket.</summary>
        private static Thread _rawReceiveThread = null;

        /// <summary>The worker thread that will create connections and reform packets for XSP.</summary>
        private static Thread _outboundThread = null;

        /// <summary>The worker thread that will keep connections alive and send raw packets back to the clients.</summary>
        private static Thread _inboundThread = null;

        /// <summary>When true, the worker threads will continue to process packets; when false they will stop.</summary>
        private static bool _threadShouldRun = false;

        /// <summary>Storage for the IFakeSGClient previously in use.</summary>
        private static ServerTestFramework.LiveService.FakeSG.IFakeSGClient _fakesgclient = null;

        #endregion

        #region Redirection

        /// <summary>
        /// Returns true if TestThroughSG is currently redirecting traffic; false otherwise.
        /// </summary>
        public static bool IsRedirecting
        {
            get
            {
                return (_bridge != null && ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.Singleton._FakeSG == _bridge);
            }
        }

        /// <summary>
        /// Does what is necessary to begin the redirection of standard traffic to the SG.
        /// </summary>
        /// <remarks>
        /// Doesn't take steps to clean up if something goes wrong.  Should be fixed.
        /// </remarks>
        public static void BeginRedirecting ()
        {
            // first reset some internal counters
            _Debug_droppedOutboundDeadSAA = 0;

            if (RequiresTargetInterface(Source))
            {
                if (_targetInterface == null)
                {
                    throw new TestThroughSGException("A value must be set for TargetInterface to begin redirection.");
                }
            } 

            if (RequiresSpoofedAddress(Source))
            {
                if (_spoofedAddress == null)
                {
                    throw new TestThroughSGException("A value must be set for SpoofedAddress to begin redirection.");
                }

                string ti_string = _targetInterface.ToString();
                string sa_string = _spoofedAddress.ToString();

                // check on ARP table entry
                // we could potentially use the IpHelper function GetIpNetTable here
                ProcessStartInfo start_info = new ProcessStartInfo("arp", "-a " + sa_string + " -N " + ti_string);
                start_info.CreateNoWindow = true;
                start_info.RedirectStandardOutput = true;
                start_info.UseShellExecute = false;

                Process arp_check = Process.Start(start_info);

                // read all data and wait for process to exit
                string arp_output = arp_check.StandardOutput.ReadToEnd();
                arp_check.WaitForExit(10000);

                if (arp_output.StartsWith("No ARP Entries Found"))
                {
                    // reuse objects to add static route
                    // we could potentially use the IpHelper function CreateIpNetEntry or SetIpNetEntry here
                    start_info.Arguments = "-s " + sa_string + " 00-00-00-00-00-00 " + ti_string;

                    arp_check = Process.Start(start_info);
                    arp_output = arp_check.StandardOutput.ReadToEnd();
                    arp_check.WaitForExit(10000);

                    if (arp_output.Contains("failed"))
                    {
                        throw new TestThroughSGException("Adding the ARP entry for the SpoofedAddress failed.\n  Arp arguments: " +
                            start_info.Arguments + "\n  Output: " + arp_output);
                    }
                }

                // check on routing table entry
                start_info.FileName = "route";
                start_info.Arguments = "print " + sa_string + " mask 255.255.255.255 " + ti_string;

                Process route_check = Process.Start(start_info);

                // read all data and wait for process to exit
                string route_output = route_check.StandardOutput.ReadToEnd();
                route_check.WaitForExit(10000);

                if (!route_output.Contains(sa_string))
                {
                    start_info.Arguments = "add " + sa_string + " mask 255.255.255.255 " + ti_string;

                    route_check = Process.Start(start_info);
                    route_output = route_check.StandardOutput.ReadToEnd();
                    route_check.WaitForExit(10000);
                }

                // create the raw socket
                switch (Source)
                {
                    case PacketSource.RawSocket:
                        _rawSocket = new RawSocket(_targetInterface, _spoofedAddress);
                        break;

                    case PacketSource.Netmon:
                        _rawSocket = new NetmonRawSocket(_targetInterface, _spoofedAddress);
                        break;
                }

            }

            // create bridge
            _bridge = new ConnectionBridge();
            _bridge.Initialize();

            // determine SG cooldown to avoid TCP time-wait failures
            int port_count = Config.GetIntSetting(Setting.sg_ClientPortLimit) - Config.GetIntSetting(Setting.sg_ConnectionServerPortLimit);
            _bridge.SGConnectionCooldown = TcpTimeWaitConstantOffset + ((double)TcpTimeWaitDelay / (double)port_count);

            _threadShouldRun = true;

            if (RequiresSpoofedAddress(Source))
            {
                // create the raw receive worker thread
                _rawReceiveThread = new Thread(RawReceiveThreadStart);
                _rawReceiveThread.IsBackground = true;
                _rawReceiveThread.Name = "TestThroughSG RawReceive";
                _rawReceiveThread.Start();

                // create the outbound worker thread
                _outboundThread = new Thread(OutboundCaptureThreadStart);
                _outboundThread.IsBackground = true;
                _outboundThread.Name = "TestThroughSG Outbound (Capture)";
                _outboundThread.Start();

                // create the inbound worker thread
                _inboundThread = new Thread(InboundCaptureThreadStart);
                _inboundThread.IsBackground = true;
                _inboundThread.Name = "TestThroughSG Inbound (Capture)";
                _inboundThread.Start();
            }
            else
            {
                // create the outbound worker thread
                _outboundThread = new Thread(OutboundDirectThreadStart);
                _outboundThread.IsBackground = true;
                _outboundThread.Name = "TestThroughSG Outbound (Direct)";
                _outboundThread.Start();

                // create the inbound worker thread
                _inboundThread = new Thread(InboundDirectThreadStart);
                _inboundThread.IsBackground = true;
                _inboundThread.Name = "TestThroughSG Inbound (Direct)";
                _inboundThread.Start();
            }

            // replace FakeSG with our own
            _fakesgclient = ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.Singleton._FakeSG;
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.Singleton._FakeSG = _bridge;

            if (RequiresSpoofedAddress(Source))
            {
                // now that we should be up and running, redirect STF VIPs to us
                Dictionary<string, IPEndPoint> redirects = new Dictionary<string, IPEndPoint>();
                string[] vints = _bridge.GetMappedVirtualInterfaceNames();

                foreach (string vint in vints)
                {
                    redirects.Add(vint, new IPEndPoint(_spoofedAddress, IPEndPoint.MinPort));
                }

                ServerTestFramework.Global.XEnv.RedirectVirtualInterfaces(redirects);
            }
            else if (Source == PacketSource.Proxy)
            {
                _proxy = new Proxy(_bridge);
                ServerTestFramework.Global.XEnv.RedirectVirtualInterfaces(_proxy.Start(_bridge.GetMappedVirtualInterfaceNames()));
            }
            else if (Source == PacketSource.Direct)
            {
                // add our hooks into FDTransaction so that it can be served
                ServerTestFramework.LiveService.FDTransaction.ExternalTcpClient = _bridge.AcquireTcpClient;
                ServerTestFramework.LiveService.FDTransaction.ExternalUdpClient = _bridge.AcquireUdpClient;
            }
        }

        /// <summary>
        /// Ends the redirection, which should put everything back to the way it was before.
        /// </summary>
        public static void EndRedirecting ()
        {
            // restore FakeSG
            ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.Singleton._FakeSG = _fakesgclient;

            if (RequiresTargetInterface(Source))
            {
                // remove redirection of virtual interfaces
                ServerTestFramework.Global.XEnv.RedirectVirtualInterfaces(null);

                if (_proxy != null)
                {
                    _proxy.Stop();
                    _proxy = null;
                }
            }
            else
            {
                // remove our hooks from FDTransaction
                ServerTestFramework.LiveService.FDTransaction.ExternalTcpClient = null;
                ServerTestFramework.LiveService.FDTransaction.ExternalUdpClient = null;
            }

            // shut down thread
            _threadShouldRun = false;

            if (_inboundThread != null)
            {
                _inboundThread.Join(10000);
                _inboundThread = null;
            }

            if (_rawReceiveThread != null)
            {
                _rawReceiveThread.Join(10000);
                _rawReceiveThread = null;
            }

            // shut down the bridge
            if (_bridge != null)
            {
                _bridge.Shutdown();
                _bridge = null;
            }

            // bridge shutdown will break this thread out of sleep
            if (_outboundThread != null)
            {
                _outboundThread.Join(10000);
                _outboundThread = null;
            }

            // close raw socket
            if (_rawSocket != null)
            {
                _rawSocket.Close();
                _rawSocket = null;
            }
        }

        #endregion

        #region Worker Threads

        /// <summary>
        /// The worker thread for TestThroughSG that receives from the raw socket.
        /// </summary>
        private static void RawReceiveThreadStart ()
        {
            while (_threadShouldRun)
            {
                try
                {
                    XspBuffer packet = _rawSocket.Receive();

                    if (packet == null)
                    {
                        // this really shouldn't happen, but we are just protecting ourselves
                        continue;
                    }

                    IPEndPoint ep = RawSocket.GetSourceIPEndPoint(packet);
                    byte protocol = RawSocket.GetProtocol(packet);
                    byte flags = (protocol == RawSocket.ProtocolTCP ? RawSocket.GetTCPFlags(packet) : (byte)0);

                    //Global.RO.Info("{0} -> :{1} | {2} | {3}", 
                    //    ep.ToString(), RawSocket.GetDestPortFromXspBuffer(packet), 
                    //    (protocol == RawSocket.ProtocolTCP ? "TCP" : "UDP"),
                    //    (protocol != RawSocket.ProtocolTCP ? "-" :
                    //    "[" + flags.ToString("X2") + "] ......" +
                    //    ((flags & RawSocket.TCPFlagSYN) == RawSocket.TCPFlagSYN ? "S" : ".") + 
                    //    "."));

                    // flags will be 0 for UDP, so this flag check can't be true
                    // we don't want to create a new connection unless we should
                    bool possibly_new = ((flags & RawSocket.TCPFlagSYN) == RawSocket.TCPFlagSYN) || (protocol == RawSocket.ProtocolUDP);

                    // append packet to connection's queue and mark it as in need of attention
                    _bridge.AppendPacketToOutboundQueue(ep, packet, possibly_new);
                }
                catch (System.Net.Sockets.SocketException se)
                {
                    // any socket exception after we are shutting down is useless
                    if (_threadShouldRun)
                    {
                        Global.RO.Debug("SocketException occured in RawReceiveThreadStart:\n" + se.ToString());
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Debug("Exception occured in RawReceiveThreadStart:\n" + e.ToString());
                }
            }
        }

        /// <summary>
        /// The worker thread for TestThroughSG that creates connections and sends packets to the SG.
        /// </summary>
        private static void OutboundCaptureThreadStart ()
        {
            while (_threadShouldRun)
            {
                try
                {
                    _bridge.WaitForOutboundWork();

                    while (true)
                    {
                        try
                        {
                            // can happen on shutdown causing this thread to deadlock
                            if (_bridge == null)
                            {
                                break;
                            }

                            // get a work item from the queue
                            ConnectionBridge.SlotAuthAssociation saa = _bridge.DequeueOutboundWork();

                            // go until we run out of work
                            if (saa == null)
                            {
                                break;
                            }

                            // this saa is dead, we are needed to drain its outbound queue for thread safety
                            if (saa.IsDead)
                            {
                                while (true)
                                {
                                    XspBuffer packet = saa.OutboundQueue.Dequeue();

                                    if (packet == null)
                                    {
                                        break;
                                    }
                                    else
                                    {
                                        ++_Debug_droppedOutboundDeadSAA;
                                        XspBufferManager.Free(packet);
                                    }
                                }
                                continue;
                            }

                            // make sure we have something to do
                            if (saa.OutboundQueue.Empty &&
                                !(saa.Connection != null && saa.Connection.State == SGConnection.ConnectionState.Connected &&
                                  saa.Connection.ChangeUsersPending))
                            {
                                continue;
                            }

                            // check for an SG connection, add one if needed
                            if (saa.Connection == null)
                            {
                                _bridge.GetSGConnection(saa);

                                // see if we need to connect
                                // we should only connect if needed for the first packet
                                // don't want to suddenly change our SG association
                                if (saa.Connection.State == SGConnection.ConnectionState.Disconnected)
                                {
                                    saa.Connection.ConnectAsync();
                                    _bridge.EnqueueOutboundWork(saa);
                                    continue;
                                }
                            }

                            // continue connecting
                            if (saa.Connection.State == SGConnection.ConnectionState.ConnectWait)
                            {
                                saa.Connection.ProcessReceiveQueue();

                                // an error occured in the key exchange
                                if (saa.Connection.State == SGConnection.ConnectionState.Disconnected)
                                {
                                    Global.RO.Error("An error occured during key exchange (TestThroughSG):\n" +
                                        saa.Connection.LastKeyexException.ToString());
                                    // WE SHOULD ALSO PROBABLY SEND A TCP RST HERE ???
                                    // PROBABLY VIA SOME STANDARD "END SAA" FUNCTION
                                    continue;
                                }

                                // still waiting for a response
                                if (saa.Connection.State == SGConnection.ConnectionState.ConnectWait)
                                {
                                    // I wish we wouldn't just spin when there is only 1 work item...
                                    _bridge.EnqueueOutboundWork(saa);
                                    continue;
                                }
                            }

                            // just to double check that we are connected
                            if (saa.Connection.State == SGConnection.ConnectionState.Connected)
                            {
                                // if the slot was set after the last reply
                                if (saa.SGInfoSet > saa.Connection.LastChangeUsersRep)
                                {
                                    // if the slot was set before the last request, we already sent it
                                    if (saa.SGInfoSet <= saa.Connection.LastChangeUsersReq)
                                    {
                                        // pump the queue
                                        saa.Connection.ProcessReceiveQueue();

                                        if (saa.Connection.ChangeUsersPending)
                                        {
                                            // @@@TODO: If it has been too long, we probably want to kill this!!!

                                            // we still didn't get a response
                                            // see how long its been, maybe we need to try again
                                            saa.Connection.ProdChangeUsers();

                                            // regardless, add back to work queue
                                            _bridge.EnqueueOutboundWork(saa);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        if (saa.SGInfoUseSGConnection)
                                        {
                                            // internal user change to open the connection up, don't copy
                                            saa.SGInfoUseSGConnection = false;
                                        }
                                        else
                                        {
                                            // copy user supplied authdata to sg connection
                                            saa.SGInfo.CopyToAuthdata(saa.Connection.Context.Authdata);
                                        }

                                        // send user change packet
                                        saa.Connection.SendChangeUsers();

                                        // back around!
                                        _bridge.EnqueueOutboundWork(saa);
                                        continue;
                                    }
                                }

                                // now we can actually send packets
                                while (true)
                                {
                                    XspBuffer packet = saa.OutboundQueue.Dequeue();

                                    if (packet == null)
                                    {
                                        break;
                                    }

                                    byte protocol = RawSocket.GetProtocol(packet);

                                    // get ports and translate dest to inet dest
                                    ushort source_port = RawSocket.GetSourcePortFromXspBuffer(packet);
                                    ushort dest_port = RawSocket.GetDestPortFromXspBuffer(packet);

                                    dest_port = _bridge.TranslateServicePortToInet(dest_port);

                                    if (dest_port == 0)
                                    {
                                        Global.RO.Warn("Unknown service port detected: " + RawSocket.GetDestPortFromXspBuffer(packet));
                                        XspBufferManager.Free(packet);
                                        continue;
                                    }

                                    switch (protocol)
                                    {
                                        case RawSocket.ProtocolTCP:
                                            {
                                                byte flags = RawSocket.GetTCPFlags(packet);

                                                // if this is a SYN only packet, we need to ensure that the MSS is not too big
                                                if (flags == RawSocket.TCPFlagSYN)
                                                {
                                                    RawSocket.EnsureTcpMss(packet, _tcpMss);
                                                }

                                                saa.Connection.Session.EncodeTcpWithDataInPlace(packet, source_port, dest_port,
                                                    packet.RawBuffer, RawSocket.GetTcpInfoOffset(packet), packet.RawBufferLength);
                                                saa.Connection.Send(packet);
                                                XspBufferManager.Free(packet);

                                                // update connection state based on TCP flags
                                                _bridge.HandleTcpFlags(saa, flags);
                                            }
                                            break;

                                        case RawSocket.ProtocolUDP:
                                            {
                                                saa.Connection.Session.EncodeUdpWithDataInPlace(packet, source_port, dest_port,
                                                    packet.RawBufferLength);
                                                saa.Connection.Send(packet);
                                                XspBufferManager.Free(packet);

                                                // set UDP activity state
                                                _bridge.MarkUdpActivity(saa);
                                            }
                                            break;

                                        default:
                                            Global.RO.Warn("Got unrecognized protocol for packet on outbound queue: " + protocol);
                                            XspBufferManager.Free(packet);
                                            break;
                                    }
                                }

                                // We finished sending packets, go on to the next work item
                                // Avoids the default case below of assuming that things are bad
                                continue;
                            }

                            // we got disconnected suddenly, we should kill this SlotAuthAssociation
                            Global.RO.Warn("Suddenly disconnected from the SG!");
                            // KILL THE SAA, INCLUDING ANY TCP CONNECTION THAT MIGHT BE GOING OVER IT !!!
                            // PROBABLY VIA SOME STANDARD "END SAA" FUNCTION
                        }
                        catch (Exception e)
                        {
                            Global.RO.Debug("Exception occured in OutboundCaptureThreadStart inner loop:\n" + e.ToString());
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Debug("Exception occured in OutboundCaptureThreadStart outer loop:\n" + e.ToString());
                }
            }
        }

        /// <summary>
        /// The worker thread for TestThroughSG that keeps connections alive and sends packets to the clients.
        /// </summary>
        private static void InboundCaptureThreadStart ()
        {
            int current_conn = 0;

            while (_threadShouldRun)
            {
                try
                {
                    // loop over all connections
                    SGConnection conn = _bridge.GetSGConnectionByIndex(ref current_conn);

                    if (conn == null || conn.State != SGConnection.ConnectionState.Connected)
                    {
                        continue;
                    }

                    // get our packets in
                    conn.ProcessReceiveQueue();

                    // see if we need to send a pulse
                    conn.SendHeartbeat(true);

                    // check the port based on the SlotAuthAssociation
                    ConnectionBridge.SlotAuthAssociation saa = ConnectionBridge.GetSlotAuthAssociationFromSGConnection(conn);

                    // no current user activity over this connection
                    if (saa == null)
                    {
                        continue;
                    }

                    // check for dead connections
                    TimeSpan dead_time = DateTime.UtcNow - saa.LastActivity;

                    // if: No activity for long timeout
                    //     No activity for half closed timeout
                    //     Fully closed
                    if (dead_time > UserActivityTimeout ||
                        (saa.TcpHalfClosed == 1 && dead_time > TcpHalfClosedTimeout) ||
                        (saa.TcpHalfClosed >= 2 && dead_time > TcpClosedTimeout))
                    {
                        _bridge.DestroySlotAuthAssociation(saa);
                        continue;
                    }

                    if (saa.TcpSent)
                    {
                        // look at the tcp port for incoming packets
                        XspBuffer queue = conn.GetPacketsOnPort(XspHeader.XSP_TYPE_TCP_0, (uint)(saa.Source.Port));

                        while (queue != null)
                        {
                            XspBuffer current = queue;
                            queue = queue.Next;
                            current.Next = null;

                            try
                            {
                                byte flags = GetTcpFlags(current);

                                MovePacketData(current, true);
                                WriteIpHeader(current, true, saa.SourceInteger);
                                WriteTcpHeader(current);

                                _rawSocket.SendTo(current.RawBuffer, (40 + current.DataBufferLength), saa.Source);

                                XspBufferManager.Free(current);

                                _bridge.HandleTcpFlags(saa, flags);
                            }
                            catch (Exception e)
                            {
                                Global.RO.Debug("Exception occured in InboundCaptureThreadStart::Tcp Send Loop:\n" + e.ToString());
                            }
                        }
                    }

                    if (saa.UdpSent)
                    {
                        // look at the udp port for incoming packets
                        XspBuffer queue = conn.GetPacketsOnPort(XspHeader.XSP_TYPE_UDP_0, (uint)(saa.Source.Port));

                        while (queue != null)
                        {
                            XspBuffer current = queue;
                            queue = queue.Next;
                            current.Next = null;

                            try
                            {
                                MovePacketData(current, false);
                                WriteIpHeader(current, false, saa.SourceInteger);
                                WriteUdpHeader(current);

                                _rawSocket.SendTo(current.RawBuffer, (40 + current.DataBufferLength), saa.Source);

                                XspBufferManager.Free(current);

                                _bridge.MarkUdpActivity(saa);
                            }
                            catch (Exception e)
                            {
                                Global.RO.Debug("Exception occured in InboundCaptureThreadStart::Udp Send Loop:\n" + e.ToString());
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Debug("Exception occured in InboundCaptureThreadStart:\n" + e.ToString());
                    // break for now so we don't go nuts with exceptions
                    break;
                }
            }
        }

        /// <summary>
        /// The worker thread for TestThroughSG that creates connections and sends packets to the SG.
        /// </summary>
        private static void OutboundDirectThreadStart ()
        {
            while (_threadShouldRun)
            {
                try
                {
                    _bridge.WaitForOutboundWork();

                    while (true)
                    {
                        try
                        {
                            // can happen on shutdown causing this thread to deadlock
                            if (_bridge == null)
                            {
                                break;
                            }

                            // get a work item from the queue
                            ConnectionBridge.SlotAuthAssociation saa = _bridge.DequeueOutboundWork();

                            // go until we run out of work
                            if (saa == null)
                            {
                                break;
                            }

                            // no connection, nothing to do here
                            if (saa.Connection == null)
                            {
                                continue;
                            }

                            // just to double check that we are connected
                            if (saa.Connection.State == SGConnection.ConnectionState.Connected)
                            {
                                // if the slot was set after the last reply
                                if (saa.SGInfoSet > saa.Connection.LastChangeUsersRep)
                                {
                                    // if the slot was set before the last request, we already sent it
                                    if (saa.SGInfoSet <= saa.Connection.LastChangeUsersReq)
                                    {
                                        // pump the queue
                                        saa.Connection.ProcessReceiveQueue();

                                        if (saa.Connection.ChangeUsersPending)
                                        {
                                            // @@@TODO: If it has been too long, we probably want to kill this!!!

                                            // we still didn't get a response
                                            // see how long its been, maybe we need to try again
                                            saa.Connection.ProdChangeUsers();

                                            // regardless, add back to work queue
                                            _bridge.EnqueueOutboundWork(saa);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        if (saa.SGInfoUseSGConnection)
                                        {
                                            // internal user change to open the connection up, don't copy
                                            saa.SGInfoUseSGConnection = false;
                                        }
                                        else
                                        {
                                            // copy user supplied authdata to sg connection
                                            saa.SGInfo.CopyToAuthdata(saa.Connection.Context.Authdata);
                                        }

                                        // send user change packet
                                        saa.Connection.SendChangeUsers();

                                        // back around!
                                        _bridge.EnqueueOutboundWork(saa);
                                        continue;
                                    }
                                }

                                // We finished sending packets, go on to the next work item
                                // Avoids the default case below of assuming that things are bad
                                continue;
                            }

                            // we got disconnected suddenly, we should kill this SlotAuthAssociation
                            Global.RO.Warn("Suddenly disconnected from the SG!");
                            // KILL THE SAA, INCLUDING ANY TCP CONNECTION THAT MIGHT BE GOING OVER IT !!!
                            // PROBABLY VIA SOME STANDARD "END SAA" FUNCTION
                        }
                        catch (Exception e)
                        {
                            Global.RO.Debug("Exception occured in OutboundDirectThreadStart inner loop:\n" + e.ToString());
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Debug("Exception occured in OutboundDirectThreadStart outer loop:\n" + e.ToString());
                }
            }
        }

        /// <summary>
        /// The worker thread for TestThroughSG that keeps connections alive and sends packets to the clients.
        /// </summary>
        private static void InboundDirectThreadStart ()
        {
            int current_conn = 0;

            while (_threadShouldRun)
            {
                try
                {
                    // loop over all connections
                    SGConnection conn = _bridge.GetSGConnectionByIndex(ref current_conn);

                    if (conn == null)
                    {
                        continue;
                    }

                    if (conn.State == SGConnection.ConnectionState.Connected)
                    {
                        // get our packets in
                        conn.ProcessReceiveQueue();

                        // see if we need to send a pulse
                        conn.SendHeartbeat(true);
                    }

                    // check the port based on the SlotAuthAssociation
                    ConnectionBridge.SlotAuthAssociation saa = ConnectionBridge.GetSlotAuthAssociationFromSGConnection(conn);

                    // no current user activity over this connection
                    if (saa != null)
                    {
                        // check for dead connections
                        if (saa.IsDead)
                        {
                            _bridge.DestroySlotAuthAssociation(saa);
                            continue;
                        }
                    }
                }
                catch (Exception e)
                {
                    Global.RO.Debug("Exception occured in InboundDirectThreadStart:\n" + e.ToString());
                    // break for now so we don't go nuts with exceptions
                    break;
                }
            }
        }

        #region Inbound Thread Helpers

        /// <summary>
        /// Scratch space used by the InboundThread.  Includes functions:
        ///   MovePacketData
        ///   WriteTcpHeader
        ///   WriteUdpHeader
        /// </summary>
        private static byte[] InboundThreadScratchSpace = new byte[12];

        /// <summary>
        /// Gets the TCP flags from an inbound packet.
        /// </summary>
        /// <param name="packet">The packet to read from.</param>
        /// <returns>The TCP flags byte.</returns>
        private static byte GetTcpFlags (XspBuffer packet)
        {
            return packet.RawBuffer[packet.TcpInfoOffset + 9];
        }

        /// <summary>
        /// Moves the data buffer of an inbound XSP packet.
        /// </summary>
        /// <param name="packet">The packet to modify.</param>
        /// <param name="isTcp">True if this is a TCP packet; false if not.</param>
        private static void MovePacketData (XspBuffer packet, bool isTcp)
        {
            if (isTcp)
            {
                Buffer.BlockCopy(packet.RawBuffer, (int)(packet.TcpInfoOffset), InboundThreadScratchSpace, 0, 12);
            }

            Buffer.BlockCopy(packet.RawBuffer, 4, packet.RawBuffer, (isTcp ? 40 : 28), (int)(packet.DataBufferLength));

            if (isTcp)
            {
                Buffer.BlockCopy(InboundThreadScratchSpace, 0, packet.RawBuffer, 24, 12);
            }
        }

        /// <summary>
        /// Writes the IP header into the packet.  May not be pretty, but faster than some serialization thing.
        /// </summary>
        /// <param name="packet">The packet to write to.</param>
        /// <param name="isTcp">True if this is a TCP packet; false if not.</param>
        /// <param name="destAddr">The destination address, as an integer.</param>
        private static void WriteIpHeader (XspBuffer packet, bool isTcp, int destAddr)
        {
            byte[] arr = packet.RawBuffer;

            // version and header length
            arr[0] = (byte)0x45;
            // differentiated services
            arr[1] = 0;
            // total size
            uint size = (uint)((isTcp ? 40 : 28) + packet.DataBufferLength);
            arr[2] = (byte)(size >> 8);
            arr[3] = (byte)(size & 0xFF);
            // identification
            arr[4] = 0;
            arr[5] = 0;
            // flags and fragment offset
            arr[6] = 0;
            arr[7] = 0;
            // ttl
            arr[8] = (byte)126;
            // protocol
            arr[9] = (isTcp ? RawSocket.ProtocolTCP : RawSocket.ProtocolUDP);
            // checksum
            arr[10] = 0;
            arr[11] = 0;
            // source IP
            int spoofed_addr = _rawSocket.SpoofedAddressInteger;
            arr[12] = (byte)((spoofed_addr) & 0xFF);
            arr[13] = (byte)((spoofed_addr >> 8) & 0xFF);
            arr[14] = (byte)((spoofed_addr >> 16) & 0xFF);
            arr[15] = (byte)((spoofed_addr >> 24) & 0xFF);
            // dest IP
            arr[16] = (byte)((destAddr) & 0xFF);
            arr[17] = (byte)((destAddr >> 8) & 0xFF);
            arr[18] = (byte)((destAddr >> 16) & 0xFF);
            arr[19] = (byte)((destAddr >> 24) & 0xFF);
        }

        /// <summary>
        /// Writes the TCP header into the packet.
        /// </summary>
        /// <param name="packet">The packet to write to.</param>
        private static void WriteTcpHeader (XspBuffer packet)
        {
            byte[] arr = packet.RawBuffer;

            // source port
            ushort source_port = _bridge.TranslateInetPortToService((ushort)(packet.SourcePort));
            arr[20] = (byte)((source_port >> 8) & 0xFF);
            arr[21] = (byte)((source_port) & 0xFF);
            // dest port
            uint dest_port = packet.DestPort;
            arr[22] = (byte)((dest_port >> 8) & 0xFF);
            arr[23] = (byte)((dest_port) & 0xFF);
            // the next 12 bytes were copied here for use by MovePacketData
            // checksum, done for us by ComputeTcpChecksum
            //arr[36] = 0;
            //arr[37] = 0;
            // urgency
            arr[38] = 0;
            arr[39] = 0;

            // if this is a SYN-ACK packet, we need to ensure that the MSS is not too big
            if (arr[33] == (byte)(RawSocket.TCPFlagSYN | RawSocket.TCPFlagACK))
            {
                EnsureTcpMss(packet, _tcpMss);
            }

            // compute some values
            uint tcp_hdr_len = (uint)(((arr[32] >> 4) & 0xF) * 4);

            // do checksum
            RawSocket.ComputeTcpChecksum(arr, 0, arr, 20, tcp_hdr_len, arr, 20 + tcp_hdr_len,
                (uint)(packet.DataBufferLength + 20 - tcp_hdr_len), InboundThreadScratchSpace);
        }

        /// <summary>
        /// Writes the UDP header into the packet.
        /// </summary>
        /// <param name="packet">The packet to write to.</param>
        private static void WriteUdpHeader (XspBuffer packet)
        {
            byte[] arr = packet.RawBuffer;

            // source port
            ushort source_port = _bridge.TranslateInetPortToService((ushort)(packet.SourcePort));
            arr[20] = (byte)((source_port >> 8) & 0xFF);
            arr[21] = (byte)((source_port) & 0xFF);
            // dest port
            uint dest_port = packet.DestPort;
            arr[22] = (byte)((dest_port >> 8) & 0xFF);
            arr[23] = (byte)((dest_port) & 0xFF);
            // length
            uint len = 8 + packet.DataBufferLength;
            arr[24] = (byte)((len >> 8) & 0xFF);
            arr[25] = (byte)((len) & 0xFF);
            // checksum, done for us by ComputeUdpChecksum
            //arr[26] = 0;
            //arr[27] = 0;

            // do checksum
            RawSocket.ComputeUdpChecksum(arr, 0, arr, 20, arr, 28, packet.DataBufferLength, InboundThreadScratchSpace);
        }

        /// <summary>
        /// Checks a TCP SYN-ACK connection response packet for an MSS, changing it if necessary.
        /// </summary>
        /// <param name="packet">The packet buffer to modify.</param>
        /// <param name="mss">The MSS value to ensure.</param>
        public static void EnsureTcpMss (XspBuffer packet, ushort mss)
        {
            // determine number of option bytes
            byte[] data = packet.RawBuffer;
            int option_bytes = (((data[32] >> 4) & 0xF) * 4) - 20;
            int mss_option_offset = 0;

            for (int i = 0; i < option_bytes; )
            {
                byte current = data[40 + i];

                switch (current)
                {
                    case RawSocket.TCPOptionEnd:
                        goto search_done;

                    case RawSocket.TCPOptionNoOp:
                        ++i;
                        break;

                    case RawSocket.TCPOptionMSS:
                        mss_option_offset = 40 + i;
                        goto search_done;

                    default:
                        i += (int)(data[40 + i + 1]);
                        break;
                }
            }

        search_done:
            if (mss_option_offset == 0)
            {
                if (option_bytes > 36)
                {
                    // should VERY rarely happen
                    throw new TestThroughSGException("Cannot add the MSS option because there are too many headers already.");
                }

                // we need to add the option... sigh
                // start by shifting all of the other data
                Buffer.BlockCopy(data, 40, data, 44, (int)(packet.DataBufferLength));
                packet.DataBufferLength += 4;

                // set the TCP header size
                byte current = data[32];
                data[32] = (byte)((((option_bytes + 4) / 4) << 4) | (current & 0xF));

                // write the option data
                data[40] = RawSocket.TCPOptionMSS;
                data[41] = 4;
                data[42] = (byte)((mss >> 8) & 0xFF);
                data[43] = (byte)(mss & 0xFF);
            }
            else
            {
                // read current option
                ushort current = (ushort)((data[mss_option_offset + 2] << 8) | data[mss_option_offset + 3]);

                if (current > mss)
                {
                    // just change the option value
                    data[mss_option_offset + 2] = (byte)((mss >> 8) & 0xFF);
                    data[mss_option_offset + 3] = (byte)(mss & 0xFF);
                }
            }
        }

        #endregion

        #endregion

        #region Debug Information

        /// <summary>A count of the number of packets dropped from dead SAAs.</summary>
        private static int _Debug_droppedOutboundDeadSAA;

        /// <summary>
        /// Gets the virtual interfaces that are mapped by the connection bridge.
        /// </summary>
        internal static List<ConnectionBridge.VirtualInterface> GetRedirectedInterfaces ()
        {
            ConnectionBridge bridge = _bridge;
            if (bridge != null)
            {
                return bridge.GetRedirectedInterfaces();
            }

            return null;
        }

        /// <summary>
        /// A collection of stats from the various subcomponents.
        /// </summary>
        internal struct StatsCollection
        {
            public int RawSocketDroppedTooSmall;
            public int RawSocketDroppedNotOurIP;
            public int RawSocketDroppedSizeMismatch;
            public int RawSocketDroppedFragmented;
            public int RawSocketDroppedProtocolNotSupported;
            public int RawSocketDroppedTooLarge;
            public int RawSocketReceived;
            public int RawSocketDroppedNotSent;
            public int RawSocketSent;

            public int BridgeSAACount;
            public int BridgeSGConnCount;

            public int TTSGDroppedDeadSAA;
        }

        /// <summary>
        /// Gets a collection of stats from the various subcomponents.
        /// </summary>
        internal static void FillStatsCollection (ref StatsCollection stats)
        {
            IRawSocket rawSocket = _rawSocket;
            if (rawSocket != null)
            {
                rawSocket.FillStatsCollection(ref stats);
            }

            ConnectionBridge bridge = _bridge;
            if (bridge != null)
            {
                bridge.FillStatsCollection(ref stats);
            }

            stats.TTSGDroppedDeadSAA = _Debug_droppedOutboundDeadSAA;
        }

        #endregion
    }

    /// <summary>
    /// An exception that is thrown by the TestThroughSG class.
    /// </summary>
    public class TestThroughSGException : Exception
    {
        public TestThroughSGException (string message) : base(message) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TestThroughSG\RawSocket.cs ===
﻿using System;
using System.Net;
using System.Net.Sockets;

using ServerTestFramework.LiveService.Auth;

namespace TestThroughSG
{
    /// <summary>
    /// The interface for doing simple raw socket work.
    /// </summary>
    internal interface IRawSocket
    {
        /// <summary>The spoofed IP address as an integer.</summary>
        int SpoofedAddressInteger
        {
            get;
        }

        /// <summary>
        /// Attempts to receive a packet from the socket, filtering down to the specified IP.
        /// Not thread safe, as a single buffer is used for receiving.
        /// </summary>
        /// <returns>An XspBuffer, with specific data encoded into it.</returns>
        /// <remarks>
        /// The XspBuffer returned will have the important data from the packet copied into it in this format:
        /// Length|| 4              | RawBufferLength | 4     | 1        | 12 if Protocol is TCP, 0 if UDP
        /// Data  || Source Address | Packet Data     | Ports | Protocol | TCP Info (12 bytes of TCP header after ports)
        /// </remarks>
        XspBuffer Receive ();

        /// <summary>
        /// Sends a packet to the specified location.
        /// </summary>
        /// <param name="buffer">The packet data to send.</param>
        /// <param name="size">The length, in bytes, of the data to send.</param>
        /// <param name="endPoint">The location to send to.</param>
        void SendTo (byte[] buffer, uint size, IPEndPoint endPoint);

        /// <summary>
        /// Closes the socket.
        /// </summary>
        void Close ();

        /// <summary>
        /// Gets a collection of stats from the raw socket.
        /// </summary>
        void FillStatsCollection (ref TestThroughSG.StatsCollection stats);
    }

    /// <summary>
    /// Contains a raw socket and provides access to receiving and sending with it.
    /// </summary>
    internal class RawSocket : IRawSocket
    {
        #region Private Fields

        /// <summary>The socket we will use to listen and send on.</summary>
        private Socket _sock = null;

        /// <summary>Buffer that we use to receive with.</summary>
        private byte[] _buffer = null;

        /// <summary>Used in receive because we must pass one in.</summary>
        private IPEndPoint _any_ep = null;

        /// <summary>The interface that the raw socket will be attached to.</summary>
        private IPAddress _targetInterface = null;

        /// <summary>The IP that we are spoofing (filters the incoming, defines the outgoing).</summary>
        private IPAddress _spoofed = null;
        private int _spoofed_int = 0;

        // This collection of values keeps stats on things that happen to this socket
        private int _dropped_TooSmall = 0;
        private int _dropped_NotOurIP = 0;
        private int _dropped_SizeDoesNotMatchIPHeader = 0;
        private int _dropped_Fragmented = 0;
        private int _dropped_ProtocolNotSupported = 0;
        private int _dropped_TooLarge = 0;
        private int _received = 0;
        private int _dropped_NotSent = 0;
        private int _sent = 0;

        #endregion

        #region Consts

        /// <summary>The IP header bit that specifies fragmentation, which we don't do.</summary>
        public const byte IPHeaderMoreFragments = 0x20;

        /// <summary>The protocol number of TCP.</summary>
        public const byte ProtocolTCP = 6;

        /// <summary>The protocol number of UDP.</summary>
        public const byte ProtocolUDP = 17;

        /// <summary>The TCP SYN flag.</summary>
        public const byte TCPFlagSYN = 0x02;
        /// <summary>The TCP SYN flag.</summary>
        public const byte TCPFlagFIN = 0x01;
        /// <summary>The TCP SYN flag.</summary>
        public const byte TCPFlagRST = 0x04;
        /// <summary>The TCP ACK flag.</summary>
        public const byte TCPFlagACK = 0x10;

        /// <summary>The TCP option end identifier.</summary>
        public const byte TCPOptionEnd = 0;
        /// <summary>The TCP option no operation identifier.</summary>
        public const byte TCPOptionNoOp = 1;
        /// <summary>The TCP option MSS identifier.</summary>
        public const byte TCPOptionMSS = 2;

        #endregion

        /// <summary>The spoofed IP address as an integer.</summary>
        public int SpoofedAddressInteger
        {
            get
            {
                return _spoofed_int;
            }
        }

        /// <summary>
        /// Creates the raw socket.
        /// </summary>
        /// <param name="targetInterface">The IPAddress of the interface that should be attached to.</param>
        /// <param name="spoofed">The IPAddress that we are spoofing.</param>
        public RawSocket (IPAddress targetInterface, IPAddress spoofed)
        {
            _targetInterface = targetInterface;
            _spoofed = spoofed;
            _spoofed_int = BitConverter.ToInt32(_spoofed.GetAddressBytes(), 0);

            _buffer = new byte[1500];
            _any_ep = new IPEndPoint(IPAddress.Any, 0);

            // create the magic socket
            _sock = new Socket(AddressFamily.InterNetwork, SocketType.Raw, ProtocolType.IP);
            _sock.Bind((EndPoint)(new IPEndPoint(_targetInterface, 0)));
            _sock.IOControl(IOControlCode.ReceiveAll, new byte[] { 1, 0, 0, 0 }, _buffer);
            _sock.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.HeaderIncluded, true);
        }

        /// <summary>
        /// Attempts to receive a packet from the socket, filtering down to the specified IP.
        /// Not thread safe, as a single buffer is used for receiving.
        /// </summary>
        /// <returns>An XspBuffer, with specific data encoded into it.</returns>
        /// <remarks>
        /// The XspBuffer returned will have the important data from the packet copied into it in this format:
        /// Length|| 4              | RawBufferLength | 4     | 1        | 12 if Protocol is TCP, 0 if UDP
        /// Data  || Source Address | Packet Data     | Ports | Protocol | TCP Info (12 bytes of TCP header after ports)
        /// </remarks>
        public XspBuffer Receive ()
        {
            if (_sock == null)
            {
                throw new RawSocketException("The socket is closed.");
            }

            while (true)
            {
                // reset _any_ep
                _any_ep.Address = IPAddress.Any;
                _any_ep.Port = 0;
                EndPoint any_ep = (EndPoint)_any_ep;

                int size = _sock.ReceiveFrom(_buffer, ref any_ep);

                // check size, if less than IP header plus UDP header, toss
                if (size < 28)
                {
                    ++_dropped_TooSmall;
                    continue;
                }

                // pull destination address from IP header
                int dest_addr = BitConverter.ToInt32(_buffer, 16);

                // not meant for us, carry on
                if (dest_addr != _spoofed_int)
                {
                    ++_dropped_NotOurIP;
                    continue;
                }

                // this shouldn't happen unless something bad happens to the packet
                int ip_ttl_len = (int)((ushort)IPAddress.NetworkToHostOrder(BitConverter.ToInt16(_buffer, 2)));

                if (ip_ttl_len != size)
                {
                    ++_dropped_SizeDoesNotMatchIPHeader;
                    continue;
                }

                // we don't handle fragmented packets
                byte flags = _buffer[6];

                if ((flags & IPHeaderMoreFragments) == IPHeaderMoreFragments)
                {
                    ++_dropped_Fragmented;
                    continue;
                }

                // pull out other fun stuffs
                int ip_hdr_len = (_buffer[0] & 0xF) * 4;
                byte protocol = _buffer[9];
                
                // only TCP and UDP
                if (protocol != ProtocolTCP && protocol != ProtocolUDP)
                {
                    ++_dropped_ProtocolNotSupported;
                    continue;
                }

                // check for a packet that is too big to fit into XSP
                if (size - ip_hdr_len > 1460)
                {
                    // could theoretically send an ICMP Fragmentation Needed packet
                    ++_dropped_TooLarge;
                    continue;
                }

                // now we are ready to copy the buffer out
                int data_offset = ip_hdr_len + (protocol == ProtocolTCP ? 20 : 8);
                int data_size = size - data_offset;

                XspBuffer xspbuff = XspBufferManager.Allocate();
                byte[] xspbytes = xspbuff.RawBuffer;

                // source IP into first 4 bytes (eventual location for XSP header)
                Buffer.BlockCopy(_buffer, 12, xspbytes, 0, 4);
                // body into the place that it will be in the XSP packet
                Buffer.BlockCopy(_buffer, data_offset, xspbytes, 4, data_size);
                // ports
                Buffer.BlockCopy(_buffer, ip_hdr_len, xspbytes, 4 + data_size, 4);
                // protocol
                xspbytes[4 + data_size + 4] = protocol;
                // if TCP, 12 byte proto-header
                if (protocol == ProtocolTCP)
                {
                    Buffer.BlockCopy(_buffer, ip_hdr_len + 4, xspbytes, 4 + data_size + 4 + 1, 12);
                }

                xspbuff.RawBufferLength = (uint)data_size;

                ++_received;
                return xspbuff;
            }
        }

        /// <summary>
        /// Sends a packet to the specified location.
        /// </summary>
        /// <param name="buffer">The packet data to send.</param>
        /// <param name="size">The length, in bytes, of the data to send.</param>
        /// <param name="endPoint">The location to send to.</param>
        public void SendTo (byte[] buffer, uint size, IPEndPoint endPoint)
        {
            if (_sock == null)
            {
                throw new RawSocketException("The socket is closed.");
            }

            int sent = _sock.SendTo(buffer, (int)size, SocketFlags.None, (EndPoint)endPoint);

            if ((uint)(sent) != size)
            {
                ++_dropped_NotSent;
            }
            else
            {
                ++_sent;
            }
        }

        /// <summary>
        /// Closes the socket.
        /// </summary>
        public void Close ()
        {
            if (_sock != null)
            {
                _sock.Close();
                _sock = null;
            }
        }

        #region XspBuffer Decoding Helpers

        /// <summary>
        /// Gets the host order source port from the RawBuffer of the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <returns>The host order port.</returns>
        public static UInt16 GetSourcePortFromXspBuffer (XspBuffer packet)
        {
            return GetPortFromXspBuffer(packet, 0);
        }

        /// <summary>
        /// Gets the host order destination port from the RawBuffer of the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <returns>The host order port.</returns>
        public static UInt16 GetDestPortFromXspBuffer (XspBuffer packet)
        {
            return GetPortFromXspBuffer(packet, 2);
        }

        /// <summary>
        /// Gets the host order port from the RawBuffer of the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <param name="offset">The offset of the port (0 is source, 2 is destination).</param>
        /// <returns>The host order port.</returns>
        private static UInt16 GetPortFromXspBuffer (XspBuffer packet, int offset)
        {
            int loc = 4 + (int)packet.RawBufferLength + offset;
            UInt16 first = (UInt16)packet.RawBuffer[loc];
            UInt16 second = (UInt16)packet.RawBuffer[loc + 1];
            return (UInt16)((first << 8) | second);
        }

        /// <summary>
        /// Gets the protocol byte from the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <returns>The protocol.</returns>
        public static byte GetProtocol (XspBuffer packet)
        {
            return packet.RawBuffer[4 + packet.RawBufferLength + 4];
        }

        /// <summary>
        /// Gets the TCP flags byte from the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <returns>The TCP flags.</returns>
        public static byte GetTCPFlags (XspBuffer packet)
        {
            return packet.RawBuffer[4 + packet.RawBufferLength + 4 + 1 + 9];
        }

        /// <summary>
        /// Gets the source IPEndPoint from the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <returns>The source IPEndPoint</returns>
        public static IPEndPoint GetSourceIPEndPoint (XspBuffer packet)
        {
            byte[] source_ip = new byte[4];
            Buffer.BlockCopy(packet.RawBuffer, 0, source_ip, 0, 4);
            return new IPEndPoint(new IPAddress(source_ip), GetSourcePortFromXspBuffer(packet));
        }

        /// <summary>
        /// Gets the offset of the TcpInfo data in the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <returns>The offset of the TcpInfo struct in the packet.</returns>
        public static uint GetTcpInfoOffset (XspBuffer packet)
        {
            return (uint)(4 + packet.RawBufferLength + 4 + 1);
        }

        /// <summary>
        /// Gets the size of the TCP header in the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <returns>The size of the TCP header in bytes.</returns>
        public static byte GetTcpHeaderSize (XspBuffer packet)
        {
            return (byte)(((packet.RawBuffer[4 + packet.RawBufferLength + 4 + 1 + 8] >> 4) & 0xF) * 4);
        }

        /// <summary>
        /// Sets the size of the TCP header in the packet.
        /// </summary>
        /// <param name="packet">An XspBuffer returned from a raw socket.</param>
        /// <param name="size">The size of the TCP header in bytes.</param>
        private static void SetTcpHeaderSize (XspBuffer packet, byte size)
        {
            uint index = 4 + packet.RawBufferLength + 4 + 1 + 8;
            byte current = packet.RawBuffer[index];
            packet.RawBuffer[index] = (byte)(((size / 4) << 4) | (current & 0xF));
        }

        /// <summary>
        /// Checks a TCP SYN connection initiating packet for an MSS, changing it if necessary.
        /// </summary>
        /// <param name="packet">The RawSocket encoded packet buffer to modify.</param>
        /// <param name="mss">The MSS value to ensure.</param>
        public static void EnsureTcpMss (XspBuffer packet, ushort mss)
        {
            // determine number of option bytes
            int option_bytes = GetTcpHeaderSize(packet) - 20;
            byte[] data = packet.RawBuffer;
            int mss_option_offset = 0;

            for (int i = 0; i < option_bytes; )
            {
                byte current = data[4 + i];

                switch (current)
                {
                    case TCPOptionEnd:
                        goto search_done;

                    case TCPOptionNoOp:
                        ++i;
                        break;

                    case TCPOptionMSS:
                        mss_option_offset = 4 + i;
                        goto search_done;

                    default:
                        i += (int)(data[4 + i + 1]);
                        break;
                }
            }

            search_done:
            if (mss_option_offset == 0)
            {
                if (option_bytes > 36)
                {
                    // should VERY rarely happen
                    throw new RawSocketException("Cannot add the MSS option because there are too many headers already.");
                }

                // we need to add the option... sigh
                // start by shifting all of the other data
                Buffer.BlockCopy(data, 4, data, 8, (int)(packet.RawBufferLength + 4 + 1 + 12));
                packet.RawBufferLength += 4;

                // set the TCP header size
                SetTcpHeaderSize(packet, (byte)(option_bytes + 4));

                // write the option data
                data[4] = TCPOptionMSS;
                data[5] = 4;
                data[6] = (byte)((mss >> 8) & 0xFF);
                data[7] = (byte)(mss & 0xFF);
            }
            else
            {
                // read current option
                ushort current = (ushort)((data[mss_option_offset + 2] << 8) | data[mss_option_offset + 3]);

                if (current > mss)
                {
                    // just change the option value
                    data[mss_option_offset + 2] = (byte)((mss >> 8) & 0xFF);
                    data[mss_option_offset + 3] = (byte)(mss & 0xFF);
                }
            }

            // we don't even send the TCP checksum to the SG, it recalculates it anyway
        }

        #endregion

        #region Raw Socket Checksum Utility

        /// <summary>
        /// Computes the ones complement sum for the given bytes.
        /// </summary>
        public static UInt16 ComputeOnesComplementSum (UInt16 carry, byte[] bytes, uint index, uint length)
        {
            UInt32 ans = (UInt32)carry;

            // round length down by one
            uint temp_len = (uint)(length & ~1);

            for (uint i = 0; i < temp_len; i += 2)
            {
                UInt32 temp = (UInt32)(bytes[index + i] << 8) | (UInt32)(bytes[index + i + 1]);
                ans += temp;
            }

            // add in last byte with padding
            if ((length & 1) == 1)
            {
                UInt32 temp = (UInt32)(bytes[index + length - 1] << 8);
                ans += temp;
            }

            // add carries down
            while ((ans & 0xFFFF0000) != 0)
            {
                ans = (ans & 0xFFFF) + (ans >> 16);
            }

            return (UInt16)ans;
        }
        
        /// <summary>
        /// Computes the UDP header checksum and writes it into the correct place.
        /// </summary>
        public static void ComputeUdpChecksum (byte[] ipHeader, uint ipHeaderOffset, byte[] udpHeader, uint udpHeaderOffset,
            byte[] udpPayload, uint udpPayloadOffset, uint udpPayloadLength, byte[] scratch)
        {
            UInt16 ans = 0;

            // first part of pseudoheader
            ans = ComputeOnesComplementSum(ans, ipHeader, ipHeaderOffset + 12, 8);

            // get length
            scratch[0] = 0;
            scratch[1] = ProtocolUDP;
            scratch[2] = udpHeader[udpHeaderOffset + 4];
            scratch[3] = udpHeader[udpHeaderOffset + 5];

            // second part of pseudoheader
            ans = ComputeOnesComplementSum(ans, scratch, 0, 4);

            // udp header, make sure checksum is 0
            udpHeader[udpHeaderOffset + 6] = 0;
            udpHeader[udpHeaderOffset + 7] = 0;
            ans = ComputeOnesComplementSum(ans, udpHeader, udpHeaderOffset, 8);

            // payload
            ans = ComputeOnesComplementSum(ans, udpPayload, udpPayloadOffset, udpPayloadLength);

            // if 1s complement would be 0, leave as 0xFFFF, otherwise, flip it
            if (ans != 0xFFFF)
            {
                ans = (UInt16)~ans;
            }

            // set checksum
            udpHeader[udpHeaderOffset + 6] = (byte)(ans >> 8);
            udpHeader[udpHeaderOffset + 7] = (byte)(ans & 0xFF);
        }

        /// <summary>
        /// Computes the TCP header checksum and writes it into the correct place.
        /// </summary>
        public static void ComputeTcpChecksum (byte[] ipHeader, uint ipHeaderOffset, byte[] tcpHeader, uint tcpHeaderOffset, uint tcpHeaderLength,
            byte[] tcpPayload, uint tcpPayloadOffset, uint tcpPayloadLength, byte[] scratch)
        {
            UInt16 ans = 0;

            // first part of pseudoheader
            ans = ComputeOnesComplementSum(ans, ipHeader, ipHeaderOffset + 12, 8);

            // compute length, put in pseudoheader
            uint total_length = tcpHeaderLength + tcpPayloadLength;
            scratch[0] = 0;
            scratch[1] = ProtocolTCP;
            scratch[2] = (byte)((total_length >> 8) & 0xFF);
            scratch[3] = (byte)(total_length & 0xFF);

            // second part of pseudoheader
            ans = ComputeOnesComplementSum(ans, scratch, 0, 4);

            // udp header, make sure checksum is 0
            tcpHeader[tcpHeaderOffset + 16] = 0;
            tcpHeader[tcpHeaderOffset + 17] = 0;
            ans = ComputeOnesComplementSum(ans, tcpHeader, tcpHeaderOffset, tcpHeaderLength);

            // payload
            ans = ComputeOnesComplementSum(ans, tcpPayload, tcpPayloadOffset, tcpPayloadLength);

            // if 1s complement would be 0, leave as 0xFFFF, otherwise, flip it
            if (ans != 0xFFFF)
            {
                ans = (UInt16)~ans;
            }

            // set checksum
            tcpHeader[tcpHeaderOffset + 16] = (byte)(ans >> 8);
            tcpHeader[tcpHeaderOffset + 17] = (byte)(ans & 0xFF);
        }

        #endregion

        #region Debug Information

        /// <summary>
        /// Gets a collection of stats from the raw socket.
        /// </summary>
        public void FillStatsCollection (ref TestThroughSG.StatsCollection stats)
        {
            stats.RawSocketDroppedTooSmall = _dropped_TooSmall;
            stats.RawSocketDroppedNotOurIP = _dropped_NotOurIP;
            stats.RawSocketDroppedSizeMismatch = _dropped_SizeDoesNotMatchIPHeader;
            stats.RawSocketDroppedFragmented = _dropped_Fragmented;
            stats.RawSocketDroppedProtocolNotSupported = _dropped_ProtocolNotSupported;
            stats.RawSocketDroppedTooLarge = _dropped_TooLarge;
            stats.RawSocketReceived = _received;
            stats.RawSocketDroppedNotSent = _dropped_NotSent;
            stats.RawSocketSent = _sent;
        }

        #endregion
    }

    /// <summary>
    /// An exception thrown by RawSocket.
    /// </summary>
    public class RawSocketException : Exception
    {
        public RawSocketException (string message) : base(message) { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TitleActivation\TitleActivation.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
//using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using System.Collections.Generic;
using System.Text;
using System.IO;

using live.common;
using live.protocol;
using live.server;
using live.client;

using xonline.common.sql.webstore;
using xonline.common.config;


namespace live.TitleActivation
{
    [TestGroup]
    public class Functionals : TestNode
    {
        [TestGroupSetup]
        public void Setup ()
        {
            live.common.Config.SetConfig(new STFConfig());

            // Try to setup NPDB with the correct settings needed to verify 
            // title activation is working.
//            Npdb npdb = new Npdb();
//            npdb.ConnectToServer(Global.DefaultNpdbSetting.ip);

//            string removeTitles = @"delete from t_multisettings where vc_value = '0xFFFF0096'
//                                    delete from t_multisettings where vc_value = '0xFFFF0095'
//                                    delete from t_multisettings where vc_value = '0xFFFF0094'
//                                    delete from t_multisettings where vc_value = '0xFFFF0093'
//                                    delete from t_multisettings where vc_value = '0xFFFF0092'";

//            string sql = @"INSERT INTO t_multisettings (vc_multisetting, vc_value) VALUES ('xbos_titleActivation_testTitles', '0xFFFF0096')
//                            INSERT INTO t_multisettings (vc_multisetting, vc_value) VALUES ('xbos_titleActivation_testTitles', '0xFFFF0095')
//                            INSERT INTO t_multisettings (vc_multisetting, vc_value) VALUES ('xbos_titleActivation_testTitles', '0xFFFF0094')
//                            INSERT INTO t_multisettings (vc_multisetting, vc_value) VALUES ('xbos_titleActivation_testTitles', '0xFFFF0093')
//                            INSERT INTO t_multisettings (vc_multisetting, vc_value) VALUES ('xbos_titleActivation_testTitles', '0xFFFF0092')";
//            int affected = npdb.IssueCommand(removeTitles);
//            Global.RO.Fatal("Removing titles if the exist. Rows affected: " + affected);

//            affected = npdb.IssueCommand(sql);
//            Global.RO.Fatal("Inserting new titles. Rows Affected: " + affected);
//            if (affected != 10)
//            {
//                Global.RO.Error("Not all titles were added to NPDB");
//            }

//            Global.RO.Fatal("Sleeping for 15 sec to allow database update");
//            Thread.Sleep(15000);
        }

        [TestCase, Description("Logs in 1 -> 4 users and verifies that they are all granted a title that has been added to t_multisettings.")]
        class P_Mainline_AllUsers_Little_Endian : TestBase
        {
            override protected void Execute ()
            {
                bool bFailed = false;

                for (int i = 0; i < 4; i++)
                {
                    // Setup the User, Nonce, and Machine
                    Random rand = new Random();
                    UInt32 Nonce = (UInt32)rand.Next();
                    Xbox360Client client = new Xbox360Client();
                    client.TitleId = 0xFFFF0096; // One of the titles added to npdb

                    // This allows us to use 1 user, then 2 users, then 3 Etc.
                    for (int j = 0; j < i + 1; j++)
                    {
                        XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
                        client.UserLoggingOn(user);

                    }

                    // Send the request
                    GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                    if (!VerifyTitleActivationResponse(response, client))
                        bFailed = true;

                    DumpUserLicenses(response.titles[0].licenseFlags);

                    // Manually verify the privileges
                    switch (i) // Number of users
                    {
                        case 0: // One User Slot 1
                            if (response.titles[0].licenseFlags != TitleActivationInfo.LicenseFlags_GrantedUser1)
                            {
                                bFailed = true;
                            }
                            else
                            {
                                Global.RO.Success("Title Privilege Users: 0");
                            }
                            break;
                        case 1: // Two users Slot 1+2
                            if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 |
                                                                    TitleActivationInfo.LicenseFlags_GrantedUser2))
                            {
                                bFailed = true;
                            }
                            else
                            {
                                Global.RO.Success("Title Privilege Users: 0+1");
                            }
                            break;
                        case 2: // Three users Slot 1+2+3
                            if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 |
                                                                    TitleActivationInfo.LicenseFlags_GrantedUser2 |
                                                                    TitleActivationInfo.LicenseFlags_GrantedUser3))
                            {
                                bFailed = true;
                            }
                            else
                            {
                                Global.RO.Success("Title Privilege Users: 0+1+2");
                            }
                            break;
                        case 3: // Four users Slot 1+2+3+4
                            if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 |
                                                                    TitleActivationInfo.LicenseFlags_GrantedUser2 |
                                                                    TitleActivationInfo.LicenseFlags_GrantedUser3))
                            {
                                bFailed = true;
                            }
                            else
                            {
                                Global.RO.Success("Title Privilege Users: 0+1+2+3");
                            }
                            break;
                    }
                }

                if (!bFailed)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Logs in 1 -> 4 users and verifies that they are all granted a title that has been added to t_multisettings.")]
        class P_Mainline_AllUsers_Big_Endian : TestBase
        {
            override protected void Execute ()
            {
                bool bFailed = false;

                for (int i = 0; i < 4; i++)
                {
                    // Setup the User, Nonce, and Machine
                    Random rand = new Random();
                    UInt32 Nonce = (UInt32)rand.Next();
                    Xbox360Client client = new Xbox360Client();
                    client.TitleId = 0xFFFF0096; // One of the titles added to npdb

                    // This allows us to use 1 user, then 2 users, then 3 Etc.
                    for (int j = 0; j < i + 1; j++)
                    {
                        XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
                        client.UserLoggingOn(user);

                    }

                    // Send the request
                    if (client.LoggedOnUsers.Count > 0)
                    {
                        GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, client.MachinePuid, Nonce, TitleActivationInfo.SIGNATUREFORMAT_BIG_ENDIAN);

                        if (!VerifyTitleActivationResponseBigEndian(response, client))
                            bFailed = true;

                        DumpUserLicenses(response.titles[0].licenseFlags);

                        // Manually verify the privileges
                        switch (i) // Number of users
                        {
                            case 0: // One User Slot 1
                                if (response.titles[0].licenseFlags != TitleActivationInfo.LicenseFlags_GrantedUser1)
                                {
                                    bFailed = true;
                                }
                                else
                                {
                                    Global.RO.Success("Title Privilege Users: 0");
                                }
                                break;
                            case 1: // Two users Slot 1+2
                                if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 |
                                                                        TitleActivationInfo.LicenseFlags_GrantedUser2))
                                {
                                    bFailed = true;
                                }
                                else
                                {
                                    Global.RO.Success("Title Privilege Users: 0+1");
                                }
                                break;
                            case 2: // Three users Slot 1+2+3
                                if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 |
                                                                        TitleActivationInfo.LicenseFlags_GrantedUser2 |
                                                                        TitleActivationInfo.LicenseFlags_GrantedUser3))
                                {
                                    bFailed = true;
                                }
                                else
                                {
                                    Global.RO.Success("Title Privilege Users: 0+1+2");
                                }
                                break;
                            case 3: // Four users Slot 1+2+3+4
                                if (response.titles[0].licenseFlags != (TitleActivationInfo.LicenseFlags_GrantedUser1 |
                                                                        TitleActivationInfo.LicenseFlags_GrantedUser2 |
                                                                        TitleActivationInfo.LicenseFlags_GrantedUser3))
                                {
                                    bFailed = true;
                                }
                                else
                                {
                                    Global.RO.Success("Title Privilege Users: 0+1+2+3");
                                }
                                break;
                        }

                    }
                }

                if (!bFailed)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Logs in 1 -> 4 users and verifies that noone is granted a title that has not been added to t_multisettings.")]
        class N_Mainline_AllUsers : TestBase
        {
            override protected void Execute ()
            {
                bool bFailed = false;

                for (int i = 0; i < 4; i++)
                {
                    // Setup the User, Nonce, and Machine
                    Random rand = new Random();
                    UInt32 Nonce = (UInt32)rand.Next();
                    Xbox360Client client = new Xbox360Client();
                    client.TitleId = 0xFFFF0097; // Not in the list of titles added to npdb

                    // This allows us to use 1 user, then 2 users, then 3 Etc.
                    for (int j = 0; j < i + 1; j++)
                    {
                        XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
                        client.UserLoggingOn(user);
                    }

                    // Send the request
                    GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                    if (!VerifyTitleActivationResponse(response, client))
                        bFailed = true;

                    DumpUserLicenses(response.titles[0].licenseFlags);

                    if (response.titles[0].licenseFlags != 0)
                    {
                        Global.RO.Error("Users: " + (i + 1));
                        bFailed = true;
                    }
                    else
                    {
                        Global.RO.Success("Users: " + (i + 1));
                    }

                }

                if (!bFailed)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Tests adams data.")]
        class P_ADAM_VERIFICATION : TestBase
        {
            override protected void Execute ()
            {
                bool bFailed = false;

                // Setup the User, Nonce, and Machine
                Random rand = new Random();
                UInt32 Nonce = 11111111;
                Xbox360Client client = new Xbox360Client();
                client.MachinePuid = 0xFA00B4E930176800;
                client.TitleId = 0xFFFF0096; // Not in the list of titles added to npdb

                XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
                user.Puid = 0x0009030C44ABA9D8;
                client.UserLoggingOn(user);

                // Send the request
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, client.MachinePuid, Nonce, TitleActivationInfo.SIGNATUREFORMAT_BIG_ENDIAN);

                if (!VerifyTitleActivationResponseBigEndian(response, client))
                    bFailed = true;

                DumpUserLicenses(response.titles[0].licenseFlags);

                if (response.titles[0].licenseFlags != TitleActivationInfo.LicenseFlags_GrantedUser1)
                {
                    Global.RO.Error("Users: 1");
                    bFailed = true;
                }
                else
                {
                    Global.RO.Success("Users: 1");
                }

                if (!bFailed)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("Verifies the the xbos_titleActivation_disableAllTitles setting works.")]
        class P_DisableAll : TestBase
        {
            protected override void Execute ()
            {
                bool bFailed = false;

                // Setup the User, Nonce, and Machine
                Random rand = new Random();
                UInt32 Nonce = (UInt32)rand.Next();
                Xbox360Client client = new Xbox360Client();
                client.TitleId = 0xFFFF0095; // Not in the list of titles added to npdb

                XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
                client.UserLoggingOn(user);

                // Send the request
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                if (!VerifyTitleActivationResponse(response, client))
                    bFailed = true;

                DumpUserLicenses(response.titles[0].licenseFlags);

                if (response.titles[0].licenseFlags != TitleActivationInfo.LicenseFlags_GrantedUser1)
                {
                    Global.RO.Error("User was not granted title privilege.");
                    bFailed = true;
                }
                else
                {
                    Global.RO.Success("It's all good in the hood, User was granted title privilege.");
                }

                // Turn off title activation and try again.
                TurnOffTitleActivation();


                // Send the request
                response = Billing.GetTitleActivationList(client, Nonce);

                if (!VerifyTitleActivationResponse(response, client))
                    bFailed = true;

                DumpUserLicenses(response.titles[0].licenseFlags);

                if (response.titles[0].licenseFlags != 0)
                {
                    Global.RO.Error("TitleActivation doesn't seem to be turned off.");
                    bFailed = true;
                }
                else
                {
                    Global.RO.Success("It's all good in the hood, User was not granted title privilege.");
                }

                // Make sure to turn title activation back on so other tests pass
                TurnOnTitleActivation();

                if (!bFailed)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("No users but requesting a title ID")]
        class N_No_Users : TestBase
        {
            override protected void Execute ()
            {
                // Setup the User, Nonce, and Machine
                bool failure = false;
                Random rand = new Random();
                UInt32 Nonce = (UInt32)rand.Next();
                Xbox360Client client = new Xbox360Client();

                client.TitleId = 0xFFFF0096;

                // Send the request
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                if (response.titles[0].licenseFlags != 0)
                {
                    Global.RO.Error("Title privilege was granted even though no users requested it.");
                    failure = true;
                }

                if (VerifyTitleActivationResponse(response, client))
                {
                    failure = true;
                }

                if (failure)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

        [TestCase, Description("A 0 Nonce passed in the request")]
        class N_Zero_Nonce : TestBase
        {
            override protected void Execute ()
            {
                bool failure = false;
                // Setup the User, Nonce, and Machine
                UInt32 Nonce = 0;
                Xbox360Client client = new Xbox360Client();

                client.TitleId = 0xFFFF0096;
                XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
                client.UserLoggingOn(user);

                // Send the request
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                DumpUserLicenses(response.titles[0].licenseFlags);
                if (!VerifyTitleActivationResponse(response, client))
                {
                    failure = true;
                }

                if (failure)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("A 0 Nonce passed in the request")]
        class N_Mismatched_Machine_PUID : TestBase
        {
            override protected void Execute ()
            {
                ResultCode = TEST_RESULTS.FAILED;
                // Setup the User, Nonce, and Machine
                UInt32 Nonce = 0;
                Xbox360Client client = new Xbox360Client();

                client.TitleId = 0xFFFF0096;
                XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
                client.UserLoggingOn(user);

                // Send the request
                try
                {
                    GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, client.MachinePuid + 1, Nonce);
                }
                catch
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }

        [TestCase, Description("A 0 TitleId passed in the request")]
        class N_Zero_TitleId : TestBase
        {
            override protected void Execute ()
            {
                bool failure = false;
                // Setup the User, Nonce, and Machine
                UInt32 Nonce = 0;
                Xbox360Client client = new Xbox360Client();

                client.TitleId = 0;
                XblUser user = CreateUser(client, XblUserTier.Silver, PassportType.Real);
                client.UserLoggingOn(user);

                // Send the request
                GetTitleActivationListResponse response = Billing.GetTitleActivationList(client, Nonce);

                if (response.titlesLength != 0)
                {
                    failure = true;
                    Global.RO.Error("Title list coming back should be empty when no title is passed.");
                }

                if (failure)
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }


        private static XblUser CreateUser ( IClient client, XblUserTier userType, PassportType passportType )
        {
            XblUserSettings settings = new XblUserSettings(userType, passportType);

            PassportUtils.CreatePassportAccounts(client, settings, true);

            XblUser user;
            uint hr = UACS.XeCreateLiveAccount(client, settings, out user);
            if (hr != 0)
            {
                throw new Exception("Failed to create user; hr = " + hr);
            }

            return user;
        }

        public static void DumpUserLicenses ( uint _licenseFlags )
        {
            Global.RO.Info("User 0: {0}",
                            (_licenseFlags & TitleActivationInfo.LicenseFlags_GrantedUser1) == TitleActivationInfo.LicenseFlags_GrantedUser1 ?
                            "Granted" : "Not Granted");
            Global.RO.Info("User 1: {0}",
                            (_licenseFlags & TitleActivationInfo.LicenseFlags_GrantedUser2) == TitleActivationInfo.LicenseFlags_GrantedUser2 ?
                            "Granted" : "Not Granted");
            Global.RO.Info("User 2: {0}",
                            (_licenseFlags & TitleActivationInfo.LicenseFlags_GrantedUser3) == TitleActivationInfo.LicenseFlags_GrantedUser3 ?
                            "Granted" : "Not Granted");
            Global.RO.Info("User 3: {0}",
                            (_licenseFlags & TitleActivationInfo.LicenseFlags_GrantedUser4) == TitleActivationInfo.LicenseFlags_GrantedUser4 ?
                            "Granted" : "Not Granted");
        }

        public static bool TurnOffTitleActivation ()
        {
            // Try to setup NPDB with the correct settings needed to verify 
            // title activation is working.
            Npdb npdb = new Npdb();
            npdb.ConnectToServer(Global.DefaultNpdbSetting.ip);

            string TurnOffActivation = @"UPDATE t_settings
                                        SET vc_value = 1
                                        WHERE vc_setting like 'xbos_titleActivation_disableAllTitles'";

            int affected = npdb.IssueCommand(TurnOffActivation);
            Global.RO.Fatal("Rows affected: " + affected);

            Global.RO.Fatal("Sleeping for 30 sec to allow database update");
            Thread.Sleep(30000);

            if (affected == 0)
            {
                Global.RO.Error("Title Activation was not turned off.");
                return false;
            }
            else
            {
                Global.RO.Success("Title Activaton was successfully turned off.");
                return true;
            }
        }

        public static bool TurnOnTitleActivation ()
        {
            // Try to setup NPDB with the correct settings needed to verify 
            // title activation is working.
            Npdb npdb = new Npdb();
            npdb.ConnectToServer(Global.DefaultNpdbSetting.ip);

            string TurnOnActivation = @"UPDATE t_settings
                                        SET vc_value = 0
                                        WHERE vc_setting like 'xbos_titleActivation_disableAllTitles'";

            int affected = npdb.IssueCommand(TurnOnActivation);
            Global.RO.Fatal("Rows affected: " + affected);

            Global.RO.Fatal("Sleeping for 30 sec to allow database update");
            Thread.Sleep(30000);

            if (affected == 0)
            {
                Global.RO.Error("Title Activation was not turned on.");
                return false;
            }
            else
            {
                Global.RO.Success("Title Activaton was successfully turned on.");
                return true;
            }
        }

        public static bool VerifyTitleActivationResponseBigEndian ( GetTitleActivationListResponse _response, Xbox360Client _client )
        {
            // Run normal verify but with big endian signature
            return VerifyTitleActivationResponse(_response, _client, TitleActivationInfo.SIGNATUREFORMAT_BIG_ENDIAN);
        }

        public static bool VerifyTitleActivationResponse ( GetTitleActivationListResponse _response, Xbox360Client _client )
        {
            return VerifyTitleActivationResponse(_response, _client, TitleActivationInfo.SIGNATUREFORMAT_LITTLE_ENDIAN);
        }

        public static bool VerifyTitleActivationResponse ( GetTitleActivationListResponse _response, Xbox360Client client, uint _signatureFormat )
        {

            string hexed = live.common.Hexer.tohex((byte[])_response.signature);

            Global.RO.Fatal(hexed);

            // Dump out the Response
            Global.RO.Info(" ");
            Global.RO.Info("[GetTitleActivationResponse]");
            Global.RO.Info("MachineId\t\t[{0:X16}]", _response.machineId);
            Global.RO.Info("Nonce    \t\t[{0}]", _response.nonce);
            Global.RO.Info("SignatureHash\t[{0}]", _response.signature.GetHashCode());
            Global.RO.Info("TitlesLength\t\t[{0}]", _response.titlesLength);
            for (int i = 0; i < _response.titlesLength; i++)
            {
                Global.RO.Info("            {0:X8} | {1}", _response.titles[i].titleId, _response.titles[i].licenseFlags);
            }
            for (int i = 0; i < 4; i++)
            {
                Global.RO.Info("            User {0}:\t [{1:X16}]", i, _response.userIds[i]);
            }
            Global.RO.Info(" ");

            // If a title ID was passed, then we should only have one in the 
            // response
            if (client.TitleId != 0)
            {
                if (_response.titlesLength != 1)
                {
                    if (client.AvailableUsers.Count != 0)
                    {
                        Global.RO.Error("Verification Error: Number of titles does not match expected. Response.TitleLegth: {0} Request: 1");
                        return false;
                    }
                }
                else
                {
                    // Verify that the title ID recieved matches the requested one.
                    if (_response.titles[0].titleId != client.TitleId)
                    {
                        Global.RO.Error("Verification Error: TitleID of response does not match requested TitleID. Response: {0}, Request: {1}");
                        return false;
                    }
                }
            }

            // Verify that the MachinePUID is correct
            if (_response.machineId != client.MachinePuid)
            {
                Global.RO.Error("Verification Error: Machine PUID of response does not match requested Machine PUID. Response: {0}, Request: {1}", _response.machineId, client.MachinePuid);
                return false;
            }

            //// Make sure the user list is the same as what we requested
            for (int i = 0; i < client.AvailableUsers.Count; i++)
            {
                if (_response.userIds[i] != client.AvailableUsers[i])
                {
                    Global.RO.Error("Verification Error: UserIDs in Request do not match UserIDs in Reply.");
                    return false;
                }
            }

            MemoryStream ms = new MemoryStream();
            BinaryWriter bw = new BinaryWriter(ms);

            if (_signatureFormat == TitleActivationInfo.SIGNATUREFORMAT_BIG_ENDIAN)
            {
                bw.Write(Revert(_response.machineId));
                for (int i = 0; i < TitleActivationInfo.MaxUserLogin; i++)
                {
                    bw.Write(Revert(_response.userIds[i]));
                }
                bw.Write(Revert(_response.nonce));
                bw.Write(Revert(_response.titlesLength));
                for (int i = 0; i < _response.titlesLength; i++)
                {
                    bw.Write(Revert(_response.titles[i].titleId));
                    bw.Write(Revert(_response.titles[i].licenseFlags));
                }
            }
            else if (_signatureFormat == TitleActivationInfo.SIGNATUREFORMAT_LITTLE_ENDIAN)
            {
                bw.Write(_response.machineId);
                for (int i = 0; i < TitleActivationInfo.MaxUserLogin; i++)
                {
                    bw.Write(_response.userIds[i]);
                }
                bw.Write(_response.nonce);
                bw.Write(_response.titlesLength);
                for (int i = 0; i < _response.titlesLength; i++)
                {
                    bw.Write(_response.titles[i].titleId);
                    bw.Write(_response.titles[i].licenseFlags);
                }
            }

            if (ServerTestFramework.Utilities.SignatureUtil.VerifySignature(ms.ToArray(), _response.signature) == false)
            {
                Global.RO.Error("Verification Erro: Signature check failed.");
                return false;
            }
            // If we made it through all the checks, the signature and data has all been verified.
            return true;
        }
        public static UInt16 Revert ( UInt16 x )
        {
            return
                (UInt16)(((UInt16)(x & 0x00FF) << 8) |
                         ((UInt16)(x & 0xFF00) >> 8));
        }

        public static UInt32 Revert ( UInt32 x )
        {
            return
                 ((x & 0x000000FF) << 24) |
                 ((x & 0x0000FF00) << 8) |
                 ((x & 0x00FF0000) >> 8) |
                 ((x & 0xFF000000) >> 24);
        }

        public static UInt64 Revert ( UInt64 x )
        {
            return
                ((UInt64)Revert((UInt32)(x >> 32))) |
                (((UInt64)Revert((UInt32)(x & 0xFFFFFFFF))) << 32);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TokenDieHard\CheckPValues.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="CheckPValues.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to check the p-values in the diehard output
// </summary>
//-----------------------------------------------------------------------
using System;
using System.Text.RegularExpressions;

using ServerTestFramework;

namespace Test.TokenDieHard
{
    /// <summary>
    /// Provides access to check the p-values in the diehard output
    /// 
    /// Examine the DieHard output and validate the p-values are in the expected range (not 0.000000 or 1.000000)
    /// 
    /// </summary>
    public class CheckPValues
    {
        /// <summary>
        /// failCount is the number of failed p-values
        /// </summary>
        private int failCount;

        /// <summary>
        /// output is the output from the diehard tests
        /// </summary>
        string output;

        /// <summary>
        /// Initializes a new instance of the CheckPValues class
        /// </summary>
        /// <param name="output">The output from the diehard tests</param>
        public CheckPValues(string output)
        {
            this.output = output;
        }

        /// <summary>
        /// Gets the number of failed p-values
        /// </summary>
        public int FailCount
        {
            get { return this.failCount; }
        }

        /// <summary>
        /// Run the specified p-value check
        /// 
        /// Get all of the p-values from the output and check that its value is in the expected range
        /// 
        /// </summary>
        public void Run()
        {
            // Find all matches of the standard p-value output
            CheckStandardPValue();

            // Find all matches for the BINARY RANK TEST for 6x8 matrices 
            BinaryRank6x8();

            // Find all matches for the OPSO, OQSO and DNA tests
            OpsoOqsoDna();

            // Find all matches for the COUNT-THE-1's TEST on a stream of bytes
            CountThe1sStream();

            // Find all matches for the COUNT-THE-1's TEST for specific bytes
            CountThe1sSpecific();

            // Find all matches for the RUNS test
            RunsTest();

            // Find all matches for the CRAPS TEST
            CrapsTest();
        }

        /// <summary>
        /// Given the regex expression, find all matches
        ///   For each match, get the p-value
        ///   Check the p-value is not 0.000000 or 1.000000
        ///     If so, something failed BIG
        /// </summary>
        /// <param name="regexs"></param>
        private void CheckPValue(string[] regexs)
        {
            foreach (string regex in regexs)
            {
                // find the string
                MatchCollection matchCollection = Regex.Matches(this.output, regex);

                foreach (Match match in matchCollection)
                {
                    // get the p-value
                    double pValue = Convert.ToDouble(match.Groups[1].Value);

                    // check the p-value
                    if ((0.000000 == pValue) || (1.000000 == pValue))
                    {
                        this.failCount++;
                        Global.RO.Error("pValue failed BIG");
                        Global.RO.Error(match.Groups[0].Value);
                    }
                }
            }
        }

        /// <summary>
        /// Find all matches for the BINARY RANK TEST for 6x8 matrices
        /// </summary>
        private void BinaryRank6x8()
        {
            string[] regexs = { @"p=1-exp\(-SUM/2\)= ([\d\s]{0,1}.\d{4,6})" };

            CheckPValue(regexs);
        }

        /// <summary>
        /// Find all matches (and variants) of
        ///   p-value=0.000000
        /// This is the standard output for most tests
        /// </summary>
        private void CheckStandardPValue()
        {
            string[] regexs = { @"p-value[=:]{0,1} ([\d\s]{0,1}.\d{4,6})" };

            CheckPValue(regexs);
        }

        /// <summary>
        /// Find all matches for the COUNT-THE-1's TEST for specific bytes
        /// </summary>
        private void CountThe1sSpecific()
        {
            string[] regexs = { @"          bits [\d\s]{2,2} to [\d\s]{8,8}.[-\d\s]{9,9}.[\d\s]{8,8} ([\d\s]{0,1}.\d{4,6})" };

            CheckPValue(regexs);
        }

        /// <summary>
        /// Find all matches for the COUNT-THE-1's TEST on a stream of bytes
        /// </summary>
        private void CountThe1sStream()
        {
            string[] regexs = { @"byte stream for tokenDieHard [\d\s]{8,8}.[-\d\s]{9,9}.[\d\s]{8,8} ([\d\s]{0,1}.\d{4,6})" };

            CheckPValue(regexs);
        }

        /// <summary>
        /// Find all matches for the CRAPS TEST
        /// </summary>
        private void CrapsTest()
        {
            string[] regexs = { @"               p-value for no. of wins: ([\d\s]{0,1}.\d{4,6})",
                                @"               p-value for throws/game: ([\d\s]{0,1}.\d{4,6})" };

            CheckPValue(regexs);
        }

        /// <summary>
        /// Find all matches for the OPSO, OQSO and DNA tests
        /// </summary>
        private void OpsoOqsoDna()
        {
            string[] regexs = { @"   OPSO for tokenDieHard    using bits [\s\d]{2,2} to [\s\d]{2,2} [\d\s]{13,13} [-\d\s]{2,2}.\d{3,3} ([\d\s]{0,1}.\d{4,6})",
                                @"   OQSO for tokenDieHard    using bits [\s\d]{2,2} to [\s\d]{2,2} [\d\s]{13,13} [-\d\s]{2,2}.\d{3,3} ([\d\s]{0,1}.\d{4,6})",
                                @"    DNA for tokenDieHard    using bits [\s\d]{2,2} to [\s\d]{2,2} [\d\s]{13,13} [-\d\s]{2,2}.\d{3,3} ([\d\s]{0,1}.\d{4,6})" };

            CheckPValue(regexs);
        }

        /// <summary>
        /// Find all matches for the RUNS test
        /// </summary>
        private void RunsTest()
        {
            string[] regexs = { @"      runs up; ks test for 10 p's: ([\d\s]{0,1}.\d{4,6})",
                                @"    runs down; ks test for 10 p's: ([\d\s]{0,1}.\d{4,6})" };

            CheckPValue(regexs);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TokenDieHard\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TokenDieHard\Main.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="Main.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   a template for creating STF test cases
// </summary>
//-----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text.RegularExpressions;
using xonline.common.token;

using ServerTestFramework;

namespace Test.TokenDieHard
{
    /// <summary>
    /// The Test Group - it contains all test cases specified herein
    ///   MainTestGroup
    ///     P_MainTestCase
    /// For more information on test attributes: http://xblwiki/default.aspx/XboxLive/TestTagging.html
    /// </summary>
    [TestGroup, Owner("yuanfeiw"), TestCasePriority(2), TestFrequency("Regression"), EnvRequirement(""), Description("Verify Token Generation Algorithm using DieHard Battery of Tests of Randomness")]
    public class MainTestGroup : TestNode
    {
        /// <summary>
        /// charSet is the set of characters valid for a token
        /// </summary>
        const string charSet = "234679CDFGHJKMPQRTVWXY";

        /// <summary>
        /// dictionaryCharSet is a collection to map a token character to an integer
        ///   token char '2' =  0
        ///   token char '3' =  1
        ///   token char '4' =  2
        ///   token char '6' =  3
        ///   token char '7' =  4
        ///   token char '9' =  5
        ///   token char 'C' =  6
        ///   token char 'D' =  7
        ///   token char 'F' =  8
        ///   token char 'G' =  9
        ///   token char 'H' = 10
        ///   token char 'J' = 11
        ///   token char 'K' = 12
        ///   token char 'M' = 13
        ///   token char 'P' = 14
        ///   token char 'Q' = 15
        ///   token char 'R' = 16
        ///   token char 'T' = 17
        ///   token char 'V' = 18
        ///   token char 'W' = 19
        ///   token char 'X' = 20
        ///   token char 'Y' = 21
        ///   ...
        /// </summary>
        static Dictionary<char, int> dictionaryCharSet = new Dictionary<char, int>();

        /// <summary>
        /// dieHardDirectory is the directory to the diehard tests and files
        /// </summary>
        const string dieHardDirectory = "DieHard";

        /// <summary>
        /// dieHardPath is the path to the diehard tests and files
        /// </summary>
        string dieHardPath;

        /// <summary>
        /// fileNameIn is the file name for input to diehard
        /// </summary>
        const string fileNameIn = "tokenDieHard";

        /// <summary>
        /// fileNameOut is the file name for output from diehard
        /// </summary>
        const string fileNameOut = "tokenDieHard.o";

        /// <summary>
        /// tokenCount is the number of tokens to generate;
        /// </summary>
        const int tokenCount = 2000000;

        /// <summary>
        /// tokensPerSecondGoal is the goal for number of tokens generated per second
        /// </summary>
        const int tokensPerSecondGoal = 1400;

        /// <summary>
        /// This setup function is called once after this TestGroup is instantiated
        /// Used to setup any requirements for all test cases in this test group
        ///
        /// Build the collection to map a token character to an integer
        ///
        /// Get the path to the DieHard executables - [current directory]\DieHard
        ///
        /// </summary>
        [TestGroupSetup]
        public void Setup()
        {
            // build the collection to map the token character to the integer
            for (int index = 0; index < charSet.Length; index++)
            {
                dictionaryCharSet[charSet[index]] = index;
            }

            Assembly assembly = Assembly.GetExecutingAssembly();
            this.dieHardPath = Path.Combine(Path.GetDirectoryName(assembly.Location), dieHardDirectory);
        }

        /// <summary>
        /// This cleanup function is called once after all test cases have completed
        /// Used to cleanup after all test cases in this test group
        /// </summary>
        [TestGroupTearDown]
        public void Shutdown()
        {
        }

        /// <summary>
        /// A Positive Test Case
        ///
        /// Generate the tokens to a file
        ///
        /// Calculate the tokens generated per second and validate that it exceeds expectations (1400 tokens per second)
        ///
        /// Run DieHard against the tokens file
        /// Get the output from DieHard
        ///
        /// Examine the DieHard output and validate the p-values are in the expected range
        ///
        /// </summary>
        [TestCase, Description("Verify Token Generation Algorithm using DieHard Battery of Tests of Randomness")]
        public void P_MainTestCase()
        {
            // get the start time
            DateTime dateTimeStart = DateTime.Now;

            // generate tokens
            Global.RO.Info("Generating tokens...");

            // generate the tokens
            GenerateTokens();

            // get the end time
            DateTime dateTimeEnd = DateTime.Now;
            TimeSpan elapsedTime = dateTimeEnd - dateTimeStart;

            Global.RO.Info("Elapsed Time: " + elapsedTime);

            // run diehard tests
            Global.RO.Info("Running DieHard...");

            // run diehard tests
            RunDieHard runDieHard = new RunDieHard(this.dieHardPath, fileNameIn, fileNameOut);
            runDieHard.Run();

            // check for an error code
            if (0 != runDieHard.ExitCode)
            {
                throw new UnexpectedTestResultException(String.Format("Unexpected exit code {0} from DieHard", runDieHard.ExitCode));
            }

            // check output
            Global.RO.Info("Checking Output...");

            // parse the output for p values
            CheckPValues checkPValues = new CheckPValues(runDieHard.Output);
            checkPValues.Run();

            // check for fail count
            if (0 != checkPValues.FailCount)
            {
                throw new UnexpectedTestResultException("Bad p-values from DieHard");
            }

            // calculate the tokens per second
            int tokensPerSecond = tokenCount / elapsedTime.Seconds;

            Global.RO.Info("Tokens Per Second: " + tokensPerSecond);

            if (tokensPerSecondGoal > tokensPerSecond)
            {
                throw new UnexpectedTestResultException(String.Format("Expected at least {0} Tokens Per Second", tokensPerSecondGoal));
            }

            Global.RO.Info("Done");
        }

        /// <summary>
        /// Generate the tokens to a file
        ///
        /// Generate a token, which will be a string in the format "22222-33333-44444-66666-7777N"
        /// Strip the '-' characters yielding a string "222223333344444666667777N"
        /// Split the token into two 12 character strings, high and low: "222223333344" and "444666667777"
        /// Convert the 12 character string into a number
        ///   Multiple the existing number by 24
        ///     We have 24 possible integers so it is a base24.
        ///     Multiple by 24 to set the correct significance
        ///   Get the next token character and map it to an integer
        ///   Add the integer value to the number
        ///   Repeat until all 12 characters have been consumed
        ///   This will yield two 55 bit numbers: 199411826 (0x000000000BE2C872) and 3175797246955880 (0x000B485EEAC89168)
        /// Write the low 6 bytes of each number to file
        ///   Cannot use the high 2 bytes since the number is less then 55 bits
        ///   Doing so would cause extra zeros to be written to file and cause DieHard to report failures
        ///   This will yield 00000BE2C872485EEAC89168
        ///
        /// This basically reverses the logic of TokenGenerator
        ///   Generate a random sequence of bytes
        ///   Convert to two UInt64 numbers
        ///   Convert to base24
        ///   Convert each integer of base24 number to token character
        /// If the TokenGenerator algorithm ever changes, this test logic probably needs to change
        ///
        /// </summary>
        private void GenerateTokens()
        {
            // open the binary stream for writing
            Global.RO.Info("Opening binary stream {0} for writing...", fileNameIn);

            using (FileStream fileStream = File.Open(Path.Combine(this.dieHardPath, fileNameIn), FileMode.Create, FileAccess.Write, FileShare.None))
            {
                using (BinaryWriter binaryWriter = new BinaryWriter(fileStream))
                {
                    // write the specified number of tokens
                    for (int tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++)
                    {
                        // generate the token and strip the dashes
                        string token = TokenGenerator.GenerateToken().Replace("-", String.Empty);

                        // split the token into two 12 character strings: high and low
                        // convert each 12 character string into a number
                        // this number will be 55 bits
                        UInt64 high = 0;
                        UInt64 low = 0;

                        for (int wedgeIndex = 0; wedgeIndex < 12; wedgeIndex++)
                        {
                            high *= (uint)charSet.Length;
                            high += (UInt64)dictionaryCharSet[token[wedgeIndex]];
                        }

                        for (int wedgeIndex = 12; wedgeIndex < 24; wedgeIndex++)
                        {
                            low *= (uint)charSet.Length;
                            low += (UInt64)dictionaryCharSet[token[wedgeIndex]];
                        }

                        // write the low 6 bytes of the high number
                        // cannot use the high 2 bytes since the number is < 55 bits
                        for (int index = 0; index < 6; index++)
                        {
                            binaryWriter.Write((byte)(high >> (8 * index)));
                        }

                        // write the low 6 bytes of the low number
                        // cannot use the high 2 bytes since the number is < 55 bits
                        for (int index = 0; index < 6; index++)
                        {
                            binaryWriter.Write((byte)(low >> (8 * index)));
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TokenImportTest\TokenImportTest.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.ClientTools;
using ServerTestFramework.Utilities;
using System.IO;

namespace TokenImportTest {

    [TestGroup]
    public class TokenImportWrap : TestNode {
        //
        [TestCase]
        class RunExistingAutomation : TestBase {
            override protected void Execute() {
                //call out to existing TokenImport.
                string pathToTestApp = Path.GetFullPath("..\\tools\\TokenImportTest\\TokenImportTest.exe");
                string pathToApp = Path.GetFullPath("..\\..\\tools\\tokenimport\\tokenimport.exe");
                string pathToSample = Path.GetFullPath("Suites\\TokenImportTestSampleTokens.txt");
                //the tool doesn't like paths.  We'll have to do this the hard way:copying
                //everything to this directory and then clearing it up afterwards.
                string testAppName = "TokenImportTest.exe";
                string appName = "tokenimport.exe";
                string sampleName = "TokenImportTestSampleTokens.txt";
                string offerid = "0xfffe07d1000000b1";  //test tool is finicky about this too.  Must
                                                        //be all lowercase.

                Global.RO.Info("Copying files to local directory...");
                if (!File.Exists(testAppName)) File.Copy(pathToTestApp, testAppName);
                if (!File.Exists(appName)) File.Copy(pathToApp, appName);
                if (!File.Exists(sampleName)) File.Copy(pathToSample, sampleName);
                
                //STOPPED HERE.  Add minseq, maxseq, find actual token file or generate your own.
                int minseq=5;
                int maxseq=95;
                
                ProcessWrapper TestApp = new ProcessWrapper("TokenImportTest", testAppName);
                //grep for failure, set result code appropriately.
                TestApp.Run(
                    " /tokenfile:" + sampleName +
                    " /minSeq:" + minseq +
                    " /maxSeq:" + maxseq + 
                    " /offerid:" + offerid);
                Global.RO.Info(TestApp.Output);
                if ((TestApp.Output.IndexOf("FAILED") != -1) ||
                    (TestApp.Output.IndexOf("NOT_EXECUTED") != -1)) {
                    //we have a failed test, report.
                    Global.RO.Error("Error or unexecuted test found in output!  Check output for details.");
                    ResultCode = TEST_RESULTS.FAILED;
                } else {
                    Global.RO.Success("All tests pass.");
                    ResultCode = TEST_RESULTS.PASSED;
                }
                //cleanup
                File.Delete(testAppName);
                File.Delete(appName);
                File.Delete(sampleName);
            }


        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\MultiProp.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace xonline.server.webcache.toolsmgmt.test.dvt
{
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class MultiProp : TestNode
    {
        /// <summary>
        /// 3 XLAST+PGNs submission that should succeed in parallel.
        /// </summary>
        [TestCase, StressTest]
        public class MultiAutopropXlast_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                int totalJobs = 3;
                int jobIter = 0;
                ulong[] workIds = new ulong[totalJobs];
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    workIds[jobIter] = BeginWork(titleIDs[jobIter], 1);
                    _report.Debug("JobID{0}: {1}", jobIter, workIds[jobIter]);
                    //  Copy files to 'fake' staging directory
                    PropWorkFile(titleIDs[jobIter].ToString() + ".xlast", workIds[jobIter].ToString());
                    PropWorkFile("itembox.png", workIds[jobIter].ToString());
                    PropWorkFile("0xFFFFFFFFFFFFFFFF.PNG", workIds[jobIter].ToString());
                }

                //  Tell widget to start doing work
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    // The working directory is the workId
                    WorkFilesReady(workIds[jobIter], workIds[jobIter].ToString());
                }

                //  Get the results
                int[] returnCodes = new int[totalJobs];
                string[] outputs = new string[totalJobs];
                WaitForWorkCompleted(workIds, ref returnCodes, ref outputs);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    ValueCheck.IsTrue(returnCodes[jobIter] == 0, "GetWorkStatusResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", outputs[jobIter].Length);
                    if (_titleProppedDict.ContainsKey(titleIDs[jobIter]) == false)
                    {
                        _titleProppedDict.Add(titleIDs[jobIter], true);
                    }
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 3 content submission that should succeed in parallel.
        /// </summary>
        [TestCase, StressTest]
        public class MultiAutopropContent_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                int totalJobs = 3;
                int jobIter = 0;
                ulong[] workIds = new ulong[totalJobs];
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    PropTitle(titleIDs[jobIter], false, titleIDs[jobIter].ToString() + ".xlast", "itembox.png", "0xffffffffffffffff.png");

                    workIds[jobIter] = BeginWork(titleIDs[jobIter], 3);
                    _report.Debug("JobID{0}: {1}", jobIter, workIds[jobIter]);

                    //  Copy files to 'fake' staging directory
                    PropWorkFile(titleIDs[jobIter].ToString() + "01000001.cab", workIds[jobIter].ToString());
                    PropWorkFile(titleIDs[jobIter].ToString() + "01000001.offer", workIds[jobIter].ToString());
                    PropWorkFile("0xffffffffffffffff.png", workIds[jobIter].ToString());
                }

                //  Tell widget to start doing work
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    // The working directory is the workId
                    WorkFilesReady(workIds[jobIter], workIds[jobIter].ToString());
                }

                //  Get the results
                int[] returnCodes = new int[totalJobs];
                string[] outputs = new string[totalJobs];
                WaitForWorkCompleted(workIds, ref returnCodes, ref outputs);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    ValueCheck.IsTrue(returnCodes[jobIter] == 0, "GetWorkStatusResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", outputs[jobIter].Length);
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        /// <summary>
        /// 3 content submission that should succeed in parallel along with 2 xlast.
        /// </summary>
        [TestCase, StressTest]
        public class MultiAutopropXlastContent_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                int jobIter = 0;
                int contentJobs = 3;
                int totalJobs = 5;
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";
                titleIDs[3] = "ffffab2c";
                titleIDs[4] = "ffffab30";

                ulong[] workIds = new ulong[totalJobs];
                for (jobIter = 0; jobIter < contentJobs; jobIter++)
                {
                    PropTitle(titleIDs[jobIter], false, titleIDs[jobIter].ToString() + ".xlast", "itembox.png", "0xffffffffffffffff.png");

                    workIds[jobIter] = BeginWork(titleIDs[jobIter], 3);
                    _report.Debug("JobID{0}: {1}", jobIter, workIds[jobIter]);

                    //  Copy files to 'fake' staging directory
                    PropWorkFile(titleIDs[jobIter].ToString() + "01000001.cab", workIds[jobIter].ToString());
                    PropWorkFile(titleIDs[jobIter].ToString() + "01000001.offer", workIds[jobIter].ToString());
                    PropWorkFile("0xffffffffffffffff.png", workIds[jobIter].ToString());
                }
                for (jobIter = contentJobs; jobIter < totalJobs; jobIter++)
                {
                    workIds[jobIter] = BeginWork(titleIDs[jobIter], 1);
                    _report.Debug("JobID{0}: {1}", jobIter, workIds[jobIter]);

                    //  Copy files to 'fake' staging directory
                    PropWorkFile(titleIDs[jobIter].ToString() + ".xlast", workIds[jobIter].ToString());
                    PropWorkFile("itembox.png", workIds[jobIter].ToString());
                    PropWorkFile("0xFFFFFFFFFFFFFFFF.PNG", workIds[jobIter].ToString());
                }

                //  Tell widget to start doing work
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    WorkFilesReady(workIds[jobIter], workIds[jobIter].ToString());
                }

                //  Get the results
                int[] returnCodes = new int[totalJobs];
                string[] outputs = new string[totalJobs];
                WaitForWorkCompleted(workIds, ref returnCodes, ref outputs);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    ValueCheck.IsTrue(returnCodes[jobIter] == 0, "GetWorkStatusResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", outputs[jobIter].Length);
                }

                for (jobIter = contentJobs; jobIter < totalJobs; jobIter++)
                {
                    if (_titleProppedDict.ContainsKey(titleIDs[jobIter]) == false)
                    {
                        _titleProppedDict.Add(titleIDs[jobIter], true);
                    }
                }

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, StressTest]
        public class MultiLiveTitle_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                int jobIter = 0;
                int totalJobs = 5;
                long[] jobId = new long[totalJobs];
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";
                titleIDs[3] = "ffffab2c";
                titleIDs[4] = "ffffab30";

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    string xlastFilename = titleIDs[jobIter].ToString() + ".xlast";
                    jobId[jobIter] = _service.CreateJob("LiveTitle job " + jobIter.ToString(), out jobInfo);
                    PropWorkFile(xlastFilename, jobId[jobIter].ToString());
                    PropWorkFile("itembox.png", jobId[jobIter].ToString());
                    PropWorkFile("0xffffffffffffffff.png", jobId[jobIter].ToString());
                    _report.Info("JobId: {0}", jobId[jobIter]);

                    actionInfo = RunLiveTitleDefault(jobId[jobIter], titleIDs[jobIter], xlastFilename);
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    actionInfo = RunLiveTitleDeploy(jobId[jobIter], titleIDs[jobIter], xlastFilename);
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);
                }

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    int execResult = _service.ExecuteJob(jobId[jobIter]);
                    _report.Info("ExecuteJob() on Job[{0}] returned : {1}", jobIter, execResult);
                }

                //Wait for complete
                JobState[] js = WaitForJobsCompleted(jobId);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _report.Success("JobId " + jobIter.ToString() + " " + js[jobIter].ToString());

                    ActionResult result = _service.GetActionResult(jobId[jobIter], 0);
                    _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                    result = _service.GetActionResult(jobId[jobIter], 1);
                    _report.Info("ReturnCode Action 2: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                    if (_titleProppedDict.ContainsKey(titleIDs[jobIter]) == false)
                    {
                        _titleProppedDict.Add(titleIDs[jobIter], true);
                    }
                }

                ResultCode = TEST_RESULTS.PASSED;

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _service.CleanupJob((ulong)jobId[jobIter]);
                }
            }
        }

        [TestCase, StressTest]
        public class MultiLiveStats_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                int jobIter = 0;
                int totalJobs = 5;
                long[] jobId = new long[totalJobs];
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";
                titleIDs[3] = "ffffab2c";
                titleIDs[4] = "ffffab30";

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    string xlastFilename = titleIDs[jobIter].ToString() + ".xlast";
                    PropLiveTitleOnly(titleIDs[jobIter], false, xlastFilename, "itembox.png", "0xffffffffffffffff.png");
                }

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    jobId[jobIter] = _service.CreateJob("LiveStats job " + jobIter.ToString(), out jobInfo);
                    _report.Info("JobId: {0}", jobId[jobIter]);

                    actionInfo = RunLiveStatsDeploy(jobId[jobIter], titleIDs[jobIter]);
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);
                }

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    int execResult = _service.ExecuteJob(jobId[jobIter]);
                    _report.Info("ExecuteJob() on Job[{0}] returned : {1}", jobIter, execResult);
                }

                //Wait for complete
                JobState[] js = WaitForJobsCompleted(jobId);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _report.Success("JobId " + jobIter.ToString() + " " + js[jobIter].ToString());

                    ActionResult result = _service.GetActionResult(jobId[jobIter], 0);
                    _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);
                }

                ResultCode = TEST_RESULTS.PASSED;

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _service.CleanupJob((ulong)jobId[jobIter]);
                }
            }
        }

        [TestCase, StressTest]
        public class MultiLiveMatch_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                int jobIter = 0;
                int totalJobs = 5;
                long[] jobId = new long[totalJobs];
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";
                titleIDs[3] = "ffffab2c";
                titleIDs[4] = "ffffab30";

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    string xlastFilename = titleIDs[jobIter].ToString() + ".xlast";
                    PropLiveTitleOnly(titleIDs[jobIter], false, xlastFilename, "itembox.png", "0xffffffffffffffff.png");
                }

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    jobId[jobIter] = _service.CreateJob("LiveMatch job " + jobIter.ToString(), out jobInfo);
                    _report.Info("JobId: {0}", jobId[jobIter]);

                    actionInfo = RunLiveMatchDeploy(jobId[jobIter], titleIDs[jobIter]);
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);
                }

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    int execResult = _service.ExecuteJob(jobId[jobIter]);
                    _report.Info("ExecuteJob() on Job[{0}] returned : {1}", jobIter, execResult);
                }

                //Wait for complete
                JobState[] js = WaitForJobsCompleted(jobId);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _report.Success("JobId " + jobIter.ToString() + " " + js[jobIter].ToString());

                    ActionResult result = _service.GetActionResult(jobId[jobIter], 0);
                    _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);
                }

                ResultCode = TEST_RESULTS.PASSED;

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _service.CleanupJob((ulong)jobId[jobIter]);
                }
            }
        }

        [TestCase, StressTest]
        public class MultiLiveContent_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                int jobIter = 0;
                int totalJobs = 3;
                long[] jobId = new long[totalJobs];
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    string xlastFilename = titleIDs[jobIter].ToString() + ".xlast";
                    PropLiveTitleOnly(titleIDs[jobIter], false, xlastFilename, "itembox.png", "0xffffffffffffffff.png");
                }

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    string offerID = titleIDs[jobIter].ToString() + "01000001";
                    jobId[jobIter] = _service.CreateJob("LiveTitle job " + jobIter.ToString(), out jobInfo);
                    PropWorkFile(offerID + ".cab", jobId[jobIter].ToString());
                    PropWorkFile(offerID + ".offer", jobId[jobIter].ToString());
                    PropWorkFile("0xffffffffffffffff.png", jobId[jobIter].ToString());
                    _report.Info("JobId: {0}", jobId[jobIter]);

                    actionInfo = RunLiveContentBuild(jobId[jobIter], titleIDs[jobIter], offerID + ".cab", offerID + ".offer", offerID);
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    actionInfo = RunLiveOfferProp(jobId[jobIter], titleIDs[jobIter], offerID + ".offer");
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);
                }

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    int execResult = _service.ExecuteJob(jobId[jobIter]);
                    _report.Info("ExecuteJob() on Job[{0}] returned : {1}", jobIter, execResult);
                }

                //Wait for complete
                JobState[] js = WaitForJobsCompleted(jobId);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _report.Success("JobId " + jobIter.ToString() + " " + js[jobIter].ToString());

                    ActionResult result = _service.GetActionResult(jobId[jobIter], 0);
                    _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                    result = _service.GetActionResult(jobId[jobIter], 1);
                    _report.Info("ReturnCode Action 2: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);
                }

                ResultCode = TEST_RESULTS.PASSED;

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _service.CleanupJob((ulong)jobId[jobIter]);
                }
            }
        }

        /// <summary>
        /// 3 content submission that should succeed in parallel along with 2 xlast.
        /// </summary>
        [TestCase, StressTest]
        public class MultiLiveToolsXlastContent_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                int jobIter = 0;
                int contentJobs = 3;
                int totalJobs = 5;
                long[] jobId = new long[totalJobs];
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";
                titleIDs[3] = "ffffab2c";
                titleIDs[4] = "ffffab30";

                for (jobIter = 0; jobIter < contentJobs; jobIter++)
                {
                    string xlastFilename = titleIDs[jobIter].ToString() + ".xlast";
                    PropLiveTitleOnly(titleIDs[jobIter], false, xlastFilename, "itembox.png", "0xffffffffffffffff.png");
                }

                // Create Content Jobs
                for (jobIter = 0; jobIter < contentJobs; jobIter++)
                {
                    string offerID = titleIDs[jobIter].ToString() + "01000001";
                    jobId[jobIter] = _service.CreateJob("LiveTitle job " + jobIter.ToString(), out jobInfo);
                    PropWorkFile(offerID + ".cab", jobId[jobIter].ToString());
                    PropWorkFile(offerID + ".offer", jobId[jobIter].ToString());
                    PropWorkFile("0xffffffffffffffff.png", jobId[jobIter].ToString());
                    _report.Info("JobId: {0}", jobId[jobIter]);

                    actionInfo = RunLiveContentBuild(jobId[jobIter], titleIDs[jobIter], offerID + ".cab", offerID + ".offer", offerID);
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    actionInfo = RunLiveOfferProp(jobId[jobIter], titleIDs[jobIter], offerID + ".offer");
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);
                }
                // Create XLast Jobs
                for (jobIter = contentJobs; jobIter < totalJobs; jobIter++)
                {
                    string xlastFilename = titleIDs[jobIter].ToString() + ".xlast";
                    jobId[jobIter] = _service.CreateJob("LiveTitle job " + jobIter.ToString(), out jobInfo);
                    PropWorkFile(xlastFilename, jobId[jobIter].ToString());
                    PropWorkFile("itembox.png", jobId[jobIter].ToString());
                    PropWorkFile("0xffffffffffffffff.png", jobId[jobIter].ToString());
                    _report.Info("JobId: {0}", jobId[jobIter]);
                    // LiveTitle Default
                    actionInfo = RunLiveTitleDefault(jobId[jobIter], titleIDs[jobIter], xlastFilename);
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("Action 1 rank: {0}", rank);
                    // LiveTitle Deploy
                    actionInfo = RunLiveTitleDeploy(jobId[jobIter], titleIDs[jobIter], xlastFilename);
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("Action 2 rank: {0}", rank);
                    // LiveStats
                    actionInfo = RunLiveStatsDeploy(jobId[jobIter], titleIDs[jobIter]);
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("Action 3 rank: {0}", rank);
                    // LiveMatch
                    actionInfo = RunLiveMatchDeploy(jobId[jobIter], titleIDs[jobIter]);
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("Action 4 rank: {0}", rank);
                }

                //  Tell widget to start doing work
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    int execResult = _service.ExecuteJob(jobId[jobIter]);
                    _report.Info("ExecuteJob() on Job[{0}] returned : {1}", jobIter, execResult);
                }

                //Wait for complete
                JobState[] js = WaitForJobsCompleted(jobId);

                for (jobIter = 0; jobIter < contentJobs; jobIter++)
                {
                    _report.Success("JobId " + jobIter.ToString() + " " + js[jobIter].ToString());

                    ActionResult result = _service.GetActionResult(jobId[jobIter], 0);
                    _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                    result = _service.GetActionResult(jobId[jobIter], 1);
                    _report.Info("ReturnCode Action 2: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);
                }
                for (jobIter = contentJobs; jobIter < totalJobs; jobIter++)
                {
                    _report.Success("JobId " + jobIter.ToString() + " " + js[jobIter].ToString());

                    ActionResult result = _service.GetActionResult(jobId[jobIter], 0);
                    _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                    result = _service.GetActionResult(jobId[jobIter], 1);
                    _report.Info("ReturnCode Action 2: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                    result = _service.GetActionResult(jobId[jobIter], 2);
                    _report.Info("ReturnCode Action 3: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                    result = _service.GetActionResult(jobId[jobIter], 3);
                    _report.Info("ReturnCode Action 4: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                    if (_titleProppedDict.ContainsKey(titleIDs[jobIter]) == false)
                    {
                        _titleProppedDict.Add(titleIDs[jobIter], true);
                    }
                }

                ResultCode = TEST_RESULTS.PASSED;

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _service.CleanupJob((ulong)jobId[jobIter]);
                }
            }
        }

        [TestCase, StressTest]
        public class MultiDirCXblob_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                int jobIter = 0;
                int totalJobs = 20;
                long[] jobId = new long[totalJobs];

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    jobId[jobIter] = _service.CreateJob("MultiDirCXblob job " + jobIter.ToString(), out jobInfo);
                    PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId[jobIter].ToString());
                    _report.Info("JobId: {0}", jobId[jobIter]);

                    actionInfo = CreateDirCdriveAction(jobId[jobIter]);
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    actionInfo = CreateTypeOfferAction(jobId[jobIter], "FFFE07F100700001wrongtitle.offer");
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);
                }

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    int execResult = _service.ExecuteJob(jobId[jobIter]);
                    _report.Info("ExecuteJob() on Job[{0}] returned : {1}", jobIter, execResult);
                }

                //Wait for complete
                JobState[] js = WaitForJobsCompleted(jobId);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _report.Success("JobId " + jobIter.ToString() + " " + js[jobIter].ToString());
                    ActionResult result = _service.GetActionResult(jobId[jobIter], 0);
                    _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                    //_report.Debug("Output:");
                    //_report.Debug(result.consoleOutput);
                    result = _service.GetActionResult(jobId[jobIter], 1);
                    _report.Info("ReturnCode Action 2: {0}", result.returnCode);
                    //_report.Debug("Output:");
                    //_report.Debug(result.consoleOutput);
                }

                ResultCode = TEST_RESULTS.PASSED;

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _service.CleanupJob((ulong)jobId[jobIter]);
                }
            }
        }

        /// <summary>
        /// 3 content submission that should succeed in succession followed by 3 dir c:
        /// WorkFilesReady runs in a single thread and cannot run parallel. This is a test 
        /// to see if it blocks parallel threads from running normal jobs
        /// </summary>
        [TestCase, StressTest]
        public class MultiAutoContentDirCXblob_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                int totalJobs = 3;
                int jobIter = 0;
                JobInfo jobInfo;
                ActionInfo actionInfo;
                ulong[] workIds = new ulong[totalJobs];
                long[] jobId = new long[totalJobs];
                string[] titleIDs = new string[totalJobs];
                titleIDs[0] = "ffffab2d";
                titleIDs[1] = "ffffab2e";
                titleIDs[2] = "ffffab2f";

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    string xlastFilename = titleIDs[jobIter].ToString() + ".xlast";
                    PropLiveTitleOnly(titleIDs[jobIter], false, xlastFilename, "itembox.png", "0xffffffffffffffff.png");

                    workIds[jobIter] = BeginWork(titleIDs[jobIter], 3);
                    _report.Debug("JobID{0}: {1}", jobIter, workIds[jobIter]);

                    //  Copy files to 'fake' staging directory
                    PropWorkFile(titleIDs[jobIter].ToString() + "01000001.cab", workIds[jobIter].ToString());
                    PropWorkFile(titleIDs[jobIter].ToString() + "01000001.offer", workIds[jobIter].ToString());
                    PropWorkFile("0xffffffffffffffff.png", workIds[jobIter].ToString());
                }
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    jobId[jobIter] = _service.CreateJob("MultiDirCXblob job " + jobIter.ToString(), out jobInfo);
                    PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId[jobIter].ToString());
                    _report.Info("JobId: {0}", jobId[jobIter]);

                    actionInfo = CreateDirCdriveAction(jobId[jobIter]);
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);
                }


                //  Tell widget to start doing work
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    // The working directory is the workId
                    WorkFilesReady(workIds[jobIter], workIds[jobIter].ToString());
                }
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    int execResult = _service.ExecuteJob(jobId[jobIter]);
                    _report.Info("ExecuteJob() on Job[{0}] returned : {1}", jobIter, execResult);
                }

                //  Get the results
                int[] returnCodes = new int[totalJobs];
                string[] outputs = new string[totalJobs];
                JobState[] js = WaitForWorkandJobsCompleted(workIds, ref returnCodes, ref outputs, jobId);

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    ValueCheck.IsTrue(returnCodes[jobIter] == 0, "GetWorkStatusResult.returnCode");
                    ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", outputs[jobIter].Length);
                }
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _report.Success("JobId " + jobIter.ToString() + " " + js[jobIter].ToString());
                    ActionResult result = _service.GetActionResult(jobId[jobIter], 0);
                    _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                    //_report.Debug("Output:");
                    //_report.Debug(result.consoleOutput);
                }

                ResultCode = TEST_RESULTS.PASSED;

                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    _service.CleanupJob((ulong)jobId[jobIter]);
                }
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\Negative.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace xonline.server.webcache.toolsmgmt.test.dvt
{
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class Negative : TestNode
    {
        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public class BeginWork_Neg_BadWorkType : ToolsMgmtBase
        {
            protected override void Execute()
            {
            BeginWork("ffff400a", 100);

            //  This is supposed to throw an exception, no more checking needed
            }
        }

        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public class WorkFilesReady_Neg_InvalidWorkID : ToolsMgmtBase
        {
            protected override void Execute()
            {
            WorkFilesReady(2200021414431358, "whatver");
            }
        }

        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public class GetWorkStatus_Neg_InvalidWorkID : ToolsMgmtBase
        {
            protected override void Execute()
            {
            int returnCode = 0;
            string output = "";

            GetWorkStatus(2200021414431358, ref returnCode, ref output);
            }
        }

        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public class GetJobLog_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobLogEntry[] jobLogs;
                _service.GetJobLog((int)-1, out jobLogs);
            }
        }

        /// <summary>
        /// Submitting an XLAST+PNGs work type, but with wrong file types.
        /// </summary>
        [TestCase]
        public class XlastSubmission_Neg_UnknownFileTypes : ToolsMgmtBase
        {
            protected override void Execute()
            {
            ulong workId = BeginWork("ffff400a", 1);
            _report.Debug("JobID: {0}", workId);

            //  Copy files to 'fake' staging directory
            PropWorkFile("ach_img.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class TrailerBothContent_DefaultOffer_Submission_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");
            PropTitle();

            ulong workId = BeginWork("fffe07f1", 2);
            _report.Debug("JobID: {0}", workId);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class TrailerLoOnlyContent_DefaultOffer_Submission_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");
            PropTitle();

            ulong workId = BeginWork("fffe07f1", 2);
            _report.Debug("JobID: {0}", workId);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100002.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class TrailerHiOnlyContent_DefaultOffer_Submission_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");
            PropTitle();

            ulong workId = BeginWork("fffe07f1", 2);
            _report.Debug("JobID: {0}", workId);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100003.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class VideoContent_DefaultOffer_Submission_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");
            PropTitle();

            ulong workId = BeginWork("fffe07f1", 2);
            _report.Debug("JobID: {0}", workId);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100700001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class VideoContent_Submission_Neg_BadXML : ToolsMgmtBase
        {
            protected override void Execute()
            {
            PropTitle();

            ulong workId = BeginWork("fffe07f1", 3);
            _report.Debug("JobID: {0}", workId);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100700001.cab", "relative");
            PropWorkFile("FFFE07F100700001malformed.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class VideoContent_Submission_Neg_BadTitle : ToolsMgmtBase
        {
            protected override void Execute()
            {
            PropTitle(); 
            ulong workId = BeginWork("fffe07f1", 3);
            _report.Debug("JobID: {0}", workId);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100700001.cab", "relative");
            PropWorkFile("FFFE07F100700001wrongtitle.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class VideoContent_Submission_Neg_BadCab : ToolsMgmtBase
        {
            protected override void Execute()
            {
            PropTitle();
            ulong workId = BeginWork("fffe07f1", 3);
            _report.Debug("JobID: {0}", workId);

            //  Copy files to 'fake' staging directory
            PropWorkFile("fffe07f100700001corrupt.cab", "relative");
            PropWorkFile("FFFE07F100700001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public class VideoContent_Submission_Neg_NoFiles : ToolsMgmtBase
        {
            protected override void Execute()
            {
            PropTitle();
            ulong workId = BeginWork("fffe07f1", 3);
            _report.Debug("JobID: {0}", workId);

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while (!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            _report.Info("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                _report.Debug("Tools output:");
                _report.Debug(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
            ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, StressTest]
        public class LiveContentInvalidPath_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                long jobId;
                string titleID = "ffffab2d";

                string offerID = titleID + "01000001";
                jobId = _service.CreateJob("LiveContent job", out jobInfo);
                _report.Info("JobId: {0}", jobId);

                actionInfo = RunLiveContentBuild(jobId, titleID, offerID + ".cab", offerID + ".offer", offerID);
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                actionInfo = RunLiveOfferProp(jobId, titleID, offerID + ".offer");
                rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);

                //Wait for complete
                JobState js;

                _report.Debug("Wait for complete");
                bool runLoop = true;
                while (runLoop)
                {
                    js = _service.GetJobStatus(jobId);
                    switch (js)
                    {
                        case JobState.Canceled:
                            _report.Info("Job Status: Cancelled");
                            runLoop = false;
                            break;
                        case JobState.Complete:
                            _report.Success("Job Status: Complete");
                            runLoop = false;
                            break;
                        case JobState.Failed:
                            _report.Error("Job Status: Failed");
                            runLoop = false;
                            break;
                        default:
                            _report.Debug("Job Status: {0}", js.ToString());
                            break;
                    }

                    System.Threading.Thread.Sleep(1000);
                }

                ActionResult result = _service.GetActionResult(jobId, 0);
                _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                ValueCheck.IsTrue(result.returnCode != 0, "GetActionResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                ResultCode = TEST_RESULTS.PASSED;

                _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase]
        public class ExecuteNoAction_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
            JobInfo jobInfo;
            long jobId;

            jobId = _service.CreateJob("test job", out jobInfo);
            _report.Debug("JobId: {0}", jobId);

            int execResult = _service.ExecuteJob(jobId);
            _report.Info("ExecuteJob() returned : {0}", execResult);
            ValueCheck.IsTrue(execResult != 0, "ExecuteJob.returnCode");
            ResultCode = TEST_RESULTS.PASSED;

            _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase]
        public class AddActionAfterExecute_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
            JobInfo jobInfo;
            ActionInfo actionInfo;
            long jobId;

            jobId = _service.CreateJob("test job", out jobInfo);
            PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
            _report.Debug("JobId: {0}", jobId);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[5];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].value = "C:\\";
            int rank = _service.AddAction(actionInfo);
            _report.Debug("rank: {0}", rank);

            int execResult = _service.ExecuteJob(jobId);
            _report.Info("ExecuteJob() returned : {0}", execResult);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "type";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
            actionInfo.files = new string[1];
            actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
            rank = _service.AddAction(actionInfo);
            ValueCheck.IsTrue(rank == -1, "AddAction.returnCode");
            _report.Debug("rank: {0}", rank);

            JobState js;

            _report.Debug("Wait for complete");
            while (true)
            {
                js = _service.GetJobStatus(jobId);
                if (js == JobState.Canceled)
                    break;
                if (js == JobState.Complete)
                    break;
                if (js == JobState.Failed)
                    break;
                _report.Debug("State: {0}", js.ToString());

                System.Threading.Thread.Sleep(1000);
            }

            _report.Success("Completed");
            ResultCode = TEST_RESULTS.PASSED;

            _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase]
        public class RepeatedExecute_Neg : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                long jobId;

                jobId = _service.CreateJob("test job", out jobInfo);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
                _report.Debug("JobId: {0}", jobId);

                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[5];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].value = "C:\\";
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[3];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "type";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                actionInfo.files = new string[1];
                actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);
                // The return value of ExecuteJob() was changed from 0 = success to 1 = success
                ValueCheck.IsTrue(execResult == 0, "ExecuteJob.returnCode");

                System.Threading.Thread.Sleep(1000);
                execResult = _service.ExecuteJob(jobId);
                _report.Info("Calling ExecuteJob() again returned : {0}", execResult);
                // The return value of ExecuteJob() was changed from 1 = failure to 2 = failure
                ValueCheck.IsTrue(execResult == 2, "ExecuteJob.returnCode");

                JobState js;

                _report.Debug("Wait for complete");
                while (true)
                {
                    js = _service.GetJobStatus(jobId);
                    if (js == JobState.Canceled)
                        break;
                    if (js == JobState.Complete)
                        break;
                    if (js == JobState.Failed)
                        break;
                    _report.Debug("State: {0}", js.ToString());

                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Completed");
                ActionResult result = _service.GetActionResult(jobId, 0);
                _report.Info("ReturnCode: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                result = _service.GetActionResult(jobId, 1);
                _report.Info("ReturnCode: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                ResultCode = TEST_RESULTS.PASSED;

                _service.CleanupJob((ulong)jobId);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\main.cs ===
using System;
using System.Text;
using System.IO;
using System.Net;
using System.Web;
using System.Xml;
using System.Diagnostics;
using System.Globalization;
using System.Security.Cryptography.X509Certificates;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.server.webcache.toolsmgmt.test.dvt;

class WebSvcTest
{
    /// <summary>
    /// The main entry point for the application.
    /// </summary>
    [STAThread]
    static void Main(string[] args)
    {
        if (args.Length == 0 || args[0].CompareTo("/?") == 0 )
        {
            Console.Write("Usage:\n\tWebSvcTest.exe WebServiceMachine [<DER type Client Certificate to use with testnet web services>]\n");
            return;
        }

        ToolsMgmt g;
        
        if (args.Length >= 2 && (args[1].EndsWith(".CER") || args[1].EndsWith(".cer")))
        {
            g = new ToolsMgmt("https://"+args[0]+"/wcToolsMgmt/ToolsMgmt.asmx");
            
            X509Certificate x509 = X509Certificate.CreateFromCertFile(@args[1]);
            g.ClientCertificates.Add(x509); 
            Console.WriteLine("Certificate:\"" + x509.GetName() + "\" is being used\n"); 
        }
        else
        {
            g = new ToolsMgmt("http://"+args[0]+":12000/wcToolsMgmt/ToolsMgmt.asmx");
        }


        TestGetActionTable(g);

        ulong id = TestBeginWork(g, 0);

        Console.WriteLine("WorkID: " + id);

        TestUploadFile(g, id, "ffff400a.xlast");
        TestUploadFile(g, id, "another.png");
        
        TestCommitWork(g, id);

    }


    static void TestGetActionTable(ToolsMgmt service)
    {
        string myXML = service.GetActionTable();

        Console.WriteLine("Action table retrieved");
    }



    static ulong TestBeginWork(ToolsMgmt service, uint wType )
    {
        BeginWorkInfo req = new BeginWorkInfo();

        req.workType = wType;
        req.titleId  = "ffff400a";

        BeginWorkResult res = service.BeginWork( req );

        Console.WriteLine("Begin SPACE LEFT: " + res.spaceAvailable);
        return res.workId;
    }


    static void TestUploadFile(ToolsMgmt service, ulong id, string fspec )
    {
        UploadFileInfo req = new UploadFileInfo();


        FileInfo     fi    = new FileInfo(fspec);
        FileStream   fs    = new FileStream(fspec, FileMode.Open, FileAccess.Read);
        BinaryReader rdr   = new BinaryReader(fs);


        req.workId   = id;
        req.fileName = fspec;
        req.fileData = rdr.ReadBytes((int) fi.Length);

        rdr.Close();
        fs.Close();

        UploadFileResult res = service.UploadFile( req );

        Console.WriteLine("Upload SPACE LEFT: " + res.spaceAvailable);

        return;
    }



    static void TestCommitWork(ToolsMgmt service, ulong id )
    {
        ASCIIEncoding ascii = new ASCIIEncoding();

        
        CommitWorkInfo req = new CommitWorkInfo();

        req.workId   = id;
        req.msWait   = 30000;

        CommitWorkResult res = service.CommitWork( req );


        Console.WriteLine("res code:   " + res.returnCode);
        Console.WriteLine("res stdout: " + ascii.GetString(res.consoleOutput));

        return;
    }




}




/*
    static State GetTitleState (ToolsMgmt service, uint titleId )
    {
        State state = State.InvalidTitle;
        PropHistoryReq req = new PropHistoryReq();
        req.titleId = titleId;
        req.fromTime = DateTime.Parse("2/16/1992");
        req.toTime = DateTime.UtcNow;

Console.WriteLine ("PRE  Create obj");
                        
        TitleInfo ti = new TitleInfo();
Console.WriteLine ("POST Create TitleInfo");
        PropHistoryResp[] resp = service.GetPropHistory( req );
Console.WriteLine ("POST GetPropHistory");
        int nIndex = 0;
        for (nIndex = 0; nIndex< resp.Length; nIndex++)
        {
Console.WriteLine ("LOOP {0} ", nIndex);
            if (resp[nIndex].titleId == titleId && 
                resp[nIndex].taskType == TaskType.PropNewTitle
                )
            {
                Console.WriteLine ("Title found, state = {0}",resp[nIndex].state );
                return resp[nIndex].state;
            }    
            Console.WriteLine ("Record {0}: titleId = {1}, xboxCntrl = {2}, task = {3}, state = {4}", nIndex, 
                resp[nIndex].titleId , 
                resp[nIndex].xboxCentralId,
                resp[nIndex].taskType, resp[nIndex].state);
        }

        if ( nIndex >= resp.Length )
        {
            throw new ApplicationException( "GetPropHistory cannot find created title, titleId = 0x" + titleId.ToString ("X"));
        }
        return state;
    }
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\TokenDieHard\RunDieHard.cs ===
﻿//-----------------------------------------------------------------------
// <copyright file="RunDieHard.cs" company="Microsoft">
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// <summary>
//   class to execute the diehard tests
// </summary>
//-----------------------------------------------------------------------
using System;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace Test.TokenDieHard
{
    /// <summary>
    /// Provides access to run an executable and get its exit code and standard output
    /// 
    /// Run DIEQUICK.EXE using the specified input file and output file
    /// Capture the standard output to a string buffer so it can be examined
    /// 
    /// </summary>
    public class RunDieHard
    {
        /// <summary>
        /// dieHardName is the name of the diehard tests executable
        /// </summary>
        const string dieHardName = "DIEQUICK.EXE";

        /// <summary>
        /// dieHardPath is the path to the diehard tests and files
        /// </summary>
        string dieHardPath;

        /// <summary>
        /// exitCode is the exit code of the executable
        /// </summary>
        private int exitCode;

        /// <summary>
        /// fileNameIn is the file name for input to diehard
        /// </summary>
        private string fileNameIn;

        /// <summary>
        /// fileNameInPrompt is the standard output prompt for the input file
        /// </summary>
        const string fileNameInPrompt = " giving the p-values but little explanation. ";

        /// <summary>
        /// fileNameOut is the file name for output from diehard
        /// </summary>
        private string fileNameOut;

        /// <summary>
        /// fileNameOutPrompt is the standard output prompt for the output file
        /// </summary>
        const string fileNameOutPrompt = " Enter name of file to be tested:";

        /// <summary>
        /// output is the standard output of the executable
        /// </summary>
        private string output;

        /// <summary>
        /// process is the process instance
        /// </summary>
        private Process process;

        /// <summary>
        /// stringBuilder is the string builder object to capture the standard output of the executable
        /// </summary>
        private StringBuilder stringBuilder;

        /// <summary>
        /// Initializes a new instance of the RunDieHard class
        /// </summary>
        /// <param name="path">The path to the diehard tests and files</param>
        /// <param name="fileNameIn">The file name for input to diehard</param>
        /// <param name="fileNameOut">The file name for output from diehard</param>
        public RunDieHard(string path, string fileNameIn, string fileNameOut)
        {
            this.dieHardPath = path;
            this.fileNameIn = fileNameIn;
            this.fileNameOut = fileNameOut;
        }

        /// <summary>
        /// Gets the exit code of the process
        /// </summary>
        public int ExitCode
        {
            get { return this.exitCode; }
        }

        /// <summary>
        /// Gets the standard output of the process
        /// </summary>
        public string Output
        {
            get { return this.output; }
        }

        /// <summary>
        /// Run the specified executable with the specified arguments and capture the output and exit code
        /// </summary>
        public void Run()
        {
            ProcessStartInfo processStartInfo = new ProcessStartInfo(Path.Combine(this.dieHardPath, dieHardName));
            processStartInfo.CreateNoWindow = true;
            processStartInfo.ErrorDialog = false;
            processStartInfo.RedirectStandardInput = true;
            processStartInfo.RedirectStandardOutput = true;
            processStartInfo.UseShellExecute = false;
            processStartInfo.WorkingDirectory = this.dieHardPath;

            this.process = new Process();
            this.process.StartInfo = processStartInfo;

            this.stringBuilder = new StringBuilder();
            this.process.OutputDataReceived += new DataReceivedEventHandler(this.OutputDataReceivedHandler);

            this.process.Start();
            this.process.BeginOutputReadLine();
            this.process.WaitForExit();

            this.exitCode = this.process.ExitCode;
            this.output = this.stringBuilder.ToString();
        }

        /// <summary>
        /// Handles the OutputDataReceived event of the Process
        /// </summary>
        /// <param name="sender">The source of the event</param>
        /// <param name="e">A DataReceivedEventArgs that contains the event data</param>
        private void OutputDataReceivedHandler(object sender, DataReceivedEventArgs e)
        {
            if (null != e.Data)
            {
                this.stringBuilder.AppendLine(e.Data);

                if (0 == String.Compare(fileNameInPrompt, e.Data))
                {
                    this.process.StandardInput.WriteLine(this.fileNameIn);
                    this.stringBuilder.AppendLine(this.fileNameIn);
                }
                else if (0 == String.Compare(fileNameOutPrompt, e.Data))
                {
                    this.process.StandardInput.WriteLine(this.fileNameOut);
                    this.stringBuilder.AppendLine(this.fileNameOut);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\Positive.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace xonline.server.webcache.toolsmgmt.test.dvt
{
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class Positive : TestNode
    {
        [TestCase, DVT]
        public class GetActionTable_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                GetActionTable();
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, DVT]
        public class CreateJobTest_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                long jobId;

                jobId = _service.CreateJob("test job", out jobInfo);
                _report.Info("JobId: {0}", jobId);
                ResultCode = TEST_RESULTS.PASSED;

                _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase, DVT]
        public class DirCXblob_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                long jobId;

                jobId = _service.CreateJob("test job", out jobInfo);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
                _report.Info("JobId: {0}", jobId);

                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[5];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].value = "C:\\";
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[3];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "type";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                actionInfo.files = new string[1];
                actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);

                JobState js;

                _report.Debug("Wait for complete");
                while (true)
                {
                    js = _service.GetJobStatus(jobId);
                    if (js == JobState.Canceled)
                        break;
                    if (js == JobState.Complete)
                        break;
                    if (js == JobState.Failed)
                        break;
                    _report.Debug("State: {0}", js.ToString());

                    System.Threading.Thread.Sleep(1000);
                }

                _report.Success("Completed");
                ActionResult result = _service.GetActionResult(jobId, 0);
                _report.Info("ReturnCode: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                result = _service.GetActionResult(jobId, 1);
                _report.Info("ReturnCode: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                ResultCode = TEST_RESULTS.PASSED;

                _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase]
        public class GetJobStatus_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                long jobId;

                jobId = _service.CreateJob("test job", out jobInfo);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
                _report.Info("JobId: {0}", jobId);

                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[5];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].value = "C:\\";
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);
                ValueCheck.IsTrue(execResult == 0, "ExecuteJob.returnCode");

                JobState js;

                _report.Debug("Wait for complete");
                bool runLoop = true;
                while (runLoop)
                {
                    js = _service.GetJobStatus(jobId);
                    switch (js)
                    {
                        case JobState.Canceled:
                            _report.Info("Job Status: Cancelled");
                            runLoop = false;
                            break;
                        case JobState.Complete:
                            _report.Success("Job Status: Complete");
                            runLoop = false;
                            break;
                        case JobState.Failed:
                            _report.Error("Job Status: Failed");
                            runLoop = false;
                            break;
                        default:
                            _report.Debug("Job Status: {0}", js.ToString());
                            break;
                    }

                    System.Threading.Thread.Sleep(1000);
                }

                _report.Success("Completed");
                ResultCode = TEST_RESULTS.PASSED;
                _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase]
        public class GetJobLog_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                long jobId;

                jobId = _service.CreateJob("test job", out jobInfo);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
                _report.Info("JobId: {0}", jobId);

                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[5];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].value = "C:\\";
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);
                ValueCheck.IsTrue(execResult == 0, "ExecuteJob.returnCode");

                JobLogEntry[] jobLogs;
                execResult = _service.GetJobLog((int)jobId, out jobLogs);
                _report.Info("GetJobLog() returned : {0}", execResult);
                ValueCheck.TestNotNull("JobLog", jobLogs);
                PrintJobLog(jobLogs);

                JobState js;

                _report.Debug("Wait for complete");
                bool runLoop = true;
                while (runLoop)
                {
                    js = _service.GetJobStatus(jobId);
                    switch (js)
                    {
                        case JobState.Canceled:
                            _report.Info("Job Status: Cancelled");
                            runLoop = false;
                            break;
                        case JobState.Complete:
                            _report.Success("Job Status: Complete");
                            runLoop = false;
                            break;
                        case JobState.Failed:
                            _report.Error("Job Status: Failed");
                            runLoop = false;
                            break;
                        default:
                            _report.Debug("Job Status: {0}", js.ToString());
                            break;
                    }

                    System.Threading.Thread.Sleep(1000);
                }

                execResult = _service.GetJobLog((int)jobId, out jobLogs);
                _report.Info("GetJobLog() returned : {0}", execResult);
                ValueCheck.TestNotNull("JobLog", jobLogs);
                PrintJobLog(jobLogs);

                _report.Success("Completed");
                ResultCode = TEST_RESULTS.PASSED;
                _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase, DVT]
        public class GetActionStatus_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                long jobId;

                jobId = _service.CreateJob("test job", out jobInfo);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
                _report.Info("JobId: {0}", jobId);

                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[5];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].value = "C:\\";
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);

                JobState js;

                _report.Debug("Wait for complete");
                bool runLoop = true;
                while (runLoop)
                {
                    js = _service.GetJobStatus(jobId);
                    switch (js)
                    {
                        case JobState.Canceled:
                            _report.Info("Job Status: Cancelled");
                            runLoop = false;
                            break;
                        case JobState.Complete:
                            _report.Success("Job Status: Complete");
                            runLoop = false;
                            break;
                        case JobState.Failed:
                            _report.Error("Job Status: Failed");
                            runLoop = false;
                            break;
                        default:
                            _report.Debug("Job Status: {0}", js.ToString());
                            break;
                    }

                    js = _service.GetActionStatus(jobId, 0);
                    switch (js)
                    {
                        case JobState.Canceled:
                            _report.Info("Action Status: Cancelled");
                            break;
                        case JobState.Complete:
                            _report.Success("Action Status: Complete");
                            break;
                        case JobState.Failed:
                            _report.Error("Action Status: Failed");
                            break;
                        default:
                            _report.Debug("Action Status: {0}", js.ToString());
                            break;
                    }

                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Completed");
                ActionResult result = _service.GetActionResult(jobId, 0);
                _report.Info("ReturnCode: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                ResultCode = TEST_RESULTS.PASSED;

                _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase, DVT]
        public class GetActionResult_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                long jobId;

                jobId = _service.CreateJob("test job", out jobInfo);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
                _report.Info("JobId: {0}", jobId);

                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[5];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].value = "C:\\";
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);

                JobState js;

                _report.Debug("Wait for complete");
                bool runLoop = true;
                while (runLoop)
                {
                    js = _service.GetJobStatus(jobId);
                    switch (js)
                    {
                        case JobState.Canceled:
                            _report.Info("Job Status: Cancelled");
                            runLoop = false;
                            break;
                        case JobState.Complete:
                            _report.Success("Job Status: Complete");
                            runLoop = false;
                            break;
                        case JobState.Failed:
                            _report.Error("Job Status: Failed");
                            runLoop = false;
                            break;
                        default:
                            _report.Debug("Job Status: {0}", js.ToString());
                            break;
                    }

                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Completed");
                ActionResult result = _service.GetActionResult(jobId, 0);
                _report.Info("ReturnCode: {0}", result.returnCode);
                _report.Debug("Output:");
                _report.Debug(result.consoleOutput);
                ResultCode = TEST_RESULTS.PASSED;

                _service.CleanupJob((ulong)jobId);
            }
        }

        [TestCase]
        public class MultiJob_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo1, jobInfo2;
                ActionInfo actionInfo;
                long jobId1, jobId2;

                jobId1 = _service.CreateJob("test job 1", out jobInfo1);
                jobId2 = _service.CreateJob("test job 1", out jobInfo2);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId1.ToString());
                _report.Info("JobId: {0}", jobId1);
                _report.Info("JobId: {0}", jobId2);

                // Job 1 Action 1
                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId1;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[5];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].value = "C:\\";
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                // Job 2 Action 1
                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId2;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[5];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].value = "C:\\";
                rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                // Job 2 Action 2
                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId2;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[3];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "type";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                actionInfo.files = new string[1];
                actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId2);
                _report.Info("ExecuteJob(2) returned : {0}", execResult);

                // Job 1 Action 2
                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId1;
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[3];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "type";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                actionInfo.files = new string[1];
                actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                execResult = _service.ExecuteJob(jobId1);
                _report.Info("ExecuteJob(1) returned : {0}", execResult);

                JobState js;

                _report.Debug("Wait for complete");
                while (true)
                {
                    js = _service.GetJobStatus(jobId2);
                    if (js == JobState.Canceled)
                        break;
                    if (js == JobState.Complete)
                        break;
                    if (js == JobState.Failed)
                        break;
                    _report.Debug("State: {0}", js.ToString());

                    System.Threading.Thread.Sleep(1000);
                }
                _report.Info("Job 2 Completed");
                while (true)
                {
                    js = _service.GetJobStatus(jobId1);
                    if (js == JobState.Canceled)
                        break;
                    if (js == JobState.Complete)
                        break;
                    if (js == JobState.Failed)
                        break;
                    _report.Debug("State: {0}", js.ToString());

                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Completed");
                ResultCode = TEST_RESULTS.PASSED;
                _service.CleanupJob((ulong)jobId1);
                _service.CleanupJob((ulong)jobId2);
            }
        }

        /// <summary>
        /// Normal XLAST+PGNs submission that should succeed.
        /// </summary>
        [TestCase, DVT]
        public class XlastSubmission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle(true);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, DVT]
        public class InGameContent_DefaultOffer_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                // set at baseline so that we use Default offer
                ClearOffers("fffe07f1");
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 2);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("fffe07f100200001.cab", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class ThemeContent_DefaultOffer_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                // set at baseline so that we use Default offer
                ClearOffers("fffe07f1");
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 2);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100500001.cab", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class GamerPicsContent_DefaultOffer_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                // set at baseline so that we use Default offer
                ClearOffers("fffe07f1");
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 2);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100400001.cab", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class DemoContent_DefaultOffer_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                // set at baseline so that we use Default offer
                ClearOffers("fffe07f1");
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 2);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100300001.cab", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class ArcadeContent_DefaultOffer_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                // set at baseline so that we use Default offer
                ClearOffers("fffe07f1");
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 2);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100600001.cab", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class InGameContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 3);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("fffe07f100200001.cab", "relative");
                PropWorkFile("fffe07f100200001.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class TrailerBothContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 4);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100100001.cab", "relative");
                PropWorkFile("fffe07f100100001.offer", "relative");
                PropWorkFile("fffe07f100100002.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class TrailerLoOnlyContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 3);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100100002.cab", "relative");
                PropWorkFile("fffe07f100100002.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class TrailerHiOnlyContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 3);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100100003.cab", "relative");
                PropWorkFile("fffe07f100100001.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class ThemeContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 3);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100500001.cab", "relative");
                PropWorkFile("fffe07f100500001.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class GamerPicsContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 3);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100400001.cab", "relative");
                PropWorkFile("fffe07f100400001.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class DemoContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 3);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100300001.cab", "relative");
                PropWorkFile("fffe07f100300001.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class ArcadeContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 3);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100600001.cab", "relative");
                PropWorkFile("fffe07f100600001.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase]
        public class VideoContent_Submission_Pos : ToolsMgmtBase
        {
            protected override void Execute()
            {
                PropTitle();

                ulong workId = BeginWork("fffe07f1", 3);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                PropWorkFile("FFFE07F100700001.cab", "relative");
                PropWorkFile("fffe07f100700001.offer", "relative");
                PropWorkFile("0xffffffffffffffff.png", "relative");

                //  Tell widget to start doing work
                WorkFilesReady(workId, "relative");

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\Regression.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;
using System.IO;

namespace xonline.server.webcache.toolsmgmt.test.dvt
{
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class Regression : TestNode
    {
        [TestCase, DVT]
        public class LSG8547 : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;
                long jobId;

                jobId = _service.CreateJob("test job", out jobInfo);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());

                // Open the file and lock it.
                FileStream stream = new FileStream(GetDestinationFilePath("FFFE07F100700001wrongtitle.offer", jobId.ToString()),
                     FileMode.Open, FileAccess.Read, FileShare.Read);
                try
                {
                    _report.Info("JobId: {0}", jobId);

                    actionInfo = new ActionInfo();
                    actionInfo.jobId = jobId;
                    actionInfo.toolFileName = "cmd";
                    actionInfo.parameters = new Parameter[5];
                    actionInfo.parameters[0] = new Parameter();
                    actionInfo.parameters[0].name = "/C";
                    actionInfo.parameters[1] = new Parameter();
                    actionInfo.parameters[1].value = "dir";
                    actionInfo.parameters[2] = new Parameter();
                    actionInfo.parameters[2].value = "test.txt";
                    actionInfo.parameters[3] = new Parameter();
                    actionInfo.parameters[3].name = "/B";
                    actionInfo.parameters[4] = new Parameter();
                    actionInfo.parameters[4].value = "C:\\";
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    actionInfo = new ActionInfo();
                    actionInfo.jobId = jobId;
                    actionInfo.toolFileName = "cmd";
                    actionInfo.parameters = new Parameter[3];
                    actionInfo.parameters[0] = new Parameter();
                    actionInfo.parameters[0].name = "/C";
                    actionInfo.parameters[1] = new Parameter();
                    actionInfo.parameters[1].value = "type";
                    actionInfo.parameters[2] = new Parameter();
                    actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                    actionInfo.files = new string[1];
                    actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    int execResult = _service.ExecuteJob(jobId);
                    _report.Info("ExecuteJob() returned : {0}", execResult);

                    JobState js;

                    _report.Debug("Wait for complete");
                    while (true)
                    {
                        js = _service.GetJobStatus(jobId);
                        if (js == JobState.Canceled)
                            break;
                        if (js == JobState.Complete)
                            break;
                        if (js == JobState.Failed)
                            break;
                        _report.Debug("State: {0}", js.ToString());

                        System.Threading.Thread.Sleep(1000);
                    }

                    _report.Success("Completed");
                    ActionResult result = _service.GetActionResult(jobId, 0);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    result = _service.GetActionResult(jobId, 1);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    _report.Debug("Output:");
                    _report.Debug(result.consoleOutput);
                    ResultCode = TEST_RESULTS.PASSED;

                    _service.CleanupJob((ulong)jobId);
                }
                finally
                {
                    stream.Close();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\Stress.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace xonline.server.webcache.toolsmgmt.test.dvt
{
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
    public class Stress : TestNode
    {
        const int DefaultMaxJobs = 100;

        [TestCase, StressTest]
        public class CreateJobTest_Stress : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo;
                int iter, maxJobs;
                long[] jobId;

                maxJobs = DefaultMaxJobs;
                jobId = new long[maxJobs];

                // Create Loop
                for (iter = 0; iter < maxJobs; ++iter)
                {
                    jobId[iter] = _service.CreateJob("test job", out jobInfo);
                    _report.Debug("JobId: {0}", jobId[iter]);
                }

                // Cleanup Loop
                for (iter = 0; iter < maxJobs; ++iter)
                {
                    _service.CleanupJob((ulong)jobId[iter]);
                    _report.Debug("Cleanup JobId: {0}", jobId[iter]);
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

        [TestCase, StressTest]
        public class MultiJob_Stress : ToolsMgmtBase
        {
            protected override void Execute()
            {
                JobInfo jobInfo1, jobInfo2;
                ActionInfo actionInfo;
                long[] jobId1, jobId2;
                ActionResult result;

                int maxJobs = DefaultMaxJobs;
                jobId1 = new long[maxJobs];
                jobId2 = new long[maxJobs];

                // Create Loop
                for (int iter = 0; iter < maxJobs; ++iter)
                {
                    _report.Info("Starting Loop {0}", iter);

                    jobId1[iter] = _service.CreateJob("test job 1", out jobInfo1);
                    jobId2[iter] = _service.CreateJob("test job 1", out jobInfo2);
                    PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId1[iter].ToString());
                    _report.Debug("JobId 1: {0}", jobId1[iter]);
                    _report.Debug("JobId 2: {0}", jobId2[iter]);

                    // Job 1 Action 1
                    actionInfo = new ActionInfo();
                    actionInfo.jobId = jobId1[iter];
                    actionInfo.toolFileName = "cmd";
                    actionInfo.parameters = new Parameter[5];
                    actionInfo.parameters[0] = new Parameter();
                    actionInfo.parameters[0].name = "/C";
                    actionInfo.parameters[1] = new Parameter();
                    actionInfo.parameters[1].value = "dir";
                    actionInfo.parameters[2] = new Parameter();
                    actionInfo.parameters[2].value = "test.txt";
                    actionInfo.parameters[3] = new Parameter();
                    actionInfo.parameters[3].name = "/B";
                    actionInfo.parameters[4] = new Parameter();
                    actionInfo.parameters[4].value = "C:\\";
                    int rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    // Job 2 Action 1
                    actionInfo = new ActionInfo();
                    actionInfo.jobId = jobId2[iter];
                    actionInfo.toolFileName = "cmd";
                    actionInfo.parameters = new Parameter[5];
                    actionInfo.parameters[0] = new Parameter();
                    actionInfo.parameters[0].name = "/C";
                    actionInfo.parameters[1] = new Parameter();
                    actionInfo.parameters[1].value = "dir";
                    actionInfo.parameters[2] = new Parameter();
                    actionInfo.parameters[2].value = "test.txt";
                    actionInfo.parameters[3] = new Parameter();
                    actionInfo.parameters[3].name = "/B";
                    actionInfo.parameters[4] = new Parameter();
                    actionInfo.parameters[4].value = "C:\\";
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    // Job 2 Action 2
                    actionInfo = new ActionInfo();
                    actionInfo.jobId = jobId2[iter];
                    actionInfo.toolFileName = "cmd";
                    actionInfo.parameters = new Parameter[3];
                    actionInfo.parameters[0] = new Parameter();
                    actionInfo.parameters[0].name = "/C";
                    actionInfo.parameters[1] = new Parameter();
                    actionInfo.parameters[1].value = "type";
                    actionInfo.parameters[2] = new Parameter();
                    actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                    actionInfo.files = new string[1];
                    actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    int execResult = _service.ExecuteJob(jobId2[iter]);
                    _report.Info("ExecuteJob(2) returned : {0}", execResult);

                    // Job 1 Action 2
                    actionInfo = new ActionInfo();
                    actionInfo.jobId = jobId1[iter];
                    actionInfo.toolFileName = "cmd";
                    actionInfo.parameters = new Parameter[3];
                    actionInfo.parameters[0] = new Parameter();
                    actionInfo.parameters[0].name = "/C";
                    actionInfo.parameters[1] = new Parameter();
                    actionInfo.parameters[1].value = "type";
                    actionInfo.parameters[2] = new Parameter();
                    actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                    actionInfo.files = new string[1];
                    actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                    rank = _service.AddAction(actionInfo);
                    _report.Debug("rank: {0}", rank);

                    execResult = _service.ExecuteJob(jobId1[iter]);
                    _report.Info("ExecuteJob(1) returned : {0}", execResult);

                    JobState js;

                    _report.Debug("Wait for complete");
                    while (true)
                    {
                        js = _service.GetJobStatus(jobId2[iter]);
                        if (js == JobState.Canceled)
                            break;
                        if (js == JobState.Complete)
                            break;
                        if (js == JobState.Failed)
                            break;
                        _report.Debug("State: {0}", js.ToString());

                        System.Threading.Thread.Sleep(1000);
                    }
                    _report.Info("Job 2 Completed");
                    while (true)
                    {
                        js = _service.GetJobStatus(jobId1[iter]);
                        if (js == JobState.Canceled)
                            break;
                        if (js == JobState.Complete)
                            break;
                        if (js == JobState.Failed)
                            break;
                        _report.Debug("State: {0}", js.ToString());

                        System.Threading.Thread.Sleep(1000);
                    }

                    _report.Info("Job 1 Completed");
                    result = _service.GetActionResult(jobId1[iter], 0);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    //_report.WriteLine("Output:");
                    //_report.WriteLine(result.consoleOutput);
                    result = _service.GetActionResult(jobId1[iter], 1);
                    _report.Info("ReturnCode: {0}", result.returnCode);
                    //_report.WriteLine("Output:");
                    //_report.WriteLine(result.consoleOutput);

                    _service.CleanupJob((ulong)jobId1[iter]);
                    _service.CleanupJob((ulong)jobId2[iter]);

                    _report.Debug("Ending Loop {0}", iter);
                }
                ResultCode = TEST_RESULTS.PASSED;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_toolsmgmtdvt_none_12.4.56.0_none_906bcc05bd142589
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=toolsmgmtdvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69.manifest
XP_MANIFEST_PATH=manifests\msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69.cat
XP_CATALOG_PATH=manifests\msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69.cat
XP_PAYLOAD_PATH=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=toolsmgmtdvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\wctoolsmgmt.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.WebWidget;
using xonline.common.config;

namespace xonline.server.webcache.toolsmgmt.test.dvt
{
	public class WCToolsMgmt : ToolsMgmt
	{
		protected RequestInfo requestInfo = null;

		public WCToolsMgmt() : this(Global.XEnv.GetVirtualInterface(VirtualInterface.wctoolsmgmt))
		{
		}

		public WCToolsMgmt(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCToolsMgmt(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/WCToolsMgmt/Toolsmgmt.asmx";
			requestInfo = new RequestInfo();
		}

		public WCToolsMgmt(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/WCToolsMgmt/Toolsmgmt.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCToolsMgmt(IPEndPoint endpoint, X509Certificate certificate)
		{
			Url = "https://" + endpoint.ToString() + "/WCToolsMgmt/Toolsmgmt.asmx";
			this.ClientCertificates.Add(certificate);
		}

		public WCToolsMgmt(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/WCToolsMgmt/Toolsmgmt.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_toolsmgmtdvt_none_12.4.56.0_none_906bcc05bd142589
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=toolsmgmtdvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69.manifest
XP_MANIFEST_PATH=manifests\msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69.cat
XP_CATALOG_PATH=manifests\msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69.cat
XP_PAYLOAD_PATH=msil_toolsmgmtdvt_no-public-key_12.4.56.0_x-ww_61e10a69
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=toolsmgmtdvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\ToolsMgmtBase.cs ===
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Text;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace xonline.server.webcache.toolsmgmt.test.dvt
{
	/// <summary>
	/// Summary description for ToolsMgmtDvt.
	/// </summary>
	/// 
	abstract public class ToolsMgmtBase : TestBase
	{
        protected static Dictionary<string, bool> _titleProppedDict = new Dictionary<string, bool>();
        protected string _uploadPath;
        protected string _inputFilePath;
        protected string _lbServer = "XESTATINH001";
        protected string _matchServer = "XETITLSQLV01";
        protected IPEndPoint _toolsMgmtAddress;
        protected X509Certificate _certificate;
        protected WCToolsMgmt _service;
        protected Report _report;
        protected const string TestRelativePath = "ToolsTransfer";

        public string UploadPath
        {
            get
            {
                return _uploadPath;
            }
        }

        public string InputFilePath
        {
            get
            {
                return _inputFilePath;
            }
        }

        public IPEndPoint ToolsMgmtAddress
        {
            get
            {
                return _toolsMgmtAddress;
            }
        }

        public X509Certificate ClientCertificate
        {
            get { return _certificate; }
            set { _certificate = value; }
        }

        #region ToolsMgmt API wrapper methods

        protected string GetActionTable()
        {
            string xmlActionTable = _service.GetActionTable();

            ValueCheck.TestNotNull("ActionTable", xmlActionTable);

            return xmlActionTable;
        }

        protected ulong BeginWork(string titleid, uint workType)
        {
            BeginWorkInfo bwi = new BeginWorkInfo();
            bwi.titleId = titleid;
            bwi.workType = workType;

            BeginWorkResult bwr = _service.BeginWork(bwi);

            ValueCheck.TestNotNull("BeginWorkResult", bwr);
            ValueCheck.TestNonZero("Work ID", bwr.workId);

            return bwr.workId;
        }

        protected bool WorkFilesReady(ulong workId, string relativePath)
        {
            string tempRelativePath = Path.Combine(TestRelativePath, relativePath);
            WorkFilesReadyInfo wfri = new WorkFilesReadyInfo();

            wfri.workId = workId;
            wfri.relativePath = tempRelativePath;
            WorkFilesReadyResult wfrr = _service.WorkFilesReady(wfri);

            ValueCheck.TestNotNull("WorkFilesReadyResult", wfrr);
            ValueCheck.IsTrue(wfrr.success, "WorkFilesReadyResult.success");

            return wfrr.success;
        }

        protected bool GetWorkStatus(ulong workId, ref int returnCode, ref string output)
        {
            output = "";

            GetWorkStatusInfo gwsi = new GetWorkStatusInfo();
            gwsi.workId = workId; // This is invalid by virtue of the leading 2200, which represents year

            GetWorkStatusResult gwsr = _service.GetWorkStatus(gwsi);

            if(gwsr.workComplete)
            {
                returnCode = gwsr.returnCode;
                output = gwsr.consoleOutput;
            }

            return gwsr.workComplete;
        }

        protected String GetDestinationFilePath(string file, string relativePath)
        {
            return Path.Combine(Path.Combine(UploadPath, Path.Combine(TestRelativePath, relativePath)), file);
        }

        protected void PropWorkFile(string file, string relativePath)
        {
            string tempRelativePath = Path.Combine(TestRelativePath, relativePath);
            if (!Directory.Exists(Path.Combine(UploadPath, tempRelativePath)))
            {
                Directory.CreateDirectory(Path.Combine(UploadPath, tempRelativePath));
            }
            File.Copy(Path.Combine(InputFilePath, file), Path.Combine(Path.Combine(UploadPath, tempRelativePath), file), true);
        }

        /// <summary>
        /// Clears the titlevault title of offer files so we can start at a clean baseline and
        /// force LiveContent to read from ZDefault.
        /// </summary>
        /// <param name="titleID">TitleID to be cleared of offer files.</param>
        protected void ClearOffers(string titleID)
        {
            string titlePath = Path.Combine(Config.GetSetting(Setting.titlevault_root),titleID);
            
            string[] offers = Directory.GetFiles(titlePath, "*.offer");
            foreach (string offer in offers)
            {
                File.Delete(Path.Combine(titlePath, offer));
            }
        }

        protected void PrintJobLog(JobLogEntry[] jobLogs)
        {
            _report.Debug("JobLog:");
            foreach (JobLogEntry jobLog in jobLogs)
            {
                _report.Debug("{0}: {1}", jobLog.logged.ToShortTimeString(), jobLog.log);
            }
        }

        protected void PropTitle()
        {
            PropTitle(false);
        }

        protected void PropTitle(bool force)
        {
            PropTitle(
                "fffe07f1",
                force,
                "apdvt.xlast",
                "another.png",
                "ach_img.png",
                "titleimg.png");
        }

        protected void PropTitle(string titleID, bool force, params string[] workFiles)
        {
            if ((_titleProppedDict.ContainsKey(titleID) == false) || (force == true))
            {
                ulong workId = BeginWork(titleID, 1);
                _report.Debug("JobID: {0}", workId);

                //  Copy files to 'fake' staging directory
                foreach (string workFile in workFiles)
                {
                    PropWorkFile(workFile, titleID);
                }

                //  Tell widget to start doing work

                WorkFilesReady(workId, titleID);

                //  Get the results
                int returnCode = 0;
                string output = "";
                while (!GetWorkStatus(workId, ref returnCode, ref output))
                {
                    System.Threading.Thread.Sleep(1000);
                }

                _report.Info("Propping Title Return Code: {0}", returnCode);
                if (output.Length != 0)
                {
                    _report.Debug("Tools output:");
                    _report.Debug(output);
                }

                ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
                if (_titleProppedDict.ContainsKey(titleID) == false)
                {
                    _titleProppedDict.Add(titleID, true);
                }
            }
        }

        protected void PropLiveTitleOnly(string titleID, bool force, string xlastFilename, params string[] workFiles)
        {
            if ((_titleProppedDict.ContainsKey(titleID) == false) || (force == true))
            {
                JobInfo jobInfo;
                ActionInfo actionInfo;

                long jobId = _service.CreateJob("LiveTitle job " + titleID, out jobInfo);
                PropWorkFile(xlastFilename, jobId.ToString());
                foreach (string workFile in workFiles)
                {
                    PropWorkFile(workFile, jobId.ToString());
                }
                _report.Info("JobId: {0}", jobId);

                actionInfo = RunLiveTitleDefault(jobId, titleID, xlastFilename);
                int rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                actionInfo = RunLiveTitleDeploy(jobId, titleID, xlastFilename);
                rank = _service.AddAction(actionInfo);
                _report.Debug("rank: {0}", rank);

                int execResult = _service.ExecuteJob(jobId);
                _report.Info("ExecuteJob() returned : {0}", execResult);

                JobState js;
                _report.Debug("Wait for complete");
                while (true)
                {
                    js = _service.GetJobStatus(jobId);
                    if (js == JobState.Canceled)
                        break;
                    if (js == JobState.Complete)
                        break;
                    if (js == JobState.Failed)
                        break;
                    // _report.Debug("State: {0}", js.ToString());

                    System.Threading.Thread.Sleep(1000);
                }
                    _report.Success("JobId " + jobId + " Completed");

                ActionResult result = _service.GetActionResult(jobId, 0);
                _report.Info("ReturnCode Action 1: {0}", result.returnCode);
                ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                result = _service.GetActionResult(jobId, 1);
                _report.Info("ReturnCode Action 2: {0}", result.returnCode);
                ValueCheck.IsTrue(result.returnCode == 0, "GetActionResult.returnCode");
                ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", result.consoleOutput.Length);

                if (_titleProppedDict.ContainsKey(titleID) == false)
                {
                    _titleProppedDict.Add(titleID, true);
                }

                _service.CleanupJob((ulong)jobId);
            }
        }

        protected string AddFilePath(long jobID, string filename)
        {
            //string filepath = ".\\" + filename;
            string filepath = _uploadPath + "\\ToolsTransfer\\" + jobID.ToString() + "\\" + filename;
            //string filepath = "E:\\ToolsMgmtWork\\" + jobID.ToString() + "\\" + filename;

            return filepath;
        }

        protected ActionInfo RunLiveTitleDefault(long jobID, string titleID, string xlastFilename)
        {
            ActionInfo actionInfo = new ActionInfo();

            actionInfo.jobId = jobID;
            actionInfo.toolFileName = "LiveTitle.exe";
            actionInfo.parameters = new Parameter[4];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/livetitledefault";
            actionInfo.parameters[0].value = "";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].name = "/xlastpath:";
            actionInfo.parameters[1].value = AddFilePath(jobID, xlastFilename);
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].name = "/lbs:";
            actionInfo.parameters[2].value = _lbServer;
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/matchsvr:";
            actionInfo.parameters[3].value = _matchServer;
            _report.Debug("Command Line: {0} {1} {2} {3} {4}",
                            actionInfo.toolFileName,
                            actionInfo.parameters[0].name + actionInfo.parameters[0].value,
                            actionInfo.parameters[1].name + actionInfo.parameters[1].value,
                            actionInfo.parameters[2].name + actionInfo.parameters[2].value,
                            actionInfo.parameters[3].name + actionInfo.parameters[3].value);

            return actionInfo;
        }

        protected ActionInfo RunLiveTitleDeploy(long jobID, string titleID, string xlastFilename)
        {
            ActionInfo actionInfo = new ActionInfo();

            actionInfo.jobId = jobID;
            actionInfo.toolFileName = "LiveTitle.exe";
            actionInfo.parameters = new Parameter[4];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/deploy";
            actionInfo.parameters[0].value = "";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].name = "/xlastpath:";
            actionInfo.parameters[1].value = AddFilePath(jobID, xlastFilename);
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].name = "/ltcpath:";
            actionInfo.parameters[2].value = titleID + "_ltc.xml";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/images";
            actionInfo.parameters[3].value = "";
            _report.Debug("Command Line: {0} {1} {2} {3} {4}",
                            actionInfo.toolFileName,
                            actionInfo.parameters[0].name + actionInfo.parameters[0].value,
                            actionInfo.parameters[1].name + actionInfo.parameters[1].value,
                            actionInfo.parameters[2].name + actionInfo.parameters[2].value,
                            actionInfo.parameters[3].name + actionInfo.parameters[3].value);

            return actionInfo;
        }

        protected ActionInfo RunLiveStatsDeploy(long jobID, string titleID)
        {
            ActionInfo actionInfo = new ActionInfo();

            actionInfo.jobId = jobID;
            actionInfo.toolFileName = "LiveStats.exe";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/deploylb";
            actionInfo.parameters[0].value = "";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].name = "/titleid:";
            actionInfo.parameters[1].value = titleID;
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].name = "/force";
            actionInfo.parameters[2].value = "";
            _report.Debug("Command Line: {0} {1} {2} {3}",
                            actionInfo.toolFileName,
                            actionInfo.parameters[0].name + actionInfo.parameters[0].value,
                            actionInfo.parameters[1].name + actionInfo.parameters[1].value,
                            actionInfo.parameters[2].name + actionInfo.parameters[2].value);

            return actionInfo;
        }

        protected ActionInfo RunLiveMatchDeploy(long jobID, string titleID)
        {
            ActionInfo actionInfo = new ActionInfo();

            actionInfo.jobId = jobID;
            actionInfo.toolFileName = "LiveMatch.exe";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/deploymatch";
            actionInfo.parameters[0].value = "";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].name = "/titleid:";
            actionInfo.parameters[1].value = titleID;
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].name = "/droptable";
            actionInfo.parameters[2].value = "";
            _report.Debug("Command Line: {0} {1} {2} {3}",
                            actionInfo.toolFileName,
                            actionInfo.parameters[0].name + actionInfo.parameters[0].value,
                            actionInfo.parameters[1].name + actionInfo.parameters[1].value,
                            actionInfo.parameters[2].name + actionInfo.parameters[2].value);

            return actionInfo;
        }

        protected ActionInfo RunLiveContentBuild(long jobID, string titleID, string cabFilename, string offerFilename, string offerID)
        {
            ActionInfo actionInfo = new ActionInfo();
            // /action:build /package:"E:\ToolsMgmtWork\1455\ffffab2d01000001.cab" /titleid:"FFFFAB2D" /site:1 /overwrite /offerfile:"E:\ToolsMgmtWork\1455\ffffab2d01000001.offer" /offerid:"FFFFAB2D01000001"
            actionInfo.jobId = jobID;
            actionInfo.toolFileName = "LiveContent.exe";
            actionInfo.parameters = new Parameter[7];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/action:";
            actionInfo.parameters[0].value = "build";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].name = "/site:";
            actionInfo.parameters[1].value = "1";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].name = "/overwrite";
            actionInfo.parameters[2].value = "";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/titleid:";
            actionInfo.parameters[3].value = titleID;
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/package:";
            actionInfo.parameters[4].value = AddFilePath(jobID, cabFilename);
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].name = "/offerfile:";
            actionInfo.parameters[5].value = AddFilePath(jobID, offerFilename);
            actionInfo.parameters[6] = new Parameter();
            actionInfo.parameters[6].name = "/offerid:";
            actionInfo.parameters[6].value = offerID;
            _report.Debug("Command Line: {0} {1} {2} {3} {4} {5} {6} {7}",
                            actionInfo.toolFileName,
                            actionInfo.parameters[0].name + actionInfo.parameters[0].value,
                            actionInfo.parameters[1].name + actionInfo.parameters[1].value,
                            actionInfo.parameters[2].name + actionInfo.parameters[2].value,
                            actionInfo.parameters[3].name + actionInfo.parameters[3].value,
                            actionInfo.parameters[4].name + actionInfo.parameters[4].value,
                            actionInfo.parameters[5].name + actionInfo.parameters[5].value,
                            actionInfo.parameters[6].name + actionInfo.parameters[6].value);

            return actionInfo;
        }

        protected ActionInfo RunLiveOfferProp(long jobID, string titleID, string offerFilename)
        {
            ActionInfo actionInfo = new ActionInfo();
            // -action:prop -file:"E:\ToolsMgmtWork\1455\ffffab2d01000001.offer" -titleid:"0xFFFFAB2D" -notransaction
            actionInfo.jobId = jobID;
            actionInfo.toolFileName = "LiveOffer.exe";
            actionInfo.parameters = new Parameter[4];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "-action:";
            actionInfo.parameters[0].value = "prop";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].name = "-titleid:";
            actionInfo.parameters[1].value = titleID;
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].name = "-file:";
            actionInfo.parameters[2].value = AddFilePath(jobID, offerFilename);
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "-notransaction";
            actionInfo.parameters[3].value = "";
            _report.Debug("Command Line: {0} {1} {2} {3} {4}",
                            actionInfo.toolFileName,
                            actionInfo.parameters[0].name + actionInfo.parameters[0].value,
                            actionInfo.parameters[1].name + actionInfo.parameters[1].value,
                            actionInfo.parameters[2].name + actionInfo.parameters[2].value,
                            actionInfo.parameters[3].name + actionInfo.parameters[3].value);

            return actionInfo;
        }

        protected ActionInfo CreateDirCdriveAction(long jobID)
        {
            ActionInfo actionInfo = new ActionInfo();

            actionInfo.jobId = jobID;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[4];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "C:\\";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/S";
            _report.Debug("Command Line: {0} {1} {2} {3} {4}",
                            actionInfo.toolFileName,
                            actionInfo.parameters[0].name,
                            actionInfo.parameters[1].value,
                            actionInfo.parameters[2].value,
                            actionInfo.parameters[3].name);

            return actionInfo;
        }

        protected ActionInfo CreateTypeOfferAction(long jobID, string fileName)
        {
            ActionInfo actionInfo = new ActionInfo();

            actionInfo.jobId = jobID;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "type";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = fileName;
            actionInfo.files = new string[1];
            actionInfo.files[0] = fileName;
            _report.Debug("Command Line: {0} {1} {2} {3}",
                            actionInfo.toolFileName,
                            actionInfo.parameters[0].name,
                            actionInfo.parameters[1].value,
                            actionInfo.parameters[2].value);

            return actionInfo;
        }

        protected void WaitForWorkCompleted(ulong[] workIds, ref int[] returnCodes, ref string[] outputs)
        {
            int totalJobs = workIds.Length;
            if ((returnCodes == null) || (returnCodes.Length != totalJobs))
                throw new ArgumentOutOfRangeException("returnCodes", "Output Array does not match the size of the input WorkIds array");
            if ((outputs == null) || (outputs.Length != totalJobs))
                throw new ArgumentOutOfRangeException("outputs", "Output Array does not match the size of the input WorkIds array");

            int jobIter = 0;
            bool[] workStatus = new bool[totalJobs];
            for (jobIter = 0; jobIter < totalJobs; jobIter++)
            {
                returnCodes[jobIter] = 0;
                outputs[jobIter] = "";
                workStatus[jobIter] = false;
            }

            _report.Debug("Wait for complete");
            bool anyJobsStillRunning = true;
            while (anyJobsStillRunning == true)
            {
                anyJobsStillRunning = false;
                string jobStatus = "Work Has Completed - ";
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    if (workStatus[jobIter] == false)
                    {
                        workStatus[jobIter] = GetWorkStatus(workIds[jobIter], ref returnCodes[jobIter], ref outputs[jobIter]);
                        if (workStatus[jobIter] == true)
                        {
                            _report.Info("Propping Title {0} Return Code: {1}", jobIter, returnCodes[jobIter]);
                            if (outputs[jobIter].Length != 0)
                            {
                                _report.Debug("Tools output:");
                                _report.Debug(outputs[jobIter]);
                            }
                        }
                        else
                        {
                            anyJobsStillRunning = true;
                        }
                    }
                    jobStatus += String.Format("\t{0}: {1};", jobIter, workStatus[jobIter]);
                }
                _report.Debug(jobStatus);

                System.Threading.Thread.Sleep(5000);
            }
        }

        protected JobState[] WaitForJobsCompleted(long[] jobIDs)
        {
            int totalJobs = jobIDs.Length;
            int jobIter = 0;
            JobState[] js = new JobState[totalJobs];
            bool[] jobComplete = new bool[totalJobs];
            for (jobIter = 0; jobIter < totalJobs; jobIter++)
            {
                jobComplete[jobIter] = false;
            }

            _report.Debug("Wait for complete");
            bool anyJobsStillRunning = true;
            while (anyJobsStillRunning == true)
            {
                anyJobsStillRunning = false;
                string debugStateString = "Current State - \n";
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    js[jobIter] = _service.GetJobStatus(jobIDs[jobIter]);
                    debugStateString += String.Format("{0}: {1};\t", jobIter, js[jobIter].ToString());
                    //Insert a new line every 10 jobs
                    if ((jobIter + 1) % 10 == 0)
                        debugStateString += "\n";
                    switch (js[jobIter])
                    {
                        case JobState.Canceled:
                            if (jobComplete[jobIter] == false)
                            {
                                jobComplete[jobIter] = true;
                                _report.Warn("Job " + jobIter.ToString() + " " + js[jobIter].ToString());
                            }
                            break;
                        case JobState.Complete:
                            if (jobComplete[jobIter] == false)
                            {
                                jobComplete[jobIter] = true;
                                _report.Success("Job " + jobIter.ToString() + " " + js[jobIter].ToString());
                            }
                            break;
                        case JobState.Failed:
                            if (jobComplete[jobIter] == false)
                            {
                                jobComplete[jobIter] = true;
                                _report.Error("Job " + jobIter.ToString() + " " + js[jobIter].ToString());
                            }
                            break;
                        default:
                            anyJobsStillRunning = true;
                            break;
                    }
                }
                _report.Debug(debugStateString);

                System.Threading.Thread.Sleep(5000);
            }

            return js;
        }

        protected JobState[] WaitForWorkandJobsCompleted(ulong[] workIds, ref int[] returnCodes, ref string[] outputs, long[] jobIDs)
        {
            int totalWork = workIds.Length;
            int totalJobs = jobIDs.Length;
            if ((returnCodes == null) || (returnCodes.Length != totalJobs))
                throw new ArgumentOutOfRangeException("returnCodes", "Output Array does not match the size of the input WorkIds array");
            if ((outputs == null) || (outputs.Length != totalJobs))
                throw new ArgumentOutOfRangeException("outputs", "Output Array does not match the size of the input WorkIds array");

            int jobIter = 0;
            bool[] workStatus = new bool[totalWork];
            for (jobIter = 0; jobIter < totalWork; jobIter++)
            {
                returnCodes[jobIter] = 0;
                outputs[jobIter] = "";
                workStatus[jobIter] = false;
            }
            JobState[] js = new JobState[totalJobs];
            bool[] jobComplete = new bool[totalJobs];
            for (jobIter = 0; jobIter < totalJobs; jobIter++)
            {
                jobComplete[jobIter] = false;
            }

            _report.Debug("Wait for complete");
            bool anyJobsStillRunning = true;
            while (anyJobsStillRunning == true)
            {
                anyJobsStillRunning = false;

                // Loop through workIds
                string jobStatus = "\nWork Completed - ";
                for (jobIter = 0; jobIter < totalWork; jobIter++)
                {
                    if (workStatus[jobIter] == false)
                    {
                        workStatus[jobIter] = GetWorkStatus(workIds[jobIter], ref returnCodes[jobIter], ref outputs[jobIter]);
                        if (workStatus[jobIter] == true)
                        {
                            _report.Info("Propping Title {0} Return Code: {1}", jobIter, returnCodes[jobIter]);
                            if (outputs[jobIter].Length != 0)
                            {
                                _report.Debug("Tools output:");
                                _report.Debug(outputs[jobIter]);
                            }
                        }
                        else
                        {
                            anyJobsStillRunning = true;
                        }
                    }
                    jobStatus += String.Format("\t{0}: {1};", jobIter, workStatus[jobIter]);
                }

                // Loop through JobIds
                jobStatus += " - Job State - ";
                for (jobIter = 0; jobIter < totalJobs; jobIter++)
                {
                    js[jobIter] = _service.GetJobStatus(jobIDs[jobIter]);
                    jobStatus += String.Format("\t{0}: {1};", jobIter, js[jobIter].ToString());
                    //Insert a new line every 10 jobs
                    if ((jobIter + 1) % 10 == 0)
                        jobStatus += "\n";
                    switch (js[jobIter])
                    {
                        case JobState.Canceled:
                            if (jobComplete[jobIter] == false)
                            {
                                jobComplete[jobIter] = true;
                                _report.Warn("Job " + jobIter.ToString() + " " + js[jobIter].ToString());
                            }
                            break;
                        case JobState.Complete:
                            if (jobComplete[jobIter] == false)
                            {
                                jobComplete[jobIter] = true;
                                _report.Success("Job " + jobIter.ToString() + " " + js[jobIter].ToString());
                            }
                            break;
                        case JobState.Failed:
                            if (jobComplete[jobIter] == false)
                            {
                                jobComplete[jobIter] = true;
                                _report.Error("Job " + jobIter.ToString() + " " + js[jobIter].ToString());
                            }
                            break;
                        default:
                            anyJobsStillRunning = true;
                            break;
                    }
                }
                _report.Debug(jobStatus);

                System.Threading.Thread.Sleep(5000);
            }

            return js;
        }

        public X509Certificate2 GetX509Certificate(String certificateName)
        {
            X509Certificate2Collection certificates;
            String nameType;

            X509Store personalStore = new X509Store(StoreName.My, StoreLocation.CurrentUser);
            personalStore.Open(OpenFlags.ReadOnly);

            if (certificateName.StartsWith("0x") || certificateName.StartsWith("0X"))
            {
                certificates = personalStore.Certificates.Find(X509FindType.FindByThumbprint, certificateName.Remove(0, 2), true);
                nameType = "thumbprint";
            }
            else if (certificateName.ToUpper().EndsWith(".CER"))
            {
                return (X509Certificate2)X509Certificate2.CreateFromCertFile(certificateName);
            }
            else
            {
                certificates = personalStore.Certificates.Find(X509FindType.FindBySubjectName, certificateName, true);
                nameType = "subject name";
            }
            personalStore.Close();

            if (certificates.Count < 1)
            {
                throw new ArgumentException("No certificates were found for the " + nameType + " " + certificateName);
            }

            if (certificates.Count > 1)
            {
                StringBuilder errorString = new StringBuilder();

                errorString.AppendLine("Found multiple certificates for the specified " + nameType + " " + certificateName);
                foreach (X509Certificate2 certificate in certificates)
                {
                    errorString.AppendFormat("{0} {1}", certificate.Thumbprint, certificate.GetNameInfo(X509NameType.SimpleName, false));
                    errorString.AppendLine();
                }

                throw new ArgumentException(errorString.ToString());
            }

            return certificates[0];
        }

        #endregion

        public ToolsMgmtBase()
        {
            _report = new Report("ToolsMgmtTest");
            XmlNode toolsMgmtDvtConfig = Global.Config.SelectSingleNode("descendant::ToolsMgmtDvt");

            XmlElement uploadPath = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("UploadPath");
            _uploadPath = Path.GetFullPath(uploadPath.InnerText);
            _report.Debug("_uploadPath = {0}", _uploadPath);

            XmlElement inputFilePath = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("InputFilePath");
            _inputFilePath = inputFilePath.InnerText;

            if(!Path.IsPathRooted(_inputFilePath))
            {
                Assembly a = Assembly.GetExecutingAssembly();
                _inputFilePath = Path.Combine(Path.GetDirectoryName(a.Location), _inputFilePath);
            }
            _report.Debug("_inputFilePath = {0}", _inputFilePath);

            _certificate = null;
            XmlElement clientCertificate = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("ClientCertificateFile");
            if(clientCertificate != null)
            {
                try
                {
                    _certificate = (X509Certificate) GetX509Certificate(clientCertificate.InnerText); 
                }
                catch(Exception e)
                {
                    throw new ApplicationException(string.Format("Failed to load client certificate {0} specified in config file.  Error = {1}.  Tests will likely fail if being performed through a WebSG.", clientCertificate.InnerText, e.Message), e);
                }
            }

            _toolsMgmtAddress = null;
            XmlElement toolsMgmtAddress = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("ToolsMgmtAddress");
            if(toolsMgmtAddress != null)
            {
                //  If cert is null, then we're talking directly to wctoolsmgmt on port 12000
                //  Otherwise we're going through websg on port 443
                int port = (_certificate == null ? 12000 : 443);

                IPAddress addr;

                try
                {
                    if(toolsMgmtAddress.InnerText.IndexOf(":") != -1)
                    {
                        string [] components = toolsMgmtAddress.InnerText.Split(':');
                        addr = IPAddress.Parse(components[0]);
                        port = Int32.Parse(components[1]);
                    }
                    else
                    {
                        addr = IPAddress.Parse(toolsMgmtAddress.InnerText);
                    }

                    _toolsMgmtAddress = new IPEndPoint(addr, port);
                    _report.Debug("_toolsMgmtAddress from XML = {0}", _toolsMgmtAddress.ToString());
                }
                catch(FormatException)
                {
                    IPHostEntry host = Dns.GetHostEntry(toolsMgmtAddress.InnerText);
                    if(host != null)
                    {
                        _toolsMgmtAddress = new IPEndPoint(host.AddressList[0], port);
                        _report.Debug("_toolsMgmtAddress from DNS = {0}", _toolsMgmtAddress.ToString());
                    }
                }
            }

            if (_toolsMgmtAddress == null)
            {
                _toolsMgmtAddress = Global.XEnv.GetVirtualInterface(VirtualInterface.wctoolsmgmt);
                _report.Debug("_toolsMgmtAddress from npdb = {0}", _toolsMgmtAddress.ToString());
            }

            if(_certificate != null)
                _service = new WCToolsMgmt(_toolsMgmtAddress, _certificate);
            else
                _service = new WCToolsMgmt(_toolsMgmtAddress);


            XmlElement lbsvrNode = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("LeaderboardServer");
            if (lbsvrNode != null)
            {
                _lbServer = lbsvrNode.InnerText;
                _report.Debug("Retrieved leaderboard server from XML: {0}", _lbServer);
            }
            else
            {
                string[] servers = Global.XEnv.GetServerListByInterface(Interface.lbsvr);
                if (servers.Length > 0)
                {
                    _lbServer = servers[0];
                    _report.Debug("Retrieved leaderboard server from NPDB: {0}", _lbServer);
                }
                else
                {
                    _report.Warn("The leaderboard server list is empty!");
                }
            }

            XmlElement matchsvrNode = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("MatchServer");
            if (matchsvrNode != null)
            {
                _matchServer = matchsvrNode.InnerText;
                _report.Debug("Retrieved match server from XML: {0}", _matchServer);
            }
            else
            {
                string[] servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                if (servers.Length > 0)
                {
                    _matchServer = servers[0];
                    _report.Debug("Retrieved match server from NPDB: {0}", _matchServer);
                }
                else
                {
                    _report.Warn("The matchmaking server list is empty!");
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\ToolsMgmt.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.server.webcache.toolsmgmt.test.dvt {
    using System.Diagnostics;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="ToolsMgmtSoap", Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ToolsMgmt : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback GetActionTableOperationCompleted;
        
        private System.Threading.SendOrPostCallback BeginWorkOperationCompleted;
        
        private System.Threading.SendOrPostCallback WorkFilesReadyOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetWorkStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddActionOperationCompleted;
        
        private System.Threading.SendOrPostCallback ExecuteJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback CancelJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetJobStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetActionStatusOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetActionResultOperationCompleted;
        
        private System.Threading.SendOrPostCallback CleanupJobOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetJobLogOperationCompleted;
        
        /// <remarks/>
        public ToolsMgmt() {
            this.Url = "http://paulram002:12000/wctoolsmgmt/toolsmgmt.asmx";
        }
        
        /// <remarks/>
        public event GetActionTableCompletedEventHandler GetActionTableCompleted;
        
        /// <remarks/>
        public event BeginWorkCompletedEventHandler BeginWorkCompleted;
        
        /// <remarks/>
        public event WorkFilesReadyCompletedEventHandler WorkFilesReadyCompleted;
        
        /// <remarks/>
        public event GetWorkStatusCompletedEventHandler GetWorkStatusCompleted;
        
        /// <remarks/>
        public event CreateJobCompletedEventHandler CreateJobCompleted;
        
        /// <remarks/>
        public event AddActionCompletedEventHandler AddActionCompleted;
        
        /// <remarks/>
        public event ExecuteJobCompletedEventHandler ExecuteJobCompleted;
        
        /// <remarks/>
        public event CancelJobCompletedEventHandler CancelJobCompleted;
        
        /// <remarks/>
        public event GetJobStatusCompletedEventHandler GetJobStatusCompleted;
        
        /// <remarks/>
        public event GetActionStatusCompletedEventHandler GetActionStatusCompleted;
        
        /// <remarks/>
        public event GetActionResultCompletedEventHandler GetActionResultCompleted;
        
        /// <remarks/>
        public event CleanupJobCompletedEventHandler CleanupJobCompleted;
        
        /// <remarks/>
        public event GetJobLogCompletedEventHandler GetJobLogCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionTable", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GetActionTable() {
            object[] results = this.Invoke("GetActionTable", new object[0]);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionTable(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionTable", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGetActionTable(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionTableAsync() {
            this.GetActionTableAsync(null);
        }
        
        /// <remarks/>
        public void GetActionTableAsync(object userState) {
            if ((this.GetActionTableOperationCompleted == null)) {
                this.GetActionTableOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionTableOperationCompleted);
            }
            this.InvokeAsync("GetActionTable", new object[0], this.GetActionTableOperationCompleted, userState);
        }
        
        private void OnGetActionTableOperationCompleted(object arg) {
            if ((this.GetActionTableCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionTableCompleted(this, new GetActionTableCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/BeginWork", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public BeginWorkResult BeginWork(BeginWorkInfo bwi) {
            object[] results = this.Invoke("BeginWork", new object[] {
                        bwi});
            return ((BeginWorkResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBeginWork(BeginWorkInfo bwi, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BeginWork", new object[] {
                        bwi}, callback, asyncState);
        }
        
        /// <remarks/>
        public BeginWorkResult EndBeginWork(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((BeginWorkResult)(results[0]));
        }
        
        /// <remarks/>
        public void BeginWorkAsync(BeginWorkInfo bwi) {
            this.BeginWorkAsync(bwi, null);
        }
        
        /// <remarks/>
        public void BeginWorkAsync(BeginWorkInfo bwi, object userState) {
            if ((this.BeginWorkOperationCompleted == null)) {
                this.BeginWorkOperationCompleted = new System.Threading.SendOrPostCallback(this.OnBeginWorkOperationCompleted);
            }
            this.InvokeAsync("BeginWork", new object[] {
                        bwi}, this.BeginWorkOperationCompleted, userState);
        }
        
        private void OnBeginWorkOperationCompleted(object arg) {
            if ((this.BeginWorkCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.BeginWorkCompleted(this, new BeginWorkCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/WorkFilesReady", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public WorkFilesReadyResult WorkFilesReady(WorkFilesReadyInfo wfri) {
            object[] results = this.Invoke("WorkFilesReady", new object[] {
                        wfri});
            return ((WorkFilesReadyResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginWorkFilesReady(WorkFilesReadyInfo wfri, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("WorkFilesReady", new object[] {
                        wfri}, callback, asyncState);
        }
        
        /// <remarks/>
        public WorkFilesReadyResult EndWorkFilesReady(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((WorkFilesReadyResult)(results[0]));
        }
        
        /// <remarks/>
        public void WorkFilesReadyAsync(WorkFilesReadyInfo wfri) {
            this.WorkFilesReadyAsync(wfri, null);
        }
        
        /// <remarks/>
        public void WorkFilesReadyAsync(WorkFilesReadyInfo wfri, object userState) {
            if ((this.WorkFilesReadyOperationCompleted == null)) {
                this.WorkFilesReadyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnWorkFilesReadyOperationCompleted);
            }
            this.InvokeAsync("WorkFilesReady", new object[] {
                        wfri}, this.WorkFilesReadyOperationCompleted, userState);
        }
        
        private void OnWorkFilesReadyOperationCompleted(object arg) {
            if ((this.WorkFilesReadyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.WorkFilesReadyCompleted(this, new WorkFilesReadyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetWorkStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetWorkStatusResult GetWorkStatus(GetWorkStatusInfo gwsi) {
            object[] results = this.Invoke("GetWorkStatus", new object[] {
                        gwsi});
            return ((GetWorkStatusResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetWorkStatus(GetWorkStatusInfo gwsi, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetWorkStatus", new object[] {
                        gwsi}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetWorkStatusResult EndGetWorkStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetWorkStatusResult)(results[0]));
        }
        
        /// <remarks/>
        public void GetWorkStatusAsync(GetWorkStatusInfo gwsi) {
            this.GetWorkStatusAsync(gwsi, null);
        }
        
        /// <remarks/>
        public void GetWorkStatusAsync(GetWorkStatusInfo gwsi, object userState) {
            if ((this.GetWorkStatusOperationCompleted == null)) {
                this.GetWorkStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetWorkStatusOperationCompleted);
            }
            this.InvokeAsync("GetWorkStatus", new object[] {
                        gwsi}, this.GetWorkStatusOperationCompleted, userState);
        }
        
        private void OnGetWorkStatusOperationCompleted(object arg) {
            if ((this.GetWorkStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetWorkStatusCompleted(this, new GetWorkStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CreateJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public long CreateJob(string description, out JobInfo jobInfo) {
            object[] results = this.Invoke("CreateJob", new object[] {
                        description});
            jobInfo = ((JobInfo)(results[1]));
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateJob(string description, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateJob", new object[] {
                        description}, callback, asyncState);
        }
        
        /// <remarks/>
        public long EndCreateJob(System.IAsyncResult asyncResult, out JobInfo jobInfo) {
            object[] results = this.EndInvoke(asyncResult);
            jobInfo = ((JobInfo)(results[1]));
            return ((long)(results[0]));
        }
        
        /// <remarks/>
        public void CreateJobAsync(string description) {
            this.CreateJobAsync(description, null);
        }
        
        /// <remarks/>
        public void CreateJobAsync(string description, object userState) {
            if ((this.CreateJobOperationCompleted == null)) {
                this.CreateJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateJobOperationCompleted);
            }
            this.InvokeAsync("CreateJob", new object[] {
                        description}, this.CreateJobOperationCompleted, userState);
        }
        
        private void OnCreateJobOperationCompleted(object arg) {
            if ((this.CreateJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateJobCompleted(this, new CreateJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/AddAction", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int AddAction(ActionInfo actionInfo) {
            object[] results = this.Invoke("AddAction", new object[] {
                        actionInfo});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddAction(ActionInfo actionInfo, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddAction", new object[] {
                        actionInfo}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndAddAction(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void AddActionAsync(ActionInfo actionInfo) {
            this.AddActionAsync(actionInfo, null);
        }
        
        /// <remarks/>
        public void AddActionAsync(ActionInfo actionInfo, object userState) {
            if ((this.AddActionOperationCompleted == null)) {
                this.AddActionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddActionOperationCompleted);
            }
            this.InvokeAsync("AddAction", new object[] {
                        actionInfo}, this.AddActionOperationCompleted, userState);
        }
        
        private void OnAddActionOperationCompleted(object arg) {
            if ((this.AddActionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddActionCompleted(this, new AddActionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/ExecuteJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int ExecuteJob(long jobId) {
            object[] results = this.Invoke("ExecuteJob", new object[] {
                        jobId});
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExecuteJob(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExecuteJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndExecuteJob(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void ExecuteJobAsync(long jobId) {
            this.ExecuteJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void ExecuteJobAsync(long jobId, object userState) {
            if ((this.ExecuteJobOperationCompleted == null)) {
                this.ExecuteJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnExecuteJobOperationCompleted);
            }
            this.InvokeAsync("ExecuteJob", new object[] {
                        jobId}, this.ExecuteJobOperationCompleted, userState);
        }
        
        private void OnExecuteJobOperationCompleted(object arg) {
            if ((this.ExecuteJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ExecuteJobCompleted(this, new ExecuteJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CancelJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CancelJob(long jobId) {
            this.Invoke("CancelJob", new object[] {
                        jobId});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelJob(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelJob(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CancelJobAsync(long jobId) {
            this.CancelJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void CancelJobAsync(long jobId, object userState) {
            if ((this.CancelJobOperationCompleted == null)) {
                this.CancelJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCancelJobOperationCompleted);
            }
            this.InvokeAsync("CancelJob", new object[] {
                        jobId}, this.CancelJobOperationCompleted, userState);
        }
        
        private void OnCancelJobOperationCompleted(object arg) {
            if ((this.CancelJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CancelJobCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetJobStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public JobState GetJobStatus(long jobId) {
            object[] results = this.Invoke("GetJobStatus", new object[] {
                        jobId});
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetJobStatus(long jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetJobStatus", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public JobState EndGetJobStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public void GetJobStatusAsync(long jobId) {
            this.GetJobStatusAsync(jobId, null);
        }
        
        /// <remarks/>
        public void GetJobStatusAsync(long jobId, object userState) {
            if ((this.GetJobStatusOperationCompleted == null)) {
                this.GetJobStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetJobStatusOperationCompleted);
            }
            this.InvokeAsync("GetJobStatus", new object[] {
                        jobId}, this.GetJobStatusOperationCompleted, userState);
        }
        
        private void OnGetJobStatusOperationCompleted(object arg) {
            if ((this.GetJobStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetJobStatusCompleted(this, new GetJobStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionStatus", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public JobState GetActionStatus(long jobId, int rank) {
            object[] results = this.Invoke("GetActionStatus", new object[] {
                        jobId,
                        rank});
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionStatus(long jobId, int rank, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionStatus", new object[] {
                        jobId,
                        rank}, callback, asyncState);
        }
        
        /// <remarks/>
        public JobState EndGetActionStatus(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((JobState)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionStatusAsync(long jobId, int rank) {
            this.GetActionStatusAsync(jobId, rank, null);
        }
        
        /// <remarks/>
        public void GetActionStatusAsync(long jobId, int rank, object userState) {
            if ((this.GetActionStatusOperationCompleted == null)) {
                this.GetActionStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionStatusOperationCompleted);
            }
            this.InvokeAsync("GetActionStatus", new object[] {
                        jobId,
                        rank}, this.GetActionStatusOperationCompleted, userState);
        }
        
        private void OnGetActionStatusOperationCompleted(object arg) {
            if ((this.GetActionStatusCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionStatusCompleted(this, new GetActionStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetActionResult", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ActionResult GetActionResult(long jobId, int rank) {
            object[] results = this.Invoke("GetActionResult", new object[] {
                        jobId,
                        rank});
            return ((ActionResult)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetActionResult(long jobId, int rank, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetActionResult", new object[] {
                        jobId,
                        rank}, callback, asyncState);
        }
        
        /// <remarks/>
        public ActionResult EndGetActionResult(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ActionResult)(results[0]));
        }
        
        /// <remarks/>
        public void GetActionResultAsync(long jobId, int rank) {
            this.GetActionResultAsync(jobId, rank, null);
        }
        
        /// <remarks/>
        public void GetActionResultAsync(long jobId, int rank, object userState) {
            if ((this.GetActionResultOperationCompleted == null)) {
                this.GetActionResultOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetActionResultOperationCompleted);
            }
            this.InvokeAsync("GetActionResult", new object[] {
                        jobId,
                        rank}, this.GetActionResultOperationCompleted, userState);
        }
        
        private void OnGetActionResultOperationCompleted(object arg) {
            if ((this.GetActionResultCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetActionResultCompleted(this, new GetActionResultCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/CleanupJob", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool CleanupJob(ulong jobId) {
            object[] results = this.Invoke("CleanupJob", new object[] {
                        jobId});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCleanupJob(ulong jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CleanupJob", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndCleanupJob(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public void CleanupJobAsync(ulong jobId) {
            this.CleanupJobAsync(jobId, null);
        }
        
        /// <remarks/>
        public void CleanupJobAsync(ulong jobId, object userState) {
            if ((this.CleanupJobOperationCompleted == null)) {
                this.CleanupJobOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCleanupJobOperationCompleted);
            }
            this.InvokeAsync("CleanupJob", new object[] {
                        jobId}, this.CleanupJobOperationCompleted, userState);
        }
        
        private void OnCleanupJobOperationCompleted(object arg) {
            if ((this.CleanupJobCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CleanupJobCompleted(this, new CleanupJobCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/ToolsMgmt/GetJobLog", RequestNamespace="http://websvc.xboxlive.com/ToolsMgmt/", ResponseNamespace="http://websvc.xboxlive.com/ToolsMgmt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public int GetJobLog(int jobId, out JobLogEntry[] jobLog) {
            object[] results = this.Invoke("GetJobLog", new object[] {
                        jobId});
            jobLog = ((JobLogEntry[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetJobLog(int jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetJobLog", new object[] {
                        jobId}, callback, asyncState);
        }
        
        /// <remarks/>
        public int EndGetJobLog(System.IAsyncResult asyncResult, out JobLogEntry[] jobLog) {
            object[] results = this.EndInvoke(asyncResult);
            jobLog = ((JobLogEntry[])(results[1]));
            return ((int)(results[0]));
        }
        
        /// <remarks/>
        public void GetJobLogAsync(int jobId) {
            this.GetJobLogAsync(jobId, null);
        }
        
        /// <remarks/>
        public void GetJobLogAsync(int jobId, object userState) {
            if ((this.GetJobLogOperationCompleted == null)) {
                this.GetJobLogOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetJobLogOperationCompleted);
            }
            this.InvokeAsync("GetJobLog", new object[] {
                        jobId}, this.GetJobLogOperationCompleted, userState);
        }
        
        private void OnGetJobLogOperationCompleted(object arg) {
            if ((this.GetJobLogCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetJobLogCompleted(this, new GetJobLogCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class BeginWorkInfo {
        
        private uint workTypeField;
        
        private string titleIdField;
        
        /// <remarks/>
        public uint workType {
            get {
                return this.workTypeField;
            }
            set {
                this.workTypeField = value;
            }
        }
        
        /// <remarks/>
        public string titleId {
            get {
                return this.titleIdField;
            }
            set {
                this.titleIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class JobLogEntry {
        
        private System.DateTime loggedField;
        
        private string logField;
        
        /// <remarks/>
        public System.DateTime logged {
            get {
                return this.loggedField;
            }
            set {
                this.loggedField = value;
            }
        }
        
        /// <remarks/>
        public string log {
            get {
                return this.logField;
            }
            set {
                this.logField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ActionResult {
        
        private JobState stateField;
        
        private int returnCodeField;
        
        private string consoleOutputField;
        
        /// <remarks/>
        public JobState state {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public int returnCode {
            get {
                return this.returnCodeField;
            }
            set {
                this.returnCodeField = value;
            }
        }
        
        /// <remarks/>
        public string consoleOutput {
            get {
                return this.consoleOutputField;
            }
            set {
                this.consoleOutputField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public enum JobState {
        
        /// <remarks/>
        Created,
        
        /// <remarks/>
        Pending,
        
        /// <remarks/>
        Download,
        
        /// <remarks/>
        Running,
        
        /// <remarks/>
        Canceled,
        
        /// <remarks/>
        Complete,
        
        /// <remarks/>
        Failed,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class Parameter {
        
        private string nameField;
        
        private string valueField;
        
        /// <remarks/>
        public string name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string value {
            get {
                return this.valueField;
            }
            set {
                this.valueField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class ActionInfo {
        
        private long jobIdField;
        
        private string toolFileNameField;
        
        private Parameter[] parametersField;
        
        private string[] filesField;
        
        /// <remarks/>
        public long jobId {
            get {
                return this.jobIdField;
            }
            set {
                this.jobIdField = value;
            }
        }
        
        /// <remarks/>
        public string toolFileName {
            get {
                return this.toolFileNameField;
            }
            set {
                this.toolFileNameField = value;
            }
        }
        
        /// <remarks/>
        public Parameter[] parameters {
            get {
                return this.parametersField;
            }
            set {
                this.parametersField = value;
            }
        }
        
        /// <remarks/>
        public string[] files {
            get {
                return this.filesField;
            }
            set {
                this.filesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class JobInfo {
        
        private long jobIdField;
        
        private ulong spaceAvailableField;
        
        private string uploadPathField;
        
        /// <remarks/>
        public long jobId {
            get {
                return this.jobIdField;
            }
            set {
                this.jobIdField = value;
            }
        }
        
        /// <remarks/>
        public ulong spaceAvailable {
            get {
                return this.spaceAvailableField;
            }
            set {
                this.spaceAvailableField = value;
            }
        }
        
        /// <remarks/>
        public string uploadPath {
            get {
                return this.uploadPathField;
            }
            set {
                this.uploadPathField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class GetWorkStatusResult {
        
        private bool workCompleteField;
        
        private int returnCodeField;
        
        private string consoleOutputField;
        
        /// <remarks/>
        public bool workComplete {
            get {
                return this.workCompleteField;
            }
            set {
                this.workCompleteField = value;
            }
        }
        
        /// <remarks/>
        public int returnCode {
            get {
                return this.returnCodeField;
            }
            set {
                this.returnCodeField = value;
            }
        }
        
        /// <remarks/>
        public string consoleOutput {
            get {
                return this.consoleOutputField;
            }
            set {
                this.consoleOutputField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class GetWorkStatusInfo {
        
        private ulong workIdField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class WorkFilesReadyResult {
        
        private bool successField;
        
        /// <remarks/>
        public bool success {
            get {
                return this.successField;
            }
            set {
                this.successField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class WorkFilesReadyInfo {
        
        private ulong workIdField;
        
        private string relativePathField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
        
        /// <remarks/>
        public string relativePath {
            get {
                return this.relativePathField;
            }
            set {
                this.relativePathField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/ToolsMgmt/")]
    public partial class BeginWorkResult {
        
        private ulong workIdField;
        
        private ulong spaceAvailableField;
        
        /// <remarks/>
        public ulong workId {
            get {
                return this.workIdField;
            }
            set {
                this.workIdField = value;
            }
        }
        
        /// <remarks/>
        public ulong spaceAvailable {
            get {
                return this.spaceAvailableField;
            }
            set {
                this.spaceAvailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionTableCompletedEventHandler(object sender, GetActionTableCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionTableCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionTableCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BeginWorkCompletedEventHandler(object sender, BeginWorkCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BeginWorkCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal BeginWorkCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public BeginWorkResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((BeginWorkResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void WorkFilesReadyCompletedEventHandler(object sender, WorkFilesReadyCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class WorkFilesReadyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal WorkFilesReadyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public WorkFilesReadyResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((WorkFilesReadyResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetWorkStatusCompletedEventHandler(object sender, GetWorkStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetWorkStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetWorkStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetWorkStatusResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetWorkStatusResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateJobCompletedEventHandler(object sender, CreateJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CreateJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public long Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public JobInfo jobInfo {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobInfo)(this.results[1]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddActionCompletedEventHandler(object sender, AddActionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddActionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddActionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ExecuteJobCompletedEventHandler(object sender, ExecuteJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ExecuteJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ExecuteJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelJobCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetJobStatusCompletedEventHandler(object sender, GetJobStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetJobStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetJobStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public JobState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionStatusCompletedEventHandler(object sender, GetActionStatusCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public JobState Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobState)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetActionResultCompletedEventHandler(object sender, GetActionResultCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetActionResultCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetActionResultCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ActionResult Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ActionResult)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CleanupJobCompletedEventHandler(object sender, CleanupJobCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CleanupJobCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal CleanupJobCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetJobLogCompletedEventHandler(object sender, GetJobLogCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetJobLogCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetJobLogCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
        
        /// <remarks/>
        public JobLogEntry[] jobLog {
            get {
                this.RaiseExceptionIfNecessary();
                return ((JobLogEntry[])(this.results[1]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ToolsMgmtTest\ToolsMgmtDvt.cs ===
using System;
using System.IO;
using System.Net;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace xonline.server.webcache.toolsmgmt.test.dvt
{
	/// <summary>
	/// Summary description for ToolsMgmtDvt.
	/// </summary>
	/// 
    [TestGroup, Owner("mifish"), TestFrequency("Daily"), EnvRequirement("Deprecated")]
	public class ToolsMgmtDvt : TestNode
	{
        private string _uploadPath;
        private string _inputFilePath;
        private IPEndPoint _toolsMgmtAddress;
        private X509Certificate _certificate;
        private WCToolsMgmt _service;

        public string UploadPath
        {
            get
            {
                return _uploadPath;
            }
        }

        public string InputFilePath
        {
            get
            {
                return _inputFilePath;
            }
        }

        public IPEndPoint ToolsMgmtAddress
        {
            get
            {
                return _toolsMgmtAddress;
            }
        }

        public X509Certificate ClientCertificate
        {
            get { return _certificate; }
            set { _certificate = value; }
        }

        #region ToolsMgmt API wrapper methods

        private string GetActionTable()
        {
            string xmlActionTable = _service.GetActionTable();

            ValueCheck.TestNotNull("ActionTable", xmlActionTable);

            return xmlActionTable;
        }

        private ulong BeginWork(string titleid, uint workType)
        {
            BeginWorkInfo bwi = new BeginWorkInfo();
            bwi.titleId = titleid;
            bwi.workType = workType;

            BeginWorkResult bwr = _service.BeginWork(bwi);

            ValueCheck.TestNotNull("BeginWorkResult", bwr);
            ValueCheck.TestNonZero("Work ID", bwr.workId);

            return bwr.workId;
        }

        private bool WorkFilesReady(ulong workId, string relativePath)
        {
            WorkFilesReadyInfo wfri = new WorkFilesReadyInfo();

            wfri.workId = workId;
            wfri.relativePath = "relative";
            WorkFilesReadyResult wfrr = _service.WorkFilesReady(wfri);

            ValueCheck.TestNotNull("WorkFilesReadyResult", wfrr);
            ValueCheck.IsTrue(wfrr.success, "WorkFilesReadyResult.success");

            return wfrr.success;
        }

        private bool GetWorkStatus(ulong workId, ref int returnCode, ref string output)
        {
            output = "";

            GetWorkStatusInfo gwsi = new GetWorkStatusInfo();
            gwsi.workId = workId; // This is invalid by virtue of the leading 2200, which represents year

            GetWorkStatusResult gwsr = _service.GetWorkStatus(gwsi);

            if(gwsr.workComplete)
            {
                returnCode = gwsr.returnCode;
                output = gwsr.consoleOutput;
            }

            return gwsr.workComplete;
        }

        private void PropWorkFile(string file, string relativePath)
        {
            if( !Directory.Exists(Path.Combine(UploadPath, relativePath)) )
                Directory.CreateDirectory(Path.Combine(UploadPath, relativePath));
            File.Copy(Path.Combine(InputFilePath, file), Path.Combine(Path.Combine(UploadPath, relativePath), file), true);
        }

        /// <summary>
        /// Clears the titlevault title of offer files so we can start at a clean baseline and
        /// force LiveContent to read from ZDefault.
        /// </summary>
        /// <param name="titleID">TitleID to be cleared of offer files.</param>
        private void ClearOffers(string titleID)
        {
            string titlePath = Path.Combine(Config.GetSetting(Setting.titlevault_root),titleID);
            
            string[] offers = Directory.GetFiles(titlePath, "*.offer");
            foreach (string offer in offers)
            {
                File.Delete(Path.Combine(titlePath, offer));
            }
        }

        #endregion

        public ToolsMgmtDvt()
        {
            XmlNode toolsMgmtDvtConfig = Global.Config.SelectSingleNode("descendant::ToolsMgmtDvt");

            XmlElement uploadPath = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("UploadPath");
            _uploadPath = Path.GetFullPath(uploadPath.InnerText);

            XmlElement inputFilePath = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("InputFilePath");
            _inputFilePath = inputFilePath.InnerText;

            if(!Path.IsPathRooted(_inputFilePath))
            {
                Assembly a = Assembly.GetExecutingAssembly();
                _inputFilePath = Path.Combine(Path.GetDirectoryName(a.Location), _inputFilePath);
            }

            _certificate = null;
            XmlElement clientCertificate = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("ClientCertificateFile");
            if(clientCertificate != null)
            {
                try
                {
                    _certificate = X509Certificate.CreateFromCertFile(clientCertificate.InnerText); 
                }
                catch(Exception e)
                {
                    throw new ApplicationException(string.Format("Failed to load client certificate {0} specified in config file.  Error = {1}.  Tests will likely fail if being performed through a WebSG.", clientCertificate.InnerText, e.Message), e);
                }
            }

            _toolsMgmtAddress = null;
            XmlElement toolsMgmtAddress = (XmlElement)toolsMgmtDvtConfig.SelectSingleNode("ToolsMgmtAddress");
            if(toolsMgmtAddress != null)
            {
                //  If cert is null, then we're talking directly to wctoolsmgmt on port 12000
                //  Otherwise we're going through websg on port 443
                int port = (_certificate == null ? 12000 : 443);

                IPAddress addr;

                try
                {
                    if(toolsMgmtAddress.InnerText.IndexOf(":") != -1)
                    {
                        string [] components = toolsMgmtAddress.InnerText.Split(':');
                        addr = IPAddress.Parse(components[0]);
                        port = Int32.Parse(components[1]);
                    }
                    else
                    {
                        addr = IPAddress.Parse(toolsMgmtAddress.InnerText);
                    }

                    _toolsMgmtAddress = new IPEndPoint(addr, port);
                }
                catch(FormatException)
                {
                    IPHostEntry host = Dns.GetHostEntry(toolsMgmtAddress.InnerText);
                    if(host != null)
                    {
                        _toolsMgmtAddress = new IPEndPoint(host.AddressList[0], port);
                    }
                }
            }

            if(_toolsMgmtAddress == null)
                _toolsMgmtAddress = Global.XEnv.GetVirtualInterface(VirtualInterface.wctoolsmgmt);

            if(_certificate != null)
                _service = new WCToolsMgmt(_toolsMgmtAddress, _certificate);
            else
                _service = new WCToolsMgmt(_toolsMgmtAddress);

        }

        [TestCase]
        public void GetActionTable_Pos()
        {
            GetActionTable();
        }

        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public void BeginWork_Neg_BadWorkType()
        {
            BeginWork("ffff400a", 100);
            
            //  This is supposed to throw an exception, no more checking needed
        }

        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public void WorkFilesReady_Neg_InvalidWorkID()
        {
            WorkFilesReady(2200021414431358, "whatver");
        }

        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public void GetWorkStatus_Neg_InvalidWorkID()
        {
            int returnCode = 0;
            string output = "";

            GetWorkStatus(2200021414431358, ref returnCode, ref output);
        }

        /// <summary>
        /// Normal XLAST+PGNs submission that should succeed.
        /// </summary>
        [TestCase]
        public void XlastSubmission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 1);

            //  Copy files to 'fake' staging directory
            PropWorkFile("apdvt.xlast", "relative");
            PropWorkFile("another.png", "relative");
            PropWorkFile("ach_img.png", "relative");
            PropWorkFile("titleimg.png", "relative");

            //  Tell widget to start doing work

            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }

        /// <summary>
        /// Submitting an XLAST+PNGs work type, but with wrong file types.
        /// </summary>
        [TestCase]
        public void XlastSubmission_Neg_UnknownFileTypes()
        {
            ulong workId = BeginWork("ffff400a", 1);

            //  Copy files to 'fake' staging directory
            PropWorkFile("ach_img.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }

        [TestCase]
        public void InGameContent_DefaultOffer_Submission_Pos()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");
            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("fffe07f100200001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void TrailerBothContent_DefaultOffer_Submission_Neg()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");

            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void TrailerLoOnlyContent_DefaultOffer_Submission_Neg()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");

            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100002.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void TrailerHiOnlyContent_DefaultOffer_Submission_Neg()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");

            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100003.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void ThemeContent_DefaultOffer_Submission_Pos()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");

            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100500001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void GamerPicsContent_DefaultOffer_Submission_Pos()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");

            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100400001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void DemoContent_DefaultOffer_Submission_Pos()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");

            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100300001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void ArcadeContent_DefaultOffer_Submission_Pos()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");

            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100600001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void VideoContent_DefaultOffer_Submission_Neg()
        {
            // set at baseline so that we use Default offer
            ClearOffers("fffe07f1");

            ulong workId = BeginWork("fffe07f1", 2);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100700001.cab", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }

        [TestCase]
        public void InGameContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("fffe07f100200001.cab", "relative");
            PropWorkFile("fffe07f100200001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void TrailerBothContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 4);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100001.cab", "relative");
            PropWorkFile("fffe07f100100001.offer", "relative");
            PropWorkFile("fffe07f100100002.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void TrailerLoOnlyContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100002.cab", "relative");
            PropWorkFile("fffe07f100100002.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void TrailerHiOnlyContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100100003.cab", "relative");
            PropWorkFile("fffe07f100100001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void ThemeContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100500001.cab", "relative");
            PropWorkFile("fffe07f100500001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void GamerPicsContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100400001.cab", "relative");
            PropWorkFile("fffe07f100400001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void DemoContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100300001.cab", "relative");
            PropWorkFile("fffe07f100300001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void ArcadeContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100600001.cab", "relative");
            PropWorkFile("fffe07f100600001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }
    
        [TestCase]
        public void VideoContent_Submission_Pos()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100700001.cab", "relative");
            PropWorkFile("fffe07f100700001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode == 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }

        [TestCase]
        public void VideoContent_Submission_Neg_BadXML()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100700001.cab", "relative");
            PropWorkFile("FFFE07F100700001malformed.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }

        [TestCase]
        public void VideoContent_Submission_Neg_BadTitle()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("FFFE07F100700001.cab", "relative");
            PropWorkFile("FFFE07F100700001wrongtitle.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }

        [TestCase]
        public void VideoContent_Submission_Neg_BadCab()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Copy files to 'fake' staging directory
            PropWorkFile("fffe07f100700001corrupt.cab", "relative");
            PropWorkFile("FFFE07F100700001.offer", "relative");
            PropWorkFile("0xffffffffffffffff.png", "relative");

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }

        [TestCase(typeof(System.Web.Services.Protocols.SoapException))]
        public void VideoContent_Submission_Neg_NoFiles()
        {
            ulong workId = BeginWork("fffe07f1", 3);

            //  Tell widget to start doing work
            WorkFilesReady(workId, "relative");

            //  Get the results
            int returnCode = 0;
            string output = "";
            while(!GetWorkStatus(workId, ref returnCode, ref output))
            {
                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Return Code: {0}", returnCode);
            if (output.Length != 0)
            {
                Console.WriteLine("Tools output:");
                Console.WriteLine(output);
            }

            ValueCheck.IsTrue(returnCode != 0, "GetWorkStatusResult.returnCode");
            ValueCheck.TestNonZero("GetWorkStatusResult.consoleOutput.Length", output.Length);
        }

        [TestCase]
        public void DirCXblob_Pos()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            ActionInfo actionInfo;
            long jobId;

            jobId = Widget.CreateJob("test job", out jobInfo);
            PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
            Console.WriteLine("JobId: {0}", jobId);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[6];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/S";
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].value = "C:\\XBLOB\\";
            int rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "type";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
            actionInfo.files = new string[1];
            actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
            rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            int execResult = Widget.ExecuteJob(jobId);
            Console.WriteLine("ExecuteJob() returned : {0}", execResult);

            JobState js;

            Console.WriteLine("Wait for complete");
            while (true)
            {
                js = Widget.GetJobStatus(jobId);
                if (js == JobState.Canceled)
                    break;
                if (js == JobState.Complete)
                    break;
                if (js == JobState.Failed)
                    break;
                Console.WriteLine("State: {0}", js.ToString());

                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Completed");
            ActionResult result = Widget.GetActionResult(jobId, 0);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);
            result = Widget.GetActionResult(jobId, 1);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);

            Widget.CleanupJob((ulong)jobId);
        }

        [TestCase]
        public void CreateJobTest_Pos()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            long jobId;

            jobId = Widget.CreateJob("test job", out jobInfo);
            Console.WriteLine("JobId: {0}", jobId);

            Widget.CleanupJob((ulong) jobId);
        }

        [TestCase]
        public void CreateJobTest_Stress()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            int iter, maxJobs;
            long[] jobId;

            maxJobs = 100;
            jobId = new long[maxJobs];

            // Create Loop
            for (iter = 0; iter < maxJobs; ++iter)
            {
                jobId[iter] = Widget.CreateJob("test job", out jobInfo);
                Console.WriteLine("JobId: {0}", jobId[iter]);
            }

            // Cleanup Loop
            for (iter = 0; iter < maxJobs; ++iter)
            {
                Widget.CleanupJob((ulong)jobId[iter]);
                Console.WriteLine("Cleanup JobId: {0}", jobId[iter]);
            }
        }

        [TestCase]
        public void ExecuteNoAction_Neg()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            long jobId;

            jobId = Widget.CreateJob("test job", out jobInfo);
            Console.WriteLine("JobId: {0}", jobId);

            int execResult = Widget.ExecuteJob(jobId);
            Console.WriteLine("ExecuteJob() returned : {0}", execResult);
            ValueCheck.IsTrue(execResult != 0, "ExecuteJob.returnCode");

            Widget.CleanupJob((ulong) jobId);
        }

        [TestCase]
        public void AddActionAfterExecute_Neg()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            ActionInfo actionInfo;
            long jobId;

            jobId = Widget.CreateJob("test job", out jobInfo);
            PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
            Console.WriteLine("JobId: {0}", jobId);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[6];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/S";
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].value = "C:\\XBLOB\\";
            int rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            int execResult = Widget.ExecuteJob(jobId);
            Console.WriteLine("ExecuteJob() returned : {0}", execResult);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "type";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
            actionInfo.files = new string[1];
            actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
            rank = Widget.AddAction(actionInfo);
            ValueCheck.IsTrue(rank == -1, "AddAction.returnCode");
            Console.WriteLine("rank: {0}", rank);

            JobState js;

            Console.WriteLine("Wait for complete");
            while (true)
            {
                js = Widget.GetJobStatus(jobId);
                if (js == JobState.Canceled)
                    break;
                if (js == JobState.Complete)
                    break;
                if (js == JobState.Failed)
                    break;
                Console.WriteLine("State: {0}", js.ToString());

                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Completed");
//            ActionResult result = Widget.GetActionResult(jobId, 0);
//            Console.WriteLine("ReturnCode: {0}", result.returnCode);
//            Console.WriteLine("Output:");
//            Console.WriteLine(result.consoleOutput);
//            result = Widget.GetActionResult(jobId, 1);
//            Console.WriteLine("ReturnCode: {0}", result.returnCode);
//            Console.WriteLine("Output:");
//            Console.WriteLine(result.consoleOutput);

            Widget.CleanupJob((ulong)jobId);
        }

        [TestCase]
        public void MultiJob_Pos()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo1, jobInfo2;
            ActionInfo actionInfo;
            long jobId1, jobId2;

            jobId1 = Widget.CreateJob("test job 1", out jobInfo1);
            jobId2 = Widget.CreateJob("test job 1", out jobInfo2);
            PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId1.ToString());
            Console.WriteLine("JobId: {0}", jobId1);
            Console.WriteLine("JobId: {0}", jobId2);

            // Job 1 Action 1
            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId1;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[6];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/S";
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].value = "C:\\XBLOB\\";
            int rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            // Job 2 Action 1
            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId2;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[6];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/S";
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].value = "C:\\XBLOB\\";
            rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            // Job 2 Action 2
            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId2;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "type";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
            actionInfo.files = new string[1];
            actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
            rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            int execResult = Widget.ExecuteJob(jobId2);
            Console.WriteLine("ExecuteJob(2) returned : {0}", execResult);

            // Job 1 Action 2
            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId1;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "type";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
            actionInfo.files = new string[1];
            actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
            rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            execResult = Widget.ExecuteJob(jobId1);
            Console.WriteLine("ExecuteJob(1) returned : {0}", execResult);

            JobState js;

            Console.WriteLine("Wait for complete");
            while (true)
            {
                js = Widget.GetJobStatus(jobId2);
                if (js == JobState.Canceled)
                    break;
                if (js == JobState.Complete)
                    break;
                if (js == JobState.Failed)
                    break;
                Console.WriteLine("State: {0}", js.ToString());

                System.Threading.Thread.Sleep(1000);
            }
            Console.WriteLine("Job 2 Completed");
/*            ActionResult result = Widget.GetActionResult(jobId2, 0);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);
            result = Widget.GetActionResult(jobId2, 1);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);
*/            
            while (true)
            {
                js = Widget.GetJobStatus(jobId1);
                if (js == JobState.Canceled)
                    break;
                if (js == JobState.Complete)
                    break;
                if (js == JobState.Failed)
                    break;
                Console.WriteLine("State: {0}", js.ToString());

                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Completed");
/*            result = Widget.GetActionResult(jobId1, 0);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);
            result = Widget.GetActionResult(jobId1, 1);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);
*/
            Widget.CleanupJob((ulong)jobId1);
            Widget.CleanupJob((ulong)jobId2);
        }

        [TestCase]
        public void MultiJob_Stress()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo1, jobInfo2;
            ActionInfo actionInfo;
            long[] jobId1, jobId2;
            ActionResult result;

            int maxJobs = 100;
            jobId1 = new long[maxJobs];
            jobId2 = new long[maxJobs];

            // Create Loop
            for (int iter = 0; iter < maxJobs; ++iter)
            {
                Console.WriteLine("Starting Loop {0}", iter);

                jobId1[iter] = Widget.CreateJob("test job 1", out jobInfo1);
                jobId2[iter] = Widget.CreateJob("test job 1", out jobInfo2);
                PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId1[iter].ToString());
                Console.WriteLine("JobId 1: {0}", jobId1[iter]);
                Console.WriteLine("JobId 2: {0}", jobId2[iter]);

                // Job 1 Action 1
                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId1[iter];
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[6];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].name = "/S";
                actionInfo.parameters[5] = new Parameter();
                actionInfo.parameters[5].value = "C:\\XBLOB\\";
                int rank = Widget.AddAction(actionInfo);
                Console.WriteLine("rank: {0}", rank);

                // Job 2 Action 1
                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId2[iter];
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[6];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "dir";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "test.txt";
                actionInfo.parameters[3] = new Parameter();
                actionInfo.parameters[3].name = "/B";
                actionInfo.parameters[4] = new Parameter();
                actionInfo.parameters[4].name = "/S";
                actionInfo.parameters[5] = new Parameter();
                actionInfo.parameters[5].value = "C:\\XBLOB\\";
                rank = Widget.AddAction(actionInfo);
                Console.WriteLine("rank: {0}", rank);

                // Job 2 Action 2
                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId2[iter];
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[3];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "type";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                actionInfo.files = new string[1];
                actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                rank = Widget.AddAction(actionInfo);
                Console.WriteLine("rank: {0}", rank);

                int execResult = Widget.ExecuteJob(jobId2[iter]);
                Console.WriteLine("ExecuteJob(2) returned : {0}", execResult);

                // Job 1 Action 2
                actionInfo = new ActionInfo();
                actionInfo.jobId = jobId1[iter];
                actionInfo.toolFileName = "cmd";
                actionInfo.parameters = new Parameter[3];
                actionInfo.parameters[0] = new Parameter();
                actionInfo.parameters[0].name = "/C";
                actionInfo.parameters[1] = new Parameter();
                actionInfo.parameters[1].value = "type";
                actionInfo.parameters[2] = new Parameter();
                actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
                actionInfo.files = new string[1];
                actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
                rank = Widget.AddAction(actionInfo);
                Console.WriteLine("rank: {0}", rank);

                execResult = Widget.ExecuteJob(jobId1[iter]);
                Console.WriteLine("ExecuteJob(1) returned : {0}", execResult);

                JobState js;

                Console.WriteLine("Wait for complete");
                while (true)
                {
                    js = Widget.GetJobStatus(jobId2[iter]);
                    if (js == JobState.Canceled)
                        break;
                    if (js == JobState.Complete)
                        break;
                    if (js == JobState.Failed)
                        break;
                    Console.WriteLine("State: {0}", js.ToString());

                    System.Threading.Thread.Sleep(1000);
                }
                Console.WriteLine("Job 2 Completed");
/*                ActionResult result = Widget.GetActionResult(jobId2[iter], 0);
                Console.WriteLine("ReturnCode: {0}", result.returnCode);
                Console.WriteLine("Output:");
                Console.WriteLine(result.consoleOutput);
                result = Widget.GetActionResult(jobId2[iter], 1);
                Console.WriteLine("ReturnCode: {0}", result.returnCode);
                Console.WriteLine("Output:");
                Console.WriteLine(result.consoleOutput);
*/
                while (true)
                {
                    js = Widget.GetJobStatus(jobId1[iter]);
                    if (js == JobState.Canceled)
                        break;
                    if (js == JobState.Complete)
                        break;
                    if (js == JobState.Failed)
                        break;
                    Console.WriteLine("State: {0}", js.ToString());

                    System.Threading.Thread.Sleep(1000);
                }

                Console.WriteLine("Job 1 Completed");
                result = Widget.GetActionResult(jobId1[iter], 0);
                Console.WriteLine("ReturnCode: {0}", result.returnCode);
                Console.WriteLine("Output:");
                Console.WriteLine(result.consoleOutput);
                result = Widget.GetActionResult(jobId1[iter], 1);
                Console.WriteLine("ReturnCode: {0}", result.returnCode);
                Console.WriteLine("Output:");
                Console.WriteLine(result.consoleOutput);

                Widget.CleanupJob((ulong)jobId1[iter]);
                Widget.CleanupJob((ulong)jobId2[iter]);

                Console.WriteLine("Ending Loop {0}", iter);
            }
        }

        [TestCase]
        public void RepeatedExecute_Neg()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            ActionInfo actionInfo;
            long jobId;

            jobId = Widget.CreateJob("test job", out jobInfo);
            PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
            Console.WriteLine("JobId: {0}", jobId);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[6];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/S";
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].value = "C:\\XBLOB\\";
            int rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);
                                    
            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[3];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "type";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "FFFE07F100700001wrongtitle.offer";
            actionInfo.files = new string[1];
            actionInfo.files[0] = "FFFE07F100700001wrongtitle.offer";
            rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            int execResult = Widget.ExecuteJob(jobId);
            Console.WriteLine("ExecuteJob() returned : {0}", execResult);
            ValueCheck.IsTrue(execResult == 0, "ExecuteJob.returnCode");

            execResult = Widget.ExecuteJob(jobId);
            Console.WriteLine("Calling ExecuteJob() again returned : {0}", execResult);
            ValueCheck.IsTrue(execResult != 0, "ExecuteJob.returnCode");

            JobState js;

            Console.WriteLine("Wait for complete");
            while (true)
            {
                js = Widget.GetJobStatus(jobId);
                if (js == JobState.Canceled)
                    break;
                if (js == JobState.Complete)
                    break;
                if (js == JobState.Failed)
                    break;
                Console.WriteLine("State: {0}", js.ToString());

                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Completed");
            ActionResult result = Widget.GetActionResult(jobId, 0);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);
            result = Widget.GetActionResult(jobId, 1);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);

            Widget.CleanupJob((ulong)jobId);
        }

        [TestCase]
        public void GetJobStatus_Pos()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            ActionInfo actionInfo;
            long jobId;

            jobId = Widget.CreateJob("test job", out jobInfo);
            PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
            Console.WriteLine("JobId: {0}", jobId);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[6];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/S";
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].value = "C:\\XBLOB\\";
            int rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            int execResult = Widget.ExecuteJob(jobId);
            Console.WriteLine("ExecuteJob() returned : {0}", execResult);
            ValueCheck.IsTrue(execResult == 0, "ExecuteJob.returnCode");

            JobState js;

            Console.WriteLine("Wait for complete");
            bool runLoop = true;
            while (runLoop)
            {
                js = Widget.GetJobStatus(jobId);
                switch(js)
                {
                    case JobState.Canceled:
                        Console.WriteLine("Job Status: Cancelled");
                        runLoop = false;
                        break;
                    case JobState.Complete:
                        Console.WriteLine("Job Status: Complete");
                        runLoop = false;
                        break;
                    case JobState.Failed:
                        Console.WriteLine("Job Status: Failed");
                        runLoop = false;
                        break;
                    default:
                        Console.WriteLine("Job Status: {0}", js.ToString());
                        break;
                }

                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Completed");
/*            ActionResult result = Widget.GetActionResult(jobId, 0);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);
            result = Widget.GetActionResult(jobId, 1);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);
*/
            Widget.CleanupJob((ulong)jobId);
        }

        [TestCase]
        public void GetActionStatus_Pos()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            ActionInfo actionInfo;
            long jobId;

            jobId = Widget.CreateJob("test job", out jobInfo);
            PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
            Console.WriteLine("JobId: {0}", jobId);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[6];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/S";
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].value = "C:\\XBLOB\\";
            int rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            int execResult = Widget.ExecuteJob(jobId);
            Console.WriteLine("ExecuteJob() returned : {0}", execResult);

            JobState js;

            Console.WriteLine("Wait for complete");
            bool runLoop = true;
            while (runLoop)
            {
                js = Widget.GetJobStatus(jobId);
                switch (js)
                {
                    case JobState.Canceled:
                        Console.WriteLine("Job Status: Cancelled");
                        runLoop = false;
                        break;
                    case JobState.Complete:
                        Console.WriteLine("Job Status: Complete");
                        runLoop = false;
                        break;
                    case JobState.Failed:
                        Console.WriteLine("Job Status: Failed");
                        runLoop = false;
                        break;
                    default:
                        Console.WriteLine("Job Status: {0}", js.ToString());
                        break;
                }

                js = Widget.GetActionStatus(jobId, 0);
                switch (js)
                {
                    case JobState.Canceled:
                        Console.WriteLine("Action Status: Cancelled");
                        break;
                    case JobState.Complete:
                        Console.WriteLine("Action Status: Complete");
                        break;
                    case JobState.Failed:
                        Console.WriteLine("Action Status: Failed");
                        break;
                    default:
                        Console.WriteLine("Action Status: {0}", js.ToString());
                        break;
                }

                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Completed");
            ActionResult result = Widget.GetActionResult(jobId, 0);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);

            Widget.CleanupJob((ulong)jobId);
        }

        [TestCase]
        public void GetActionResult_Pos()
        {
            WCToolsMgmt Widget = new WCToolsMgmt(_toolsMgmtAddress);
            JobInfo jobInfo;
            ActionInfo actionInfo;
            long jobId;

            jobId = Widget.CreateJob("test job", out jobInfo);
            PropWorkFile("FFFE07F100700001wrongtitle.offer", jobId.ToString());
            Console.WriteLine("JobId: {0}", jobId);

            actionInfo = new ActionInfo();
            actionInfo.jobId = jobId;
            actionInfo.toolFileName = "cmd";
            actionInfo.parameters = new Parameter[6];
            actionInfo.parameters[0] = new Parameter();
            actionInfo.parameters[0].name = "/C";
            actionInfo.parameters[1] = new Parameter();
            actionInfo.parameters[1].value = "dir";
            actionInfo.parameters[2] = new Parameter();
            actionInfo.parameters[2].value = "test.txt";
            actionInfo.parameters[3] = new Parameter();
            actionInfo.parameters[3].name = "/B";
            actionInfo.parameters[4] = new Parameter();
            actionInfo.parameters[4].name = "/S";
            actionInfo.parameters[5] = new Parameter();
            actionInfo.parameters[5].value = "C:\\XBLOB\\";
            int rank = Widget.AddAction(actionInfo);
            Console.WriteLine("rank: {0}", rank);

            int execResult = Widget.ExecuteJob(jobId);
            Console.WriteLine("ExecuteJob() returned : {0}", execResult);

            JobState js;

            Console.WriteLine("Wait for complete");
            bool runLoop = true;
            while (runLoop)
            {
                js = Widget.GetJobStatus(jobId);
                switch (js)
                {
                    case JobState.Canceled:
                        Console.WriteLine("Job Status: Cancelled");
                        runLoop = false;
                        break;
                    case JobState.Complete:
                        Console.WriteLine("Job Status: Complete");
                        runLoop = false;
                        break;
                    case JobState.Failed:
                        Console.WriteLine("Job Status: Failed");
                        runLoop = false;
                        break;
                    default:
                        Console.WriteLine("Job Status: {0}", js.ToString());
                        break;
                }

                System.Threading.Thread.Sleep(1000);
            }

            Console.WriteLine("Completed");
            ActionResult result = Widget.GetActionResult(jobId, 0);
            Console.WriteLine("ReturnCode: {0}", result.returnCode);
            Console.WriteLine("Output:");
            Console.WriteLine(result.consoleOutput);

            Widget.CleanupJob((ulong)jobId);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\UnitTest\UnitTester.cs ===
using System;
using System.IO;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
	public class UnitTester
	{
		[STAThread]
		static void Main(string[] args)
		{
			ArrayList tests = new ArrayList();

			tests.Add(new SimpleWireDataUnitTest());
			tests.Add(new WireDataUnitTest());
			tests.Add(new WireDataNestedUnitTest());
			tests.Add(new WireDataArrayUnitTest());
			tests.Add(new SubStaticUnitTest());

			bool success = true;
			foreach (UnitTest t in tests)
			{
				if (args.Length == 1 && args[0] == "/noexceptions")
				{
					t.RunTest();
					Console.WriteLine(t.Name + " passed.");
				}
				else
				{
					try
					{
						t.RunTest();
						Console.WriteLine(t.Name + " passed.");
					}
					catch(Exception e)
					{
						Console.WriteLine("Unit Test exception in " + t.Name + "\n" + e.ToString());
						success = false;
					}
				}
			}

			if (success)
				Console.WriteLine("Test complete.");
			else
				Console.WriteLine("Tests failed.");
		}
	}

	public class SimpleWireDataUnitTest : UnitTest
	{
		class TestSubclass : WireData
		{
			public uint a;
			public int bLen = 0;
			public string b;
		}

		public override void RunTest()
		{
			TestSubclass wd = new TestSubclass();
			wd.a = 4;
			wd.b = "Hello";

			byte[] bytes = (byte[])wd;

			wd = (TestSubclass)new TestSubclass().ReadBytes(bytes);

			Verify(wd.a == 4);
			Verify(wd.b == "Hello");
		}
	}

	public class WireDataUnitTest : UnitTest
	{
		class TestSubclass : WireData
		{
			public byte a = 0;
			public ulong b;
			[WireInfo(ArraySize=10)] public string c;
			public int d;
			[WireInfo(SizeParam="a")] public int[] e;
			[WireInfo(ArraySize=2)] public byte[] f;
			[WireInfo(ArraySize=3)] public string g;
			public DateTime h;
			public uint iLen = 0;
			public string i;
			public int jLen = 0;
			public string j = null;
		}

		public override void RunTest()
		{
			TestSubclass wd = new TestSubclass();
			wd.b = 0xFAFAFFFFFAFA1234;
			wd.c = "hello";
			wd.d = 0x4ADA1234;
			wd.e = new int[5] {5, 6, 7, 8, 9};
			wd.f = new byte[2] {10, 11};
			wd.h = new DateTime(2002, 9, 20);
			wd.i = "bye";

			Stream s = new MemoryStream();
			wd.WriteStream(s);

			wd = new TestSubclass();

			s.Position = 0;
			wd.ReadStream(s);

			Verify(wd.a == 5);
			Verify(wd.b == 0xFAFAFFFFFAFA1234);
			Verify(wd.c == "hello");
			Verify(wd.d == 0x4ADA1234);
			Verify(wd.e.Length == 5 && wd.e[0] == 5 && wd.e[1] == 6 && wd.e[2] == 7 && wd.e[3] == 8 && wd.e[4] == 9);
			Verify(wd.f.Length == 2 && wd.f[0] == 10 && wd.f[1] == 11);
			Verify(wd.g.Length == 0);
			Verify(wd.h == new DateTime(2002, 9, 20));
			Verify(wd.iLen == 3);
			Verify(wd.i.Length == 3 && wd.i == "bye");
			Verify(wd.jLen == 0);
			Verify(wd.j.Length == 0 && wd.j == "");

			wd.g = "goodbye";
			s.Position = 0;
			try
			{
				wd.WriteStream(s);
				Verify(false);
			}
			catch(Exception)
			{
			}
		}
	}

	public class WireDataNestedUnitTest : UnitTest
	{
		class TestSubSubclass : WireData
		{
			public uint c = 3;
			public byte dLen = 0;
			public string d = "4";
		}

		class TestSubclass : WireData
		{
			public int a = 1;
			public TestSubSubclass b = new TestSubSubclass();
			public ulong e = 5;
		}

		public override void RunTest()
		{
			TestSubclass wd = new TestSubclass();

			Stream s = new MemoryStream();
			wd.WriteStream(s);

			wd = new TestSubclass();

			s.Position = 0;
			wd.ReadStream(s);

			Verify(wd.a == 1);
			Verify(wd.b.c == 3);
			Verify(wd.b.dLen == 1);
			Verify(wd.b.d == "4");
			Verify(wd.e == 5);
		}
	}

	public class WireDataArrayUnitTest : UnitTest
	{
		class TestSubclass : WireData
		{
			[WireInfo(ArraySize=3)] public TestSubSubclass[] a = null;
			public int bLen = 2;
			public TestSubSubclass[] b = null;
		}

		class TestSubSubclass : WireData
		{
			public uint a = 4;
			public int bLen = 0;
			public string b;
		}

		public override void RunTest()
		{
			TestSubclass wd = new TestSubclass();

			wd = (TestSubclass)new TestSubclass().ReadBytes((byte[])wd);

			Verify(wd.a.Length == 3);
			Verify(wd.a[0].a == 0 && wd.a[0].b == "");
			Verify(wd.a[1].a == 0 && wd.a[1].b == "");
			Verify(wd.a[2].a == 0 && wd.a[2].b == "");
			Verify(wd.b.Length == 0);

			wd.a[0].a = 2;
			wd.a[0].b = "hi";
			wd.a[1].a = 1;
			wd.a[2].b = "goodbye";

			wd.b = new TestSubSubclass[2] {new TestSubSubclass() ,new TestSubSubclass()};
			wd.b[0].a = 3;
			wd.b[0].b = "hello";
			wd.b[1].a = 5;

			wd = (TestSubclass)new TestSubclass().ReadBytes((byte[])wd);

			Verify(wd.a.Length == 3);
			Verify(wd.a[0].a == 2 && wd.a[0].b == "hi");
			Verify(wd.a[1].a == 1 && wd.a[1].b == "");
			Verify(wd.a[2].a == 0 && wd.a[2].b == "goodbye");

			Verify(wd.b.Length == 2);
			Verify(wd.b[0].a == 3 && wd.b[0].b == "hello");
			Verify(wd.b[1].a == 5 && wd.b[1].b == "");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\VoucherMgrTest\VoucherMgrTest.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.STFTools;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

namespace VoucherMgrTest {

    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class ImportESPVoucherOnlyCases : TestNode {
        //check ranges
        //IMPORT
        //only minseq
        //only maxseq
        //

        [TestCase, DVT]
        class ImportTest_noRange : VoucherMgrTestBase {
            override protected void Execute() {
                ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, -1, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, -1, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, -1, 0, 2, -1, -1, -1);
            }
        }

        [TestCase]
        class ImportTest_minRangeOnly : VoucherMgrTestBase {
            override protected void Execute() {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 007602001, -1, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 641000000, -1, -1);
                ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID , - 1, 0, 2, minSeq, -1, -1);                   
            }
        }

        [TestCase]
        class ImportTest_minRangeOnly_UseOfferId : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 007602001, -1, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 641000000, -1, -1);
                ImportTestOld(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID , - 1, 0, 2, minSeq, -1, -1);                   
            }
        }

        [TestCase]
        class ImportTest_maxRangeOnly : VoucherMgrTestBase {
            override protected void Execute() {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 641000010, -1);
                ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, -1, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, -1, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, - 1, 0, 2, -1, maxSeq, -1);
            }
        }
        [TestCase]
        class ImportTest_min_maxRange : VoucherMgrTestBase {
            override protected void Execute() {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 007602001, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 641000000, 641000010, -1);
                ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
            }
        }

        [TestCase]
        class ImportTest_Xbox1_min_maxRange : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 007602001, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 641000000, 641000010, -1);
                ImportTest(SampleVouchersOldFormat, true, XBOX1_OFFERID, 1, 1, 1, minSeq, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
            }
        }
        [TestCase]
        class ImportTest_variousArgs : VoucherMgrTestBase {
            override protected void Execute() {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, 5, 1, 1, 007602020, 007602070, 5);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, 5, 1, 1, 641000000, 641000010, 5);
                ImportTest(SampleVouchersOldFormat, true, ESP_SCG_Offer, 5, 1, 1, minSeq, maxSeq, 5);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, 5, 1, 1, minSeq, maxSeq, 5);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, 5, 1, 1, minSeq, maxSeq, 5);
            }
        }
		
    }
    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class ImportEMSVoucherOnlyCases : TestNode
    {
        //check ranges
        //IMPORT
        //only minseq
        //only maxseq
        //

        [TestCase, DVT]
        class ImportTest_noRange : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, -1, -1, -1);
            }
        }

        [TestCase]
        class ImportTest_minRangeOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 007602001, -1, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 641000000, -1, -1);
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, -1, -1);
            }
        }

        [TestCase]
        class ImportTest_maxRangeOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 641000010, -1);
                //ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, -1, maxSeq, -1);
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, -1, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, - 1, 0, 2, -1, maxSeq, -1);
            }
        }
        [TestCase]
        class ImportTest_min_maxRange : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 007602001, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 641000000, 641000010, -1);
                //ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
            }
        }
        [TestCase]
        class ImportTest_variousArgs : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, 5, 1, 1, 007602020, 007602070, 5);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, 5, 1, 1, 641000000, 641000010, 5);
                //ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, 5, 1, 1, minSeq, maxSeq, 5);
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, 5, 1, 1, minSeq, maxSeq, 5);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, 5, 1, 1, minSeq, maxSeq, 5);
            }
        }

    }
    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class ImportBothVouchersCases : TestNode
    {
        //check ranges
        //IMPORT
        //only minseq
        //only maxseq
        //

        [TestCase, DVT]
        class ImportTest_noRange : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, -1, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, -1, -1, -1);
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, -1, 0, 2, -1, -1, -1);
            }
        }

        [TestCase]
        class ImportTest_minRangeOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 007602001, -1, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 641000000, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, -1, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, -1, -1);
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID , - 1, 0, 2, minSeq, -1, -1);                   
            }
        }

        [TestCase]
        class ImportTest_maxRangeOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, -1, 641000010, -1);
                //ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, -1, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, -1, maxSeq, -1);
                
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, - 1, 0, 2, -1, maxSeq, -1);
            }
        }
        [TestCase]
        class ImportTest_min_maxRange : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 007602001, 007602050, -1);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, -1, 0, 2, 641000000, 641000010, -1);
                //ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
                
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
            }
        }
        [TestCase]
        class ImportTest_variousArgs : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, 5, 1, 1, 007602020, 007602070, 5);
                //ImportTest(SampleVouchers, true, VOUCHER_OFFERID, 5, 1, 1, 641000000, 641000010, 5);
                //ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, 5, 1, 1, minSeq, maxSeq, 5);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, 5, 1, 1, minSeq, maxSeq, 5);

                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, ESP_SCG_Offer, 5, 1, 1, minSeq, maxSeq, 5);
            }
        }

    }
//disable
//disable 1x
//disable 2x(still disabled?)
//enable then disable
    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class DisableCases : TestNode {

        [TestCase]
        class DisableTest_noRange_ESP_Only : VoucherMgrTestBase {
            override protected void Execute() {
                DisableTest(VoucherType.ESPOnly, SampleVouchersOldFormat, true, -1, -1);
            }
        }

        [TestCase]
        class DisableTest_minRangeOnly_EMS_Only : VoucherMgrTestBase {
            override protected void Execute() {
                
                //DisableTest(SampleVouchers, true, 007602001, -1 );
                DisableTest(VoucherType.EMSOnly, SampleVouchersOldFormat, true, minSeq, -1);
            }
        }

        [TestCase]
        class DisableTest_maxRangeOnly_EMS_Only : VoucherMgrTestBase {
            override protected void Execute() {
                
                //DisableTest(SampleVouchers, true, -1, 007602050);
                DisableTest(VoucherType.EMSOnly, SampleVouchersOldFormat, true, -1, maxSeq);
            }
        }
        [TestCase]
        class DisableTest_min_maxRange_Both : VoucherMgrTestBase {
            override protected void Execute() {
                
                //DisableTest(SampleVouchers, true, 007602001, 007602050);
                DisableTest(VoucherType.Both, SampleVouchersOldFormat, true, minSeq, maxSeq);
            }
        }
    }

    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class EnableCases : TestNode {

        [TestCase]
        class EnableTest_noRange_EMS_Only : VoucherMgrTestBase {
            override protected void Execute() {
                
                EnableTest(VoucherType.EMSOnly, SampleVouchersOldFormat, true, -1, -1);
            }
        }

        [TestCase]
        class EnableTest_minRangeOnly_ESP_Only : VoucherMgrTestBase {
            override protected void Execute() {
                //EnableTest(SampleVouchers, true, -1, 007602050);
                
                EnableTest(VoucherType.ESPOnly, SampleVouchersOldFormat, true, minSeq, -1);
            }
        }

        [TestCase]
        class EnableTest_maxRangeOnly_Both : VoucherMgrTestBase {
            override protected void Execute() {
                //EnableTest(SampleVouchers, true, 007602001, -1);
                
                EnableTest(VoucherType.Both, SampleVouchersOldFormat, true, -1, maxSeq);
            }
        }
        [TestCase]
        class EnableTest_min_maxRange_Both : VoucherMgrTestBase {
            override protected void Execute() {
                //EnableTest(SampleVouchers, true, 007602001, 007602050);
                
                EnableTest(VoucherType.Both, SampleVouchersOldFormat, true, minSeq, maxSeq);
            }
        }
    }

    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class DeleteCases : TestNode {
        [TestCase]
        class DeleteTest_noRange : VoucherMgrTestBase {
            override protected void Execute() {
                
                DeleteTest(SampleVouchersOldFormat, true, -1, -1);
            }
        }

        [TestCase]
        class DeleteTest_minRangeOnly : VoucherMgrTestBase {
            override protected void Execute() {
                //DeleteTest(SampleVouchers, true, -1, 007602050);
                
                DeleteTest(SampleVouchersOldFormat, true, minSeq, -1);
            }
        }

        [TestCase]
        class DeleteTest_maxRangeOnly : VoucherMgrTestBase {
            override protected void Execute() {
                //DeleteTest(SampleVouchers, true, 007602001, -1);
                
                DeleteTest(SampleVouchersOldFormat, true, -1, maxSeq);
            }
        }
        [TestCase]
        class DeleteTest_min_maxRange : VoucherMgrTestBase {
            override protected void Execute() {
                //DeleteTest(SampleVouchers, true, 007602001, 007602050);
                
                DeleteTest(SampleVouchersOldFormat, true, minSeq, maxSeq);
            }
        }

        //delete with the wrong offerid, ensure no items are deleted.
        //[TestCase, Ignore]
        class DeleteTest_varying_offerid :  VoucherMgrTestBase {
            override protected void Execute() {
                int min = 931;
                
                //int max = 0076020050;
                //int max = 641000010;
                ClearVouchers(VOUCHER_OFFERID);
                ClearVouchers(EMS_OFFERID);

                //dummy up the import so we just get the range.
                //VoucherMgrProcess.Import(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, min, maxSeq, -1);
                //VoucherMgrProcess.Import(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, min, maxSeq, -1);
                ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, min, maxSeq, -1);
                //ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, min, maxSeq, -1);
                VoucherMgrProcess.Delete(SampleVouchersOldFormat, true, "0x1234567812345678", min, maxSeq, -1);
                SetResultCode(Verify(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, true, min, maxSeq));

                //dummy up the import so we just get the range.
                //VoucherMgrProcess.Delete(SampleVouchersOldFormat, true, "00010000-0018-0050-0000-0000000C1000", min, maxSeq, -1);
                //SetResultCode(Verify(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, true, min, maxSeq));
            }
        }
        [TestCase]
        class DeleteTest_EmsOfferOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                int min = 931;
                
                //int max = 0076020050;
                //int max = 641000010;
                ClearVouchers(VOUCHER_OFFERID);
                ClearVouchers(EMS_OFFERID);//VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
                //dummy up the import so we just get the range.                
                VoucherMgrProcess.Import(SampleVouchersOldFormat, true, EMS_OFFERID, 23, VOUCHER_OFFERID, -1, 0, 2, min, maxSeq, -1);
                VoucherMgrProcess.Delete(SampleVouchersOldFormat, true, EMS_OFFERID, min, maxSeq, -1);
                SetResultCode(VerifyMissing(SampleVouchersOldFormat, true, EMS_OFFERID, min, maxSeq));
                //SetResultCode(Verify(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, true, min, maxSeq));
            }
        }

        [TestCase]
        class DeleteTest_ESPOfferOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                int min = 931;
                
                //int max = 0076020050;
                //int max = 641000010;
                ClearVouchers(VOUCHER_OFFERID);
                ClearVouchers(EMS_OFFERID);//VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
                //dummy up the import so we just get the range.
                VoucherMgrProcess.Import(SampleVouchersOldFormat, true, EMS_OFFERID, 23, VOUCHER_OFFERID, -1, 0, 2, min, maxSeq, -1);
                VoucherMgrProcess.Delete(SampleVouchersOldFormat, true, EMS_OFFERID, min, maxSeq, -1);
                SetResultCode(VerifyMissing(SampleVouchersOldFormat, true, VOUCHER_OFFERID, min, maxSeq));
                //SetResultCode(Verify(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, true, min, maxSeq));
            }
        }

        class DeleteTest_BothOffers : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                int min = 931;
                
                //int max = 0076020050;
                //int max = 641000010;
                ClearVouchers(VOUCHER_OFFERID);
                ClearVouchers(EMS_OFFERID);//VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
                //dummy up the import so we just get the range.
                VoucherMgrProcess.Import(SampleVouchersOldFormat, true, EMS_OFFERID, 23, VOUCHER_OFFERID, -1, 0, 2, min, maxSeq, -1);
                VoucherMgrProcess.Delete(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, min, maxSeq, -1);
                SetResultCode(VerifyMissing(SampleVouchersOldFormat, true, VOUCHER_OFFERID, min, maxSeq));
                SetResultCode(VerifyMissing(SampleVouchersOldFormat, true, EMS_OFFERID, min, maxSeq));
            }
        }

    }

    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class NegativeCases : TestNode {
        [TestCase]
        class ImportTest_badKey : VoucherMgrTestBase {
            override protected void Execute() {
                
                ExpectFailOfImportTest("12345-thisisgarbage-etcetc-stuff-garbage", false, VOUCHER_OFFERID, -1, 0, 2, maxSeq, -1, -1,
                    "token is not a valid 5x5 code");
               }
        }

        //TODO:This is a minor bug in VoucherMgr--it should give an appropriate string about
        //useCount on failure!
        [TestCase]
        class ImportTest_baduseCount : VoucherMgrTestBase {
            override protected void Execute() {
                
                ExpectFailOfImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -321, 0, 2, -1, -1, -1,
                    "");
            }
        }

        [TestCase]
        class ImportTest_baduseSCG : VoucherMgrTestBase {
            override protected void Execute() {
                
               /* ExpectFailOfImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 75, 2, -1, 007602042, -1,
                    "Only allowable values for /SCG are 0 (disabled) or 1 (enabled).");*/
                ExpectFailOfImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 75, 2, -1, maxSeq, -1,
                    "Only allowable values for /SCG are 0 (disabled) or 1 (enabled).");
            }
        }
        [TestCase]
        class ImportTest_badconsoleVer : VoucherMgrTestBase {
            override protected void Execute() {
                
                ExpectFailOfImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 931, minSeq, -1, -1,
                    "Only allowable values for /consolever are 1 (Xbox) or 2 (Xenon).");
            }
        }

        [TestCase]
        class ImportTest_badESPOfferId : VoucherMgrTestBase {
            override protected void Execute() {
                
                ExpectFailOfImportTest(SampleVouchersOldFormat, true, "garbagegarbagegarbage", -1, 0, 931, minSeq, -1, -1,
                    "Invalid offer id.");
            }
        }

        [TestCase]
        class ImportTest_badEMSOfferId : VoucherMgrTestBase
        {
            override protected void Execute()
            {

                VoucherMgr.InvalidEMSOfferId = "0x584107ED00000001";
                ExpectFailOfImportTest(SampleVouchersOldFormat, true, VoucherMgr.InvalidEMSOfferId, -1, 0, 931, minSeq, -1, -1,
                    "Invalid offer id.");
                VoucherMgr.InvalidEMSOfferId = "";
            }
        }
//disable
//bad arguments
//these don't appear to be errors, or negative cases.  Don't know what should happen.
/*
        [TestCase]
        class DisableTest_badKey : VoucherMgrTestBase {
            override protected void Execute() {
                int min = 931;
                int max = 007602001;
                ClearVouchers(VOUCHER_OFFERID);
                ExpectFailOfDisableTest("12345-12345-12391-12490-12092", false, min, max,
                    "Key must be in one of the following formats: XXXXX-XXXXX-XXXXX-XXXXX-XXXXX or XXXXXXXXXXXXXXXXXXXXXXXXX");
            }
        }

        [TestCase]
        class DisableTest_KeyNotAdded : VoucherMgrTestBase {
            override protected void Execute() {
                ClearVouchers(VOUCHER_OFFERID);
                ExpectFailOfDisableTest(SampleVouchers, true, 931, 007602001,
                    "Key must be in one of the following formats: XXXXX-XXXXX-XXXXX-XXXXX-XXXXX or XXXXXXXXXXXXXXXXXXXXXXXXX");
            }
        }
*/

//this is not a test case, but a helper to make it easier to clean the vouchers.
    }

    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class RawFormat_ImportCases : TestNode {

        [TestCase, DVT]
        class ImportTest_NoRange : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                
                ImportTest(SampleVouchersNewFormat, true, VOUCHER_OFFERID, -1, 0, 2, -1, -1, -1);
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, -1, -1, -1);
                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, VOUCHER_OFFERID, - 1, 0, 2, -1, -1, -1);
            }
        }

        [TestCase]
        class ImportTest_minRangeOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                
		        ImportTest(SampleVouchersNewFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, -1, -1);
                ImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, -1, -1);
                ImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, VOUCHER_OFFERID, -1, 0, 2, minSeq, -1, -1);            
            }
        }
	 [TestCase]
        class ImportTest_maxRangeOnly : VoucherMgrTestBase {
            override protected void Execute() {
                
                ImportTest(SampleVouchersNewFormat, true, VOUCHER_OFFERID, -1, 0, 2, -1, maxSeq, -1);
                ImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, -1, 0, 2, -1, maxSeq, -1);
                ImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, VOUCHER_OFFERID, -1, 0, 2, -1, maxSeq, -1);
            }
        }
        [TestCase]
        class ImportTest_min_maxRange : VoucherMgrTestBase {
            override protected void Execute() {
                
                ImportTest(SampleVouchersNewFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
                ImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, -1, 0, 2, minSeq, maxSeq, -1);
            }
        }
        [TestCase]
        class ImportTest_variousArgs : VoucherMgrTestBase {
            override protected void Execute() {
                
                ImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, ESP_SCG_Offer, 5, 1, 1, minSeq, maxSeq, 5);
            }
        }


    	}

    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class RawFormat_DisableCases : TestNode {

        [TestCase]
        class DisableTest_noRange_Both : VoucherMgrTestBase {
            override protected void Execute() {
                
                DisableTest(VoucherType.Both, SampleVouchersNewFormat, true, -1, -1);
            }
        }

        [TestCase]
        class DisableTest_minRangeOnly_Both : VoucherMgrTestBase {
            override protected void Execute() {
                
                DisableTest(VoucherType.Both, SampleVouchersNewFormat, true, minSeq, -1);
            }
        }

        [TestCase]
        class DisableTest_maxRangeOnly_ESP : VoucherMgrTestBase {
            override protected void Execute() {
                
                DisableTest(VoucherType.ESPOnly,SampleVouchersNewFormat, true, -1, maxSeq);
            }
        }
        [TestCase]
        class DisableTest_min_maxRange_EMS : VoucherMgrTestBase {
            override protected void Execute() {
                
                DisableTest(VoucherType.EMSOnly, SampleVouchersNewFormat, true, minSeq, maxSeq);
            }
        }
    }


    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class RawFormat_EnableCases : TestNode {

        [TestCase]
        class EnableTest_noRange_ESP : VoucherMgrTestBase {
            override protected void Execute() {
                
                EnableTest(VoucherType.ESPOnly, SampleVouchersNewFormat, true, -1, -1);
            }
        }

        [TestCase]
        class EnableTest_minRangeOnly_EMS : VoucherMgrTestBase {
            override protected void Execute() {
                
                EnableTest(VoucherType.EMSOnly, SampleVouchersNewFormat, true, minSeq, -1);
            }
        }

        [TestCase]
        class EnableTest_maxRangeOnly_Both : VoucherMgrTestBase {
            override protected void Execute() {
                
                EnableTest(VoucherType.Both, SampleVouchersNewFormat, true, -1, maxSeq);
            }
        }
        [TestCase]
        class EnableTest_min_maxRange_Both : VoucherMgrTestBase {
            override protected void Execute() {
                
                EnableTest(VoucherType.Both, SampleVouchersNewFormat, true, minSeq, maxSeq);
            }
        }
    }


    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class RawFormat_DeleteCases : TestNode {
        [TestCase]
        class DeleteTest_noRange : VoucherMgrTestBase {
            override protected void Execute() {
                
                DeleteTest(SampleVouchersNewFormat, true, -1, -1);
            }
        }

        [TestCase]
        class DeleteTest_minRangeOnly : VoucherMgrTestBase {
            override protected void Execute() {
                
                DeleteTest(SampleVouchersNewFormat, true, minSeq, -1);
            }
        }

        [TestCase]
        class DeleteTest_maxRangeOnly : VoucherMgrTestBase {
            override protected void Execute() {
                
                DeleteTest(SampleVouchersNewFormat, true, -1, maxSeq);
            }
        }
        [TestCase]
        class DeleteTest_min_maxRange : VoucherMgrTestBase {
            override protected void Execute() {
                
                DeleteTest(SampleVouchersNewFormat, true, minSeq, maxSeq);
            }
        }

        //delete with the wrong offerid, ensure no items are deleted.
        //[TestCase, Ignore]
        class DeleteTest_varying_offerid :  VoucherMgrTestBase {
            override protected void Execute() {
                int min = 931;
                
                //int max = 641000010;
                ClearVouchers(VOUCHER_OFFERID);
                ClearVouchers(EMS_OFFERID);
                //dummy up the import so we just get the range.
                VoucherMgrProcess.Import(SampleVouchersNewFormat, true, VOUCHER_OFFERID, 23, -1, 0, 2, min, maxSeq, -1);
                VoucherMgrProcess.Import(SampleVouchersNewFormat, true, EMS_OFFERID, 23, -1, 0, 2, min, maxSeq, -1);

                VoucherMgrProcess.Delete(SampleVouchersNewFormat, true, "0x1234567812345678", min, maxSeq, -1);
                SetResultCode(Verify(SampleVouchersNewFormat, true, VOUCHER_OFFERID, -1, 0, 2, true, min, maxSeq));

                VoucherMgrProcess.Delete(SampleVouchersNewFormat, true, "00010000-0018-0050-0000-0000000C1000", min, maxSeq, -1);
                SetResultCode(Verify(SampleVouchersNewFormat, true, EMS_OFFERID, -1, 0, 2, true, min, maxSeq));
            }
        }

        [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
        class DeleteTest_EmsOfferOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                int min = 931;
                
                //int max = 0076020050;
                //int max = 641000010;
                ClearVouchers(VOUCHER_OFFERID);
                ClearVouchers(EMS_OFFERID);
                //dummy up the import so we just get the range.                
                VoucherMgrProcess.Import(SampleVouchersNewFormat, true, EMS_OFFERID, 23, VOUCHER_OFFERID, -1, 0, 2, min, maxSeq, -1);
                VoucherMgrProcess.Delete(SampleVouchersNewFormat, true, EMS_OFFERID, min, maxSeq, -1);
                SetResultCode(VerifyMissing(SampleVouchersNewFormat, true, EMS_OFFERID, min, maxSeq));
                //SetResultCode(Verify(SampleVouchersNewFormat, true, VOUCHER_OFFERID, -1, 0, 2, true, min, maxSeq));
            }
        }

        [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
        class DeleteTest_ESPOfferOnly : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                int min = 931;
                
                //int max = 0076020050;
                //int max = 641000010;
                ClearVouchers(VOUCHER_OFFERID);
                ClearVouchers(EMS_OFFERID);//VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
                //dummy up the import so we just get the range.
                VoucherMgrProcess.Import(SampleVouchersNewFormat, true, EMS_OFFERID, 23, VOUCHER_OFFERID, -1, 0, 2, min, maxSeq, -1);
                VoucherMgrProcess.Delete(SampleVouchersNewFormat, true, EMS_OFFERID, min, maxSeq, -1);
                SetResultCode(VerifyMissing(SampleVouchersNewFormat, true, VOUCHER_OFFERID, min, maxSeq));
                //SetResultCode(Verify(SampleVouchersNewFormat, true, EMS_OFFERID, -1, 0, 2, true, min, maxSeq));
            }
        }

        class DeleteTest_BothOffers : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                int min = 931;
                
                //int max = 0076020050;
                //int max = 641000010;
                ClearVouchers(VOUCHER_OFFERID);
                ClearVouchers(EMS_OFFERID);//VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
                //dummy up the import so we just get the range.
                VoucherMgrProcess.Import(SampleVouchersNewFormat, true, EMS_OFFERID, 23, VOUCHER_OFFERID, -1, 0, 2, min, maxSeq, -1);
                VoucherMgrProcess.Delete(SampleVouchersNewFormat, true, EMS_OFFERID, VOUCHER_OFFERID, min, maxSeq, -1);
                SetResultCode(VerifyMissing(SampleVouchersNewFormat, true, VOUCHER_OFFERID, min, maxSeq));
                SetResultCode(VerifyMissing(SampleVouchersNewFormat, true, EMS_OFFERID, min, maxSeq));
            }
        }

    }

    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class RawFormat_NegativeCases : TestNode {
        [TestCase]
        class ImportTest_badKey : VoucherMgrTestBase {
            override protected void Execute() {
                
                ExpectFailOfImportTest("12345-thisisgarbage-etcetc-stuff-garbage", false, VOUCHER_OFFERID, -1, 0, 2, maxSeq, -1, -1,
                    "token is not a valid 5x5 code");
               }
        }

        //TODO:This is a minor bug in VoucherMgr--it should give an appropriate string about
        //useCount on failure!
        [TestCase]
        class ImportTest_baduseCount4444 : VoucherMgrTestBase {
            override protected void Execute() {

                ExpectFailOfImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, -321, 0, 2, -1, -1, -1,
                    "");
            }
        }

        [TestCase]
        class ImportTest_baduseSCGXXX : VoucherMgrTestBase {
            override protected void Execute() {

                ExpectFailOfImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, -1, 75, 2, -1, maxSeq, -1,
                    "Only allowable values for /SCG are 0 (disabled) or 1 (enabled).");
            }
        }
        [TestCase]
        class ImportTest_badconsoleVer : VoucherMgrTestBase {
            override protected void Execute() {

                ExpectFailOfImportTest(SampleVouchersNewFormat, true, EMS_OFFERID, -1, 0, 931, minSeq, -1, -1,
                    "Only allowable values for /consolever are 1 (Xbox) or 2 (Xenon).");
            }
        }

        
        [TestCase]
        class ImportTest_badESPOfferId : VoucherMgrTestBase {
            override protected void Execute() {
                
                ExpectFailOfImportTest(SampleVouchersNewFormat, true, "garbagegarbagegarbage", -1, 0, 931, maxSeq, -1, -1,
                    "Invalid offer id.");
            }
        }

        [TestCase]
        class ImportTest_badEmsOfferId : VoucherMgrTestBase {
            override protected void Execute() {

                VoucherMgr.InvalidEMSOfferId ="0x584107ED00000001";
                ExpectFailOfImportTest(SampleVouchersNewFormat, true, VoucherMgr.InvalidEMSOfferId, -1, 0, 931, maxSeq, -1, -1,
                    "Invalid offer id.");
                VoucherMgr.InvalidEMSOfferId = "";
            }
        }
    	}

    [TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("")]
    public class ViewTestCases : TestNode {        
      [TestCase]
      class ViewEPSStatus : VoucherMgrTestBase {
           
           override protected void Execute() {
               int delt = 1;
               int nextstart = delt + 1;

               VoucherMgrProcess.Delete(SampleVouchersOldFormat, true, "", minSeq, minSeq + nextstart + delt, -1);
               ImportTestNoClear(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, minSeq + delt, -1);

               ImportTestNoClear(SampleVouchersOldFormat, true, VOUCHER_OFFERID1, -1, 0, 2, minSeq + nextstart, minSeq + nextstart+ delt, -1);

               SetResultCode(ViewTest(SampleVouchersOldFormat, true, minSeq, minSeq + delt, VoucherType.ESPOnly));
            }
        }

      [TestCase]
        class ViewEpsEMSVoucherStatus : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                int delt = 1;
                int nextstart = delt + 1;

                VoucherMgrProcess.Delete(SampleVouchersOldFormat, true, "", minSeq, minSeq + nextstart + delt, -1);
                ImportTestNoClear(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, minSeq, minSeq + delt, -1);

                ImportTestNoClear(SampleVouchersOldFormat, true, VOUCHER_OFFERID1, -1, 0, 2, minSeq + nextstart, minSeq + nextstart, -1);
                ImportTestNoClear(SampleVouchersOldFormat, true, EMS_ArcadeOfferId, 6, 0, 2, minSeq + nextstart + delt, minSeq + nextstart + delt, -1);

                // create a silver user
                XeUser user = XbosUser.XenonSilverUser();

                // consume one token each, one for esp offer and one for ems offer
                string hash = "995e4dca68c6dc4365a8f030ab9f963fb96a7ce0";   // the hash from seqence 641000002
                byte[] hashBytes = Hexer.unhex(hash);
                TokendbWS.UnuseToken(hash);
                TokendbWS.UnuseVoucher(hash);
                TokendbWS.RegisterVoucherUse(hashBytes, user.UserPuid);

                hash = "21ED3B549BC83F9D848E2FDFE4F7902FD193BF7C";  // the hash from sequence  641000003
                hashBytes = Hexer.unhex(hash);
                TokendbWS.UnuseToken(hash);
                TokendbWS.UnuseVoucher(hash);
                TokendbWS.RegisterEmsTokenUse(hashBytes, user.UserPuid);

                SetResultCode(ViewTest(SampleVouchersOldFormat, true, minSeq + nextstart, minSeq + nextstart, VoucherType.ESPViewState));
                SetResultCode(ViewTest(SampleVouchersOldFormat, true, minSeq + nextstart + delt, minSeq + nextstart + delt, VoucherType.EMSOnly));
            }
        }

    }

    // Stop the auto test run picking up these manual tests
    //[TestGroup, Owner("yuanfeiw"), TestFrequency("Regression"), EnvRequirement("Manual")]
    public class ManualTestCases : TestNode
    {        

        [TestCase]
        class EpsSummary : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                
                ImportTest(SampleVouchersOldFormat, true, VOUCHER_OFFERID, -1, 0, 2, -1, -1, -1);
                EspSummary();
                SetResultCode(true);
            }
        }


        [TestCase]
        class EmsSummary : VoucherMgrTestBase
        {
            override protected void Execute()
            {

                ImportTest(SampleVouchersOldFormat, true, EMS_OFFERID, -1, 0, 2, -1, -1, -1);
                EmsSummary();
                SetResultCode(true);
            }
        }

        /* The following test cases are used to help running the manul tests to verify vourchermgr correclty handle errro and write to FailedVouchers.txt
            [p_svc_add_vouchers] and [p_svc_add_tokens]
             Add the following to the sprocs to generate exception from sprocs.
                    if rand() >0.3
                      begin
                     RAISERROR ('time out', 16, 1)
                     return 0
                    end         
             
         Testcase:
             1. Verify ESP prop only
             2. Verify EMS prop only
             3. Verify ESP and EMS prop         
            
          Step:                        
             1. Run correspoonding GetImportXXXFailedTestVouchersCommandLine testcase and get the prop command line from stfgui.  
             2. Run ClearFailedTestVouchers testcase
             3. Change the corresponding sproc 
             4. Run the prop command got from Step 1 in a shell window.
             5. Run Verify test and should expect failure. If not, restart from Step 2.
             6. Change the sproc back
             7. copy FailedVouchers.txt .\InputFiles\VoucherMgr\f.txt and replace the filename in the prop command to f.txt to repro the failed vouchers
             8. Rerun Step 4 should be successful.
            
         These Steps are needed for the 3 testcases mentioned above.
         */
        [TestCase]
        class ClearFailedTestVouchers : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                ClearVouchers(EMS_OFFERID);
                ClearVouchers(VOUCHER_OFFERID);
                SetResultCode(true);
            }
        }


        [TestCase]
        class GetImportEMSFailedTestVouchersCommandLine : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                VoucherMgrProcess.Import(FailedTestVouchers, true, EMS_OFFERID, 23, -1, 0, 2, -1, -1, 0);

            }
        }


        [TestCase]
        class GetImportESPFailedTestVouchersCommandLine : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                VoucherMgrProcess.Import(FailedTestVouchers, true, VOUCHER_OFFERID, 23, -1, 0, 2, -1, -1, 0);
 
            }
        }

        [TestCase]
        class GetImportBothFailedTestVouchersCommandLine : VoucherMgrTestBase
        {
            override protected void Execute()
            {                
                VoucherMgrProcess.Import(FailedTestVouchers, true, EMS_OFFERID, 23, VOUCHER_OFFERID,  -1, 0, 2, -1, -1, 0);
            }
        }

        [TestCase]
        class VerifyFailedTestESPVoucherImported : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                bool success = Verify(FailedTestVouchers, true, VOUCHER_OFFERID, -1, 0, 2, true, -1, -1);
                SetResultCode(success);
            }
        }


        [TestCase]
        class VerifyFailedTestEMSVoucherImported : VoucherMgrTestBase
        {
            override protected void Execute()
            {
                bool success = Verify(FailedTestVouchers, true, EMS_OFFERID, -1, 0, 2, true, -1, -1);
                SetResultCode(success);
            }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\VoucherMgrTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\VoucherMgrTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_vouchermgrtest_none_12.4.56.0_none_240356065b616c01
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=vouchermgrtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df.manifest
XP_MANIFEST_PATH=manifests\msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df.cat
XP_CATALOG_PATH=manifests\msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df.cat
XP_PAYLOAD_PATH=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=vouchermgrtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\VoucherMgrTest\VoucherMgrTestBase.cs ===
using System;
using System.Data;
using System.Xml;
using System.IO;


using System.Data.SqlTypes;
using System.Data.SqlClient;
using System.Data.Common;
using System.Collections;
using System.Text;
using System.Runtime.InteropServices;

using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.Database;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;


namespace VoucherMgrTest {

    public abstract class VoucherMgrTestBase : TestNode {
        //public const string VOUCHER_OFFERID = "0xFFFE07D1000000B1";
        public static string VOUCHER_OFFERID = null;/*"0xFFFE00008000000A";*/
        public static string VOUCHER_OFFERID1 = null;
        public const string ESP_SCG_Offer = "0xFFFE07D10FF00021";
        public const string XBOX1_OFFERID = "0xFFFE00008000000A";

        public const string EMS_OFFERID = "00010000-0023-0004-0000-0000000C2000";
        public const string EMS_ArcadeOfferId = "00000001-0000-4000-8000-0000584107F6"; // BVT title 0x584107F6, Texas Holdem, full game
        public const string EMS_OFFERID1 = "";
        string _voucherMgrPath;
        private string _sampleVouchers;
        private string _sampleVouchersOldFormat;
        private string _sampleVouchersNewFormat;
        private string _failedTestVouchers;
        int _minSeq;
        int _maxSeq;
        public enum VoucherType {ESPOnly, EMSOnly, Both, ESPViewState };
        private VoucherMgr _voucherMgrProcess;

        public string SampleVouchers { get { return _sampleVouchers; } }
        public string SampleVouchersOldFormat { get { return _sampleVouchersOldFormat; } }
        public string SampleVouchersNewFormat { get { return _sampleVouchersNewFormat; } }
        public string FailedTestVouchers { get { return _failedTestVouchers; } }

        public int minSeq { get { return _minSeq; } }
        public int maxSeq { get { return _maxSeq; } }

        public VoucherMgr VoucherMgrProcess { get { return _voucherMgrProcess; } }

        public VoucherMgrTestBase() {
            ReadXmlIni();                       
            _voucherMgrProcess = new VoucherMgr(_voucherMgrPath);

        }



        protected virtual void Init()
        {
            Environment.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.XEnv.GetServerListByInterface("npdb")[0]);
            if (VOUCHER_OFFERID == null) VOUCHER_OFFERID = CreateContentOffer();
            if (VOUCHER_OFFERID1 == null) VOUCHER_OFFERID1 = CreateContentOffer();

        }


        public override void Run()
        {
            Init();
            Execute();
        }

        protected virtual void Execute()
        {
        }

        private const int cost_of_item = 21;
        private const uint TITLE_ID = 0x2D5A7DFF;
        private const uint CONTENT_REVENUE_SKU_ID = 5001; // using test SKU. old 0x05;
        private const string CONTENT_REVENUE_SKU = "XBX-00005";
        private const uint OFFER_CAMPAIGN = 0x00ff1234;

        
        
        
        public static string CreateContentOffer()
        {

            byte tier = 3;
            PaymentTypeEnum paymentType = PaymentTypeEnum.Token; 
            int priceWhole =10;
            int priceFractional=0;
            // *** TITLE ***
            XbosTitle title = new XbosTitle(TITLE_ID, false);
            title.Create();

            // *** OFFER ***
            RandomEx RandGen = new RandomEx();
            ulong offerId = ((ulong)TITLE_ID << 32) + (ulong)RandGen.Next(1, int.MaxValue);

            ContentOfferLoader.AddOffer(TITLE_ID,
                offerId,
                1000,
                2000,
                0,
                0x0002,  // content offer
                "Vouchermgr test",
                true);
            ContentOfferLoader.AddOfferRegion(offerId,
                103,
                tier,
                (int)paymentType,
                DateTime.UtcNow.AddYears(-1),
                DateTime.UtcNow.AddYears(1),
                "", // not used for content offers
                priceWhole,
                priceFractional,
                0);
            ContentOfferLoader.AddOfferCultureDetails(offerId,
                1033,
                "Vouchermgr test",
                "Vouchermgr test.");
            ContentOfferLoader.AddOfferSku((int)CONTENT_REVENUE_SKU_ID,
                OfferingSKUType.RevenueSKU,
                CONTENT_REVENUE_SKU,
                "Test SKU");
            ContentOfferLoader.AddOfferCampaign((int)OFFER_CAMPAIGN,
                "Test campaign");
            ContentOfferLoader.AddDmpOfferDetails(offerId,
                (int)CONTENT_REVENUE_SKU_ID,
                2, // premium content
                (int)OFFER_CAMPAIGN);

            if (paymentType == PaymentTypeEnum.Token)
            {
                TokendbWS.UnuseVoucher(XbosOffer.OFFER_VOUCHER_HASH);
                TokendbWS.DeleteVoucher(XbosOffer.OFFER_VOUCHER_HASH);
                TokendbWS.AddVoucherForOffer(XbosOffer.OFFER_VOUCHER_HASH, offerId, 1, 0, 2);
            }

            // the offers are cached by Offer.CreateInstance(), have to flush them
            // using random offer id now, cacheflush is not needed
            //Global.XEnv.ExecuteXmgmtCommand(Interface.xbos_billing_offering, "e :xbos CacheFlush");

            return "0x"+ offerId.ToString("X");

        }
        public void ReadXmlIni() {
            XmlNode XmlConfig = Global.Config.SelectSingleNode("descendant::VoucherMgrTest");
            if (XmlConfig == null) {
                throw new VoucherMgrException("ERROR: No .xml file found!  Important paths cannot be loaded.");
            }

            XmlNode defaultToolsPath = XmlConfig.SelectSingleNode("DefaultToolsPath");
            XmlNode voucherMgrExe = XmlConfig.SelectSingleNode("VoucherMgrExe");
            _voucherMgrPath = Path.Combine(Path.GetFullPath(defaultToolsPath.InnerXml), voucherMgrExe.InnerXml);

            _sampleVouchers = XmlConfig.SelectSingleNode("SampleVoucherFullPath").InnerXml;
            _sampleVouchersOldFormat = XmlConfig.SelectSingleNode("SampleVoucherFullPathOldFormat").InnerXml;
            _sampleVouchersNewFormat = XmlConfig.SelectSingleNode("SampleVoucherFullPathNewFormat").InnerXml;
            _failedTestVouchers = XmlConfig.SelectSingleNode("FailedTestVouchers").InnerXml;
            _minSeq = Int32.Parse(XmlConfig.SelectSingleNode("minSeq").InnerXml);
            _maxSeq = Int32.Parse(XmlConfig.SelectSingleNode("maxSeq").InnerXml);
        }

        public bool ImportTest(string filename, bool isFile, string offerid, int useCount, int useSCG, uint consoleVer, int min,
                               int max, int retries) {
            if ( ESP_SCG_Offer != offerid)
                ClearVouchers(offerid);
            VoucherMgrProcess.Import(filename, isFile, offerid, 23, useCount, useSCG, consoleVer, min, max, retries);
            Global.RO.Info(VoucherMgrProcess.Output);
            //parse the file and check that the expectedhashes actually made it up there.
            //bool success = VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
            bool success = Verify(filename, isFile, offerid, useCount, useSCG, consoleVer, true, min, max);            
            SetResultCode(success);
            return success;
        }


        public bool ImportTestNoClear(string filename, bool isFile, string offerid, int useCount, int useSCG, uint consoleVer, int min,
                               int max, int retries)
        {
            
            VoucherMgrProcess.Import(filename, isFile, offerid, 23, useCount, useSCG, consoleVer, min, max, retries);
            Global.RO.Info(VoucherMgrProcess.Output);
            //parse the file and check that the expectedhashes actually made it up there.
            //bool success = VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
            bool success = Verify(filename, isFile, offerid, useCount, useSCG, consoleVer, true, min, max);
            SetResultCode(success);
            return success;
        }

        public bool ImportTestOld(string filename, bool isFile, string offerid, int useCount, int useSCG, uint consoleVer, int min,
                               int max, int retries)
        {

            ClearVouchers(offerid);
            VoucherMgrProcess.ImportOld(filename, isFile, offerid, useCount, useSCG, consoleVer, min, max, retries);
            Global.RO.Info(VoucherMgrProcess.Output);
            //parse the file and check that the expectedhashes actually made it up there.
            //bool success = VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
            bool success = Verify(filename, isFile, offerid, useCount, useSCG, consoleVer, true, min, max);
            SetResultCode(success);
            return success;
        }
        public bool ImportTest(string filename, bool isFile, string emsofferid, string espofferid, int useCount, int useSCG, uint consoleVer, int min,
                               int max, int retries) {
            ClearVouchers(emsofferid);
            if (ESP_SCG_Offer != espofferid)
                ClearVouchers(espofferid);

            VoucherMgrProcess.Import(filename, isFile, emsofferid, 23, espofferid, useCount, useSCG, consoleVer, min, max, retries);
            Global.RO.Info(VoucherMgrProcess.Output);
            //parse the file and check that the expectedhashes actually made it up there.
            //bool success = VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);
            bool emsSuccess = Verify(filename, isFile, emsofferid, useCount, useSCG, consoleVer, true, min, max);
            if (emsSuccess) Global.RO.Success("ems vouchers insert successfully");
            else Global.RO.Error("EMS vouchers insert failed");


            bool espSuccess = Verify(filename, isFile, espofferid, useCount, useSCG, consoleVer, true, min, max);
            SetResultCode(emsSuccess && espSuccess);

            if (espSuccess) Global.RO.Success("esp vouchers insert successfully");
            else Global.RO.Error("ESP vouchers insert failed");

            return emsSuccess && espSuccess;
        }


        //this tool catches its own exceptions and does not return error codes.  Grep strings for
        //output instead.
        public void ExpectFailOfImportTest(string filename, bool isFile, string offerid, int useCount, int useSCG, uint consoleVer, 
                                           int min, int max, int retries, string expectedError) {
            VoucherMgrProcess.Import(filename, isFile, offerid, 23, useCount, useSCG, consoleVer, min, max, retries);
            Global.RO.Info(VoucherMgrProcess.Output);
            if (VoucherMgrProcess.Output.IndexOf(expectedError) == -1) {
                Global.RO.Error("Wrong error message output.  String \"" + expectedError + "\" not found!");
                SetResultCode (false);
            } else {
                SetResultCode(true);
            }
        }

        public bool DisableTest(VoucherType t, string filename, bool isFile, int min, int max)
        {
            bool espSuccess = true;
            bool emsSuccess = true;

            if (t == VoucherType.ESPOnly || t == VoucherType.Both)
            {
                ClearVouchers(VOUCHER_OFFERID);
                VoucherMgrProcess.Import(filename, isFile, VOUCHER_OFFERID, 23, -1, 0, 2, min, max, -1);
                Global.RO.Info(VoucherMgrProcess.Output);
            }

            if (t == VoucherType.EMSOnly || t == VoucherType.Both)
            {
                ClearVouchers(EMS_OFFERID);
                VoucherMgrProcess.Import(filename, isFile, EMS_OFFERID, 23, -1, 0, 2, min, max, -1);
            }
            //dummy up the import so we just get the range.
            //VoucherMgrProcess.Import(filename, isFile, VOUCHER_OFFERID, -1, 0, 2, min, max, -1);
            //VoucherMgrProcess.Import(filename, isFile, EMS_OFFERID, -1, 0, 2, min, max, -1);
            //VoucherMgrProcess.Enable(filename, isFile, min, max);
            VoucherMgrProcess.Disable(filename, isFile, min, max);

            if (t == VoucherType.ESPOnly || t == VoucherType.Both)
            {
                espSuccess = Verify(filename, isFile, VOUCHER_OFFERID, -1, 0, 2, false, min, max);
                if (espSuccess) Global.RO.Success("ESP vouchers disable successfully");
                else Global.RO.Error("ESP vouchers disable failed");
            }

            if (t == VoucherType.EMSOnly || t == VoucherType.Both)
            {
                emsSuccess = Verify(filename, isFile, EMS_OFFERID, -1, 0, 2, false, min, max);
                if (emsSuccess) Global.RO.Success("EMS vouchers disable successfully");
                else Global.RO.Error("EMS vouchers disable failed");
            }

            
            SetResultCode(espSuccess && emsSuccess);
            return espSuccess && emsSuccess;
        }



        //expect that item is not disabled, because of some bad argument.
        public void ExpectFailOfDisableTest(string filename, bool isFile, int min, int max, string expectedError) {
            VoucherMgrProcess.Disable(filename, isFile, min, max);
            Global.RO.Info(VoucherMgrProcess.Output);
            if (VoucherMgrProcess.Output.IndexOf(expectedError) == -1) {
                Global.RO.Error("Wrong error message output.  String \"" + expectedError + "\" not found!");
                SetResultCode (false);
            } else {
                SetResultCode(true);
            }
        }

        public bool EnableTest(VoucherType t, string filename, bool isFile, int min, int max)
        {
            bool espSuccess = true;
            bool emsSuccess = true;

            if (t == VoucherType.ESPOnly || t == VoucherType.Both)
            {
                ClearVouchers(VOUCHER_OFFERID);
                VoucherMgrProcess.Import(filename, isFile, VOUCHER_OFFERID, 23, -1, 0, 2, min, max, -1);
                Global.RO.Info(VoucherMgrProcess.Output);
            }

            if (t == VoucherType.EMSOnly || t == VoucherType.Both)
            {
                ClearVouchers(EMS_OFFERID);
                VoucherMgrProcess.Import(filename, isFile, EMS_OFFERID, 23, -1, 0, 2, min, max, -1);
            }
            //ClearVouchers(VOUCHER_OFFERID);
            //ClearVouchers(EMS_OFFERID);
            //dummy up the import so we just get the range.
            //VoucherMgrProcess.Import(filename, isFile, VOUCHER_OFFERID, -1, 0, 2, min, max, -1);
            //VoucherMgrProcess.Import(filename, isFile, EMS_OFFERID, -1, 0, 2, min, max, -1);
            VoucherMgrProcess.Disable(filename, isFile, min, max);
            VoucherMgrProcess.Enable(filename, isFile, min, max);

            if (t == VoucherType.ESPOnly || t == VoucherType.Both)
            {
                espSuccess = Verify(filename, isFile, VOUCHER_OFFERID, -1, 0, 2, true, min, max);

                if (espSuccess) Global.RO.Success("ESP vouchers enable successfully");
                else Global.RO.Error("ESP vouchers enable failed");
            }

            if (t == VoucherType.EMSOnly || t == VoucherType.Both)
            {
                emsSuccess = Verify(filename, isFile, EMS_OFFERID, -1, 0, 2, true, min, max);
                if (emsSuccess) Global.RO.Success("EMS vouchers enable successfully");
                else Global.RO.Error("EMS vouchers enable failed");
            }

            SetResultCode(emsSuccess && espSuccess);
            return emsSuccess && espSuccess;
        }

        public bool DeleteTest(string filename, bool isFile, int min, int max) {
            ClearVouchers(VOUCHER_OFFERID);
            ClearVouchers(EMS_OFFERID);
            //dummy up the import so we just get the range.
            VoucherMgrProcess.Import(filename, isFile, VOUCHER_OFFERID, 23, -1, 0, 2, min, max, -1);
            VoucherMgrProcess.Import(filename, isFile, EMS_OFFERID, 23, -1, 0, 2, min, max, -1);
            VoucherMgrProcess.Delete(filename, isFile, "", min, max, -1);
            bool espSuccess = VerifyMissing(filename, isFile, VOUCHER_OFFERID, min, max);

            if (espSuccess) Global.RO.Success("ESP vouchers delete successfully");
            else Global.RO.Error("ESP vouchers delete failed");
            bool emsSuccess = VerifyMissing(filename, isFile, EMS_OFFERID, min, max);

            if (emsSuccess) Global.RO.Success("EMS vouchers delete successfully");
            else Global.RO.Error("EMS vouchers delete failed");
            
            SetResultCode(espSuccess && emsSuccess);
            return espSuccess && emsSuccess;
        }

	    public bool ViewTest(string filename, bool isFile, int minSeq, int maxSeq, VoucherType t)
        {
            string output = VoucherMgrProcess.View(filename, isFile, minSeq, maxSeq);
            Global.RO.Info(output);
            string expected;

            if (t == VoucherType.ESPOnly)
            {
                expected = string.Format(
                    "hash: 0x29fbbbd0b8c1980869d3db7d45b40c8b9c245263\r\nOffer ID: {0}      Use count: -1         Status: Active            SCG: 0    Console Version: 2\r\n\r\nhash: 0x07da0a2cf3fac0c6045173ff98555664be9c7598\r\nOffer ID: {1}      Use count: -1         Status: Active            SCG: 0    Console Version: 2\r\n\r\n",
                    VOUCHER_OFFERID, VOUCHER_OFFERID);
            }
            else if (t == VoucherType.EMSOnly)
            {
                expected = string.Format(
                    "hash: 0x21ed3b549bc83f9d848e2fdfe4f7902fd193bf7c\r\nNo uses registered.\r\nOffer ID: {0}      Media Type Id: 23      Use count: 6         Status: Active            SCG: 0    Console Version: 2\r\nUses\r\n----\r\n",
                    EMS_ArcadeOfferId);
            }
            else if (t == VoucherType.ESPViewState)
            {
                expected = string.Format(
                    "hash: 0x995e4dca68c6dc4365a8f030ab9f963fb96a7ce0\r\nOffer ID: {0}      Use count: -1         Status: Active            SCG: 0    Console Version: 2\r\nUses\r\n----\r\n",
                    VOUCHER_OFFERID1);
            }
            else
            {
                return true;
            }

            if (output.ToLower().Replace(" ", "").Contains(expected.ToLower().Replace(" ", ""))) 
                return true;
            else 
                return false;
	    }

        public bool EspSummary()
        {
            Global.RO.Info(VoucherMgrProcess.Summary());
            return true;
        }
        

        public bool EmsSummary()
        {
            Global.RO.Info(VoucherMgrProcess.EmsSummary());
            return true;
        }


        //if delete is true...we really need to know the state beforehand to do any out-of-range
        //checking.  For here, we will verify that in the file, for every sequence in the range,
        //there is no entry with that offerId and hash.
        public bool VerifyMissing(string filename, bool isFile,
                                  string offerid, 
                                  int min, int max) {
            if (isFile) {
                //parse
                VoucherFile samples = new VoucherFile(filename);
                VoucherData data = new VoucherData();
                bool success = true;
                samples.Reset();
                while (samples.FillWithData(data)) {
                    bool inRange = (((data.seqNum >= min) || min == -1) &&
                                     ((data.seqNum <= max) || max == -1));
                    if (!inRange) { continue; }  //we won't care about entries outside of the range.
                    bool found = IsInDB(data.hash, offerid, false);
                    if (found) {
                        Global.RO.Warn("seqNum:" + data.seqNum + " should have been deleted, but was found!");
                        success = false;
                    }
                }
                return success;
            } else {
                //handle strings!
                Global.RO.Error("String not supported yet");
                return false;
            }           
        }

        //Given a range, verify that every entry before the min is not present, that every range in
        //between is present, and that every entry after is not present.  All entries are from the
        //sample file.
        public bool Verify(string filename, bool isFile,
                           string offerid, int useCount,
                           int useSCG, uint consoleVer, bool enable,
                           int min, int max) {
            if (isFile) {
                //parse
                VoucherFile samples = new VoucherFile(filename);
                VoucherData data = new VoucherData();
                bool success = true;
                samples.Reset();
                
                while (samples.FillWithData(data)) {
                    bool found = IsInDB(data.hash, offerid, useCount, useSCG, consoleVer, enable, true);
                    bool expected = (((data.seqNum >= min) || min == -1) &&
                                     ((data.seqNum <= max) || max == -1));
                    //Global.RO.Info("\n SeqNumber = {0}, Min = {1}, Max = {2} ", data.seqNum, min, max);
                    bool entryOkay = (expected && found) || (!expected && !found);
                    if (!entryOkay) {
                        Global.RO.Warn("seqNum:" + data.seqNum + "  dataPresent:" + found + "  expected:" + expected);
                    }
                    success = success && entryOkay;                                                                                 
                }
                return success;
            } else {
                //handle strings!
                Global.RO.Error("String not supported yet");
                return false;
            }
        }


        bool IsEmsOfferId(string offerId) {
             
            try
            {
                Guid guidId = new Guid(offerId);
                return true;
            }
            catch
            {
                return false;
            }
        }


        public void ClearVouchers(string offerid) {
            string sql;

            if (IsEmsOfferId(offerid))
                sql = "delete FROM t_tokens WHERE uid_offer_id= '" + offerid + "'";
            else
                sql = "delete FROM t_vouchers WHERE bi_offer_id = " + offerid;

            Global.RO.Info("Query {0}", sql);
		
            int FieldsAffected = 0;          
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                for (int p = 0; p < ws.PhysicalPartitions; p++)
                {
                    ws.PhysicalPartition = p;
                    ws.CommandSql = sql;
                    FieldsAffected += ws.ExecuteNonQuery();
                }
                Global.RO.Info("Fields affected = {0}", FieldsAffected);
            }
            //UodbWS.ExecuteNonQuery(query);
            //UodbWS.ExecuteSQLNonQuery(query, BitConverter.ToInt64(hashBytes, 0));
        }

        //less time-consuming.  Merely checks that the number of hashes of that offerID is equal to
        //the number expected.
        public bool VerifyNumberOfHashes(string offerid, int numExpected) {
            string query = "select COUNT(*) FROM t_vouchers WHERE bi_offer_id = " + offerid;
	     return true;
            //return (UodbWS.ExecuteScalarExpectingResult(query, numExpected));            
        }

        public bool IsInDB(string hash, string offerid, bool quiet) {
            string query;

            if (IsEmsOfferId(offerid))
                query = "select COUNT(*) FROM t_tokens WHERE bin_token_hash = 0x" + hash + " AND uid_offer_id = '" + offerid+ "'";
            else
                query = "select COUNT(*) FROM t_vouchers WHERE bin_voucher_hash = 0x" + hash + " AND bi_offer_id = " + offerid;

            if (!quiet) {
                Global.RO.Info(query);
            }
            bool exist = false;
           /* using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.Partition = WstCommand.AnyPartition;
                ws.CommandSql = query;

                if (ws.ExecuteScalar() != null)
                {
                    Global.RO.Info("Row exists - 3 param IsInDB function");
                    exist = true;
                }
                return exist;
            }*/
            byte[] hashBytes = Hexer.unhex(hash);
            object result = (int)(TokendbWS.ExecuteSQLScalar(query, BitConverter.ToInt64(hashBytes, 0)));
		   Global.RO.Info("Return: " + (int)result);
	    if (result == null)
			exist = false;
	    else if ((int)result > 0)
			exist = true;
	    return exist;
		
           // return (UodbWS.ExecuteScalarExpectingResult(query, 1));            
        }

        public bool IsInDB(string hash, string offerid, int useCount, int useSCG, uint consoleVer, bool enable, bool quiet) {
            int enableNum = enable ? 0 : 1; //enable = 0, disable = 1.
            //Global.RO.Info("Select * {0}", here," {1}", enableNum);
            //Global.RO.Info("select * FROM t_vouchers WHERE bin_voucher_hash = 0x{0} AND bi_offer_id = {1} AND i_use_count = {2} AND f_in_scg = {3} AND f_console_version = {4} AND i_voucher_status_id =  {5}", hash, offerid, useCount, useSCG, consoleVer, enableNum);
            string query;

            if (IsEmsOfferId(offerid))
                query = "select COUNT(*) FROM t_tokens WHERE bin_token_hash = 0x" + hash + " AND uid_offer_id = '" + offerid + "'" +
                    " AND i_use_count = " + useCount + " AND f_in_scg = " + useSCG + " AND f_console_version = " + consoleVer +
                    "AND i_token_status_id = " + enableNum;
            else
                query = "select COUNT(*) FROM t_vouchers WHERE bin_voucher_hash = 0x" + hash + " AND bi_offer_id = " + offerid +
                    " AND i_use_count = " + useCount + " AND f_in_scg = " + useSCG + " AND f_console_version = " + consoleVer +
                    "AND i_voucher_status_id = " + enableNum;
            if (!quiet) {
                Global.RO.Info(query);
            }

               bool exist = false;
          // return (UodbWS.ExecuteScalarExpectingResult(query, 1));
            byte[] hashBytes = Hexer.unhex(hash);
            object result = (int)(TokendbWS.ExecuteSQLScalar(query, BitConverter.ToInt64(hashBytes, 0)));
	    //Global.RO.Info("Return: " + (int)result);
	    if (result == null)
			exist = false;
	    else if ((int)result > 0)
			exist = true;
	    return exist;
		
        }

        /// <summary>
        /// This is a bit of a hack right now, but this will just cause an 
        /// exception to be thrown if the test should be failed.  Doesn't 
        /// really do what it says, but this is the easiest way to fix up
        /// all of the places it's used.
        /// </summary>
        /// <param name="success">True if the test is passed, false otherwise</param>
        public void SetResultCode(bool success) 
        {
            if(!success)
            {
                throw new UnexpectedTestResultException("VoucherMgr Test Failed");
            }
        }

    }

    public class VoucherFile {
        private StreamReader _fileStream;
        private string _filename;

        public VoucherFile(string filename) {
            //Preprocess--grab the entire offer map and store it in a structure.
            _filename = filename;
            _fileStream = File.OpenText(filename);
        }
        
        //returns true if there is a line to be read.  Fills the data with that line.  Returns false
        //and leaves data unchanged otherwise.
        public bool FillWithData(VoucherData data) {
            String line = _fileStream.ReadLine();
            if (line == null) return false;
            String [] columns = line.Split(new Char [] {','});
            data.seqNum = (uint) uint.Parse(columns[1]);
            if (columns.Length >4)
                data.hash = columns[4];
            else
                data.hash = columns[3];
            return true;
        }

        //start reading from the top.
        public void Reset() {
            _fileStream.Close();
            _fileStream = File.OpenText(_filename);
        }
       
    }
    public class VoucherData {
        public uint seqNum;
        public string hash;
    }
            

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\VoucherMgrTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_vouchermgrtest_none_12.4.56.0_none_240356065b616c01
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=vouchermgrtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df.manifest
XP_MANIFEST_PATH=manifests\msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df.cat
XP_CATALOG_PATH=manifests\msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df.cat
XP_PAYLOAD_PATH=msil_vouchermgrtest_no-public-key_12.4.56.0_x-ww_ccc620df
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=vouchermgrtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\VoucherMgrTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCIntegration\Stress.cs ===
using System;
using ServerTestFramework;

namespace WCIntegration
{
    [StressInstantiate]
    public class StressSimple : TestBase
    {
        protected override void Execute()
        {
        }
    }

    [StressInstantiate]
    public class StressSimpleTwo : TestBase
    {
        protected override void Execute()
        {
        }
    }

    [StressInstantiate]
    public class StressFailer : TestBase
    {
        protected override void Execute()
        {
            throw new UnexpectedTestResultException("Not really unexpected.");
        }
    }

    [StressInstantiate]
    public class StressDeadlocker : TestBase
    {
        protected override void Execute()
        {
            if (RandGen.Next(100) == 0)
            {
                System.Threading.Thread.Sleep(11000);
                throw new UnexpectedTestResultException("This should've deadlocked!");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\WCUtil.cs ===
using System;
using System.IO;
using System.Net;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.WebWidget;
//using ServerTestFramework.Web.UtilWrapper;
using WCUtilTest.WCutilWrapper;

namespace WCUtilTest
{
	public class WCRequestInfo
	{
		public string SubjectName;
		public string ClientIPPort;
		public string RequestId;

		public WCRequestInfo()
		{
			SubjectName = "t2client1";
			ClientIPPort = "1.2.3.4:0";
			RequestId = "CAFEBABEDEADBEEF";
		}

		public WCRequestInfo(string subjectName)
		{
			SubjectName = subjectName;
			ClientIPPort = "1.1.1.1:1000";
			RequestId = "CAFEBABEDEADBEEF";
		}

		public WCRequestInfo(string subjectName, string clientIPPort, string requestId)
		{
			SubjectName = subjectName;
			ClientIPPort = clientIPPort;
			RequestId = requestId;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCIntegration\Func.cs ===
using System;
using ServerTestFramework;

namespace WCIntegration
{
	public class FuncSimpleGroup : TestNode
	{
		protected STFHost m_host;
		protected string m_sEnvironment;
		protected uint m_uiTimeout;
		TitleInfoList titles;

		public FuncSimpleGroup(string sUrl, string sEnvironment, uint uiTimeout)
		{
			m_host = new STFHost();
			m_host.Url = sUrl;
			m_sEnvironment = sEnvironment;
			m_uiTimeout = uiTimeout;
			name = sEnvironment + "  (" + sUrl + ")";
		}

		[TestCase, Description("Verify I can retrieve the title list")]
		class GetTitleList : TestBase
		{

			protected override void Execute()
			{
				if(this.Parent.GetType() != typeof(FuncSimpleGroup))
					return;

				FuncSimpleGroup p = (FuncSimpleGroup) this.Parent;
				
				p.titles = p.m_host.GetTitleList(p.m_sEnvironment, p.m_uiTimeout);
				
				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCIntegration\WCIntegration.cs ===
using System;
using System.Xml;
using ServerTestFramework;

namespace WCIntegration
{
	// Must be named the same as the namespace
	public struct Environment
	{
		public string sUrl;
		public uint uiTimeout;
	}

	public class WCIntegration : TestSuite
	{
		Environment[] m_envs = null;

		public override void Initialize(XmlDocument config)
		{
            XmlNodeList envs = config.SelectNodes("//stf/config/integration/environments/environment");
			Environment[] es;
			// Pull the list of environments from the configuration file
			if (envs != null && envs.Count > 0)
			{
				es = new Environment[envs.Count];
				int c = 0;
				// I will grab each environment and try to hit the method to ensure that the environment
				// exists.
				foreach (XmlNode env in envs)
				{
					if(env.NodeType == System.Xml.XmlNodeType.Element && env.Name == "environment")
					{
						foreach(XmlAttribute attr in env.Attributes)
						{
							if(attr.Name == "url")
							{
								es[c].sUrl = attr.Value;
							}
							else if(attr.Name == "timeout")
							{
								es[c].uiTimeout = System.Convert.ToUInt32(attr.Value);
							}
						}
						if(es[c].sUrl != null && es[c].sUrl != "")
						{
							/* Test the url given to see if it is valid.  If so, leave this entry
							 * otherwise overwrite on the next iteration.
							 */
							try
							{
								STFHost host = new STFHost();
								string [] res;
								host.Url = es[c].sUrl;
								res = host.GetEnvironments();
								if(res == null || res.Length == 0)
								{
									es[c].uiTimeout = 0;
									es[c].sUrl = null;
									continue;
								}
							}
							catch(System.Exception e)
							{
								Console.Write(ExceptionInfo(e, false));
								es[c].sUrl = null;
								es[c].uiTimeout = 0;
								continue;
							}							
							c++;
						}
						else
						{
							es[c].uiTimeout = 0;
							es[c].sUrl = null;
						}
					}
				}

				if(c != 0)
				{
					m_envs = new Environment[c];
					for(int i = 0; i < c; ++i)
					{
						m_envs[i] = es[i];
					}
				}
			}
		}

		public static string ExceptionInfo(System.Exception e, bool fHtml)
		{
			return ExceptionInfo(e, fHtml, 0);
		}

		protected static string Repeat(string str, uint count)
		{
			string res = "";
			for(int i = 0; i < count; ++i)
				res += str;
			return res;
		}

		protected static string ExceptionInfo(System.Exception e, bool fHtml, uint depth)
		{
			
			string s;
			s  = ((fHtml) ? "<li>" : Repeat("\t", depth) ) + "Message: " + e.Message + ((fHtml) ? "<br>\n" : "\n");
			if(e.TargetSite != null)
				s += ((fHtml) ? "<li>" : Repeat("\t", depth) ) + "Method: " + e.TargetSite.ToString() + ((fHtml) ? "<br>\n" : "\n");
			if(e.HelpLink != null && e.HelpLink.Length != 0)
				s += ((fHtml) ? "<li>" : Repeat("\t", depth) ) + "Help Link: " + e.HelpLink + ((fHtml) ? "<br>\n" : "\n");
			if(e.StackTrace != null)
				s += ((fHtml) ? "<li>" : Repeat("\t", depth) ) + "Call Stack: " + e.StackTrace + ((fHtml) ? "<br>\n" : "\n");
			if(e.InnerException != null)
				s += ((fHtml) ? "<ul>" : Repeat("\t", depth) + "InnerException:") + ExceptionInfo(e.InnerException, fHtml, depth + 1) + ((fHtml) ? "</ul>\n" : "\n");
			return s;
		}

		public TestBaseGroupList GetTests(XmlDocument config)
		{
			Initialize(config);
			return GetTests();
		}

		public override TestBaseGroupList GetTests()
		{
			TestBaseGroupList tests = new TestBaseGroupList();
			
			/*
			 * First go to the specified service and retrieve 
			 * 
			 */
			if(m_envs != null && m_envs.Length > 0)
			{
				foreach(Environment e in m_envs)
				{
					try
					{
						STFHost host = new STFHost();
						host.Url = e.sUrl;
						string[] res = host.GetEnvironments();
						foreach(string s in res)
						{
							try
							{
								tests.Add(new FuncSimpleGroup(e.sUrl, s, e.uiTimeout));
							}
							catch
							{
							}
						}
					}
					catch
					{
					}
				}
			}

			return tests;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\StressWC.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
//using ServerTestFramework.Web.UtilWrapper;
using WCUtilTest.WCutilWrapper;
using WCUtilTest.WebWidget;
using ServerTestFramework.LiveService.UserAccount;

namespace WCUtilTest
{
	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressMedium : TestBase
	{
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			try
			{
				util.QuickCacheInsert(CacheType.FriendsPresence, 12400, 86400);
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressSmall : TestBase
	{
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			try
			{
				util.QuickCacheInsert(CacheType.FriendsPresence, 1024, 86400);
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressLarge : TestBase
	{
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			try
			{
				util.QuickCacheInsert(CacheType.FriendsPresence, 33000, 86400);
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressPUIDLookup : TestBase
	{
		public static System.UInt64 puid = 0;
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;
			try
			{
				puid = util.LookupPUID("webuser42");
				if (puid == 0) 
				{ 
					ResultCode=TEST_RESULTS.FAILED; 
				}
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressTeamPUIDLookup : TestBase
	{
		public static System.UInt64 puid = 0;
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			uint uiTitleID = 0xB2D2;
			string sTeamName = "webteam42";

			try
			{
				puid = util.LookupTeamPUID(uiTitleID, sTeamName);
				if (puid == 0) 
				{ 
					ResultCode=TEST_RESULTS.FAILED; 
				}
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=12)]
	class CacheStressTeamPUIDLookupx100 : TestBase
	{
		public static System.UInt64 puid = 0;
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			uint uiTitleID = 0xB2D2;
			string sTeamName = "webteam42";

			try
			{
				puid = util.LookupTeamPUIDx100(uiTitleID, sTeamName);
				if (puid == 0) 
				{ 
					ResultCode=TEST_RESULTS.FAILED; 
				}
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressTeamNameLookup : TestBase
	{
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;
			ulong ulTeamPuid = 0xFEFE0000B2D2FFA1;
			uint uiTitleID = 0xB2D2;
			string sTeamName;

			try
			{
				sTeamName = util.LookupTeamName(uiTitleID, ulTeamPuid);
				if (!sTeamName.Equals("webteam94")) 
				{ 
					ResultCode=TEST_RESULTS.FAILED; 
				}
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=12)]
	class CacheStressTeamNameLookupx100 : TestBase
	{
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;
			ulong ulTeamPuid = 0xFEFE0000B2D2FFA1;
			uint uiTitleID = 0xB2D2;
			string sTeamName;

			try
			{
				sTeamName = util.LookupTeamNamex100(uiTitleID, ulTeamPuid);
				if (!sTeamName.Equals("webteam94")) 
				{ 
					ResultCode=TEST_RESULTS.FAILED; 
				}
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressPUIDLookupMiss : TestBase
	{
		public static System.UInt64 puid = 0;
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			try
			{
				puid = util.LookupPUID("notfound");
				if (puid != 0) 
				{ 
					ResultCode=TEST_RESULTS.FAILED; 
				}
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressWebIDLookup : TestBase
	{
		public static byte[] WebID = new byte[8];
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		public CacheStressWebIDLookup()
		{
			WebID[0] = 0x7E;
			WebID[1] = 0xFE;
			WebID[2] = 0xFF;
			WebID[3] = 0xFF;
			WebID[4] = 0xFF;
			WebID[5] = 0xFF;
			WebID[6] = 1;
			WebID[7] = 0;
		}

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			try
			{
				PUIDAndOwner PaO = util.LookupWebID(WebID, "webuser639");
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=20)]
	class CacheStressWebIDLookupx100 : TestBase
	{
		public static byte[] WebID = new byte[8];
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		public CacheStressWebIDLookupx100()
		{
			WebID[0] = 0x7E;
			WebID[1] = 0xFE;
			WebID[2] = 0xFF;
			WebID[3] = 0xFF;
			WebID[4] = 0xFF;
			WebID[5] = 0xFF;
			WebID[6] = 1;
			WebID[7] = 0;
		}

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			try
			{
				PUIDAndOwner PaO = util.LookupWebIDx100(WebID, "webuser639");
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressWebIDLookupMiss : TestBase
	{
		public static byte[] WebID = new byte[8];
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		public CacheStressWebIDLookupMiss()
		{
			WebID[0] = 0;
			WebID[1] = 0;
			WebID[2] = 0;
			WebID[3] = 0;
			WebID[4] = 0;
			WebID[5] = 0;
			WebID[6] = 1;
			WebID[7] = 0;
		}

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			// We're supposed to throw an exception if the WebID isn't there
			try
			{
				PUIDAndOwner PaO = util.LookupWebID(WebID, "doesntexist");
				ResultCode=TEST_RESULTS.FAILED;
			}
			catch
			{
				ResultCode=TEST_RESULTS.PASSED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressGamerTagLookup : TestBase
	{
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			try
			{
				System.UInt64 puid = 0x0009FFFFFFFFFF80;
				string gamerTag = util.LookupGamerTag(puid);
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=10)]
	class CacheStressGamerTagLookupMiss : TestBase
	{
		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;
			WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
			try
			{
				System.UInt64 puid = 733;
				string gamerTag = util.LookupGamerTag(puid);
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}

	[StressInstantiate, StressTest(Priority=100)]
	class CacheStressBatchLookupx100 : TestBase
	{
		public static WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
		public static string[] gtArray = new string[100];
		public static ulong[] puidArray = new ulong[100];

		public CacheStressBatchLookupx100()
		{
			for(uint i = 1; i <= gtArray.Length; i++)
			{
				gtArray[i-1] = "webuser"+i;
			}
		}

		override protected void Execute()
		{
			ResultCode=TEST_RESULTS.PASSED;

			try
			{
				puidArray = util.LookupPUIDBatch(gtArray);
				gtArray = util.LookupGamerTagBatch(puidArray);
			}
			catch
			{
				ResultCode=TEST_RESULTS.FAILED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\WCUtilTestCacheInsert.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
//using ServerTestFramework.Web.UtilWrapper;
using WCUtilTest.WCutilWrapper;
using WCUtilTest.WebWidget;

namespace WCUtilTest
{
	public class FuncCacheMethods : TestNode
	{
		public static CacheType[] m_ct = new CacheType[3];
		public static UInt32 m_uiExpire = 10;

            protected static RandomEx RandGen = new RandomEx();



		public FuncCacheMethods()
		{
			m_ct[0] = CacheType.FriendsPresence;
			m_ct[1] = CacheType.StatChunk;
			m_ct[2] = CacheType.UserSettings;
		}

		[TestCase, Description("Mainline cache Insert")]
		class MainCacheInsert : TestBase
		{
			override protected void Execute()
			{
				byte[] rgbKey = new byte[8];

				RandGen.NextBytes(rgbKey);

				// Insert an item into the cache
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				foreach(CacheType ct in m_ct)
				{
					if(!util.ArbitraryCacheInsert(ct, rgbKey, 101, m_uiExpire))
					{
						ResultCode=TEST_RESULTS.FAILED;
					}
				}
			}
		}

		[TestCase, Description("Ensure that the cache item times out.")]
		class CacheTimeout : TestBase
		{
			override protected void Execute()
			{
				uint uiValueLen = 24;
				uint uiExpireTimeInSecs = 5;
				byte[] rgbKey = new byte[8];
				byte[] rgbValue = new byte[uiValueLen];
				byte[] rgbReturn = new byte[uiValueLen];
				RandGen.NextBytes(rgbKey);
				RandGen.NextBytes(rgbValue);

				// Insert 1000 items into the cache as fast as possible
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					util.CacheInsert(CacheType.FriendsPresence, rgbKey, rgbValue, uiExpireTimeInSecs);
				} 
				catch (Exception)
				{ 
					ResultCode=TEST_RESULTS.FAILED;
				}
					
				// Wait until the item has almost expired
				System.Threading.Thread.Sleep((int)(uiExpireTimeInSecs-1) * 1000);
				rgbReturn = util.CacheLookup(CacheType.FriendsPresence, rgbKey);

				// Validate that we get what we want
				for(uint i = 0; i < uiValueLen; i++)
				{
					if(rgbReturn[i] != rgbValue[i])
						ResultCode=TEST_RESULTS.FAILED;
				}

				System.Threading.Thread.Sleep(2000);
				// Now that item should be expired
				rgbReturn = util.CacheLookup(CacheType.FriendsPresence, rgbKey);

				if(rgbReturn != null)
				{
					ResultCode=TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("1 Million 1 byte inserts")]
		class CacheInsert1Milx1 : TestBase
		{
			override protected void Execute()
			{
				// Insert 1000 items into the cache as fast as possible
				ResultCode=TEST_RESULTS.PASSED;
				UInt32 numToInsert = 1000000;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					util.QuickCacheInsertX(CacheType.FriendsPresence, 1, m_uiExpire, numToInsert);
				}
				catch
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				float TPS = numToInsert/Elapsed;
				Console.WriteLine("\n    TPS " + TPS.ToString("F0"));
			}
		}

		[TestCase, Description("1 Million 64 byte inserts")]
		class CacheInsert1Milx64 : TestBase
		{
			override protected void Execute()
			{
				// Insert 1000 items into the cache as fast as possible
				UInt32 numToInsert = 1000000;
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					util.QuickCacheInsertX(CacheType.FriendsPresence, 64, m_uiExpire, numToInsert);
				}
				catch
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				float TPS = numToInsert/Elapsed;
				Console.WriteLine("\n    TPS " + TPS.ToString("F0"));
			}
		}

		[TestCase, Description("1 Million 256 byte inserts")]
		class CacheInsert1Milx256 : TestBase
		{
			override protected void Execute()
			{
				// Insert 1,000,000 items into the cache at 256 bytes each
				// 250 megs
				UInt32 numToInsert = 1000000;
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					util.QuickCacheInsertX(CacheType.FriendsPresence, 256, m_uiExpire, numToInsert);
				}
				catch
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				float TPS = numToInsert/Elapsed;
				Console.WriteLine("\n    TPS " + TPS.ToString("F0"));
			}
		}

		[TestCase, Description("100,000 1024 byte inserts")]
		class CacheInsert100000x1024 : TestBase
		{
			override protected void Execute()
			{
				// Insert 100000 items into the cache
				// Roughly 100 megs
				uint numToInsert = 100000;
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					util.QuickCacheInsertX(CacheType.FriendsPresence, 1024, m_uiExpire, numToInsert);
				}
				catch
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				float TPS = numToInsert/Elapsed;
				Console.WriteLine("\n    TPS " + TPS.ToString("F0"));
			}
		}

		[TestCase, Description("10,000 10240 byte inserts")]
		class CacheInsert10000x10240 : TestBase
		{
			override protected void Execute()
			{
				// Insert 10000 items into the cache as fast as possible
				// Roughly 100 megs
				uint numToInsert = 10000;
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					util.QuickCacheInsertX(CacheType.FriendsPresence, 10240, m_uiExpire, numToInsert);
				}
				catch
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				float TPS = numToInsert/Elapsed;
				Console.WriteLine("\n    TPS " + TPS.ToString("F0"));
			}
		}

		[TestCase, Description("1000 102400 byte inserts")]
		class CacheInsert1000x102400 : TestBase
		{
			override protected void Execute()
			{
				// Insert 1000 items each 102k large, 1000 times
				// Roughly 100 megs
				uint numToInsert = 1000;
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					util.QuickCacheInsertX(CacheType.FriendsPresence, 102400, m_uiExpire, numToInsert);
				}
				catch
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				float TPS = numToInsert/Elapsed;
				Console.WriteLine("\n    TPS " + TPS.ToString("F0"));
			}
		}


		[TestCase, Description("Minimum cache Insert")]
		class MinCacheInsert : TestBase
		{
			override protected void Execute()
			{
				byte[] rgbKey = new byte[1];

				rgbKey.Initialize();

				// Insert an item into the cache
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				foreach(CacheType ct in m_ct)
				{
					if(!util.ArbitraryCacheInsert(ct, rgbKey, 0, m_uiExpire))
					{
						ResultCode=TEST_RESULTS.FAILED;
					}
				}
			}
		}

		[TestCase, Description("Double Insert")]
		class DoubleCacheInsert : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				byte[] rgbKey = new byte[8];
				byte[] rgbValue = new byte[101];

				RandGen.NextBytes(rgbKey);
				RandGen.NextBytes(rgbValue);

				// Insert an item into the cache twice
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					foreach(CacheType ct in m_ct)
					{
						util.CacheInsert(ct, rgbKey, rgbValue, m_uiExpire);
						util.CacheInsert(ct, rgbKey, rgbValue, m_uiExpire);
					}
				}
				catch (Exception)
				{
					ResultCode=TEST_RESULTS.FAILED;
				}
			}
		}

		[TestCase, Description("Bad Insert")]
		class BadCacheInsert : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				byte[] rgbKey = new byte[8];
				byte[] rgbValue = new byte[100];

				RandGen.NextBytes(rgbKey);
				RandGen.NextBytes(rgbValue);

				// Insert an item into the cache with a bad cache type
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				try
				{
					util.CacheInsert(CacheType.UserSettings+6, rgbKey, rgbValue, m_uiExpire);
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception)	{}
			}
		}

		[TestCase, Description("Bad Insert")]
		class NegativeLookup : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;
				byte[] rgbKey = new byte[8];
				byte[] rgbValue = new byte[101];
				byte[] rgbRecv = new byte[101];

				RandGen.NextBytes(rgbKey);
				RandGen.NextBytes(rgbValue);

				// Insert an item into the cache twice
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				foreach(CacheType ct in m_ct)
				{
					util.CacheInsert(ct, rgbKey, rgbValue, m_uiExpire);

					// Look up with a key that doesn't point to anything
					// which should also find nothing.  There could be a collision
					// here if the key generate is the same as a prev insert
					RandGen.NextBytes(rgbKey);
					rgbRecv = util.CacheLookup(ct, rgbKey);
					if(rgbRecv != null)
					{
						ResultCode=TEST_RESULTS.FAILED;
					}

					try
					{
						rgbRecv = util.CacheLookup(ct, null);
						ResultCode=TEST_RESULTS.FAILED;
					} 
					catch (Exception){}
				}
			}
		}

		[TestCase, Description("Expiring Cache Insert")]
		class ExpiringCacheInsert : TestBase
		{
			override protected void Execute()
			{
				byte[] rgbKey = new byte[8];

				RandGen.NextBytes(rgbKey);

				// Insert an item into the cache
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				foreach(CacheType ct in m_ct)
				{
					if(!util.ArbitraryCacheInsert(ct, rgbKey, 101, 0))
					{
						ResultCode=TEST_RESULTS.FAILED;
					}
				}
			}
		}

		[TestCase, Description("Never ending Cache Insert")]
		class NeverEndingInsert : TestBase
		{
			override protected void Execute()
			{
				byte[] rgbKey = new byte[8];

				RandGen.NextBytes(rgbKey);

				// Insert an item into the cache
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
				foreach(CacheType ct in m_ct)
				{
					if(!util.ArbitraryCacheInsert(ct, rgbKey, 101, 4294967295))
					{
						ResultCode=TEST_RESULTS.FAILED;
					}
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\WCUtilTestGenInfo.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Utilities;
//using ServerTestFramework.Web.UtilWrapper;
using WCUtilTest.WCutilWrapper;
using WCUtilTest.WebWidget;

namespace WCUtilTest
{
	public class FuncGeneralInfo : TestNode
	{
		[TestCase]
			class FuncGetPartnerSpecificTitleInfo : TestBase
		{
			protected string DisplayNameLocale(LocalizedDisplayName n)
			{
				return n.DisplayName + " (" + n.Locale + ")";
			}

			override protected void Execute()
			{
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				TitlePrivilegeInfo[] titleList = util.GetPartnerSpecificTitleInfo();

				Console.WriteLine("Retrieved titles");
				foreach (TitlePrivilegeInfo title in titleList)
				{
					// If the title ID has the proper information, then continue
					// Some titles may have no information due to test cases
					// or incomplete inserts
					if(title.LocalizedName != null)
					{
						Console.Write(DisplayNameLocale(title.LocalizedName[0]));
						if (title.LocalizedName.Length > 1)
						{
							Console.Write(" aka ");
							Console.Write(DisplayNameLocale(title.LocalizedName[1]));
						}
						for (int i = 2; i < title.LocalizedName.Length; i++)
							Console.Write(", " + DisplayNameLocale(title.LocalizedName[i]));
						Console.WriteLine();
	
						Console.WriteLine("  TitleID: " + Hexer.tohex(title.TitleID));
						Console.WriteLine("  Rating: " + title.Rating.ToString());
						Console.WriteLine("  Default Locale: " + title.DefaultLocale);
						Console.WriteLine("  Privileges: " + title.Privileges.ToString());
					}
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\WCUtilTest.cs ===
using System;
using ServerTestFramework;

namespace WCUtilTest
{
	public class WCUtilTest : TestSuite
	{
		public override void Initialize(System.Xml.XmlDocument config)
		{
			ServerTestFramework.WebWidget.Initializer.Initialize();
		}

		override public TestBaseGroupList GetTests()
		{
			TestBaseGroupList tests = new TestBaseGroupList();

			tests.Add(new FuncGeneralInfo());
			tests.Add(new FuncUtilMethods());
			tests.Add(new FuncCacheMethods());
			tests.Add(new FuncLookup());

			return tests;
		}

		override public StressTestBaseList GetStressTests()
		{
			StressTestBaseList tests = new StressTestBaseList();
			tests.Add(typeof(CacheStressBatchLookupx100),100);
			tests.Add(typeof(CacheStressSmall),10);
			tests.Add(typeof(CacheStressMedium),10);
			tests.Add(typeof(CacheStressLarge),10);
			tests.Add(typeof(CacheStressTeamPUIDLookup),10);
			tests.Add(typeof(CacheStressTeamNameLookup),10);
			tests.Add(typeof(CacheStressPUIDLookup),10);
			tests.Add(typeof(CacheStressWebIDLookup),10);
			tests.Add(typeof(CacheStressGamerTagLookup),10);
			tests.Add(typeof(CacheStressPUIDLookupMiss),10);
			tests.Add(typeof(CacheStressWebIDLookupMiss),10);
			tests.Add(typeof(CacheStressGamerTagLookupMiss),10);
			tests.Add(typeof(CacheStressTeamPUIDLookupx100),1);
			tests.Add(typeof(CacheStressTeamNameLookupx100),1);
			tests.Add(typeof(CacheStressWebIDLookupx100),1);
			
			return tests;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\WCUtilTestLookup.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using WCUtilTest.WebWidget;
using ServerTestFramework.Utilities;

namespace WCUtilTest
{
	public class FuncLookup : TestNode
	{
		[TestCase, Description("Mainline Team Lookup")]
		/// FuncLookupTeamPUID_Basic
		/// TitleID: 0xB2D2
		/// TeamName: MyTeam
		class FuncLookupTeamPUID_Basic : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				ulong ulTeamPuid = 0;
				uint uiTitleID = 0xB2D2;
				string sTeamName = "webteam0";

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				ulTeamPuid = util.LookupTeamPUID(uiTitleID, sTeamName);

				if(ulTeamPuid != 0xFEFE0000B2D2FFFF)
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("FuncLookupTeamPUID_Zero")]
		/// FuncLookupTeamPUID_Zero
		/// TitleID: 0
		/// TeamName: MyTeam
		class FuncLookupTeamPUID_Zero : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				ulong ulTeamPuid = 0;
				uint uiTitleID = 0;
				string sTeamName = "MyTeam";

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				try
				{
					ulTeamPuid = util.LookupTeamPUID(uiTitleID, sTeamName);
				}
				catch
				{
					ResultCode = TEST_RESULTS.FAILED;
				}

				if(ulTeamPuid != 0)
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("FuncLookupTeamPUID_NA")]
		/// FuncLookupTeamPUID_NA
		/// TitleID: 0xB2D2
		/// TeamName: Valid Doesn't Exist
		class FuncLookupTeamPUID_NA : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				ulong ulTeamPuid = 0;
				uint uiTitleID = 0xB2D2;
				string sTeamName = "NotHere";

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				try
				{
					ulTeamPuid = util.LookupTeamPUID(uiTitleID, sTeamName);
				}
				catch
				{
					ResultCode = TEST_RESULTS.FAILED;
				}

				if(ulTeamPuid != 0)
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("FuncLookupTeamPUID_Empty")]
		/// FuncLookupTeamPUID_Empty
		/// TitleID: 0xB2D2
		/// TeamName: Invalid ""
		class FuncLookupTeamPUID_Empty : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				ulong ulTeamPuid = 0;
				uint uiTitleID = 0xB2D2;
				string sTeamName = "";

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				try
				{
					ulTeamPuid = util.LookupTeamPUID(uiTitleID, sTeamName);
				}
				catch
				{
					ResultCode = TEST_RESULTS.FAILED;
				}

				if(ulTeamPuid != 0)
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("FuncLookupTeamPUID_TooLong")]
		/// FuncLookupTeamPUID_TooLong
		/// TitleID: 0xB2D2
		/// TeamName: Invalid (Too Long)
		class FuncLookupTeamPUID_TooLong : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				ulong ulTeamPuid = 0;
				uint uiTitleID = 0xB2D2;
				string sTeamName = "1234567890123456";

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				try
				{
					ulTeamPuid = util.LookupTeamPUID(uiTitleID, sTeamName);
				}
				catch(Exception e)
				{
					if(e.ToString().IndexOf(("team name passed "+sTeamName+" ( index = 0) is too long")) == -1)
						ResultCode = TEST_RESULTS.FAILED;
				}

				// TODO: Should this throw an exception?
				if(ulTeamPuid != 0)
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("Mainline Multiple Team Lookup")]
		/// FuncLookupTeamPUIDs_Basic
		/// TitleID: 0xB2D2
		/// TeamName: web_TeamX where X [0..49]
		class FuncLookupTeamPUIDs_Basic : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				const uint numNames = 50;
				ulong[] ulTeamPuids = new ulong[numNames];
				uint uiTitleID = 0xB2D2;
				string[] sTeamNames = new string[numNames];

				uint n = 0;
				while(n < numNames)
				{
					sTeamNames[n] = "webteam"+n;
					n++;
				}

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				ulTeamPuids = util.LookupTeamPUIDs(uiTitleID, sTeamNames);

				n = 0;
				foreach(ulong puid in ulTeamPuids)
				{
					if(puid != 0xFEFE0000B2D2FFFF - n)
						ResultCode = TEST_RESULTS.FAILED;
					n++;
				}
			}
		}


		[TestCase, Description("Multiple Team Lookup, empty team names")]
		/// FuncLookupTeamPUIDs_Empty
		/// TitleID: 0xB2D2
		/// TeamName: web_TeamX where X [0..49]
		class FuncLookupTeamPUIDs_Empty : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				const uint numNames = 50;
				ulong[] ulTeamPuids = new ulong[numNames];
				uint uiTitleID = 0xB2D2;
				string[] sTeamNames = new string[numNames];

				uint n = 0;
				while(n < numNames)
				{
					sTeamNames[n] = "";
					n++;
				}

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				ulTeamPuids = util.LookupTeamPUIDs(uiTitleID, sTeamNames);

				n = 0;
				foreach(ulong puid in ulTeamPuids)
				{
					if(puid != 0)
						ResultCode = TEST_RESULTS.FAILED;
					n++;
				}
			}
		}


		[TestCase, Description("Multiple Team Lookup, null params")]
		/// FuncLookupTeamPUIDs_NULL
		/// TitleID: 0xB2D2
		/// TeamName: web_TeamX where X [0..49]
		class FuncLookupTeamPUIDs_Null : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				const uint numNames = 50;
				ulong[] ulTeamPuids = new ulong[numNames];
				uint uiTitleID = 0xB2D2;
				string[] sTeamNames = new string[numNames];

				uint n = 0;
				while(n < numNames)
				{
					sTeamNames[n] = "SomeValidName";
					n++;
				}

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				// Null TeamNames parameter
				try
				{
					ulTeamPuids = util.LookupTeamPUIDs(uiTitleID, null);
				}
				catch(Exception e)
				{
					if(e.ToString().IndexOf(("teamNames == null or teamNames.Length == 0")) == -1)
						ResultCode = TEST_RESULTS.FAILED;
				}

				// 0 TitleID
				try
				{
					ulTeamPuids = util.LookupTeamPUIDs(0, sTeamNames);
				}
				catch
				{
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}


		[TestCase, Description("Look up Puids for team names that are too long")]
		/// FuncLookupTeamPUIDs_TooLong
		/// TitleID: 0xB2D2
		/// TeamName: web_xxxxxxx_teamX where X [0..49]
		class FuncLookupTeamPUIDs_TooLong : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				const uint numNames = 50;
				ulong[] ulTeamPuids = new ulong[numNames];
				uint uiTitleID = 0xB2D2;
				string[] sTeamNames = new string[numNames];

				// 16 character team name, 17 with terminator
				uint n = 0;
				while(n < numNames)
				{
					sTeamNames[n] = "web_xxxxxxx_team"+n;
					n++;
				}

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				try
				{
					ulTeamPuids = util.LookupTeamPUIDs(uiTitleID, sTeamNames);
				}
				catch(Exception e)
				{
					if(e.ToString().IndexOf(("is too long")) == -1)
						ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}


		[TestCase, Description("FuncLookupTeamName_Basic")]
		/// FuncLookupTeamName_Basic
		/// TitleID: 0xB2D2
		/// TeamPUID: Exists
		class FuncLookupTeamName_Basic : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				ulong ulTeamPuid = 0xFEFE0000B2D2FF80;
				uint uiTitleID = 0xB2D2;
				string sTeamName = "";

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				sTeamName = util.LookupTeamName(uiTitleID, ulTeamPuid);

				if(!sTeamName.Equals("webteam127"))
					ResultCode = TEST_RESULTS.FAILED;
			}
		}


		[TestCase, Description("FuncLookupTeamName_MaxMin")]
		/// FuncLookupTeamName_MaxMin
		/// TitleID: 0xB2D2
		/// TeamPUID: 0 (Doesn't Exist), and Max Ulong (0xFFFFFFFF) - Doesn't Exist
		class FuncLookupTeamName_MaxMin : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				ulong[] ulTeamPuids = new ulong[2] {0, ulong.MaxValue};
				uint uiTitleID = 0xB2D2;
				string sTeamName = "";

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				// TODO: When a puid is not found, do we throw an exception or return an empty string?
				foreach(ulong puid in ulTeamPuids)
				{
					sTeamName = util.LookupTeamName(uiTitleID, puid);
					if(!sTeamName.Equals(""))
						ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}


		[TestCase, Description("FuncLookupTeamName_BadTitle")]
		/// FuncLookupTeamName_BadTitle
		/// TitleID: 0, Max
		/// TeamPUID: Exists
		class FuncLookupTeamName_BadTitle : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				ulong ulTeamPuid = 0xFEFE0000B2D2FFA0;
				uint[] uiTitleIDs = new uint[3] {0, uint.MaxValue, 666};
				string sTeamName = "";

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				// TODO: When a puid is not found, do we throw an exception or return an empty string?
				foreach(uint title in uiTitleIDs)
				{
					sTeamName = util.LookupTeamName(title, ulTeamPuid);
					if(!sTeamName.Equals(""))
						ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}


		[TestCase, Description("FuncLookupTeamNames_Basic")]
		/// FuncLookupTeamNames_Basic
		/// TitleID: 0xB2D2
		/// TeamPUID: Exists
		class FuncLookupTeamNames_Basic : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				const uint numNames = 50;
				ulong[] ulTeamPuids = new ulong[numNames];
				uint uiTitleID = 0xB2D2;
				string[] sTeamNames = new string[numNames];

				uint n = 0;
				while(n < numNames)
				{
					ulTeamPuids[n] = 0xFEFE0000B2D2FF80+n;
					n++;
				}

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				sTeamNames = util.LookupTeamNames(uiTitleID, ulTeamPuids);

				// The list should go from webteam127 to webteam78
				n = 127;
				foreach(string s in sTeamNames)
				{
					if(!s.Equals("webteam"+n))
						ResultCode = TEST_RESULTS.FAILED;
					n--;
				}
			}
		}


		[TestCase, Description("FuncLookupTeamNames_MaxMin")]
		/// FuncLookupTeamNames_MaxMin
		/// TitleID: 0xB2D2
		/// TeamPUID: Exists, 0, Max
		class FuncLookupTeamNames_MaxMin : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				const uint numNames = 2;
				ulong[] ulTeamPuids = new ulong[numNames];
				uint uiTitleID = 0xB2D2;
				string[] sTeamNames = new string[numNames];

				// Set the last two
				ulTeamPuids[0] = 0;
				ulTeamPuids[1] = 0xFFFFFFFFFFFFFFFF;

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				sTeamNames = util.LookupTeamNames(uiTitleID, ulTeamPuids);

				// Both should be empty
				foreach(string s in sTeamNames)
				{
					if(!s.Equals(""))
						ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}


		[TestCase, Description("FuncLookupTeamNames_BadTitle")]
		/// FuncLookupTeamNames_BadTitle
		/// TitleID: 666
		/// TeamPUID: Exists
		class FuncLookupTeamNames_BadTitle : TestBase
		{
			override protected void Execute()
			{
				ResultCode = TEST_RESULTS.PASSED;
				const uint numNames = 50;
				ulong[] ulTeamPuids = new ulong[numNames];
				uint uiTitleID = 666;
				string[] sTeamNames = new string[numNames];

				// Set up a list of valid PUIDs
				uint n = 0;
				while(n < numNames)
				{
					ulTeamPuids[n] = 0xFEFE0000B2D2FF80+n;
					n++;
				}

				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));
 
				sTeamNames = util.LookupTeamNames(uiTitleID, ulTeamPuids);

				// The list should be all empty since the TitleID doesn't exist
				foreach(string s in sTeamNames)
				{
					if(!s.Equals(""))
						ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}


		[TestCase, Description("Look up gamer tags in batch")]
		class LookupBatchIDs : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				ulong[] puidArray = new ulong[400];
				ulong[] puidArrayConfirm = new ulong[400];
				ulong[] puidArrayMin = new ulong[1];
				string[] gtArray = new string[400];
				string[] gtArrayConfirm = new string[400];
				string[] gtArrayMin = new string[1];

				// Set up min array
				gtArrayMin[0] = "webuser1";

				// Set up gamer tag array
				for(uint i = 1; i <= gtArray.Length; i++)
				{
					gtArray[i-1] = "webuser"+i;
				}

				WCUtil util = new WCUtil(new RequestInfo("t2client2"));

				// +++++ POSITIVE CASES +++++
				// Single gamer tag and puid
				puidArrayMin = util.LookupPUIDBatch(gtArrayMin);
				gtArrayMin = util.LookupGamerTagBatch(puidArrayMin);

				puidArray = util.LookupPUIDBatch(gtArray);
				gtArrayConfirm = util.LookupGamerTagBatch(puidArray);
				// Check gtArrayConfirm against gtArray
				for(uint i = 0; i < gtArrayConfirm.Length; i++)
				{
					if(!gtArrayConfirm[i].Equals(gtArray[i]))
						ResultCode=TEST_RESULTS.FAILED;
				}

				puidArrayConfirm = util.LookupPUIDBatch(gtArrayConfirm);
				// Check puidArrayConfirm against puidArray
				for(uint i = 0; i < puidArrayConfirm.Length; i++)
				{
					if(puidArrayConfirm[i] != puidArray[i])
						ResultCode=TEST_RESULTS.FAILED;
				}				
			}
		}


		[TestCase, Description("Look up gamer tags in batch")]
		class LookupBatchIDs_Negative : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				ulong[] puidArray = new ulong[100];
				ulong[] puidArrayNull = null;
				ulong[] puidArrayConfirm = new ulong[100];
				ulong[] puidArrayTooBig = new ulong[401];
				string[] gtArray = new string[100];
				string[] gtArrayNull = null;
				string[] gtArrayTooBig = new string[401];

				// Set up over sized Array
				for(uint i = 1; i <= gtArrayTooBig.Length; i++)
				{
					gtArrayTooBig[i-1] = "webuser"+i;
				}

				// Set up normal sized Array
				for(uint i = 1; i <= gtArray.Length; i++)
				{
					gtArray[i-1] = "webuser"+i;
				}

				WCUtil util = new WCUtil(new RequestInfo("t2client2"));

				// ----- NEGATIVE CASES -----
				// Large GamerTag Array
				try
				{
					puidArrayTooBig = util.LookupPUIDBatch(gtArrayTooBig);
				}
				catch(Exception e)
				{
					if(e.ToString().IndexOf(("Number of input parameters "+gtArrayTooBig.Length+" exceeds maximum allowed (400)")) == -1)
						ResultCode=TEST_RESULTS.FAILED;
				}

				// Large PUID Array
				puidArrayTooBig = new ulong[401];
				for(uint j = 0; j < puidArrayTooBig.Length; j++)
				{
					puidArrayTooBig[j] = 1445;
				}
				try
				{
					gtArrayTooBig = util.LookupGamerTagBatch(puidArrayTooBig);
				}
				catch(Exception e)
				{
					if(e.ToString().IndexOf(("Number of input parameters "+puidArrayTooBig.Length+" exceeds maximum allowed (400)")) == -1)
						ResultCode=TEST_RESULTS.FAILED;
				}
				
				// null PUID Array
				try
				{
					puidArray = util.LookupPUIDBatch(gtArrayNull);
					ResultCode=TEST_RESULTS.FAILED;
				}
				catch{}

				// null GamerTag Array
				try
				{
					gtArray = util.LookupGamerTagBatch(puidArrayNull);
					ResultCode=TEST_RESULTS.FAILED;
				}
				catch{}

				// Some gamer Tags don't exist
				gtArray[50] = "BadUser44";
				try
				{
					puidArray = util.LookupPUIDBatch(gtArray);
					if(puidArray[50] != 0)
						ResultCode=TEST_RESULTS.FAILED;
				}
				catch
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				// All gamer tags don't exist
				for(uint j = 0; j < gtArray.Length; j++)
				{
					gtArray[j] = "BadUser"+j;
				}
				try
				{
					puidArray = util.LookupPUIDBatch(gtArray);
					for(uint j = 0; j < puidArray.Length; j++)
					{
						if(puidArray[j] != 0)
							ResultCode=TEST_RESULTS.FAILED;
					}
				}
				catch(Exception e)
				{
					ConsoleX.WriteLine(e.ToString());
					ResultCode=TEST_RESULTS.FAILED;
				}

				// Some puids don't exist
				for(uint j = 0; j < gtArray.Length; j++)
				{
					gtArray[j] = "Web_User"+j;
				}
				// Get a good set of puids
				puidArray = util.LookupPUIDBatch(gtArray);
				// Corrupt one of them
				puidArray[43] = 555;
				try
				{
					gtArray = util.LookupGamerTagBatch(puidArray);
					if(!gtArray[43].Equals("??????"))
						ResultCode=TEST_RESULTS.FAILED;
				}
				catch{}

				// All puids don't exit
				for(uint k = 0; k < puidArray.Length; k++)
				{
					puidArray[k] = k;
				}
				try
				{
					gtArray = util.LookupGamerTagBatch(puidArray);
					for(uint j = 0; j < gtArray.Length; j++)
					{
						if(!gtArray[j].Equals("??????"))
							ResultCode=TEST_RESULTS.FAILED;
					}
				}
				catch{}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\WCUtilTestPermission.cs ===
using System;
using System.IO;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
//using ServerTestFramework.Web.UtilWrapper;
using WCUtilTest.WCutilWrapper;
using WCUtilTest.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

namespace WCUtilTest
{
	public class FuncUtilMethods : TestNode
	{
		public static UInt32 m_uiExpire = 600;
		public static TitlePrivilege[] m_tp;
		public static uint[] m_uTitleIDs;
		public static string[] m_BadAPIStrings;
		public static string[] m_validAPIStringsWCTest1;
		public static string[] m_validAPIStringsWCTest2;
		public static string[] m_validAPIStringsWCTest3;

		public FuncUtilMethods()
		{
			m_tp = new TitlePrivilege[] { TitlePrivilege.None,
											TitlePrivilege.ReadOnly,
											TitlePrivilege.ReadWrite,
											TitlePrivilege.FullControl };
			m_uTitleIDs = new uint[] {0xc0fe0000, 0xc0fe1000, 0xc0fe3000, 0xc0fe7000};
			m_BadAPIStrings = new string[]{   "",
											  "SomeUninteligibleString",
											  "GeneralInfo.GetTitleList1",
											  " GeneralInfo.GetTitleList",
											  "GeneralInfo.GetTitleList ",
											  "GeneralInfo.GetTitleLis",
											  "eneralInfo.GetTitleList",
											  "GeneralInfoGetTitleList" };
			m_validAPIStringsWCTest1 = new string[]{	"GeneralInfo.GetTitleList",
														"UserAccount.LinkUser",
														"UserAccount.LinkedGamerTags",
														"UserAccount.GetUserSettings",
														"Presence.GetFriends",
														"Stats.GetLBList",
														"Stats.EnumerateLB",
														"Stats.GetLBNearGamerTag",
														"Stats.GetLBForGamerTags",
														"Stats.GetLBDetailsForGamerTags",
														"Stats.EnumerateLBRaw"};
			m_validAPIStringsWCTest2 = new string[]{	"GeneralInfo.GetTitleList",
														"UserAccount.LinkUser",
														"UserAccount.LinkedGamerTags",
														"UserAccount.GetUserSettings",
														"Presence.GetFriends",
														"Stats.GetLBList",
														"Stats.EnumerateLB",
														"Stats.GetLBNearGamerTag",
														"Stats.GetLBForGamerTags",
														"Stats.GetLBDetailsForGamerTags" };
			m_validAPIStringsWCTest3 = new string[]{ "Stats.EnumerateLBRaw" };
		}

/*  Per johnblac - testing does not use wua.LinkUser anymore

		[TestCase, Description("Look up WebIDs and Gamer Tags")]
		class LookupIDs : UserTestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				PUIDAndOwner PO;
				PUIDAndOwner[] rgPO = new PUIDAndOwner[4];
				byte[] rgbWebID = new byte[8];
				byte[] rgbWebID2Gamers = new byte[8];
				byte[] rgbEmptyWebID = new byte[8];
				byte[] rgbLargeWebID = new byte[9];
				byte[] rgbSmallWebID = new byte[7];
				
				RandGen.NextBytes(rgbWebID);		// This is a Passport/random Web ID
				RandGen.NextBytes(rgbWebID2Gamers);	// This is a Passport/random Web ID
				RandGen.NextBytes(rgbEmptyWebID);	// Empty WebID unless there is a collision

//				WCUtil util = new WCUtil(new RequestInfo("t2client2"));
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

				// Create an owner and link a user
				Owner o = UACS.GenerateOwner();
				System.UInt64 puid = UACS.CreateUser(o);
				WCUserAccount wua = new WCUserAccount(Global.Env.UserWebCacheServer);
				bool f = wua.LinkUser(rgbWebID, o.gamertag, true, o.phonePrefix, o.phoneNumber, o.phoneExtension, o.postalCode, o.cardHolder, o.cardNumber);
				Check(f);
				// User Linked

				// Create 2 users and link them to the same web ID
				Owner o2 = UACS.GenerateOwner();
				Owner o3 = UACS.GenerateOwner();
				System.UInt64 puid2 = UACS.CreateUser(o2);
				System.UInt64 puid3 = UACS.CreateUser(o3);
				Check(wua.LinkUser(rgbWebID2Gamers, o2.gamertag, true, o2.phonePrefix, o2.phoneNumber, o2.phoneExtension, o2.postalCode, o2.cardHolder, o2.cardNumber));
				Check(wua.LinkUser(rgbWebID2Gamers, o3.gamertag, true, o3.phonePrefix, o3.phoneNumber, o3.phoneExtension, o3.postalCode, o3.cardHolder, o3.cardNumber));
				System.Threading.Thread.Sleep(31000);	// Wait 30 seconds for the link to take place
				// Two users linked

				// +++++ POSITIVE CASES +++++
				PO = util.LookupWebID(rgbWebID, o.gamertag);	// Valid WebID/GamerTag
				if( (PO._PUID & 0x7fffffffffffffff )!= puid ) { ResultCode=TEST_RESULTS.FAILED; }
				rgPO = util.LookupWebIDArray(rgbWebID);	// WebID with 1 gamer tag
				if ( ( rgPO[0]._PUID & 0x7fffffffffffffff ) != puid ) { ResultCode=TEST_RESULTS.FAILED; }
				rgPO = util.LookupWebIDArray(rgbWebID2Gamers);	// WebID with n gamer tags
				if (rgPO.Length != 2) { ResultCode=TEST_RESULTS.FAILED; }
				// The PUIDs may not come back in the same order they were linked
				else if ( !( ((rgPO[0]._PUID & 0x7fffffffffffffff ) == puid2) || (( rgPO[1]._PUID & 0x7fffffffffffffff ) == puid2)) &&
					  ( ((rgPO[0]._PUID & 0x7fffffffffffffff ) == puid3) || (( rgPO[1]._PUID & 0x7fffffffffffffff ) == puid3)) )
				{ ResultCode=TEST_RESULTS.FAILED; }

				// ----- NEGATIVE CASES -----
				rgPO = util.LookupWebIDArray(rgbEmptyWebID);	// WebID with 0 gamer tags
				if(rgPO.Length != 0) { ResultCode=TEST_RESULTS.FAILED; }

				try
				{
					PO = util.LookupWebID(rgbWebID, "");	// Empty GamerTag
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(rgbWebID, null);		// Invalid GamerTag
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(rgbWebID, "1234567890123456");	// GamerTag too long
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(null, "Neo");		// Empty WebID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					rgPO = util.LookupWebIDArray(null);	// Invalid webID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					rgPO = util.LookupWebIDArray(rgbLargeWebID);	// Invalid webID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					rgPO = util.LookupWebIDArray(rgbSmallWebID);	// Invalid webID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}
			}
		}
*/

/*  Per johnblac - testing does not use wua.LinkUser anymore

		[TestCase, Description("Look up WebIDs and Gamer Tags with a Non Owner account")]
		class LookupIDsNonOwner : UserTestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				PUIDAndOwner PO;
				PUIDAndOwner[] rgPO = new PUIDAndOwner[4];
				byte[] rgbWebID = new byte[8];
				byte[] rgbWebID2Gamers = new byte[8];
				byte[] rgbEmptyWebID = new byte[8];
				byte[] rgbLargeWebID = new byte[9];
				byte[] rgbSmallWebID = new byte[7];
				
				RandGen.NextBytes(rgbWebID);		// This is a Passport/random Web ID
				RandGen.NextBytes(rgbWebID2Gamers);	// This is a Passport/random Web ID
				RandGen.NextBytes(rgbEmptyWebID);	// Empty WebID unless there is a collision

				WCUtil util = new WCUtil(new RequestInfo("t2client2"));

				// Create an owner and link a user
				Owner o = UACS.GenerateOwner();
				System.UInt64 puid = UACS.CreateUser(o);
				WCUserAccount wua = new WCUserAccount(Global.Env.UserWebCacheServer);
				bool f = wua.LinkUser(rgbWebID, o.gamertag, false, o.phonePrefix, o.phoneNumber, o.phoneExtension, o.postalCode, o.cardHolder, o.cardNumber);
				Check(f);
				// User Linked

				// Create 2 users and link them to the same web ID
				Owner o2 = UACS.GenerateOwner();
				Owner o3 = UACS.GenerateOwner();
				System.UInt64 puid2 = UACS.CreateUser(o2);
				System.UInt64 puid3 = UACS.CreateUser(o3);
				Check(wua.LinkUser(rgbWebID2Gamers, o2.gamertag, false, o2.phonePrefix, o2.phoneNumber, o2.phoneExtension, o2.postalCode, o2.cardHolder, o2.cardNumber));
				Check(wua.LinkUser(rgbWebID2Gamers, o3.gamertag, false, o3.phonePrefix, o3.phoneNumber, o3.phoneExtension, o3.postalCode, o3.cardHolder, o3.cardNumber));
				System.Threading.Thread.Sleep(31000);	// Wait 31 seconds for the link to take place
				// Two users linked

				// +++++ POSITIVE CASES +++++
				PO = util.LookupWebID(rgbWebID, o.gamertag);	// Valid WebID/GamerTag
				if( (PO._PUID & 0x7fffffffffffffff )!= puid ) { ResultCode=TEST_RESULTS.FAILED; }
				rgPO = util.LookupWebIDArray(rgbWebID);	// WebID with 1 gamer tag
				if ( ( rgPO[0]._PUID & 0x7fffffffffffffff ) != puid ) { ResultCode=TEST_RESULTS.FAILED; }
				rgPO = util.LookupWebIDArray(rgbWebID2Gamers);	// WebID with n gamer tags
				if (rgPO.Length != 2) { ResultCode=TEST_RESULTS.FAILED; }
					// The PUIDs may not come back in the same order they were linked
				else if ( !( ((rgPO[0]._PUID & 0x7fffffffffffffff ) == puid2) || (( rgPO[1]._PUID & 0x7fffffffffffffff ) == puid2)) &&
					( ((rgPO[0]._PUID & 0x7fffffffffffffff ) == puid3) || (( rgPO[1]._PUID & 0x7fffffffffffffff ) == puid3)) )
				{ ResultCode=TEST_RESULTS.FAILED; }

				// ----- NEGATIVE CASES -----
				rgPO = util.LookupWebIDArray(rgbEmptyWebID);	// WebID with 0 gamer tags
				if(rgPO.Length != 0) { ResultCode=TEST_RESULTS.FAILED; }

				try
				{
					PO = util.LookupWebID(rgbWebID, "");	// Empty GamerTag
					ResultCode=TEST_RESULTS.FAILED;
				}
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(rgbWebID, null);		// Invalid GamerTag
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(rgbWebID, "1234567890123456");	// GamerTag too long
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(null, "Neo");		// Empty WebID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					rgPO = util.LookupWebIDArray(null);	// Invalid webID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					rgPO = util.LookupWebIDArray(rgbLargeWebID);	// Invalid webID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					rgPO = util.LookupWebIDArray(rgbSmallWebID);	// Invalid webID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}
			}
		}
*/

/*  Per johnblac - testing does not use wua.LinkUser anymore

		[TestCase, Description("Look up WebIDs")]
		class LookupVariableIDs : UserTestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				PUIDAndOwner PO;
				PUIDAndOwner[] rgPO = new PUIDAndOwner[4];
				byte[] rgbWebID = new byte[127];
				byte[] rgbWebID2Gamers = new byte[127];
				byte[] rgbEmptyWebID = new byte[127];
				byte[] rgbLargeWebID = new byte[128];
				byte[] rgbSmallWebID = new byte[7];
				byte[] rgbIncorrectWebID = new byte[126];
				
				RandGen.NextBytes(rgbWebID);		// This is a Passport/random Web ID
				RandGen.NextBytes(rgbWebID2Gamers);	// This is a Passport/random Web ID
				RandGen.NextBytes(rgbEmptyWebID);	// Empty WebID unless there is a collision
				RandGen.NextBytes(rgbIncorrectWebID);	// This webID is shorter than specified but still valid

				// Use partner t2client3 because it uses a credential type that is not 1
				// and will therefor utilize the non standard webID lengths
				WCUtil util = new WCUtil(new RequestInfo("t2client4"));

				// Create an owner and link a user
				Owner o = UACS.GenerateOwner();
				System.UInt64 puid = UACS.CreateUser(o);
				WCUserAccount wua = new WCUserAccount(Global.Env.UserWebCacheServer, new RequestInfo("t2client4"));
				bool f = wua.LinkUser(rgbWebID, o.gamertag, true, o.phonePrefix, o.phoneNumber, o.phoneExtension, o.postalCode, o.cardHolder, o.cardNumber);
				Check(f);
				// User Linked

				// Create 2 users and link them to the same web ID
				Owner o2 = UACS.GenerateOwner();
				Owner o3 = UACS.GenerateOwner();
				System.UInt64 puid2 = UACS.CreateUser(o2);
				System.UInt64 puid3 = UACS.CreateUser(o3);
				Check(wua.LinkUser(rgbWebID2Gamers, o2.gamertag, true, o2.phonePrefix, o2.phoneNumber, o2.phoneExtension, o2.postalCode, o2.cardHolder, o2.cardNumber));
				Check(wua.LinkUser(rgbWebID2Gamers, o3.gamertag, true, o3.phonePrefix, o3.phoneNumber, o3.phoneExtension, o3.postalCode, o3.cardHolder, o3.cardNumber));
				System.Threading.Thread.Sleep(31000);	// Wait 30 seconds for the link to take place
				// Two users linked

				// +++++ POSITIVE CASES +++++
				PO = util.LookupWebID(rgbWebID, o.gamertag);	// Valid WebID/GamerTag
				if( (PO._PUID & 0x7fffffffffffffff )!= puid ) { ResultCode=TEST_RESULTS.FAILED; }
				rgPO = util.LookupWebIDArray(rgbWebID);	// WebID with 1 gamer tag
				if ( ( rgPO[0]._PUID & 0x7fffffffffffffff ) != puid ) { ResultCode=TEST_RESULTS.FAILED; }
				rgPO = util.LookupWebIDArray(rgbWebID2Gamers);	// WebID with n gamer tags
				if (rgPO.Length != 2) { ResultCode=TEST_RESULTS.FAILED; }
					// The PUIDs may not come back in the same order they were linked
				else if ( !( ((rgPO[0]._PUID & 0x7fffffffffffffff ) == puid2) || (( rgPO[1]._PUID & 0x7fffffffffffffff ) == puid2)) &&
					( ((rgPO[0]._PUID & 0x7fffffffffffffff ) == puid3) || (( rgPO[1]._PUID & 0x7fffffffffffffff ) == puid3)) )
				{ ResultCode=TEST_RESULTS.FAILED; }

				// ----- NEGATIVE CASES -----
				rgPO = util.LookupWebIDArray(rgbEmptyWebID);	// WebID with 0 gamer tags
				if(rgPO.Length != 0) { ResultCode=TEST_RESULTS.FAILED; }

				try
				{
					PO = util.LookupWebID(rgbWebID, "");	// Empty GamerTag
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(rgbWebID, null);		// Invalid GamerTag
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(rgbWebID, "1234567890123456");	// GamerTag too long
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(null, "Neo");		// Empty WebID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					rgPO = util.LookupWebIDArray(null);	// Invalid webID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					// For non passport types, we want an empty PO struct
					rgPO = util.LookupWebIDArray(rgbLargeWebID);	// Invalid webID
					if(rgPO.Length !=0)
						ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception)
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				try
				{
					// For non passport types, we want an empty PO struct
					rgPO = util.LookupWebIDArray(rgbSmallWebID);	// Invalid webID
					if(rgPO.Length !=0)
						ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception)
				{
					ResultCode=TEST_RESULTS.FAILED;
				}
			}
		}
*/

/*  Per johnblac - testing does not use wua.LinkUser anymore

		[TestCase, Description("Look up WebIDs for Non Owners")]
		class LookupVariableIDsNonOwner : UserTestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				PUIDAndOwner PO;
				PUIDAndOwner[] rgPO = new PUIDAndOwner[4];
				byte[] rgbWebID = new byte[127];
				byte[] rgbWebID2Gamers = new byte[127];
				byte[] rgbEmptyWebID = new byte[127];
				byte[] rgbLargeWebID = new byte[128];
				byte[] rgbSmallWebID = new byte[7];
				byte[] rgbIncorrectWebID = new byte[126];
				
				RandGen.NextBytes(rgbWebID);		// This is a Passport/random Web ID
				RandGen.NextBytes(rgbWebID2Gamers);	// This is a Passport/random Web ID
				RandGen.NextBytes(rgbEmptyWebID);	// Empty WebID unless there is a collision
				RandGen.NextBytes(rgbIncorrectWebID);	// This webID is shorter than specified but still valid

				// Use partner t2client3 because it uses a credential type that is not 1
				// and will therefor utilize the non standard webID lengths
				WCUtil util = new WCUtil(new RequestInfo("t2client4"));

				// Create an owner and link a user
				Owner o = UACS.GenerateOwner();
				System.UInt64 puid = UACS.CreateUser(o);
				WCUserAccount wua = new WCUserAccount(Global.Env.UserWebCacheServer, new RequestInfo("t2client4"));
				bool f = wua.LinkUser(rgbWebID, o.gamertag, false, o.phonePrefix, o.phoneNumber, o.phoneExtension, o.postalCode, o.cardHolder, o.cardNumber);
				Check(f);
				// User Linked

				// Create 2 users and link them to the same web ID
				Owner o2 = UACS.GenerateOwner();
				Owner o3 = UACS.GenerateOwner();
				System.UInt64 puid2 = UACS.CreateUser(o2);
				System.UInt64 puid3 = UACS.CreateUser(o3);
				Check(wua.LinkUser(rgbWebID2Gamers, o2.gamertag, false, o2.phonePrefix, o2.phoneNumber, o2.phoneExtension, o2.postalCode, o2.cardHolder, o2.cardNumber));
				Check(wua.LinkUser(rgbWebID2Gamers, o3.gamertag, false, o3.phonePrefix, o3.phoneNumber, o3.phoneExtension, o3.postalCode, o3.cardHolder, o3.cardNumber));
				System.Threading.Thread.Sleep(31000);	// Wait 30 seconds for the link to take place
				// Two users linked

				// +++++ POSITIVE CASES +++++
				PO = util.LookupWebID(rgbWebID, o.gamertag);	// Valid WebID/GamerTag
				if( (PO._PUID & 0x7fffffffffffffff )!= puid ) { ResultCode=TEST_RESULTS.FAILED; }
				rgPO = util.LookupWebIDArray(rgbWebID);	// WebID with 1 gamer tag
				if ( ( rgPO[0]._PUID & 0x7fffffffffffffff ) != puid ) { ResultCode=TEST_RESULTS.FAILED; }
				rgPO = util.LookupWebIDArray(rgbWebID2Gamers);	// WebID with n gamer tags
				if (rgPO.Length != 2) { ResultCode=TEST_RESULTS.FAILED; }
					// The PUIDs may not come back in the same order they were linked
				else if ( !( ((rgPO[0]._PUID & 0x7fffffffffffffff ) == puid2) || (( rgPO[1]._PUID & 0x7fffffffffffffff ) == puid2)) &&
					( ((rgPO[0]._PUID & 0x7fffffffffffffff ) == puid3) || (( rgPO[1]._PUID & 0x7fffffffffffffff ) == puid3)) )
				{ ResultCode=TEST_RESULTS.FAILED; }

				// ----- NEGATIVE CASES -----
				rgPO = util.LookupWebIDArray(rgbEmptyWebID);	// WebID with 0 gamer tags
				if(rgPO.Length != 0) { ResultCode=TEST_RESULTS.FAILED; }

				try
				{
					PO = util.LookupWebID(rgbWebID, "");	// Empty GamerTag
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(rgbWebID, null);		// Invalid GamerTag
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(rgbWebID, "1234567890123456");	// GamerTag too long
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				try
				{
					PO = util.LookupWebID(null, "Neo");		// Empty WebID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					rgPO = util.LookupWebIDArray(null);	// Invalid webID
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception){}

				try
				{
					// For non passport types, we want an empty PO struct
					rgPO = util.LookupWebIDArray(rgbLargeWebID);	// Invalid webID
					if(rgPO.Length !=0)
						ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception)
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				try
				{
					// For non passport types, we want an empty PO struct
					rgPO = util.LookupWebIDArray(rgbSmallWebID);	// Invalid webID
					if(rgPO.Length !=0)
						ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception)
				{
					ResultCode=TEST_RESULTS.FAILED;
				}
			}
		}
*/

		[TestCase, Description("Verify if a partner has permission to use certain APIs")]
		class CheckAPIPermissionPositive : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				WCUtil util1 = new WCUtil(new RequestInfo("WCTest1"));
				WCUtil util2 = new WCUtil(new RequestInfo("WCTest2", "10.10.1.24:0", "456"));
				WCUtil util3 = new WCUtil(new RequestInfo("WCTest3"));
				WCUtil util4 = new WCUtil(new RequestInfo("WCTest4"));

				// This should throw an exception
				try
				{
					util1.CheckAPI(null);		// Should throw an exception
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				// None of these should throw an exception
				try
				{
					foreach(string s in m_validAPIStringsWCTest1)
					{
						util1.CheckAPI(s);	// Valid name with permission
					}
					foreach(string s in m_validAPIStringsWCTest2)
					{
						util2.CheckAPI(s);	// Valid name with permission
					}
					foreach(string s in m_validAPIStringsWCTest3)
					{
						util3.CheckAPI(s);	// Valid name with permission
					}
				}
				catch (Exception) 
				{
					ResultCode=TEST_RESULTS.FAILED;
				}

				CheckPermissions(m_validAPIStringsWCTest1, util1);	// Haa permission to everything
				CheckPermissions(m_validAPIStringsWCTest2, util2, 0xc0fe1000);	// Doesn't have permission to EnumerateLBRaw
				CheckPermissions(m_validAPIStringsWCTest3, util3, 0xc0fe1000);	// Only has permission to EnumerateLBRaw

				// WCTest4 has permission 'none' under the 0xc0fe1000 TitleID which breaks our
				// previous titleID rules, so this should still work despite the rule change
				// in the database
				try
				{
					util4.CheckAPIAndTitle("GeneralInfo.GetTitleList", 0xc0fe1000, TitlePrivilege.None);
				} 
				catch (Exception) {ResultCode=TEST_RESULTS.FAILED;}
			}

			// This function does the logic on an API list and a util object
			// that decides whether or not each API in the list has the correct
			// permissions
			protected void CheckPermissions(string[] sAPIList, WCUtil utilObj)
			{
				// The CheckAPIAndTitle method is much more specific.
				foreach(string s in sAPIList)
				{
					for(uint i=0; i < m_uTitleIDs.Length; i++)
					{
						for(uint j=0; j < m_tp.Length; j++)
						{
							// 0xc0fe000 m_uiTitleIDs[0] = none
							// 0xc0fe100 m_uiTitleIDs[1] = read
							// 0xc0fe300 m_uiTitleIDs[2] = read/write
							// 0xc0fe700 m_uiTitleIDs[3] = full
							// NOTE: these arrays are set up such that the 1..n
							// TitleID has the same permissions as the 1..n 
							// element in the permissions array
							if(j <= i)
							{
								// We have permission, this should work
								try
								{
									utilObj.CheckAPIAndTitle(s, m_uTitleIDs[i], m_tp[j]);
								}
								catch (Exception)
								{
									ResultCode=TEST_RESULTS.FAILED;
								}
							}
							else
							{
								// We don't have permission so we should throw
								try
								{
									utilObj.CheckAPIAndTitle(s, m_uTitleIDs[i], m_tp[j]);
									ResultCode=TEST_RESULTS.FAILED;
								} 
								catch (Exception) {}
							}
						}
					}
				}
			}

			// This function does the logic on an API list and a util object
			// that decides whether or not each API in the list has the correct
			// permissions
			protected void CheckPermissions(string[] sAPIList, WCUtil utilObj, uint TitleID)
			{
				// The CheckAPIAndTitle method is much more specific.
				foreach(string s in sAPIList)
				{
					// 0xc0fe000 m_uiTitleIDs[0] = none
					// 0xc0fe100 m_uiTitleIDs[1] = read
					// 0xc0fe300 m_uiTitleIDs[2] = read/write
					// 0xc0fe700 m_uiTitleIDs[3] = full
					// NOTE: these arrays are set up such that the 1..n
					// TitleID has the same permissions as the 1..n 
					// element in the permissions array
					switch(TitleID)
					{
						case 0xc0fe0000:
							PermissionHelper(s, utilObj, TitleID, 3);
							break;
						case 0xc0fe1000:
							PermissionHelper(s, utilObj, TitleID, 2);
							break;
						case 0xc0fe3000:
							PermissionHelper(s, utilObj, TitleID, 1);
							break;
						case 0xc0fe7000:
							PermissionHelper(s, utilObj, TitleID, 0);
							break;
						default:
							ResultCode=TEST_RESULTS.FAILED;
							break;
					}
				}
			}

			// This interprets the TitleID and asks for permission for the API
			// where it knows it should have it and checks for failure 
			// where it knows it should *not* have it.
			protected void PermissionHelper(string sAPI, WCUtil utilObj, uint TitleID, uint uiOffSet)
			{
				for(uint j=0; j < m_tp.Length-uiOffSet; j++)
				{
					if(j < m_tp.Length-uiOffSet)
					{
						try
						{
							utilObj.CheckAPIAndTitle(sAPI, TitleID, m_tp[j]);
						}
						catch (Exception)
						{
							ResultCode=TEST_RESULTS.FAILED;
						}
					}
					else
					{
						// We don't have permission so we should throw
						try
						{
							utilObj.CheckAPIAndTitle(sAPI, TitleID, m_tp[j]);
							ResultCode=TEST_RESULTS.FAILED;
						} 
						catch (Exception) {}
					}
				}
			}
		}


		[TestCase, Description("Verify if a partner has permission to use certain APIs with negative test cases")]
		class CheckAPIPermissionNegative : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

				// This partner has no IP information in the DB, it should bail always
				WCUtil util5 = new WCUtil(new RequestInfo("WCTest5"));

				// These should all throw an exception
				// WCUtil *** 1 ***
				foreach(string s in m_BadAPIStrings)
				{
					try
					{
						util.CheckAPI(s);
						ResultCode=TEST_RESULTS.FAILED;
					} 
					catch (Exception) {}
				}

				// These should all throw an exception
				// WCUtil *** 5 ***
				foreach(string s in m_validAPIStringsWCTest1)
				{
					try
					{
						util5.CheckAPI(s);
						ResultCode=TEST_RESULTS.FAILED;
					} 
					catch (Exception) {}
				}

				// Test the bad API strings.  Each should throw
				foreach(TitlePrivilege tp in m_tp)
				{
					foreach(uint TitleID in m_uTitleIDs)
					{
						foreach(string s in m_BadAPIStrings)
						{
							try
							{
								util.CheckAPIAndTitle(s, TitleID, tp);
								throw new UnexpectedTestResultException();
							}
							catch (UnexpectedTestResultException) {throw;}
							catch (Exception) {}
						}
					}
				}

				// Check for TitleIDs with NO permissions
				// 0xc0fea000 has no permissions to any API
				foreach(string s in m_validAPIStringsWCTest1)
				{
					foreach(TitlePrivilege tp in m_tp)
					{
						try
						{
							util.CheckAPIAndTitle(s, 0xc0fea000, tp);
							throw new UnexpectedTestResultException();
						}
						catch (UnexpectedTestResultException) {throw;}
						catch (Exception) {}
					}
				}
			}
		}


		[TestCase, Description("Verify APIs without proper permissions are in fact denied")]
		class CheckAPIPermissionDenied : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				WCUtil util2 = new WCUtil(new RequestInfo("WCTest2"));
				WCUtil util3 = new WCUtil(new RequestInfo("WCTest3"));
				WCUtil util4 = new WCUtil(new RequestInfo("WCTest4"));

				// This API doesn't have permission for this certificate
				// and should therefor throw a permission denied exception
				try
				{
					util2.CheckAPI("Stats.EnumerateLBRaw");	// Valid name without permission
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception) {}

				// WCTest2 doesn't have permissions to EnumerateLBRaw
				// but it does to everything else (see Positive test cases)
				foreach(TitlePrivilege tp in m_tp)
				{
					foreach(uint TitleID in m_uTitleIDs)
					{
						try
						{
							util2.CheckAPIAndTitle("Stats.EnumerateLBRaw", TitleID, tp);
							ResultCode=TEST_RESULTS.FAILED;
						} 
						catch (Exception) {}
					}
				}

				// WCTest3 only has permissions to EnumerateLBRaw
				foreach(string s in m_validAPIStringsWCTest2)
				{
					foreach(TitlePrivilege tp in m_tp)
					{
						foreach(uint TitleID in m_uTitleIDs)
						{
							try
							{
								util3.CheckAPIAndTitle(s, TitleID, tp);
								ResultCode=TEST_RESULTS.FAILED;
							} 
							catch (Exception) {}
						}
					}
				}

				// WCTest4 has permissions but with a different ID
				// The last three permissions should fail (all but none)
				for(uint i = 1; i < m_tp.Length; i++)
				{
					try
					{
						util4.CheckAPIAndTitle("GeneralInfo.GetTitleList", 0xc0fe1000, m_tp[i]);
						ResultCode=TEST_RESULTS.FAILED;
					} catch (Exception) {}
				}
			}
		}


		[TestCase, Description("Look up a bunch of gamer tags/PUIDs, valid and non-valid.")]
		class GamerTagAndPUIDChecks : UserTestBase
		{
			override protected void Execute()
			{
				string szGamerTag;
				string szLongGamerTag = "1234567890123456";
				ulong PUID = 0;

				// Set up data structures for the tests
				ResultCode=TEST_RESULTS.PASSED;
				WCUtil util = new WCUtil(new RequestInfo("WCTest1"));

				// Create an owner
				Owner o = UACS.GenerateOwner();
				ulong puid = UACS.CreateUser(o);
				System.Threading.Thread.Sleep(31000);	// Wait 30 seconds for the link to take place
				// User created

				// ****** Lookup Gamer Tags **********
				try
				{
					// +++++ POSITIVE CASES +++++
					szGamerTag = util.LookupGamerTag(puid);	// Valid PUID
					if(o.gamertag != szGamerTag) { ResultCode=TEST_RESULTS.FAILED; }

					// ----- NEGATIVE CASES -----
					szGamerTag = util.LookupGamerTag(0);	// 0
					if(szGamerTag != "??????" && szGamerTag != "hehehe") { ResultCode=TEST_RESULTS.FAILED; }

					szGamerTag = util.LookupGamerTag(ulong.MaxValue);	// Max
					if(szGamerTag != "??????") { ResultCode=TEST_RESULTS.FAILED; }

					szGamerTag = util.LookupGamerTag(42);	// Doesn't exist
					if(szGamerTag != "??????") { ResultCode=TEST_RESULTS.FAILED; }


					// ****** Lookup PUIDS **********
					// +++++ POSITIVE CASES +++++
					PUID = util.LookupPUID("webuser42");	// Valid user
					if (PUID == 0) 
					{ 
						ConsoleX.WriteLine("**  WebTestUser42 not found.  Database may not be loaded."); 
						ResultCode=TEST_RESULTS.FAILED; 
					}

					PUID = util.LookupPUID(o.gamertag);	// Valid user
					if (PUID != puid) { ResultCode=TEST_RESULTS.FAILED; }

					// ----- NEGATIVE CASES -----
					PUID = util.LookupPUID("");		// Empty
					if(PUID != 0) { ResultCode=TEST_RESULTS.FAILED; }

					PUID = util.LookupPUID("123456789012345");	// User doesn't exist
					if(PUID != 0) { ResultCode=TEST_RESULTS.FAILED; }

					PUID = util.LookupPUID(null);	// Invalid
					if(PUID != 0) { ResultCode=TEST_RESULTS.FAILED; }

				}
				catch (Exception e)
				{
					ConsoleX.WriteLine(e.ToString());
					ResultCode=TEST_RESULTS.FAILED;
				}

				// This should throw an exception
				// Gamertag too long
				try
				{
					PUID = util.LookupPUID(szLongGamerTag);	// User is too long
					ResultCode=TEST_RESULTS.FAILED;
				} 
				catch (Exception e)
				{
					if(e.ToString().IndexOf(("GamerTag passed "+szLongGamerTag+" ( index = 0) is too long")) == -1)
						ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}


		[TestCase, Description("Certain partners shouldn't be allowed from some IPs")]
		class CheckPartnerIPs : TestBase
		{
			override protected void Execute()
			{
				ResultCode=TEST_RESULTS.PASSED;

				// Set up data structures for the tests
				WCUtil util = new WCUtil(new RequestInfo("WCTest2", "10.10.1.24:0", "72000"));
				// This API should work for everyone
				try
				{
					util.CheckAPI("GeneralInfo.GetTitleList");	// Valid name without permission
				} catch (Exception) { ResultCode=TEST_RESULTS.FAILED; }

				WCUtil util1 = new WCUtil(new RequestInfo("WCTest2", "10.12.1.1:0", "72001"));
				try
				{
					util1.CheckAPI("GeneralInfo.GetTitleList");	// Valid name without permission
				} 
				catch (Exception) { ResultCode=TEST_RESULTS.FAILED; }
				
				WCUtil util2 = new WCUtil(new RequestInfo("WCTest2", "10.12.255.255:0", "72002"));
				try
				{
					util2.CheckAPI("GeneralInfo.GetTitleList");	// Valid name without permission
				} 
				catch (Exception) { ResultCode=TEST_RESULTS.FAILED; }

				// ---- These should all fail since their IPs are out of range ----
				WCUtil util3 = new WCUtil(new RequestInfo("WCTest2", "10.10.1.25:0", "72003"));
				try
				{
					util3.CheckAPI("GeneralInfo.GetTitleList");	// Valid name without permission
					ResultCode=TEST_RESULTS.FAILED;
				} catch (Exception) { }
				
				WCUtil util4 = new WCUtil(new RequestInfo("WCTest2", "10.13.1.1:0", "72004"));
				try
				{
					util4.CheckAPI("GeneralInfo.GetTitleList");	// Valid name without permission
					ResultCode=TEST_RESULTS.FAILED;
				} catch (Exception) { }
				
				WCUtil util5 = new WCUtil(new RequestInfo("WCTest2", "0.0.0.0:0", "72005"));
				try
				{
					util5.CheckAPI("GeneralInfo.GetTitleList");	// Valid name without permission
					ResultCode=TEST_RESULTS.FAILED;
				} catch (Exception) { }
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCIntegration\STFHost.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.573.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="STFHostSoap", Namespace="http://tempuri.org/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(FriendsInfo))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(LBResults))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBResults))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(DetailedLBResults))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBEntry[]))]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(RawLBAttribute[]))]
public class STFHost : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    /// <remarks/>
    public STFHost() {
        this.Url = "http://bscriver-pc03/stfhost/stfhost.asmx";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetEnvironments", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public string[] GetEnvironments() {
        object[] results = this.Invoke("GetEnvironments", new object[0]);
        return ((string[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetEnvironments(System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetEnvironments", new object[0], callback, asyncState);
    }
    
    /// <remarks/>
    public string[] EndGetEnvironments(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((string[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/SetEnvironment", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public bool SetEnvironment(string e, System.UInt32 TimeLimit) {
        object[] results = this.Invoke("SetEnvironment", new object[] {
                    e,
                    TimeLimit});
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginSetEnvironment(string e, System.UInt32 TimeLimit, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("SetEnvironment", new object[] {
                    e,
                    TimeLimit}, callback, asyncState);
    }
    
    /// <remarks/>
    public bool EndSetEnvironment(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/EnumerateLB", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public StatsDetailedLB EnumerateLB(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries) {
        object[] results = this.Invoke("EnumerateLB", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        return ((StatsDetailedLB)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateLB(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateLB", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public StatsDetailedLB EndEnumerateLB(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((StatsDetailedLB)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/EnumerateLBRaw", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public StatsRawLB EnumerateLBRaw(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries) {
        object[] results = this.Invoke("EnumerateLBRaw", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries});
        return ((StatsRawLB)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginEnumerateLBRaw(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, System.UInt32 StartIndex, System.UInt32 MaxEntries, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("EnumerateLBRaw", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    StartIndex,
                    MaxEntries}, callback, asyncState);
    }
    
    /// <remarks/>
    public StatsRawLB EndEnumerateLBRaw(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((StatsRawLB)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetLBDetailsForGamerTags", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public StatsDetailedLB GetLBDetailsForGamerTags(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList) {
        object[] results = this.Invoke("GetLBDetailsForGamerTags", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    GamerTagList});
        return ((StatsDetailedLB)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBDetailsForGamerTags(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBDetailsForGamerTags", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
    }
    
    /// <remarks/>
    public StatsDetailedLB EndGetLBDetailsForGamerTags(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((StatsDetailedLB)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetLBForGamerTags", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public StatsFriendsLB GetLBForGamerTags(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList) {
        object[] results = this.Invoke("GetLBForGamerTags", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    GamerTagList});
        return ((StatsFriendsLB)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBForGamerTags(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, string[] GamerTagList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBForGamerTags", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    GamerTagList}, callback, asyncState);
    }
    
    /// <remarks/>
    public StatsFriendsLB EndGetLBForGamerTags(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((StatsFriendsLB)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetLBList", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public StatsLBList GetLBList(string e, System.UInt32 TimeLimit, System.UInt32 TitleID) {
        object[] results = this.Invoke("GetLBList", new object[] {
                    e,
                    TimeLimit,
                    TitleID});
        return ((StatsLBList)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBList(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBList", new object[] {
                    e,
                    TimeLimit,
                    TitleID}, callback, asyncState);
    }
    
    /// <remarks/>
    public StatsLBList EndGetLBList(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((StatsLBList)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetLBNearGamerTag", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public StatsDetailedLB GetLBNearGamerTag(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, string GamerTag, System.UInt32 NumAbove, System.UInt32 NumBelow) {
        object[] results = this.Invoke("GetLBNearGamerTag", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow});
        return ((StatsDetailedLB)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetLBNearGamerTag(string e, System.UInt32 TimeLimit, System.UInt32 TitleID, System.UInt32 LBID, string GamerTag, System.UInt32 NumAbove, System.UInt32 NumBelow, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetLBNearGamerTag", new object[] {
                    e,
                    TimeLimit,
                    TitleID,
                    LBID,
                    GamerTag,
                    NumAbove,
                    NumBelow}, callback, asyncState);
    }
    
    /// <remarks/>
    public StatsDetailedLB EndGetLBNearGamerTag(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((StatsDetailedLB)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetTitleList", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public TitleInfoList GetTitleList(string e, System.UInt32 TimeLimit) {
        object[] results = this.Invoke("GetTitleList", new object[] {
                    e,
                    TimeLimit});
        return ((TitleInfoList)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetTitleList(string e, System.UInt32 TimeLimit, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetTitleList", new object[] {
                    e,
                    TimeLimit}, callback, asyncState);
    }
    
    /// <remarks/>
    public TitleInfoList EndGetTitleList(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((TitleInfoList)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetFriends", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public FriendsList GetFriends(string e, System.UInt32 TimeLimit, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag) {
        object[] results = this.Invoke("GetFriends", new object[] {
                    e,
                    TimeLimit,
                    WebID,
                    GamerTag});
        return ((FriendsList)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetFriends(string e, System.UInt32 TimeLimit, System.Byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetFriends", new object[] {
                    e,
                    TimeLimit,
                    WebID,
                    GamerTag}, callback, asyncState);
    }
    
    /// <remarks/>
    public FriendsList EndGetFriends(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((FriendsList)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/LinkedGamerTags", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public LinkInfo[] LinkedGamerTags(string e, System.UInt32 TimeLimit, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID) {
        object[] results = this.Invoke("LinkedGamerTags", new object[] {
                    e,
                    TimeLimit,
                    WebID});
        return ((LinkInfo[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLinkedGamerTags(string e, System.UInt32 TimeLimit, System.Byte[] WebID, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LinkedGamerTags", new object[] {
                    e,
                    TimeLimit,
                    WebID}, callback, asyncState);
    }
    
    /// <remarks/>
    public LinkInfo[] EndLinkedGamerTags(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((LinkInfo[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/LinkUser", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public bool LinkUser(string e, System.UInt32 TimeLimit, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber) {
        object[] results = this.Invoke("LinkUser", new object[] {
                    e,
                    TimeLimit,
                    WebID,
                    GamerTag,
                    Owner,
                    PhonePrefix,
                    PhoneNumber,
                    PhoneExtension,
                    PostalCode,
                    CardHolder,
                    CardNumber});
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginLinkUser(string e, System.UInt32 TimeLimit, System.Byte[] WebID, string GamerTag, bool Owner, string PhonePrefix, string PhoneNumber, string PhoneExtension, string PostalCode, string CardHolder, string CardNumber, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("LinkUser", new object[] {
                    e,
                    TimeLimit,
                    WebID,
                    GamerTag,
                    Owner,
                    PhonePrefix,
                    PhoneNumber,
                    PhoneExtension,
                    PostalCode,
                    CardHolder,
                    CardNumber}, callback, asyncState);
    }
    
    /// <remarks/>
    public bool EndLinkUser(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((bool)(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://tempuri.org/GetUserSettings", RequestNamespace="http://tempuri.org/", ResponseNamespace="http://tempuri.org/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
    public System.UInt32 GetUserSettings(string e, System.UInt32 TimeLimit, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] WebID, string GamerTag) {
        object[] results = this.Invoke("GetUserSettings", new object[] {
                    e,
                    TimeLimit,
                    WebID,
                    GamerTag});
        return ((System.UInt32)(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetUserSettings(string e, System.UInt32 TimeLimit, System.Byte[] WebID, string GamerTag, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetUserSettings", new object[] {
                    e,
                    TimeLimit,
                    WebID,
                    GamerTag}, callback, asyncState);
    }
    
    /// <remarks/>
    public System.UInt32 EndGetUserSettings(System.IAsyncResult asyncResult) {
        object[] results = this.EndInvoke(asyncResult);
        return ((System.UInt32)(results[0]));
    }
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://tempuri.org/")]
public class StatsDetailedLB : DetailedLBResults {
    
    /// <remarks/>
    public System.UInt32 ValidSeconds;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(StatsDetailedLB))]
public class DetailedLBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public DetailedLBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class DetailedLBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntryAttribute[] F;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBEntryAttribute {
    
    /// <remarks/>
    public string ID;
    
    /// <remarks/>
    public string V;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/UserAccount/")]
public class LinkInfo {
    
    /// <remarks/>
    public string GamerTag;
    
    /// <remarks/>
    public bool Owner;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Presence/")]
public class OfflineFriend {
    
    /// <remarks/>
    public string G;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Presence/")]
public class OnlineFriend {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 T;
    
    /// <remarks/>
    public System.UInt32 S;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Presence/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(FriendsList))]
public class FriendsInfo {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public OnlineFriend[] OnlineFriends;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public OfflineFriend[] OfflineFriends;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://tempuri.org/")]
public class FriendsList : FriendsInfo {
    
    /// <remarks/>
    public System.UInt32 ValidSeconds;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(StatsFriendsLB))]
public class LBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://tempuri.org/")]
public class StatsFriendsLB : LBResults {
    
    /// <remarks/>
    public System.UInt32 ValidSeconds;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class LocalizedDisplayName {
    
    /// <remarks/>
    public string Locale;
    
    /// <remarks/>
    public string DisplayName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public class TitlePrivilegeInfo {
    
    /// <remarks/>
    public System.UInt32 TitleID;
    
    /// <remarks/>
    public TitlePrivilege Privileges;
    
    /// <remarks/>
    public ESRBRating Rating;
    
    /// <remarks/>
    public string DefaultLocale;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LocalizedDisplayName[] LocalizedName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public enum TitlePrivilege {
    
    /// <remarks/>
    None,
    
    /// <remarks/>
    ReadOnly,
    
    /// <remarks/>
    ReadWrite,
    
    /// <remarks/>
    FullControl,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/GeneralInfo/")]
public enum ESRBRating {
    
    /// <remarks/>
    ALL,
    
    /// <remarks/>
    ADULT,
    
    /// <remarks/>
    MATURE,
    
    /// <remarks/>
    TEEN,
    
    /// <remarks/>
    EVERYONE,
    
    /// <remarks/>
    KIDS_TO_ADULTS,
    
    /// <remarks/>
    EARLY_CHILDHOOD,
    
    /// <remarks/>
    UNSPECIFIED,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://tempuri.org/")]
public class TitleInfoList {
    
    /// <remarks/>
    public TitlePrivilegeInfo[] info;
    
    /// <remarks/>
    public System.UInt32 ValidSeconds;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBAttributeInfo {
    
    /// <remarks/>
    public string ID;
    
    /// <remarks/>
    public AttributeUnit Unit;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public StatsLocalizedName[] LocalizedAttrName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum AttributeUnit {
    
    /// <remarks/>
    Integer,
    
    /// <remarks/>
    Float,
    
    /// <remarks/>
    Percent,
    
    /// <remarks/>
    GamerTag,
    
    /// <remarks/>
    TimeStamp,
    
    /// <remarks/>
    MilliSeconds,
    
    /// <remarks/>
    TenMilliSeconds,
    
    /// <remarks/>
    HundredMilliSeconds,
    
    /// <remarks/>
    Seconds,
    
    /// <remarks/>
    Minutes,
    
    /// <remarks/>
    Hours,
    
    /// <remarks/>
    Days,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class StatsLocalizedName {
    
    /// <remarks/>
    public string Locale;
    
    /// <remarks/>
    public string DisplayName;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class LBInfo {
    
    /// <remarks/>
    public System.UInt32 LBID;
    
    /// <remarks/>
    public LBResetType ResetType;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public StatsLocalizedName[] LocalizedLBName;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public LBAttributeInfo[] AttributeInfo;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public enum LBResetType {
    
    /// <remarks/>
    Never,
    
    /// <remarks/>
    Weekly,
    
    /// <remarks/>
    Monthly,
    
    /// <remarks/>
    Bimonthly,
    
    /// <remarks/>
    Quarterly,
    
    /// <remarks/>
    Semiannually,
    
    /// <remarks/>
    Annually,
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://tempuri.org/")]
public class StatsLBList {
    
    /// <remarks/>
    public LBInfo[] info;
    
    /// <remarks/>
    public System.UInt32 ValidSeconds;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class RawLBAttribute {
    
    /// <remarks/>
    public System.UInt32 ID;
    
    /// <remarks/>
    public object V;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
public class RawLBEntry {
    
    /// <remarks/>
    public string G;
    
    /// <remarks/>
    public System.UInt32 R;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public RawLBAttribute[] A;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Stats/")]
[System.Xml.Serialization.XmlIncludeAttribute(typeof(StatsRawLB))]
public class RawLBResults {
    
    /// <remarks/>
    [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
    public RawLBEntry[] Entries;
    
    /// <remarks/>
    public System.DateTime LBLastResetDate;
    
    /// <remarks/>
    public System.UInt32 TotalLBEntries;
}

/// <remarks/>
[System.Xml.Serialization.XmlTypeAttribute(Namespace="http://tempuri.org/")]
public class StatsRawLB : RawLBResults {
    
    /// <remarks/>
    public System.UInt32 ValidSeconds;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\Web References\WCUtilities\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.0.3705.288
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.0.3705.288.
// 
namespace WCUtilTest.WCUtilities {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WCUtilWrapperSoap", Namespace="http://websvc.xboxlive.com/Test/WCUtilDll/")]
    public class WCUtilWrapper : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public WCUtilWrapper() {
            this.Url = "http://10.11.2.116/wcutilwrapper/wcutilwrapper.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Test/WCUtilDll/GetPartnerSpecificTitleInfo", RequestNamespace="http://websvc.xboxlive.com/Test/WCUtilDll/", ResponseNamespace="http://websvc.xboxlive.com/Test/WCUtilDll/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public TitlePrivilegeInfo[] GetPartnerSpecificTitleInfo() {
            object[] results = this.Invoke("GetPartnerSpecificTitleInfo", new object[0]);
            return ((TitlePrivilegeInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPartnerSpecificTitleInfo(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPartnerSpecificTitleInfo", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public TitlePrivilegeInfo[] EndGetPartnerSpecificTitleInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TitlePrivilegeInfo[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/Test/WCUtilDll/SetRequestInfo", RequestNamespace="http://websvc.xboxlive.com/Test/WCUtilDll/", ResponseNamespace="http://websvc.xboxlive.com/Test/WCUtilDll/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetRequestInfo(string APIName) {
            this.Invoke("SetRequestInfo", new object[] {
                        APIName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetRequestInfo(string APIName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetRequestInfo", new object[] {
                        APIName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetRequestInfo(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Test/WCUtilDll/")]
    public class TitlePrivilegeInfo {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public TitlePrivilege Privileges;
        
        /// <remarks/>
        public ESRBRating Rating;
        
        /// <remarks/>
        public string DefaultLocale;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LocalizedDisplayName[] LocalizedName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Test/WCUtilDll/")]
    public enum TitlePrivilege {
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        ReadOnly,
        
        /// <remarks/>
        ReadWrite,
        
        /// <remarks/>
        FullControl,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Test/WCUtilDll/")]
    public enum ESRBRating {
        
        /// <remarks/>
        ALL,
        
        /// <remarks/>
        ADULT,
        
        /// <remarks/>
        MATURE,
        
        /// <remarks/>
        TEEN,
        
        /// <remarks/>
        EVERYONE,
        
        /// <remarks/>
        KIDS_TO_ADULTS,
        
        /// <remarks/>
        EARLY_CHILDHOOD,
        
        /// <remarks/>
        UNSPECIFIED,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/Test/WCUtilDll/")]
    public class LocalizedDisplayName {
        
        /// <remarks/>
        public string Locale;
        
        /// <remarks/>
        public string DisplayName;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\Webwidget\WCUtilWrapper.cs ===
using System;
using System.IO;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using WCUtilTest.WCutilWrapper;
using ServerTestFramework.LiveService;
using xonline.common.config;

namespace WCUtilTest.WebWidget
{
	public class WCUtil : WCutilWrapper.WCUtilWrapper
	{
		protected RequestInfo requestInfo = null;

            /*
		public WCUtil() : this(Global.Env.UtilityWebCacheServer.EPDefault)
		{
		}
            */

		public WCUtil(LiveServer ls) : this(ls.EPDefault)
		{
		}

		public WCUtil(RequestInfo requestInfo)
		{
			Url = "http://" + Global.XEnv.GetVirtualInterface(VirtualInterface.lspstrsrflt).ToString() + "/LSPStrsRflt/reflect.asmx";
			this.requestInfo = requestInfo;
		}

		public WCUtil(IPEndPoint endpoint)
		{
			Url = "http://" + endpoint.ToString() + "/LSPStrsRflt/reflect.asmx";
			requestInfo = new RequestInfo();
		}

		public WCUtil(IPEndPoint endpoint, CertificateEntry certificate)
		{
			Url = "https://" + endpoint.ToString() + "/LSPStrsRflt/reflect.asmx";
			this.ClientCertificates.Add(new X509Certificate(certificate.Cert));
		}

		public WCUtil(IPEndPoint endpoint, RequestInfo requestInfo)
		{
			Url = "http://" + endpoint.ToString() + "/LSPStrsRflt/reflect.asmx";
			this.requestInfo = requestInfo;
		}

		override protected WebRequest GetWebRequest(Uri url)
		{
			WebRequest wr = base.GetWebRequest(new Uri(Url));

			if (requestInfo != null)
			{
				wr.Headers.Add("Subject-Name", requestInfo.SubjectName);
				wr.Headers.Add("Client-IP-Port", requestInfo.ClientIPPort);
				wr.Headers.Add("RequestId", requestInfo.RequestId);
			}

			return wr;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\ApprovalAssist.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;


namespace WebFormNS
{
	/// <summary>
	
	public class ApprovalAssist
	{
		
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!911";
		/// </summary>
		public static void ApprovalAssist1()
		{
			
			//
			//Helpers.profreg.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.text.xbox.com/en-us#");
			System.Threading.Thread.Sleep(2000);
			System.Threading.Thread.Sleep(2000);
			
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Approval Assistant&&value=http://auth.test.xbox.com/NR/exeres/32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Display Name&&value=javascript:__doPostBack('ApprovalAssistantGrid$_ctl2$_ctl0','')");
			System.Threading.Thread.Sleep(2000);
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Location&&value=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl1','')");
			System.Threading.Thread.Sleep(2000);

			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Owner&&value=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl2','')");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Last Modified&&value=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl3','')");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true");
			WebFormNS.ResourceMan.ResourceMan1();
			
			//	('/CMS/WebAuthor/Dialogs/TasksAssistant/ApprovalAssistant/ApprovalAssistant.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF%7d')
		//		CMS_openWindowApprovalAssistant
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WCUtilTest\Web References\WCutilWrapper\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2300
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.1.4322.2300.
// 
namespace WCUtilTest.WCutilWrapper {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="WCUtilWrapperSoap", Namespace="http://websvc.xboxlive.com/LSPStrsRflt/")]
    public class WCUtilWrapper : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public WCUtilWrapper() {
            this.Url = "http://10.40.202.51:12000/LSPStrsRflt/reflect.asmx";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/CheckAPI", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CheckAPI(string APIName) {
            this.Invoke("CheckAPI", new object[] {
                        APIName});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckAPI(string APIName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckAPI", new object[] {
                        APIName}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCheckAPI(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/CheckAPIAndTitle", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CheckAPIAndTitle(string APIName, System.UInt32 TitleID, TitlePrivilege privilegeRequired) {
            this.Invoke("CheckAPIAndTitle", new object[] {
                        APIName,
                        TitleID,
                        privilegeRequired});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckAPIAndTitle(string APIName, System.UInt32 TitleID, TitlePrivilege privilegeRequired, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckAPIAndTitle", new object[] {
                        APIName,
                        TitleID,
                        privilegeRequired}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCheckAPIAndTitle(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupPUID", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64 LookupPUID(string gamerTag) {
            object[] results = this.Invoke("LookupPUID", new object[] {
                        gamerTag});
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupPUID(string gamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupPUID", new object[] {
                        gamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64 EndLookupPUID(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupPUIDx100", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64 LookupPUIDx100(string gamerTag) {
            object[] results = this.Invoke("LookupPUIDx100", new object[] {
                        gamerTag});
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupPUIDx100(string gamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupPUIDx100", new object[] {
                        gamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64 EndLookupPUIDx100(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupPUIDBatch", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64[] LookupPUIDBatch(string[] gamerTags) {
            object[] results = this.Invoke("LookupPUIDBatch", new object[] {
                        gamerTags});
            return ((System.UInt64[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupPUIDBatch(string[] gamerTags, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupPUIDBatch", new object[] {
                        gamerTags}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64[] EndLookupPUIDBatch(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupGamerTag", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string LookupGamerTag(System.UInt64 PUID) {
            object[] results = this.Invoke("LookupGamerTag", new object[] {
                        PUID});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupGamerTag(System.UInt64 PUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupGamerTag", new object[] {
                        PUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndLookupGamerTag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupGamerTagx100", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string LookupGamerTagx100(System.UInt64 PUID) {
            object[] results = this.Invoke("LookupGamerTagx100", new object[] {
                        PUID});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupGamerTagx100(System.UInt64 PUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupGamerTagx100", new object[] {
                        PUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndLookupGamerTagx100(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupGamerTagBatch", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] LookupGamerTagBatch(System.UInt64[] PUIDs) {
            object[] results = this.Invoke("LookupGamerTagBatch", new object[] {
                        PUIDs});
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupGamerTagBatch(System.UInt64[] PUIDs, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupGamerTagBatch", new object[] {
                        PUIDs}, callback, asyncState);
        }
        
        /// <remarks/>
        public string[] EndLookupGamerTagBatch(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupTeamPUID", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64 LookupTeamPUID(System.UInt32 titleId, string teamName) {
            object[] results = this.Invoke("LookupTeamPUID", new object[] {
                        titleId,
                        teamName});
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupTeamPUID(System.UInt32 titleId, string teamName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupTeamPUID", new object[] {
                        titleId,
                        teamName}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64 EndLookupTeamPUID(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupTeamPUIDs", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64[] LookupTeamPUIDs(System.UInt32 titleId, string[] teamNames) {
            object[] results = this.Invoke("LookupTeamPUIDs", new object[] {
                        titleId,
                        teamNames});
            return ((System.UInt64[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupTeamPUIDs(System.UInt32 titleId, string[] teamNames, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupTeamPUIDs", new object[] {
                        titleId,
                        teamNames}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64[] EndLookupTeamPUIDs(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupTeamPUIDx100", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public System.UInt64 LookupTeamPUIDx100(System.UInt32 titleId, string teamName) {
            object[] results = this.Invoke("LookupTeamPUIDx100", new object[] {
                        titleId,
                        teamName});
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupTeamPUIDx100(System.UInt32 titleId, string teamName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupTeamPUIDx100", new object[] {
                        titleId,
                        teamName}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.UInt64 EndLookupTeamPUIDx100(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.UInt64)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupTeamName", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string LookupTeamName(System.UInt32 titleId, System.UInt64 puidTeam) {
            object[] results = this.Invoke("LookupTeamName", new object[] {
                        titleId,
                        puidTeam});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupTeamName(System.UInt32 titleId, System.UInt64 puidTeam, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupTeamName", new object[] {
                        titleId,
                        puidTeam}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndLookupTeamName(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupTeamNames", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string[] LookupTeamNames(System.UInt32 titleId, System.UInt64[] puidTeams) {
            object[] results = this.Invoke("LookupTeamNames", new object[] {
                        titleId,
                        puidTeams});
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupTeamNames(System.UInt32 titleId, System.UInt64[] puidTeams, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupTeamNames", new object[] {
                        titleId,
                        puidTeams}, callback, asyncState);
        }
        
        /// <remarks/>
        public string[] EndLookupTeamNames(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupTeamNamex100", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string LookupTeamNamex100(System.UInt32 titleId, System.UInt64 puidTeam) {
            object[] results = this.Invoke("LookupTeamNamex100", new object[] {
                        titleId,
                        puidTeam});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupTeamNamex100(System.UInt32 titleId, System.UInt64 puidTeam, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupTeamNamex100", new object[] {
                        titleId,
                        puidTeam}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndLookupTeamNamex100(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupWebIDArray", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public PUIDAndOwner[] LookupWebIDArray([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webID) {
            object[] results = this.Invoke("LookupWebIDArray", new object[] {
                        webID});
            return ((PUIDAndOwner[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupWebIDArray(System.Byte[] webID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupWebIDArray", new object[] {
                        webID}, callback, asyncState);
        }
        
        /// <remarks/>
        public PUIDAndOwner[] EndLookupWebIDArray(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PUIDAndOwner[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupWebID", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PUIDAndOwner LookupWebID([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webID, string GamerTag) {
            object[] results = this.Invoke("LookupWebID", new object[] {
                        webID,
                        GamerTag});
            return ((PUIDAndOwner)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupWebID(System.Byte[] webID, string GamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupWebID", new object[] {
                        webID,
                        GamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public PUIDAndOwner EndLookupWebID(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PUIDAndOwner)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/LookupWebIDx100", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public PUIDAndOwner LookupWebIDx100([System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] webID, string GamerTag) {
            object[] results = this.Invoke("LookupWebIDx100", new object[] {
                        webID,
                        GamerTag});
            return ((PUIDAndOwner)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginLookupWebIDx100(System.Byte[] webID, string GamerTag, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("LookupWebIDx100", new object[] {
                        webID,
                        GamerTag}, callback, asyncState);
        }
        
        /// <remarks/>
        public PUIDAndOwner EndLookupWebIDx100(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((PUIDAndOwner)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/GetPartnerSpecificTitleInfo", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public TitlePrivilegeInfo[] GetPartnerSpecificTitleInfo() {
            object[] results = this.Invoke("GetPartnerSpecificTitleInfo", new object[0]);
            return ((TitlePrivilegeInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPartnerSpecificTitleInfo(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPartnerSpecificTitleInfo", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public TitlePrivilegeInfo[] EndGetPartnerSpecificTitleInfo(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((TitlePrivilegeInfo[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/CacheInsert", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CacheInsert(CacheType type, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] key, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] value, System.UInt32 expireInSeconds) {
            this.Invoke("CacheInsert", new object[] {
                        type,
                        key,
                        value,
                        expireInSeconds});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCacheInsert(CacheType type, System.Byte[] key, System.Byte[] value, System.UInt32 expireInSeconds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CacheInsert", new object[] {
                        type,
                        key,
                        value,
                        expireInSeconds}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCacheInsert(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/ArbitraryCacheInsert", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public bool ArbitraryCacheInsert(CacheType type, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] key, System.UInt32 uiSizeInBytes, System.UInt32 expireInSeconds) {
            object[] results = this.Invoke("ArbitraryCacheInsert", new object[] {
                        type,
                        key,
                        uiSizeInBytes,
                        expireInSeconds});
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginArbitraryCacheInsert(CacheType type, System.Byte[] key, System.UInt32 uiSizeInBytes, System.UInt32 expireInSeconds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ArbitraryCacheInsert", new object[] {
                        type,
                        key,
                        uiSizeInBytes,
                        expireInSeconds}, callback, asyncState);
        }
        
        /// <remarks/>
        public bool EndArbitraryCacheInsert(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/QuickCacheInsert", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void QuickCacheInsert(CacheType type, System.UInt32 uiSizeInBytes, System.UInt32 expireInSeconds) {
            this.Invoke("QuickCacheInsert", new object[] {
                        type,
                        uiSizeInBytes,
                        expireInSeconds});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQuickCacheInsert(CacheType type, System.UInt32 uiSizeInBytes, System.UInt32 expireInSeconds, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("QuickCacheInsert", new object[] {
                        type,
                        uiSizeInBytes,
                        expireInSeconds}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndQuickCacheInsert(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/QuickCacheInsertX", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void QuickCacheInsertX(CacheType type, System.UInt32 uiSizeInBytes, System.UInt32 expireInSeconds, System.UInt32 numToInsert) {
            this.Invoke("QuickCacheInsertX", new object[] {
                        type,
                        uiSizeInBytes,
                        expireInSeconds,
                        numToInsert});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginQuickCacheInsertX(CacheType type, System.UInt32 uiSizeInBytes, System.UInt32 expireInSeconds, System.UInt32 numToInsert, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("QuickCacheInsertX", new object[] {
                        type,
                        uiSizeInBytes,
                        expireInSeconds,
                        numToInsert}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndQuickCacheInsertX(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/CacheLookup", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] CacheLookup(CacheType type, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] key) {
            object[] results = this.Invoke("CacheLookup", new object[] {
                        type,
                        key});
            return ((System.Byte[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCacheLookup(CacheType type, System.Byte[] key, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CacheLookup", new object[] {
                        type,
                        key}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Byte[] EndCacheLookup(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Byte[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/FrontDoorRequest", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public System.Byte[] FrontDoorRequest(string Url, System.UInt64 RequestingUserPUID, System.UInt32 titleID, System.UInt32 serviceId1, System.UInt32 serviceId2, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] System.Byte[] postData) {
            object[] results = this.Invoke("FrontDoorRequest", new object[] {
                        Url,
                        RequestingUserPUID,
                        titleID,
                        serviceId1,
                        serviceId2,
                        postData});
            return ((System.Byte[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginFrontDoorRequest(string Url, System.UInt64 RequestingUserPUID, System.UInt32 titleID, System.UInt32 serviceId1, System.UInt32 serviceId2, System.Byte[] postData, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("FrontDoorRequest", new object[] {
                        Url,
                        RequestingUserPUID,
                        titleID,
                        serviceId1,
                        serviceId2,
                        postData}, callback, asyncState);
        }
        
        /// <remarks/>
        public System.Byte[] EndFrontDoorRequest(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((System.Byte[])(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("http://websvc.xboxlive.com/LSPStrsRflt/ReloadTitlesAndPartners", RequestNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", ResponseNamespace="http://websvc.xboxlive.com/LSPStrsRflt/", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ReloadTitlesAndPartners() {
            this.Invoke("ReloadTitlesAndPartners", new object[0]);
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReloadTitlesAndPartners(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReloadTitlesAndPartners", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReloadTitlesAndPartners(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/LSPStrsRflt/")]
    public enum TitlePrivilege {
        
        /// <remarks/>
        None,
        
        /// <remarks/>
        ReadOnly,
        
        /// <remarks/>
        ReadWrite,
        
        /// <remarks/>
        FullControl,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/LSPStrsRflt/")]
    public class PUIDAndOwner {
        
        /// <remarks/>
        public System.UInt64 _PUID;
        
        /// <remarks/>
        public bool Owner;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/LSPStrsRflt/")]
    public class LocalizedDisplayName {
        
        /// <remarks/>
        public string Locale;
        
        /// <remarks/>
        public string DisplayName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/LSPStrsRflt/")]
    public class TitlePrivilegeInfo {
        
        /// <remarks/>
        public System.UInt32 TitleID;
        
        /// <remarks/>
        public TitlePrivilege Privileges;
        
        /// <remarks/>
        public ESRBRating Rating;
        
        /// <remarks/>
        public string DefaultLocale;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
        public LocalizedDisplayName[] LocalizedName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/LSPStrsRflt/")]
    public enum ESRBRating {
        
        /// <remarks/>
        ALL,
        
        /// <remarks/>
        ADULT,
        
        /// <remarks/>
        MATURE,
        
        /// <remarks/>
        TEEN,
        
        /// <remarks/>
        EVERYONE,
        
        /// <remarks/>
        KIDS_TO_ADULTS,
        
        /// <remarks/>
        EARLY_CHILDHOOD,
        
        /// <remarks/>
        UNSPECIFIED,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://websvc.xboxlive.com/LSPStrsRflt/")]
    public enum CacheType {
        
        /// <remarks/>
        StatChunk,
        
        /// <remarks/>
        FriendsPresence,
        
        /// <remarks/>
        UserSettings,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\ChannelProps.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for ChannelProps.
	/// </summary>
	public class ChannelProps
	{
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!911";

		public static void ChannelProps1()
		{
			//
			//
			//Helpers.profreg.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.text.xbox.com/en-us#");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Channel Properties&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PropertiesDialogs/ChannelProperties.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7bD9EC795B-E176-4211-B1B7-593E8B81B1AB%7d");
			System.Threading.Thread.Sleep(2000);
			

			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true");
			WebFormNS.PageProps.PageProps1();
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\copy.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;


namespace WebFormNS
{
	/// 
	/// Copy a page to another channel.
	/// 


	public class copy
	{
		
		

		
		public static void copy1()
		{
			//
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Copy&&value=http://auth.test.xbox.com/NR/exeres/2397ADEF-7DA4-491F-8075-40528AA93ABE.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#}");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=zh-TW&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageCopy/TreeFrame.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b1B878977-BDDE-42F8-B6B9-B751B99D8FA8%7d#}");
			copy.PresstabKey();
			copy.PresstabKey();
			copy.PresstabKey();
			copy.PressEnter();
			Move.Move1();
			//
		}
		public static bool PressEnter()
		{
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\DeleteTopNewPage.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// 
	//  Delete the top html page, which should be davewebrunnertest
	/// </summary>
	public class DeleteTopNewPage
	{
		
		public static void DeleteTopNewPage1()
		{
			//	//
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
							
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "href=Davewebrunnertest.htm&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Delete&&value=http://auth.test.xbox.com/NR/exeres/D9EC795B-E176-4211-B1B7-593E8B81B1AB.htm?NRMODE=Unpublished&wbc_purpose=Basic#&&exactmatch=false&&exactmatch=false");
			Console.WriteLine("will try to click on davewebrunnertest.htm now");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true&&ClearCookies=true");
			Console.WriteLine("End of Delete New page");
			ChannelProps.ChannelProps1();
			
			
			//
		}
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\CreateNewPage.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace WebFormNS
{
	/// <summary>
	
	/// </summary>
	public class CreateNewPage
	{
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!911";
		/// </summary>
		public static void CreateNewPage1()
		{
			//	//
			//Helpers.profreg.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Create New Page&&value=TemplateGalleriesBrowse.aspx");
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\Move.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for Move.
	/// </summary>
	public class Move
	{
		
		

		
		
		
		public static void Move1()
		{
			//
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Move&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageMove/PageMoveDlg.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b1BF207D7-A765-4903-88DE-1B93F38D1B56%7d}");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=zh-TW&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PageMove/TreeFrame.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b1BF207D7-A765-4903-88DE-1B93F38D1B56%7d#}");
			Move.PresstabKey();
			Move.PresstabKey();
			Move.PresstabKey();
			Move.PressEnter();
			
			subappdec.subappdec1();
			//
		}
		public static bool PressEnter()
		{
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\PageProps.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for PageProps.
	/// </summary>
	public class PageProps
	{
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!911";
		public static void PageProps1()
		{
			//
			//Helpers.profreg.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.text.xbox.com/en-us#");
			System.Threading.Thread.Sleep(2000);
				
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Channel Properties&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/PropertiesDialogs/PostingProperties.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID=%7b32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF%7d");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true");
			WebFormNS.RevisonHist.RevisonHist1();

			
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\Main.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;



 

namespace WebFormNS

{

	
	//Main.cs is designed to collect data from ProfReg.xml and put the data into Array's.
	//The section at the bottom of this class initiates the start of the functionality.

	public class Helpers
	{
	
		
		
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!911";
		

		
		
	
			
		/// </summary>
		public static void Initializer() 
		{
			
		
			//Helpers.profreg.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);

			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			
			
		}	
		
		public class WebFormTC : TestSuite

		{	

			public override void Initialize(System.Xml.XmlDocument config)
			{
			
				Console.WriteLine("Test am I getting here");
								 
			}
			
			public override InitializerInfo GetRequiredResources()

			{

				// need to use fakesg service

				InitializerInfo ii= new InitializerInfo();
				
				ii.UseFakeSG = false;
				
				Helpers.Initializer();		
				
				return ii;

			}

 

			// stress test for BasicTest

			public override InitializerInfo GetStressRequiredResources()

			{

				// besides using fakeSG service, this stress test also need to

				// createUsers before testing start, also need certificates

				InitializerInfo   ii = new InitializerInfo();

				ii.UseFakeSG = false;

				ii.CreateUsers = false;

				ii.Certificates = false;

				return ii;

			}
		}
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\PManager.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;



 



namespace WebFormNS
{
	/// <summary>
	/// Summary description for PManager.
	/// </summary>
	public class PManager
	{
		

		public static void PManager1()
		{
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Production Manager&&value=http://auth.test.xbox.com/NR/exeres/32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Page&&value=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl0','')");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Channel&&value=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl1','')");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Last Modified&&value=javascript:__doPostBack('ProductionManagerGrid$_ctl2$_ctl2','')");
			Helpers.XHTMLVal.Click(HTMLUIObj.Image, "src=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/CommonImages/Icons/iconGoTo.gif");
			

			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true");
			
			WebFormNS.ApprovalAssist.ApprovalAssist1();
			
			
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\Preview.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for Preview.
	/// </summary>
	public class Preview
	{
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!911";

		public static void Preview1()
		{
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.text.xbox.com/en-us#");
			int start;
			int at;
			int end;
			int count;

			
		
			string FullHTML = Helpers.XHTMLVal.GetHTMLAttribute(HTMLUIObj.ByTag, "tag=html&&AttributeToGet=InnerHTML");
			
			end = FullHTML.Length;
			//start = end/2;
			start = 1;
			//FullHTML.IndexOf("At least we can put text in our first flex template", start, end);
			at = 0;
			while((start <= end) && (at > -1))
			{
				// start+count must be a position within -str-.
				count = end - start;
				at = FullHTML.IndexOf("At least we can put text in our first flex template", start, count);
				if (at == -1) break;
				Console.Write("{0} ", at);
				start = at+1;
			}

			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Preview&&value=http://auth.test.xbox.com/NR/exeres/32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublishedPreview&nr_emit=View");
		
			int prestart;
			int preat;
			int preend;
			int precount;

			
		
			string preFullHTML = Helpers.XHTMLVal.GetHTMLAttribute(HTMLUIObj.ByTag, "tag=html&&AttributeToGet=InnerHTML");
			
			preend = preFullHTML.Length;
			//start = end/2;
			prestart = 1;
			//FullHTML.IndexOf("At least we can put text in our first flex template", start, end);
			preat = 0;
			while((prestart <= preend) && (preat > -1))
			{
				// start+count must be a position within -str-.
				precount = preend - prestart;
				preat = preFullHTML.IndexOf("At least we can put text in our first flex template", prestart, precount);
				if (preat == -1) break;
				Console.Write("{0} ", preat);
				prestart = preat+1;
			}
			if (preat != 0)
						{
							Console.WriteLine("The verification is on the main page and the preview page");
						}
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true");
			WebFormNS.CreateNewPage.CreateNewPage1();
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\subappdec.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for subappdec.
	/// </summary>
	public class subappdec
	{
		
			//
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!911";
		/// </summary>
		public static void subappdec1()
		{
			//	//
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
								
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=View Revisions by Date&&value=http://auth.test.xbox.com/NR/exeres/3274E414-5270-4CA3-87D0-D0DDE1477020,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#");
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PresstabKey();
			
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PresstabKey();
			WebFormNS.subappdec.PressEnter();
			System.Threading.Thread.Sleep(2000);
			WebFormNS.subappdec.PresstabKey();
			System.Threading.Thread.Sleep(2000);
			
			WebFormNS.subappdec.PressEnter();
			
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Submit&&value=http://auth.test.xbox.com/NR/exeres/B07380B3-98A5-4890-8BAB-AD7B11F4F89F.htm?wbc_purpose=Basic&NRMODE=Unpublished&WBCMODE=PresentationUnpublished#");
			Console.WriteLine("Clicking on submit");
			System.Threading.Thread.Sleep(20000);
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Decline&&value=http://auth.test.xbox.com/NR/exeres/4C4A5EFF-8EA8-42D9-B196-ECB9E7097FE9,frameless.htm?NRMODE=Update&WBCMODE=PresentationUnpublished#");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true&&ClearCookies=true");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Submit&&value=http://auth.test.xbox.com/NR/exeres/B07380B3-98A5-4890-8BAB-AD7B11F4F89F.htm?wbc_purpose=Basic&NRMODE=Unpublished&WBCMODE=PresentationUnpublished#");
			Console.WriteLine("Clicking on submit");
			Console.WriteLine("End of submit approve decline page");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Approve&&value=http://auth.test.xbox.com/NR/exeres/4C4A5EFF-8EA8-42D9-B196-ECB9E7097FE9,frameless.htm?NRMODE=Update&WBCMODE=PresentationUnpublished#");
			System.Threading.Thread.Sleep(2000);
			
			
			//
		}
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			Console.WriteLine("Pressing Enter");
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool PresstabKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\ViewRevbyDate.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for ViewRevbyDate.
	/// </summary>
	public class ViewRevbyDate
	{
		


		public static void ViewRevbyDate1()
		{
			//
			Console.WriteLine("Starting View Revisions by Date");
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
			
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&id=SwitchToPresentationUnpublishedAnchor");
			
			

			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=View Revisions by Date&&value=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/RevisionBrowser/PageRevisionPreviewByDateDlg.aspx?NRMODE=Unpublished&FRAMELESS=true&NRNODEGUID=%7b90F79D5F-71E9-435F-AC5C-95B9D52B17AB%7d");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"title=Microsoft Content Management Server&&exactmatch=false");						
			
			
			Helpers.XHTMLVal.FindIE("title=PageRevisionPreviewByDateDlg");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=PageRevisionPreviewByDateDlg&&exactmatch=false");
			Helpers.XHTMLVal.InputText(Win32UIObj.Text, "name=tbxStartDate&&InputToText=1/4/2005");
			Helpers.XHTMLVal.InputText(HTMLUIObj.TextBox, "TextToInput=1/19/2005&&name=tbxStartDate&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.ByTag, "tag=Button&&id=WBC_imgView&&exactmatch=false");
			Console.WriteLine("View Revision by date testing is done");
			copy.copy1();
			

			//
		}
		public static bool PressEnter()
		{
			System.Threading.Thread.Sleep(2000);
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool changedate2()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=10/05/2004&&TimesToPress=1");

		}
		public static bool changedate1()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=10/06/2004&&TimesToPress=1");

		}
		public static bool PresstabKey() 
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\RevisonHist.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for RevisonHist.
	/// </summary>
	public class RevisonHist
	{
		
		


		public static bool RevisonHist1()
		{
			//
			bool return4;
			Helpers.XHTMLVal.SetCredentials(@"username="+Helpers.authUser+"&&password="+Helpers.authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.FindIE("title=FlexTemplate");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=FlexTemplate&&exactmatch=false");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.test.xbox.com/en-us#");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Davewebrunnertest.htm&&value=http://auth.test.xbox.com/NR/exeres/479B163C-9F86-4DD9-9089-9E2B60B955A2.htm?wbc_purpose=Basic&NRMODE=Unpublished&WBCMODE=PresentationUnpublished#");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Revision History&&value=http://auth.test.xbox.com/NR/exeres/479B163C-9F86-4DD9-9089-9E2B60B955A2.htm?wbc_purpose=Basic&NRMODE=Unpublished&WBCMODE=PresentationUnpublished#");
			Helpers.XHTMLVal.FindIE("title=Microsoft Content Management Server");
			Helpers.XHTMLVal.AttachTo(Win32Special.Window,"Title=Microsoft Content Management Server&&exactmatch=false");
			
			if (Helpers.XHTMLVal.Verify(Win32UIObj.MenuItem, "name=Properties&&ExactMatch=true", true))
			{
				return4 = true;
			}
			else
			{
				return4 = false;
			}
			Helpers.XHTMLVal.Click(HTMLUIObj.CheckBox, "name=UnapprovedRevisionCheckBox&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.Button, "name=ClearButton&&exactmatch=false");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=10");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=15");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=20");
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=PagingConfigControl&&TextToInput=All");
			
			
			Console.WriteLine("Revision History Testing is done");
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true&&ClearCookies=true");
			ViewRevbyDate.ViewRevbyDate1();
			
					return return4;
		}
		public static bool PressEnter()
		{
			
			return Helpers.XHTMLVal.PressKey("TextToInput=[enter]");
		}
		public static bool changedate2()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=10/05/2004&&TimesToPress=1");

		}
		public static bool changedate1()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=10/06/2004&&TimesToPress=1");

		}
		public static bool PresstabKey() 
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool Pressleftmouse()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[mouseleft]&&TimesToPress=2");
		}
		public static bool PressupKey()
		{
			System.Threading.Thread.Sleep(40000);
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebRunner\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil__webrunner_1_none_12.4.56.0_none_3d6157f90700a8ec
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_webrunner_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a.manifest
XP_MANIFEST_PATH=manifests\msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a.cat
XP_CATALOG_PATH=manifests\msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a.cat
XP_PAYLOAD_PATH=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_webrunner_1,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebRunner\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil__webrunner_1_none_12.4.56.0_none_3d6157f90700a8ec
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_webrunner_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a.manifest
XP_MANIFEST_PATH=manifests\msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a.cat
XP_CATALOG_PATH=manifests\msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a.cat
XP_PAYLOAD_PATH=msil__webrunner_1_no-public-key_12.4.56.0_x-ww_5b8a639a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_webrunner_1,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\ResourceMan.cs ===
using System;
using Microsoft.WebRunner;
using ServerTestFramework;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using Microsoft.WebRunner.Loggers;

namespace WebFormNS
{
	/// <summary>
	/// Summary description for ResourceMan.
	/// </summary>
	public class ResourceMan
	{
		
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//public static string authUser = "TEST\\_xbcauthbvt";
		//public static string authPass = "F0rSh@r0n";
		public static string authUser = "TEST\\davidulm";
		public static string authPass = "Test!911";
		

		public static void ResourceMan1()
		{
			
			//Helpers.profreg.StartApplication(AppObj.IE, "url=http://test.xbox.com/en-us");
			XHTMLVal.SetCredentials(@"username="+authUser+"&&password="+authPass);
			Helpers.XHTMLVal.StartApplication(AppObj.IE, "url=http://auth.test.xbox.com/en-us");
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.text.xbox.com/en-us#");
	
			Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Resource Manager&&value=http://auth.test.xbox.com/NR/exeres/32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF,frameless.htm?NRMODE=Unpublished&WBCMODE=PresentationUnpublished&wbc_purpose=Basic#");
			
			System.Threading.Thread.Sleep(1000);
			Helpers.XHTMLVal.Click(HTMLUIObj.Select, "id=ResourceGalleriesControl_GalleriesViewSelect");
			
			WebFormNS.ResourceMan.PresstabKey();
			System.Threading.Thread.Sleep(20000);
			WebFormNS.ResourceMan.PressupKey();
			
			System.Threading.Thread.Sleep(20000);
			WebFormNS.ResourceMan.PressdownKey();
			//Should be list view now
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Resource Gallery&&value=javascript:__doPostBack('ResourceGalleriesControl$ResourceGalleryGrid$_ctl2$_ctl0','')");
			System.Threading.Thread.Sleep(2000);
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Location&&value=javascript:__doPostBack('ResourceGalleriesControl$ResourceGalleryGrid$_ctl2$_ctl1','')");
			System.Threading.Thread.Sleep(10000);
			Helpers.XHTMLVal.Click(Win32UIObj.Text, "name=Last Modified&&value=javascript:__doPostBack('ResourceGalleriesControl$ResourceGalleryGrid$_ctl2$_ctl2','')");
			System.Threading.Thread.Sleep(1000);
			Helpers.XHTMLVal.Click(Win32UIObj.List, "name=Resource Manager&&MouseAction=right"); //This does a right click
			System.Threading.Thread.Sleep(1000);
			Helpers.XHTMLVal.AttachTo(Win32Special.Window, "name=Back");
			WebFormNS.ResourceMan.PresstabKey();
			System.Threading.Thread.Sleep(1000);
			WebFormNS.ResourceMan.PressdownKey();
			System.Threading.Thread.Sleep(20000);
			//Helpers.XHTMLVal.Click(HTMLUIObj.Link, "href=http://auth.test.xbox.com/CMS/WebAuthor/Dialogs/ResourceBrowser/Management/ResourcesBrowse.aspx?NRMODE=Update&FRAMELESS=true&NRNODEGUID={32C2FFBD-0A31-4FD1-A011-2DDBC4952BCF}&wbc_gallery={BB6FDE0E-4E97-46B1-80D8-6ACE950A4979}&TimeStamp=632361364549357623&&exactmatch=false");
			//Helpers.XHTMLVal.Click(HTMLUIObj.Link, "href=ResourcesBrowse.aspx?&&exactmatch=false");
			WebFormNS.ResourceMan.ClickonProdCat();
			System.Threading.Thread.Sleep(1000);
			Helpers.XHTMLVal.CleanUp("CloseBrowsers=true&&ClearCache=true");
			//WebFormNS.ChannelProps.ChannelProps1();
			WebFormNS.Preview.Preview1();
			
		}
		public static bool ClickonProdCat()
		{
			return Helpers.XHTMLVal.Click(HTMLUIObj.Link, "innertext=Product Catalog&&exactmatch=false");
		}
		public static bool PresstabKey()
		{
				return Helpers.XHTMLVal.PressKey("TextToInput=[tab]");
		}
		public static bool PressupKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[up]");
			System.Threading.Thread.Sleep(40000);
		}
		public static bool PressdownKey()
		{
			return Helpers.XHTMLVal.PressKey("TextToInput=[down]");
			System.Threading.Thread.Sleep(40000);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebForm\WF.cs ===
using System;
using System.Xml;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Collections;
using System.Net;
using System.Threading;
using System.Text;
using System.Resources;
using System.Reflection;
using System.Globalization;
using Microsoft.WebRunner;
using ServerTestFramework;
using Microsoft.WebRunner.Loggers;




namespace WebFormNS
{
	/// <summary>
	/// I will break this class up again to make it a more descriptive class but for now the test cases
	/// start here and consoleregistration will be broken out to another class to finish this out.
	/// I will do that this weekend...Dave
	/// </summary>
	[TestGroup] 

	public class WebFormInput : TestNode
	{
		/// <summary>
		const int ERROR_FILE_NOT_FOUND =2;
		const int ERROR_ACCESS_DENIED = 5;
		public static WebRunnerSDK mySDK;
		public static System.Threading.Timer myPopUpTimer;
		public static WebRunnerSDK XHTMLVal = new WebRunnerSDK(); 
		//Starting up the application to test my account with console serial number
		
	
		[TestCase, Description("This test case passes")]
			class GoodTest1 : TestBase
		{
			protected override void Execute()
			{
				bool Results = WebFormTC(0);
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		[TestCase, Description("This test should work. Good data")]
			class secondgoodtest2 : TestBase
		{
			protected override void Execute()
			{
				bool Results = WebFormTC(1);
				
				if (Results) 
				{
					ResultCode = TEST_RESULTS.PASSED;
				}
				else 
				{ 
					ResultCode = TEST_RESULTS.FAILED;
				}
			}
		}
		
		public static bool WebFormTC(int nCntr)
		{
			
			bool Results = true;
			bool Falseoverride = true;
			
			
			
			if (Helpers.XHTMLVal.Verify(HTMLUIObj.Url, "Url=http://auth.test.xbox.com/en-us"))
			{
				Helpers.XHTMLVal.Click(Win32UIObj.Link, "name=Switch To Edit Site&&value=http://auth.text.xbox.com/en-us#");
			}
			else
			{
				Console.WriteLine("Cannot verify the site is up correctly");
			
			}

			//Production Manager Testing
			WebFormNS.PManager.PManager1();
			
				
		  
			//End: Console.WriteLine("Logging out of passport and clearing cache then closing browser");
		
			Helpers.XHTMLVal.Click(HTMLUIObj.Link, "HREF=http://login.passport-ppe.com/logout.srf&&exactmatch=false");
					
			
			//Helpers.profreg.CleanUp("CloseBrowsers=true&&ClearCache=true&&ClearCookies=false");
			if (Falseoverride == false)
			{
				Results = false;
			}
			return Results;
			//
		}
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\Stress.cs ===
using System;
using ServerTestFramework;

namespace WebSGBVTs
{
    //TODO: Stress tests
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\CertificateStore.cs ===
using System;
using System.Security.Cryptography.X509Certificates;
using CAPICOM;

namespace WebSGBVTs
{
	/// <summary>
	/// CertificateStore contains a bunch of static functions used to deal with x509 certificates.
	/// Blatantly copied and modified from WSHelper
	/// </summary>
	public class CertificateStore
	{
		public static string CertificateCN(string cert)
		{
			string txt = cert;
			int idx = txt.IndexOf("CN=");
			if(idx < 0)
				return "";
			idx += 3;
			int end = txt.IndexOf(',', idx);
			if(end < 0)
				return txt.Substring(idx, txt.Length - idx);
			return txt.Substring(idx, end - idx);
		}

		public static string CertificateCN(X509Certificate cert)
		{
			return CertificateCN(cert.Subject);
		}

		public static StoreClass GetCertificateStore()
		{
			try
			{
				StoreClass store = new StoreClass();
				string user = System.Security.Principal.WindowsIdentity.GetCurrent().Name;
				CAPICOM.CAPICOM_STORE_LOCATION loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_CURRENT_USER_STORE;
				if(user.StartsWith("NT AUTHORITY\\") || user.EndsWith("\\ASPNET"))
					loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_LOCAL_MACHINE_STORE;
				int i = user.LastIndexOf("\\");
				if(i >= 0)
				{
					string m = user.Substring(0, i).ToLower();
					string u = user.Substring(i + 1).ToLower();
					if(u == "iusr_" + m || u == "iwam_" + m)
						loc = CAPICOM.CAPICOM_STORE_LOCATION.CAPICOM_LOCAL_MACHINE_STORE;
				}
				store.Open(loc, "My", CAPICOM.CAPICOM_STORE_OPEN_MODE.CAPICOM_STORE_OPEN_READ_ONLY);
//				Console.WriteLine("GetCertificateStore: Using store " + loc.ToString() + " for user " + user);
				return store;
			}
			catch(System.Exception f)
			{
				throw new Exception ("GetCertificateStore: Exception accessing the certificate store: " + f.ToString());
			}
//			return null;
		}

		public static bool ExistsCertificate(X509Certificate cer)
		{
			try
			{
				StoreClass store = GetCertificateStore();
				if(store == null)
					return true;
				if(store.Certificates == null || store.Certificates.Count == 0)
				{
					throw new Exception ("ExistsCertificate: No certificates found in the store.");
				}
				else
				{
					foreach(ICertificate2 cert in store.Certificates)
					{
						if(cert.IsValid().Result && (CertificateCN(cer.Issuer) == CertificateCN(cert.IssuerName)) &&
							(CertificateCN(cer.Subject) == CertificateCN(cert.SubjectName)))
						{
//							Console.WriteLine("ExistsCertificate: Found a certificate in the store for: " + CertificateCN(cer.GetIssuerName()) + "\\" + CertificateCN(cer.GetName()));
							return true;
						}
					}
					throw new Exception ("ExistsCertificate: Failed to find a certificate in the store for: " + CertificateCN(cer.Issuer) + "\\" + CertificateCN(cer.Subject));
				}
			}
			catch(System.Exception f)
			{
				throw new Exception ("ExistsCertificate: Exception enumerating certificates: " + f.ToString());
			}
//			return false;
		}

		public static X509Certificate LookupCertificate(string issuer, string subject)
		{
			try
			{
				StoreClass store = GetCertificateStore();
				if(store == null || store.Certificates == null || store.Certificates.Count == 0)
				{
					Console.WriteLine("LookupCertificate: No certificates found in the store.");
				}
				else
				{
					foreach(ICertificate2 cert in store.Certificates)
					{
                        //bool fValidCert = cert.IsValid().Result;
                        bool fValidIssuer = (issuer == null || issuer == "" || issuer == CertificateCN(cert.IssuerName));
                        bool fValidSubject = (subject != null && subject != "" && subject == CertificateCN(cert.SubjectName));

                        if (/*fValidCert &&*/ fValidIssuer && fValidSubject	)
						{
//							Console.WriteLine("LookupCertificate: Found a certificate in the store for: " + ((issuer == null || issuer == "") ? "*" : issuer) + "\\" + ((subject != null && subject != "") ? subject : "<unspecified>"));
							string b64cert = cert.Export(CAPICOM.CAPICOM_ENCODING_TYPE.CAPICOM_ENCODE_BASE64);
							return new X509Certificate(Convert.FromBase64String(b64cert));
						}
					}
					throw new Exception ("ExistsCertificate: Failed to find a certificate in the store for: " + ((issuer == null || issuer == "") ? "*" : issuer) + "\\" + ((subject != null && subject != "") ? subject : "<unspecified>"));
				}
			}
			catch(System.Exception f)
			{
				throw new Exception ("LookupCertificate: Exception enumerating certificates: " + f.ToString());
			}
			return null;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\FuncWebSG.cs ===
using System;
using System.Collections;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.GeneralInfo;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.Web.SignatureWidget;
using xonline.common.config;

namespace WebSGBVTs
{
	#region Linked Accounts related tests
	/// <summary>
	/// Account Linking related tests
	/// </summary>
	[TestGroup]
	public class AccountLinkingGroup : TestNode
	{
		/// <summary>
		/// This test is equivalent to WSTestSuite.WSTests.LinkUser.
		/// </summary>
		[TestCase, Description("Verify accounts can be linked")]
		class LinkUser : UserTestBase
		{
			protected override void Execute ()
			{
				// Pessimist.
				ResultCode = TEST_RESULTS.FAILED;

				// Create an owner
				UacsCommon uacs = new UacsCommon ();
				Owner owner = UACS.GenerateOwner();

				// Create a user
				ulong puid = uacs.CreateUser (owner);

				// Connect to the WebSG
				WCUserAccount ua = new WCUserAccount (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// Link the user
				if (ua.LinkUser (puid, false, owner))
					ResultCode = TEST_RESULTS.PASSED;
			}
		} // LinkUserTest

		/// <summary>
		/// This test is equivalent to WSTestSuite.WSTest.GeneralInfoLinkedGamerTags
		/// </summary>
		[TestCase, Description("Verify linked accounts can be retrieved using GeneralInfo")]
		class GeneralInfoLinkedGamerTags : UserTestBase
		{
			protected override void Execute ()
			{
				// Pessimist.
				ResultCode = TEST_RESULTS.FAILED;

				// Connect to the WebSG
				WCGeneralInfo gi = new WCGeneralInfo (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// Get the webID for webuser0
				UInt64 webID = 0x0001FFFFFFFFFBFF;

				// Get link information for webuser0
				ServerTestFramework.Web.GeneralInfo.LinkInfo[] LIs = gi.LinkedGamerTags (BitConverter.GetBytes (webID));

				// It should have returned a valid array
				if (null == LIs)
					throw new Exception ("Could not retrieve linked gamer tags");

				// Done!
				ResultCode = TEST_RESULTS.PASSED;

			}
		} // GeneralInfoLinkedGamerTags

		/// <summary>
		/// This test is equivalent to WSTestSuite.WSTest.ValidateLinkedUser
		/// </summary>
		[TestCase, Description("Verify accounts can be linked")]
		class ValidateLinkedUser : UserTestBase
		{
			protected override void Execute ()
			{
				// Pessimist.
				ResultCode = TEST_RESULTS.FAILED;

				// Connect to the WebSG
				WCUserAccount ua = new WCUserAccount (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// Get the webID for webuser0
				string user = "webuser0";
				UInt64 webID = 0x0001FFFFFFFFFBFF;

				// Get link information for webuser0
				ServerTestFramework.Web.UserAccount.LinkInfo[] LIs = ua.LinkedGamerTags (BitConverter.GetBytes (webID));

                if (LIs.Length == 0)
                {
                    throw new Exception("Didn't get and linked gamertags back, are the webusers propped?");
                }

				// It should be linked as owner
				if (0 != String.Compare (user, LIs[0].GamerTag, true))
					throw new Exception ("GamerTag and requested GamerTag don\'t match: Wanted \'" + user + "\', got \'" + LIs[0].GamerTag);

				// Done!
				ResultCode = TEST_RESULTS.PASSED;

			}
		} // ValidateLinkedUser


		[TestCase, Description("Verify that the linked account in UserAccount match those in GeneralInfo")]
		class ValidateLinkedGamerTags : UserTestBase
		{
			protected override void Execute ()
			{
				// Pessimist.
				ResultCode = TEST_RESULTS.FAILED;

				// Connect to the WebSG
				WCGeneralInfo gi = new WCGeneralInfo (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				WCUserAccount ua = new WCUserAccount (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// Get the webID for webuser0
				UInt64 webID = 0x0001FFFFFFFFFBFF;

				// Get link information for webuser0
				ServerTestFramework.Web.GeneralInfo.LinkInfo[] giLGTs = gi.LinkedGamerTags (BitConverter.GetBytes (webID));
				ServerTestFramework.Web.UserAccount.LinkInfo[] uaLGTs = ua.LinkedGamerTags (BitConverter.GetBytes (webID));

				// It should have returned a valid arrays
				if (null == giLGTs)
					throw new Exception ("Could not retrieve linked gamer tags from GeneralInfo");

				if (null == uaLGTs)
					throw new Exception ("Could not retrieve linked gamer tags from UserAccount");

				// Place the GI game tags in a hash table for later comparison
				Hashtable hgi = new Hashtable(), hua = new Hashtable();
				foreach(ServerTestFramework.Web.GeneralInfo.LinkInfo li in giLGTs)
				{
					hgi[(li.Owner ? "+" : "-") + li.GamerTag] = 1;
				}

				// Place the UA game tags in a hash table for later comparison
				foreach(ServerTestFramework.Web.UserAccount.LinkInfo li in uaLGTs)
				{
					hua[(li.Owner ? "+" : "-") + li.GamerTag] = 1;
				}

				// The gamertags in on one hashtable must match those of the other
				foreach(string key in hua.Keys)
				{
					if(hgi[key] == null)
						throw new Exception("There is a mismatch between the linked account lists returned between the GeneralInfo widget and the UserAccount widget.  They have different contents.");
				}

				// Done
				ResultCode = TEST_RESULTS.PASSED;
			}
		} // ValidateLinkedGamerTags

	} // AccountLinkingGroup

	#endregion

	#region Title List related tests
	/// <summary>
	/// Title List related tests
	/// </summary>
	[TestGroup]
	public class TitleListGroup : TestNode
	{
		[TestCase, Description("")]
		class GetTitleList : UserTestBase
		{
			protected override void Execute ()
			{
				// Pessimist...
				ResultCode = TEST_RESULTS.FAILED;

				// Connect to the WebSG
				WCGeneralInfo gi = new WCGeneralInfo (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// Get the list of titles
				uint uValidSeconds;
				TitlePrivilegeInfo[] aTitles = gi.GetTitleList (out uValidSeconds);

				if (null == aTitles)
					throw new Exception ("Could not get title list.");

				// Done!
				ResultCode = TEST_RESULTS.PASSED;
			}
		} // GetTitleList

		[TestCase, Description("")]
		class VerifyTitleList : UserTestBase
		{
			protected override void Execute ()
			{
				// Pessimist...
				ResultCode = TEST_RESULTS.FAILED;

				// Connect to the WebSG
				WCGeneralInfo gi = new WCGeneralInfo (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// Get the list of titles
				uint uValidSeconds;
				TitlePrivilegeInfo[] aTitles = gi.GetTitleList (out uValidSeconds);

				if (null == aTitles)
					throw new Exception ("Could not get title list.");

				// Verify each title
				System.Globalization.CultureInfo ci;
				foreach (TitlePrivilegeInfo tpi in aTitles)
				{
					// Try to extract culture info from the title
					string sTPILocale = (tpi.DefaultLocale == "en-SG") ? "zh-SG" : tpi.DefaultLocale;
					ci = new System.Globalization.CultureInfo (sTPILocale);

                    // Check for no localized names, this means that there is a problem in WebDB
                    if (tpi.LocalizedName == null)
                    {
                        throw new Exception("No localized names found for title 0x" + tpi.TitleID.ToString("X8"));
                    }

					// Find default title
					bool bDefaultFound = false;
					foreach (LocalizedDisplayName ldn in tpi.LocalizedName)
					{
						string sLDNLocale = (ldn.Locale == "en-SG") ? "zh-SG" : ldn.Locale;
						if (sTPILocale == sLDNLocale)
						{
							bDefaultFound = true;
							break;
						}

						ci = new System.Globalization.CultureInfo(sLDNLocale);
					} // foreach

					// Oh oh... Fail if the default title wasn't found
					if (!bDefaultFound) throw new Exception ("No default title could be found.");

				} // foreach

				// Done!
				ResultCode = TEST_RESULTS.PASSED;
			}
		} // GetTitleList

	} // TitleListGroup
	#endregion

    /* Alerts no longer supported
     *
	#region Alerts related tests
    [TestGroup]
	public class AlertsGroup : TestNode
	{
		[TestCase, Description("")]
		class ScheduleContentAlert : TestBase
		{
			protected override void Execute()
			{
				// Pessimist...
				ResultCode = TEST_RESULTS.FAILED;

				// Connect to the WebSG
				WCAlertsWidget alert = new WCAlertsWidget (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// Schedule an alert for webuser0
				UInt64 webID = 0x0001FFFFFFFFFBFF;
				alert.ScheduleContentAlert (BitConverter.GetBytes (webID), 128, "en-US", "STF generated alert.", DateTime.UtcNow.AddYears(1));

				// Done!
				ResultCode = TEST_RESULTS.PASSED;
			}
		} // ScheduleContentAlert
	} // AlertsGroup
	#endregion
    *
    */

} // WebSGBVTs
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_websgbvts_none_12.4.56.0_none_bbcb884e0bb5504a
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=websgbvts
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e.manifest
XP_MANIFEST_PATH=manifests\msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e.cat
XP_CATALOG_PATH=manifests\msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e.cat
XP_PAYLOAD_PATH=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=websgbvts,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\WebSGBVTs.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Threading;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Web;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Query;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;

[assembly: RootNode(typeof(WebSGBVTs.WebSGBVTs))]

namespace WebSGBVTs
{
    [Owner("johnmcp"), TestFrequency("Daily"), TestCasePriority(2)]
	public class WebSGBVTs : TestNode
	{
	}

	public class Helper
	{
		// string containing the name of the certificate
		static private string _Certificate = null;
		static private string _XUID = null;
		static private string _Filename = "WebSGBVTs.xml";


		static public string Certificate
		{
			get
			{
				// Get the certificate if you don't already have it
				if (null == _Certificate)
					_GetCertificateFromXML ();

				// Return the certificate
				return _Certificate;
			}
		}

		static public string XUID
		{
			get
			{
				// Get the certificate if you don't already have it
				if (null == _XUID)
					_GetXUIDFromXML ();

				// Return the certificate
				return _XUID;
			}
		}

		static private void _GetCertificateFromXML ()
		{
/*			string sFilename = "WebSGBVTs.xml";
			XmlDocument parameters = new XmlDocument ();
			parameters.Load (sFilename);
			XmlNode paramNode;

			try
			{
				// query
				paramNode = parameters.SelectSingleNode("/certificate");
				if (null == paramNode) throw new Exception();
				_Certificate = paramNode.InnerText;
			}
			catch (Exception)
			{
				ConsoleX.WriteLine("Could not find the certificate name in " + sFilename);
			}
*/
			XmlConfigFile Config = new XmlConfigFile (_Filename);
			_Certificate = Config["/certificate"];
		}

		static private void _GetXUIDFromXML ()
		{
			XmlConfigFile Config = new XmlConfigFile (_Filename);
			_XUID = Config["/xuid"];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_websgbvts_none_12.4.56.0_none_bbcb884e0bb5504a
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=websgbvts
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e.manifest
XP_MANIFEST_PATH=manifests\msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e.cat
XP_CATALOG_PATH=manifests\msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e.cat
XP_PAYLOAD_PATH=msil_websgbvts_no-public-key_12.4.56.0_x-ww_c3d02d1e
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=websgbvts,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\Tests\GeneralInfoWidgetTests.cs ===
using System;
using System.Threading;
using System.IO;
using System.Globalization;
using ServerTestFramework;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.GeneralInfo;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

namespace WebSGBVTs
{
	/// <summary>
	/// Summary description for GeneralInfoWidgetTests.
	/// </summary>
	[TestGroup]
	public class GeneralInfoWidgetTests : TestNode
	{
		[TestCase, Description("Verify that a title list can be received")]
		class GetTitleList : TestBase
		{
			protected override void Execute ()
			{
				// Pessimist!
				ResultCode = TEST_RESULTS.FAILED;

				// Connect to the GeneralInfo Widget throgh the WebSG
				WCGeneralInfo gi = new WCGeneralInfo (Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// Get the list of titles
				UInt32 uValidSeconds;
				TitlePrivilegeInfo [] tpi = gi.GetTitleList (out uValidSeconds);

				// Did we get something?
				if (tpi.Length < 1)
					throw new Exception ("Could not get any titles!");

				// Done
				ResultCode = TEST_RESULTS.PASSED;
			}
		}

        [TestCase, Description("Get the webId for a new user")]
        class GetLinkedUsers : TestBase
        {
            protected override void Execute()
            {
                // Pessimist!
                ResultCode = TEST_RESULTS.FAILED;

                //Create a user
                XeUser x = new XeUser();
                x.Create();

                // Connect to the GeneralInfo Widget throgh the WebSG
                WCGeneralInfo gi = new WCGeneralInfo(Global.XEnv.GetVirtualInterface(VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

                // Wait for the cache to pick it up.
                Thread.Sleep(30000);

                byte[] webID = BitConverter.GetBytes(x.PassportOwnerPuid);

                // Get the user Info
                LinkInfo[] li = gi.LinkedGamerTags(webID);

                // Did we get something?
                if (li.Length < 1)
                    throw new Exception("Could not get any Link Info!");

                // Is it the same user
                if (!li[0].GamerTag.Equals(x.Gamertag))
                    throw new Exception("Link User data didn't match user!");

                // Done
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\Tests\SignatureVerifyTests.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.SignatureWidget;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using xonline.common.config;

namespace WebSGBVTs
{
	[TestGroup]
	public class SignatureVerifyTests : TestNode
	{
		#region Helpers
		static bool GetXMLSigData(XSigVerifySignatureRequest[] SigData)
		{
			// Load the signatures from the XML file
			XmlDocument signatures = new XmlDocument();
			signatures.Load("VerifyWidget.xml");
			XmlNodeList sigs = signatures.SelectNodes("/stf/signatures/sig");
			if(sigs != null)
			{
				uint i = 0;
				foreach (XmlNode sig in sigs)
				{
					try
					{
						string name = sig.Attributes["name"].Value;
						if(name.StartsWith("digest"))
						{
							SigData[i/2]._digest = Hexer.unhex(sig.InnerText);
						}
						else if(name.StartsWith("signature"))
						{
							SigData[i/2]._signature = Hexer.unhex(sig.InnerText);
						}
						else
						{
							ConsoleX.WriteLine("Invalid signature element found in xml.");
							return false;
						}
					}
					catch (Exception)
					{
						ConsoleX.WriteLine("Invalid signature element found in xml.");
						return false;
					}
					i++;
				}
			}
				// Couldn't read any nodes in the XML file
			else
			{
				return false;
			}

			return true;
		}

		static bool VerifyHRArray(uint[] ResultArray, uint[] ExpectedArray, int count)
		{
			// The array's should match in size
			if(ResultArray.Length != ExpectedArray.Length)
				return false;

			// Check each service result,
			// return true only of all results are S_OK
			for(int i = 0; i < count; i++)
			{
				if(ResultArray[i] != ExpectedArray[i])
					return false;
			}
			return true;
		}
		#endregion

		[TestCase, Description("BasicVerifyWidget")]
		class BasicVerifyWidget : TestBase
		{
			protected override void Execute()
			{
				const int numSigs = 3;
				uint[] HRs = new uint[numSigs];
				uint[] ExpectedHRs = new uint[numSigs];
				ResultCode = TEST_RESULTS.PASSED;

				// Our sig data structure
				XSigVerifySignatureRequest[] SigData = new XSigVerifySignatureRequest[numSigs];
				for(uint i = 0; i < SigData.Length; i++)
				{
					SigData[i] = new XSigVerifySignatureRequest();
				}

				// This reads 3 pre-loaded signature/digest combinations that should
				// all succeed from an XML file.
				if(!GetXMLSigData(SigData))
					ResultCode = TEST_RESULTS.FAILED;

				// Create our widget reference
				WCSignature sw = new WCSignature(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				HRs = sw.VerifySignature(SigData);

				if(!VerifyHRArray(HRs, ExpectedHRs, SigData.Length))
					ResultCode = TEST_RESULTS.FAILED;
			}
		} // BasicVerifyWidget

	}
} // WebSGBVTs
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\Tests\StatsWidgetTest.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Xml;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Stats;
using ServerTestFramework.LiveService.Stats;
using xonline.common.config;

namespace WebSGBVTs
{
	[TestGroup]
	public class StatsWidgetTests : TestNode
	{
		#region StatsWidgetTest Initialization and Cleanup
		public override void PreRun ()
		{
			ConsoleX.Write("Connecting to SQL servers...");
			// open SQL connections
			try
			{
				/* Stats SQL no longer exists or up to date now that everything done in memory
				Helpers.statsSqlConn = new SqlConnection("Data Source="+Global.Env.StatsSQL.TextFront[1]+";Integrated Security =true;Initial Catalog=xstats");
				Helpers.statsSqlConn.Open();
				*/
				Helpers.npdbSqlConn = new SqlConnection("Data Source="+Global.XEnv.GetServerListByInterface(Interface.npdb)[0]+";Integrated Security =true;Initial Catalog=webdb");
				Helpers.npdbSqlConn.Open();
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine("Unable to connect to SQL: "+e.Message);
			}
			ConsoleX.WriteLine("done");

			ConsoleX.Write("Turning off caching for tests...");
			// turn off caching for functionals
			Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats DisableCache");
			//			string retVal;
			//			foreach (string StatsWidgetServer in Global.Env.StatsWebCacheServer.TextBack)
			//				ServerTestFramework.LiveService.ManagementConsole.Execute(StatsWidgetServer,"exec :wcstats DisableCache",out retVal);
			System.Threading.Thread.Sleep(500);
			ConsoleX.WriteLine("done");

			// create comp lb's
			for (int i=0; i<Helpers.CompLBIDs.Length; i++)
			{
				ConsoleX.WriteGuage("Creating competition LBs",i*100/Helpers.CompLBIDs.Length);
				int compTemplate = i%4 + 1 + (i/4)*10;
				try
				{
					ReqCompCreateLb CompCreateReq = new ReqCompCreateLb((uint)Helpers.titleIdTeamTests,(uint)compTemplate);
					RepCompCreateLb response = CompCreateReq.GetResponse();
					Helpers.CompLBIDs[i] = response._uiLbId;
					System.Threading.Thread.Sleep(400);
				}
				catch (Exception e)
				{
					ConsoleX.ClearLine();
					ConsoleX.WriteLine("Error creating competition LB with id "+compTemplate+": "+e.Message);
				}
			}
			ConsoleX.WriteGuage("Creating competition LBs",100);
			ConsoleX.WriteLine();

			// create team (if not exist already for 0xc3b0)
			ConsoleX.WriteGuage("Creating teams",0);
			WCTeams wcteams = new WCTeams();
			byte [] webid = BitConverter.GetBytes(Convert.ToUInt64(562949953420287));
			for (int i=0; i<5; i++)
			{
				ConsoleX.WriteGuage("Creating teams",i*20);
				try
				{
					wcteams.CreateTeam(Helpers.titleIdGetLBListTests,webid,"webuser0","webteam1000"+i.ToString(),8,"team for stats tests","motto","url",webid,webid);
				}
				catch (Exception e)
				{
					if (e.Message.ToLower().IndexOf("8015210a") == -1)
						ConsoleX.WriteLine("Error creating team: "+e.Message);
				}
			}
			ConsoleX.WriteGuage("Creating teams",100);
			ConsoleX.WriteLine();
			ConsoleX.WriteLine();
		}

		public override void PostRun ()
		{
			// close SQL connections
			/* Stats SQL no longer exists or up to date now that everything done in memory
			if (Helpers.statsSqlConn != null && Helpers.statsSqlConn.State != ConnectionState.Closed)
				Helpers.statsSqlConn.Close();
			*/
			if (Helpers.npdbSqlConn != null && Helpers.npdbSqlConn.State != ConnectionState.Closed)
				Helpers.npdbSqlConn.Close();

			// turn on caching
			Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats EnableCache");
			//			string retVal;
			//			foreach (string StatsWidgetServer in Global.Env.StatsWebCacheServer.TextBack)
			//				ServerTestFramework.LiveService.ManagementConsole.Execute(StatsWidgetServer,"exec :wcstats EnableCache",out retVal);
			System.Threading.Thread.Sleep(500);

			// delete comp leaderboards
			for (int i=0; i<Helpers.CompLBIDs.Length; i++)
			{
				if (Helpers.CompLBIDs[i] == 0)
					continue;
				ReqCompDeleteLb CompDelReq = new ReqCompDeleteLb((uint)Helpers.titleIdTeamTests,(uint)Helpers.CompLBIDs[i]);
				CompDelReq.GetResponse();
				System.Threading.Thread.Sleep(400);
			}
		}
		#endregion

		#region Common Code
		public class Helpers
		{
			public static bool logging = true;

			public static uint titleIdTeamTests = 0xb2d2;
			public static uint titleIdGetLBListTests = 0xc3b0;

			public static uint [] CompLBIDs = new uint[8];

			//		public static SqlConnection statsSqlConn = null;
			public static SqlConnection npdbSqlConn = null;

			public static bool VerifyDetailedResults(DetailedLBResults result, DetailedLBResults expected)
			{
				// no longer check reset date now that SQL access gone
				// if (result.LBLastResetDate.ToUniversalTime() < expected.LBLastResetDate ||
				if (result.TotalLBEntries != expected.TotalLBEntries ||
					result.Entries.Length != expected.Entries.Length)
					return false;
				for (int i=0; i<result.Entries.Length; i++)
				{
					if (result.Entries[i].G != expected.Entries[i].G ||
						result.Entries[i].R != expected.Entries[i].R ||
						result.Entries[i].F.Length != expected.Entries[i].F.Length)
						return false;
					for (int j=0; j<result.Entries[i].F.Length; j++)
					{
						if (result.Entries[i].F[j].ID != expected.Entries[i].F[j].ID ||
							result.Entries[i].F[j].V != expected.Entries[i].F[j].V)
							return false;
					}
				}
				return true;
			}

//			public static bool VerifyUnits(Unit [] results, Unit [] expected)
//			{
//				if (results.Length != expected.Length)
//					return false;
//				for (int i=0; i<results.Length; i++)
//				{
//					if (results[i].G.Length != expected[i].G.Length ||
//						results[i].F.Length != expected[i].F.Length)
//						return false;
//					string [] sortedG = new string[results[i].G.Length];
//					Array.Copy(results[i].G,0,sortedG,0,sortedG.Length);
//					Array.Sort(sortedG);
//					for (int j=0; j<results[i].G.Length; j++)
//					{
//						if (sortedG[j].CompareTo(expected[i].G[j]) != 0)
//							return false;
//					}
//					for (int j=0; j<results[i].F.Length; j++)
//					{
//						if (results[i].F[j].ID != expected[i].F[j].ID ||
//							results[i].F[j].V != expected[i].F[j].V)
//							return false;
//					}
//				}
//				return true;
//			}

			public static LBEntryAttribute [] GetLBAttributes(uint LBid, int rank /*0-based*/)
			{
				LBEntryAttribute [] F = null;

				if (LBid > 20 || LBid < 1)
				{
					// comp LB
					if (LBid == Helpers.CompLBIDs[4])
						LBid = 11;
					else if (LBid == Helpers.CompLBIDs[5])
						LBid = 12;
					else if (LBid == Helpers.CompLBIDs[6])
						LBid = 13;
					else if (LBid == Helpers.CompLBIDs[7])
						LBid = 14;
				}

				int nAttr = (int)(LBid % 10);
				if (nAttr > 4)
					nAttr -= 4;
				switch (nAttr)
				{
					case 1:	// 0 attributes
						F = new LBEntryAttribute[0];
						break;
					case 2:	// 1 attribute
						F = new LBEntryAttribute[1];
						F[0] = new LBEntryAttribute();
						F[0].ID = "65";
						F[0].V = Convert.ToString(rank+1);
						break;
					case 3:	// 32 attributes
						F = new LBEntryAttribute[32];
						for (int j=0; j<32; j++)
						{
							F[j] = new LBEntryAttribute();
							F[j].ID = Convert.ToString(65+j);
							F[j].V = Convert.ToString((j+1)*rank+1);
							if (3 == j)
								F[j].V = "gamerTag"+F[j].V;
							else if (13 == j)
								F[j].V = "team"+F[j].V;
						}
						break;
					case 4:	// 64 attributes
						F = new LBEntryAttribute[64];
						for (int j=0; j<64; j++)
						{
							F[j] = new LBEntryAttribute();
							F[j].ID = Convert.ToString(65+j);
							F[j].V = Convert.ToString((j+1)*rank+1);
							if (F[j].ID == "68")
								F[j].V = "gamerTag"+F[j].V;
							else if (F[j].ID == "78")
								F[j].V = "team"+F[j].V;
							else if (F[j].ID == "87")
								F[j].V = Convert.ToString(((j+1)*rank+1)+((j+2)*rank+1));
							else if (F[j].ID == "88")
								F[j].V = Convert.ToString((j*rank+1)-((j+1)*rank+1));
							else if (F[j].ID == "89")
								F[j].V = Convert.ToString(((j+1)*rank+1)*((j+2)*rank+1));
							else if (F[j].ID == "90")
								F[j].V = Convert.ToString((j*rank+1)/((j+1)*rank+1));
							else if (F[j].ID == "91")
								F[j].V = Convert.ToString((double)((j+1)*rank+1)+(double)((j+2)*rank+1));
							else if (F[j].ID == "92")
								F[j].V = Convert.ToString((double)(j*rank+1)-(double)((j+1)*rank+1));
							else if (F[j].ID == "93")
								F[j].V = Convert.ToString((double)((j+1)*rank+1)*(double)((j+2)*rank+1));
							else if (F[j].ID == "94")
								F[j].V = Convert.ToString((double)(j*rank+1)/(double)((j+1)*rank+1));
							else if (F[j].ID == "95")
								F[j].V = Convert.ToString(((ulong)((j+1)*rank+1) & 0x7FC) >> 2);
							else if (F[j].ID == "96")
								F[j].V = System.DateTime.FromFileTimeUtc((j+1)*rank+1).ToString(@"mm/dd/yy");
						}
						// change order of attributes
						LBEntryAttribute [] Fordered = new LBEntryAttribute[64];
						Array.Copy(F,35,Fordered,0,29);
						Array.Copy(F,0,Fordered,29,35);
						F = Fordered;
						break;
					default:
						ConsoleX.WriteLine("Unknown LBID in GetLBAttributes.");
						break;
				}
				return F;
			}

			public static DetailedLBResults GetDetailedLB(uint LBid, int nEntriesToReturn)
			{
				return GetDetailedLB(LBid,0,nEntriesToReturn);
			}

			public static DetailedLBResults GetDetailedLB(uint LBid, uint startPos, int nEntriesToReturn)
			{
				DetailedLBResults lbResults = new DetailedLBResults();
				lbResults.TotalLBEntries = 221;
				lbResults.Entries = new DetailedLBEntry[nEntriesToReturn];

				// fill Entries array
				if (nEntriesToReturn > 0)
				{
					lbResults.Entries = new DetailedLBEntry[nEntriesToReturn];
					for (uint i=0; i<nEntriesToReturn; i++)
					{
						lbResults.Entries[i] = new DetailedLBEntry();
						lbResults.Entries[i].G = "webteam"+Convert.ToString(i+startPos);
						lbResults.Entries[i].R = i+startPos+1;
						lbResults.Entries[i].F = GetLBAttributes(LBid,(int)(i+startPos));
					}
				}

				/* SQL server no longer kept up to date
				// make DB call to find out reset date
				string lb_id = null;
				if (LBid > 20 || LBid < 0)
				{
					// comp template
					if (LBid == Helpers.CompLBIDs[4])
						lb_id = "0x2C000000";
					else if (LBid == Helpers.CompLBIDs[5])
						lb_id = "0x30000000";
					else if (LBid == Helpers.CompLBIDs[6])
						lb_id = "0x34000000";
					else if (LBid == Helpers.CompLBIDs[7])
						lb_id = "0x38000000";
				}
				else
					lb_id = LBid.ToString();
				string sql = "Data Source="+Global.Env.NPDBSQL.TextDefault+";Integrated Security =true;Initial Catalog=webdb";
				SqlCommand mySqlCommand = null;
				SqlDataReader myDataReader = null;
				try
				{
					// create the SQL request
					string strCommand = "select dt_Change_datetime from t_leaderboard_info where i_title_id = "+titleIdTeamTests+" AND i_lb_id = "+lb_id;
					mySqlCommand = new SqlCommand(strCommand,Helpers.npdbSqlConn);

					// make the request
					myDataReader = mySqlCommand.ExecuteReader();

					// check the result
					if (myDataReader.Read() == false)
						throw new Exception();
					lbResults.LBLastResetDate = myDataReader.GetDateTime(0);
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine("Unable to get last reset date for LB: "+e.Message);
					lbResults.LBLastResetDate = DateTime.UtcNow.AddDays(-3);

					if (Helpers.npdbSqlConn.State != ConnectionState.Open)
						Helpers.npdbSqlConn.Open();
				}
				finally
				{
					if (myDataReader != null && !myDataReader.IsClosed)
					{
						myDataReader.Close();
						myDataReader = null;
					}
				}
				*/

				return lbResults;
			}

			public static LBInfo [] GetLBInfoFromXML(string typeVal, bool teamLB)
			{
				LBInfo [] lbInfo = null;

				XmlDocument parameters = new XmlDocument();
				parameters.Load(@"0000b2d2.xsc");
				XmlNode paramNode = null;
				XmlNodeList paramNodes = null, innerNodes = null;

				try
				{
					paramNodes = parameters.DocumentElement.SelectNodes("/Title/LeaderboardContainer");
					if (0 == paramNodes.Count)
						throw new Exception();
					for (int i=0; i<paramNodes.Count; i++)
					{
						if (paramNodes[i].Attributes["type"].Value.CompareTo(typeVal) == 0)
						{
							paramNode = paramNodes[i];
							break;
						}
					}

					if (null == paramNode)
						throw new Exception();

					// get list of leaderboards for given leaderboard type
					paramNodes = paramNode.ChildNodes;
					if (0 == paramNodes.Count)
						throw new Exception();
					lbInfo = new LBInfo[4];
					int lbIndex = -1;
					for (int i=0; i<paramNodes.Count; i++)
					{
						if (paramNodes[i].NodeType == XmlNodeType.Comment)
							continue;
						if (paramNodes[i].Name != "Leaderboard" &&
							paramNodes[i].Name != "LeaderboardTemplate")
							throw new Exception();
						string outerName = paramNodes[i].Name;
						// get LBID
						if (null == paramNodes[i].Attributes["ID"])
							throw new Exception();
						uint lbID = Convert.ToUInt32(paramNodes[i].Attributes["ID"].Value);
						if ((teamLB && lbID < 10) ||
							(!teamLB && lbID > 10)) //! is lbID==10 case correct?
							continue;		// ignore team/non-team leaderboards for whichever case specified
						lbIndex++;

						// look at each leaderboard setup individually
						parameters.LoadXml(paramNodes[i].OuterXml);

						lbInfo[lbIndex] = new LBInfo();
						// set LBID
						lbInfo[lbIndex].LBID = lbID;
						// set LB Name(s)
						innerNodes = parameters.SelectNodes("/"+outerName+"/Names/LocalizedName");
						if (0 == innerNodes.Count)
							throw new Exception();
						else
						{
							lbInfo[lbIndex].LocalizedLBName = new StatsLocalizedName[innerNodes.Count];
							for (int j=0; j<innerNodes.Count; j++)
							{
								lbInfo[lbIndex].LocalizedLBName[j] = new StatsLocalizedName();
								if (2 != innerNodes[j].ChildNodes.Count ||
									innerNodes[j].ChildNodes[0].Name != "Name" ||
									innerNodes[j].ChildNodes[1].Name != "Locale")
									throw new Exception();
								lbInfo[lbIndex].LocalizedLBName[j].DisplayName = innerNodes[j].ChildNodes[0].InnerText;
								lbInfo[lbIndex].LocalizedLBName[j].Locale = innerNodes[j].ChildNodes[1].InnerText;
							}
						}
						// get reset type
						if (null == parameters.SelectSingleNode("/"+outerName+"/Reset") ||
							"" == parameters.SelectSingleNode("/"+outerName+"/Reset").InnerText)
							lbInfo[lbIndex].ResetType = LBResetType.Never;
						else
							lbInfo[lbIndex].ResetType = (LBResetType)Convert.ToInt32(parameters.SelectSingleNode("/"+outerName+"/Reset").InnerText);
						// get attribute info
						XmlNodeList atts = parameters.SelectNodes("/"+outerName+"/FormattedValues/FormattedValue");
						if (0 == atts.Count)
							lbInfo[lbIndex].AttributeInfo = new LBAttributeInfo[0];
						else
						{
							lbInfo[lbIndex].AttributeInfo = new LBAttributeInfo[atts.Count];
							for (int j=0; j<atts.Count; j++)
							{
								lbInfo[lbIndex].AttributeInfo[j] = new LBAttributeInfo();
								// isolate attributes
								XmlDocument attribInfo = new XmlDocument();
								attribInfo.LoadXml(atts[j].OuterXml);

								// set attribute ID
								if (null == attribInfo.SelectSingleNode("/FormattedValue/NameID"))
									throw new Exception();
								lbInfo[lbIndex].AttributeInfo[j].ID = attribInfo.SelectSingleNode("/FormattedValue/NameID").InnerText;
								// set attribute names
								innerNodes = attribInfo.SelectNodes("/FormattedValue/Names/LocalizedName");
								if (0 == innerNodes.Count)
									lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName = null;
								else
								{
									lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName = new StatsLocalizedName[innerNodes.Count];
									for (int k=0; k<innerNodes.Count; k++)
									{
										lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName[k] = new StatsLocalizedName();
										if (2 != innerNodes[k].ChildNodes.Count ||
											innerNodes[k].ChildNodes[0].Name != "Name" ||
											innerNodes[k].ChildNodes[1].Name != "Locale")
											throw new Exception();
										lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName[k].DisplayName = innerNodes[k].ChildNodes[0].InnerText;
										lbInfo[lbIndex].AttributeInfo[j].LocalizedAttrName[k].Locale = innerNodes[k].ChildNodes[1].InnerText;
									}
								}
								// set attributeUnit
								if (null == attribInfo.SelectSingleNode("/FormattedValue/Type"))
									throw new Exception();
								if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Integer")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Integer;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Percent")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Percent;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Float")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Float;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Gamertag")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.GamerTag;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Timestamp")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.TimeStamp;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Millisecond")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.MilliSeconds;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "TenMillisecond")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.TenMilliSeconds;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "HundredMillisecond")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.HundredMilliSeconds;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Second")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Seconds;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Minute")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Minutes;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Hours")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Hours;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Days")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Days;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "String")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.String;
								else if (attribInfo.SelectSingleNode("/FormattedValue/Type").InnerText == "Team")
									lbInfo[lbIndex].AttributeInfo[j].Unit = AttributeUnit.Team;
							}
							if (lbInfo[lbIndex].AttributeInfo.Length == 64)
							{
								LBAttributeInfo [] Fordered = new LBAttributeInfo[64];
								Array.Copy(lbInfo[lbIndex].AttributeInfo,35,Fordered,0,29);
								Array.Copy(lbInfo[lbIndex].AttributeInfo,0,Fordered,29,35);
								lbInfo[lbIndex].AttributeInfo = Fordered;
							}
						}
					}
				}
				catch
				{
					ConsoleX.WriteLine("Invalid parameter element found in xml.");
					return null;
				}

				if (lbInfo[3] != null)
					return lbInfo;
				if (lbInfo[0] == null)
					return null;

				LBInfo [] retVal = null;
				if (lbInfo[1] == null)
					retVal = new LBInfo[1];
				else if (lbInfo[2] == null)
					retVal = new LBInfo[2];
				else
					retVal = new LBInfo[3];

				Array.Copy(lbInfo,0,retVal,0,retVal.Length);
				return retVal;
			}

			public static LBInfo [] SpecifyNumLBs(LBType type, int nLBs)
			{
				RemoveLeaderboards(titleIdGetLBListTests);

				LBInfo [] lbInfo = new LBInfo[nLBs];

				for (int i=0; i<nLBs; i++)
				{
					lbInfo[i] = new LBInfo();
					lbInfo[i].AttributeInfo = new LBAttributeInfo[0];
					lbInfo[i].LocalizedLBName = new StatsLocalizedName[2];
					lbInfo[i].LocalizedLBName[0] = new StatsLocalizedName();
					lbInfo[i].LocalizedLBName[0].Locale = "en-CA";
					lbInfo[i].LocalizedLBName[0].DisplayName = "temp LB "+Convert.ToString(20+i);
					lbInfo[i].LocalizedLBName[1] = new StatsLocalizedName();
					lbInfo[i].LocalizedLBName[1].Locale = "en-US";
					lbInfo[i].LocalizedLBName[1].DisplayName = "temp LB "+Convert.ToString(20+i);
					lbInfo[i].ResetType = LBResetType.Never;
					lbInfo[i].LBID = (uint)(20+i);
					if (!CreateLeaderboard(titleIdGetLBListTests, type, 20+i))
						return null;
				}

				Global.XEnv.ExecuteXmgmtCommand(Interface.wcstats,"exec :wcstats ReloadLeaderboards");
				//			string retVal;
				//			foreach (string StatsWidgetServer in Global.Env.StatsWebCacheServer.TextBack)
				//				ServerTestFramework.LiveService.ManagementConsole.Execute(StatsWidgetServer,"exec :wcstats ReloadLeaderboards",out retVal);
				System.Threading.Thread.Sleep(500);

				return lbInfo;
			}

			public static bool RemoveLeaderboards(uint titleId)
			{
				bool bRet = false;

				// remove from webdb
				try
				{
					// create the SQL request
					SqlCommand mySqlCommand = new SqlCommand("delete from t_leaderboard_name_info where i_title_id = "+titleId,Helpers.npdbSqlConn);
					mySqlCommand.ExecuteNonQuery();
					mySqlCommand = new SqlCommand("delete from t_leaderboard_info where i_title_id = "+titleId,Helpers.npdbSqlConn);
					mySqlCommand.ExecuteNonQuery();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine(e.Message);
					bRet = false;

					if (Helpers.npdbSqlConn.State != ConnectionState.Open)
						Helpers.npdbSqlConn.Open();
				}

				return bRet;
			}

			public static bool CreateLeaderboard(uint titleId, LBType type, int lbid)
			{
				bool bRet = true;

				// add LB to webdb
				try
				{
					// LB info
					SqlCommand mySqlCommand = new SqlCommand("p_webdb_tmr_insert_lb_info",Helpers.npdbSqlConn);
					mySqlCommand.CommandType = CommandType.StoredProcedure;
					SqlParameter result = new SqlParameter();
					result.Direction = ParameterDirection.ReturnValue;
					mySqlCommand.Parameters.Add(result);
					mySqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
					mySqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = lbid;
					mySqlCommand.Parameters.Add("@ti_reset_type", SqlDbType.TinyInt).Value = (int)LBResetType.Never;
					mySqlCommand.Parameters.Add("@i_lb_type", SqlDbType.Int).Value = (int)type;
					mySqlCommand.Parameters.Add("@i_entries_per_cache_line", SqlDbType.Int).Value = 50;
					mySqlCommand.Parameters.Add("@i_expiration_seconds", SqlDbType.Int).Value = 5;
					mySqlCommand.Parameters.Add("@ti_dont_list", SqlDbType.TinyInt).Value = 0;

					mySqlCommand.ExecuteNonQuery();

					// localized name #1
					mySqlCommand = new SqlCommand("p_webdb_tmr_insert_lb_name_info",Helpers.npdbSqlConn);
					mySqlCommand.CommandType = CommandType.StoredProcedure;
					result = new SqlParameter();
					result.Direction = ParameterDirection.ReturnValue;
					mySqlCommand.Parameters.Add(result);
					mySqlCommand.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
					mySqlCommand.Parameters.Add("@i_lb_id", SqlDbType.Int).Value = lbid;
					mySqlCommand.Parameters.Add("@vc_display_name", SqlDbType.VarChar).Value = "temp LB "+lbid;
					mySqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.VarChar).Value = "en-CA";

					mySqlCommand.ExecuteNonQuery();

					// localized name #2
					mySqlCommand.Parameters.RemoveAt(mySqlCommand.Parameters.Count-1);
					mySqlCommand.Parameters.Add("@vc_locale_id", SqlDbType.VarChar).Value = "en-US";

					mySqlCommand.ExecuteNonQuery();
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine(e.Message);
					bRet = false;

					if (Helpers.npdbSqlConn.State != ConnectionState.Open)
						Helpers.npdbSqlConn.Open();
				}

				return bRet;
			}

			public static void FillTeamDB (uint titleId, uint lbid, uint nAttr, ulong nToAdd)
			{
				// check to see if LB already filled with correct # entries
				WCStats wcstats = new WCStats(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				uint validsec;
				try
				{
					DetailedLBResults res = wcstats.EnumerateTeamLB(titleId,lbid,1,1,out validsec);
					if (res.TotalLBEntries == nToAdd)
						return;
				}
				catch (Exception)
				{
				}

				// reset leaderboards for title
				ServerTestFramework.LiveService.Stats.XRLResetUser ResetReq = new ServerTestFramework.LiveService.Stats.XRLResetUser(titleId,0,lbid);
				ResetReq.Execute();
				System.Threading.Thread.Sleep(400);

				ulong rating=110000;
				ulong basePUID = 0xFEFE00000000FFFF+((ulong)titleId<<16);
				ServerTestFramework.LiveService.Stats.XrlSubAttr[] stats;
				ServerTestFramework.LiveService.Stats.XRLSetRequest SetReq = null;

				if (nAttr >= 64)
				{
					for (ulong count=0; count<nToAdd; count+=2)
					{
						ulong nRec = 2;
						if (nToAdd-count < 2)
							nRec = nToAdd-count;
						SetReq = new ServerTestFramework.LiveService.Stats.XRLSetRequest(titleId,(uint)nRec*2);

						// set up request
						for (ulong i=0; i<nRec; i++)
						{
							stats = new ServerTestFramework.LiveService.Stats.XrlSubAttr[1];
							stats[0] = new ServerTestFramework.LiveService.Stats.XrlSubAttr(ServerTestFramework.LiveService.Stats.Util.SpecialAttrib.Rating,rating-10*(count+i));
							SetReq.AddSetData(lbid,basePUID-count-i,stats);
							// set up attributes
							stats = new ServerTestFramework.LiveService.Stats.XrlSubAttr[64];
							for (ushort j=0; j<64; j++)
							{
								if (nAttr == 64)
									stats[j] = new ServerTestFramework.LiveService.Stats.XrlSubAttr((ushort)(j+1),(uint)(1+(j+1)*(int)(count+i)));
								else
									stats[j] = new ServerTestFramework.LiveService.Stats.XrlSubAttr((ushort)(j+1),(uint)0);
							}

							// add to request
							SetReq.AddSetData(lbid,basePUID-count-i,stats);
						}
						ServerTestFramework.LiveService.Stats.XRLSetResponse response = SetReq.Execute();
						if(response.xResult != ServerTestFramework.LiveService.Stats.Util.XResult.S_OK)
						{
                            Global.RO.Info("Could not add to Team LB.");
						}
					}
				}
				else
				{
					for (ulong count=0; count<nToAdd; count+=4)
					{
						ulong nRec = 4;
						if (nToAdd-count < 4)
							nRec = nToAdd-count;
						SetReq = new ServerTestFramework.LiveService.Stats.XRLSetRequest(titleId,(uint)nRec);

						// set up request
						for (ulong i=0; i<nRec; i++)
						{
							// set up attributes
							stats = new ServerTestFramework.LiveService.Stats.XrlSubAttr[nAttr+1];
							stats[0] = new ServerTestFramework.LiveService.Stats.XrlSubAttr(ServerTestFramework.LiveService.Stats.Util.SpecialAttrib.Rating,rating-10*(count+i));
							for (ushort j=1; j<nAttr+1; j++)
							{
								stats[j] = new ServerTestFramework.LiveService.Stats.XrlSubAttr((ushort)j,(uint)(1+j*(int)(count+i)));
							}

							// add to request
							SetReq.AddSetData(lbid,basePUID-count-i,stats);
						}
						ServerTestFramework.LiveService.Stats.XRLSetResponse response = SetReq.Execute();
						if(response.xResult != ServerTestFramework.LiveService.Stats.Util.XResult.S_OK)
						{
                            Global.RO.Info("Could not add to Team LB.");
						}
					}
				}

				System.Threading.Thread.Sleep(200);

				// reset cache?
			}

			public static void CreateUnit(ulong basePUID, SqlCommand cmd, uint nAttr, ulong [] teamSuffix, ulong rating, double activity)
			{
				// set up users in unit
				Array.Sort(teamSuffix);		// put in sorted order (PUIDs is reversed later) so PUIDs will be in ascending order
				byte [] PUIDs = new byte[teamSuffix.Length*8];
				for (int j=0; j<teamSuffix.Length; j++)
					Array.Copy(BitConverter.GetBytes(basePUID-teamSuffix[j]),0,PUIDs,j*8,8);
				Array.Reverse(PUIDs);

				// set up attributes
				System.IO.MemoryStream ms = new System.IO.MemoryStream((int)nAttr * 11);
				System.IO.BinaryWriter bw = new System.IO.BinaryWriter(ms);
				for (ushort j=0; j<nAttr; j++)
				{
					bw.Write((ushort)(j+1));		// unit attrib ids MUST be 1 - 64
					bw.Write((ushort)1);
					bw.Write((long)(1+j*rating));
				}
				byte [] attribs = ms.ToArray();

				// make request
				cmd.Parameters.Add("@vb_players",SqlDbType.VarBinary).Value = PUIDs;
				cmd.Parameters.Add("@f_actdelta",SqlDbType.Float).Value = activity;
				cmd.Parameters.Add("@bi_rating1",SqlDbType.BigInt).Value = rating;
				cmd.Parameters.Add("@vb_attrib1",SqlDbType.VarBinary).Value = attribs;

				// Execute stored procedure
				cmd.ExecuteNonQuery();

				// remove params added in this method
				for (int i=0; i<4; i++)
					cmd.Parameters.RemoveAt(cmd.Parameters.Count-1);
			}

			public static void FillUnit (uint titleId, uint lbid, uint nAttr)
			{
				/* Stats SQL no longer exists or up to date now that everything done in memory

				SqlDataReader myDataReader = null;

				ulong rating=110000;
				double activity = 1000;

				try
				{
					// check unit LB contents to see if units already exist
					SqlCommand cmd = new SqlCommand("select count(*) from t_unitLbRow (nolock) where i_titleId = "+titleIdTeamTests+" and i_unitLbId = "+lbid, Helpers.statsSqlConn);
					myDataReader = cmd.ExecuteReader();
					if (myDataReader.Read() == false || myDataReader.GetInt32(0) == 126)
					{
						myDataReader.Close();
						return;
					}
					myDataReader.Close();

					// set up command
					cmd = new SqlCommand("p_Units_UpdateStats", Helpers.statsSqlConn);
					cmd.CommandType = CommandType.StoredProcedure;
					SqlParameter ret = new SqlParameter();
					ret.Direction = ParameterDirection.ReturnValue;
					cmd.Parameters.Add(ret);
					cmd.Parameters.Add("@i_titleId",SqlDbType.Int).Value = (int)titleId;
					cmd.Parameters.Add("@i_unitLbId1",SqlDbType.Int).Value = (int)lbid;

					ulong basePUID = 0xFEFE00000000FFFF+((ulong)titleId<<16);
					if (lbid < 10)
						basePUID = 0x0009FFFFFFFFFFFF;	// user LB, not team

					// one unit with webteam0
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {0,234,47},1200,6000);
					// five units with webteam31 (1st 2 with same 2 gamertags and length 3 and 4)
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {900,31,4},11000,1000);
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {31,4,790,500},10990,1500);
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {201,5,94,31},10980,2000);
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {31,25},10970,2500);
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {482,999,31},10960,3000);
					// 20 units with webteam789
					for (ulong i=0; i<20; i++)
						CreateUnit(basePUID,cmd,nAttr,new ulong[] {700+15*i,789},rating-30*i,activity+100*i);
					// 100 units with webteam200
					for (ulong i=0; i<100; i++)
						CreateUnit(basePUID,cmd,nAttr,new ulong[] {200,300+i*4,100+i},rating-5*i,activity+100*i);
				}
				catch (Exception e)
				{
					System.Console.WriteLine("Could not add to Unit LB: "+e.Message);

					if (Helpers.statsSqlConn.State != ConnectionState.Open)
						Helpers.statsSqlConn.Open();
				}
				finally
				{
					if (myDataReader != null && !myDataReader.IsClosed)
					{
						myDataReader.Close();
						myDataReader = null;
					}
				}
				*/
			}

			public static void FillDBForStress(uint lbid, int nAttr, ulong nToAdd, bool isTeam)
			{
				/* Stats SQL no longer exists, everything now in memory

				// check if DB already filled
				SqlDataReader myDataReader = null;
				try
				{
					object uid = null;

					SqlCommand cmd = new SqlCommand("select uid_leader_board_id from t_leader_board where i_title_id = 0xb2d2 and i_leader_board_type = "+lbid,Helpers.statsSqlConn);
					myDataReader = cmd.ExecuteReader();
					if (myDataReader.Read())
						uid = myDataReader.GetValue(0);
					myDataReader.Close();

					cmd = new SqlCommand("select count(*) from t_rating where uid_leader_board_id = '"+uid+"'", Helpers.statsSqlConn);
					myDataReader = cmd.ExecuteReader();
					if (myDataReader.Read())
						if (myDataReader.GetInt32(0) == (int)nToAdd)
							return;
				}
				catch (Exception)
				{
					if (Helpers.statsSqlConn.State != ConnectionState.Open)
						Helpers.statsSqlConn.Open();
				}
				finally
				{
					if (myDataReader != null && !myDataReader.IsClosed)
					{
						myDataReader.Close();
						myDataReader = null;
					}
				}
				*/

				// use Enumerate to see if leaderboard already filled with data (since can't make SQL calls)
				WCStats wcstats = new WCStats(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				uint validseconds;
				DetailedLBResults dLBresults;
				if (isTeam)
					dLBresults = wcstats.EnumerateTeamLB(0xb2d2,lbid,1,1,out validseconds);
				else
					dLBresults = wcstats.EnumerateLB(0xb2d2,lbid,1,1,out validseconds);
				if (dLBresults.TotalLBEntries == nToAdd)
					return;

				// reset leaderboard
				ServerTestFramework.LiveService.Stats.XRLResetUser ResetReq = new ServerTestFramework.LiveService.Stats.XRLResetUser(0xb2d2,0,lbid);
				System.Threading.Thread.Sleep(50);
				ResetReq.Execute();
				System.Threading.Thread.Sleep(400);

				ConsoleX.Write("Filling LB "+lbid+"...");

				System.Random rnd = new Random((int)DateTime.Now.ToFileTime());
				ulong basePUID = 0x0009FFFFFFFFFFFF;
				if (isTeam)
					basePUID = 0xFEFE0000B2D2FFFF;
				ServerTestFramework.LiveService.Stats.XrlSubAttr[] stats;
				ServerTestFramework.LiveService.Stats.XRLSetRequest SetReq = null;

				if (nAttr == 64)
				{
					for (ulong count=0; count<nToAdd; count+=2)
					{
						ulong nRec = 2;
						if (nToAdd-count < 2)
							nRec = nToAdd-count;
						SetReq = new ServerTestFramework.LiveService.Stats.XRLSetRequest(0xb2d2,(uint)nRec*2);

						// set up request
						for (ulong i=0; i<nRec; i++)
						{
							stats = new ServerTestFramework.LiveService.Stats.XrlSubAttr[1];
							stats[0] = new ServerTestFramework.LiveService.Stats.XrlSubAttr(ServerTestFramework.LiveService.Stats.Util.SpecialAttrib.Rating,(ulong)rnd.Next(5000,11000));
							SetReq.AddSetData(lbid,basePUID-count-i,stats);
							// set up attributes
							stats = new ServerTestFramework.LiveService.Stats.XrlSubAttr[nAttr];
							for (ushort j=0; j<nAttr; j++)
							{
								stats[j] = new ServerTestFramework.LiveService.Stats.XrlSubAttr((ushort)(j+1),(uint)rnd.Next(500,50000));
							}

							// add to request
							SetReq.AddSetData(lbid,basePUID-count-i,stats);
						}
						ServerTestFramework.LiveService.Stats.XRLSetResponse response = SetReq.Execute();
						if(response.xResult != ServerTestFramework.LiveService.Stats.Util.XResult.S_OK)
						{
                            Global.RO.Info("Could not add to Stress LB.");
						}
					}
				}
				else
				{
					for (ulong count=0; count<nToAdd; count+=4)
					{
						ulong nRec = 4;
						if (nToAdd-count < 4)
							nRec = nToAdd-count;
						SetReq = new ServerTestFramework.LiveService.Stats.XRLSetRequest(0xb2d2,(uint)nRec);

						// set up request
						for (ulong i=0; i<nRec; i++)
						{
							// set up attributes
							stats = new ServerTestFramework.LiveService.Stats.XrlSubAttr[nAttr+1];
							stats[0] = new ServerTestFramework.LiveService.Stats.XrlSubAttr(ServerTestFramework.LiveService.Stats.Util.SpecialAttrib.Rating,(ulong)rnd.Next(5000,11000));
							for (ushort j=1; j<nAttr+1; j++)
							{
								stats[j] = new ServerTestFramework.LiveService.Stats.XrlSubAttr(j,(uint)rnd.Next(500,50000));
							}

							// add to request
							SetReq.AddSetData(lbid,basePUID-count-i,stats);
						}
						ServerTestFramework.LiveService.Stats.XRLSetResponse response = SetReq.Execute();
						if(response.xResult != ServerTestFramework.LiveService.Stats.Util.XResult.S_OK)
						{
                            Global.RO.Info("Could not add to Stress LB.");
						}
					}
				}
				ConsoleX.WriteLine("done");
			}

			public static void FillUnitForStress (uint lbid, uint nAttr, bool isTeam)
			{
				/* Stats SQL no longer exists or up to date now that everything done in memory

				// check if DB already filled
				SqlCommand cmd;
				SqlDataReader myDataReader = null;
				try
				{
					cmd = new SqlCommand("select count(*) from t_unitLbRow where i_titleId = 0xb2d2 and i_unitLbId = "+lbid, Helpers.statsSqlConn);
					myDataReader = cmd.ExecuteReader();
					if (myDataReader.Read())
						if (myDataReader.GetInt32(0) >= 9196)
							return;
				}
				catch (Exception)
				{
					if (Helpers.statsSqlConn.State != ConnectionState.Open)
						Helpers.statsSqlConn.Open();
				}
				finally
				{
					if (myDataReader != null && !myDataReader.IsClosed)
					{
						myDataReader.Close();
						myDataReader = null;
					}
				}

				ConsoleX.Write("Filling Unit LB "+lbid+"...");

				System.Random rnd = new Random((int)DateTime.Now.ToFileTime());

				// set up command
				cmd = new SqlCommand("p_Units_UpdateStats", Helpers.statsSqlConn);
				cmd.CommandType = CommandType.StoredProcedure;
				SqlParameter ret = new SqlParameter();
				ret.Direction = ParameterDirection.ReturnValue;
				cmd.Parameters.Add(ret);
				cmd.Parameters.Add("@i_titleId",SqlDbType.Int).Value = (int)(0xb2d2);
				cmd.Parameters.Add("@i_unitLbId1",SqlDbType.Int).Value = (int)lbid;


				ulong basePUID = 0x0009FFFFFFFFFFFF;
				if (isTeam)
					basePUID = 0xFEFE0000B2D2FFFF;

				// create 2-member units
				for (ulong i=0; i<1023; i++)
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {i,i+1},(ulong)rnd.Next(500,50000),(double)rnd.Next(5000,10000));
				// create 3-member units
				for (ulong i=0; i<1022; i++)
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {i,i+1,i+2},(ulong)rnd.Next(500,50000),(double)rnd.Next(5000,10000));
				// create 4-member units
				for (ulong i=0; i<1021; i++)
					CreateUnit(basePUID,cmd,nAttr,new ulong[] {i,i+1,i+2,i+3},(ulong)rnd.Next(500,50000),(double)rnd.Next(5000,10000));

				ConsoleX.WriteLine("done");
			*/
			}
		}
		#endregion

		#region EnumerateTeamLB Helpers
		public static bool EnumerateTeamLB_VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailedResults(results,expected);
		}

		public static bool EnumerateTeamLB_RunPositiveTest(uint LBid,uint maxEntries,DetailedLBResults expected)
		{
			return EnumerateTeamLB_RunPositiveTest(LBid,1,maxEntries,expected,221);
		}

		public static bool EnumerateTeamLB_RunPositiveTest(uint LBid,uint maxEntries,DetailedLBResults expected,uint nEntriesInDB)
		{
			return EnumerateTeamLB_RunPositiveTest(LBid,1,maxEntries,expected,nEntriesInDB);
		}

		public static bool EnumerateTeamLB_RunPositiveTest(uint LBid,uint startIndex,uint maxEntries,DetailedLBResults expected,uint nEntriesInDB)
		{
			// set up correct # entries for given LB
			uint nAttr = 0;
			if (LBid > 20)
			{
				// comp LB
				if (LBid == Helpers.CompLBIDs[4])
					nAttr = 0;
				else if (LBid == Helpers.CompLBIDs[5])
					nAttr = 1;
				else if (LBid == Helpers.CompLBIDs[6])
					nAttr = 32;
				else if (LBid == Helpers.CompLBIDs[7])
					nAttr = 64;
			}
			else
			{
				nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
			}
			Helpers.FillTeamDB(Helpers.titleIdTeamTests,LBid,nAttr,nEntriesInDB);

			// correct the expected # entries in DB
			expected.TotalLBEntries = nEntriesInDB;

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
			try
			{
				DetailedLBResults dLBResults = stats.EnumerateTeamLB(Helpers.titleIdTeamTests,LBid,startIndex,maxEntries,out ValidSeconds);

				if (!EnumerateTeamLB_VerifyPositive(dLBResults,expected))
					return false;
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				return false;
			}

			return true;
		}


		#endregion

		#region EnumerateTeamLB Tests
		[TestCase, Description("EnumerateTeamLB Valid: Regular-Team with 1 attrib")]
		class EnumerateTeamLB_Valid_RegularTeam_1Attrib : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetDetailedLB(12,20);

				if (EnumerateTeamLB_RunPositiveTest(12,20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		} // EnumerateTeamLBValid_RegularTeam_1Attrib

		[TestCase, Ignore, Description("EnumerateTeamLB Valid: Competition-Team with 1 attrib")]
		class EnumerateTeamLB_Valid_CompTeam_1Attrib : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetDetailedLB(Helpers.CompLBIDs[5],20);

				if (EnumerateTeamLB_RunPositiveTest(Helpers.CompLBIDs[5],20,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		#endregion

		#region GetLBListByType Helpers
		public static bool GetLBListByType_VerifyPositive(LBInfo [] result, LBInfo [] expected)
		{
			if (result.Length != expected.Length)
				return false;

			for (int i=0; i<result.Length; i++)
			{
				int expIndex = 0;
				while (expIndex < expected.Length && result[i].LBID != expected[expIndex].LBID)
					expIndex++;
				if (expIndex == expected.Length)
					return false;

				if (result[i].ResetType != expected[expIndex].ResetType ||
					result[i].LocalizedLBName.Length != expected[expIndex].LocalizedLBName.Length ||
					result[i].AttributeInfo.Length != expected[expIndex].AttributeInfo.Length)
					return false;
				for (int j=0; j<result[i].LocalizedLBName.Length; j++)
					if (result[i].LocalizedLBName[j].DisplayName.CompareTo(expected[expIndex].LocalizedLBName[j].DisplayName) != 0 ||
						result[i].LocalizedLBName[j].Locale.CompareTo(expected[expIndex].LocalizedLBName[j].Locale) != 0)
						return false;
				for (int j=0; j<result[i].AttributeInfo.Length; j++)
				{
					if (result[i].AttributeInfo[j].ID.CompareTo(expected[expIndex].AttributeInfo[j].ID) != 0 ||
						result[i].AttributeInfo[j].Unit != expected[expIndex].AttributeInfo[j].Unit ||
						result[i].AttributeInfo[j].LocalizedAttrName.Length != expected[expIndex].AttributeInfo[j].LocalizedAttrName.Length)
						return false;

					for (int k=0; k<result[i].AttributeInfo[j].LocalizedAttrName.Length; k++)
						if (result[i].AttributeInfo[j].LocalizedAttrName[k].DisplayName.CompareTo(expected[expIndex].AttributeInfo[j].LocalizedAttrName[k].DisplayName) != 0 ||
							result[i].AttributeInfo[j].LocalizedAttrName[k].Locale.CompareTo(expected[expIndex].AttributeInfo[j].LocalizedAttrName[k].Locale) != 0)
							return false;
				}
			}

			return true;
		}

		public static bool GetLBListByType_RunPositiveTest(uint titleId, LBType type, LBInfo [] expected)
		{
			uint ValidSeconds;
			WCStats stats = new WCStats(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
			try
			{
				LBInfo [] info = stats.GetLBListByType(titleId,type,out ValidSeconds);
				if (!GetLBListByType_VerifyPositive(info,expected))
					return false;
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				return false;
			}

			return true;
		}

		#endregion

		#region GetLBListByType Tests
		[TestCase, Description("GetLBListByType Valid: basic verification Regular type LB")]
		class GetLBListByType_ValidRegular : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("individual",false);

				if (GetLBListByType_RunPositiveTest(Helpers.titleIdTeamTests,LBType.Regular,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		} // GetLBListByType_ValidRegular

		[TestCase, Ignore, Description("GetLBListByType Valid: basic verification Competition type LB")]
		class GetLBListByType_ValidCompetition : TestBase
		{
			protected override void Execute()
			{
				LBInfo [] expectedResult = Helpers.GetLBInfoFromXML("competitions",false);

				foreach (LBInfo exp in expectedResult)
				{
					if (exp.LBID == 1)
						exp.LBID = 0x04000000;
					else if (exp.LBID == 2)
						exp.LBID = 0x08000000;
					else if (exp.LBID == 3)
						exp.LBID = 0x0C000000;
					else if (exp.LBID == 4)
						exp.LBID = 0x10000000;
				}

				if (GetLBListByType_RunPositiveTest(Helpers.titleIdTeamTests,LBType.CompetitionTemplate,expectedResult))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			} // GetLBListByType_ValidCompetition
		}

		#endregion

		#region GetTeamLBDetailsForTeamNames Helpers
		public static bool GetTeamLBDetailsForTeamNames_VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailedResults(results,expected);
		}

		public static bool GetTeamLBDetailsForTeamNames_RunPositiveTest(uint LBid,string [] teams,DetailedLBResults expected)
		{
			// set up correct # entries for given LB
			uint nAttr = 0;
			if (LBid > 20)
			{
				// comp LB
				if (LBid == Helpers.CompLBIDs[4])
					nAttr = 0;
				else if (LBid == Helpers.CompLBIDs[5])
					nAttr = 1;
				else if (LBid == Helpers.CompLBIDs[6])
					nAttr = 32;
				else if (LBid == Helpers.CompLBIDs[7])
					nAttr = 64;
			}
			else
			{
				nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
			}
			Helpers.FillTeamDB(Helpers.titleIdTeamTests,LBid,nAttr,221);

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
			try
			{
				DetailedLBResults dLBResults = stats.GetTeamLBDetailsForTeamNames(Helpers.titleIdTeamTests,LBid,teams,out ValidSeconds);

				if (!GetTeamLBDetailsForTeamNames_VerifyPositive(dLBResults,expected))
					return false;
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				return false;
			}

			return true;
		}

		public static DetailedLBResults GetTeamLBDetailsForTeamNames_GetDetailedLBResults(uint LBid,int [] teams)
		{
			DetailedLBResults dLBResults = Helpers.GetDetailedLB(LBid,0);
			if (teams.Length == 0)
				return dLBResults;

			// now update Entries array to include all teams
			int nResults = 0;
			for (int i=0; i<teams.Length; i++)
				if (teams[i] <= 220)
					nResults++;
			dLBResults.Entries = new DetailedLBEntry[nResults];
			int index = 0;
			foreach (int team in teams)
			{
				if (team > 220)
					continue;
				dLBResults.Entries[index] = new DetailedLBEntry();
				dLBResults.Entries[index].G = "webteam"+team;
				dLBResults.Entries[index].R = (uint)team+1;
				dLBResults.Entries[index].F = Helpers.GetLBAttributes(LBid,team);
				index++;
			}

			return dLBResults;
		}

		#endregion

		#region GetTeamLBDetailsForTeamNames Tests
		[TestCase, Description("GetTeamLBDetailsForTeamNames Valid: Regular-team LB with 1 attribute")]
		class GetTeamLBDetailsForTeamNames_ValidRegularTeam1Attrib : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetTeamLBDetailsForTeamNames_GetDetailedLBResults(12,new int[] {5,47,0,200,220});

				if (GetTeamLBDetailsForTeamNames_RunPositiveTest(12,new string[] {"webteam5","webteam47","webteam0","webteam200","webteam220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetTeamLBDetailsForTeamNames Valid: Competition-team LB with 1 attribute")]
		class GetTeamLBDetailsForTeamNames_ValidCompTeam1Attrib : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = GetTeamLBDetailsForTeamNames_GetDetailedLBResults(Helpers.CompLBIDs[5],new int[] {5,47,0,200,220});

				if (GetTeamLBDetailsForTeamNames_RunPositiveTest(Helpers.CompLBIDs[5],new string[] {"webteam5","webteam47","webteam0","webteam200","webteam220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		#endregion

		#region GetTeamLBForTeamNames Helpers
			public static bool GetTeamLBForTeamNames_VerifyPositive(LBResults result, LBResults expected)
			{
				// no longer check reset date now that SQL access gone
				// if (result.LBLastResetDate == expected.LBLastResetDate ||
				if (result.TotalLBEntries != expected.TotalLBEntries ||
					result.Entries.Length != expected.Entries.Length)
					return false;
				for (int i=0; i<result.Entries.Length; i++)
				{
					if (result.Entries[i].G != expected.Entries[i].G ||
						result.Entries[i].R != expected.Entries[i].R)
						return false;
				}
				return true;
			}

			public static bool GetTeamLBForTeamNames_RunPositiveTest(uint LBid,string [] teams,LBResults expected)
			{
				return GetTeamLBForTeamNames_RunPositiveTest(Helpers.titleIdTeamTests,LBid,teams,expected);
			}

			public static bool GetTeamLBForTeamNames_RunPositiveTest(uint titleId,uint LBid,string [] teams,LBResults expected)
			{
				// set up correct # entries for given LB
				uint nAttr = 0;
				if (LBid > 20)
				{
					// comp LB
					if (LBid == Helpers.CompLBIDs[4])
						nAttr = 0;
					else if (LBid == Helpers.CompLBIDs[5])
						nAttr = 1;
					else if (LBid == Helpers.CompLBIDs[6])
						nAttr = 32;
					else if (LBid == Helpers.CompLBIDs[7])
						nAttr = 64;
				}
				else
				{
					nAttr = (LBid % 10) - 1;
					if (nAttr > 4)
						nAttr -= 4;
					if (nAttr > 1)
						nAttr = 32 * (nAttr - 1);
				}
				Helpers.FillTeamDB(Helpers.titleIdTeamTests,LBid,nAttr,221);

				// make request
				uint ValidSeconds;
				WCStats stats = new WCStats(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				try
				{
					LBResults lbResults = stats.GetTeamLBForTeamNames(titleId,LBid,teams,out ValidSeconds);

					if (!GetTeamLBForTeamNames_VerifyPositive(lbResults,expected))
						return false;
				}
				catch (Exception e)
				{
					ConsoleX.WriteLine(e.Message);
					return false;
				}

				return true;
			}

			public static LBResults GetTeamLBForTeamNames_GetLBResults(uint LBid,int [] teams)
			{
				DetailedLBResults dLBResults = Helpers.GetDetailedLB(LBid,0);
				LBResults lbResults = new LBResults();
				lbResults.TotalLBEntries = dLBResults.TotalLBEntries;
				//			lbResults.LBLastResetDate = dLBResults.LBLastResetDate;

				// now update Entries array to include all teams
				int nResults = 0;
				for (int i=0; i<teams.Length; i++)
					if (teams[i] <= 220)
						nResults++;
				lbResults.Entries = new LBEntry[nResults];
				int index = 0;
				foreach (int team in teams)
				{
					if (team > 220)
						continue;
					lbResults.Entries[index] = new LBEntry();
					lbResults.Entries[index].G = "webteam"+team;
					lbResults.Entries[index].R = (uint)team+1;
					index++;
				}

				return lbResults;
			}

			#endregion

		#region GetTeamLBForTeamNames Tests

		[TestCase, Description("GetTeamLBForTeamNames Valid: basic verification Regular-team LB")]
		class GetTeamLBForTeamNames_ValidRegularTeam : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetTeamLBForTeamNames_GetLBResults(12,new int[] {5,47,0,200,220});

				if (GetTeamLBForTeamNames_RunPositiveTest(12,new string[] {"webteam5","webteam47","webteam0","webteam200","webteam220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}

		[TestCase, Ignore, Description("GetTeamLBForTeamNames Valid: basic verification Competition-team LB")]
		class GetTeamLBForTeamNames_ValidCompTeam : TestBase
		{
			protected override void Execute()
			{
				LBResults expected = GetTeamLBForTeamNames_GetLBResults(Helpers.CompLBIDs[5],new int[] {5,47,0,200,220});

				if (GetTeamLBForTeamNames_RunPositiveTest(Helpers.CompLBIDs[5],new string[] {"webteam5","webteam47","webteam0","webteam200","webteam220"},expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		}
		#endregion

		#region GetTeamLBNearTeamName Helpers
		public static bool GetTeamLBNearTeamName_VerifyPositive(DetailedLBResults results, DetailedLBResults expected)
		{
			return Helpers.VerifyDetailedResults(results,expected);
		}

		public static bool GetTeamLBNearTeamName_RunPositiveTest(uint LBid,string team,uint nAbove,uint nBelow, DetailedLBResults expected)
		{
			// set up correct # entries for given LB
			uint nAttr = 0;
			if (LBid > 20)
			{
				// comp LB
				if (LBid == Helpers.CompLBIDs[4])
					nAttr = 0;
				else if (LBid == Helpers.CompLBIDs[5])
					nAttr = 1;
				else if (LBid == Helpers.CompLBIDs[6])
					nAttr = 32;
				else if (LBid == Helpers.CompLBIDs[7])
					nAttr = 64;
			}
			else
			{
				nAttr = (LBid % 10) - 1;
				if (nAttr > 4)
					nAttr -= 4;
				if (nAttr > 1)
					nAttr = 32 * (nAttr - 1);
			}
			Helpers.FillTeamDB(Helpers.titleIdTeamTests,LBid,nAttr,221);

			// make request
			uint ValidSeconds;
			WCStats stats = new WCStats(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
			try
			{
				DetailedLBResults dLBResults = stats.GetTeamLBNearTeamName(Helpers.titleIdTeamTests,LBid,team,nAbove,nBelow,out ValidSeconds);

				if (!GetTeamLBNearTeamName_VerifyPositive(dLBResults,expected))
					return false;
			}
			catch (Exception e)
			{
				ConsoleX.WriteLine(e.Message);
				return false;
			}

			return true;
		}

		#endregion

		#region GetTeamLBNearTeamName Tests
		[TestCase, Description("GetTeamLBNearTeamName Valid: basic verification Regular 1 attrib")]
		class GetTeamLBNearTeamName_ValidRegular1Attribute : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetDetailedLB(12,20,21);

				if (GetTeamLBNearTeamName_RunPositiveTest(12,"webteam30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		} // GetTeamLBNearTeamName_ValidRegular1Attribute

		[TestCase, Ignore, Description("GetTeamLBNearTeamName Valid: basic verification Competition 1 attrib")]
		public class GetTeamLBNearTeamName_ValidComp1Attribute : TestBase
		{
			protected override void Execute()
			{
				DetailedLBResults expected = Helpers.GetDetailedLB(Helpers.CompLBIDs[5],20,21);

				if (GetTeamLBNearTeamName_RunPositiveTest(Helpers.CompLBIDs[5],"webteam30",10,10,expected))
					ResultCode = TEST_RESULTS.PASSED;
				else
					ResultCode = TEST_RESULTS.FAILED;
			}
		} // GetTeamLBNearTeamName_ValidComp1Attribute
		#endregion

	} // StatsWidgetTests

} // namespace WebSGBVTs
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\Tests\MessagingWidgetTests.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using ServerTestFramework.WebWidget;
using ServerTestFramework.Web.Messaging;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.config;

namespace WebSGBVTs
{
	#region MessagingWidget Helpers
	public class MWGlobal
	{
		// Globally visible user lists
		static public PuidName[]	Users;
		static public int  UserMax = 10;

		static public System.Collections.Hashtable MessageList = new System.Collections.Hashtable();

		static public System.Collections.Queue RevokeList = new System.Collections.Queue();

		static public CPUIDList StressUsers;

		MWGlobal()
		{
		}
	}
	#endregion

	/// <summary>
	/// Summary description for MessagingWidgetTests.
	/// </summary>
	[TestGroup]
	public class MessagingWidgetTests : TestNode
	{
		#region MessagingWidget Initialization and Cleanup
		public override void PreRun ()
		{
			MWGlobal.Users = new PuidName[MWGlobal.UserMax];
			UacsCommon ua=new UacsCommon();

			MWGlobal.MessageList.Clear();

			for(int i = 0; i < MWGlobal.UserMax; i++)
			{
				//Owner o = ua.GenerateOwner();
				Owner o = new Owner("MW" + ua.Random.GenerateRandomNameString(10));
				ulong puid = ua.CreateUser(o);

				WCUserAccount wua = new WCUserAccount(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				byte []webPuid = ua.GenerateWebId(puid);

				if (! (wua.LinkUser(webPuid, true, o)) )
				{
					ConsoleX.WriteLine("Could not link gamertag???");
				}
				else
				{
					MWGlobal.Users[i] = new PuidName(puid, o.gamertag, webPuid);
					//ConsoleX.WriteLine("Linked user " + MWGlobal.Users[i].ToString() );
					Global.RO.Info("MWGlobal.Users[{2}] = new PuidName({0},\"{1}\", ua.GenerateWebId({0}));", puid, o.gamertag, i);
				}

				new SleepInfo("Wait for cache", 5500);	// allow time for link cache to happen
            }

            new SleepInfo("Wait for cache final", 5500);	// allow time for link cache to happen
		}
		#endregion

		[TestCase, Description("Send Test Data Messages")]
		class SendTestData : TestBase
		{
            protected uint totalMessagesSent = 0;
            protected uint[] senderIndeces = { 0, 6, 7, 8, 9, 2 };

			protected uint SendTestMessage(string reciptag, string msgidentifier)
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				string[] recipients = new string[ 1 ];
				recipients[ 0 ] = reciptag;

                // Prevent message throttling from giving us a hard time
                uint senderIndex = senderIndeces[totalMessagesSent / 250];
                ++totalMessagesSent;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				WCRecipientResult[] results = null;

				UInt32 hr = service.SendMessage(
                    MWGlobal.Users[senderIndex].WebId,	   // Sender
                    MWGlobal.Users[senderIndex].GamerTag,
					0,                             // SenderContext
					WCMessageFlags.TitleReserved0, // MessageFlags
					400001,                        // SenderTitleID
					60,								// Expire Minutes
					WCMessageType.TitleCustom,		// WCMessageType
					recipients,                    // Recipient IDs
					null,	                     // Details
					//null,							// Strings
					null,							// Attachments
					out results );

				if( HResult.Failed(hr) )
				{
					Global.RO.Info("Failed SendMessage({0}, {1}), call returned HResult: {2:X}", reciptag, 
                        msgidentifier, hr);
					ResultCode = TEST_RESULTS.FAILED;
					return hr;
				}

				if ( (results != null) && (results.Length > 0) )
				{
					if( HResult.Failed(results[0].MessageID ) )
                    {
                        Global.RO.Info("Failed SendMessage({0}, {1}), call returned HResult: {2:X}, " + 
                            "result[0].MessageID: ", reciptag, msgidentifier, hr, results[0].MessageID);
						ResultCode = TEST_RESULTS.FAILED;
					}
					else
					{
						MWGlobal.MessageList.Add(msgidentifier, results[0].MessageID);
					}

					return results[0].MessageID;
				}
				else
				{
                    Global.RO.Warn("SendMessage succeed to pass but no results were returned.");
					ResultCode = TEST_RESULTS.FAILED;
					return 0x80000000;
				}

			}

			protected override void Execute()
			{
                totalMessagesSent = 0;
				ResultCode = TEST_RESULTS.PASSED;

				// Send 101 messages to User3 for max enum and queue check
				// TODO: this takes 20-30 secs...  something we can do here?

				for(int i = 0; i < 101; i++)
				{
					SendTestMessage(MWGlobal.Users[3].GamerTag, "maxtest" + i.ToString());
				}

				// Send basic msg for user1
				SendTestMessage(MWGlobal.Users[1].GamerTag, "BasicMessage");

				// Send msg for User5 for Revoke tests
				SendTestMessage(MWGlobal.Users[5].GamerTag, "RevokeMsg");


				// Send msg for User4 for Delete tests
				SendTestMessage(MWGlobal.Users[4].GamerTag, "DeleteMsg");

			}
		}
		[TestCase, Description("BasicSendSystemMessage")]
			class BasicSendTitleMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				WCMessageDetails smDetails = new WCMessageDetails();
				// TODO: Add some details

				WCLocalizedString[] strings = new WCLocalizedString[ 1 ];
				strings[ 0 ] = new WCLocalizedString();
				// TODO: Add some strings

				WCMessageAttachment[] attachments = new WCMessageAttachment[ 1 ];
				attachments[ 0 ] = new WCMessageAttachment();
				// TODO: Add some attachments

				uint MessageID = 0;
				ushort delay = 0;

				UInt32 hr = service.SendTitleWideMessage(
					"TestCase",
					0,
					System.DateTime.UtcNow,
					0,
					WCMessageFlags.TitleReserved1,	// MessageFlags
					400001,							// Sender TitleID
					60,
					WCMessageType.TitleCustom,
					"Some TEST Message",
					smDetails,
					null,
					null,
					out delay,
					out MessageID
					);

				if( HResult.Failed( hr ) )
				{
					Console.WriteLine("Failed SendSystemMessage, HResult: " + hr);
					return;
				}

				MWGlobal.MessageList.Add("SysMsgBasic", MessageID);

				ConsoleX.WriteLine("Created system messageID: " + MessageID);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("BasicGetDetails")]
			class BasicGetDetails : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				WCTitleWideMessageSummary summary = null;
				WCMessageDetails details = null;

				// pull this from Send test
				uint MessageID  = (uint) MWGlobal.MessageList["SysMsgBasic"];

				UInt32 hr = service.GetTitleWideMessageDetails(
					400001,
					MessageID,
					out summary,
					out details
					);

				if( HResult.Failed( hr ) )
				{
					Console.WriteLine("GetMessageDetails failed, HResult: " + hr );
					return;
				}

				if ( summary != null )
				{

					Console.WriteLine( "    Summary:" );
					Console.WriteLine( "        szSenderName - {0}",    summary.SenderName );
					Console.WriteLine( "	    Description - {0}",		summary.Description );
					Console.WriteLine( "        dwTitleID - {0}",		summary.TitleID );
					Console.WriteLine( "        qwSenderContext - {0}", summary.SenderContext );
					Console.WriteLine( "        mtSentTime - {0}",      summary.SentTime );
					Console.WriteLine( "        dwMessageID - {0}",     summary.MessageID );
					Console.WriteLine( "        dwMessageFlags - {0}",  summary.MessageFlags );
					Console.WriteLine( "        bMessageType - {0}",    summary.MessageType );
					Console.WriteLine( "        wExpireMinutes - {0}",  summary.ExpireMinutes );
					Console.WriteLine( "        cbDetails - {0}",       summary.DetailsSize );
				}

				if ( details != null )
				{
					if (details.NullProp != null)
					{
						Console.WriteLine("Nullprop count: " + details.NullProp.Length);
					}

					if (details.ByteProp != null)
						foreach ( WCByteProp byteprop in details.ByteProp )
						{
							Console.WriteLine("ByteProp: " + byteprop.Value );
						}

					if (details.WordProp != null)
						foreach ( WCWordProp wordprop in details.WordProp )
						{
							Console.WriteLine("WordProp: " + wordprop.Value );
						}

					if (details.DwordProp != null)
						foreach ( WCDwordProp dwordprop in details.DwordProp )
						{
							Console.WriteLine("DWordProp: " + dwordprop.Value );
						}

					if (details.QwordProp != null)
						foreach ( WCQwordProp qwordprop in details.QwordProp )
						{
							Console.WriteLine("QWordProp: " + qwordprop.Value );
						}

					if (details.StringProp != null)
						foreach ( WCStringProp stringprop in details.StringProp )
						{
							Console.WriteLine("StringProp: " + stringprop.Value );
						}

					if (details.TimeProp != null)
						foreach ( WCTimeProp timeprop in details.TimeProp )
						{
							Console.WriteLine("TimeProp: " + timeprop.Value );
						}

					if (details.BinaryProp != null)
						foreach ( WCBinaryProp binprop in details.BinaryProp )
						{
							Console.WriteLine("BinaryProp size: " + binprop.Value.Length);
						}

					if (details.AttachmentProp != null)
						foreach ( WCAttachmentProp attachprop in details.AttachmentProp )
						{
							Console.WriteLine("AttachmentProp: " + attachprop.AttachUrl );
						}

					if (details.BoolProp != null)
						foreach ( WCBoolProp boolprop in details.BoolProp )
						{
							Console.WriteLine("BoolProp: " + boolprop.Value );
						}

					if (details.StringProp != null)
						foreach ( WCStringIdProp stringidprop in details.StringIdProp )
						{
							Console.WriteLine("StringIDProp: " + stringidprop.Value );
						}

				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("ValidDeleteMessage")]
		class ValidDeleteMessage : TestBase
		{
			protected override void Execute()
			{
				// 1.  verify msg exists
				// 2.  delete msg
				// 3.  verify deletion

				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				WCMessageSummary summary = null;
				WCMessageDetails details = null;

				uint delmsgID = (uint) MWGlobal.MessageList["DeleteMsg"];

				//First make sure it exists
				UInt32 hr = service.GetMessageDetails(
					MWGlobal.Users[4].WebId,
					MWGlobal.Users[4].GamerTag,
					delmsgID,
					0,
					0,
					out summary,
					out details
					);

				if ( summary == null )   // failed to get our  message
				{
					Console.WriteLine("DeleteMsg does not exist.");
					return;
				}

				hr = service.DeleteMessage(
					MWGlobal.Users[4].WebId,
					MWGlobal.Users[4].GamerTag,		// user info
					delmsgID,						// MessageID
					0								// DeleteFlags
					);

				if( HResult.Succeeded( hr ) )
				{
					// verify delete
				}
				else
				{
					Console.WriteLine("Delete call failed, hr: " + hr.ToString("X") );
					return;
				}


				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("BasicDeleteSystemMessage")]
		class BasicDeleteSystemMessage : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				// pull this from Send test
				uint MessageID  = (uint) MWGlobal.MessageList["SysMsgBasic"];

				UInt32 hr = service.DeleteTitleWideMessage(
					400001,			// TitleID
					MessageID,		// MessageID
					0				// WCDeleteSysMsgFlags
					//WCDeleteSysMsgFlags.RevokeAll
					);

				if( HResult.Succeeded( hr ) )
				{
					// Hurray!

					// TODO: Verify msg deletion
				}
				else
				{
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("ValidEnumMessages")]
		class ValidEnumMessages : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				WCMessageSummary[] summary = null;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				Console.WriteLine("EnumMessages User: " +MWGlobal.Users[1].GamerTag);

				UInt32 hr = service.EnumMessages(
					MWGlobal.Users[1].WebId,       // User
					MWGlobal.Users[1].GamerTag,
					out summary );

				Console.WriteLine( "EnumMessages returned {0}", hr );

				if( HResult.Succeeded( hr ) )
				{
					if ( summary.Length == 0 )   // we should have SEVERAL messages  (test for exact count?)
					{
						Console.WriteLine( "Got no messages!" );
						return;
					}

					// spew
					for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
					{
						Console.WriteLine( "    Message {0}", iMessage );
						Console.WriteLine( "        szSenderName - {0}", summary[ iMessage ].Sender );
						Console.WriteLine( "        qwSenderContext - {0}", summary[ iMessage ].SenderContext );
						Console.WriteLine( "        mtSentTime - {0}", summary[ iMessage ].SentTime );
						Console.WriteLine( "        dwMessageID - {0}", summary[ iMessage ].MessageID );
						Console.WriteLine( "        dwMessageFlags - {0}", summary[ iMessage ].MessageFlags );
						Console.WriteLine( "        dwSenderTitleID - {0}", summary[ iMessage ].SenderTitleID );
						Console.WriteLine( "        bMessageType - {0}", summary[ iMessage ].MessageType );
						Console.WriteLine( "        wExpireMinutes - {0}", summary[ iMessage ].ExpireMinutes );
						Console.WriteLine( "        cbDetails - {0}", summary[ iMessage ].DetailsSize );
					}
				}
				else
				{
					//failed, TODO: log some useful stuff here

					return;
				}
				Console.WriteLine();

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("BasicEnumSysMsgs")]
		class BasicEnumSysMsgs : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				WCTitleWideMessageSummary[] summary = null;

				UInt32 hr = service.EnumTitleWideMessages(
					400001,
					out summary
					);

				if( HResult.Succeeded( hr ) )
				{
					for( int iMessage = 0; iMessage < summary.Length; iMessage++ )
					{
						Console.WriteLine( "    Message {0}", iMessage );
						Console.WriteLine( "        TitleID - {0}", summary[ iMessage ].TitleID);
						Console.WriteLine( "        SenderName - {0}", summary[ iMessage ].SenderName);
						Console.WriteLine( "        qwSenderContext - {0}", summary[ iMessage ].SenderContext );
						Console.WriteLine( "        Region - {0}", summary[ iMessage ].Region );
						Console.WriteLine( "        mtSentTime - {0}", summary[ iMessage ].SentTime );
						Console.WriteLine( "        dwMessageID - {0}", summary[ iMessage ].MessageID );
						Console.WriteLine( "        dwMessageFlags - {0}", summary[ iMessage ].MessageFlags );
						Console.WriteLine( "        dwDescription - {0}", summary[ iMessage ].Description);
						Console.WriteLine( "        bMessageType - {0}", summary[ iMessage ].MessageType );
						Console.WriteLine( "        wExpireMinutes - {0}", summary[ iMessage ].ExpireMinutes );
						Console.WriteLine( "        cbDetails - {0}", summary[ iMessage ].DetailsSize );
					}
				}
				else
				{
					Console.WriteLine("Enum failed: " + hr.ToString("X") );
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("ValidGetDetails")]
		class ValidGetDetails : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));
				WCMessageSummary summary = null;
				WCMessageDetails details = null;

				// pull this from Send test?
				//uint uiSentMessageID = 0x0000ABCD;

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				uint msgid = 0;

				if ( MWGlobal.MessageList.Contains("BasicMessage") )
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;

				uint hr = service.GetMessageDetails(
					MWGlobal.Users[1].WebId,               // User
					MWGlobal.Users[1].GamerTag,
					msgid,				// MessageID
					//WCMessageFlags.Read, // SetFlags
					//WCMessageFlags.TitleReserved0, // UnsetFlags
					0,
					0,
					out summary,
					out details );

				if( HResult.Failed( hr ) )
				{
					Console.WriteLine("GetMessageDetails failed, HResult: " + hr );
					return;
				}

				if ( summary != null )
				{

					Console.WriteLine( "    Summary:" );
					Console.WriteLine( "        szSenderName - {0}",    summary.Sender );
					Console.WriteLine( "        qwSenderContext - {0}", summary.SenderContext );
					Console.WriteLine( "        mtSentTime - {0}",      summary.SentTime );
					Console.WriteLine( "        dwMessageID - {0}",     summary.MessageID );
					Console.WriteLine( "        dwMessageFlags - {0}",  summary.MessageFlags );
					Console.WriteLine( "        dwSenderTitleID - {0}", summary.SenderTitleID );
					Console.WriteLine( "        bMessageType - {0}",    summary.MessageType );
					Console.WriteLine( "        wExpireMinutes - {0}",  summary.ExpireMinutes );
					Console.WriteLine( "        cbDetails - {0}",       summary.DetailsSize );
				}

				if ( details != null )
				{
					if ( details.NullProp != null )
					{
						Console.WriteLine("Nullprop count: " + details.NullProp.Length);
					}

					foreach ( WCByteProp byteprop in details.ByteProp )
					{
						Console.WriteLine("ByteProp: " + byteprop.Value );
					}

					foreach ( WCWordProp wordprop in details.WordProp )
					{
						Console.WriteLine("WordProp: " + wordprop.Value );
					}

					foreach ( WCDwordProp dwordprop in details.DwordProp )
					{
						Console.WriteLine("DWordProp: " + dwordprop.Value );
					}

					foreach ( WCQwordProp qwordprop in details.QwordProp )
					{
						Console.WriteLine("QWordProp: " + qwordprop.Value );
					}

					foreach ( WCStringProp stringprop in details.StringProp )
					{
						Console.WriteLine("StringProp: " + stringprop.Value );
					}

					foreach ( WCTimeProp timeprop in details.TimeProp )
					{
						Console.WriteLine("TimeProp: " + timeprop.Value );
					}

					foreach ( WCBinaryProp binprop in details.BinaryProp )
					{
						Console.WriteLine("BinaryProp size: " + binprop.Value.Length);
					}

					foreach ( WCAttachmentProp attachprop in details.AttachmentProp )
					{
						Console.WriteLine("AttachmentProp: " + attachprop.AttachUrl );
					}

					foreach ( WCBoolProp boolprop in details.BoolProp )
					{
						Console.WriteLine("BoolProp: " + boolprop.Value );
					}

					foreach ( WCStringIdProp stringidprop in details.StringIdProp )
					{
						Console.WriteLine("StringIDProp: " + stringidprop.Value );
					}

				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("BasicGetMsgString")]
		class BasicGetMsgString : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				string resultString = service.GetMessageString(
					400001,
					2147483653,
					//WCLanguage.English
					"en-US"
					);

				if ( resultString == null )
				{
					return;
				}
				else
					ConsoleX.WriteLine("\nGot string: " + resultString);

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
		[TestCase, Description("ValidRevokeMessage")]
		class ValidRevokeMessage : TestBase
		{
			// 1. verify msg exists
			// 2. revoke msg
			// 3. verify revoke

			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[5].GamerTag;
				//user.WebID = MWGlobal.Users[5].WebId;

				WCMessageSummary[] summary = null;

				UInt32 hr = service.EnumMessages(
					MWGlobal.Users[5].WebId,       // User
					MWGlobal.Users[5].GamerTag,
					out summary );

				if ( HResult.Failed(hr) )
				{
					Console.WriteLine("Enum failed, hr: " + hr.ToString("X"));
					return;
				}

				// find message ID for revoke
				bool msgFound = false;
				uint revokemsgID;

				if ( MWGlobal.MessageList.Contains("RevokeMsg") )
					revokemsgID = (uint) MWGlobal.MessageList["RevokeMsg"];
				else
				{
					Console.WriteLine("Message to revoke not sent.");
					return;
				}

				foreach (WCMessageSummary sum in summary)
				{
					if ( sum.MessageID == revokemsgID)
						msgFound = true;
				}

				if (!msgFound)
				{
					Console.WriteLine("Message to revoke not found in user queue.");
					return;
				}

				// Now revoke the message

				WCRecipientResult[] revokelist = new WCRecipientResult[1];
				revokelist[0] = new WCRecipientResult();
				revokelist[0].User = MWGlobal.Users[5].GamerTag;
				revokelist[0].MessageID = revokemsgID;

				//user.GamerTag = MWGlobal.Users[0].GamerTag;
				//user.WebID = MWGlobal.Users[0].WebId;

				hr = service.RevokeMessage(
					MWGlobal.Users[0].WebId,
					MWGlobal.Users[0].GamerTag,
					revokelist
					);

				if( HResult.Failed( hr ) )
				{
					Console.WriteLine("Failed to revoke msg, hr: " + hr.ToString("X") );
					return;
				}

				// now verify revoke
				//user.GamerTag = MWGlobal.Users[5].GamerTag;
				//user.WebID = MWGlobal.Users[5].WebId;

				summary = null;

				hr = service.EnumMessages(
					MWGlobal.Users[5].WebId,       // User
					MWGlobal.Users[5].GamerTag,
					out summary );

				if ( HResult.Failed(hr) )
				{
					Console.WriteLine("Enum2 failed, hr: " + hr.ToString("X"));
					return;
				}

				msgFound = false;
				foreach (WCMessageSummary sum in summary)
				{
					if ( sum.MessageID == revokemsgID)
						msgFound = true;
				}

				if ( msgFound )   // uh-oh, the revoke did not work!?
				{
					Console.WriteLine("Msg stille exists in queue.");
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		[TestCase, Description("ValidSetFlags")]
		class ValidSetFlags : TestBase
		{
			protected override void Execute()
			{
				WCMessaging service = new WCMessaging(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				//WCWebUser user = new WCWebUser();
				//user.GamerTag = MWGlobal.Users[1].GamerTag;
				//user.WebID = MWGlobal.Users[1].WebId;

				uint msgid = 0;
				if ( MWGlobal.MessageList.Contains("BasicMessage") )		//TODO: Use seperate message/user?
					msgid = (uint) MWGlobal.MessageList["BasicMessage"];
				else
					return;

				UInt32 hr = service.SetMessageFlags(
					MWGlobal.Users[1].WebId,
					MWGlobal.Users[1].GamerTag,
					msgid,
					WCMessageFlags.Read | WCMessageFlags.TitleReserved0,
					0
					);

				if( HResult.Succeeded( hr ) )
				{
					WCMessageSummary summary = new WCMessageSummary();
					WCMessageDetails details = new WCMessageDetails();

					hr = service.GetMessageDetails(MWGlobal.Users[1].WebId, MWGlobal.Users[1].GamerTag, msgid, 0, 0, out summary, out details);
					if( HResult.Succeeded(hr))
					{
						Console.WriteLine("FLAGS: " + summary.MessageFlags );
					}
					else
					{
						Console.WriteLine("GetDetails failed: " + hr.ToString("X") );
					}
				}
				else
				{
					return;
				}

				ResultCode = TEST_RESULTS.PASSED;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\Tests\UserWidgetTests.cs ===
using System;
using System.Collections;
using System.Web.Services.Protocols;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Web;
using ServerTestFramework.Web.UserAccount;
using ServerTestFramework.WebWidget;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace WebSGBVTs
{
	[TestGroup]
	public class UserWidgetTests : TestNode
	{
		#region Common code
		public abstract class LinkAccountTestBase: UserTestBase
		{
			protected WCUserAccount wua = new WCUserAccount(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

			public void DumpLinkInfo (LinkInfo []li)
			{
				if (li.Length==0)
				{
					Global.RO.Info("< no accounts linked >");
				}
				foreach(LinkInfo l in li)
				{
					Global.RO.Info(l.GamerTag+"  owner:"+l.Owner);
				}
			}

			public class DataPoint
			{
				public Owner o;
				public ulong puid;
				public byte []webPuid;
				public bool owner;
			}

			protected void	WaitForCache()
			{
				new SleepInfo("Wait for cache", 31500);
			}

			protected uint	DoGetUserSettings(byte []webId, string gamer)
			{
				uint ret=wua.GetUserSettings(webId,gamer);
				UserInfo ui=UodbWS.GetUserInfo(UodbWS.DoesUserExist(gamer));
				uint myValue=(uint)( ((uint) ui.ticketFlags<<16) | ((uint) ui.country<<8));

				if (myValue!=ret)
					throw new UnexpectedTestResultException("Expected flag 0x"+myValue.ToString("X")+", got 0x"+ret.ToString("X"));

				return ret;
			}
		}
		#endregion

		[TestCase, Description("Attempt to link a new account")]
		class LinkAccount_LinkAsOwner : UserTestBase
		{
			override protected void Execute()
			{

				// Draft an American
				Owner o = UACS.GenerateOwner();
				//o.gamertag = "RMATestThisNow";
				o.phoneNumber="425-401-6745";
				o.cardHolder="Denver Pyle";

				ulong puid = UACS.CreateUser(o);

				WCUserAccount wua = new WCUserAccount(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate(null, Helper.Certificate));

				byte []webPuid=UACS.GenerateWebId(puid);
				bool f = wua.LinkUser(webPuid, true, o);
				ValueCheck.Test("LinkUser return value", true, f);

				UserWebMappingList uwml=UodbWS.GetUserWebMapping(puid);
				if (uwml[0].OwnerWebPuid!=puid)
					return;
				if (uwml[0].GamerWebPuid!=puid)
					return;
				if (!uwml[0].CompareGamer(webPuid))
					return;
				if (!uwml[0].CompareOwner(webPuid))
					return;
				if (uwml[0].CredentialType!=1)
					return;
				if ((uwml[0].Change-DateTime.Now).TotalMinutes>5)
					return;

				//DEBUG output so I can verify BUG 34611
				ConsoleX.WriteLine("Linked: " + o.gamertag + " " + puid);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Attempt to link a new account")]
		class GetAccountLinking_Mainline : LinkAccountTestBase
		{
			override protected void Execute()
			{
				// Draft an American
				Owner o = UACS.GenerateOwner();
				ulong puid = UACS.CreateUser(o);

				byte []webPuid=UACS.GenerateWebId(puid);
				bool f = wua.LinkUser(webPuid, true, o);
				ValueCheck.Test("LinkUser return value", true, f);

				WaitForCache();
				WaitForCache();

				LinkInfo []li=wua.LinkedGamerTags(webPuid);

				if (li.Length!=1)
					throw new UnexpectedTestResultException("Expected 1 result, got "+li.Length);

				if (li[0].GamerTag!=o.gamertag)
				{
					Console.WriteLine("\n" + li[0].GamerTag + " : " + o.gamertag);
					throw new UnexpectedTestResultException("Gamer tags don't match");
				}


				if (li[0].Owner!=true)
					return;

				ResultCode=TEST_RESULTS.PASSED;
			}
		}


		[TestCase, Description("Execute this case for a new user")]
		class GetUserSettings_Mainline : LinkAccountTestBase
		{
			override protected void Execute()
			{
				// Draft an American
				Owner o = UACS.GenerateOwner();
				ulong puid = UACS.CreateUser(o);

				byte []webPuid=UACS.GenerateWebId(puid);
				bool f = wua.LinkUser(webPuid, true, o);
				ValueCheck.Test("LinkUser return value", true, f);

				WaitForCache();
				DoGetUserSettings(webPuid,o.gamertag);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

// We don't support unlinking for launch 10/2005
		[TestCase, Ignore, Description("Unlink an account")]
		class UnlinkAccount_UnlinkOwner : UserTestBase
		{
			override protected void Execute()
			{
				Owner o = UACS.GenerateOwner();
				ulong puid = UACS.CreateUser(o);

				if( puid == 0 )
					throw new UnexpectedTestResultException("Puid returned from CreateUser was 0");

				WCUserAccount wua = new WCUserAccount(Global.XEnv.GetVirtualInterface (VirtualInterface.websg), CertificateStore.LookupCertificate (null, Helper.Certificate));

				byte []webPuid=UACS.GenerateWebId(puid);
				bool f = wua.LinkUser(webPuid, true, o);
				ValueCheck.Test("LinkUser return value", true, f);

				//cache wait
				new SleepInfo("Wait for cache", 11500);

				UserWebMappingList uwml=UodbWS.GetUserWebMapping(puid);
				if (uwml[0].OwnerWebPuid!=puid)
					return;
				//DEBUG
				ConsoleX.WriteLine("Mapped: " + uwml[0].OwnerWebPuid + "  " + uwml[0].OwnerWebId);

                //// Now unlink this user
                //bool retVal = wua.UnlinkGamerTag(webPuid, o.gamertag );

                //if (!retVal)
                //{
                //    ConsoleX.WriteLine("Failed to unlink gamertag.");
                //    return;
                //}

                //// Now user should not be linked
                //uwml = null;
                //uwml=UodbWS.GetUserWebMapping(puid);

                ////DEBUG
                //ConsoleX.WriteLine("Mapped: " + uwml[0].OwnerWebPuid + "  " + uwml[0].OwnerWebId);

                //if (uwml.Length!=0)
                //    if (uwml[0].OwnerWebPuid != 0)
                //        return;


				//DEBUG output so I can verify BUG 34611
				//ConsoleX.WriteLine("Linked: " + o.gamertag + " " + puid);

				ResultCode=TEST_RESULTS.PASSED;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\WebSGBVTs\Tests\LSPWidgetTests.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.Threading;
using System.IO;
using System.Xml;
using System.Text;
using System.Net;
using System.Net.Sockets;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using xonline.common.config;

namespace WebSGBVTs
{
	[TestGroup]
	public class LSPWidgetTests : TestNode
	{
		#region LSPWidget Test Helpers
		/// <summary>
		/// Key data values.
		/// </summary>
		struct KeyData
		{
			public uint     _keyVersion;
			public byte[]   _key;
		}


		/// <summary>
		/// SiteInfoReply:  Response to site info request.
		/// </summary>
		public class SiteInfoReply
		{
			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="_maxNumberOfKeys">Number of values expected in the array.</param>
			public SiteInfoReply( )
			{
				_numberOfKeys = 0;
				_curFileTime = 0;

				// create the array of keys
				_keys = null;

			}

			/// <summary>
			/// Constructs the binary form to be returned.
			/// </summary>
			/// <returns>byte array representation of this class.</returns>
			public void ReadBinary( byte[] data )
			{
				MemoryStream ms = new MemoryStream( data );
				BinaryReader br = new BinaryReader( ms );

				// read the expected time and number of keys.
				_curFileTime = br.ReadUInt64( );
				_numberOfKeys = br.ReadUInt32( );

				// set the array size.
				_keys = new KeyData[_numberOfKeys];
				for ( int x = 0; x < _numberOfKeys; x++ )
				{
					_keys[x]._keyVersion = br.ReadUInt32( );
					// all key sizes are 16 bytes.
					_keys[x]._key = br.ReadBytes( 16 );
				}

				br.Close();
			}

			public override string ToString()
			{
				string result = "";

				result = "TIME: " + System.DateTime.FromFileTime((long)_curFileTime).ToString() + "\n";
				result += "Number Of Keys: " + _numberOfKeys + "\n";
				result += "Keys: \n";

				// got through the list and print out all the keys.
				for ( int x = 0; x < _numberOfKeys; x++ )
				{
					_keys[x]._key[0].ToString("X");
					result += "Version: " + _keys[x]._keyVersion + " Value: 0x";

					// print out each byte as a hex value.
					for (int y = 0; y < _keys[x]._key.Length; y++ )
					{
						result += _keys[x]._key[y].ToString("X");
					}

					result += "\n";
				}

				return result;
			}

			ulong       _curFileTime;
			uint        _numberOfKeys;
			KeyData[]   _keys;
		}


		/// <summary>
		/// PUIDInfo:  structure to read and reply to PUID data.
		/// </summary>
		public class PUIDInfo
		{
			/// <summary>
			/// Constructor
			/// </summary>
			public PUIDInfo( uint expectedNumberOfPUIDs )
			{
				_numberOfPUIDs = 0;
				_PUIDs = new ulong[expectedNumberOfPUIDs];
			}

			public PUIDInfo( )
			{
				_numberOfPUIDs = 0;
				_PUIDs = null;
			}

			/// <summary>
			/// ReadBinary:  Reads binary data and puts it into the puid list.
			/// </summary>
			/// <param name="data">binary data to stream.</param>
			public void ReadBinary( byte[] data )
			{
				MemoryStream ms = new MemoryStream( data );
				BinaryReader br = new BinaryReader( ms );

				// get the expected number of PUIDs
				_numberOfPUIDs = br.ReadUInt32();

				// check if we have a null array
				if ( _PUIDs == null )
				{
					_PUIDs = new ulong[_numberOfPUIDs];
				}

				// ensure out array is big enough
				if ( _PUIDs.Length < _numberOfPUIDs )
				{
					throw new Exception( "Invalid usage of class.  Array size isn't big enough for incoming data.");
				}

				// add all the PUIDs to a list.
				for ( int x = 0; x < _numberOfPUIDs; x++ )
				{
					_PUIDs[x] = br.ReadUInt64();
				}

				br.Close();
			}

			/// <summary>
			/// Add a PUID the the PUID list.  Should only be used if class created with expectedNumberOfPUIDs
			///   and not read from binary.
			/// </summary>
			/// <param name="PUID">PUID to add</param>
			public void AddPUID( ulong PUID )
			{
				if ( _PUIDs == null )
				{
					throw new Exception( "Invalid usage of class.  You must specify a size before adding new PUIDs");
				}

				_PUIDs[_numberOfPUIDs] = PUID;
				_numberOfPUIDs++;
			}

			/// <summary>
			/// Constructs the binary form to be returned.
			/// </summary>
			/// <returns>byte array representation of this class.</returns>
			public byte[] GetBinary()
			{
				MemoryStream ms = new MemoryStream();
				BinaryWriter bw = new BinaryWriter( ms );

				bw.Write( _numberOfPUIDs );

				for ( int x = 0; x < _numberOfPUIDs; x++ )
				{
					bw.Write( _PUIDs[x] );
				}

				bw.Close();

				return ms.ToArray();
			}

			public override string ToString()
			{
				string result = "";
				for ( int x = 0; x < _numberOfPUIDs; x++ )
				{
					if ( result.Length > 0 )
					{
						result += "|" + _PUIDs[x].ToString();
					}
					else
					{
						result = _PUIDs[x].ToString();
					}
				}

				return result;
			}

			/// <summary>
			/// PUIDs:  Enumerator access to the PUID list.
			/// </summary>
			public ulong[] PUIDs
			{
				get
				{
					return _PUIDs;
				}
			}

			/// <summary>
			/// Count:  number of puids in list.
			/// </summary>
			public uint Count
			{
				get
				{
					return _numberOfPUIDs;
				}
			}

			protected uint        _numberOfPUIDs;
			protected ulong[]     _PUIDs;
		}


		/// <summary>
		/// GamerTagInfo:  structure to read and reply to gamertag data.
		/// </summary>
		public class GamerTagInfo
		{
			/// <summary>
			/// Constructor
			/// </summary>
			public GamerTagInfo( uint expectedNumberOfGTs )
			{
				_numberOfGTs = 0;
				_GamerTags = new string[expectedNumberOfGTs];
			}

			public GamerTagInfo( )
			{
				_numberOfGTs = 0;
				_GamerTags = null;
			}

			/// <summary>
			/// ReadBinary:  Reads binary data and puts it into the gamertag list.
			/// </summary>
			/// <param name="data">binary data to stream.</param>
			public void ReadBinary( byte[] data )
			{
				MemoryStream ms = new MemoryStream( data );
				BinaryReader br = new BinaryReader( ms );

				// get the expected number of PUIDs
				_numberOfGTs = br.ReadUInt32();

				// check if we have a null array
				if ( _GamerTags == null )
				{
					_GamerTags = new string[_numberOfGTs];
				}

				// ensure out array is big enough
				if ( _GamerTags.Length < _numberOfGTs )
				{
					throw new Exception( "Invalid usage of class.  Array size isn't big enough for incoming data.");
				}

				// add all the PUIDs to a list.
				for ( int x = 0; x < _numberOfGTs; x++ )
				{
					byte[] newgamertag = br.ReadBytes( (int)(c_GAMERTAG_SIZE * 2) );
					string stringgamertag = System.Text.UnicodeEncoding.Unicode.GetString( newgamertag, 0, newgamertag.Length );
					_GamerTags[x] = stringgamertag;

				}

				br.Close();
			}

			/// <summary>
			/// Add a gamertag to the gamertag list.  Should only be used if class created with expectedNumberOfGts
			///   and not read from binary.
			/// </summary>
			/// <param name="gamertag">gamertag to add</param>
			public void AddGamerTag( string gamertag )
			{
				if ( _GamerTags == null )
				{
					throw new Exception( "Invalid usage of class.  You must specify a size before adding new PUIDs");
				}

				_GamerTags[_numberOfGTs] = gamertag;
				_numberOfGTs++;
			}

			/// <summary>
			/// Constructs the binary form to be returned.
			/// </summary>
			/// <returns>byte array representation of this class.</returns>
			public byte[] GetBinary()
			{
				MemoryStream ms = new MemoryStream();
				BinaryWriter bw = new BinaryWriter( ms );

				bw.Write( _numberOfGTs );

				for ( int x = 0; x < _numberOfGTs; x++ )
				{
					byte[] binaryGT = System.Text.UnicodeEncoding.Unicode.GetBytes( _GamerTags[x].PadRight( (int)c_GAMERTAG_SIZE, (char)0 ) );
					bw.Write( binaryGT, 0, binaryGT.Length );
				}

				bw.Close();

				return ms.ToArray();
			}

			public override string ToString()
			{
				System.Text.StringBuilder sb = new System.Text.StringBuilder();

				for ( int x = 0; x < _numberOfGTs; x++ )
				{
					// put these string together.
					if ( sb.Length > 0 )
					{
						sb.Append( "|" + _GamerTags[x].ToString() );
					}
					else
					{
						sb.Append( _GamerTags[x] );
					}
				}

				return sb.ToString();
			}

			/// <summary>
			/// Gamertags:  Enumerator access to the gamertag list.
			/// </summary>
			public string[] Gamertags
			{
				get
				{
					return _GamerTags;
				}
			}

			/// <summary>
			/// Count:  number of puids in list.
			/// </summary>
			public uint Count
			{
				get
				{
					return _numberOfGTs;
				}
			}


			public const uint c_GAMERTAG_SIZE = 16;

			protected uint        _numberOfGTs;
			protected string[]    _GamerTags;
		}


		/// <summary>
		/// UdpsTestCase:  The base class for the test cases used by xdtool.
		/// </summary>
		public class TestCase : Object
		{
			// ----------------------------------
			//  Constants
			// ----------------------------------

			// ----------------------------------
			//  Type
			// ----------------------------------
			protected enum TEST_STATE
			{
				NONE                = 0,
				COMPLETE            = 1,
				WAITING_RESPONSE    = 2,
			};

			// ----------------------------------
			//  Methods
			// ----------------------------------
			public TestCase()
			{
				_resultstring = "Invalid";
				_wc = new WebClient();

				// Add the necessary headers
				_wc.Headers.Add("Content-Type", "xon/0");
				_wc.Headers.Add("User-Agent", "0/1.00.65535");
				_wc.Headers.Add("Subject-Name", "t2client2");
				_wc.Headers.Add("Client-IP-Port", "1.2.3.4:0");
				_wc.Headers.Add("RequestId", "CAFEBABEDEADBEEF");
			}

			/// <summary>
			/// Run:  executes the test case.  Should be overridden.
			/// </summary>
			public virtual void Run()
			{
				// override this method executing
				throw new Exception( "Method not supported." );
			}

			/// <summary>
			/// Process:  Takes a given packet returning true if it belongs to this case.
			/// </summary>
			public virtual bool Process( Object packet )
			{
				// override this method executing
				throw new Exception( "Method not supported." );
			}

			/// <summary>
			/// VerifyOwnership:  determines if a packet belongs to the test case.
			/// </summary>
			/// <param name="id">byte array of id to check</param>
			/// <returns>true if the id belongs to this test case.</returns>
			public virtual bool VerifyOwnership( byte[] id )
			{
				// override this method executing
				throw new Exception( "Method not supported." );
			}

			/// <summary>
			/// IsComplete:  (Should be overridden) True if test case complete.
			/// </summary>
			/// <returns>Whether operation is complete or not.</returns>
			public virtual bool IsComplete()
			{
				throw new Exception("Please implement this function.");
			}

			/// <summary>
			/// Result:  The final result of the test case...  set to false if not complete.
			/// </summary>
			public virtual int Result
			{
				get
				{
					return _result;
				}
			}


			/// <summary>
			/// ToString:  returns the result string for this entry.
			/// </summary>
			public override string ToString()
			{
				return _resultstring;
			}



			// ----------------------------------
			//  Members
			// ----------------------------------
			protected int       _result;
			protected string    _resultstring;
			protected WebClient _wc;
		}


		/// <summary>
		/// TestForwardRequest:  .
		/// </summary>
		public class TestForwardRequest: TestCase
		{
			// ----------------------------------
			//  Constant
			// ----------------------------------

			// ----------------------------------
			//  Methods
			// ----------------------------------
			public TestForwardRequest( string httpserver )
			{
				_url = "http://" + httpserver + "/LiveProxy/forwardrequest.aspx";

				_body = "";
				_xrl = "";
				_result = 0;
				_resultstring = "";
			}

			/// <summary>
			/// Run:  start, execute the test case.
			/// </summary>
			public override void Run()
			{
				byte[] data = System.Text.ASCIIEncoding.ASCII.GetBytes(_body);

				// add the necessary headers.
				_wc.Headers.Set( "xrl", _xrl );
				_wc.Headers.Set( "title-id", _titleID );

				byte[] resp = _wc.UploadData( _url, "POST", data );

				_resultstring = "Response received: \n";

				// print out the results.
				foreach ( string s in _wc.ResponseHeaders )
				{
					_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
				}
				_resultstring = System.Text.ASCIIEncoding.ASCII.GetString( resp );
				_state = TEST_STATE.COMPLETE;

			}

			/// <summary>
			/// Process:  Takes a given packet returning true if it belongs to this case.
			/// </summary>
			public override bool Process( Object data )
			{
				bool result = true;

				// if it does...  determine our state.
				switch( _state )
				{
					case TEST_STATE.COMPLETE:
					{
					}
						break;
					case TEST_STATE.NONE:
					case TEST_STATE.WAITING_RESPONSE:
					default:
					{
						throw new Exception( "Invalid state." );
					}
				}

				return result;
			}

			/// <summary>
			/// IsComplete:  True if test case complete.
			/// </summary>
			/// <returns>Whether operation is complete or not.</returns>
			public override bool IsComplete()
			{
				return ( _state == TEST_STATE.COMPLETE );
			}

			/// <summary>
			/// VerifyOwnership:  determines if a packet belongs to the test case.
			/// </summary>
			/// <param name="id">byte array of id to check</param>
			/// <returns>true if the id belongs to this test case.</returns>
			public override bool VerifyOwnership( byte[] id )
			{
				return true;
			}



			/// <summary>
			/// Result:  The final result of the test case...  set to false if not complete.
			///     0 -- failed.
			///     1 -- passed.
			/// </summary>
			public override int Result
			{
				get
				{
					if ( _state == TEST_STATE.COMPLETE )
					{
						return _result;
					}
					else
					{
						return 0;
					}
				}
			}

			public string XRL
			{
				get
				{
					return _xrl;
				}
				set
				{
					_xrl = value;
				}
			}

			public string Body
			{
				get
				{
					return _body;
				}
				set
				{
					_body = value;
				}
			}

			public string titleID
			{
				get
				{
					return _titleID;
				}
				set
				{
					_titleID = value;
				}
			}

			// ----------------------------------
			//  Members
			// ----------------------------------
			protected TEST_STATE        _state;
			protected string            _url;
			protected string            _body;
			protected string            _xrl;
			protected string            _titleID;

		}


		/// <summary>
		/// TestGetSiteInfo:  Tests the site info call to the live proxy.
		/// </summary>
		public class TestGetSiteInfo: TestCase
		{
			// ----------------------------------
			//  Constant
			// ----------------------------------

			// ----------------------------------
			//  Methods
			// ----------------------------------
			public TestGetSiteInfo( string httpserver )
			{
				_url = "http://" + httpserver + "/LiveProxy/getsiteinfo.aspx";

				_siteId = 0;
				_result = 0;
				_resultstring = "";
			}

			/// <summary>
			/// Run:  start, execute the test case.
			/// </summary>
			public override void Run()
			{
				byte[] data = System.BitConverter.GetBytes( _siteId );

				byte[] resp = _wc.UploadData( _url, data );

				SiteInfoReply sir = new SiteInfoReply();
				sir.ReadBinary( resp );

				_resultstring = "Response received: \n";

				// print out the results.
				foreach ( string s in _wc.ResponseHeaders )
				{
					_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
				}

				_resultstring += sir.ToString();
				_state = TEST_STATE.COMPLETE;

			}

			/// <summary>
			/// Process:  Takes a given packet returning true if it belongs to this case.
			/// </summary>
			public override bool Process( Object data )
			{
				bool result = true;

				// if it does...  determine our state.
				switch( _state )
				{
					case TEST_STATE.COMPLETE:
					{
					}
						break;
					case TEST_STATE.NONE:
					case TEST_STATE.WAITING_RESPONSE:
					default:
					{
						throw new Exception( "Invalid state." );
					}
				}

				return result;
			}

			/// <summary>
			/// IsComplete:  True if test case complete.
			/// </summary>
			/// <returns>Whether operation is complete or not.</returns>
			public override bool IsComplete()
			{
				return ( _state == TEST_STATE.COMPLETE );
			}

			/// <summary>
			/// VerifyOwnership:  determines if a packet belongs to the test case.
			/// </summary>
			/// <param name="id">byte array of id to check</param>
			/// <returns>true if the id belongs to this test case.</returns>
			public override bool VerifyOwnership( byte[] id )
			{
				return true;
			}



			/// <summary>
			/// Result:  The final result of the test case...  set to false if not complete.
			///     0 -- failed.
			///     1 -- passed.
			/// </summary>
			public override int Result
			{
				get
				{
					if ( _state == TEST_STATE.COMPLETE )
					{
						return _result;
					}
					else
					{
						return 0;
					}
				}
			}

			public int SiteId
			{
				get
				{
					return _siteId;
				}
				set
				{
					_siteId = value;
				}
			}

			// ----------------------------------
			//  Members
			// ----------------------------------
			protected TEST_STATE        _state;
			protected string            _url;
			protected int               _siteId;

		}


		/// <summary>
		/// TestGetSitePUIDs:  Tests the lookup puid call to the live proxy.
		/// </summary>
		public class TestGetSitePUIDs: TestCase
		{
			// ----------------------------------
			//  Constant
			// ----------------------------------

			// ----------------------------------
			//  Methods
			// ----------------------------------
			public TestGetSitePUIDs( string httpserver )
			{
				_url = "http://" + httpserver + "/LiveProxy/getsitepuids.aspx";

				_result = 0;
				_resultstring = "";
			}

			/// <summary>
			/// Run:  start, execute the test case.
			/// </summary>
			public override void Run()
			{

				byte[] data = new byte[0];

				byte[] resp = _wc.UploadData( _url, data );

				MemoryStream ms = new MemoryStream( resp );
				BinaryReader br = new BinaryReader( ms );

				ulong machinepuid = br.ReadUInt64();
				ulong userpuid = br.ReadUInt64();

				_resultstring = "Response received: \n";

				// print out the results.
				foreach ( string s in _wc.ResponseHeaders )
				{
					_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
				}

				_resultstring += "MachinePUID: 0x" + machinepuid.ToString("X") + ", UserPUID: 0x" + userpuid.ToString("X");
				_state = TEST_STATE.COMPLETE;
				br.Close();

			}

			/// <summary>
			/// Process:  Takes a given packet returning true if it belongs to this case.
			/// </summary>
			public override bool Process( Object data )
			{
				bool result = true;

				// if it does...  determine our state.
				switch( _state )
				{
					case TEST_STATE.COMPLETE:
					{
					}
						break;
					case TEST_STATE.NONE:
					case TEST_STATE.WAITING_RESPONSE:
					default:
					{
						throw new Exception( "Invalid state." );
					}
				}

				return result;
			}

			/// <summary>
			/// IsComplete:  True if test case complete.
			/// </summary>
			/// <returns>Whether operation is complete or not.</returns>
			public override bool IsComplete()
			{
				return ( _state == TEST_STATE.COMPLETE );
			}

			/// <summary>
			/// VerifyOwnership:  determines if a packet belongs to the test case.
			/// </summary>
			/// <param name="id">byte array of id to check</param>
			/// <returns>true if the id belongs to this test case.</returns>
			public override bool VerifyOwnership( byte[] id )
			{
				return true;
			}



			/// <summary>
			/// Result:  The final result of the test case...  set to false if not complete.
			///     0 -- failed.
			///     1 -- passed.
			/// </summary>
			public override int Result
			{
				get
				{
					if ( _state == TEST_STATE.COMPLETE )
					{
						return _result;
					}
					else
					{
						return 0;
					}
				}
			}

			/// <summary>
			/// SubjectName:  subjecty name to use.
			/// </summary>
			public string SubjectName
			{
				get
				{
					return _subjectName;
				}
				set
				{
					_subjectName = value;
				}
			}


			// ----------------------------------
			//  Members
			// ----------------------------------
			protected TEST_STATE        _state;
			protected string            _url;
			protected string            _subjectName;

		}


		/// <summary>
		/// TestLookupPUID:  Tests the lookup puid call to the live proxy.
		/// </summary>
		public class TestLookupPUID: TestCase
		{
			// ----------------------------------
			//  Constant
			// ----------------------------------

			// ----------------------------------
			//  Methods
			// ----------------------------------
			public TestLookupPUID( string httpserver)
			{
				_url = "http://" + httpserver + "/LiveProxy/lookuppuid.aspx";

				_result = 0;
				_resultstring = "";
			}

			public TestLookupPUID( string httpserver, uint numPUIDs )
			{
				_url = "http://" + httpserver + "/LiveProxy/lookuppuid.aspx";

				_result = 0;
				_resultstring = "";
				_puidInfo = new PUIDInfo(numPUIDs);
			}

			/// <summary>
			/// Run:  start, execute the test case.
			/// </summary>
			public override void Run()
			{
				byte[] data = _puidInfo.GetBinary();

				byte[] resp = _wc.UploadData( _url,"POST", data );

				GamerTagInfo gti = new GamerTagInfo();
				gti.ReadBinary( resp );

				_resultstring = "Response received: \n";

				// print out the results.
				foreach ( string s in _wc.ResponseHeaders )
				{
					_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
				}

				_resultstring += gti.ToString();
				_state = TEST_STATE.COMPLETE;

			}

			/// <summary>
			/// Run:  start, execute the test case.
			/// </summary>
			public void RunNull()
			{
				byte[] data = new byte[0];

				byte[] resp = _wc.UploadData( _url,"POST", data );

				GamerTagInfo gti = new GamerTagInfo();
				gti.ReadBinary( resp );

				_resultstring = "Response received: \n";

				// print out the results.
				foreach ( string s in _wc.ResponseHeaders )
				{
					_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
				}

				_resultstring += gti.ToString();
				_state = TEST_STATE.COMPLETE;

			}

			/// <summary>
			/// Process:  Takes a given packet returning true if it belongs to this case.
			/// </summary>
			public override bool Process( Object data )
			{
				bool result = true;

				// if it does...  determine our state.
				switch( _state )
				{
					case TEST_STATE.COMPLETE:
					{
					}
						break;
					case TEST_STATE.NONE:
					case TEST_STATE.WAITING_RESPONSE:
					default:
					{
						throw new Exception( "Invalid state." );
					}
				}

				return result;
			}

			/// <summary>
			/// IsComplete:  True if test case complete.
			/// </summary>
			/// <returns>Whether operation is complete or not.</returns>
			public override bool IsComplete()
			{
				return ( _state == TEST_STATE.COMPLETE );
			}

			/// <summary>
			/// VerifyOwnership:  determines if a packet belongs to the test case.
			/// </summary>
			/// <param name="id">byte array of id to check</param>
			/// <returns>true if the id belongs to this test case.</returns>
			public override bool VerifyOwnership( byte[] id )
			{
				return true;
			}



			/// <summary>
			/// Result:  The final result of the test case...  set to false if not complete.
			///     0 -- failed.
			///     1 -- passed.
			/// </summary>
			public override int Result
			{
				get
				{
					if ( _state == TEST_STATE.COMPLETE )
					{
						return _result;
					}
					else
					{
						return 0;
					}
				}
			}

			public void AddPUID( ulong puid )
			{
				_puidInfo.AddPUID( puid );
			}

			public int NumberOfPUIDs
			{
				get
				{
					return (int)_puidInfo.Count;
				}
				set
				{
					_puidInfo = new PUIDInfo( (uint)value );
				}
			}

			// ----------------------------------
			//  Members
			// ----------------------------------
			protected TEST_STATE        _state;
			protected string            _url;
			protected PUIDInfo          _puidInfo;

		}


		/// <summary>
		/// TestLookupGamerTag:  Tests the lookup gamertag call to the live proxy.
		/// </summary>
		public class TestLookupGamerTag: TestCase
		{
			// ----------------------------------
			//  Constant
			// ----------------------------------

			// ----------------------------------
			//  Methods
			// ----------------------------------
			public TestLookupGamerTag( string httpserver )
			{
				_url = "http://" + httpserver + "/LiveProxy/lookupgamertag.aspx";

				_result = 0;
				_resultstring = "";

			}

			public TestLookupGamerTag( string httpserver, uint numGamerTags )
			{
				_url = "http://" + httpserver + "/LiveProxy/lookupgamertag.aspx";

				_result = 0;
				_resultstring = "";
				_gtInfo = new GamerTagInfo(numGamerTags);
			}


			/// <summary>
			/// Run:  start, execute the test case.
			/// </summary>
			public override void Run()
			{
				byte[] data = _gtInfo.GetBinary();

				byte[] resp = _wc.UploadData( _url, "POST", data );

				PUIDInfo pi = new PUIDInfo();
				pi.ReadBinary( resp );

				_resultstring = "Response received: \n";

				// print out the results.
				foreach ( string s in _wc.ResponseHeaders )
				{
					_resultstring += s + " = " + (_wc.ResponseHeaders.GetValues( s ))[0] + " \n";
				}

				_resultstring += pi.ToString();
				_state = TEST_STATE.COMPLETE;
			}

			/// <summary>
			/// Process:  Takes a given packet returning true if it belongs to this case.
			/// </summary>
			public override bool Process( Object data )
			{
				bool result = true;

				// if it does...  determine our state.
				switch( _state )
				{
					case TEST_STATE.COMPLETE:
					{
					}
						break;
					case TEST_STATE.NONE:
					case TEST_STATE.WAITING_RESPONSE:
					default:
					{
						throw new Exception( "Invalid state." );
					}
				}

				return result;
			}

			/// <summary>
			/// IsComplete:  True if test case complete.
			/// </summary>
			/// <returns>Whether operation is complete or not.</returns>
			public override bool IsComplete()
			{
				return ( _state == TEST_STATE.COMPLETE );
			}

			/// <summary>
			/// VerifyOwnership:  determines if a packet belongs to the test case.
			/// </summary>
			/// <param name="id">byte array of id to check</param>
			/// <returns>true if the id belongs to this test case.</returns>
			public override bool VerifyOwnership( byte[] id )
			{
				return true;
			}



			/// <summary>
			/// Result:  The final result of the test case...  set to false if not complete.
			///     0 -- failed.
			///     1 -- passed.
			/// </summary>
			public override int Result
			{
				get
				{
					if ( _state == TEST_STATE.COMPLETE )
					{
						return _result;
					}
					else
					{
						return 0;
					}
				}
			}

			public void AddGamerTag( string gamertag )
			{
				_gtInfo.AddGamerTag( gamertag );
			}

			public int NumberOfGamerTags
			{
				get
				{
					return (int)_gtInfo.Count;
				}
				set
				{
					_gtInfo = new GamerTagInfo( (uint)value );
				}
			}

			// ----------------------------------
			//  Members
			// ----------------------------------
			protected TEST_STATE        _state;
			protected string            _url;
			protected GamerTagInfo      _gtInfo;

		}

		public class LSPTestSuite
		{
			public void LoadConfig( str