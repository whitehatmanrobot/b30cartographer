Y_CopyBytes2 },							// WRMSR 
	{ 0x31, ENTRY_CopyBytes2 },							// RDTSC 
	{ 0x32, ENTRY_CopyBytes2 },							// RDMSR 
	{ 0x33, ENTRY_CopyBytes2 },							// RDPMC 
	{ 0x34, ENTRY_CopyBytes2 },							// SYSENTER 
	{ 0x35, ENTRY_CopyBytes2 },							// SYSEXIT 
	{ 0x36, ENTRY_Invalid },							// _36 
	{ 0x37, ENTRY_Invalid },							// _37 
	{ 0x38, ENTRY_Invalid },							// _38 
	{ 0x39, ENTRY_Invalid },							// _39 
	{ 0x3A, ENTRY_Invalid },							// _3A 
	{ 0x3B, ENTRY_Invalid },							// _3B 
	{ 0x3C, ENTRY_Invalid },							// _3C 
	{ 0x3D, ENTRY_Invalid },							// _3D 
	{ 0x3E, ENTRY_Invalid },							// _3E 
	{ 0x3F, ENTRY_Invalid },							// _3F 
	{ 0x40, ENTRY_CopyBytes2Mod },						// CMOVO (0F 40) 
	{ 0x41, ENTRY_CopyBytes2Mod },						// CMOVNO (0F 41) 
	{ 0x42, ENTRY_CopyBytes2Mod },						// CMOVB & CMOVNE (0F 42) 
	{ 0x43, ENTRY_CopyBytes2Mod },						// CMOVAE & CMOVNB (0F 43) 
	{ 0x44, ENTRY_CopyBytes2Mod },						// CMOVE & CMOVZ (0F 44) 
	{ 0x45, ENTRY_CopyBytes2Mod },						// CMOVNE & CMOVNZ (0F 45) 
	{ 0x46, ENTRY_CopyBytes2Mod },						// CMOVBE & CMOVNA (0F 46) 
	{ 0x47, ENTRY_CopyBytes2Mod },						// CMOVA & CMOVNBE (0F 47) 
	{ 0x48, ENTRY_CopyBytes2Mod },						// CMOVS (0F 48) 
	{ 0x49, ENTRY_CopyBytes2Mod },						// CMOVNS (0F 49) 
	{ 0x4A, ENTRY_CopyBytes2Mod },						// CMOVP & CMOVPE (0F 4A) 
	{ 0x4B, ENTRY_CopyBytes2Mod },						// CMOVNP & CMOVPO (0F 4B) 
	{ 0x4C, ENTRY_CopyBytes2Mod },						// CMOVL & CMOVNGE (0F 4C) 
	{ 0x4D, ENTRY_CopyBytes2Mod },						// CMOVGE & CMOVNL (0F 4D) 
	{ 0x4E, ENTRY_CopyBytes2Mod },						// CMOVLE & CMOVNG (0F 4E) 
	{ 0x4F, ENTRY_CopyBytes2Mod },						// CMOVG & CMOVNLE (0F 4F) 
	{ 0x50, ENTRY_Invalid },							// _50 
	{ 0x51, ENTRY_Invalid },							// _51 
	{ 0x52, ENTRY_Invalid },							// _52 
	{ 0x53, ENTRY_Invalid },							// _53 
	{ 0x54, ENTRY_Invalid },							// _54 
	{ 0x55, ENTRY_Invalid },							// _55 
	{ 0x56, ENTRY_Invalid },							// _56 
	{ 0x57, ENTRY_Invalid },							// _57 
	{ 0x58, ENTRY_Invalid },							// _58 
	{ 0x59, ENTRY_Invalid },							// _59 
	{ 0x5A, ENTRY_Invalid },							// _5A 
	{ 0x5B, ENTRY_Invalid },							// _5B 
	{ 0x5C, ENTRY_Invalid },							// _5C 
	{ 0x5D, ENTRY_Invalid },							// _5D 
	{ 0x5E, ENTRY_Invalid },							// _5E 
	{ 0x5F, ENTRY_Invalid },							// _5F 
	{ 0x60, ENTRY_CopyBytes2Mod },						// PUNPCKLBW/r 
	{ 0x61, ENTRY_Invalid },							// _61 
	{ 0x62, ENTRY_CopyBytes2Mod },						// PUNPCKLWD/r 
	{ 0x63, ENTRY_CopyBytes2Mod },						// PACKSSWB/r 
	{ 0x64, ENTRY_CopyBytes2Mod },						// PCMPGTB/r 
	{ 0x65, ENTRY_CopyBytes2Mod },						// PCMPGTW/r 
	{ 0x66, ENTRY_CopyBytes2Mod },						// PCMPGTD/r 
	{ 0x67, ENTRY_CopyBytes2Mod },						// PACKUSWB/r 
	{ 0x68, ENTRY_CopyBytes2Mod },						// PUNPCKHBW/r 
	{ 0x69, ENTRY_CopyBytes2Mod },						// PUNPCKHWD/r 
	{ 0x6A, ENTRY_CopyBytes2Mod },						// PUNPCKHDQ/r 
	{ 0x6B, ENTRY_CopyBytes2Mod },						// PACKSSDW/r 
	{ 0x6C, ENTRY_Invalid },							// _6C 
	{ 0x6D, ENTRY_Invalid },							// _6D 
	{ 0x6E, ENTRY_CopyBytes2Mod },						// MOVD/r 
	{ 0x6F, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x70, ENTRY_Invalid },							// _70 
	{ 0x71, ENTRY_CopyBytes2Mod1 },						// PSLLW/6 ib,PSRAW/4 ib,PSRLW/2 ib 
	{ 0x72, ENTRY_CopyBytes2Mod1 },						// PSLLD/6 ib,PSRAD/4 ib,PSRLD/2 ib 
	{ 0x73, ENTRY_CopyBytes2Mod1 },						// PSLLQ/6 ib,PSRLQ/2 ib 
	{ 0x74, ENTRY_CopyBytes2Mod },						// PCMPEQB/r 
	{ 0x75, ENTRY_CopyBytes2Mod },						// PCMPEQW/r 
	{ 0x76, ENTRY_CopyBytes2Mod },						// PCMPEQD/r 
	{ 0x77, ENTRY_CopyBytes2 },							// EMMS 
	{ 0x78, ENTRY_Invalid },							// _78 
	{ 0x79, ENTRY_Invalid },							// _79 
	{ 0x7A, ENTRY_Invalid },							// _7A 
	{ 0x7B, ENTRY_Invalid },							// _7B 
	{ 0x7C, ENTRY_Invalid },							// _7C 
	{ 0x7D, ENTRY_Invalid },							// _7D 
	{ 0x7E, ENTRY_CopyBytes2Mod },						// MOVD/r 
	{ 0x7F, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x80, ENTRY_CopyBytes3Or5Target },				// JO 
	{ 0x81, ENTRY_CopyBytes3Or5Target },				// JNO 
	{ 0x82, ENTRY_CopyBytes3Or5Target },				// JB,JC,JNAE 
	{ 0x83, ENTRY_CopyBytes3Or5Target },				// JAE,JNB,JNC 
	{ 0x84, ENTRY_CopyBytes3Or5Target },				// JE,JZ,JZ 
	{ 0x85, ENTRY_CopyBytes3Or5Target },				// JNE,JNZ 
	{ 0x86, ENTRY_CopyBytes3Or5Target },				// JBE,JNA 
	{ 0x87, ENTRY_CopyBytes3Or5Target },				// JA,JNBE 
	{ 0x88, ENTRY_CopyBytes3Or5Target },				// JS 
	{ 0x89, ENTRY_CopyBytes3Or5Target },				// JNS 
	{ 0x8A, ENTRY_CopyBytes3Or5Target },				// JP,JPE 
	{ 0x8B, ENTRY_CopyBytes3Or5Target },				// JNP,JPO 
	{ 0x8C, ENTRY_CopyBytes3Or5Target },				// JL,NGE 
	{ 0x8D, ENTRY_CopyBytes3Or5Target },				// JGE,JNL 
	{ 0x8E, ENTRY_CopyBytes3Or5Target },				// JLE,JNG 
	{ 0x8F, ENTRY_CopyBytes3Or5Target },				// JG,JNLE 
	{ 0x90, ENTRY_CopyBytes2Mod },						// CMOVO (0F 40) 
	{ 0x91, ENTRY_CopyBytes2Mod },						// CMOVNO (0F 41) 
	{ 0x92, ENTRY_CopyBytes2Mod },						// CMOVB & CMOVC & CMOVNAE (0F 42) 
	{ 0x93, ENTRY_CopyBytes2Mod },						// CMOVAE & CMOVNB & CMOVNC (0F 43) 
	{ 0x94, ENTRY_CopyBytes2Mod },						// CMOVE & CMOVZ (0F 44) 
	{ 0x95, ENTRY_CopyBytes2Mod },						// CMOVNE & CMOVNZ (0F 45) 
	{ 0x96, ENTRY_CopyBytes2Mod },						// CMOVBE & CMOVNA (0F 46) 
	{ 0x97, ENTRY_CopyBytes2Mod },						// CMOVA & CMOVNBE (0F 47) 
	{ 0x98, ENTRY_CopyBytes2Mod },						// CMOVS (0F 48) 
	{ 0x99, ENTRY_CopyBytes2Mod },						// CMOVNS (0F 49) 
	{ 0x9A, ENTRY_CopyBytes2Mod },						// CMOVP & CMOVPE (0F 4A) 
	{ 0x9B, ENTRY_CopyBytes2Mod },						// CMOVNP & CMOVPO (0F 4B) 
	{ 0x9C, ENTRY_CopyBytes2Mod },						// CMOVL & CMOVNGE (0F 4C) 
	{ 0x9D, ENTRY_CopyBytes2Mod },						// CMOVGE & CMOVNL (0F 4D) 
	{ 0x9E, ENTRY_CopyBytes2Mod },						// CMOVLE & CMOVNG (0F 4E) 
	{ 0x9F, ENTRY_CopyBytes2Mod },						// CMOVG & CMOVNLE (0F 4F) 
	{ 0xA0, ENTRY_CopyBytes2 },							// PUSH 
	{ 0xA1, ENTRY_CopyBytes2 },							// POP 
	{ 0xA2, ENTRY_CopyBytes2 },							// CPUID 
	{ 0xA3, ENTRY_CopyBytes2Mod },						// BT  (0F A3)   
	{ 0xA4, ENTRY_CopyBytes2Mod1 },						// SHLD  
	{ 0xA5, ENTRY_CopyBytes2Mod },						// SHLD  
	{ 0xA6, ENTRY_Invalid },							// _A6 
	{ 0xA7, ENTRY_Invalid },							// _A7 
	{ 0xA8, ENTRY_CopyBytes2 },							// PUSH 
	{ 0xA9, ENTRY_CopyBytes2 },							// POP 
	{ 0xAA, ENTRY_CopyBytes2 },							// RSM 
	{ 0xAB, ENTRY_CopyBytes2Mod },						// BTS (0F AB) 
	{ 0xAC, ENTRY_CopyBytes2Mod1 },						// SHRD  
	{ 0xAD, ENTRY_CopyBytes2Mod },						// SHRD  
	{ 0xAE, ENTRY_CopyBytes2Mod },						// FXRSTOR/1,FXSAVE/0 
	{ 0xAF, ENTRY_CopyBytes2Mod },						// IMUL (0F AF) 
	{ 0xB0, ENTRY_CopyBytes2Mod },						// CMPXCHG (0F B0) 
	{ 0xB1, ENTRY_CopyBytes2Mod },						// CMPXCHG (0F B1) 
	{ 0xB2, ENTRY_CopyBytes2Mod },						// LSS/r 
	{ 0xB3, ENTRY_CopyBytes2Mod },						// BTR (0F B3) 
	{ 0xB4, ENTRY_CopyBytes2Mod },						// LFS/r 
	{ 0xB5, ENTRY_CopyBytes2Mod },						// LGS/r 
	{ 0xB6, ENTRY_CopyBytes2Mod },						// MOVZX/r 
	{ 0xB7, ENTRY_CopyBytes2Mod },						// MOVZX/r 
	{ 0xB8, ENTRY_Invalid },							// _B8 
	{ 0xB9, ENTRY_Invalid },							// _B9 
	{ 0xBA, ENTRY_CopyBytes2Mod1 },						// BT & BTC & BTR & BTS (0F BA) 
	{ 0xBB, ENTRY_CopyBytes2Mod },						// BTC (0F BB) 
	{ 0xBC, ENTRY_CopyBytes2Mod },						// BSF (0F BC) 
	{ 0xBD, ENTRY_CopyBytes2Mod },						// BSR (0F BD) 
	{ 0xBE, ENTRY_CopyBytes2Mod },						// MOVSX/r 
	{ 0xBF, ENTRY_CopyBytes2Mod },						// MOVSX/r 
	{ 0xC0, ENTRY_CopyBytes2Mod },						// XADD/r 
	{ 0xC1, ENTRY_CopyBytes2Mod },						// XADD/r 
	{ 0xC2, ENTRY_Invalid },							// _C2 
	{ 0xC3, ENTRY_Invalid },							// _C3 
	{ 0xC4, ENTRY_Invalid },							// _C4 
	{ 0xC5, ENTRY_Invalid },							// _C5 
	{ 0xC6, ENTRY_Invalid },							// _C6 
	{ 0xC7, ENTRY_CopyBytes2Mod },						// CMPXCHG8B (0F C7) 
	{ 0xC8, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xC9, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCA, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCB, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCC, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCD, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCE, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xCF, ENTRY_CopyBytes2 },							// BSWAP 0F C8 + rd 
	{ 0xD0, ENTRY_Invalid },							// _D0 
	{ 0xD1, ENTRY_CopyBytes2Mod },						// PSRLW/r 
	{ 0xD2, ENTRY_CopyBytes2Mod },						// PSRLD/r 
	{ 0xD3, ENTRY_CopyBytes2Mod },						// PSRLQ/r 
	{ 0xD4, ENTRY_Invalid },							// _D4 
	{ 0xD5, ENTRY_CopyBytes2Mod },						// PMULLW/r 
	{ 0xD6, ENTRY_Invalid },							// _D6 
	{ 0xD7, ENTRY_Invalid },							// _D7 
	{ 0xD8, ENTRY_CopyBytes2Mod },						// PSUBUSB/r 
	{ 0xD9, ENTRY_CopyBytes2Mod },						// PSUBUSW/r 
	{ 0xDA, ENTRY_Invalid },							// _DA 
	{ 0xDB, ENTRY_CopyBytes2Mod },						// PAND/r 
	{ 0xDC, ENTRY_CopyBytes2Mod },						// PADDUSB/r 
	{ 0xDD, ENTRY_CopyBytes2Mod },						// PADDUSW/r 
	{ 0xDE, ENTRY_Invalid },							// _DE 
	{ 0xDF, ENTRY_CopyBytes2Mod },						// PANDN/r 
	{ 0xE0, ENTRY_Invalid },							// _E0 
	{ 0xE1, ENTRY_CopyBytes2Mod },						// PSRAW/r 
	{ 0xE2, ENTRY_CopyBytes2Mod },						// PSRAD/r 
	{ 0xE3, ENTRY_Invalid },							// _E3 
	{ 0xE4, ENTRY_Invalid },							// _E4 
	{ 0xE5, ENTRY_CopyBytes2Mod },						// PMULHW/r 
	{ 0xE6, ENTRY_Invalid },							// _E6 
	{ 0xE7, ENTRY_Invalid },							// _E7 
	{ 0xE8, ENTRY_CopyBytes2Mod },						// PSUBB/r 
	{ 0xE9, ENTRY_CopyBytes2Mod },						// PSUBW/r 
	{ 0xEA, ENTRY_Invalid },							// _EA 
	{ 0xEB, ENTRY_CopyBytes2Mod },						// POR/r 
	{ 0xEC, ENTRY_CopyBytes2Mod },						// PADDSB/r 
	{ 0xED, ENTRY_CopyBytes2Mod },						// PADDSW/r 
	{ 0xEE, ENTRY_Invalid },							// _EE 
	{ 0xEF, ENTRY_CopyBytes2Mod },						// PXOR/r 
	{ 0xF0, ENTRY_Invalid },							// _F0 
	{ 0xF1, ENTRY_CopyBytes2Mod },						// PSLLW/r 
	{ 0xF2, ENTRY_CopyBytes2Mod },						// PSLLD/r 
	{ 0xF3, ENTRY_CopyBytes2Mod },						// PSLLQ/r 
	{ 0xF4, ENTRY_Invalid },							// _F4 
	{ 0xF5, ENTRY_CopyBytes2Mod },						// PMADDWD/r 
	{ 0xF6, ENTRY_Invalid },							// _F6 
	{ 0xF7, ENTRY_Invalid },							// _F7 
	{ 0xF8, ENTRY_CopyBytes2Mod },						// PSUBB/r 
	{ 0xF9, ENTRY_CopyBytes2Mod },						// PSUBW/r 
	{ 0xFA, ENTRY_CopyBytes2Mod },						// PSUBD/r 
	{ 0xFB, ENTRY_Invalid },							// _FB 
	{ 0xFC, ENTRY_CopyBytes2Mod },						// PADDB/r 
	{ 0xFD, ENTRY_CopyBytes2Mod },						// PADDW/r 
	{ 0xFE, ENTRY_CopyBytes2Mod },						// PADDD/r 
	{ 0xFF, ENTRY_Invalid },							// _FF 
	{ 0, ENTRY_End },
};

BOOL CDetourDis::SanityCheckSystem()
{
	for (ULONG n = 0; n < 256; n++) {
		REFCOPYENTRY pEntry = &s_rceCopyTable[n];

		if (n != pEntry->nOpcode) {
			ASSERT(n == pEntry->nOpcode);
			return FALSE;
		}
	}
	if (s_rceCopyTable[256].pfCopy != NULL) {
		ASSERT(!"Missing end marker.");
		return FALSE;
	}
	
	for (n = 0; n < 256; n++) {
		REFCOPYENTRY pEntry = &s_rceCopyTable0F[n];

		if (n != pEntry->nOpcode) {
			ASSERT(n == pEntry->nOpcode);
			return FALSE;
		}
	}
	if (s_rceCopyTable0F[256].pfCopy != NULL) {
		ASSERT(!"Missing end marker.");
		return FALSE;
	}
	
	return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\detours.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.3. (Build 43)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

//#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
#define DETOUR_TRAMPOLINE_SIZE          32
#define DETOUR_SECTION_HEADER_SIGNATURE 0x00727444   // "Dtr\0"

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
    return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { call _Detours_GetVA_##target };\
    __asm { jmp eax };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_EMPTY(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { xor eax, eax };\
    __asm { mov eax, [eax] };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;
    
    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;
    
    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszName,
                                                          PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
                            PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                          PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                            PBYTE pbDetour,
                                            PBYTE *ppbRealTrampoline,
                                            PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemove(PBYTE pbTrampoline, PBYTE pbDetour);

////////////////////////////////////////////////////////////// Code Functions.
//
PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
                                     PBYTE pbSrc,
                                     PBYTE *ppbTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PBYTE pbData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);
                                  
BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCWSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);
                  
#ifdef UNICODE
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI DetourContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllW
#else
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

/////////////////////////////////////////////////////////////////// Old Names.
//
#define ContinueProcessWithDll            DetourContinueProcessWithDll 
#define ContinueProcessWithDllA           DetourContinueProcessWithDllA
#define ContinueProcessWithDllW           DetourContinueProcessWithDllW
#define CreateProcessWithDll              DetourCreateProcessWithDll 
#define CreateProcessWithDllA             DetourCreateProcessWithDllA
#define CreateProcessWithDllW             DetourCreateProcessWithDllW
#define DETOUR_TRAMPOLINE_WO_TARGET       DETOUR_TRAMPOLINE_EMPTY
#define DetourBinaryPurgePayload          DetourBinaryPurgePayloads
#define DetourEnumerateExportsForInstance DetourEnumerateExports
#define DetourEnumerateInstances          DetourEnumerateModules
#define DetourFindEntryPointForInstance   DetourGetEntryPoint
#define DetourFindFinalCode               DetourGetFinalCode
#define DetourFindPayloadInBinary         DetourFindPayload
#define DetourGetSizeOfBinary             DetourGetSizeOfPayloads
#define DetourRemoveWithTrampoline        DetourRemove
#define PCREATE_PROCESS_ROUTINE           PDETOUR_CREATE_PROCESS_ROUTINE
#define PCREATE_PROCESS_ROUTINEA          PDETOUR_CREATE_PROCESS_ROUTINEA
#define PCREATE_PROCESS_ROUTINEW          PDETOUR_CREATE_PROCESS_ROUTINEW
//

#endif // _DETOURS_H_

////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\Helpers.cpp ===
#include "globals.h"


/********************************************************************************
HELPERS.CPP
********************************************************************************/
BOOL YesOrNo(void)
{
    CHAR c = 'a';

    do
    {
        //c = (char)_getch();
        scanf("%c", &c);
    }
    while (tolower(c) != 'n' && tolower(c) != 'y');

    if (tolower(c) != 'y')
        return FALSE;
    else
        return TRUE;
};




/********************************************************************************
********************************************************************************/
/*
void CreateClassLinkFile(TCHAR *pszFileName)

{
        char *szHeader[] = {
            "HRESULT MyDirectMusicCreateInstance(REFCLSID clsid,        \r\n",
            "                                    LPUNKNOWN pUnkOuter,   \r\n", 
            "                                    REFIID iid,            \r\n", 
            "                                    LPVOID *ppvInterface)  \r\n",
            "{                                                          \r\n",
            "   HRESULT hr = E_FAIL;\r\n",
            "                       \r\n",
            "   switch (clsid)      \r\n",
            "   {                   \r\n",
        };

        char *szTail[] = {

            "    default:    \r\n",
            "        printf(\"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );\r\n",
            "        break;      \r\n", 
            "    };             \r\n",
            "    return hr;     \r\n",
            "}                  \r\n"

        };




    //Check to see if the file exists.
    if (_access(pszFileName, 00) == 0)
    {

        //Check to see if the file is writeable.
        if (_access(pszFileName, 02) != 0)
        {
            printf("Error: Cannot write to %s.", pszFileName);
            return;
        }

        printf("%s exists, overwrite? (y/n) ", pszFileName);
        if (!YesOrNo())
            return;
    }

    HANDLE hFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
		DWORD dwBytesWritten;
        for (DWORD dwI = 0; dwI < NUMELEMS(szHeader); dwI++)
        {
            WriteFile(hFile,szHeader[dwI],strlen(szHeader[dwI]),&dwBytesWritten,NULL);
        }
        CClassTracker *pScan = g_pClassList;
        for (;;)
        {
            CClassTracker *pBestSoFar = NULL;
            DWORD dwMaxCount = 0;
            for (pScan = g_pClassList;pScan;pScan = pScan->m_pNext)
            {
                if (!pScan->m_fSaved)
                {
                    if (pScan->m_dwCount > dwMaxCount)
                    {
                        pBestSoFar = pScan;
                        dwMaxCount = pScan->m_dwCount;
                    }
                }
            }
            if (!pBestSoFar)
            {
                break;
            }
            pBestSoFar->m_fSaved = TRUE;
            char szData[400];
            wsprintfA(szData,"    case %s:\r\n        // %s.\r\n        hr = %s;\r\n        break;\r\n",
                pBestSoFar->m_pszClassName,pBestSoFar->m_pszComment,pBestSoFar->m_pszFunctionName);
            WriteFile(hFile,szData,strlen(szData),&dwBytesWritten,NULL);
        }
        for (dwI = 0; dwI < NUMELEMS(szTail); dwI++)
        {
            WriteFile(hFile,szTail[dwI],strlen(szTail[dwI]),&dwBytesWritten,NULL);
        }
        CloseHandle(hFile);
    }
}
*/


#ifndef _UNICODE
//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToWide()
// Desc: This is a UNICODE conversion utility to convert a CHAR string into a
//       WCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, 
                                     int cchDestChar )
{
    if( wstrDestination==NULL || strSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = strlen(strSource)+1;

    MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
                         wstrDestination, cchDestChar-1 );

    wstrDestination[cchDestChar-1] = 0;
}
#endif

//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertGenericStringToWide()
// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a
//       WCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, 
                                        int cchDestChar )
{
    if( wstrDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
	    wcscpy( wstrDestination, tstrSource );
    else
	    wcsncpy( wstrDestination, tstrSource, cchDestChar );
#else
    DXUtil_ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );
#endif
}



/********************************************************************************
********************************************************************************/
void InsertClass(const char *pszClassName, const char *pszFunctionName, const char *pszComment)
{
    CClassTracker *pScan = g_pClassList;
    for (;pScan;pScan = pScan->m_pNext)
    {
        if (strcmp(pScan->m_pszClassName,pszClassName)==0)
        {
            pScan->m_dwCount++;
            return;
        }
    }
    pScan = new CClassTracker;
    if (pScan)
    {
        pScan->m_pszClassName = pszClassName;
        pScan->m_pszFunctionName = pszFunctionName;
        pScan->m_pszComment = pszComment;
        pScan->m_pNext = g_pClassList;
        g_pClassList = pScan;
    }
}


/********************************************************************************
********************************************************************************/
void RemoveClass(const char *pszClassName)
{
    CClassTracker *pScan = g_pClassList;
    CClassTracker *pLast = NULL;
    
    
    for (;pScan;pScan = pScan->m_pNext)
    {
        if (strcmp(pScan->m_pszClassName, pszClassName)==0)
        {
            //If we're deleting the beginning of the list, then move the official root up one.
            if (g_pClassList == pScan)
            {
                g_pClassList = g_pClassList->m_pNext;
            }
            
            //If there's a node before us, point it to the next one.
            if (pLast)
            {
                pLast->m_pNext = pScan->m_pNext;                
                delete pScan;
            }

            break;  
        }

        pLast = pScan;
    }
}

/********************************************************************************
********************************************************************************/
BOOL CLSIDPresent( LPCSTR pszClassName)
{
    CClassTracker *pScan = g_pClassList;
    BOOL bFound = FALSE;
    
    for (;pScan;pScan = pScan->m_pNext)
    {
        if (strcmp(pScan->m_pszClassName, pszClassName)==0)
        {
            bFound = TRUE;
            break;  
        }

    }

    return bFound;

}




/**********************************************************************
**********************************************************************/
LPCSTR PathFindFileName(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
};


/********************************************************************************
********************************************************************************/
HRESULT ChopPath(const char *p_szFullString, LPSTR p_szPathOut, LPSTR p_szFileOut)
{
HRESULT hr = S_OK;
LPCSTR szFile = NULL;
DWORD dwLength;
CHAR szPathOut[MAX_PATH] = {0};
CHAR szFileOut[MAX_PATH] = {0};

ASSERT(p_szPathOut || p_szFileOut);
ASSERT(p_szFullString);

if (SUCCEEDED(hr))
{
    if (!p_szFullString)
    {
        hr = E_POINTER;
    }
}

//Parse out the file name.
if (SUCCEEDED(hr))
{
    //If the name ends in a '/' or a '\\' then there is no file name.
    if ('/' == p_szFullString[strlen(p_szFullString) - 1] ||
        '\\' == p_szFullString[strlen(p_szFullString) - 1] )
    {
        szFile = &p_szFullString[strlen(p_szFullString)];
    }
    else
    {    
        szFile = (LPSTR)PathFindFileName(p_szFullString);
    }

    //Should never happen.
    ASSERT(szFile);

    //Store the file name.
    strcpy(szFileOut, szFile);
}

if (SUCCEEDED(hr))
{
    //Store the path name.
    dwLength = strlen(p_szFullString) - strlen(szFile);
    strncpy(szPathOut, p_szFullString, dwLength);
    szPathOut[dwLength] = NULL;
}

//Regardless of whether the test passed, set these out-parameters.
if (p_szPathOut)
    strcpy(p_szPathOut, szPathOut);
if (p_szFileOut)
    strcpy(p_szFileOut, szFileOut);

return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\Helpers.h ===
/********************************************************************************
HELPERS.H
********************************************************************************/

VOID DXUtil_ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, 
                                     int cchDestChar );
VOID DXUtil_ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, 
                                        int cchDestChar );

HRESULT ChopPath(const char *p_szFullString, LPSTR p_szPathOut, LPSTR p_szFileOut);
LPCSTR PathFindFileName(LPCSTR pPath);


BOOL YesOrNo(void);

HRESULT PrintUsage(void);


struct CLSID_Map
{
	const CLSID *clsid;
	TCHAR *tcstr;
};


class CClassTracker 
{
public:
    CClassTracker() { m_pNext = NULL; m_dwCount = 1; m_fSaved = FALSE; }
    CClassTracker *     m_pNext;
    DWORD               m_dwCount;
    const char *        m_pszClassName;
    const char *        m_pszFunctionName;
    const char *        m_pszComment;
    BOOL                m_fSaved;
};



struct CLSIDElement
{
const GUID*  pclsid;
LPCSTR pszClassName;
LPCSTR pszFunctionName;
LPCSTR pszComment;
};

extern CClassTracker *g_pClassList;
extern CLSIDElement CLSIDTable[];

void InsertClass(const char *pszClassName, const char *pszFunctionName, const char *pszComment);
void RemoveClass(const char *pszClassName);
BOOL CLSIDPresent( LPCSTR pszClassName);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\disasm.h ===
//////////////////////////////////////////////////////////////////////////////
//
//	Module:		detours.lib
//  File:		disasm.h
//
//	Detours for binary functions.  Version 1.3. (Build 43)
//  Includes support for all x86 chips prior to the Pentium III.
//
//	Copyright 1999, Microsoft Corporation
//
//	http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DISASM_H_
#define _DISASM_H_

class CDetourDis
{
  public:
	CDetourDis(PBYTE *ppbTarget, LONG *plExtra);
	
	PBYTE 	CopyInstruction(PBYTE pbDst, PBYTE pbSrc);
	static BOOL	SanityCheckSystem();

  public:
	struct COPYENTRY;
	typedef const COPYENTRY * REFCOPYENTRY;

	typedef PBYTE (CDetourDis::* COPYFUNC)(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

	enum {
		DYNAMIC 	= 0x1u,
		ADDRESS 	= 0x2u,
		NOENLARGE	= 0x4u,

		SIB			= 0x10u,
		NOTSIB		= 0x0fu,
	};
	struct COPYENTRY 
	{
		ULONG 		nOpcode 		: 8;				// Opcode
		ULONG		nFixedSize 		: 3;				// Fixed size of opcode
		ULONG		nFixedSize16 	: 3;				// Fixed size when 16 bit operand
		ULONG		nModOffset 		: 3;				// Offset to mod/rm byte (0=none)
		LONG		nRelOffset 		: 3;				// Offset to relative target.
		ULONG		nFlagBits		: 4;				// Flags for DYNAMIC, etc.
		COPYFUNC	pfCopy;								// Function pointer.
	};

  protected:
#define ENTRY_CopyBytes1			1, 1, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes1Dynamic		1, 1, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes2			2, 2, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Jump		2, 2, 0, 1, 0, CopyBytes
#define ENTRY_CopyBytes2CantJump	2, 2, 0, 1, NOENLARGE, CopyBytes
#define ENTRY_CopyBytes2Dynamic		2, 2, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3			3, 3, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Dynamic		3, 3, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3Or5			5, 3, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Or5Target	5, 3, 0, 1, 0, CopyBytes
#define ENTRY_CopyBytes5Or7Dynamic	7, 5, 0, 0, DYNAMIC, CopyBytes
#define ENTRY_CopyBytes3Or5Address	5, 3, 0, 0, ADDRESS, CopyBytes
#define ENTRY_CopyBytes4			4, 4, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes5			5, 5, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes7			7, 7, 0, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Mod			2, 2, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes2Mod1		3, 3, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes2ModOperand	6, 4, 1, 0, 0, CopyBytes
#define ENTRY_CopyBytes3Mod			3, 3, 2, 0, 0, CopyBytes
#define ENTRY_CopyBytesPrefix		1, 1, 0, 0, 0, CopyBytesPrefix
#define ENTRY_Copy0F				1, 1, 0, 0, 0, Copy0F
#define ENTRY_Copy66				1, 1, 0, 0, 0, Copy66
#define ENTRY_Copy67				1, 1, 0, 0, 0, Copy67
#define ENTRY_CopyF6				0, 0, 0, 0, 0, CopyF6
#define ENTRY_CopyF7				0, 0, 0, 0, 0, CopyF7
#define ENTRY_CopyFF				0, 0, 0, 0, 0, CopyFF
#define ENTRY_Invalid				1, 1, 0, 0, 0, Invalid
#define ENTRY_End					0, 0, 0, 0, 0, NULL
	
	PBYTE CopyBytes(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyBytesPrefix(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	
	PBYTE Invalid(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

	PBYTE AdjustTarget(PBYTE pbDst, PBYTE pbSrc, LONG cbOp, LONG cbTargetOffset);
	
	VOID	Set16BitOperand();
	VOID	Set32BitOperand();
	VOID	Set16BitAddress();
	VOID	Set32BitAddress();
	
  protected:
	PBYTE Copy0F(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE Copy66(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE Copy67(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyF6(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyF7(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);
	PBYTE CopyFF(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc);

  protected:	
	static const COPYENTRY	s_rceCopyTable[257];
	static const COPYENTRY	s_rceCopyTable0F[257];
	static const BYTE 		s_rbModRm[256];

  protected:
	BOOL				m_b16BitOperand;
	BOOL				m_b16BitAddress;

	PBYTE *				m_ppbTarget;
	LONG *				m_plExtra;
	
	LONG				m_lScratchExtra;
	PBYTE				m_pbScratchTarget;
	BYTE				m_rbScratchDst[64];
};

#endif //_DISASM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\alist.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
//
// alist.cpp
//
#include <xtl.h>
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\alist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

#if _MSC_VER > 1000
#pragma once
#endif

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

protected:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            if (pList)
            {
                m_pHead=m_pHead->Cat(pList->GetHead());
            }
        };
    void AddHead(AListItem *pItem)
        {
            if (pItem!=NULL)
            {
                pItem->SetNext(m_pHead);
                m_pHead=pItem;
            }
        };
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) 
        {
            if (pItem != NULL)
            {
                m_pHead=m_pHead->Remove(pItem);
            }
        };
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(AListItem *pItem);
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li = m_pHead;
            if(m_pHead)
            {
                m_pHead = m_pHead->GetNext();
                li->SetNext(NULL);
            }
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\DebugCmd.cpp ===
//-----------------------------------------------------------------------------
// File: DebugCmd.CPP
//
// Desc: 
//      Helps an application expose functionality through the debug channel
//  to a debug console running on a remote machine.
//      Commands are sent through the debug channel to the debug monitor on
//  the Xbox machine.  The Xbox machine routes it to the command processor,
//  which is linked into the application (this happens on a separate thread
//  from the application's).  When the application polls for commands to be
//  run (usually once per frame), it can then pick up the command to execute
//  and do the appropriate processing.
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xbdm.h>
#include <stdio.h>

#include "DebugCmd.h"

// our critical section
bool g_fcsInited = false;
CRITICAL_SECTION g_cs;

// command prefix
const char *g_szCmd = "XAUD";

// processorproc buffer
#define REMOTEBUF_SIZE 10
static char g_aszRemoteBuf[REMOTEBUF_SIZE][CCH_MAXCMDLEN];
static int g_nRemoteBufWriteSlot;
static int g_nRemoteBufReadSlot;

const DCCMDDEF g_rgDCCmds[] =                   // List of app-defined commands
{
    {"help",      RCmdHelp,      " [CMD]: List commands / usage"},
    {"set",       RCmdSet,       " var [=] <val>: set a variable"},
    // Add additional application defined commands here:
	{"connect",RCmdAddConnection," : Connects an application"},
	{"disconnect",RCmdRemoveConnection," : Disconnects an application"},
    {"initialize",RCmdInitializeExperimenter," : Initializes Xbox Experimenter functions"},
	{"uninitialize",RCmdUninitializeExperimenter," : Uninitializes Xbox Experimenter functions"},
    {"load",      RCmdLoad,      " <segmentID> <filename>: Loads a segment"},
    {"unload",    RCmdUnload,    " <segmentID> : Unloads a segment"},
    {"play",      RCmdPlay,      " <segmentID> <segmentFlags> <audiopathID> <standardAudiopathID>: Plays a segment"},
    {"stop",      RCmdStop,      " <segmentID> <segmentFlags>: Stops a segment"},
	{"searchDirectory",RCmdSearchDirectory, " <searchDirectory>: Sets the search directory"},
	{"clearCache",RCmdClearCache," : Clears the loader's cache"},
	{"panic",	  RCmdPanic,	 " : Stop everything"},
    {"createAudiopath",RCmdCreateAudiopath," <audiopathID> <filename>: Loads and instantiates an audiopath"},
	{"createStandardAudiopath",RCmdCreateAudiopath," <audiopathID> <dwType>: Instantiates a standard audiopath"},
    {"setDefaultAudiopath",RCmdSetDefaultAudiopath," <audiopathID>: Sets a audiopath as the default audiopath"},
    {"releaseAudiopath",RCmdReleaseAudiopath," <audiopathID> : Releases an audiopath"},
	{"Script.Init",RCmdScriptInit," <scriptID> <filename>: Loads and initializes a script"},
	{"Script.Release",RCmdScriptRelease," <scriptID>: Releases a script"},
	{"Script.EnumVariable",RCmdScriptEnumVariable," <scriptID> <variableIndex>: Enumerates a variable"},
	{"Script.GetVariableVariant",RCmdScriptGetVariableVariant," <scriptID> <variableName>: Gets a variable"},
	{"Script.SetVariableVariant",RCmdScriptSetVariableVariant," <scriptID> <variableName>: Sets a variable"},
	{"Script.EnumRoutine",RCmdScriptEnumRoutine," <scriptID> <routineIndex>: Enumerates a routine"},
	{"Script.CallRoutine",RCmdScriptCallRoutine," <scriptID> <routineName>: Calls a routine"},
	{"WaveBank.PlayEntry",RCmdWaveBankPlayEntry," : <file_name> Plays a wave bank entry"},
	{"WaveBank.StopAll",RCmdWaveBankStopAll," : Stops all playing wave bank entries"},
};

const DCCMDDEFNOW g_rgDCCmdsNow[] = // List of app-defined commands that must be processed immediately
{
	{"Synth.Initialize",RCmdSynthInitialize," : Initializes the synth"},
	{"Synth.Uninitialize",RCmdSynthUninitialize," : Uninitializes the synth"},
    {"Synth.PlayBuffer",RCmdSynthPlayBuffer," <rtBuffer> <rtNow> <cbBuffer> : Plays a buffer of MIDI events"},
    {"Synth.Download",RCmdSynthDownload," <dwBufferID> <cbBuffer> : Downloads an instrument buffer"},
    {"Synth.Unload",RCmdSynthUnload," <dwBufferID> : Unloads an instrument buffer"},
    {"Synth.GetTime",RCmdSynthGetTime," : Gets the current time"},
	{"Synth.SetChannelGroups",RCmdSynthSetChannelGroups," : <dwNumChannelGroups> Sets the number of channel groups to use"},
	{"Synth.SetDefaultAudiopath",RCmdSynthSetDefaultAudioPath," : <dwNumAudioPath> Sets the default audiopath to use"},
};

//=========================================================================
// Name: RCmdHelp
// Desc: Builtin command - help
//          Iterates over the list of builtin and application-provided 
//          commands and displays a help string for each one
//=========================================================================
void RCmdHelp(int argc, char *argv[])
{
	UNREFERENCED_PARAMETER( argc );
	UNREFERENCED_PARAMETER( argv );

    int iCmd;

    for(iCmd = 0; iCmd < sizeof(g_rgDCCmds) / sizeof(g_rgDCCmds[0]); iCmd++)
    {
        DCCMDPrintf("%s\t%s\n",
            g_rgDCCmds[iCmd].szCmd,
            g_rgDCCmds[iCmd].szCmdHelp);
    }
    for(iCmd = 0; iCmd < sizeof(g_rgDCCmdsNow) / sizeof(g_rgDCCmdsNow[0]); iCmd++)
    {
        DCCMDPrintf("%s\t%s\n",
            g_rgDCCmdsNow[iCmd].szCmd,
            g_rgDCCmdsNow[iCmd].szCmdHelp);
    }
}

//=========================================================================
// Name: RCmdSet
// Desc: Builtin command - set
//          Can set or display values of any variables exposed by the 
//          application to the debug console
//=========================================================================
void RCmdSet(int argc, char *argv[])
{
    UINT nIndex;

    if(argc == 1)
    {
        // if we aren't passed any arguments, then just list all the variables and
        // what their current values are.
        for(nIndex = 0; nIndex < g_nVars; nIndex++)
        {
            switch(g_rgDCCMDVars[nIndex].ddt)
            {
            case SDOS_bool:
                DCCMDPrintf("%s\t= %d\n", g_rgDCCMDVars[nIndex].lpstr,
                    *(bool *)g_rgDCCMDVars[nIndex].lpvAddr);
                break;
            case SDOS_I4:
                DCCMDPrintf("%s\t= %d\n", g_rgDCCMDVars[nIndex].lpstr,
                    *(INT *)g_rgDCCMDVars[nIndex].lpvAddr);
                break;
            case SDOS_I2:
                DCCMDPrintf("%s\t= %d\n", g_rgDCCMDVars[nIndex].lpstr,
                    *(WORD *)g_rgDCCMDVars[nIndex].lpvAddr);
                break;
            case SDOS_R4:
                DCCMDPrintf("%s\t= %0.1f\n", g_rgDCCMDVars[nIndex].lpstr,
                    *(float *)g_rgDCCMDVars[nIndex].lpvAddr);
                break;
            }
        }
    }
    else
    {
        // if the user did a set "foo = 2" move arg3 to arg2
        if(argv[2][0] == '=')
            argv[2] = argv[3];

        // Find the entry for this variable, if we can
        for(nIndex = 0; nIndex < g_nVars; nIndex++)
        {
            if(!lstrcmpiA(argv[1], g_rgDCCMDVars[nIndex].lpstr))
            {
                char *endptr;
                DWORD dwVal = (argv[2][0] == '0' && argv[2][1] == 'x') ?
                    strtoul(argv[2], &endptr, 16) : atoi(argv[2]);

                // Set the appropriate type of data
                LPVOID lpvAddr = g_rgDCCMDVars[nIndex].lpvAddr;
                switch(g_rgDCCMDVars[nIndex].ddt)
                {
                case SDOS_bool:
                    *(bool *)lpvAddr = !!dwVal;
                    DCCMDPrintf("set %s = %d\n", argv[1], *(bool *)lpvAddr);
                    break;
                case SDOS_I4:
                    *(INT *)lpvAddr = dwVal;
                    DCCMDPrintf("set %s = %d\n", argv[1], *(INT *)lpvAddr);
                    break;
                case SDOS_I2:
                    *(WORD *)lpvAddr = (WORD)dwVal;
                    DCCMDPrintf("set %s = %d\n", argv[1], *(WORD *)lpvAddr);
                    break;
                case SDOS_R4:
                    *(float *)lpvAddr = (float)atof(argv[2]);
                    DCCMDPrintf("set %s = %0.1f\n", argv[1], *(float *)lpvAddr);
                    break;
                }

                // call the notif func if there was one
                if(g_rgDCCMDVars[nIndex].pfnNotifFunc)
                    g_rgDCCMDVars[nIndex].pfnNotifFunc(lpvAddr);

                return;
            }
        }

        DCCMDPrintf("variable '%s' not found\n", argv[1]);
    }
}

//=========================================================================
// Name: CmdToArgv
// Dsec: Parse szCmd into argv and return # of args. (modifies szCmd)
//=========================================================================
int CmdToArgv(char *szCmd, char *szArg[], int maxargs)
{
    int argc = 0;
    int argcT = 0;
    char *szNil = szCmd + lstrlenA(szCmd);

    while(argcT < maxargs)
    {
        // eat whitespace
        while(*szCmd && (*szCmd == ' '))
            szCmd++;

        if(!*szCmd)
        {
            szArg[argcT++] = (char *)szNil;
        }
        else
        {
            // find the end of this arg
            char chEnd = (*szCmd == '"' || *szCmd == '\'') ? *szCmd++ : ' ';
            char *szArgEnd = szCmd;
            while(*szArgEnd && (*szArgEnd != chEnd))
                szArgEnd++;

            // record this bad boy
            szArg[argcT++] = szCmd;
            argc = argcT;

            // move szArg to the next argument (or not)
            szCmd = *szArgEnd ? szArgEnd + 1 : szArgEnd;
            *szArgEnd = 0;
        }
    }

    return argc;
}


//
// Temporary replacement for CRT string funcs, since
// we can't call CRT functions on the debug monitor
// thread right now.
//

//=========================================================================
// Name: dbgstrlen
// Desc: Returns length of sz
//=========================================================================
int dbgstrlen( LPCSTR sz )
{
    LPCSTR szEnd = sz;

    while( *szEnd )
        szEnd++;

    return szEnd - sz;
}

//=========================================================================
// Name: dbglc
// Desc: Returns lowercase of char
//=========================================================================
inline char dbglc( char ch )
{
    if( ch >= 'A' && ch <= 'Z' )
        return ch - ( 'A' - 'a' );
    else
        return ch;
}

//=========================================================================
// Name: dbgstrcmpn
// Desc: String compare.  Returns TRUE if strings are equal up to n 
//       chars or end of string
//=========================================================================
BOOL dbgstrcmpn( LPCSTR sz1, LPCSTR sz2, int n )
{
    while( ( dbglc( *sz1 ) == dbglc( *sz2 ) ) && *sz1 && n > 0 )
    {
        --n;
        ++sz1;
        ++sz2;
    }

    return( n == 0 || dbglc( *sz1 ) == dbglc( *sz2 ) );
}

//=========================================================================
// Name: dbgstrcpy
// Desc: Copies szSrc to szDest and terminates szDest
//=========================================================================
void dbgstrcpy( LPSTR szDest, LPCSTR szSrc )
{
    while( ( *szDest++ = *szSrc++ ) != 0 )
        ;
}
    
//=========================================================================
// Name: DCCmdPRocessorProc
// Desc: Cmd notification proc
//
//  This is what is called by the Xbox debug monitor to have us process
//  a command.  What we'll actually attempt to do is tell it to make calls
//  to us on a separate thread, so that we can just block until we're 
//  able to process a command.
//=========================================================================
extern "C" ULONG _cdecl DbgPrint(PCH Format, ...);
HRESULT __stdcall DCCmdProcessorProc(LPCSTR szCommand, LPSTR szResp,
    DWORD cchResp, PDM_CMDCONT pdmcc)
{
    // skip over prefix
    LPCSTR szCmd = szCommand + lstrlenA(g_szCmd) + 1;
    BOOL   fKnownCommand = FALSE;

    // check if this is the initial connect signal
    if(dbgstrcmpn(szCmd, "__connect__", 11))
    {
        // if so, respond that we're connected
        lstrcpynA(szResp, "Version 0.1 Connected.", cchResp);
        return XBDM_NOERR;
    }

    // check to see if the cmd exists
    for(int iCmd = 0; iCmd < sizeof(g_rgDCCmds) / sizeof(g_rgDCCmds[0]); iCmd++)
    {
        if(dbgstrcmpn(g_rgDCCmds[iCmd].szCmd, szCmd, dbgstrlen(g_rgDCCmds[iCmd].szCmd)))
        {
            // If we find the string, copy it into the command buffer
            // to be examined by the polling function
            fKnownCommand = TRUE;
            break;
        }
    }

	int iCmdNow = -1;
	if( !fKnownCommand )
	{
		// check to see if the cmd exists
		for(iCmdNow = 0; iCmdNow < sizeof(g_rgDCCmdsNow) / sizeof(g_rgDCCmdsNow[0]); iCmdNow++)
		{
			if(dbgstrcmpn(g_rgDCCmdsNow[iCmdNow].szCmd, szCmd, dbgstrlen(g_rgDCCmdsNow[iCmdNow].szCmd)))
			{
				// If we find the string, call its function immediately
				fKnownCommand = TRUE;
				break;
			}
		}
	}

	HRESULT hr = XBDM_NOERR;

    if( fKnownCommand )
    {
		if( iCmdNow != -1 )
		{
			char *      szArgv[10];
			int         argc;
			char        szLocalBuf[CCH_MAXCMDLEN]; // local copy of command
			dbgstrcpy( szLocalBuf, szCmd );

			// Now process the command
			argc = CmdToArgv(szLocalBuf, szArgv, 10);
			hr = g_rgDCCmdsNow[iCmdNow].pfnHandler(argc, szArgv, szResp, cchResp, pdmcc);
		}
		else
		{
			// g_aszRemoteBuf needs to be protected by the critical section
			EnterCriticalSection(&g_cs);

			// If the read and write heads are at the same position, and there is data ther
			if( (g_nRemoteBufWriteSlot == g_nRemoteBufReadSlot)
			&&	g_aszRemoteBuf[g_nRemoteBufWriteSlot][0] )
			{
				// This means the application has probably stopped polling for debug commands
				dbgstrcpy( szResp, "Cannot execute - previous commands still pending" );
			}
			else
			{
				// Otherwise, write out the command
				dbgstrcpy( g_aszRemoteBuf[g_nRemoteBufWriteSlot], szCmd );
				g_nRemoteBufWriteSlot++;
				if( g_nRemoteBufWriteSlot >= REMOTEBUF_SIZE )
				{
					g_nRemoteBufWriteSlot = 0;
				}
			}
			LeaveCriticalSection(&g_cs);
		}
    }
    else
    {
        dbgstrcpy( szResp, "unknown command" );
    }

    return hr;
}
extern void PlayMIDI();

//=========================================================================
// Name: DCHandleCmds
// Desc: Poll routine called by Xbox app
//
//  The application should call this function periodically, usually every
//  frame.  This will check to see if there is a command waiting to be
//  executed, and if so, execute it.
//=========================================================================
BOOL DCHandleCmds()
{
    static BOOL fRegistered = false;
    char *      szArgv[10];
    int         argc;
    char        szLocalBuf[CCH_MAXCMDLEN]; // local copy of command

    // Initialize ourselves when we're first called.
    if(!fRegistered)
    {
        // init our critical section
        if(!g_fcsInited)
        {
            InitializeCriticalSection(&g_cs);
            g_fcsInited = true;
        }

        // register our command handler with the debug monitor
        HRESULT hr = DmRegisterCommandProcessor(g_szCmd, DCCmdProcessorProc);
        if(FAILED(hr))
            return false;

        fRegistered = true;
    }

    // If there's nothing waiting, return.
    if( !g_aszRemoteBuf[g_nRemoteBufReadSlot][0] )
    {
        return false;
    }

    // 
    // Grab a copy of the command to free up
    // the crtical section
    //
    EnterCriticalSection(&g_cs);

    lstrcpyA( szLocalBuf, g_aszRemoteBuf[g_nRemoteBufReadSlot] );
    g_aszRemoteBuf[g_nRemoteBufReadSlot][0] = 0;

	g_nRemoteBufReadSlot++;
	if( g_nRemoteBufReadSlot >= REMOTEBUF_SIZE )
	{
		g_nRemoteBufReadSlot = 0;
	}

    LeaveCriticalSection(&g_cs);

	{
        char szBuf[100+CCH_MAXCMDLEN];
        sprintf( szBuf, "Read command %s\n", szLocalBuf );
        OutputDebugString( szBuf );
	}


    // Now process the command
    argc = CmdToArgv(szLocalBuf, szArgv, 10);

    // Find the entry in our command list
    for(int iCmd = 0; iCmd < sizeof(g_rgDCCmds) / sizeof(g_rgDCCmds[0]); iCmd++)
    {
        if(!lstrcmpiA(g_rgDCCmds[iCmd].szCmd, szArgv[0]))
        {
            g_rgDCCmds[iCmd].pfnHandler(argc, szArgv);
            break;
        }
    }

    return true;
}

//=========================================================================
// Name: DCCMDPrintf 
// Desc: Asynchronous printf routine that sends the string to the 
//          Remote Xbox Command Client
//=========================================================================
BOOL DCCMDPrintf(LPCSTR szFmt, ...)
{
    char szBuf[CCH_MAXCMDLEN];
    int cch;
    va_list arglist;

	// Zero buffer
	ZeroMemory( szBuf, sizeof(char) * CCH_MAXCMDLEN );

    // copy prefix into into buffer
    for(int ich = 0; ich < sizeof(g_szCmd); ich++)
        szBuf[ich] = g_szCmd[ich];
    szBuf[ich - 1] = '!';

    // format arguments
    va_start(arglist, szFmt);
    cch = _vsnprintf(&szBuf[ich], CCH_MAXCMDLEN - ich, szFmt, arglist);
    va_end(arglist);

    // send it out
    DmSendNotificationString(szBuf);
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\DebugCmd.h ===
//-----------------------------------------------------------------------------
// File: DebugCmd.H
//
// Desc: Remote Xbox command header
//
// This header file should be included into your application.  It provides 
// function and type definitions.  You will also need to modify the following
// variables:
//
// g_rgDCCmds - This is the list of commands your application provides.  Note
//  that "help" and "set" are provided automatically and can not be overriden.
//  This is currently defined in DebugCmd.cpp
// g_rgDCCMDVars - This is a list of variables that your application exposes.
//  They can be examined and modified by the builtin "set" command.
//  This should be defined in your application source, after including DebugCmd.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#ifndef _DEBUGCMD_H_
#define _DEBUGCMD_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <xbdm.h>

/////////////////////////////////////////////////////////////////////////////
// Commands
/////////////////////////////////////////////////////////////////////////////

void RCmdHelp(int argc, char *argv[]);          // Help command
void RCmdSet(int argc, char *argv[]);           // Set command
// Add prototypes for your app-defined commands here
void RCmdAddConnection(int argc, char *argv[]);
void RCmdRemoveConnection(int argc, char *argv[]);
void RCmdInitializeExperimenter(int argc, char *argv[]);    // Initializes for Xbox Experimenter
void RCmdUninitializeExperimenter(int argc, char *argv[]);    // Initializes for Xbox Experimenter
void RCmdLoad(int argc, char *argv[]);          // Loads the segment
void RCmdUnload(int argc, char *argv[]);        // Unloads the segment
void RCmdPlay(int argc, char *argv[]);          // Plays the segment
void RCmdStop(int argc, char *argv[]);          // Stops the segment
void RCmdSearchDirectory(int argc, char *argv[]);// Sets the search directory
void RCmdClearCache(int argc, char *argv[]);    // Clears the loader's cache
void RCmdPanic(int argc, char *argv[]);			// Stop everything
void RCmdCreateAudiopath(int argc, char *argv[]);// Creates the audiopath
void RCmdSetDefaultAudiopath(int argc, char *argv[]);// Sets the default audiopath
void RCmdReleaseAudiopath(int argc, char *argv[]);// Releases the audiopath

void RCmdScriptInit(int argc, char *argv[]);// Initializes a script
void RCmdScriptRelease(int argc, char *argv[]);// Releases a script
void RCmdScriptEnumVariable(int argc, char *argv[]);// Enumerates a variable
void RCmdScriptGetVariableVariant(int argc, char *argv[]);// Gets a variable
void RCmdScriptSetVariableVariant(int argc, char *argv[]);// Sets a variable
void RCmdScriptEnumRoutine(int argc, char *argv[]);// Enumerates a routine
void RCmdScriptCallRoutine(int argc, char *argv[]);// Calls a routine

HRESULT RCmdSynthPlayBuffer(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);// Plays a buffer of MIDI events
HRESULT __stdcall SynthReceiveBuffer(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse);

HRESULT RCmdSynthDownload(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);// Downloads an instrument
HRESULT __stdcall SynthReceiveDownload(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse);

HRESULT RCmdSynthUnload(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);// Unloads an instrument
HRESULT RCmdSynthGetTime(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);// Get the current time
HRESULT RCmdSynthSetChannelGroups(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);// Set the number of channel groups
HRESULT RCmdSynthSetDefaultAudioPath(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);// Set the default audiopath to perform on
HRESULT RCmdSynthInitialize(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);// Set the number of channel groups
HRESULT RCmdSynthUninitialize(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);// Set the number of channel groups

void RCmdWaveBankPlayEntry(int argc, char **argv);
void RCmdWaveBankStopAll(int argc, char **argv);

void RCmdChange( void * );                      // Notified on changes


#define CCH_MAXCMDLEN       256
typedef void (*RCMDSHANDLER)(int argc, char *argv[]);

// Command definition structure
typedef struct _DCCMDDEF
{
    LPSTR           szCmd;                      // Name of command
    RCMDSHANDLER    pfnHandler;                 // Handler function
    LPSTR           szCmdHelp;                  // Description of command
} DCCMDDEF;

typedef HRESULT (*RCMDSHANDLERNOW)(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc);

// Command definition structure
typedef struct _DCCMDDEFNOW
{
    LPSTR           szCmd;                      // Name of command
    RCMDSHANDLERNOW pfnHandler;                 // Handler function
    LPSTR           szCmdHelp;                  // Description of command
} DCCMDDEFNOW;

extern const DCCMDDEF g_rgDCCmds[];             // List of app-defined commands
extern const DCCMDDEFNOW g_rgDCCmdsNow[];       // List of app-defined commands that should be processed immediately


/////////////////////////////////////////////////////////////////////////////
// Variables
/////////////////////////////////////////////////////////////////////////////

enum DCCMDDATATYPES { SDOS_bool, SDOS_I2, SDOS_I4, SDOS_R4 };
typedef void (*DCCMDSETNOTIF)(LPVOID lpvAddr);

// Variable definition structure
typedef struct _DCCMDVARDEF
{
    LPCSTR          lpstr;                      // Name of variable
    LPVOID          lpvAddr;                    // Address of variable
    DCCMDDATATYPES  ddt;                        // Data type of variable
    DCCMDSETNOTIF   pfnNotifFunc;               // Function to call upon change
} DCCMDVARDEF;

// These should get defined in your application cpp file:
extern const DCCMDVARDEF g_rgDCCMDVars[];       // List of application variables
extern const UINT        g_nVars;               // Number of application vars


/////////////////////////////////////////////////////////////////////////////
// Misc
/////////////////////////////////////////////////////////////////////////////

//
// handle any remote commands that have been sent - this
// should be called periodically by the application
//
BOOL DCHandleCmds();

//
// asynchronous printf - this is used to send
// responses back to the debug console
//
BOOL DCCMDPrintf(LPCSTR szFmt, ...);

#endif // _DEBUGCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\macros.h ===
#pragma once

#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)

#define RELEASE( p )                                                 \
{                                                                    \
	if( NULL != p )                                                  \
		p->Release();                                                \
                                                                     \
    p = NULL;                                                        \
}

#define VALIDATEHR( hr )										     \
{																	 \
	if ( S_FALSE == hr )                                             \
	{                                                                \
		printf( "hr was S_FALSE\n" );                              \
	}																 \
}

#define SAFEDELETE( p )                                              \
{                                                                    \
	delete p;                                                        \
	p = NULL;                                                        \
}

#define SAFECLOSEHANDLE( h )                                         \
{                                                                    \
	if ( NULL != h )                                                 \
		CloseHandle( h );                                            \
		                                                             \
	h = NULL;                                                        \
}

#define CHECKPTR( p )												 \
if ( NULL == p )													 \
{																	 \
	printf( "Argument was NULL\n" );								 \
	hr = E_POINTER;													 \
}

#define CHECKALLOC( p )                                              \
if ( NULL == p )                                                     \
{                                                                    \
	printf( #p ## " was NULL\n" );                                 \
	hr = E_OUTOFMEMORY;                                              \
}                                                                    

#define ALLOCATEANDCHECKSTRUCT( p, type )                            \
if ( SUCCEEDED( hr ) )			                                     \
{								                                     \
	p = new type();				                                     \
									                                 \
	CHECKALLOC( p );                                                 \
	                                                                 \
	if ( SUCCEEDED( hr ) )                                           \
	{                                                                \
	   memset( p, 0, sizeof( type ) );                               \
	}                                                                \
}	

#define ALLOCATEANDCHECK( p, type )                                  \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    p = new type();                                                  \
                                                                     \
    CHECKALLOC( p );                                                 \
                                                                     \
}							

#ifdef NOLOGGING
#define SETLOG( handle, name, comp, subcomp, func )
#else // NOLOGGING
#define SETLOG( handle, name, comp, subcomp, func )                  \
{                                                                    \
   g_hLog = handle;                                                  \
   xSetOwnerAlias( g_hLog, name );                                   \
   xSetComponent( g_hLog, comp, subcomp );                           \
   xSetFunctionName( g_hLog, func );                                 \
}
#endif //NOLOGGING

#ifdef NOLOGGING
#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
	if ( FAILED( hr ) )                                              \
	{                                                                \
	    printf( #func ## " returned: 0x%x\n", hr );                \
	}                                                                \
}
#else // NOLOGGING
#define EXECUTE( func )                                              \
{                                                                    \
	hr = func;                                                       \
	VALIDATEHR( hr );	                                             \
	if ( FAILED( hr ) )                                              \
	{                                                                \
	    printf( #func ## " returned: 0x%x\n", hr );                \
		xLog( g_hLog, XLL_FAIL, #func ## " returned: 0x%x\n", hr );  \
	}                                                                \
	else                                                             \
	{                                                                \
		xLog( g_hLog, XLL_PASS, #func ## " returned: 0x%x\n", hr );  \
	}                                                                \
	                                                                 \
}   
#endif // NOLOGGING     

#ifdef NOLOGGING
#define SHOULDRUNTEST( libName, testName ) TRUE 
#else // NOLOGGING
#define SHOULDRUNTEST( libName, testName ) GetProfileIntA( libName, testName, FALSE ) 
#endif // NOLOGGING
                                                           

#define CHECKEXECUTE( func )                                         \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
    EXECUTE( func );                                                 \
}

#define CHECK( exp )                                                 \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	exp;                                                             \
}

#define FAIL_ON_CONDITION( exp )                                     \
if ( exp )                                                           \
{                                                                    \
    ASSERT( ! ( exp ) );                                             \
    hr = E_FAIL;                                                     \
}

//Runs the function without printing anything.
#define RUN( func )                                                  \
{                                                                    \
	hr = func;                                                       \
}

// Runs the function for a bool value
#define RUNBOOL( func )                                              \
{                                                                    \
	hr = func ? S_OK : E_FAIL;                                       \
}

// Runs the function for a 0 int value
#define RUNINT( func )                                               \
{                                                                    \
	hr = 0 == func ? S_OK : E_FAIL;                                  \
}                                                                    

// Runs the function for a valid handle value
#define RUNHANDLE( handle, func )                                    \
{                                                                    \
	hr = NULL != ( handle = func ) ? S_OK : E_FAIL;                  \
}  

//Checks and runs the function without printing anything.
#define CHECKRUN( exp )                                              \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUN(exp);                                                        \
	VALIDATEHR( hr );                                                \
}

// Checks and runs the function for a bool value
#define CHECKRUNBOOL( exp )                                          \
if ( SUCCEEDED( hr ) )                                               \
{																	 \
	RUNBOOL( exp );                                                  \
}

// Checks and runs the function for a 0 int return                   
#define CHECKRUNINT( exp )                                           \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUNINT( exp );                                                   \
}

// Checks and runs the function for a valid handle return                   
#define CHECKRUNHANDLE( handle, exp )                                \
if ( SUCCEEDED( hr ) )                                               \
{                                                                    \
	RUNHANDLE( handle, exp );                                        \
}

#define NUMELEMS(x) ( sizeof( x ) / sizeof( ( x ) [0] ) )

#define SUCCEED_ON_FAIL( hr, expected ) expected == hr ? S_OK : S_OK == hr ? E_FAIL : hr
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\dspserver.cpp ===
#include "..\..\..\..\..\test\multimedia\dsp\dspserver.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\DMConsole.cpp ===
//-----------------------------------------------------------------------------
// File: DMConsole.cpp
//
// Desc: Xbox side of 'Xbox Experimenter' plugin for DMP.
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//
// Revised 9/26 to include DSP Server code
//
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBUtil.h>
#include <XBFont.h>
#include <XBHelp.h>

#include "DebugCmd.h"
#include "DMConsole.h"
#include <xbdm.h>
#include "dsstdfx.h"
#include <xtl.h>
// END NEW

#include "dspserver.h"
#include "wavbndlr.h"

#define XBOX_EXPERIMENTER_NAME "Xbox Experimenter"

static const DWORD MIDI_INDICATOR_OFF_DELAY = 500; //msec

extern CRITICAL_SECTION g_cs;
CXBoxSample g_xbApp;
BOOL dbgstrcmpn( LPCSTR sz1, LPCSTR sz2, int n );
int dbgstrlen( LPCSTR sz );
IDirectMusicLoader8*      g_pLoader         = NULL;
IDirectMusicPerformance8* g_pPerformance    = NULL;
//IDirectMusicPort*         g_pIDirectMusicPort = NULL;

extern void WbCheckStatusAll(void);

//------------------------------------------------------------------------------
//  PreDownloadEffectsImage
//------------------------------------------------------------------------------
void __cdecl
PreDownloadEffectsImage(void)
/*++

Routine Description:

    Stops the RMS display when a new image is about to be downloaded

Arguments:

    None

Return Value:

    None

--*/
{
    // stop reading data until download complete
    g_xbApp.m_bDisplayRMS = FALSE;
}

//------------------------------------------------------------------------------
//  DownloadEffectsImage
//------------------------------------------------------------------------------
void __cdecl
DownloadEffectsImage(
                     IN LPDSEFFECTIMAGEDESC pImageDes, 
                     IN int                 count,
                     IN char**              pEffectNames, 
                     IN int*                pEffectIndices
                     )
/*++

Routine Description:

    Looks for the rms effect index in the downloaded image to reset
    the rms display

Arguments:

    OUT pImageDes -         Pointer to the DSEFFECTIMAGEDESC 
                            structure that is returned by the 
                            method, which describes the DSP 
                            scratch image. 
    OUT count -             Number of effects in image
    OUT pEffectNames -      Array of effect name strings 
                            (each null terminated)
    OUT pEffectIndices -    Array of effect indices

Return Value:

    None

--*/
{
    // if we've got an RMS effect, find it and start reading effect data again
    int     i;
    bool    bFound;

    g_xbApp.m_pEffectsImageDesc = pImageDes;
    g_xbApp.m_bDisplayRMS = TRUE;
}

//-----------------------------------------------------------------------------
// Callouts for labelling the gamepad on the help screen
//-----------------------------------------------------------------------------
XBHELP_CALLOUT g_HelpCallouts[] = 
{
    { XBHELP_BACK_BUTTON,  XBHELP_PLACEMENT_2, L"Display help" },
//  { XBHELP_LEFTSTICK,    XBHELP_PLACEMENT_2, L"Adjust volume" },
    { XBHELP_A_BUTTON,      XBHELP_PLACEMENT_2, L"Reset peak meters" }
//    { XBHELP_RIGHTSTICK,   XBHELP_PLACEMENT_2, L"Adjust groove\nlevel" },
};

#define NUM_HELP_CALLOUTS 2


//-----------------------------------------------------------------------------
// Name: InitDirectMusic
// Desc: Init DM
//-----------------------------------------------------------------------------
HRESULT InitDirectMusic() 
{
    // Initialize DirectMusic
    DirectMusicInitialize();

    // Create loader object
    DirectMusicCreateInstance( CLSID_DirectMusicLoader, NULL, 
                               IID_IDirectMusicLoader8, (VOID**)&g_pLoader );

    // Create performance object
    DirectMusicCreateInstance( CLSID_DirectMusicPerformance, NULL,
                               IID_IDirectMusicPerformance8, (VOID**)&g_pPerformance );

    // Initialize the performance with the standard audio path.
    // The flags (final) argument allows us to specify whether or not we want
    // DirectMusic to create a thread on our behalf to process music, using 
    // DMUS_INITAUDIO_NOTHREADS.  The default is for DirectMusic to create its
    // own thread; DMUS_INITAUDIO_NOTHREADS tells DirectMusic not to do this, 
    // and the app will periodically call DirectMusicDoWork().  For software 
    // emulation on alpha hardware, it's generally better to have DirectMusic
    // create its own thread. On real hardware, periodically calling 
    // DirectMusicDoWork may provide a better option.
    g_pPerformance->InitAudioX( 0, 0, 128, 0 );

    g_pPerformance->AddNotificationType( GUID_NOTIFICATION_SEGMENT );

    // Now DirectMusic will play in the background, so continue on with our task
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetVolume()
// Desc: Set volume on the main music audipath
// Note: The argument to IDirectMusicAudioPath::SetVolume is attenuation in
//       hundredths of a dB.  Attenuation more than 60dB is silent, so
//       that's our effective minimum.  
// Note: No longer used, per raid #9045.
//-----------------------------------------------------------------------------
HRESULT SetVolume( LONG lVolume )
{
    // Change range from [0,100] to [-6000,0]
    lVolume = lVolume * 60 - 6000;

    static lOldVolume = 0;
    if (lOldVolume != lVolume)
    {
        lOldVolume = lVolume;    
        // Change volume on all audiopaths
        CAudiopathItem *pAudiopathTmp = (CAudiopathItem *)g_xbApp.m_lstAudiopaths.GetHead();
        while( pAudiopathTmp )   
        {
            pAudiopathTmp->m_pAudiopath8->SetVolume( lVolume, 0 );
            pAudiopathTmp = pAudiopathTmp->GetNext();
        }
    }
 
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SetGrooveLevel()
// Desc: Change the groove level of the performance
//-----------------------------------------------------------------------------
HRESULT SetGrooveLevel( INT dwGrooveLevel )
{
    CHAR chGrooveLevel = (CHAR)dwGrooveLevel;
    g_pPerformance->SetGlobalParam( GUID_PerfMasterGrooveLevel, 
                                    &chGrooveLevel, sizeof(CHAR) );
    return S_OK;
}


//-----------------------------------------------------------------------------
// Variable declaration block:
// These are the variables exposed to the "set" command. Don't forget to update
// g_nVars to reflect the number of entries
//-----------------------------------------------------------------------------
const DCCMDVARDEF g_rgDCCMDVars[] = 
{
    { "groove", &g_xbApp.m_fGrooveLevel, SDOS_R4, RCmdChange },
    { "volume", &g_xbApp.m_fVolume, SDOS_R4, RCmdChange },
};
const UINT g_nVars = 2;


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    // Note: We defined g_xbApp as a global to give access to debug channel
    if( FAILED( g_xbApp.Create() ) )
        return;
    g_xbApp.Run();
}




//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Application class constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
{
    // draw as fast as possible to sample more peak values
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    m_fGrooveLevel =  50.0f;
    m_fVolume      = 100.0f;        
    m_fMIDICounter =   0.0f;
    m_pDSound      = NULL;
    m_bSynthInitialized = FALSE;
    m_bDrawHelp = FALSE;
    m_bDisplayRMS = TRUE;

    for (DWORD k=0; k<PEAK_NUM_BINS; k++)
    {
        m_fMaxLevels[k] = 0.0f;
        m_fHistoryBufferAverage[k] = 0.0f;
        for (DWORD j=0; j<HISTORY_BUFFER_SIZE; j++)
            m_fLevelsHistoryBuffer[k][j] = 0.0f;
    }
    m_dwHistoryBufferIndex = 0;

	m_fLastMIDICounterValue = 0.0f;
	m_dwMIDIIndicatorOnTime = 0;
}




//-----------------------------------------------------------------------------
// Name: DownloadScratch
// Desc: Downloads a DSP scratch image to the DSP
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::DownloadScratch(PCHAR pszScratchFile)
{
    HANDLE hFile;
    DWORD dwSize = 0;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err;

        err = GetLastError();
        OutputDebugString( _T("Failed to open the dsp image file.\n") );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );
        
        if (!bResult)
        {
            DWORD err;

            err = GetLastError();
            OutputDebugString( _T("\n Failed to open the dsp image file.\n") );
            hr = HRESULT_FROM_WIN32(err);
        }

    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        if (SUCCEEDED(hr))
        {
            DSEFFECTIMAGELOC dsEffectImageLoc;
            dsEffectImageLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
            dsEffectImageLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;
            hr = m_pDSound->DownloadEffectsImage( pBuffer,
                                                  dwSize,
                                                  &dsEffectImageLoc,
                                                  &m_pEffectsImageDesc );
            m_bDisplayRMS = TRUE;
        }
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }
    
    return hr;
}



// only needed if we run update in a separate thread
DWORD WINAPI ThreadProc(LPVOID lpParameter)
{
((CXBoxSample *)(lpParameter))->UpdatePeakLevels();
// should never return
return (0);
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    if( FAILED( InitDirectMusic() ) )
        return E_FAIL;

    if( FAILED( m_FontBig.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_FontSmall.Create( m_pd3dDevice, "font12.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create help
    if( FAILED( m_Help.Create( m_pd3dDevice, "Gamepad.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    DirectSoundCreate( NULL, &m_pDSound, NULL );
    if( FAILED( DownloadScratch( "D:\\media\\dsstdfx.bin" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    DirectSoundUseFullHRTF();

    m_bDrawHelp = FALSE;

// Start thread that checks for DSP refresh calls from DSPBuilder
    CDSPServer::Run(m_pDSound, 80, 1000, PreDownloadEffectsImage,
                    DownloadEffectsImage);

// Start thread that runs calculations on RMS effect (if present)
// Not needed if main render loop is fast enough
//  CreateThread (NULL, 0, ThreadProc, this, 0, NULL);

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 || pGamePad->fY1 || pGamePad->fX2 || pGamePad->fX2  )
        return TRUE;

    // Nothing active
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    const XBGAMEPAD* pGamepad = GetPrimaryController();
    if( pGamepad )
    {
        // Toggle help
        if( pGamepad->wPressedButtons & XINPUT_GAMEPAD_BACK ) 
        {
            m_bDrawHelp = !m_bDrawHelp;
        }

        // NEW - reset peak levels
        if ( m_DefaultGamepad.bPressedAnalogButtons[ XINPUT_GAMEPAD_A ] && m_bDisplayRMS)
        {
            DSOUTPUTLEVELS dsLevels;
            for (int k=0; k<PEAK_NUM_BINS; k++)
            {
                m_fMaxLevels[k] = 0.0f;
            } 
            m_pDSound->GetOutputLevels(&dsLevels, TRUE);
        }

        // Adjust volume
        /*
        m_fVolume += pGamepad->fY1 * m_fElapsedTime * 100.0f;
        if( m_fVolume <   1.0f )   m_fVolume =   1.0f;
        if( m_fVolume > 100.0f )   m_fVolume = 100.0f;
        SetVolume( (INT)m_fVolume);
        */

        // Adjust sound
        /*
        m_fGrooveLevel += pGamepad->fY2 * m_fElapsedTime * 100.0f;
        if( m_fGrooveLevel <   1.0f )   m_fGrooveLevel =   1.0f;
        if( m_fGrooveLevel > 100.0f )   m_fGrooveLevel = 100.0f;
        SetGrooveLevel( (INT)(m_fGrooveLevel - 50) );
        */

        // Play sound based on button pressed
        /*
        if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_X] ) 
            PlaySound( g_pSound1 );

        if( pGamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_A] ) 
            PlaySound( g_pSound2 );
        */

        // Handle requests for debug output
        /*
        if( m_DefaultGamepad.bPressedAnalogButtons[0] )
        {
            DCCMDPrintf("Framerate is %s\n", m_strFrameRate );
        }
        if( m_DefaultGamepad.bPressedAnalogButtons[1]  )
        {
            DCCMDPrintf("Current texture is %s\n", m_szTexFile );
        }
        */
    }

    // Process any pending commands from the debug channel
    DCHandleCmds(); 

    // Process any pending buffers
    //DCHandleBuffers();


    // NEW - Do Fast Fourier Transform for volume LED display
//  if (m_bDisplayRMS)
//      FourierTransform(); 

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
    EnterCriticalSection(&g_cs);
    
    /* Replaced by DirectMusic's own thread
    // Give DM a chance to keep playing. The quantum is the amount of time in
    // mS we expect until DirectMusicDoWork() will be called again. At 60fps,
    // the quantum is 16.667.
    const DWORD dwFps = 60;
    const DWORD dwQuantum = 1000 / dwFps;
    DirectMusicDoWork( dwQuantum );
    */

    DMUS_NOTIFICATION_PMSG *pNotificationMsg;
    // S_FALSE means no more messages, and pNotificationMsg is NULL
    if( S_OK == g_pPerformance->GetNotificationPMsg( &pNotificationMsg ) )
    {
        if( GUID_NOTIFICATION_SEGMENT == pNotificationMsg->guidNotificationType )
        {
            HandleSegmentNotification( pNotificationMsg );
        }
        g_pPerformance->FreePMsg( reinterpret_cast<DMUS_PMSG*>(pNotificationMsg) );
    }

    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, 0xff0000ff, 1.0f, 0L );

    // Begin the scene
    m_pd3dDevice->BeginScene();
    RenderGradientBackground( 0xff404040, 0xff404080 );

    // Show title, frame rate, and help
    if( m_bDrawHelp )
        m_Help.Render( &m_FontBig, g_HelpCallouts, NUM_HELP_CALLOUTS );
    else
    {
        /*
        m_FontBig.DrawText( 64, 150, 0xffffff00, L"Volume:" );
        {
            struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
            BACKGROUNDVERTEX v[4];
            FLOAT x1 = 200, x2 = x1 + (340*m_fVolume)/100;
            FLOAT y1 = 152, y2 = y1 + 20;
            v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffffff;
            v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffffff;
            v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xffff0000;
            v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xffff0000;

            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
            m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
        }
        */

        /*
        m_FontBig.DrawText( 64, 200, 0xffffff00, L"Groove Level:" );
        {
            struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
            BACKGROUNDVERTEX v[4];
            FLOAT x1 = 200, x2 = x1 + (340*m_fGrooveLevel)/100;
            FLOAT y1 = 200, y2 = y1 + 20;
            v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffffff;
            v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffffff;
            v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xff00ff00;
            v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xff00ff00;

            m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
            m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
        }
        // Display the groove level number
        {
            WCHAR wcstr[MAX_PATH];
            wsprintfW(wcstr, L"(%d)", (INT)(m_fGrooveLevel - 50) );
            m_FontBig.DrawText( 64, 220, 0xffffff00, wcstr );
        }
        */

        // Synth stats
/*      if( g_pIDirectMusicPort )
        {
            DMUS_SYNTHSTATS8 dmSynthStats;
            ZeroMemory( &dmSynthStats, sizeof( DMUS_SYNTHSTATS8 ) );
            dmSynthStats.dwSize = sizeof( DMUS_SYNTHSTATS8 );
            if( SUCCEEDED( g_pIDirectMusicPort->GetRunningStats( (LPDMUS_SYNTHSTATS)&dmSynthStats ) ) )
            {
                WCHAR wcstr[MAX_PATH];
                if( dmSynthStats.dwValidStats & DMUS_SYNTHSTATS_VOICES )
                {
                    wsprintfW(wcstr, L"%d", dmSynthStats.dwVoices );
                    m_FontBig.DrawText( 64, 250, 0xffffff00, L"Voices" );
                    m_FontBig.DrawText( 300, 250, 0xffffff00, wcstr );
                }
                if( dmSynthStats.dwValidStats & DMUS_SYNTHSTATS_TOTAL_CPU )
                {
                    wsprintfW(wcstr, L"%d.%d%%", dmSynthStats.dwTotalCPU/100, dmSynthStats.dwTotalCPU%100 );
                    m_FontBig.DrawText( 64, 270, 0xffffff00, L"Total CPU" );
                    m_FontBig.DrawText( 300, 270, 0xffffff00, wcstr );
                }
                if( dmSynthStats.dwValidStats & DMUS_SYNTHSTATS_CPU_PER_VOICE )
                {
                    wsprintfW(wcstr, L"%d.%d%%", dmSynthStats.dwCPUPerVoice/100, dmSynthStats.dwCPUPerVoice%100 );
                    m_FontBig.DrawText( 64, 290, 0xffffff00, L"CPU per voice" );
                    m_FontBig.DrawText( 300, 290, 0xffffff00, wcstr );
                }
                if( dmSynthStats.dwValidStats & DMUS_SYNTHSTATS_LOST_NOTES )
                {
                    wsprintfW(wcstr, L"%d", dmSynthStats.dwLostNotes );
                    m_FontBig.DrawText( 64, 310, 0xffffff00, L"Lost notes" );
                    m_FontBig.DrawText( 300, 310, 0xffffff00, wcstr );
                }
                if( dmSynthStats.dwValidStats & DMUS_SYNTHSTATS_PEAK_VOLUME )
                {
                    wsprintfW(wcstr, L"%ddb", dmSynthStats.lPeakVolume );
                    m_FontBig.DrawText( 64, 330, 0xffffff00, L"Peak volume" );
                    m_FontBig.DrawText( 300, 330, 0xffffff00, wcstr );
                }
                if( dmSynthStats.dwValidStats & DMUS_SYNTHSTATS_FREE_MEMORY )
                {
                    wsprintfW(wcstr, L"%d", dmSynthStats.dwFreeMemory );
                    m_FontBig.DrawText( 64, 350, 0xffffff00, L"Free memory" );
                    m_FontBig.DrawText( 300, 350, 0xffffff00, wcstr );
                }
                wsprintfW(wcstr, L"%d", dmSynthStats.dwSynthMemUse );
                m_FontBig.DrawText( 64, 370, 0xffffff00, L"Memory use" );
                m_FontBig.DrawText( 300, 370, 0xffffff00, wcstr );
            }
        }*/

        WCHAR szString[256];
        swprintf (szString,L"Audio Console App with DSP Server (%i)", _XTL_VER);
        m_FontBig.DrawText(  64, 50, 0xffffffff, szString);
        
        CConnectionItem *pConnection = (CConnectionItem *)m_lstConnections.GetHead();

        if(pConnection)
        {
            DWORD dwOffset = 80;

            while(pConnection)
            {
                MultiByteToWideChar(CP_ACP, 0, pConnection->m_szName, -1, szString, sizeof(szString) / sizeof(szString[0]));
                wcscat(szString, L" connected");
                
                m_FontBig.DrawText( 64, (FLOAT)dwOffset, 0xffffff00, szString );
                
                dwOffset += 20;

                pConnection = pConnection->GetNext();
            }

            dwOffset += 20;

            if( m_bSynthInitialized )
            {
				DWORD dwTicks = GetTickCount();
				if (m_fMIDICounter != m_fLastMIDICounterValue)
				{
					m_fLastMIDICounterValue = m_fMIDICounter;
					m_dwMIDIIndicatorOnTime = dwTicks;
				}
				if ((dwTicks - m_dwMIDIIndicatorOnTime) > MIDI_INDICATOR_OFF_DELAY)
					m_FontBig.DrawText( 64, (FLOAT)dwOffset, 0xff666666, L"MIDI idle");
				else
					m_FontBig.DrawText( 64, (FLOAT)dwOffset, 0xff00aa00, L"MIDI received" );
			}
        }
        else
        {
            m_FontBig.DrawText( 110, 160, 0xffffff00, L"This tool is designed for composers and sound" );
            m_FontBig.DrawText( 110, 180, 0xffffff00, L"designers to audition their content on the Xbox" );
            m_FontBig.DrawText( 110, 200, 0xffffff00, L"hardware.  It is used in conjunction with PC-" );
            m_FontBig.DrawText( 110, 220, 0xffffff00, L"based audio tools, such as DirectMusic Producer");
            m_FontBig.DrawText( 110, 240, 0xffffff00, L"for Xbox, Xbox Wave Bundler, and DSP Builder,");
            m_FontBig.DrawText( 110, 260, 0xffffff00, L"which manage content and effects program" );
            m_FontBig.DrawText( 110, 280, 0xffffff00, L"downloading to the Xbox as well as playback of");
            m_FontBig.DrawText( 110, 300, 0xffffff00, L"that content. For more information, please" );
            m_FontBig.DrawText( 110, 320, 0xffffff00, L"consult the tools chapter of the Audio Best" );
			m_FontBig.DrawText( 110, 340, 0xffffff00, L"Practices Guide at https://xds.xbox.com");
        }
        // NEW - Draw Volume LEDs
// Probably needs critical section to handle when effects program changed via DSP Builder
//      EnterCriticalSection(&m_criticalSection);
        if (m_bDisplayRMS)
        {
            UpdatePeakLevels();
            RenderPeakLevels();
        }
//      LeaveCriticalSection(&m_criticalSection);
    }
    // End scene
    m_pd3dDevice->EndScene();

    LeaveCriticalSection(&g_cs);
    
    WbCheckStatusAll();

    return S_OK;
}

//-----------------------------------------------------------------------------
// Adds a remote connection to the application.
//-----------------------------------------------------------------------------
void CXBoxSample::AddConnection(LPCSTR pszConnection)
{
    CConnectionItem *       pConnection;
    
    EnterCriticalSection(&g_cs);
    
    if(pConnection = new CConnectionItem)
    {
        strncpy(pConnection->m_szName, pszConnection, sizeof(pConnection->m_szName));
        m_lstConnections.AddTail(pConnection);
    }

    LeaveCriticalSection(&g_cs);
}

//-----------------------------------------------------------------------------
// Removes a remote connection to the application.
//-----------------------------------------------------------------------------
void CXBoxSample::RemoveConnection(LPCSTR pszConnection)
{
    CConnectionItem *       pConnection;
    
    EnterCriticalSection(&g_cs);
    
    for(pConnection = (CConnectionItem *)m_lstConnections.GetHead(); pConnection; pConnection = pConnection->GetNext())
    {
        if(!strncmp(pConnection->m_szName, pszConnection, sizeof(pConnection->m_szName)))
        {
            m_lstConnections.Remove(pConnection);
            delete pConnection;

            break;
        }
    }

    LeaveCriticalSection(&g_cs);
}

//-----------------------------------------------------------------------------
// Name: SendNotification()
// Desc: Sends a notification with an encoded HRESULT
//-----------------------------------------------------------------------------
void SendNotification( char *strName, DWORD dwData1, DWORD dwData2 )
{
    // Pass the result back to the Windows application
    char strNotification[CCH_MAXCMDLEN];

    // Zero buffer
    ZeroMemory( strNotification, sizeof(char) * CCH_MAXCMDLEN );

    // Copy command prefix and name
    strcpy( strNotification, g_szCmd );
    strcat( strNotification, strName );

    char strNumber[16];

    // Add dwData1
    _itoa( dwData1, strNumber, 10 );
    strcat( strNotification, strNumber );

    if( dwData2 != 0xFFFFFFFF )
    {
        // Add a space
        strcat( strNotification, " " );

        // Add dwData2
        _itoa( dwData2, strNumber, 10 );
        strcat( strNotification, strNumber );
    }

    DmSendNotificationString( strNotification );
}

//-----------------------------------------------------------------------------
// Name: HandleSegmentNotification()
// Desc: Handle a segment notification
//-----------------------------------------------------------------------------
void CXBoxSample::HandleSegmentNotification( DMUS_NOTIFICATION_PMSG *pNotificationMsg )
{
    if( pNotificationMsg->punkUser == NULL )
    {
        return;
    }

    // Find this segment
    CSegmentItem *pSegmentItem = (CSegmentItem *)g_xbApp.m_lstSegments.GetHead();
    while( pSegmentItem )
    {
        if( pSegmentItem->m_pSegmentState8 == pNotificationMsg->punkUser )
        {
            break;
        }
        pSegmentItem = pSegmentItem->GetNext();
    }

    // If we found the segment
    if( pSegmentItem )
    {
        // If we're stopping, release our segment state
        if( (pNotificationMsg->dwNotificationOption == DMUS_NOTIFICATION_SEGEND)
        ||  (pNotificationMsg->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT) )
        {
            pSegmentItem->m_pSegmentState8->Release();
            pSegmentItem->m_pSegmentState8 = NULL;
        }

        // Pass the notification on the the Windows application
        SendNotification( "!Segment ", pSegmentItem->m_dwSegmentID, pNotificationMsg->dwNotificationOption );
    }
}


//-----------------------------------------------------------------------------
// Name: Adds a connection to the application.
//-----------------------------------------------------------------------------
void RCmdAddConnection(int argc, char *argv[])
{
    CHAR                    szName[0x100];
    int                     i;
    
    if(argc < 2)
    {
        OutputDebugString("Invalid number of arguments");
        return;
    }

    strcpy(szName, argv[1]);

    for(i = 2; i < argc; i++)
    {
        strcat(szName, " ");
        strcat(szName, argv[i]);
    }

    g_xbApp.AddConnection(szName);
}


//-----------------------------------------------------------------------------
// Name: Removes a connection to the application.
//-----------------------------------------------------------------------------
void RCmdRemoveConnection(int argc, char *argv[])
{
    CHAR                    szName[0x100];
    int                     i;
    
    if(argc < 2)
    {
        OutputDebugString("Invalid number of arguments");
        return;
    }

    strcpy(szName, argv[1]);

    for(i = 2; i < argc; i++)
    {
        strcat(szName, " ");
        strcat(szName, argv[i]);
    }

    g_xbApp.RemoveConnection(szName);
}


//-----------------------------------------------------------------------------
// Name: Initializes the Xbox Experimenter functions
//-----------------------------------------------------------------------------
void RCmdInitializeExperimenter(int argc, char *argv[])
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
    
    g_xbApp.AddConnection(XBOX_EXPERIMENTER_NAME);
}


//-----------------------------------------------------------------------------
// Name: Uninitializes the Xbox Experimenter functions
//-----------------------------------------------------------------------------
void RCmdUninitializeExperimenter(int argc, char *argv[])
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
    
    // Stop the performance
    g_pPerformance->StopEx( 0, 0, 0 );

    // Wait for everything to really stop
    Sleep(10);

    // Clear the default audiopath and port
    g_pPerformance->SetDefaultAudioPath( NULL );
/*  if( g_pIDirectMusicPort )
    {
        g_pIDirectMusicPort->Release();
        g_pIDirectMusicPort = NULL;
    }*/

    // Delete all the segments
    while( !g_xbApp.m_lstSegments.IsEmpty() )
    {
        // Get the first segment
        CSegmentItem *pSegmentItem = (CSegmentItem *)g_xbApp.m_lstSegments.RemoveHead();

        // If the segment state exists, stop it
        if( pSegmentItem->m_pSegmentState8 )
        {
            g_pPerformance->StopEx( pSegmentItem->m_pSegmentState8, 0, 0 );
            pSegmentItem->m_pSegmentState8->Release();
            pSegmentItem->m_pSegmentState8 = NULL;
        }

        // Unload the segment
        if( pSegmentItem->m_pSegment8 )
        {
            pSegmentItem->m_pSegment8->Unload( g_pPerformance );

            // Release the segment
            pSegmentItem->m_pSegment8->Release();
            pSegmentItem->m_pSegment8 = NULL;
        }

        // Delete the item
        delete pSegmentItem;
    }

    // Delete all the audiopaths
    while( !g_xbApp.m_lstAudiopaths.IsEmpty() )
    {
        CAudiopathItem *pAudiopathItem = (CAudiopathItem *)g_xbApp.m_lstAudiopaths.RemoveHead();

        // Release the Audiopath
        if( pAudiopathItem->m_pAudiopath8 )
        {
            pAudiopathItem->m_pAudiopath8->Release();
            pAudiopathItem->m_pAudiopath8 = NULL;
        }

        // Delete the item
        delete pAudiopathItem;
    }

    //ASSERT( g_xbApp.m_lstScripts.IsEmpty() );

    g_xbApp.RemoveConnection(XBOX_EXPERIMENTER_NAME);
}


//-----------------------------------------------------------------------------
// Name: RCmdPlay
// Desc: Sets the new texture to be used
//-----------------------------------------------------------------------------
void RCmdPlay(int argc, char *argv[])
{
    HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 5 )
    {
        DCCMDPrintf("Need to specify a segment ID, flags, audiopathID, and default audiopath ID \n");
        hr = E_INVALIDARG;
    }

    DWORD dwSegmentID = 0xFFFFFFFF;
    CSegmentItem *pSegmentItem = NULL;

    if( SUCCEEDED(hr) )
    {
        dwSegmentID = atoi(argv[1]);

        // Ensure this segment exists
        CSegmentItem *pSegmentTmp = (CSegmentItem *)g_xbApp.m_lstSegments.GetHead();
        while( pSegmentTmp )
        {
            if( dwSegmentID == pSegmentTmp->m_dwSegmentID )
            {
                pSegmentItem = pSegmentTmp;
                break;
            }
            pSegmentTmp = pSegmentTmp->GetNext();
        }
    }

    if( NULL == pSegmentItem )
    {
        OutputDebugString( "RCmdPlay: Segment ID not found\n" );
        hr = E_INVALIDARG;
    }

    // Ensure this segment isn't already playing
    if( SUCCEEDED(hr) )
    {
        if( pSegmentItem->m_pSegmentState8 )
        {
            OutputDebugString( "RCmdPlay: Segment already playing\n" );
            hr = E_FAIL;
        }
    }

    DWORD dwPlayFlags = 0;
    DWORD dwAudiopathID = 0;
    DWORD dwStandardAudiopathID = 0;
    IDirectMusicAudioPath *pIDirectMusicAudioPath = NULL;
    
    if( SUCCEEDED(hr) )
    {
        dwPlayFlags = atoi(argv[2]);
        dwAudiopathID = atoi(argv[3]);
        dwStandardAudiopathID = atoi(argv[4]);

        // If specified, ensure this audiopath exists
        if( dwAudiopathID )
        {
            CAudiopathItem *pAudiopathTmp = (CAudiopathItem *)g_xbApp.m_lstAudiopaths.GetHead();
            while( pAudiopathTmp )
            {
                if( dwAudiopathID == pAudiopathTmp->m_dwAudiopathID )
                {
                    pIDirectMusicAudioPath = pAudiopathTmp->m_pAudiopath8;
                    if( pIDirectMusicAudioPath)
                    {
                        pIDirectMusicAudioPath->AddRef();
                    }
                    break;
                }
                pAudiopathTmp = pAudiopathTmp->GetNext();
            }
        }

        // If specified, create a standard audiopath
        if( !pIDirectMusicAudioPath
        &&  dwStandardAudiopathID )
        {
            hr = g_pPerformance->CreateStandardAudioPath( dwStandardAudiopathID, 128, TRUE, &pIDirectMusicAudioPath );

            if( FAILED(hr)
            ||  !pIDirectMusicAudioPath )
            {
                OutputDebugString( "RCmdPlay: Unable to create standard Audiopath\n" );
                if( SUCCEEDED(hr) )
                {
                    hr = E_INVALIDARG;
                }
            }
        }
    }

    if( SUCCEEDED(hr)
    &&  dwAudiopathID
    &&  NULL == pIDirectMusicAudioPath )
    {
        OutputDebugString( "RCmdPlay: Audiopath ID not found\n" );
        hr = E_INVALIDARG;
    }

    IDirectMusicSegmentState8 *pIDirectMusicSegmentState8 = NULL;

    // Play segment on the default audio path 
    if( SUCCEEDED(hr) ) 
    { // DMUS_SEGF_SEGMENTEND | DMUS_SEGF_ALIGN | DMUS_SEGF_VALID_START_TICK 
//        pSegmentItem->m_pSegment8->SetStartPoint(768*19);
        hr = g_pPerformance->PlaySegmentEx( pSegmentItem->m_pSegment8, NULL, NULL, dwPlayFlags ,  
                                            0, &pIDirectMusicSegmentState8, NULL, pIDirectMusicAudioPath );
    } 
  
    if( SUCCEEDED( hr ) ) 
    {
        // Save the segment state
        // No need to AddRef() - PlaySegmentEx did that for us
        pSegmentItem->m_pSegmentState8 = pIDirectMusicSegmentState8;
    }

    if( pIDirectMusicAudioPath) 
    { 
        pIDirectMusicAudioPath->Release();
    }

    // Pass the result back to the Windows application
    SendNotification( "!PlayResult ", dwSegmentID, hr );
}

//-----------------------------------------------------------------------------
// Name: RCmdStop
// Desc: Stops the segment
//-----------------------------------------------------------------------------
void RCmdStop(int argc, char *argv[])
{
    // Check our arguments
    if( argc < 3 )
    {
        DCCMDPrintf("Need to specify an ID and flags\n");
        return;
    }

    const DWORD dwSegmentID = atoi(argv[1]);
    const DWORD dwStopFlags = atoi(argv[2]);

    CSegmentItem *pSegmentItem = (CSegmentItem *)g_xbApp.m_lstSegments.GetHead();
    while( pSegmentItem )
    {
        if( dwSegmentID == pSegmentItem->m_dwSegmentID )
        {
            if( pSegmentItem->m_pSegmentState8 )
            {
                g_pPerformance->StopEx( pSegmentItem->m_pSegmentState8, 0, 0 );
                // Don't release the segment state here - wait for the SEGABORT notification
            }
            else
            {
                OutputDebugString( "RCmdStop: Segment not playing\n" );
            }

            return;
        }
        pSegmentItem = pSegmentItem->GetNext();
    }

    if( NULL == pSegmentItem )
    {
        OutputDebugString( "RCmdStop: Segment not found\n" );
    }
}

//-----------------------------------------------------------------------------
// Name: RCmdChange
// Desc: Called after changing one of our lighting values, so that we can
//       reset the light
//-----------------------------------------------------------------------------
void RCmdChange( void * pvAddr )
{
    //g_pd3dDevice->SetLight( 0, &g_xbApp.m_Light );
}

//-----------------------------------------------------------------------------
// Name: RCmdSearchDirectory
// Desc: sets the search directory
//-----------------------------------------------------------------------------
void RCmdSearchDirectory(int argc, char *argv[])
{
    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify the search directory\n");
        return;
    }

    // Tell DirectMusic where the default search path is
    g_pLoader->SetSearchDirectory( GUID_DirectMusicAllTypes, 
                                   argv[1], TRUE );
}

//-----------------------------------------------------------------------------
// Name: RCmdClearCache
// Desc: clears the cache
//-----------------------------------------------------------------------------
void RCmdClearCache(int argc, char *argv[])
{
    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( argv );

    // Tell DirectMusic to clear its cache
    HRESULT hr = g_pLoader->ClearCache( GUID_DirectMusicAllTypes );

    // Pass the result back to the Windows application
    SendNotification( "!ClearCacheResult ", hr, 0xFFFFFFFF );
}

//-----------------------------------------------------------------------------
// Name: RCmdLoad
// Desc: loads a segment
//-----------------------------------------------------------------------------
void RCmdLoad(int argc, char *argv[])
{
    HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 3 )
    {
        DCCMDPrintf("Need to specify the ID and filename\n");
        hr = E_INVALIDARG;
    }

    DWORD dwSegmentID = 0xFFFFFFFF;
    CSegmentItem *pSegmentItem = NULL;
    
    if( SUCCEEDED(hr) )
    {
        dwSegmentID = atoi(argv[1]);

        // Ensure this segment ID doesn't exist
        pSegmentItem = (CSegmentItem *)g_xbApp.m_lstSegments.GetHead();
        while( pSegmentItem )
        {
            if( dwSegmentID == pSegmentItem->m_dwSegmentID )
            {
                OutputDebugString( "RCmdLoad: Segment ID already in use\n" );
                hr = E_INVALIDARG;
                break;
            }
            pSegmentItem = pSegmentItem->GetNext();
        }
    }

    // Load segment
    IDirectMusicSegment8 *pIDirectMusicSegment8 = NULL;
    if( SUCCEEDED(hr) )
    {
        hr = g_pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment, IID_IDirectMusicSegment8, 
                                            argv[2], (VOID**)&pIDirectMusicSegment8 );
    }
 
    if( SUCCEEDED( hr ) )
    {
        // Download music
        hr = pIDirectMusicSegment8->Download( g_pPerformance );
    }

    if( SUCCEEDED( hr ) )
    {
        // Add segment to list
        pSegmentItem = new CSegmentItem;
        pSegmentItem->m_dwSegmentID = dwSegmentID;
        pSegmentItem->m_pSegment8 = pIDirectMusicSegment8;
        pSegmentItem->m_pSegment8->AddRef();
        g_xbApp.m_lstSegments.AddHead( pSegmentItem );
    }

    // Release segment
    if( pIDirectMusicSegment8 )
    {
        pIDirectMusicSegment8->Release();
    }

    // Pass the result back to the Windows application
    SendNotification( "!LoadResult ", dwSegmentID, hr );
}

//-----------------------------------------------------------------------------
// Name: RCmdUnload
// Desc: unloads a segment
//-----------------------------------------------------------------------------
void RCmdUnload(int argc, char *argv[])
{
    HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify the ID\n");
        hr = E_INVALIDARG;
    }

    DWORD dwSegmentID = 0xFFFFFFFF;
    CSegmentItem *pSegmentItem = NULL;
    if( SUCCEEDED(hr) )
    {
        dwSegmentID = atoi(argv[1]);

        // Ensure this segment ID exists
        CSegmentItem *pSegmentTemp = (CSegmentItem *)g_xbApp.m_lstSegments.GetHead();
        while( pSegmentTemp )
        {
            if( dwSegmentID == pSegmentTemp->m_dwSegmentID )
            {
                pSegmentItem = pSegmentTemp;
                break;
            }
            pSegmentTemp = pSegmentTemp->GetNext();
        }
    }

    if( NULL == pSegmentItem )
    {
        OutputDebugString( "RCmdUnload: Segment ID not found\n" );
        hr = E_INVALIDARG;
    }

    // If the segment state exists, stop it
    if( SUCCEEDED(hr)
    &&  pSegmentItem->m_pSegmentState8 )
    {
        g_pPerformance->StopEx( pSegmentItem->m_pSegmentState8, 0, 0 );
        pSegmentItem->m_pSegmentState8->Release();
        pSegmentItem->m_pSegmentState8 = NULL;
    }

    // Unload the segment
    if( SUCCEEDED(hr) )
    {
        hr = pSegmentItem->m_pSegment8->Unload( g_pPerformance );
    }

    if( pSegmentItem )
    {
        // Release the segment
        pSegmentItem->m_pSegment8->Release();
        pSegmentItem->m_pSegment8 = NULL;

        // Remove the item from the list
        g_xbApp.m_lstSegments.Remove( pSegmentItem );

        // Delete the item
        delete pSegmentItem;
    }

    // Pass the result back to the Windows application
    SendNotification( "!UnloadResult ", dwSegmentID, hr );
}

//-----------------------------------------------------------------------------
// Name: RCmdPanic
// Desc: Stop everything
//-----------------------------------------------------------------------------
void RCmdPanic(int argc, char *argv[])
{
    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( argv );

    // Stop all segments
    CSegmentItem *pSegmentItem = (CSegmentItem *)g_xbApp.m_lstSegments.GetHead();
    while( pSegmentItem )
    {
        if( pSegmentItem->m_pSegmentState8 )
        {
            g_pPerformance->StopEx( pSegmentItem->m_pSegmentState8, 0, 0 );
            pSegmentItem->m_pSegmentState8->Release();
            pSegmentItem->m_pSegmentState8 = NULL;
        }
        pSegmentItem = pSegmentItem->GetNext();
    }

    // Stop the performance
    HRESULT hr = g_pPerformance->StopEx( 0, 0, 0 );

    // Pass the result back to the Windows application
    SendNotification( "!PanicResult ", hr, 0xFFFFFFFF );
}

//-----------------------------------------------------------------------------
// Name: RCmdCreateAudiopath
// Desc: Loads and instantiates an audiopath
//-----------------------------------------------------------------------------
void RCmdCreateAudiopath(int argc, char *argv[])
{
    HRESULT hr = S_OK;

    bool fCreateStandard = false;
    // Check if we should create a standard audiopath
    if(dbgstrcmpn("createStandardAudiopath", argv[0], dbgstrlen("createStandardAudiopath")))
    {
        fCreateStandard = true;
    }

    // Check our arguments
    if( fCreateStandard )
    {
        if( argc < 4 )
        {
            DCCMDPrintf("Need to specify the ID, type, and # of PChannels\n");
            hr = E_INVALIDARG;
        }
    }
    else
    {
        if( argc < 3 )
        {
            DCCMDPrintf("Need to specify the ID and filename\n");
            hr = E_INVALIDARG;
        }
    }

    DWORD dwAudiopathID = 0xFFFFFFFF;
    CAudiopathItem *pAudiopathItem = NULL;
    
    if( SUCCEEDED(hr) )
    {
        dwAudiopathID = atoi(argv[1]);

        // Ensure this audiopath ID doesn't exist
        pAudiopathItem = (CAudiopathItem *)g_xbApp.m_lstAudiopaths.GetHead();
        while( pAudiopathItem )
        {
            if( dwAudiopathID == pAudiopathItem->m_dwAudiopathID )
            {
                OutputDebugString( "RCmdCreateAudiopath: Audiopath ID already in use\n" );
                hr = E_INVALIDARG;
                break;
            }
            pAudiopathItem = pAudiopathItem->GetNext();
        }
    }

    // Initialize variables
    IUnknown *punkAudiopathConfig = NULL;
    IDirectMusicAudioPath8 *pIDirectMusicAudioPath8 = NULL;

    // Check if we should create a standard audiopath
    if(fCreateStandard)
    {
        // Create standard audiopath
        if( SUCCEEDED(hr) )
        {
            DWORD dwType = atoi(argv[2]);
            DWORD dwPChannels = atoi(argv[3]);
            hr = g_pPerformance->CreateStandardAudioPath( dwType, dwPChannels, TRUE, &pIDirectMusicAudioPath8 );
        }
    }
    else
    {
        // Load audiopath config
        if( SUCCEEDED(hr) )
        {
            hr = g_pLoader->LoadObjectFromFile( CLSID_DirectMusicAudioPathConfig, IID_IUnknown,
                                                argv[2], (VOID**)&punkAudiopathConfig );
        }
 
        // Create the audiopath
        if( SUCCEEDED( hr ) )
        {
            hr = g_pPerformance->CreateAudioPath( punkAudiopathConfig, TRUE, &pIDirectMusicAudioPath8 );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        // Add audiopath to list
        pAudiopathItem = new CAudiopathItem;
        pAudiopathItem->m_dwAudiopathID = dwAudiopathID;
        pAudiopathItem->m_pAudiopath8 = pIDirectMusicAudioPath8;
        pAudiopathItem->m_pAudiopath8->AddRef();
        g_xbApp.m_lstAudiopaths.AddHead( pAudiopathItem );
    }

    // Release audiopath config
    if( punkAudiopathConfig )
    {
        punkAudiopathConfig->Release();
    }

    // Release audiopath
    if( pIDirectMusicAudioPath8 )
    {
        pIDirectMusicAudioPath8->Release();
    }

    // Pass the result back to the Windows application
    SendNotification( "!CreateResult ", dwAudiopathID, hr );
}

//-----------------------------------------------------------------------------
// Name: RCmdSetDefaultAudiopath
// Desc: Sets the default audiopath
//-----------------------------------------------------------------------------
void RCmdSetDefaultAudiopath(int argc, char *argv[])
{
    HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify an audiopath ID\n");
        hr = E_INVALIDARG;
    }

    DWORD dwAudiopathID = 0xFFFFFFFF;
    CAudiopathItem *pAudiopathItem = NULL;

    if( SUCCEEDED(hr) )
    {
        dwAudiopathID = atoi(argv[1]);

        // Ensure this audiopath exists
        CAudiopathItem *pAudiopathTmp = (CAudiopathItem *)g_xbApp.m_lstAudiopaths.GetHead();
        while( pAudiopathTmp )
        {
            if( dwAudiopathID == pAudiopathTmp->m_dwAudiopathID )
            {
                pAudiopathItem = pAudiopathTmp;
                break;
            }
            pAudiopathTmp = pAudiopathTmp->GetNext();
        }
    }

    if( NULL == pAudiopathItem )
    {
        OutputDebugString( "RCmdSetDefaultAudiopath: Audiopath ID not found\n" );
        hr = E_INVALIDARG;
    }

    // Set as default audiopath
    if( SUCCEEDED(hr) )
    {
        hr = g_pPerformance->SetDefaultAudioPath( pAudiopathItem->m_pAudiopath8 );
    }

    // Get the default port
    if( SUCCEEDED(hr) )
    {
/*      if( g_pIDirectMusicPort )
        {
            g_pIDirectMusicPort->Release();
            g_pIDirectMusicPort = NULL;
        }*/

/*      pAudiopathItem->m_pAudiopath8->GetObjectInPath( DMUS_PCHANNEL_ALL, DMUS_PATH_PORT, 0,
            GUID_All_Objects, 0, IID_IDirectMusicPort, (void **)&g_pIDirectMusicPort );*/
    }

    // Pass the result back to the Windows application
    SendNotification( "!SetDefaultResult ", dwAudiopathID, hr );
}

//-----------------------------------------------------------------------------
// Name: RCmdReleaseAudiopath
// Desc: releases an audiopath
//-----------------------------------------------------------------------------
void RCmdReleaseAudiopath(int argc, char *argv[])
{
    HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify the ID\n");
        hr = E_INVALIDARG;
    }

    DWORD dwAudiopathID = 0xFFFFFFFF;
    CAudiopathItem *pAudiopathItem = NULL;
    if( SUCCEEDED(hr) )
    {
        dwAudiopathID = atoi(argv[1]);

        // Ensure this audiopath ID exists
        CAudiopathItem *pAudiopathTemp = (CAudiopathItem *)g_xbApp.m_lstAudiopaths.GetHead();
        while( pAudiopathTemp )
        {
            if( dwAudiopathID == pAudiopathTemp->m_dwAudiopathID )
            {
                pAudiopathItem = pAudiopathTemp;
                break;
            }
            pAudiopathTemp = pAudiopathTemp->GetNext();
        }
    }

    if( NULL == pAudiopathItem )
    {
        OutputDebugString( "RCmdReleaseAudiopath: Audiopath ID not found\n" );
        hr = E_INVALIDARG;
    }

    // Remove the audiopath as the default audiopath, if necessary
    if( SUCCEEDED(hr) )
    {
        IDirectMusicAudioPath8 *pIDirectMusicAudioPath8 = NULL;
        g_pPerformance->GetDefaultAudioPath( &pIDirectMusicAudioPath8 );
        if( pIDirectMusicAudioPath8 == pAudiopathItem->m_pAudiopath8 )
        {
            g_pPerformance->SetDefaultAudioPath( NULL );

/*          if( g_pIDirectMusicPort )
            {
                g_pIDirectMusicPort->Release();
                g_pIDirectMusicPort = NULL;
            }*/
        }

        if( pIDirectMusicAudioPath8 )
        {
            pIDirectMusicAudioPath8->Release();
        }

        // Release the Audiopath
        pAudiopathItem->m_pAudiopath8->Release();
        pAudiopathItem->m_pAudiopath8 = NULL;

        // Remove the item from the list
        g_xbApp.m_lstAudiopaths.Remove( pAudiopathItem );

        // Delete the item
        delete pAudiopathItem;
    }

    // Pass the result back to the Windows application
    SendNotification( "!ReleaseResult ", dwAudiopathID, hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\dspserver.h ===
#ifndef INCL_DMCONSOLE_DSPSERVER_H
#define INCL_DMCONSOLE_DSPSERVER_H

#include "..\..\..\..\..\test\multimedia\dsp\dspserver.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\DMConsole.h ===
#ifndef _DMCONSOLE_H_
#define _DMCONSOLE_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include "alist.h"

// NEW - USED FOR FFT
#include "dmusicip.h"

#define MAX_FREQUENCY_BINS	16384
#define M_PI	3.14159265358979323846
#define PEAK_NUM_BINS	8
#define HISTORY_BUFFER_SIZE	8
// --END NEW

extern const char *g_szCmd;

//-----------------------------------------------------------------------------
// Global DirectMusic variables
//-----------------------------------------------------------------------------
extern IDirectMusicLoader8*      g_pLoader;
extern IDirectMusicPerformance8* g_pPerformance;



//-----------------------------------------------------------------------------
// Name: class CSegmentItem
// Desc: Class for hosting a segment in a list item.
//-----------------------------------------------------------------------------
class CSegmentItem : public AListItem
{
public:
	CSegmentItem() : AListItem(), m_pSegment8(NULL), m_pSegmentState8(NULL), m_dwSegmentID(0xFFFFFFFF) {}

    IDirectMusicSegment8		*m_pSegment8;
    IDirectMusicSegmentState8   *m_pSegmentState8;
    DWORD                        m_dwSegmentID;

    CSegmentItem *GetNext() const {return (CSegmentItem *)m_pNext;};
};


//-----------------------------------------------------------------------------
// Name: class CAudiopathItem
// Desc: Class for hosting an audiopath in a list item.
//-----------------------------------------------------------------------------
class CAudiopathItem : public AListItem
{
public:
	CAudiopathItem() : AListItem(), m_pAudiopath8(NULL), m_dwAudiopathID(0xFFFFFFFF) {}

    IDirectMusicAudioPath8		*m_pAudiopath8;
    DWORD                        m_dwAudiopathID;

    CAudiopathItem *GetNext() const {return (CAudiopathItem *)m_pNext;};
};


//-----------------------------------------------------------------------------
// Name: class CScriptItem
// Desc: Class for hosting a script in a list item.
//-----------------------------------------------------------------------------
class CScriptItem : public AListItem
{
public:
	CScriptItem() : AListItem(), m_pScript8(NULL), m_dwScriptID(0xFFFFFFFF) {}

    IDirectMusicScript8			*m_pScript8;
    DWORD                        m_dwScriptID;

    CScriptItem *GetNext() const {return (CScriptItem *)m_pNext;};
};


//-----------------------------------------------------------------------------
// Name: class CDownloadItem
// Desc: Class for hosting a download buffer in a list item.
//-----------------------------------------------------------------------------
class CDownloadItem : public AListItem
{
public:
	CDownloadItem()
    {
        m_hHandle = NULL;
        m_pbBuffer = NULL;
    }

//    IDirectMusicDownload		*m_pIDirectMusicDownload;
//    DWORD                        m_dwXboxDownloadID;
//	DWORD						 m_dwPCDownloadID;
	DWORD						 m_dwUniqueID;
    HANDLE                      m_hHandle;
    BYTE *                      m_pbBuffer;
    CDownloadItem *GetNext() const {return (CDownloadItem *)m_pNext;};
};

//-----------------------------------------------------------------------------
// Name: class CConnectionItem
// Desc: Class for hosting a connection application.
//-----------------------------------------------------------------------------
class CConnectionItem : public AListItem
{
public:
    CHAR m_szName[64];

	CConnectionItem()
    {
        m_szName[0] = 0;
    }

    CConnectionItem *GetNext() const {return (CConnectionItem *)m_pNext;};
};


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Application class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Font
    CXBFont m_FontBig;      // Large font object
	CXBFont m_FontSmall;	// small font object
    CXBHelp m_Help;         // Help object
    BOOL    m_bDrawHelp;    // Should we draw help?
//	static CRITICAL_SECTION	m_criticalSection;

public:
    FLOAT   m_fGrooveLevel;
    FLOAT   m_fVolume;
	FLOAT	m_fMIDICounter;

	BOOL	m_bSynthInitialized;
	BOOL	m_bDisplayRMS;
    DWORD   m_dwEffectIndex;

	FLOAT	m_fLastMIDICounterValue;
	DWORD	m_dwMIDIIndicatorOnTime;

	LPDSEFFECTIMAGEDESC m_pEffectsImageDesc;

	FLOAT				m_fMaxLevels[PEAK_NUM_BINS];
	FLOAT				m_fLevelsHistoryBuffer[PEAK_NUM_BINS][HISTORY_BUFFER_SIZE];
	FLOAT				m_fHistoryBufferAverage[PEAK_NUM_BINS];
	FLOAT				m_fDisplayLevel[PEAK_NUM_BINS];
	DWORD				m_dwHistoryBufferIndex;

	AList	m_lstSegments;
	AList	m_lstAudiopaths;
	AList	m_lstScripts;
	AList	m_lstDownloads;
	AList	m_lstConnections;

    LPDIRECTSOUND8    m_pDSound;      // DSound object

    HRESULT Initialize();
    HRESULT FrameMove();
    HRESULT Render();
    void    HandleSegmentNotification( DMUS_NOTIFICATION_PMSG *pNotificationMsg );

    HRESULT DownloadScratch(PCHAR pszScratchFile);  // downloads a default DSP image to the GP

	// NEW - Methods for LED display for volume
	HRESULT UpdatePeakLevels();
	HRESULT RenderPeakLevels();

    CXBoxSample();

    void AddConnection(LPCSTR pszConnection);
    void RemoveConnection(LPCSTR pszConnection);
};



#endif // _DMCONSOLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\makefile.inc ===
#
# Standard inference rule for generating dsp files.
# Also includes rule for generating DSP scratch image
#

.SUFFIXES: .dsp .dsx .ini .bin .rdf .xpr

{}.dsx{$O}.dsp:
    m4 -DPROJNAME=$(PROJNAME) -DTARGETNAME=$(TARGETNAME) -DTITLEID=$(TITLEID) -DCOMMONSOURCEFILELIST= -DRELEASELIBS= -DDEBUGLIBS= $** > $(O)\tmp.m4
    m4 -DPOUND=# $(O)\tmp.m4 > $@
    del $(O)\tmp.m4
!ifndef NO_BINPLACE
    @!binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $@
!endif

dsstdfx:
    copy $(_NT386TREE)\$*.bin media

{}.ini{$O}.bin:
    set _XGPIMAGE_DSP_CODE_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\bin
    set _XGPIMAGE_INI_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\ini
    xgpimage $** $*.bin $*.h
    copy $*.bin media
    copy $*.h
!ifndef NO_BINPLACE
    @!binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $@
    @!binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $*.h
!endif


.rdf{$O}.xpr:
    bundler $** -o $*.xpr -h $*.h -e $*.err
    copy $*.xpr media
    copy $*.h

C_DEFINES=$(C_DEFINES) -D_USE_XGMATH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\fourier.cpp ===
#include <XBApp.h>
#include <XBFont.h>
#include <XBHelp.h>
#include <xgraphics.h>

// CHANGED - include DMConsole.h instead
// #include "dsptest.h"
#include "DMConsole.h"
#include "dsstdfx.h"
// END NEW


static const float SPECTRUM_LEFT_X = 250.;
static const float SPECTRUM_BOTTOM_Y = 300.;
static const float SPECTRUM_X_SIZE = 300.;
static const float SPECTRUM_Y_SIZE = 100.;

static const float SPECTRUM_NUM_BINS = 32.;

static const DWORD FFT_WINDOW_SIZE = 512;

// constants for graphical LED display
static const float PEAK_MONITOR_BAR_WIDTH = 20.;
static const float PEAK_MONITOR_BAR_SPACING = 35.;
static const float PEAK_MONITOR_DIGITAL_ANALOG_SPACING = 50;
static const float PEAK_MONITOR_LABEL_SPACING_Y = 10.0;
static const float PEAK_DISPLAY_BAR_HEIGHT = 2.0;
static const float PEAK_DISPLAY_BAR_OFFSET = 10.0;
static const float PEAK_MONITOR_LEFT_X = 100.;
static const float PEAK_MONITOR_BOTTOM_Y = 400.;
static const float PEAK_MONITOR_X_SIZE = 300.;
//static const float PEAK_MONITOR_Y_SIZE = 100.;
static const float PEAK_MONITOR_Y_MAX = 220.0;
static const float PEAK_MONITOR_MIN_DB = -60.0;
static const float PEAK_MONITOR_DB_AXIS_SCALE = 5.;
static const float PEAK_MONITOR_Y_HIGHVOLUME = (FLOAT)(PEAK_MONITOR_BOTTOM_Y-(.9*PEAK_MONITOR_Y_MAX)); 
static const float PEAK_MONITOR_Y_MIDVOLUME = (FLOAT)(PEAK_MONITOR_BOTTOM_Y-(.7*PEAK_MONITOR_Y_MAX));
//static const float PEAK_NORMALIZE_DISPLAY = 0.004f;


// based on 20 log(2) = 6.0206 , times 23 bits of amplitude for Xbox
// static const float XBOX_REFERENCE_DB = 138.47379800543134979831989157327;

static const float DISPLAY_DECAY_CONSTANT = 10.0;


//-----------------------------------------------------------------------------
// Name: UpdatePeakLevels
// Desc: Updates current level values (from RMS effect)
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::UpdatePeakLevels()
{
    

    // NEW turned levels into array, and coded to PEAK_NUM_BINS
    // FLOAT fLeftLevel=0.0, fRightLevel = 0.0, fValue = 0.;
    FLOAT fValue = 0.;
    // NEW - show LEDs for all six channels
    FLOAT fPeakLevels[PEAK_NUM_BINS];
    // Level to display ("smoothed out")
    FLOAT fHistoryBufferAverage_Previous;

    DirectSoundDoWork();

    // NEW - we're displaying with other AudConsole content, so don't start the scene or redraw

    //
    // get the data from dsound
    //

    DSOUTPUTLEVELS dsOutputLevels;
    memset(&dsOutputLevels, 0 ,sizeof(dsOutputLevels));

    m_pDSound->GetOutputLevels(&dsOutputLevels, FALSE);

    //
    // digital peak levels
    //

    fPeakLevels[DSMIXBIN_FRONT_LEFT] = (FLOAT) dsOutputLevels.dwDigitalFrontLeftPeak;
    fPeakLevels[DSMIXBIN_FRONT_RIGHT] = (FLOAT) dsOutputLevels.dwDigitalFrontRightPeak;
    fPeakLevels[DSMIXBIN_BACK_LEFT] = (FLOAT) dsOutputLevels.dwDigitalBackLeftPeak;
    fPeakLevels[DSMIXBIN_BACK_RIGHT] = (FLOAT) dsOutputLevels.dwDigitalBackRightPeak;
    fPeakLevels[DSMIXBIN_FRONT_CENTER] = (FLOAT) dsOutputLevels.dwDigitalFrontCenterPeak;
    fPeakLevels[DSMIXBIN_LOW_FREQUENCY] = (FLOAT) dsOutputLevels.dwDigitalLowFrequencyPeak;

    //
    // analog peak levels
    //

    fPeakLevels[DSMIXBIN_FRONT_LEFT+6] = (FLOAT) dsOutputLevels.dwAnalogLeftTotalPeak;
    fPeakLevels[DSMIXBIN_FRONT_RIGHT+6] = (FLOAT) dsOutputLevels.dwAnalogRightTotalPeak;


    for (DWORD k=0; k < PEAK_NUM_BINS; k ++)
    {
        fPeakLevels[k] = (FLOAT)(fPeakLevels[k]/pow(2,23));
        if (fPeakLevels[k] > m_fMaxLevels[k]) {
            m_fMaxLevels[k] = fPeakLevels[k];
        }

    // new - fill in history buffer and use for display
        fHistoryBufferAverage_Previous = m_fHistoryBufferAverage[k];

        m_fHistoryBufferAverage[k] += (fPeakLevels[k] - m_fLevelsHistoryBuffer[k][m_dwHistoryBufferIndex]) / HISTORY_BUFFER_SIZE;
        m_fLevelsHistoryBuffer[k][m_dwHistoryBufferIndex] = fPeakLevels[k];


/* Option 1 for current level display: Average of buffers (slow response, and doesn't show peaks)*/
        if (m_fHistoryBufferAverage[k] < fHistoryBufferAverage_Previous)
        // new level is lower than stored, so 'decay'
        {
            m_fDisplayLevel[k] = (FLOAT)(m_fHistoryBufferAverage[k]* exp(-(fHistoryBufferAverage_Previous-m_fHistoryBufferAverage[k])/DISPLAY_DECAY_CONSTANT));
        }
        else
        {
            m_fDisplayLevel[k] = m_fHistoryBufferAverage[k];
        }

/* Option 2 for current level display: Current buffer value (jittery) 
            m_fDisplayLevel[k] = fLevels[k];*/

    }

    m_dwHistoryBufferIndex = (++m_dwHistoryBufferIndex)%(HISTORY_BUFFER_SIZE);

   return S_OK;
}


//-----------------------------------------------------------------------------
// Name: RenderPeakLevels
// Desc: Draw the current level values (from RMS effect)
//-----------------------------------------------------------------------------
HRESULT
CXBoxSample::RenderPeakLevels()
{
    WCHAR szString[256];
    WCHAR *PeakLabels[]={L"L", L"R", L"C", L"LFE", L"LS", L"RS", L"aLeft", L"aRight"};
    FLOAT fXPos, fYPos;
    FLOAT x1, x2;
    FLOAT y1, y2;

    // calculations for display levels are in UpdatePeakLevels(), running in separate thread
    for (DWORD k=0; k<PEAK_NUM_BINS; k++)
    {
        fXPos = PEAK_MONITOR_LEFT_X + PEAK_MONITOR_BAR_WIDTH/2 + (PEAK_MONITOR_BAR_WIDTH+PEAK_MONITOR_BAR_SPACING)*k;
		if (k>=6)
			fXPos += PEAK_MONITOR_DIGITAL_ANALOG_SPACING;
        fYPos = PEAK_MONITOR_BOTTOM_Y + PEAK_MONITOR_LABEL_SPACING_Y;

        m_FontSmall.DrawText( fXPos, fYPos, 0xffffff00, PeakLabels[k], XBFONT_CENTER_X);

        if (m_fMaxLevels[k] >= .9999f)
        {
            swprintf (szString,L"CLIP");
            m_FontSmall.DrawText( fXPos, fYPos+20, 0xffff2e43, szString, XBFONT_CENTER_X);
        }
        else 
        {
            if (m_fMaxLevels[k] > 0.0001f)
                swprintf (szString,L"%2.2f", 20.0f * log10(m_fMaxLevels[k]));
            else swprintf (szString, L"-Inf");

            m_FontSmall.DrawText( fXPos, fYPos+20, 0xffffff00, szString, XBFONT_CENTER_X);
        }

    }
	// draw dB meter labels (Y-axis)
	for (FLOAT fLabel_counter=0; fLabel_counter >= PEAK_MONITOR_MIN_DB; fLabel_counter-=PEAK_MONITOR_DB_AXIS_SCALE)
	{
		swprintf (szString, L"%2.0f", fLabel_counter);
		m_FontSmall.DrawText (PEAK_MONITOR_LEFT_X - 2.0f * PEAK_DISPLAY_BAR_OFFSET, PEAK_MONITOR_BOTTOM_Y - (PEAK_MONITOR_Y_MAX - PEAK_MONITOR_Y_MAX * fLabel_counter / PEAK_MONITOR_MIN_DB), 0xffffff00, szString, XBFONT_RIGHT | XBFONT_CENTER_Y);
	}
		
	//
    // display current peak levels - better in above loop with render switching?
    //

    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );


    // NEW - draw all current levels

    for (k=0; k < PEAK_NUM_BINS; k++)
    {
        FLOAT fDisplayLevel;
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX v[4];
        
        //
        // normalize level so its range is reasonable
        //

        // Hardware can only produce -60 dB, so only display values larger than that
        if (m_fDisplayLevel[k] > 0.0)
        {
            fDisplayLevel = (FLOAT)(PEAK_MONITOR_Y_MAX - ((20.0f * log10(m_fDisplayLevel[k])) * PEAK_MONITOR_Y_MAX / PEAK_MONITOR_MIN_DB) );
            if (fDisplayLevel < 0.0)
                fDisplayLevel = 0.0;
        }
        else
            fDisplayLevel = 0.0;
        
        x1 = PEAK_MONITOR_LEFT_X + (PEAK_MONITOR_BAR_WIDTH + PEAK_MONITOR_BAR_SPACING)*k;
		if (k>=6)
			x1 += PEAK_MONITOR_DIGITAL_ANALOG_SPACING;
        x2 = x1 + PEAK_MONITOR_BAR_WIDTH;
        y2 = PEAK_MONITOR_BOTTOM_Y;
        y1 = y2 - fDisplayLevel;

        if (y1 < PEAK_MONITOR_Y_HIGHVOLUME) // red for top-most portion
        {
            v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffff0000;
            v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffff0000;
            v[2].p = D3DXVECTOR4( x1, PEAK_MONITOR_Y_HIGHVOLUME, 1.0f, 1.0f ); v[2].color = 0xff5f0000;
            v[3].p = D3DXVECTOR4( x2, PEAK_MONITOR_Y_HIGHVOLUME, 1.0f, 1.0f ); v[3].color = 0xff5f0000;

            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );

            y1 = PEAK_MONITOR_Y_HIGHVOLUME;
        }
        if (y1 < PEAK_MONITOR_Y_MIDVOLUME) // yellow for mid-range
        {
            v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xffffff00;
            v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xffffff00;
            v[2].p = D3DXVECTOR4( x1, PEAK_MONITOR_Y_MIDVOLUME, 1.0f, 1.0f ); v[2].color = 0xff5f5f00;
            v[3].p = D3DXVECTOR4( x2, PEAK_MONITOR_Y_MIDVOLUME, 1.0f, 1.0f ); v[3].color = 0xff5f5f00;

            m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );
            y1 = PEAK_MONITOR_Y_MIDVOLUME;
        }
        // green for bottom portion
        v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f ); v[0].color = 0xff00ff00;
        v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f ); v[1].color = 0xff00ff00;
        v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f ); v[2].color = 0xff005f00;
        v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f ); v[3].color = 0xff005f00;

        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );


        // plot peak value (solid line slightly wider than volume bars)
        fDisplayLevel = (m_fMaxLevels[k]) * (FLOAT)PEAK_MONITOR_Y_MAX;
        if (m_fMaxLevels[k] == 0)
            fDisplayLevel = 0.0;
        else
            fDisplayLevel = (FLOAT)(PEAK_MONITOR_Y_MAX - ((20.0f * log10(m_fMaxLevels[k])) * PEAK_MONITOR_Y_MAX / PEAK_MONITOR_MIN_DB));
        if (fDisplayLevel < 0.0)
            fDisplayLevel = 0;

        x1 = PEAK_MONITOR_LEFT_X + (PEAK_MONITOR_BAR_WIDTH + PEAK_MONITOR_BAR_SPACING)*k - PEAK_DISPLAY_BAR_OFFSET;
		if (k>=6)
			x1 += PEAK_MONITOR_DIGITAL_ANALOG_SPACING;

        x2 = x1 + PEAK_MONITOR_BAR_WIDTH + 2*PEAK_DISPLAY_BAR_OFFSET;
        y2 = PEAK_MONITOR_BOTTOM_Y - fDisplayLevel; 
        y1 = y2 - PEAK_DISPLAY_BAR_HEIGHT;

        v[0].p = D3DXVECTOR4( x1, y1, 1.0f, 1.0f );
        v[1].p = D3DXVECTOR4( x2, y1, 1.0f, 1.0f );
        v[2].p = D3DXVECTOR4( x1, y2, 1.0f, 1.0f );
        v[3].p = D3DXVECTOR4( x2, y2, 1.0f, 1.0f );
        // color line based on range
        for (int r=0; r<4; r++)
        {
            if (y2 < PEAK_MONITOR_Y_HIGHVOLUME)
                v[r].color = 0xffff0000;
            else if (y2 < PEAK_MONITOR_Y_MIDVOLUME)
                v[r].color = 0xffffff00;
            else
                v[r].color = 0xff00ff00;
        }
        
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_TRIANGLESTRIP, 2, v, sizeof(v[0]) );

    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\wavbndlr.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1/4/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wavbndlr.cpp
 *  Content:    WaveBank/WaveBundler remote functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/4/2002   dereks  Created.
 *
 ****************************************************************************/

#include <xtl.h>
#include <xbdm.h>
#include "debugcmd.h"
#include "wavbndlr.h"

#define DPF(a) OutputDebugString(a "\n")

#define ASSERT(exp) \
    { \
        if(!(exp)) \
        { \
            __asm int 3 \
        } \
    }

#define IS_VALID_HANDLE_VALUE(h) ((h) && (INVALID_HANDLE_VALUE != (h)))

typedef struct _WBPLAYENTRYCONTEXT
{
    struct _WBPLAYENTRYCONTEXT *    pPrev;
    struct _WBPLAYENTRYCONTEXT *    pNext;
    LPDIRECTSOUNDBUFFER             pBuffer;
} WBPLAYENTRYCONTEXT, *LPWBPLAYENTRYCONTEXT;

LPWBPLAYENTRYCONTEXT g_pctxPlayEntry = NULL;
HANDLE g_hMutex = CreateMutex(NULL, FALSE, NULL);

class CAutoLock
{
protected:
    HANDLE                  m_hMutex;

public:
    CAutoLock(HANDLE hMutex)
        : m_hMutex(hMutex)
    {
        ASSERT(IS_VALID_HANDLE_VALUE(m_hMutex));
        WaitForSingleObject(m_hMutex, INFINITE);
    }

    ~CAutoLock(void)
    {
        ASSERT(IS_VALID_HANDLE_VALUE(m_hMutex));
        ReleaseMutex(m_hMutex);
    }
};

#define AutoLock() \
    CAutoLock __AutoLock(g_hMutex)


/****************************************************************************
 *
 *  WbAddEntry
 *
 *  Description:
 *      Adds an entry to the WaveBank!PlayEntry context list.
 *
 *  Arguments:
 *      LPWBPLAYENTRYCONTEXT [in]: context.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WbAddEntry"

void
WbAddEntry
(
    LPWBPLAYENTRYCONTEXT    pContext
)
{
    AutoLock();
    
    ASSERT(!pContext->pPrev);
    ASSERT(!pContext->pNext);

    if(g_pctxPlayEntry)
    {
        ASSERT(!g_pctxPlayEntry->pPrev);
        
        pContext->pNext = g_pctxPlayEntry;
        g_pctxPlayEntry->pPrev = pContext;
    }

    g_pctxPlayEntry = pContext;
}
        

/****************************************************************************
 *
 *  WbRemoveEntry
 *
 *  Description:
 *      Removes an entry from the WaveBank!PlayEntry context list.
 *
 *  Arguments:
 *      LPWBPLAYENTRYCONTEXT [in]: context.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WbRemoveEntry"

void
WbRemoveEntry
(
    LPWBPLAYENTRYCONTEXT    pContext
)
{
    AutoLock();
    
    if(pContext->pPrev)
    {
        pContext->pPrev->pNext = pContext->pNext;
    }

    if(pContext->pNext)
    {
        pContext->pNext->pPrev = pContext->pPrev;
    }

    if(pContext == g_pctxPlayEntry)
    {
        ASSERT(!pContext->pPrev);
        g_pctxPlayEntry = pContext->pNext;
    }

    pContext->pPrev = pContext->pNext = NULL;
}


/****************************************************************************
 *
 *  WbAllocContext
 *
 *  Description:
 *      Allocates context to track a stream.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *
 *  Returns:  
 *      LPWBPLAYENTRYCONTEXT: context.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WbAllocContext"

LPWBPLAYENTRYCONTEXT
WbAllocContext
(
    LPDIRECTSOUNDBUFFER     pBuffer
)
{
    LPWBPLAYENTRYCONTEXT    pContext;

    AutoLock();
    
    if(pContext = (WBPLAYENTRYCONTEXT *)LocalAlloc(LPTR, sizeof(*pContext)))
    {
        pContext->pBuffer = pBuffer;

        WbAddEntry(pContext);
    }

    return pContext;
}
        

/****************************************************************************
 *
 *  WbFreeContext
 *
 *  Description:
 *      Frees context used to track a stream.
 *
 *  Arguments:
 *      LPWBPLAYENTRYCONTEXT [in/out]: context.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WbFreeContext"

void
WbFreeContext
(
    LPWBPLAYENTRYCONTEXT    pContext
)
{
    AutoLock();
    
    WbRemoveEntry(pContext);

    if(pContext->pBuffer)
    {
        pContext->pBuffer->Release();
    }

    LocalFree(pContext);
}
        

/****************************************************************************
 *
 *  WbCheckStatus
 *
 *  Description:
 *      Checks the status of a buffer and frees it if it's stopped.
 *
 *  Arguments:
 *      LPWBPLAYENTRYCONTEXT [in/out]: context.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WbCheckStatus"

void
WbCheckStatus
(
    LPWBPLAYENTRYCONTEXT    pContext
)
{
    DWORD                   dwStatus    = 0;
    
    AutoLock();
    
    if(pContext->pBuffer)
    {
        pContext->pBuffer->GetStatus(&dwStatus);

        if(!(dwStatus & DSBSTATUS_PLAYING))
        {
            WbFreeContext(pContext);
        }
    }
}
        

/****************************************************************************
 *
 *  WbCheckStatus
 *
 *  Description:
 *      Checks the status of a buffer and frees it if it's stopped.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WbCheckStatusAll"

void
WbCheckStatusAll
(
    void
)
{
    LPWBPLAYENTRYCONTEXT    pContext    = g_pctxPlayEntry;
    LPWBPLAYENTRYCONTEXT    pNext;

    AutoLock();
    
    while(pContext)
    {
        pNext = pContext->pNext;

        WbCheckStatus(pContext);

        pContext = pNext;
    }
}
        

/****************************************************************************
 *
 *  RCmdWaveBankPlayEntry
 *
 *  Description:
 *      Plays an individual sound bank entry.
 *
 *  Arguments:
 *      int [in]: argument count.
 *      char ** [in]: arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "RCmdWaveBankPlayEntry"

void 
RCmdWaveBankPlayEntry
(
    int                     argc, 
    char **                 argv
)
{
    HANDLE                  hFile           = INVALID_HANDLE_VALUE;
    WBPLAYENTRYCONTEXT *    pContext        = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    HRESULT                 hr              = S_OK;
    WAVEBANKENTRY           Entry;
    DSBUFFERDESC            dsbd;
    WAVEBANKUNIWAVEFORMAT   wfx;
    DWORD                   dwRead;
    LPVOID                  pvLock;
    DWORD                   i;

    AutoLock();
    
    ZeroMemory(&dsbd, sizeof(dsbd));

    if(2 != argc)
    {
        DPF("Bad argument count");
        hr = E_INVALIDARG;
    }

    //
    // Open the file
    //
    
    if(SUCCEEDED(hr))
    {
        hFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_DELETE_ON_CLOSE, NULL);

        if(!IS_VALID_HANDLE_VALUE(hFile))
        {
            DPF("Failed to open file");
            hr = E_FAIL;
        }
    }

    //
    // Read the entry header
    //

    if(SUCCEEDED(hr))
    {
        if(!ReadFile(hFile, &Entry, sizeof(Entry), &dwRead, NULL))
        {
            DPF("Failed to read file header");
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr) && (sizeof(Entry) != dwRead))
    {
        DPF("Not enough data read from the file");
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        WaveBankExpandFormat(&Entry.Format, &wfx);
    }

    //
    // Create the buffer
    //

    if(SUCCEEDED(hr))
    {
        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = &wfx.WaveFormatEx;
        dsbd.dwBufferBytes = Entry.PlayRegion.dwLength;

        if(FAILED(hr = DirectSoundCreateBuffer(&dsbd, &pBuffer)))
        {
            DPF("Unable to create audio buffer");
        }
    }

    //
    // Allocate context to track the buffer
    //

    if(SUCCEEDED(hr))
    {
        if(!(pContext = WbAllocContext(pBuffer)))
        {
            DPF("Out of memory");
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Read the entire entry into the buffer
    //

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = pBuffer->Lock(0, 0, &pvLock, &dwRead, NULL, NULL, DSBLOCK_ENTIREBUFFER)))
        {
            DPF("Unable to lock buffer");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(!ReadFile(hFile, pvLock, dwRead, &dwRead, NULL))
        {
            DPF("Unable to read wave data");
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {
        pBuffer->Unlock(pvLock, dwRead, NULL, 0);
    }

    //
    // Set loop points
    //

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = pBuffer->SetLoopRegion(Entry.LoopRegion.dwStart, Entry.LoopRegion.dwLength)))
        {
            DPF("Unable to set loop region");
        }
    }

    //
    // Start playback
    //

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Play(0, 0, Entry.LoopRegion.dwLength ? DSBPLAY_LOOPING : 0);
    }

    //
    // Clean up
    //

    if(FAILED(hr))
    {
        if(pContext)
        {
            WbFreeContext(pContext);
        }
        else if(pBuffer)
        {
            pBuffer->Release();
        }
    }

    if(IS_VALID_HANDLE_VALUE(hFile))
    {
        CloseHandle(hFile);
    }
}


/****************************************************************************
 *
 *  RCmdWaveBankStopAll
 *
 *  Description:
 *      Stops all playing entries.
 *
 *  Arguments:
 *      int [in]: argument count.
 *      char ** [in]: arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "RCmdWaveBankStopAll"

void 
RCmdWaveBankStopAll
(
    int                     argc, 
    char **                 argv
)
{
    HRESULT                 hr          = S_OK;
    LPWBPLAYENTRYCONTEXT    pContext;
    
    AutoLock();
    
    if(1 != argc)
    {
        DPF("Bad argument count");
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr))
    {
        for(pContext = g_pctxPlayEntry; pContext; pContext = pContext->pNext)
        {
            pContext->pBuffer->Stop();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\scriptproxy.cpp ===
//-----------------------------------------------------------------------------
// File: ScriptProxy.cpp
//
// Desc: Methods to proxy a DirectMusic script onto the Xbox
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBUtil.h>
#include <XBFont.h>
#include <XBHelp.h>
#include "dmusicip.h"
#include "DebugCmd.h"
#include "DMConsole.h"
#include <xbdm.h>
//#include <objbase.h>
//#include "..\..\..\dmusic\dmscript\dmscript.h"

extern CRITICAL_SECTION g_cs;
extern CXBoxSample g_xbApp;
extern void SendNotification( char *strName, DWORD dwData1, DWORD dwData2 );

CScriptItem *GetScriptFromID( DWORD dwScriptID )
{
	// Ensure this script ID doesn't exist
	CScriptItem *pScriptItem = (CScriptItem *)g_xbApp.m_lstScripts.GetHead();
	while( pScriptItem )
	{
		if( dwScriptID == pScriptItem->m_dwScriptID )
		{
			return pScriptItem;
		}
		pScriptItem = pScriptItem->GetNext();
	}

	return NULL;
}


//-----------------------------------------------------------------------------
// Name: RCmdScriptInit
// Desc: initializes a script
//-----------------------------------------------------------------------------

void RCmdScriptInit(int argc, char *argv[])
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 3 )
    {
        DCCMDPrintf("Need to specify the ID and filename\n");
        hr = E_INVALIDARG;
    }

    DWORD dwScriptID = 0xFFFFFFFF;
	
	if( SUCCEEDED(hr) )
	{
		dwScriptID = atoi(argv[1]);

		// Ensure this script ID doesn't exist
		if( GetScriptFromID( dwScriptID ) )
		{
			OutputDebugString( "RCmdScriptInit: Script ID already in use\n" );
			hr = E_INVALIDARG;
		}
	}

    // Load script
    IDirectMusicScript8 *pIDirectMusicScript8 = NULL;
	if( SUCCEEDED(hr) )
	{
		hr = g_pLoader->LoadObjectFromFile( CLSID_DirectMusicScript, IID_IDirectMusicScript8, 
											argv[2], (VOID**)&pIDirectMusicScript8 );
	}
 
	DMUS_SCRIPT_ERRORINFO dmScriptErrorInfo;
	ZeroMemory( &dmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO) );
	dmScriptErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);
	if( SUCCEEDED( hr ) )
	{
	    // Initialize
        hr = pIDirectMusicScript8->Init( g_pPerformance, &dmScriptErrorInfo );
    }

	if( SUCCEEDED( hr ) )
	{
		// Add script to list
        CScriptItem *pScriptItem = new CScriptItem;
        pScriptItem->m_dwScriptID = dwScriptID;
        pScriptItem->m_pScript8 = pIDirectMusicScript8;
		pScriptItem->m_pScript8->AddRef();
        g_xbApp.m_lstScripts.AddHead( pScriptItem );
	}

	// Release script
	if( pIDirectMusicScript8 )
	{
		pIDirectMusicScript8->Release();
	}

    // Pass the result back to the Windows application
	SendNotification( "!Script.InitResult ", dwScriptID, hr );
}


//-----------------------------------------------------------------------------
// Name: RCmdScriptRelease
// Desc: Releases a script
//-----------------------------------------------------------------------------

void RCmdScriptRelease(int argc, char *argv[])
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify the ID\n");
        hr = E_INVALIDARG;
    }

    DWORD dwScriptID = 0xFFFFFFFF;
	CScriptItem *pScriptItem = NULL;
	if( SUCCEEDED(hr) )
	{
		dwScriptID = atoi(argv[1]);

		// Ensure this script ID exists
		pScriptItem = GetScriptFromID( dwScriptID );
	}

	if( NULL == pScriptItem )
	{
        OutputDebugString( "RCmdScriptRelease: Script ID not found\n" );
		hr = E_INVALIDARG;
	}

    // Release script
	if( SUCCEEDED(hr) )
	{
		pScriptItem->m_pScript8->Release();
		pScriptItem->m_pScript8 = NULL;

		// Remove the item from the list
		g_xbApp.m_lstScripts.Remove( pScriptItem );

		// Delete the item
		delete pScriptItem;
	}
 
    // Pass the result back to the Windows application
	SendNotification( "!Script.ReleaseResult ", dwScriptID, hr );
}


//-----------------------------------------------------------------------------
// Name: RCmdScriptEnumVariable
// Desc: Enumerates a variable
//-----------------------------------------------------------------------------

void RCmdScriptEnumVariable(int argc, char *argv[])
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 3 )
    {
        DCCMDPrintf("Need to specify the ID and variable index\n");
		hr = E_INVALIDARG;
    }

    DWORD dwScriptID = 0xFFFFFFFF;
	CScriptItem *pScriptItem = NULL;
	if( SUCCEEDED(hr) )
	{
		dwScriptID = atoi(argv[1]);

		// Ensure this script ID exists
		pScriptItem = GetScriptFromID( dwScriptID );
	}

	if( NULL == pScriptItem )
	{
        OutputDebugString( "RCmdScriptEnumVariable: Script ID not found\n" );
		hr = E_INVALIDARG;
	}

	// Query the script
	if( SUCCEEDED(hr) )
	{
		// TODO:
		//DWORD dwVariableID = atoi(argv[2]);
		//WCHAR wcstrName[MAX_PATH];
		//hr = pScriptItem->m_pScript8->EnumVariable( dwVariableID, wcstrName );
	}

	// TODO: Pass the value back

    // Pass the result back to the Windows application
	SendNotification( "!Script.EnumVariableResult ", dwScriptID, hr );
}


//-----------------------------------------------------------------------------
// Name: RCmdScriptGetVariableVariant
// Desc: Gets a variable
//-----------------------------------------------------------------------------

void RCmdScriptGetVariableVariant(int argc, char *argv[])
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 3 )
    {
        DCCMDPrintf("Need to specify the ID and variable index\n");
		hr = E_INVALIDARG;
    }

    DWORD dwScriptID = 0xFFFFFFFF;
	CScriptItem *pScriptItem = NULL;
	if( SUCCEEDED(hr) )
	{
		dwScriptID = atoi(argv[1]);

		// Ensure this script ID exists
		pScriptItem = GetScriptFromID( dwScriptID );
	}

	if( NULL == pScriptItem )
	{
        OutputDebugString( "RCmdScriptGetVariableVariant: Script ID not found\n" );
		hr = E_INVALIDARG;
	}

	// Query the script
	if( SUCCEEDED(hr) )
	{
		// TODO:
		//VARIANT varValue;
		//DMUS_SCRIPT_ERRORINFO dmScriptErrorInfo;
		//ZeroMemory( &dmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO) );
		//dmScriptErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);
		//WCHAR wcstrVariableName[MAX_PATH];
		//wsprintfW( wcstrVariableName, L"%S", argv[2] );
		//hr = pScriptItem->m_pScript8->GetVariableVariant( wcstrVariableName, &varValue, &dmScriptErrorInfo );
	}

	// TODO: Pass the value back

    // Pass the result back to the Windows application
	SendNotification( "!Script.GetVariableVariantResult ", dwScriptID, hr );
}


//-----------------------------------------------------------------------------
// Name: RCmdScriptSetVariableVariant
// Desc: Sets a variable
//-----------------------------------------------------------------------------

void RCmdScriptSetVariableVariant(int argc, char *argv[])
{
	// TODO:
}


//-----------------------------------------------------------------------------
// Name: RCmdScriptEnumRoutine
// Desc: Enumerates a routine
//-----------------------------------------------------------------------------

void RCmdScriptEnumRoutine(int argc, char *argv[])
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 3 )
    {
        DCCMDPrintf("Need to specify the ID and routine index\n");
		hr = E_INVALIDARG;
    }

    DWORD dwScriptID = 0xFFFFFFFF;
	CScriptItem *pScriptItem = NULL;
	if( SUCCEEDED(hr) )
	{
		dwScriptID = atoi(argv[1]);

		// Ensure this script ID exists
		pScriptItem = GetScriptFromID( dwScriptID );
	}

	if( NULL == pScriptItem )
	{
        OutputDebugString( "RCmdScriptEnumRoutine: Script ID not found\n" );
		hr = E_INVALIDARG;
	}

	// Query the script
	if( SUCCEEDED(hr) )
	{
		// TODO:
		//DWORD dwRoutineID = atoi(argv[2]);
		//WCHAR wcstrName[MAX_PATH];
		//hr = pScriptItem->m_pScript8->EnumRoutine( dwRoutineID, wcstrName );
	}

	// TODO: Pass the value back

    // Pass the result back to the Windows application
	SendNotification( "!Script.EnumRoutineResult ", dwScriptID, hr );
}


//-----------------------------------------------------------------------------
// Name: RCmdScriptCallRoutine
// Desc: Calls a routine
//-----------------------------------------------------------------------------

void RCmdScriptCallRoutine(int argc, char *argv[])
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 3 )
    {
        DCCMDPrintf("Need to specify the ID and routine name\n");
		hr = E_INVALIDARG;
    }

    DWORD dwScriptID = 0xFFFFFFFF;
	CScriptItem *pScriptItem = NULL;
	if( SUCCEEDED(hr) )
	{
		dwScriptID = atoi(argv[1]);

		// Ensure this script ID exists
		pScriptItem = GetScriptFromID( dwScriptID );
	}

	if( NULL == pScriptItem )
	{
        OutputDebugString( "RCmdScriptCallRoutine: Script ID not found\n" );
		hr = E_INVALIDARG;
	}

	// Query the script
	if( SUCCEEDED(hr) )
	{
		// TODO:
		DMUS_SCRIPT_ERRORINFO dmScriptErrorInfo;
		ZeroMemory( &dmScriptErrorInfo, sizeof(DMUS_SCRIPT_ERRORINFO) );
		dmScriptErrorInfo.dwSize = sizeof(DMUS_SCRIPT_ERRORINFO);
		hr = pScriptItem->m_pScript8->CallRoutine( argv[2], &dmScriptErrorInfo );
	}

	// TODO: Pass the error info back

    // Pass the result back to the Windows application
	SendNotification( "!Script.CallRoutineResult ", dwScriptID, hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\portproxy.cpp ===
//-----------------------------------------------------------------------------
// File: PortProxy.cpp
//
// Desc: Methods to proxy a DirectMusic synth onto the Xbox
//
// Copyright (c) 2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <XBApp.h>
#include <XBUtil.h>
#include <XBFont.h>
#include <XBHelp.h>
#include "dmusicip.h"
#include "DebugCmd.h"
#include "DMConsole.h"
#include <xbdm.h>
#include "dowork.h"
#include "..\..\..\dmusic\dmime\dmperf.h"
#include <dmusbuff.h>

#define XBOX_SYNTH_NAME "Xbox Synthesizer"

extern CXBoxSample g_xbApp;

struct PChannelInfo {
	DWORD dwGroup;
	DWORD dwMChannel;
    long  lBendRange;
	short nCurrentRPN;
	short nLastPBend;
//    short nCount;
};

#define MIDI_PBEND          0xE0 
#define MIDI_SYSX           0xF0
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26
#define CC_NRPN_LSB    0x62
#define CC_NRPN_MSB    0x63
#define CC_RPN_LSB     0x64
#define CC_RPN_MSB     0x65
#define RPN_PITCHBEND  0x00

static REFERENCE_TIME s_rtBufferStart = 0;
static REFERENCE_TIME s_rtTimingOffset = 0;

static IDirectMusicAudioPath *s_pIDirectMusicAudioPath = NULL;
static DWORD s_dwNumPChannels = 0;
//static DWORD s_dwTempNumPChannels = 0;
static DWORD s_dwDefaultAudioPathID = DMUS_APATH_SHARED_STEREOPLUSREVERB;
static PChannelInfo *s_pPChannelInfo = NULL;
//static PChannelInfo *s_pTempPChannelInfo = NULL;
//static BOOL fChanged = FALSE;
//static DWORD s_dwOldAudioPathID = DMUS_APATH_SHARED_STEREOPLUSREVERB;

//static DWORD  s_dwNextAudioPathID = 0;
//        s_dwDefaultAudioPathID = dwPathID;
//        hr = RecreateDefaultAudioPath(dwPathID,s_dwNumPChannels);

//HRESULT RecreateDefaultAudioPath(DWORD dwAudioPathID, DWORD dwNumPChannels);


/*void DumpPChannelInfo()

{
    if (s_dwNextAudioPathID != s_dwDefaultAudioPathID)
    {
        s_dwDefaultAudioPathID = s_dwNextAudioPathID;
        RecreateDefaultAudioPath(s_dwDefaultAudioPathID,s_dwNumPChannels);
    }
    if (fChanged)
    {
        if (s_pTempPChannelInfo)
        {
            DbgPrint("Audiopath: %lx\nPCh\tG\tCh\tNotes Played\n",s_dwOldAudioPathID);
            DWORD dwX;
            for (dwX = 0; dwX < s_dwTempNumPChannels; dwX++)
            {
                DbgPrint("%ld\t%ld\t%ld\t%ld\n",dwX,s_pTempPChannelInfo[dwX].dwGroup,
                    s_pTempPChannelInfo[dwX].dwMChannel,(long) s_pTempPChannelInfo[dwX].nCount);
            }
            DbgPrint("\n");
            s_dwOldAudioPathID = s_dwDefaultAudioPathID;
        }
        fChanged = FALSE;
    }
}
*/

//-----------------------------------------------------------------------------
// Name: RCmdSynthPlayBuffer
// Desc: plays a buffer of MIDI events
//-----------------------------------------------------------------------------
HRESULT RCmdSynthPlayBuffer(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 4 )
    {
        DCCMDPrintf("Need to specify the buffer time and size, and the \"now\" time\n");
		hr = E_INVALIDARG;
    }

	DWORD dwSize = 0;
	REFERENCE_TIME rtPCNow = 0;
	if( SUCCEEDED(hr) )
	{
		s_rtBufferStart = _atoi64(argv[1]);
		rtPCNow = _atoi64(argv[2]);
		dwSize = atoi(argv[3]);

		if( dwSize == 0 )
		{
			hr = E_INVALIDARG;
		}
	}

	// Set the timing offset
	/* Should no longer need this timing offset
	if( SUCCEEDED(hr)
	&&	(0 == s_rtTimingOffset) )
	{
		REFERENCE_TIME rtXboxNow = 0;
		if( SUCCEEDED( g_pPerformance->GetTime( &rtXboxNow, NULL ) ) )
		{
			s_rtTimingOffset = rtXboxNow - rtPCNow;
		}
	}
	*/

	// Allocate the buffer to receive the data in
	BYTE *pbData = NULL;
	if( SUCCEEDED(hr) )
	{
		pbData = new BYTE[dwSize];

		if( pbData == NULL )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if( SUCCEEDED(hr) )
	{
		pdmcc->HandlingFunction = SynthReceiveBuffer;
		pdmcc->DataSize = 0;
		pdmcc->Buffer = pbData;
		pdmcc->BufferSize = dwSize;
		pdmcc->CustomData = 0;
		pdmcc->BytesRemaining = dwSize;

		hr = XBDM_READYFORBIN;
	}

	return hr;
}

void GMReset( void )
{
	if( s_pPChannelInfo )
	{
		for( DWORD i = 0; i < s_dwNumPChannels; i++ )
		{
			s_pPChannelInfo[i].lBendRange = 200;
			s_pPChannelInfo[i].nCurrentRPN = 0x3FFF;
			s_pPChannelInfo[i].nLastPBend = 0x2000;
		}
	}
}

/*void PlayMIDI()

{
    IDirectMusicSynthX *pSynth;
    HRESULT hr = g_pPerformance->GetSynth(&pSynth);

	if( SUCCEEDED(hr) )
	{
        CDownloadItem *pDownloadItem = (CDownloadItem *) g_xbApp.m_lstDownloads.GetHead();
        for (; pDownloadItem; pDownloadItem = pDownloadItem->GetNext() )
        {
            if (pDownloadItem->m_hHandle == NULL)
		    {
                BOOL fFree;
                hr = pSynth->Download(&pDownloadItem->m_hHandle,
                    pDownloadItem->m_pbBuffer,&fFree);  
            }
        }
        pSynth->Release();
    }
}

void QueueMIDI(DWORD dwMsg)

{
    dwBuffer[dwWrite++] = dwMsg;
    if (dwWrite >= 100) dwWrite = 0;
}*/

void PlayBufferOnDefaultPort( BYTE *pbBuffer, DWORD cbBuffer, REFERENCE_TIME rtBufferStart )
{
	HRESULT hr = E_FAIL;

    IDirectMusicSynthX *pSynth;
    hr = g_pPerformance->GetSynth(&pSynth);

	if( SUCCEEDED(hr) )
	{

		class MIDIEVENT : public DMUS_EVENTHEADER {
		public:
			 BYTE  abEvent[4];           // Actual event data, rounded up to be an even number
										 // of QWORD's (8 bytes)
		};

		typedef class MIDIEVENT FAR  *LPMIDIEVENT;

		while( cbBuffer )
		{
			// Skip events that are too short
			if (cbBuffer < sizeof(DMUS_EVENTHEADER))
			{
				break;
			}

			LPMIDIEVENT lpEventHdr = (LPMIDIEVENT)pbBuffer;
			DWORD cbEvent = DMUS_EVENT_SIZE(lpEventHdr->cbEvent);
			if (cbEvent > cbBuffer)
			{
				break;
			}

			pbBuffer += cbEvent;
			cbBuffer -= cbEvent;

			const BYTE bStatus = lpEventHdr->abEvent[0];
			DWORD dwChannelGroup = lpEventHdr->dwChannelGroup;
			DWORD dwOrigPChannelBase = max( 0, dwChannelGroup-1) * 16;

			// If a normal MIDI event (non-sysex)
			if( (lpEventHdr->cbEvent < 4)
			&&	(bStatus & 0x80)
			&&	(bStatus & 0xF0) != 0xF0 )
			{
				DWORD dwOrigPChannel = dwOrigPChannelBase + (bStatus & 0xF);

				if( dwOrigPChannel < s_dwNumPChannels )
				{
					lpEventHdr->abEvent[0] = BYTE((bStatus & 0xF0) | BYTE(s_pPChannelInfo[dwOrigPChannel].dwMChannel & 0xF));
					dwChannelGroup = s_pPChannelInfo[dwOrigPChannel].dwGroup;
//                    s_pPChannelInfo[dwOrigPChannel].nCount++;
				}
				else
				{
					// Invalid PChannel
					assert(FALSE);
					continue;
				}

				if( (bStatus & 0xF0) == MIDI_PBEND )
				{
					long lBend = lpEventHdr->abEvent[1] | (lpEventHdr->abEvent[2] << 7);
					s_pPChannelInfo[dwOrigPChannel].nLastPBend = short(lBend);
					lBend -= 0x2000;
					lBend *= s_pPChannelInfo[dwOrigPChannel].lBendRange;
					lBend += 0x1000;        // handle rounding up.
					lBend /= 0x2000;
					lBend += 0x2000;
					lpEventHdr->abEvent[1] = (BYTE) lBend & 0x7F;
					lpEventHdr->abEvent[2] = (BYTE) (lBend >> 7) & 0x7F;
				}
				else if( (bStatus & 0xF0) == MIDI_CCHANGE )
				{
					switch( lpEventHdr->abEvent[1] )
					{
					case CC_RPN_LSB:
						s_pPChannelInfo[dwOrigPChannel].nCurrentRPN = (s_pPChannelInfo[dwOrigPChannel].nCurrentRPN & 0x3f80) + lpEventHdr->abEvent[2];
						break; 
					case CC_RPN_MSB:
						s_pPChannelInfo[dwOrigPChannel].nCurrentRPN = (s_pPChannelInfo[dwOrigPChannel].nCurrentRPN & 0x7f) + (lpEventHdr->abEvent[2] << 7);
						break;
					case CC_NRPN_LSB :
					case CC_NRPN_MSB :
						s_pPChannelInfo[dwOrigPChannel].nCurrentRPN = 0x3FFF;
						break;
					case CC_DATAENTRYMSB:
						switch (s_pPChannelInfo[dwOrigPChannel].nCurrentRPN)
						{
						case RPN_PITCHBEND:
							// Special case for a range of 82 semitones, because this must
							// really be an attempt to have the pitch bend map directly to
							// pitch cents.
							if (lpEventHdr->abEvent[2] == 82)
							{
								s_pPChannelInfo[dwOrigPChannel].lBendRange = 8192;
							}
							else
							{
								s_pPChannelInfo[dwOrigPChannel].lBendRange = lpEventHdr->abEvent[2] * 100;
							}

							// Change this to a pitch bend message (since the synth ignores the RPN)
							{
								long lBend = s_pPChannelInfo[dwOrigPChannel].nLastPBend;
								lBend -= 0x2000;
								lBend *= s_pPChannelInfo[dwOrigPChannel].lBendRange;
								lBend += 0x1000;        // handle rounding up.
								lBend /= 0x2000;
								lBend += 0x2000;
								lpEventHdr->abEvent[1] = (BYTE) lBend & 0x7F;
								lpEventHdr->abEvent[2] = (BYTE) (lBend >> 7) & 0x7F;
								lpEventHdr->abEvent[0] = (lpEventHdr->abEvent[0] & 0xF) | MIDI_PBEND;
							}

							break;
						}
					}
				}
                DWORD dwMsg = lpEventHdr->abEvent[0] + (lpEventHdr->abEvent[1] << 8) + (lpEventHdr->abEvent[2] << 16);
                pSynth->SendShortMsg(rtBufferStart + lpEventHdr->rtDelta,dwChannelGroup, dwMsg);
			}
			else
			{
				// Just change the channel group
				if( dwOrigPChannelBase < s_dwNumPChannels )
				{
					dwChannelGroup = s_pPChannelInfo[dwOrigPChannelBase].dwGroup;
				}
				else
				{
					// Invalid PChannel
					assert(FALSE);
					continue;
				}

				if(	(MIDI_SYSX == bStatus)
				&&	(lpEventHdr->cbEvent >= 6))
				{
					switch( lpEventHdr->abEvent[1] )
					{
					case 0x7E : // General purpose ID
						if (lpEventHdr->abEvent[3] == 0x09) 
						{
							GMReset();
						}
						break;
					case 0x41 : // Roland
						if (lpEventHdr->cbEvent < 11) 
						{
							break;
						}
						if (lpEventHdr->abEvent[3] != 0x42) break;
						if (lpEventHdr->abEvent[4] != 0x12) break;

						// GS Reset
						if( 0x40007F == ((lpEventHdr->abEvent[5] << 16) |
							((lpEventHdr->abEvent[6] & 0xF0) << 8) | lpEventHdr->abEvent[7]) )
						{
							GMReset();
						}
						break;
					case 0x43 : // Yamaha
						if ((lpEventHdr->abEvent[3] == 0x4C) &&
							(lpEventHdr->abEvent[4] == 0) &&
							(lpEventHdr->abEvent[5] == 0) &&
							(lpEventHdr->abEvent[6] == 0x7E) &&
							(lpEventHdr->abEvent[7] == 0))
						{   // XG System On
							GMReset();
						}
						break;
					}
				}
                pSynth->SendLongMsg(rtBufferStart + lpEventHdr->rtDelta,dwChannelGroup, 
                    lpEventHdr->abEvent, lpEventHdr->cbEvent);
			}

			g_xbApp.m_fMIDICounter+=0.4F;
			if( g_xbApp.m_fMIDICounter > 100.0 )
			{
				g_xbApp.m_fMIDICounter = 1.0;
			}

		}
        pSynth->Release();
	}
}

HRESULT __stdcall SynthReceiveBuffer(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
	//char strDebug[500];
	//sprintf( strDebug, "Recv: %x %x %x %x %x %x\n", pdmcc->HandlingFunction, pdmcc->DataSize,
	//	pdmcc->Buffer, pdmcc->BufferSize, pdmcc->CustomData, pdmcc->BytesRemaining );
	//OutputDebugStringA(strDebug);
	if( pdmcc->DataSize != pdmcc->BufferSize )
	{
		// We can't handle this
		DebugBreak();
	}
	if( pdmcc->DataSize != 0 )
	{
		//g_xbApp.m_fVolume = min( 256, pdmcc->DataSize ) * 100.0 / 256.0;

		//REFERENCE_TIME rtLatencyTime = 0;
		//g_pPerformance->GetLatencyTime( &rtLatencyTime );

		LPBYTE pbBuffer = (LPBYTE) pdmcc->Buffer;
		PlayBufferOnDefaultPort( pbBuffer, pdmcc->DataSize, s_rtBufferStart + s_rtTimingOffset );
		delete []pbBuffer;
	}

	// We don't want to receive any more buffers
	pdmcc->BytesRemaining = 0;
	return XBDM_NOERR;
}

//-----------------------------------------------------------------------------
// Name: RCmdSynthDownload
// Desc: Downloads an instrument
//-----------------------------------------------------------------------------
HRESULT RCmdSynthDownload(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 3 )
    {
        DCCMDPrintf("Need to specify the ID and size\n");
		hr = E_INVALIDARG;
    }

	DWORD dwID = 0xFFFFFFFF;
	DWORD dwSize = 0;
	if( SUCCEEDED(hr) )
	{
		dwID = atoi(argv[1]);
		dwSize = atoi(argv[2]);

		if( dwSize == 0 )
		{
			hr = E_INVALIDARG;
		}
	}

	// Allocate the buffer to receive the data in
	BYTE *pbData = NULL;
	if( SUCCEEDED(hr) )
	{
		pbData = new BYTE[dwSize];

		if( pbData == NULL )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if( SUCCEEDED(hr) )
	{
		pdmcc->HandlingFunction = SynthReceiveDownload;
		pdmcc->DataSize = 0;
		pdmcc->Buffer = pbData;
		pdmcc->BufferSize = dwSize;
		pdmcc->CustomData = (PVOID)dwID;
		pdmcc->BytesRemaining = dwSize;

		hr = XBDM_READYFORBIN;
	}

	return hr;
}


void DownloadToDefaultPort( BYTE *pbBuffer, DWORD cbBuffer, DWORD dwUniqueDownloadID )
{
    IDirectMusicSynthX *pSynth = NULL;
	HRESULT hr = E_FAIL;

	if( g_pPerformance )
    {
        hr = g_pPerformance->GetSynth(&pSynth);
    }
    if (SUCCEEDED(hr))
    {
        HANDLE hDownload = NULL; 
        BOOL fFree;
        hr = pSynth->Download(&hDownload,pbBuffer,&fFree); 
        pSynth->Release();
        if( SUCCEEDED(hr) )
	    {
            if (fFree)
            {
                delete [] pbBuffer;
                pbBuffer = NULL;
            }
		    CDownloadItem *pDownloadItem = new CDownloadItem;
		    if( pDownloadItem )
		    {
			    pDownloadItem->m_hHandle = hDownload;
                pDownloadItem->m_dwUniqueID = dwUniqueDownloadID;
                pDownloadItem->m_pbBuffer = pbBuffer;
			    g_xbApp.m_lstDownloads.AddTail( pDownloadItem );
		    }
	    }
    }
}

HRESULT __stdcall SynthReceiveDownload(PDM_CMDCONT pdmcc, LPSTR szResponse, DWORD cchResponse)
{
	//char strDebug[500];
	//sprintf( strDebug, "Download: %x %x %x %x %x %x\n", pdmcc->HandlingFunction, pdmcc->DataSize,
	//	pdmcc->Buffer, pdmcc->BufferSize, pdmcc->CustomData, pdmcc->BytesRemaining );
	//OutputDebugStringA(strDebug);

	//	pdmcc->DataSize = 0; // Data to process in this call
	//	pdmcc->Buffer = pbData; // Offset into buffer
	//	pdmcc->BufferSize = dwSize; // Size of total buffer
	//	pdmcc->CustomData = pbData; // Download ID
	//	pdmcc->BytesRemaining = dwSize; // Size of buffer left

	// Get a BYTE pointer to the buffer start
	LPBYTE pbSrcBuffer = (LPBYTE) pdmcc->Buffer;

	// Subtract the amount of data we read in
	pdmcc->BytesRemaining -= pdmcc->DataSize;

	// Increment the buffer pointer
	pbSrcBuffer += pdmcc->DataSize;

	// Update the DM_CMDCONT structure's pointer
	pdmcc->Buffer = pbSrcBuffer;

	if( 0 == pdmcc->BytesRemaining )
	{
		// If we're done

		// Compute the buffer start
		LPBYTE pbSrcStart = pbSrcBuffer - pdmcc->BufferSize;

		// Call DownloadToDefaultPort with buffer pointer, buffer size, and buffer ID
		DownloadToDefaultPort( pbSrcStart, pdmcc->BufferSize, (DWORD)pdmcc->CustomData );
	}

	return XBDM_NOERR;
}

HRESULT CALLBACK FreeHandle(HANDLE hHandle, HANDLE hUserData)
{
    BYTE * pbData = (BYTE *)hUserData;
    delete [] pbData;
	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: RCmdSynthUnload
// Desc: Unloads an instrument buffer
//-----------------------------------------------------------------------------
void UnloadFromDefaultPort( CDownloadItem *pDownloadItem )
{
    IDirectMusicSynthX *pSynth = NULL;
	if( g_pPerformance )
    {
        if (SUCCEEDED(g_pPerformance->GetSynth(&pSynth)))
        {
            pSynth->Unload(pDownloadItem->m_hHandle,FreeHandle,pDownloadItem->m_pbBuffer); 
            pSynth->Release();
        }
    }
}

HRESULT RCmdSynthUnload(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify the ID\n");
		hr = E_INVALIDARG;
    }

	CDownloadItem *pDownloadItem = NULL;
	DWORD dwID = 0xFFFFFFFF;
	if( SUCCEEDED(hr) )
	{
		dwID = atoi(argv[1]);

	    // Ensure this download buffer exists
        CDownloadItem *pDownloadTmp = (CDownloadItem *)g_xbApp.m_lstDownloads.GetHead();
        while( pDownloadTmp )
        {
            if( dwID == pDownloadTmp->m_dwUniqueID )
            {
				pDownloadItem = pDownloadTmp;
			    break;
            }
            pDownloadTmp = pDownloadTmp->GetNext();
        }
	}


	if( NULL == pDownloadItem )
	{
		char strDebugString[MAX_PATH];
		sprintf( strDebugString, "RCmdSynthUnload: Download ID %d not found\n", dwID );
		OutputDebugString( strDebugString );
        hr = E_INVALIDARG;
	}

	// Unload the download buffer
	if( SUCCEEDED(hr) )
	{
		UnloadFromDefaultPort( pDownloadItem );
	}

	if( pDownloadItem )
	{
		// Release the download buffer
//		pDownloadItem->m_pIDirectMusicDownload->Release();
//		pDownloadItem->m_pIDirectMusicDownload = NULL;

		// Remove the item from the list
		g_xbApp.m_lstDownloads.Remove( pDownloadItem );

		// Delete the item
		delete pDownloadItem;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Name: RCmdSynthGetTime
// Desc: Gets the current time
//-----------------------------------------------------------------------------
HRESULT RCmdSynthGetTime(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
	HRESULT hr = S_OK;

	REFERENCE_TIME rtXboxNow = 0;
	if( cchResp > 30
	&&	SUCCEEDED( g_pPerformance->GetTime( &rtXboxNow, NULL ) ) )
	{
		sprintf( szResp, "%I64d", rtXboxNow );
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}


HRESULT RecreateDefaultAudioPath(DWORD dwAudioPathID, DWORD dwNumPChannels)

{
    HRESULT hr;
	IDirectMusicAudioPath *pIDirectMusicAudioPath = NULL;
    hr = g_pPerformance->CreateStandardAudioPath( dwAudioPathID, dwNumPChannels, TRUE, &pIDirectMusicAudioPath );
    s_dwDefaultAudioPathID = dwAudioPathID;
	// Get a pointer to the performance's class
	CPerformance *pCPerformance = NULL;
	if( SUCCEEDED(hr) )
	{
		hr = g_pPerformance->QueryInterface( IID_CPerformance, (void **)&pCPerformance );
	}

	// If dwNumPChannels is zero, release our current audiopath
	if( SUCCEEDED(hr) && !dwNumPChannels )
	{
		if( s_pIDirectMusicAudioPath )
		{
			s_pIDirectMusicAudioPath->Release();
			s_pIDirectMusicAudioPath = NULL;
		}
		delete []s_pPChannelInfo;
		s_pPChannelInfo = NULL;
	}

	PChannelInfo *pPChannelInfo = NULL;
	if( SUCCEEDED(hr) && pIDirectMusicAudioPath )
	{
		pPChannelInfo = new PChannelInfo[dwNumPChannels];
		
		if( !pPChannelInfo )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if( SUCCEEDED(hr) && pPChannelInfo )
	{
		DWORD dwRealPChannel;
		for( DWORD i=0; i < dwNumPChannels; i++ )
		{
			hr = pIDirectMusicAudioPath->ConvertPChannel( i, &dwRealPChannel );
			if( FAILED(hr) )
			{
				break;
			}

			hr = pCPerformance->PChannelInfo( dwRealPChannel, NULL, &pPChannelInfo[i].dwGroup, &pPChannelInfo[i].dwMChannel );
			if( FAILED(hr) )
			{
				break;
			}

			pPChannelInfo[i].lBendRange = 200;
			pPChannelInfo[i].nCurrentRPN = 0x3FFF;
			pPChannelInfo[i].nLastPBend = 0x2000;
		}
	}

	if( SUCCEEDED(hr) && pPChannelInfo )
	{
		if( s_pIDirectMusicAudioPath )
		{
			s_pIDirectMusicAudioPath->Release();
		}
		s_pIDirectMusicAudioPath = pIDirectMusicAudioPath;
		pIDirectMusicAudioPath = NULL;

//		DWORD dwRealPChannel = 0;
//		s_pIDirectMusicAudioPath->ConvertPChannel( 0, &dwRealPChannel );

		s_dwNumPChannels = dwNumPChannels;
		delete []s_pPChannelInfo;
        s_pPChannelInfo = pPChannelInfo;
		pPChannelInfo = NULL;
	}

	if( pPChannelInfo )
	{
		delete []pPChannelInfo;
	}

	if( pCPerformance )
	{
		pCPerformance->Release();
	}

	if( pIDirectMusicAudioPath )
	{
		pIDirectMusicAudioPath->Release();
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Name: RCmdSynthSetDefaultAudioPath
// Desc: Sets the default audiopath to perform on
//-----------------------------------------------------------------------------
HRESULT RCmdSynthSetDefaultAudioPath(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify the id of the audiopath\n");
		hr = E_INVALIDARG;
    }

	DWORD dwPathID = atoi(argv[1]);
    if (s_dwDefaultAudioPathID != dwPathID)
    {
        s_dwDefaultAudioPathID = dwPathID;
        hr = RecreateDefaultAudioPath(dwPathID,s_dwNumPChannels);
    }
    return hr;
}

//-----------------------------------------------------------------------------
// Name: RCmdSynthSetChannelGroups
// Desc: Sets the number of channel groups
//-----------------------------------------------------------------------------
HRESULT RCmdSynthSetChannelGroups(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
	HRESULT hr = S_OK;

    // Check our arguments
    if( argc < 2 )
    {
        DCCMDPrintf("Need to specify the number of channel groups\n");
		hr = E_INVALIDARG;
    }

	DWORD dwNumPChannels = 0;
//	IDirectMusicAudioPath *pIDirectMusicAudioPath = NULL;
	if( SUCCEEDED(hr) )
	{
		dwNumPChannels = atoi(argv[1]) * 16;

		// If the number of PChannels changed to a non-zero number
		if( dwNumPChannels
		&&	(dwNumPChannels != s_dwNumPChannels) )
		{
            hr = RecreateDefaultAudioPath(s_dwDefaultAudioPathID, dwNumPChannels);
//			hr = g_pPerformance->CreateStandardAudioPath( DMUS_APATH_SHARED_STEREOPLUSREVERB, dwNumPChannels, TRUE, &pIDirectMusicAudioPath );
		}
		else
		{
			hr = S_FALSE;
		}
	}

	// Get a pointer to the performance's class
/*	CPerformance *pCPerformance = NULL;
	if( SUCCEEDED(hr) )
	{
		hr = g_pPerformance->QueryInterface( IID_CPerformance, (void **)&pCPerformance );
	}

	// If dwNumPChannels is zero, release our current audiopath
	if( SUCCEEDED(hr) && !dwNumPChannels )
	{
		if( s_pIDirectMusicAudioPath )
		{
			s_pIDirectMusicAudioPath->Release();
			s_pIDirectMusicAudioPath = NULL;
		}
		s_dwNumPChannels = 0;
		delete []s_pPChannelInfo;
		s_pPChannelInfo = NULL;
	}

	PChannelInfo *pPChannelInfo = NULL;
	if( SUCCEEDED(hr) && pIDirectMusicAudioPath )
	{
		pPChannelInfo = new PChannelInfo[dwNumPChannels];
		
		if( !pPChannelInfo )
		{
			hr = E_OUTOFMEMORY;
		}
	}

	if( SUCCEEDED(hr) && pPChannelInfo )
	{
		DWORD dwRealPChannel;
		for( DWORD i=0; i < dwNumPChannels; i++ )
		{
			hr = pIDirectMusicAudioPath->ConvertPChannel( i, &dwRealPChannel );
			if( FAILED(hr) )
			{
				break;
			}

			hr = pCPerformance->PChannelInfo( dwRealPChannel, NULL, &pPChannelInfo[i].dwGroup, &pPChannelInfo[i].dwMChannel );
			if( FAILED(hr) )
			{
				break;
			}

			pPChannelInfo[i].lBendRange = 200;
			pPChannelInfo[i].nCurrentRPN = 0x3FFF;
			pPChannelInfo[i].nLastPBend = 0x2000;
		}
	}

	if( SUCCEEDED(hr) && pPChannelInfo )
	{
		if( s_pIDirectMusicAudioPath )
		{
			s_pIDirectMusicAudioPath->Release();
		}
		s_pIDirectMusicAudioPath = pIDirectMusicAudioPath;
		pIDirectMusicAudioPath = NULL;

		DWORD dwRealPChannel = 0;
		s_pIDirectMusicAudioPath->ConvertPChannel( 0, &dwRealPChannel );
//		pCPerformance->PChannelInfo( dwRealPChannel, &s_pSynthProxyPort, NULL, NULL );

		s_dwNumPChannels = dwNumPChannels;
		delete []s_pPChannelInfo;
		s_pPChannelInfo = pPChannelInfo;
		pPChannelInfo = NULL;
	}

	if( pPChannelInfo )
	{
		delete []pPChannelInfo;
	}

	if( pCPerformance )
	{
		pCPerformance->Release();
	}

	if( pIDirectMusicAudioPath )
	{
		pIDirectMusicAudioPath->Release();
	}
*/
	return hr;
}

//-----------------------------------------------------------------------------
// Name: RCmdSynthInitialize
// Desc: Initializes the synth proxy
//-----------------------------------------------------------------------------
HRESULT RCmdSynthInitialize(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
	RCmdSynthUninitialize( argc, argv, szResp, cchResp, pdmcc );

    g_xbApp.AddConnection(XBOX_SYNTH_NAME);

	g_xbApp.m_fMIDICounter = 0.0;
	g_xbApp.m_bSynthInitialized = TRUE;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: RCmdSynthUninitialize
// Desc: Uninitializes the synth proxy
//-----------------------------------------------------------------------------
HRESULT RCmdSynthUninitialize(int argc, char *argv[], LPSTR szResp, DWORD cchResp, PDM_CMDCONT pdmcc)
{
	while( !g_xbApp.m_lstDownloads.IsEmpty() )
	{
		CDownloadItem *pDownloadItem = (CDownloadItem *)g_xbApp.m_lstDownloads.RemoveHead();

		// Release the download buffer
//		if( pDownloadItem->m_pIDirectMusicDownload )
		{
			// Unload the download buffer
			UnloadFromDefaultPort( pDownloadItem );

//			pDownloadItem->m_pIDirectMusicDownload->Release();
//			pDownloadItem->m_pIDirectMusicDownload = NULL;
		}

		// Delete the item
		delete pDownloadItem;
	}

    g_xbApp.RemoveConnection(XBOX_SYNTH_NAME);

	g_xbApp.m_bSynthInitialized = FALSE;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbInput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // Inherited members from XINPUT_GAMEPAD
	//
    // WORD    wButtons;
    // BYTE    bAnalogButtons[8];
    // SHORT   sThumbLX;
    // SHORT   sThumbLY;
    // SHORT   sThumbRX;
    // SHORT   sThumbRY;

    // Thumb stick values in range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // Buttons pressed since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

	// Rumble properties
	XINPUT_RUMBLE	Rumble;
	XINPUT_FEEDBACK	Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetPrimaryController()
// Desc: The first controller used by the player or the controller on the
//       lowest numbered slot. NULL if no controllers inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* XBInput_GetPrimaryController();




//-----------------------------------------------------------------------------
// Name: XBInput_IsAnyButtonActive()
// Desc: TRUE if any button or thumbstick depressed on the given controller
//-----------------------------------------------------------------------------
BOOL XBInput_IsAnyButtonActive( const XBGAMEPAD* );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbApp.Cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
CXBApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;




//-----------------------------------------------------------------------------
// Name: CXBApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBApplication::CXBApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OutputDebugString( _T("XBApp: Creating Direct3D...\n") );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OutputDebugString( _T("XBApp: Unable to create Direct3D!\n") );
        return E_FAIL;
    }

    // Create the device
    OutputDebugString( _T("XBApp: Creating the D3D device...\n") );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OutputDebugString( _T("XBApp: Could not create D3D device!\n") );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Clear the backbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    OutputDebugString( _T("XBApp: Creating gamepad devices...\n") );
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        OutputDebugString( _T("XBApp: Call to CreateGamepads() failed!\n") );
        return hr;
    }

    // Initialize the app's device-dependent objects
    OutputDebugString( _T("XBApp: Initializing the app...\n") );
    if( FAILED( hr = Initialize() ) )
    {
        OutputDebugString( _T("XBApp: Call to Initialize() failed!\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID CXBApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT CXBApplication::Run()
{
    OutputDebugString( _T("XBApp: Running the application...\n") );

    // Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;

    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }

                // Check if we need to alter the current rumble value
                if( ( m_Gamepad[i].Rumble.wLeftMotorSpeed   != m_Gamepad[i].Feedback.Rumble.wLeftMotorSpeed  ) || 
                    ( m_Gamepad[i].Rumble.wRightMotorSpeed  != m_Gamepad[i].Feedback.Rumble.wRightMotorSpeed ) )
                {
                    // Check to see if we are still transferring current motor
                    // value. If so, we can't update. so just ignore it
                    if( m_Gamepad[i].Feedback.Header.dwStatus != ERROR_IO_PENDING )
                    {
                        // We can alter the motor values
                        m_Gamepad[i].Feedback.Rumble.wLeftMotorSpeed  = m_Gamepad[i].Rumble.wLeftMotorSpeed;
                        m_Gamepad[i].Feedback.Rumble.wRightMotorSpeed = m_Gamepad[i].Rumble.wRightMotorSpeed;
                        XInputSetState( m_Gamepad[i].hDevice, &m_Gamepad[i].Feedback );
                    }
                }
            }
        }

        // Handle special input functions:
        // -  Both triggers and white button triggers a screen dump
        // -  Both triggers and black button triggers a reboot
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                // With white button, dump the backbuffer contents
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
                    XGWriteSurfaceToFile( m_pBackBuffer, "D:\\BackBuffer.bmp" );

                // With black button, reboot to the Xbox Dashboard
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

        // Check Start button
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
            m_bPaused = !m_bPaused;

        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwElapsedTime.QuadPart));
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}




//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXBApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbFont.Cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbHelp.Cpp ===
//-----------------------------------------------------------------------------
// File: XBHelp.cpp
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.06.01 - Changes for April XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include "XBHelp.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Constants for rendering callouts on the help screen. The order of these
// callouts is in agreement with the enum structure in XBHelp.h
//-----------------------------------------------------------------------------
static D3DXVECTOR2 g_vHelpCallouts[] = 
{
    // Order:
    // Button position (start of line),
    // End of line for placement one, Start of text for placement one
    // End of line for placement two, Start of text for placement two

    // Left thumbstick
    D3DXVECTOR2( 255.0f, 149.0f ),
    D3DXVECTOR2( 141.0f,  99.0f ), D3DXVECTOR2( 108.0f,  77.0f ),
    D3DXVECTOR2( 145.0f, 124.0f ), D3DXVECTOR2( 108.0f,  77.0f ),
    
    // Right thumbstick 
    D3DXVECTOR2( 370.0f, 191.0f ),
    D3DXVECTOR2( 370.0f, 363.0f ), D3DXVECTOR2( 352.0f, 364.0f ),
    D3DXVECTOR2( 370.0f, 363.0f ), D3DXVECTOR2( 352.0f, 364.0f ),

    // D-pad
    D3DXVECTOR2( 254.0f, 194.0f ),
    D3DXVECTOR2( 117.0f, 223.0f ), D3DXVECTOR2(  78.0f, 222.0f ),
    D3DXVECTOR2( 117.0f, 223.0f ), D3DXVECTOR2(  78.0f, 222.0f ),
    
    // Back button
    D3DXVECTOR2( 288.0f, 221.0f ),
    D3DXVECTOR2( 185.0f, 284.0f ), D3DXVECTOR2( 145.0f, 282.0f ),
    D3DXVECTOR2( 185.0f, 284.0f ), D3DXVECTOR2( 145.0f, 282.0f ),

    // Start button
    D3DXVECTOR2( 322.0f, 223.0f ),
    D3DXVECTOR2( 262.0f, 343.0f ), D3DXVECTOR2( 217.0f, 340.0f ),
    D3DXVECTOR2( 262.0f, 343.0f ), D3DXVECTOR2( 217.0f, 340.0f ),

    // X button
    D3DXVECTOR2( 394.0f, 176.0f ),
    D3DXVECTOR2( 295.0f, 124.0f ), D3DXVECTOR2( 268.0f, 101.0f ),
    D3DXVECTOR2( 300.0f, 149.0f ), D3DXVECTOR2( 268.0f, 101.0f ),

    // Y button
    D3DXVECTOR2( 405.0f, 164.0f ),
    D3DXVECTOR2( 416.0f,  99.0f ), D3DXVECTOR2( 404.0f, 76.0f ),
    D3DXVECTOR2( 416.0f,  99.0f ), D3DXVECTOR2( 404.0f, 51.0f ),

    // A button
    D3DXVECTOR2( 411.0f, 189.0f ),
    D3DXVECTOR2( 431.0f, 298.0f ), D3DXVECTOR2( 424.0f, 298.0f ),
    D3DXVECTOR2( 431.0f, 298.0f ), D3DXVECTOR2( 424.0f, 298.0f ),

    // B button
    D3DXVECTOR2( 422.0f, 175.0f ),
    D3DXVECTOR2( 443.0f, 244.0f ), D3DXVECTOR2( 435.0f, 243.0f ),
    D3DXVECTOR2( 443.0f, 244.0f ), D3DXVECTOR2( 435.0f, 243.0f ),

    // White button
    D3DXVECTOR2( 424.0f, 158.0f ),
    D3DXVECTOR2( 458.0f, 124.0f ), D3DXVECTOR2( 444.0f, 102.0f ),
    D3DXVECTOR2( 448.0f, 148.0f ), D3DXVECTOR2( 444.0f, 102.0f ),
    
    // Black button
    D3DXVECTOR2( 443.0f, 170.0f ),
    D3DXVECTOR2( 456.0f, 183.0f ), D3DXVECTOR2( 442.0f, 182.0f ),
    D3DXVECTOR2( 456.0f, 183.0f ), D3DXVECTOR2( 442.0f, 182.0f ),

    // Left trigger button
    D3DXVECTOR2( 230.0f, 173.0f ),
    D3DXVECTOR2( 164.0f, 160.0f ), D3DXVECTOR2( 66.0f, 150.0f ),
    D3DXVECTOR2( 164.0f, 160.0f ), D3DXVECTOR2( 66.0f, 150.0f ),

    // Right trigger button
    D3DXVECTOR2( 462.0f, 172.0f ),
    D3DXVECTOR2( 480.0f, 170.0f ), D3DXVECTOR2( 482.0f, 158.0f ),
    D3DXVECTOR2( 480.0f, 170.0f ), D3DXVECTOR2( 482.0f, 158.0f ),

    // Misc callout
    D3DXVECTOR2(  64.0f, 380.0f ),
    D3DXVECTOR2(  64.0f, 380.0f ), D3DXVECTOR2( 64.0f, 405.0f ),
    D3DXVECTOR2(  64.0f, 380.0f ), D3DXVECTOR2( 64.0f, 380.0f ),
};




//-----------------------------------------------------------------------------
// Name: CXBHelp()
// Desc: Help class constructor
//-----------------------------------------------------------------------------
CXBHelp::CXBHelp()
{
    m_pd3dDevice      = NULL;
    m_pGamepadTexture = NULL;
    m_pVB             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBHelp()
// Desc: Help class destructor
//-----------------------------------------------------------------------------
CXBHelp::~CXBHelp()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Creates the help class' internal objects
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strResource )
{
    // Keep track of the device
    m_pd3dDevice = pd3dDevice;

    // Create the gamepad resource
    if( FAILED( m_xprResource.Create( pd3dDevice, strResource, 1 ) ) )
        return E_FAIL;

    // Store access to the 640x480, linear gamepad texture
    m_pGamepadTexture = m_xprResource.GetTexture( 0UL );

    // Create a vertex buffer for rendering the help screen
    m_pd3dDevice->CreateVertexBuffer( 4*6*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                      0L, D3DPOOL_DEFAULT, &m_pVB );
    struct VERTEX { D3DXVECTOR4 p; FLOAT tu, tv; };
    VERTEX* v;
    m_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
    v[0].p = D3DXVECTOR4(   0,   0, 0, 0 ); v[0].tu =   0; v[0].tv =   0;
    v[1].p = D3DXVECTOR4( 640,   0, 0, 0 ); v[1].tu = 639; v[1].tv =   0;
    v[2].p = D3DXVECTOR4( 640, 480, 0, 0 ); v[2].tu = 639; v[2].tv = 479;
    v[3].p = D3DXVECTOR4(   0, 480, 0, 0 ); v[3].tu =   0; v[3].tv = 479;
    m_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the help class' internal objects/
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Destroy()
{
    SAFE_RELEASE( m_pVB );
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the gamepad help image, and it's labelled callouts.
//-----------------------------------------------------------------------------
HRESULT CXBHelp::Render( CXBFont* pFont, XBHELP_CALLOUT* tags, 
                         DWORD dwNumCallouts )
{
    // Set state to render the gamepad image
    m_pd3dDevice->SetTexture( 0, m_pGamepadTexture );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,   FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,  D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,  D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_TEX1 );

    // Render the gamepad image
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 6*sizeof(FLOAT) );
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, 1 );

    // Set state to draw the lines
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW );

    for( DWORD i=0; i<dwNumCallouts; i++ )
    {
        // Determine the line start and end positions
        WORD wLineStartIndex = tags[i].wControl;
        WORD wLineEndIndex   = tags[i].wControl + 2*(tags[i].wPlacement-1)+1;
        FLOAT line1x = g_vHelpCallouts[wLineStartIndex].x;
        FLOAT line1y = g_vHelpCallouts[wLineStartIndex].y;
        FLOAT line2x = g_vHelpCallouts[wLineEndIndex].x;
        FLOAT line2y = g_vHelpCallouts[wLineEndIndex].y;

        // Draw the callout line
        D3DXVECTOR4 v[2];
        v[0] = D3DXVECTOR4( line1x, line1y, 0.0f, 0.0f );
        v[1] = D3DXVECTOR4( line2x, line2y, 0.0f, 0.0f );
        
        m_pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, v, sizeof(D3DXVECTOR4) );
    }

    // Prepare font for rendering
    pFont->Begin();

    // Render the callouts
    for( i=0; i<dwNumCallouts; i++ )
    {
        // Determine the text position
        WORD wTextPosIndex = tags[i].wControl + 2*(tags[i].wPlacement-1)+2;
        FLOAT textx = g_vHelpCallouts[wTextPosIndex].x;
        FLOAT texty = g_vHelpCallouts[wTextPosIndex].y;

        // Draw the callout text
        pFont->DrawText( textx, texty, 0xffffffff, tags[i].strText );
    }

    // Flush the text drawing
    pFont->End();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbApp.h ===
//-----------------------------------------------------------------------------
// File: XBApp.h
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class CXBApplication
// Desc: A base class for creating sample Xbox applications. To create a simple
//       Xbox application, simply derive this class and override the following
//       functions:
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class CXBApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize()            { return S_OK; }
    virtual HRESULT FrameMove()             { return S_OK; }
    virtual HRESULT Render()                { return S_OK; }
    virtual HRESULT Cleanup()               { return S_OK; }

public:
    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    CXBApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbHelp.h ===
//-----------------------------------------------------------------------------
// File: XBHelp.h
//
// Desc: Support class for rendering a help image, which is an image of an Xbox
//       gamepad, with labelled callouts to each of the gamepad's controls.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.06.01 - Changes for April XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBHELP_H
#define XBHELP_H
#include "XBFont.h"
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: struct XBHELP_CALLOUT
// Desc: Structure for callout information, used to label controls when
//       rendering an image of an Xbox gamepad. An app will define an array of
//       of these, one for each gamepad control used.
//-----------------------------------------------------------------------------
struct XBHELP_CALLOUT
{
    WORD     wControl;    // An index to identify a control, as enum'ed below
    WORD     wPlacement;  // An offset to pick from one of the possible placements
    WCHAR*   strText;     // Text to draw when rendering this callout
};




//-----------------------------------------------------------------------------
// Name: class CXBHelp
// Desc: Class for rendering a help image of a gamepad with labelled callouts.
//-----------------------------------------------------------------------------
class CXBHelp
{
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pGamepadTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVB;

public:
    // Constructor/destructor
    CXBHelp();
    ~CXBHelp();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* pResource );
    HRESULT Destroy();

    // Renders the help screen
    HRESULT Render( CXBFont* pFont, XBHELP_CALLOUT* tags, DWORD dwNumCallouts );
};




//-----------------------------------------------------------------------------
// A bunch of constants used to identify callout positions
//-----------------------------------------------------------------------------
enum
{   
    XBHELP_LEFTSTICK,
    XBHELP_LEFTSTICK_LINEEND_1, XBHELP_LEFTSTICK_TEXTPOS_1,
    XBHELP_LEFTSTICK_LINEEND_2, XBHELP_LEFTSTICK_TEXTPOS_2,

    XBHELP_RIGHTSTICK,
    XBHELP_RIGHTSTICK_LINEEND_1, XBHELP_RIGHTSTICK_TEXTPOS_1,
    XBHELP_RIGHTSTICK_LINEEND_2, XBHELP_RIGHTSTICK_TEXTPOS_2,

    XBHELP_DPAD,
    XBHELP_DPAD_LINEEND_1, XBHELP_DPAD_TEXTPOS_1,
    XBHELP_DPAD_LINEEND_2, XBHELP_DPAD_TEXTPOS_2,

    XBHELP_BACK_BUTTON,
    XBHELP_BACK_BUTTON_LINEEND_1, XBHELP_BACK_BUTTON_TEXTPOS_1,
    XBHELP_BACK_BUTTON_LINEEND_2, XBHELP_BACK_BUTTON_TEXTPOS_2,

    XBHELP_START_BUTTON,
    XBHELP_START_BUTTON_LINEEND_1, XBHELP_START_BUTTON_TEXTPOS_1,
    XBHELP_START_BUTTON_LINEEND_2, XBHELP_START_BUTTON_TEXTPOS_2,

    XBHELP_X_BUTTON,
    XBHELP_X_BUTTON_LINEEND_1, XBHELP_X_BUTTON_TEXTPOS_1,
    XBHELP_X_BUTTON_LINEEND_2, XBHELP_X_BUTTON_TEXTPOS_2,

    XBHELP_Y_BUTTON,
    XBHELP_Y_BUTTON_LINEEND_1, XBHELP_Y_BUTTON_TEXTPOS_1,
    XBHELP_Y_BUTTON_LINEEND_2, XBHELP_Y_BUTTON_TEXTPOS_2,

    XBHELP_A_BUTTON,
    XBHELP_A_BUTTON_LINEEND_1, XBHELP_A_BUTTON_TEXTPOS_1,
    XBHELP_A_BUTTON_LINEEND_2, XBHELP_A_BUTTON_TEXTPOS_2,

    XBHELP_B_BUTTON,
    XBHELP_B_BUTTON_LINEEND_1, XBHELP_B_BUTTON_TEXTPOS_1,
    XBHELP_B_BUTTON_LINEEND_2, XBHELP_B_BUTTON_TEXTPOS_2,

    XBHELP_WHITE_BUTTON,
    XBHELP_WHITE_BUTTON_LINEEND_1, XBHELP_WHITE_BUTTON_TEXTPOS_1,
    XBHELP_WHITE_BUTTON_LINEEND_2, XBHELP_WHITE_BUTTON_TEXTPOS_2,

    XBHELP_BLACK_BUTTON,
    XBHELP_BLACK_BUTTON_LINEEND_1, XBHELP_BLACK_BUTTON_TEXTPOS_1,
    XBHELP_BLACK_BUTTON_LINEEND_2, XBHELP_BLACK_BUTTON_TEXTPOS_2,

    XBHELP_LEFT_BUTTON,
    XBHELP_LEFT_BUTTON_LINEEND_1, XBHELP_LEFT_BUTTON_TEXTPOS_1,
    XBHELP_LEFT_BUTTON_LINEEND_2, XBHELP_LEFT_BUTTON_TEXTPOS_2,

    XBHELP_RIGHT_BUTTON,
    XBHELP_RIGHT_BUTTON_LINEEND_1, XBHELP_RIGHT_BUTTON_TEXTPOS_1,
    XBHELP_RIGHT_BUTTON_LINEEND_2, XBHELP_RIGHT_BUTTON_TEXTPOS_2,

    XBHELP_MISC_CALLOUT,
    XBHELP_MISC_CALLOUT_LINEEND_1, XBHELP_MISC_CALLOUT_TEXTPOS_1,
    XBHELP_MISC_CALLOUT_LINEEND_2, XBHELP_MISC_CALLOUT_TEXTPOS_2,
};




//-----------------------------------------------------------------------------
// Placement options for each callout, used as an offset into the enumerated
// list above.
//-----------------------------------------------------------------------------
#define XBHELP_PLACEMENT_CUSTOM 0   // For future implementation
#define XBHELP_PLACEMENT_1      1   // Callout has one line of text
#define XBHELP_PLACEMENT_2      2   // Callout has two lines of text




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbInput.Cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.25

// Threshold for analog buttons
#define XBINPUT_BUTTONTHRESHOLD 1

// Global instance of gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
			pGamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
			pGamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( pGamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            pGamepads[i].wButtons          = xiState.Gamepad.wButtons;
            pGamepads[i].bAnalogButtons[0] = xiState.Gamepad.bAnalogButtons[0];
            pGamepads[i].bAnalogButtons[1] = xiState.Gamepad.bAnalogButtons[1];
            pGamepads[i].bAnalogButtons[2] = xiState.Gamepad.bAnalogButtons[2];
            pGamepads[i].bAnalogButtons[3] = xiState.Gamepad.bAnalogButtons[3];
            pGamepads[i].bAnalogButtons[4] = xiState.Gamepad.bAnalogButtons[4];
            pGamepads[i].bAnalogButtons[5] = xiState.Gamepad.bAnalogButtons[5];
            pGamepads[i].bAnalogButtons[6] = xiState.Gamepad.bAnalogButtons[6];
            pGamepads[i].bAnalogButtons[7] = xiState.Gamepad.bAnalogButtons[7];
            pGamepads[i].sThumbLX          = xiState.Gamepad.sThumbLX;
            pGamepads[i].sThumbLY          = xiState.Gamepad.sThumbLY;
            pGamepads[i].sThumbRX          = xiState.Gamepad.sThumbRX;
            pGamepads[i].sThumbRY          = xiState.Gamepad.sThumbRY;

            // Put Xbox device input for the gamepad into our custom format
            pGamepads[i].fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fX1) < XBINPUT_DEADZONE )
                pGamepads[i].fX1 = 0.0f;

            pGamepads[i].fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fY1) < XBINPUT_DEADZONE )
                pGamepads[i].fY1 = 0.0f;

            pGamepads[i].fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fX2) < XBINPUT_DEADZONE )
                pGamepads[i].fX2 = 0.0f;

            pGamepads[i].fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            if( fabsf(pGamepads[i].fY2) < XBINPUT_DEADZONE ) 
                pGamepads[i].fY2 = 0.0f;

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed since the last
            // call. Here, we considered an analog button pressed (a boolean 
            // condition) if that value is >= the threshold.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] >= XBINPUT_BUTTONTHRESHOLD );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}



//-----------------------------------------------------------------------------
// Name: XBInput_GetPrimaryController()
// Desc: The primary controller is the first controller used by a player.
//       If no controller has been used or the controller has been removed,
//       the primary controller is the controller inserted at the lowest 
//       port number. Function returns NULL if no controller is inserted.
//-----------------------------------------------------------------------------
const XBGAMEPAD* XBInput_GetPrimaryController()
{
    static INT nPrimaryController = -1;

    // If primary controller has been set and hasn't been removed, use it
    const XBGAMEPAD* pGamePad = NULL;
    if( nPrimaryController != -1 )
    {
        pGamePad = &g_Gamepads[ nPrimaryController ];
        if( pGamePad->hDevice != NULL )
            return pGamePad;
    }

    // Primary controller hasn't been set or has been removed...

    // Examine each inserted controller to see if any is being used
    INT nFirst = -1;
    for( DWORD i=0; i < XGetPortCount(); ++i )
    {
        pGamePad = &g_Gamepads[i];
        if( pGamePad->hDevice != NULL )
        {
            // Remember the lowest inserted controller ID
            if( nFirst == -1 )
                nFirst = i;

            // If any button is active, we found the primary controller
            if( XBInput_IsAnyButtonActive( pGamePad ) )
            {
                nPrimaryController = i;
                return pGamePad;
            }
        }
    }

    // No controllers are inserted
    if( nFirst == -1 )
        return NULL;

    // The primary controller hasn't been set and no controller has been
    // used yet, so return the controller on the lowest port number
    pGamePad = &g_Gamepads[ nFirst ];
    return pGamePad;
}




//-----------------------------------------------------------------------------
// Name: XBInput_IsAnyButtonActive()
// Desc: TRUE if any button depressed or any thumbstick offset on the given
//       controller.
//-----------------------------------------------------------------------------
BOOL XBInput_IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return TRUE;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] )
            return TRUE;
    }

    // Check thumbsticks
    if( pGamePad->fX1 >  XBINPUT_DEADZONE ||
        pGamePad->fX1 < -XBINPUT_DEADZONE ||
        pGamePad->fY1 >  XBINPUT_DEADZONE ||
        pGamePad->fY1 < -XBINPUT_DEADZONE )
    {
        return TRUE;
    }

    if( pGamePad->fX2 >  XBINPUT_DEADZONE ||
        pGamePad->fX2 < -XBINPUT_DEADZONE ||
        pGamePad->fY2 >  XBINPUT_DEADZONE ||
        pGamePad->fY2 < -XBINPUT_DEADZONE )
    {
        return TRUE;
    }

    // Nothing active
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbFont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\Xbmesh.Cpp ===
//-----------------------------------------------------------------------------
// File: XBMesh.cpp
//
// Desc: Support code for loading geometry stored in .xbg files. See the
//       <XBMesh.h> header file for information on using this class.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.15.01 - Mass changes (removed D3DX and .x support) for April XDK
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgmath.h>
#include <stdio.h>
#include "XBMesh.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: CXBMesh()
// Desc: 
//-----------------------------------------------------------------------------
CXBMesh::CXBMesh()
{
    m_pAllocatedSysMem = NULL;
    m_pAllocatedVidMem = NULL;
    m_pMeshFrames      = NULL;
    m_dwNumFrames      = 0;
    m_dwRefCount       = 1L;
}




//-----------------------------------------------------------------------------
// Name: ~CXBMesh()
// Desc: 
//-----------------------------------------------------------------------------
CXBMesh::~CXBMesh()
{
    // Free textures
    for( DWORD i=0; i<m_dwNumFrames; i++ )
    {
        for( DWORD j = 0; j < m_pMeshFrames[i].m_MeshData.m_dwNumSubsets; j++ )
        {
            SAFE_RELEASE( m_pMeshFrames[i].m_MeshData.m_pSubsets[j].pTexture );
        }
    }

    // Free alloacted memory
    if( m_pAllocatedSysMem )
        delete[] m_pAllocatedSysMem;

    if( m_pAllocatedVidMem )
        D3D_FreeContiguousMemory( m_pAllocatedVidMem );
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                         CXBPackedResource* pResource )
{
    // Find the media file
    CHAR strMeshPath[512];
    if( FAILED( XBUtil_FindMediaFile( strMeshPath, strFilename ) ) )
        return E_FAIL;

    // Open the file
    FILE* file = fopen( strMeshPath, "rb" );
    if( file == NULL )
    {
        OutputDebugString( _T("CXBFile::Create(): ERROR: File not found!\n") );
        return E_FAIL;
    }

    // Read the magic number
    DWORD dwFileID;
    fread( &dwFileID, 1, sizeof(DWORD), file ); 

    if( dwFileID != XBG_FILE_ID )
    {
        OutputDebugString( _T("CXBFile::Create(): ERROR: Invalid XBG file type!\n") );
        fclose( file );
        return E_FAIL;
    }

    // Read in header
    DWORD dwNumFrames;  // Number of mesh frames in the file
    DWORD dwSysMemSize; // Num bytes needed for system memory objects
    DWORD dwVidMemSize; // Num bytes needed for video memory objects

    fread( &dwNumFrames,  1, sizeof(DWORD), file );
    fread( &dwSysMemSize, 1, sizeof(DWORD), file );
    fread( &dwVidMemSize, 1, sizeof(DWORD), file );

    // Read in system memory objects
    m_pAllocatedSysMem = (VOID*)new BYTE[dwSysMemSize];
    fread( m_pAllocatedSysMem, dwSysMemSize, 1, file );

    // Read in video memory objects
    m_pAllocatedVidMem = D3D_AllocContiguousMemory( dwVidMemSize, D3DVERTEXBUFFER_ALIGNMENT );
    fread( m_pAllocatedVidMem, dwVidMemSize, 1, file ); 
    
    // Done with the file
    fclose( file );

    // Now we need to patch the mesh data. Any pointers read from the file were
    // stored as file offsets. So, we simply need to add a base address to patch
    // things up.
    m_pMeshFrames = (XBMESH_FRAME*)m_pAllocatedSysMem;
    m_dwNumFrames = dwNumFrames;

    for( DWORD i=0; i<m_dwNumFrames; i++ )
    {
        XBMESH_FRAME* pFrame = &m_pMeshFrames[i];
        XBMESH_DATA*  pMesh  = &m_pMeshFrames[i].m_MeshData;

        if( pFrame->m_pChild )
            pFrame->m_pChild  = (XBMESH_FRAME*)( (DWORD)pFrame->m_pChild - 16 + (DWORD)m_pMeshFrames );
        if( pFrame->m_pNext )
            pFrame->m_pNext   = (XBMESH_FRAME*)( (DWORD)pFrame->m_pNext  - 16 + (DWORD)m_pMeshFrames );
        if( pMesh->m_pSubsets )
            pMesh->m_pSubsets = (XBMESH_SUBSET*)( (DWORD)pMesh->m_pSubsets - 16 + (DWORD)m_pMeshFrames);
        
        if( pMesh->m_dwNumIndices )
            pMesh->m_IB.Data  = pMesh->m_IB.Data - 16 + (DWORD)m_pMeshFrames;
        if( pMesh->m_dwNumVertices )
            pMesh->m_VB.Register( m_pAllocatedVidMem );
    }

    // Finally, create any textures used by the meshes' subsets. In this 
    // implementation, we are pulling textures out of the passed in resource.
    if( pResource )
    {
        for( DWORD i=0; i<m_dwNumFrames; i++ )
        {
            XBMESH_DATA* pMesh = &m_pMeshFrames[i].m_MeshData;

            for( DWORD j = 0; j < pMesh->m_dwNumSubsets; j++ )
            {
                XBMESH_SUBSET* pSubset = &pMesh->m_pSubsets[j];

                pSubset->pTexture = pResource->GetTexture( pSubset->strTexture );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the hierarchy of frames and meshes.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags )
{
    if( m_pMeshFrames )
        RenderFrame( pd3dDevice, m_pMeshFrames, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderFrame()
// Desc: Renders a frame (save state, apply matrix, render children, restore).
//-----------------------------------------------------------------------------
HRESULT CXBMesh::RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pFrame, 
                              DWORD dwFlags )
{
    // Apply the frame's local transform
    D3DXMATRIX matSavedWorld, matWorld;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld );
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, &matSavedWorld );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Render the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        RenderMesh( pd3dDevice, &pFrame->m_MeshData, dwFlags );

    // Render any child frames
    if( pFrame->m_pChild ) 
        RenderFrame( pd3dDevice, pFrame->m_pChild, dwFlags );

    // Restore the transformation matrix
    pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld );
    
    // Render any sibling frames
    if( pFrame->m_pNext )  
        RenderFrame( pd3dDevice, pFrame->m_pNext, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderMesh()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                             DWORD dwFlags )
{
    D3DVertexBuffer* pVB           = &pMesh->m_VB;
    DWORD            dwNumVertices =  pMesh->m_dwNumVertices;
    D3DIndexBuffer*  pIB           = &pMesh->m_IB;
    DWORD            dwNumIndices  =  pMesh->m_dwNumIndices;
    DWORD            dwFVF         =  pMesh->m_dwFVF;
    DWORD            dwVertexSize  =  pMesh->m_dwVertexSize;
    D3DPRIMITIVETYPE dwPrimType    =  pMesh->m_dwPrimType;
    DWORD            dwNumSubsets  =  pMesh->m_dwNumSubsets;
    XBMESH_SUBSET*   pSubsets      = &pMesh->m_pSubsets[0];

    if( dwNumVertices == 0 )
        return S_OK;

    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, pVB, dwVertexSize );
    pd3dDevice->SetIndices( pIB, 0 );

    // Set the FVF code, unless the user asked us not to
    if( 0 == ( dwFlags & XBMESH_NOFVF ) )
        pd3dDevice->SetVertexShader( dwFVF );

    // Render the subsets
    for( DWORD i = 0; i < dwNumSubsets; i++ )
    {
        BOOL bRender = FALSE;

        // Render the opaque subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_ALPHAONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    bRender = TRUE;
            }
            else
                bRender = TRUE;
        }

        // Render the transparent subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_OPAQUEONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    bRender = TRUE;
            }
        }

        if( bRender )
        {
            // Set the material, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
                pd3dDevice->SetMaterial( &pSubsets[i].mtrl );

            // Set the texture, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOTEXTURES ) )
                pd3dDevice->SetTexture( 0, pSubsets[i].pTexture );

            // Call the callback, so the app can tweak state before rendering
            // each subset
            BOOL bRenderSubset = RenderCallback( pd3dDevice, i, &pSubsets[i], dwFlags );

            // Draw the mesh subset
            if( bRenderSubset )
            {
                DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == dwPrimType ) ? pSubsets[i].dwIndexCount-2 : pSubsets[i].dwIndexCount/3;
                pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, pSubsets[i].dwIndexCount,
                                                  pSubsets[i].dwIndexStart, dwNumPrimitives );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ComputeRadius()
// Desc: Finds the farthest point from zero on the mesh.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeRadius()
{
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );

    return ComputeFrameRadius( m_pMeshFrames, &matIdentity );
}




//-----------------------------------------------------------------------------
// Name: ComputeFrameRadius()
// Desc: Calls ComputeMeshRadius for each frame with the correct transform.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeFrameRadius( XBMESH_FRAME* pFrame, D3DXMATRIX* pmatParent )
{
    // Apply the frame's local transform
    D3DXMATRIX matWorld;
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, pmatParent );

    FLOAT fRadius = 0.0f;

    // Compute bounds for the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        fRadius = ComputeMeshRadius( &pFrame->m_MeshData, &matWorld );

    // Compute bounds for any child frames
    if( pFrame->m_pChild ) 
    {
        FLOAT fChildRadius = ComputeFrameRadius( pFrame->m_pChild, &matWorld  );

        if( fChildRadius > fRadius )
            fRadius = fChildRadius;
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )  
    {
        FLOAT fSiblingRadius = ComputeFrameRadius( pFrame->m_pNext, pmatParent );

        if( fSiblingRadius > fRadius )
            fRadius = fSiblingRadius;
    }

    return fRadius;
}




//-----------------------------------------------------------------------------
// Name: ComputeMeshRadius()
// Desc: Finds the farthest point from zero on the mesh.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeMeshRadius( XBMESH_DATA* pMesh, D3DXMATRIX* pmat )
{
    DWORD       dwNumVertices = pMesh->m_dwNumVertices;
    DWORD       dwVertexSize  = pMesh->m_dwVertexSize;
    BYTE*       pVertices;
    D3DXVECTOR3 vPos;
    FLOAT       fMaxDist2 = 0.0f;

    pMesh->m_VB.Lock( 0, 0, &pVertices, 0 );

    while( dwNumVertices-- )
    {
        D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pmat );

        FLOAT fDist2 = vPos.x*vPos.x + vPos.y*vPos.y + vPos.z*vPos.z;

        if( fDist2 > fMaxDist2 )
            fMaxDist2 = fDist2;

        pVertices += dwVertexSize;
    }

    pMesh->m_VB.Unlock();

    return sqrtf( fMaxDist2 );
}

//-----------------------------------------------------------------------------
//  Take the union of two boxes
//-----------------------------------------------------------------------------
inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }
static void UnionBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)
{
	pvMin->x = MIN(pvMin->x, vMin.x);
	pvMin->y = MIN(pvMin->y, vMin.y);
	pvMin->z = MIN(pvMin->z, vMin.z);
	pvMax->x = MAX(pvMax->x, vMax.x);
	pvMax->y = MAX(pvMax->y, vMax.y);
	pvMax->z = MAX(pvMax->z, vMax.z);
}

//-----------------------------------------------------------------------------
// Name: ComputeBoundingBox()
// Desc: Calculates the bounding box of the entire hierarchy.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );
    return ComputeFrameBoundingBox( m_pMeshFrames, &matIdentity, pvMin, pvMax );
}

//-----------------------------------------------------------------------------
// Name: ComputeFrameBoundingBox()
// Desc: Calls ComputeMeshBoundingBox for each frame with the correct transform.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeFrameBoundingBox( XBMESH_FRAME* pFrame, D3DXMATRIX* pmatParent, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	HRESULT hr;
	
	// initialize bounds to be reset on the first UnionBox
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;
	
    // Apply the frame's local transform
    D3DXMATRIX matWorld;
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, pmatParent );

    // Compute bounds for the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets )
	{
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeMeshBoundingBox( &pFrame->m_MeshData, &matWorld, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
	}

    // Compute bounds for any child frames
    if( pFrame->m_pChild ) 
    {
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeFrameBoundingBox( pFrame->m_pChild, &matWorld, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )  
    {
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeFrameBoundingBox( pFrame->m_pNext, pmatParent, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ComputeMeshBoundingBox()
// Desc: Calculate the bounding box of the transformed mesh.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeMeshBoundingBox( XBMESH_DATA* pMesh, D3DXMATRIX* pmat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	// initialize bounds to be reset on the first point
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;
    DWORD       dwNumVertices = pMesh->m_dwNumVertices;
    DWORD       dwVertexSize  = pMesh->m_dwVertexSize;
    BYTE*       pVertices;
    D3DXVECTOR3 vPos;
    pMesh->m_VB.Lock( 0, 0, &pVertices, 0 );
    while( dwNumVertices-- )
    {
        D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pmat );
		UnionBox(pvMin, pvMax, vPos, vPos);	// expand the bounding box to include the point
        pVertices += dwVertexSize;
    }
    pMesh->m_VB.Unlock();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\Xbmesh.h ===
//-----------------------------------------------------------------------------
// File: XBMesh.h
//
// Desc: Support code for loading geometry stored in .xbg files. These files
//       typically converted from .x geometry files using the MakeXBG tool. See
//       that tool for more information.
//
//       XBG files were designed to minimalize overhead in the loading and
//       rendering process on the Xbox. The data in a .xbg file is basically
//       stored in one system memory chunk, and one video memory chunk.
//       Therefore, loading a .xbg file is simply two fread() calls followed
//       by some patchup (which turns file offsets into real pointers).
//
//       Geometry files are loaded into arrays of the following structures.
//       XBMESH_FRAME structures contain data to make a frame hierarchy (such
//       as "next" and "child" pointers, plus a transformation matrix). The
//       XMMESH_DATA structure contains data for rendering a mesh (such as
//       the vertex buffer, num of indices, etc.). Finally, the XBMESH_SUBSET
//       structure contains subset properties (materials and textures) and
//       primitive ranges (start index, index count, etc.) for each subset of
//       the data in the XBMESH_DATA structure.
//
//       To use this class, simply instantiate the class, and call Create().
//       Thereafter, the mesh can be rendered with the Render() call. Some
//       render flags are available (see below) to limit what gets rendered.
//       For instance, an app might want to render opaque subsets only, or
//       use a custom vertex shader. For truely custom control, override the
//       CXBMesh class with a new RenderCallback() function, and put any
//       custom pre-rendering code in the callback. The typical use for this
//       is to pass data to a custom vertex shader.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.15.01 - Mass changes (removed D3DX and .x support) for April XDK
//       04.15.01 - Using packed resources for May XDK
//       04.17.01 - 16-byte aligning matrices in the file format
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBMESH_H
#define XBMESH_H
#include "XBResource.h"
#include "XBUtil.h"




// Rendering flags. Default is no flags (0x00000000)
#define XBMESH_OPAQUEONLY      0x00000001 // Only render opaque subsets
#define XBMESH_ALPHAONLY       0x00000002 // Only render alpha subsets

#define XBMESH_NOMATERIALS     0x00000010 // Do not use mesh materials
#define XBMESH_NOTEXTURES      0x00000020 // Do not use mesh textures
#define XBMESH_NOFVF           0x00000040 // Do not use mesh FVF code


// The magic number to identify .xbg files
#define XBG_FILE_ID (((DWORD)'X'<<0)|(((DWORD)'B'<<8))|(((DWORD)'G'<<16))|(2<<24))




//-----------------------------------------------------------------------------
// Name: struct XBMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBMESH_SUBSET
{
    D3DMATERIAL8       mtrl;            // Material for this subset
    LPDIRECT3DTEXTURE8 pTexture;        // Texture
    CHAR               strTexture[64];
    DWORD              dwVertexStart;   // Range of vertices to render
    DWORD              dwVertexCount;
    DWORD              dwIndexStart;    // Range of vertex indices to render
    DWORD              dwIndexCount;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_DATA
// Desc: Struct for mesh data
//-----------------------------------------------------------------------------
struct XBMESH_DATA
{
    D3DVertexBuffer   m_VB;            // Mesh geometry
    DWORD             m_dwNumVertices;
    D3DIndexBuffer    m_IB;
    DWORD             m_dwNumIndices;
    
    DWORD             m_dwFVF;         // Mesh vertex info
    DWORD             m_dwVertexSize;
    D3DPRIMITIVETYPE  m_dwPrimType;

    DWORD             m_dwNumSubsets;  // Subset info for rendering calls
    XBMESH_SUBSET*    m_pSubsets;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESHFRAME
// Desc: Struct for building a hierarchy of meshes.
//-----------------------------------------------------------------------------
__declspec(align(16)) struct XBMESH_FRAME
{
    D3DXMATRIX        m_matTransform; // The transformation matrix for this frame
    
    XBMESH_DATA       m_MeshData;     // The mesh data belonging to this frame

    CHAR              m_strName[64];
    
    XBMESH_FRAME*     m_pChild;       // Child and sibling ptrs for the hierarchy
    XBMESH_FRAME*     m_pNext;
};




//-----------------------------------------------------------------------------
// Name: class CXBMesh
// Desc: Wrapper class for loading geoemtry files, and rendering the resulting
//       hierachy of meshes and frames.
//-----------------------------------------------------------------------------
class CXBMesh
{
    // Memory allocated during file loading. Ptrs are retained for cleanup.
    VOID* m_pAllocatedSysMem;
    VOID* m_pAllocatedVidMem;

public:
    // Hierarchy (frames and meshes) of loaded geometry
    XBMESH_FRAME* m_pMeshFrames;
    DWORD         m_dwNumFrames;

    // Internal rendering functions
    virtual HRESULT RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pMesh, 
                                 DWORD dwFlags );
    virtual HRESULT RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                                DWORD dwFlags );

    // Internal functions to find the radius of sphere centered at zero enclosing mesh.
    float ComputeFrameRadius(XBMESH_FRAME* pFrame, D3DXMATRIX* pParentMat);
    float ComputeMeshRadius(XBMESH_DATA* pMesh, D3DXMATRIX* pMat);
	
    // Internal functions to find the bounding box of the mesh.
    HRESULT ComputeFrameBoundingBox(XBMESH_FRAME* pFrame, D3DXMATRIX* pParentMat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
	HRESULT ComputeMeshBoundingBox(XBMESH_DATA* pMesh, D3DXMATRIX* pMat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);

public:
    // Reference counting
    DWORD   m_dwRefCount;
    DWORD   AddRef()  { return ++m_dwRefCount; }
    DWORD   Release() { if( --m_dwRefCount ) return m_dwRefCount;
                        delete this; return 0L; }

public:
    // Constructor/destructor
    CXBMesh();
    virtual ~CXBMesh();

    // Creation function. Call this function to create the hierarchy of frames
    // and meshes from a geometry file.
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                    CXBPackedResource* pResource = NULL );

    // Access functions
    XBMESH_FRAME* GetFrame( DWORD i ) { return &m_pMeshFrames[i]; }
    XBMESH_DATA*  GetMesh( DWORD i )  { return &m_pMeshFrames[i].m_MeshData; }

    // Overridable callback function (called before anything is rendered). 
    // This is useful for setting vertex shader constants, etc., before
    // rendering.
    virtual BOOL RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                                 XBMESH_SUBSET* pSubset, DWORD dwFlags ) { return TRUE; }
    
    // Render function. Call this function to render the hierarchy of frames
    // and meshes.
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags = 0x00000000 );

    // Function to find the radius of sphere centered at zero enclosing mesh.
    float ComputeRadius();
    // find the bounding box of all the subsets
	HRESULT ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbUtil.Cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\ChildView.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ChildView.h

Abstract:

	Main window

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version
	17-Jul-2001	robheit
		Added support for the application toolbar

--*/
#if !defined(AFX_CHILDVIEW_H__147C6C30_763C_4DA0_B48D_424E36301991__INCLUDED_)
#define AFX_CHILDVIEW_H__147C6C30_763C_4DA0_B48D_424E36301991__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Winsock2.h"
#include "Graph.h"

//------------------------------------------------------------------------------
//	CChildView
//------------------------------------------------------------------------------
class CChildView : public CWnd
{
// Construction
public:

	CChildView();
	virtual ~CChildView();

public:
	
	void EnableMenuItem(CMenu*	pPopupMenu, UINT nIndex);
	BOOL Quit(void);
	LPCTSTR GetStatusBarText(void);
	void Reset(void);
	void UpdateScrollBars(void);
	void TransmitModuleParameters(const CModule* pModule, int index=-1);
	
//	inline const CPoint& GetOffset(void) const { return m_offset; };
//	inline BOOL GetConnected(void) const { return m_bConnected; };

protected:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildView)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

	void OnUpdateXboxTransmitImageUI(CCmdUI* pCmdUI);
	void OnUpdateFileNewUI(CCmdUI* pCmdUI);
	void OnUpdateFileSaveUI(CCmdUI* pCmdUI);
	void OnUpdateFileOpenUI(CCmdUI* pCmdUI);
	void OnUpdateFileGenSaveImgUI(CCmdUI* pCmdUI);

	// Generated message map functions
protected:
	//{{AFX_MSG(CChildView)
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnFileGenerateAndSaveImage();
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	afx_msg void OnFileOpen();
	afx_msg void OnFileNew();
	afx_msg void OnXboxTransmitImage();
	afx_msg void OnToolsDirectories();
	afx_msg void OnToolsBuildOptions();
	afx_msg void OnToolsTransmitOptions();
	afx_msg void OnGraphShowGrid();
	afx_msg void OnToolsSnapToGrid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	BOOL Connect(LPCTSTR);
	void Disconnect(void);
	DWORD GetCRC(const VOID* pBuffer, ULONG bufferSize) const;

private:

	CGraph*		m_pGraph;
	BOOL		m_bConnected;
	SOCKET		m_socket;
	CString		m_xboxName;
	CString		m_statusBarText;
	CString		m_transmitDestination;
	CPoint		m_offset;
	int			m_width;
	int			m_height;
	DWORD		m_dwParamOffset;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDVIEW_H__147C6C30_763C_4DA0_B48D_424E36301991__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\cipher.cpp ===
#include "..\xcodescr\cipher.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbUtil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\DMConsole\XbResource.Cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Under UMA emulation, we copy the data from AGP memory to video memory.
    // This will not be necessary with final hardware
    D3D_CopyContiguousMemoryToVideo( m_pVidMemData );

    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\ChildView.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ChildView.cpp

Abstract:

	The primary window for the dsp builder

Author:

	Robert Heitkamp (robheit) 07-May-2001

Revision History:

	07-May-2001 robheit
		Initial Version
	17-Jul-2001 robheit
		Added the toolbar support

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "ChildView.h"
#include "ConnectDialog.h"
#include "DirsDialog.h"
#include "Module.h"

//------------------------------------------------------------------------------
//	Stuff:
//------------------------------------------------------------------------------
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------------------------
//	Versions:
//------------------------------------------------------------------------------
static const BYTE cDspImageVersion	= 2;
static const BYTE cDspIndexVersion	= 1;
static const BYTE cFXParamsVersion	= 1;
static const BYTE cI3DL2Version		= 1;

//------------------------------------------------------------------------------
//	CChildView::CChildView
//------------------------------------------------------------------------------
CChildView::CChildView(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	char					name[256];
	DWORD					length = 256;
	DSFX_AMPMOD_MONO_STATE	effect;

	m_pGraph		= NULL;
	m_bConnected	= FALSE;
	m_width			= 0;
	m_height		= 0;
	m_offset.x		= 0;
	m_offset.y		= 0;
	m_dwParamOffset	= (DWORD)&effect.dwInMixbinPtrs - (DWORD)&effect;
	m_socket		= INVALID_SOCKET;

	WSADATA wsaData;
	unsigned short version = MAKEWORD(2, 2);
	WSAStartup(version, &wsaData);

	// Get the Xbox name
	if(DmGetXboxName(name, &length) == XBDM_NOERR)
	{
		m_xboxName = name;
		m_xboxName += ":80";

		m_transmitDestination = m_xboxName;
	}
}

//------------------------------------------------------------------------------
//	CChildView::~CChildView
//------------------------------------------------------------------------------
CChildView::~CChildView(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pGraph)
		delete m_pGraph;

	Disconnect();
}

//------------------------------------------------------------------------------
//	Message Map
//------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CChildView,CWnd )
	//{{AFX_MSG_MAP(CChildView)
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONDOWN()
	ON_WM_SIZE()
	ON_WM_VSCROLL()
	ON_WM_HSCROLL()
	ON_WM_MOUSEWHEEL()
	ON_WM_MOUSEMOVE()
	ON_COMMAND(ID_FILE_GENERATE_AND_SAVE_IMAGE, OnFileGenerateAndSaveImage)
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
	ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
	ON_COMMAND(ID_XBOX_TRANSMIT_IMAGE, OnXboxTransmitImage)
	ON_UPDATE_COMMAND_UI(ID_XBOX_TRANSMIT_IMAGE, OnUpdateXboxTransmitImageUI)
	ON_UPDATE_COMMAND_UI(ID_FILE_NEW, OnUpdateFileNewUI)
	ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSaveUI)
	ON_UPDATE_COMMAND_UI(ID_FILE_OPEN, OnUpdateFileOpenUI)
	ON_UPDATE_COMMAND_UI(ID_FILE_GENERATE_AND_SAVE_IMAGE, OnUpdateFileGenSaveImgUI)
	ON_COMMAND(IDC_TOOLS_DIRECTORIES, OnToolsDirectories)
	ON_COMMAND(IDC_TOOLS_BUILD_OPTIONS, OnToolsBuildOptions)
	ON_COMMAND(IDC_TOOLS_TRANSMIT_OPTIONS, OnToolsTransmitOptions)
	ON_COMMAND(ID_GRID_SHOW_GRID, OnGraphShowGrid)
	ON_COMMAND(IDC_TOOLS_SNAP_TO_GRID, OnToolsSnapToGrid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------------
//	CChildView::PreCreateWindow
//------------------------------------------------------------------------------
BOOL 
CChildView::PreCreateWindow(
							IN OUT CREATESTRUCT&	cs
							) 
/*++

Routine Description:

	Called before the window is created to adjust in initialization params

Arguments:

	IN OUT cs -	CREATESTRUCT (modify this)

Return Value:

	TRUE on success, otherwise FALSE

--*/
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	cs.dwExStyle	|= WS_EX_CLIENTEDGE;
	cs.style		&= ~WS_BORDER;
	cs.style		|= WS_VSCROLL | WS_HSCROLL;
	cs.lpszClass	= AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, 
										  ::LoadCursor(NULL, IDC_ARROW), 
										  HBRUSH(COLOR_WINDOW+1), NULL);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CChildView::OnPaint
//------------------------------------------------------------------------------
void 
CChildView::OnPaint(void) 
/*++

Routine Description:

	Handles all expose events

Arguments:

	None

Return Value:

	None

--*/
{
	CRect	rect;

	if(!m_pGraph)
		return;

	// Get the update region before creating the CPaintDC because CPaintDC
	// will clear the region
	GetUpdateRect(rect);

	rect += m_pGraph->GetRect().TopLeft();

	CPaintDC	dc(this);

	m_pGraph->Draw(rect, &dc);
}

//------------------------------------------------------------------------------
//	CChildView::OnCreate
//------------------------------------------------------------------------------
int 
CChildView::OnCreate(
					 IN OUT LPCREATESTRUCT	lpCreateStruct
					 ) 
/*++

Routine Description:

	Create event. Create the grid and setup the scroll bars

Arguments:

	IN OUT lpCreateStruct -	Create parameters

Return Value:

	0 on success, anything else on failure

--*/
{
	SCROLLINFO	scrollInfo;
	CRect		rect;

	// Base class callback
	if (CWnd ::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Create the graph
	m_pGraph = new CGraph(this);

	GetClientRect(rect);
	m_width		= rect.Width();
	m_height	= rect.Height();
	m_pGraph->SetRect(rect);

	// Vertical scroll bar
	scrollInfo.cbSize		= sizeof(SCROLLINFO);
	scrollInfo.fMask		= SIF_ALL;
	scrollInfo.nMin			= 0;
	scrollInfo.nMax			= MAX(1, m_height - 1);
	scrollInfo.nPage		= (UINT)scrollInfo.nMax;
	scrollInfo.nPos			= 0;
	scrollInfo.nTrackPos	= 0;
	SetScrollInfo(SB_VERT, &scrollInfo);

	// Horizontal scroll bar (hidden for now)
	scrollInfo.cbSize		= sizeof(SCROLLINFO);
	scrollInfo.fMask		= SIF_ALL;
	scrollInfo.nMin			= 0;
	scrollInfo.nMax			= MAX(1, m_width - 1);
	scrollInfo.nPage		= (UINT)scrollInfo.nMax;
	scrollInfo.nPos			= 0;
	scrollInfo.nTrackPos	= 0;
	SetScrollInfo(SB_HORZ, &scrollInfo);

	return 0;
}

//------------------------------------------------------------------------------
//	CChildView::OnLButtonDblClk
//------------------------------------------------------------------------------
void 
CChildView::OnLButtonDblClk(
						    IN UINT		nFlags, 
						    IN CPoint	point
						    ) 
/*++

Routine Description:

	Handles left mouse double click events by passing them to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->OnLButtonDblClk(nFlags, point);
}

//------------------------------------------------------------------------------
//	CChildView::OnLButtonDown
//------------------------------------------------------------------------------
void 
CChildView::OnLButtonDown(
						  IN UINT	nFlags, 
						  IN CPoint	point
						  ) 
/*++

Routine Description:

	Handles left mouse down events by passing them to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	// Trap the mouse
	if(m_pGraph)
	{
		SetCapture();
		m_pGraph->OnLButtonDown(nFlags, point);
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnLButtonUp
//------------------------------------------------------------------------------
void 
CChildView::OnLButtonUp(
						IN UINT		nFlags, 
						IN CPoint	point
						) 
/*++

Routine Description:

	Passes left mouse up events to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was released

Return Value:

	None

--*/
{
	if(m_pGraph)
	{
		ReleaseCapture();
		m_pGraph->OnLButtonUp(nFlags, point);
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnRButtonDown
//------------------------------------------------------------------------------
void 
CChildView::OnRButtonDown(
						  IN UINT	nFlags, 
						  IN CPoint	point
						  ) 
/*++

Routine Description:

	Passes right mouse up events to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was pressed

Return Value:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->OnRButtonDown(nFlags, point);
}

//------------------------------------------------------------------------------
//	CChildView::OnSize
//------------------------------------------------------------------------------
void 
CChildView::OnSize(
				   IN UINT	nType, 
				   IN int	cx, 
				   IN int	cy
				   ) 
{
	CRect		rect;
	SCROLLINFO	scrollInfo;
	CRect		bounds;

	if(m_pGraph)
		bounds = m_pGraph->GetBounds();

	CWnd ::OnSize(nType, cx, cy);

	if(!m_pGraph)
		return;

	// Adjust the visible area on the graph
	rect		= m_pGraph->GetRect();
	rect.right	= rect.left + cx;
	rect.bottom = rect.top + cy;
	m_pGraph->SetRect(rect);

	// Adjust the scroll bars
	if(cx != m_width)
	{
		m_width				= cx;
		cx					= m_width + m_offset.x;
		cx					= MAX(cx, bounds.right);
		scrollInfo.cbSize	= sizeof(SCROLLINFO);
		scrollInfo.fMask	= SIF_PAGE | SIF_RANGE | SIF_POS;
		scrollInfo.nMin		= 0;
		scrollInfo.nPos		= m_offset.x;
		scrollInfo.nPage	= (UINT)MAX(0, m_width - 1);
		scrollInfo.nMax		= MAX(0, cx - 1);
//		if(scrollInfo.nPage > (UINT)scrollInfo.nMax)
//			scrollInfo.nPage = (UINT)scrollInfo.nMax;
		SetScrollInfo(SB_HORZ, &scrollInfo);
	}

	if(cy != m_height)
	{
		m_height			= cy;
		cy					= m_height + m_offset.y;
		cy					= MAX(cy, bounds.bottom);
		scrollInfo.cbSize	= sizeof(SCROLLINFO);
		scrollInfo.fMask	= SIF_PAGE | SIF_RANGE | SIF_POS;
		scrollInfo.nMin		= 0;
		scrollInfo.nPos		= m_offset.y;
		scrollInfo.nPage	= (UINT)MAX(0, m_height - 1);
		scrollInfo.nMax		= MAX(0, cy - 1);
//		if(scrollInfo.nPage > (UINT)scrollInfo.nMax)
//			scrollInfo.nPage = (UINT)scrollInfo.nMax;
		SetScrollInfo(SB_VERT, &scrollInfo);
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnVScroll
//------------------------------------------------------------------------------
void 
CChildView::OnVScroll(
					  IN UINT			nSBCode, 
					  IN UINT			nPos, 
					  IN CScrollBar*
					  ) 
{
	int			pos;
	SCROLLINFO	scrollInfo;
	int			y;

	if(!m_pGraph || !GetScrollInfo(SB_VERT, &scrollInfo, SIF_PAGE))
		return;

	switch(nSBCode)
	{
	case SB_LINEUP:
		pos	= m_offset.y;
		y	= GetScrollPos(SB_VERT);
		y	-= m_height / 20;
		if(y < 0)
			y = 0;
		m_offset.y = y;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		UpdateScrollBars();
		SetScrollPos(SB_VERT, m_offset.y);
		ScrollWindow(0, pos - m_offset.y);
		break;

	case SB_LINEDOWN:
		pos	= m_offset.y;
		y	= GetScrollPos(SB_VERT);
		y	+= m_height / 20;
		if(y > (MAX_SIZE - m_height))
			y = MAX_SIZE - m_height;
		m_offset.y = y;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		UpdateScrollBars();
		SetScrollPos(SB_VERT, m_offset.y);
		ScrollWindow(0, pos - m_offset.y);
		break;

	case SB_PAGEUP:
		y	= GetScrollPos(SB_VERT);
		y	-= m_height;
		if(y < 0)
			y = 0;
		m_offset.y = y;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		SetScrollPos(SB_VERT, m_offset.y);
		Invalidate();
		break;

	case SB_PAGEDOWN:
		y	= GetScrollPos(SB_VERT);
		y	+= m_height;
		if(y > (MAX_SIZE - m_height))
			y = MAX_SIZE - m_height;
		m_offset.y = y;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		SetScrollPos(SB_VERT, m_offset.y);
		Invalidate();
		break;

	case SB_THUMBTRACK:
		y			= m_offset.y - (int)nPos;
		m_offset.y	= (int)nPos;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		ScrollWindow(0, y);
		SetScrollPos(SB_VERT, (int)nPos);
		break;
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnHScroll
//------------------------------------------------------------------------------
void 
CChildView::OnHScroll(
					  IN UINT			nSBCode, 
					  IN UINT			nPos, 
					  IN CScrollBar*
					  ) 
{
	int			pos;
	SCROLLINFO	scrollInfo;
	int			x;

	if(!m_pGraph || !GetScrollInfo(SB_HORZ, &scrollInfo, SIF_PAGE | SIF_RANGE))
		return;

	switch(nSBCode)
	{
	case SB_LINEUP:
		pos	= m_offset.x;
		x	= GetScrollPos(SB_HORZ);
		x	-= m_width / 20;
		if(x < 0)
			x = 0;
		m_offset.x = x;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		UpdateScrollBars();
		SetScrollPos(SB_HORZ, m_offset.x);
		ScrollWindow(pos - m_offset.x, 0);
		break;

	case SB_LINEDOWN:
		pos	= m_offset.x;
		x	= GetScrollPos(SB_HORZ);
		x	+= m_width / 20;
		if(x > (MAX_SIZE - m_width))
			x = MAX_SIZE - m_width;
		m_offset.x = x;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		UpdateScrollBars();
		SetScrollPos(SB_HORZ, m_offset.x);
		ScrollWindow(pos - m_offset.x, 0);
		break;

	case SB_PAGEUP:
		x	= GetScrollPos(SB_HORZ);
		x	-= m_width;
		if(x < 0)
			x = 0;
		m_offset.x = x;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		SetScrollPos(SB_HORZ, m_offset.x);
		Invalidate();
		break;

	case SB_PAGEDOWN:
		x	= GetScrollPos(SB_HORZ);
		x	+= m_width;
		if(x > (MAX_SIZE - m_width))
			x = MAX_SIZE - m_width;
		m_offset.x 	= x;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		SetScrollPos(SB_HORZ, m_offset.x);
		Invalidate();
		break;

	case SB_THUMBTRACK:
		x			= m_offset.x - (int)nPos;
		m_offset.x	= (int)nPos;
		m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
		ScrollWindow(x, 0);
		SetScrollPos(SB_HORZ, (int)nPos);
		break;
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnMouseWheel
//------------------------------------------------------------------------------
BOOL 
CChildView::OnMouseWheel(
						 IN UINT, 
						 IN short	zDelta, 
						 IN CPoint
						 ) 
/*++

Routine Description:

	Respond to mouse wheel movement (VScroll)

Arguments:

	IN nFlags -	State of mouse buttons and control/shift keys
	IN zDelta -	Mouse wheel movement
	IN pt -		Mouse location

Return Value:

	None

--*/
{
	int			pos;
	SCROLLINFO	scrollInfo;
	int			y;

	if(m_pGraph && GetScrollInfo(SB_VERT, &scrollInfo, SIF_PAGE))
	{
		if(zDelta > 0)
		{
			pos	= m_offset.y;
			y	= GetScrollPos(SB_VERT);
			y	-= m_height / 20;
			if(y < 0)
				y = 0;
			m_offset.y = y;
			m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
			SetScrollPos(SB_VERT, m_offset.y);
			ScrollWindow(0, pos - m_offset.y);
		}
		else if(zDelta < 0)
		{
			pos	= m_offset.y;
			y	= GetScrollPos(SB_VERT);
			y	+= m_height / 20;
			if(y > (MAX_SIZE - (int)scrollInfo.nPage))
				y = MAX_SIZE - (int)scrollInfo.nPage;
			m_offset.y = y;
			m_pGraph->SetRect(CRect(m_offset.x, m_offset.y, m_offset.x + m_width, m_offset.y + m_height));
			SetScrollPos(SB_VERT, m_offset.y);
			ScrollWindow(0, pos - m_offset.y);
		}
	}
	return TRUE;
}

//------------------------------------------------------------------------------
//	CChildView::OnMouseMove
//------------------------------------------------------------------------------
void 
CChildView::OnMouseMove(
						IN UINT		nFlags, 
						IN CPoint	point
						) 
/*++

Routine Description:

	Passes mouse move events to the grid

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was pressed

Return Value:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->OnMouseMove(nFlags, point);
}

//------------------------------------------------------------------------------
//	CChildView::EnableMenuItem
//------------------------------------------------------------------------------
void 
CChildView::EnableMenuItem(
						   IN CMenu*	pPopupMenu,
						   IN UINT		nIndex
						   )
/*++

Routine Description:

	Enables or disables menu items

Arguments:

	IN pPopupMenu -	Menu
	IN nIndex -		Item

Return Value:

	None

--*/
{
	if(!m_pGraph)
		return;

	switch(nIndex)
	{
	case 0:	// File
		pPopupMenu->EnableMenuItem(ID_FILE_NEW, m_pGraph->AreEffectsLoaded() ? MF_ENABLED : MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_FILE_OPEN, m_pGraph->AreEffectsLoaded() ? MF_ENABLED : MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_FILE_SAVE, m_pGraph->AreEffectsLoaded() ? MF_ENABLED : MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_FILE_SAVE_AS, m_pGraph->AreEffectsLoaded() ? MF_ENABLED : MF_GRAYED);
		pPopupMenu->EnableMenuItem(ID_FILE_GENERATE_AND_SAVE_IMAGE, 
								   (m_pGraph->AreEffectsLoaded() && 
								   (strlen(m_pGraph->GetIniFilename()) > 4)) ? MF_ENABLED : MF_GRAYED);
		break;

	case 1:	// View
		pPopupMenu->CheckMenuItem(ID_GRID_SHOW_GRID, m_pGraph->GetShowGrid() ? MF_CHECKED : MF_UNCHECKED);
		break;

	case 2:	// Xbox
		pPopupMenu->EnableMenuItem(ID_XBOX_TRANSMIT_IMAGE, 
								   (m_pGraph->AreEffectsLoaded() &&  
								    (strlen(m_pGraph->GetIniFilename()) > 4)) ? MF_ENABLED : MF_GRAYED);
		break;

	case 3: // Tools
		pPopupMenu->CheckMenuItem(IDC_TOOLS_SNAP_TO_GRID, m_pGraph->GetSnapToGrid() ? MF_CHECKED : MF_UNCHECKED);
		break;
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnFileGenerateAndSaveImage
//------------------------------------------------------------------------------
void 
CChildView::OnFileGenerateAndSaveImage(void) 
/*++

Routine Description:

	Saves the data as a dsp image

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->SaveImage();
}

//------------------------------------------------------------------------------
//	CChildView::OnFileSave
//------------------------------------------------------------------------------
void 
CChildView::OnFileSave(void) 
/*++

Routine Description:

	Saves the data as a grid file

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->Save(NULL);
}

//------------------------------------------------------------------------------
//	CChildView::OnFileSaveAs
//------------------------------------------------------------------------------
void 
CChildView::OnFileSaveAs(void) 
/*++

Routine Description:

	Saves the grid as a new name

Arguments:

	None

Return Value:

	None

--*/
{
	if(!m_pGraph)
		return;

	CFileDialog	fileDialog(FALSE, _T("fx"), NULL, OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST,
						   _T("DSP Builder Files (.fx)|*.fx|All Files (*.*)|*.*||"));
	if(fileDialog.DoModal() == IDOK)
		m_pGraph->Save(fileDialog.GetPathName());
}

//------------------------------------------------------------------------------
//	CChildView::OnFileNew
//------------------------------------------------------------------------------
void 
CChildView::OnFileNew(void) 
/*++

Routine Description:

	Create a new grid file

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->New();
}

//------------------------------------------------------------------------------
//	CChildView::OnFileOpen
//------------------------------------------------------------------------------
void 
CChildView::OnFileOpen(void) 
/*++

Routine Description:

	Opens a new grid file

Arguments:

	None

Return Value:

	None

--*/
{
	if(!m_pGraph)
		return;

	CFileDialog	fileDialog(TRUE, _T("fx"), NULL, 
						   OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
						   _T("DSP Builder Files (.fx)|*.fx|All Files (*.*)|*.*||"));
	if(fileDialog.DoModal() == IDOK)
		m_pGraph->Open(fileDialog.GetPathName());
}

//------------------------------------------------------------------------------
//	CChildView::Connect
//------------------------------------------------------------------------------
BOOL
CChildView::Connect(
					IN LPCTSTR	pNameOrIP
					) 
/*++

Routine Description:

	Connects to the xbox. This routine can take a while. It is recommended
	that a wait cursor be displayed before calling.

Arguments:

	IN pNameOrIP -	Name or IP address of Xbox

Return Value:

	TRUE if a connection was made, FALSE otherwise

--*/
{
	LPVOID			lpMsgBuf;
    int				ret;
	sockaddr_in		sa;
	SOCKADDR		bindSockaddr;
	unsigned long	addr;
	int				index;
	CString			portString;
	ULONG			ulTitleAddr;
	CString			string	= pNameOrIP;
	unsigned short	port	= 80;

	// Disconnect
	Disconnect();

	// Cleanup the string and save it
	string.TrimLeft();
	string.TrimRight();
	m_xboxName = string;

	// Is a port listed?
	index = string.Find(':');
	if(index >= 0)
	{
		portString = string.Right(string.GetLength() - index - 1);
		portString.TrimLeft();
		if(!portString.IsEmpty())
			port = (unsigned short)atol((LPCTSTR)portString);
		string.Delete(index, string.GetLength() - index);
	}

	memset(&sa, 0, sizeof(SOCKADDR));
	sa.sin_family	= AF_INET;
	sa.sin_port		= htons(port);

	// Is it an ip address?
	addr = inet_addr((LPCTSTR)string);
	if(addr != INADDR_NONE)
		sa.sin_addr.s_addr = addr;

	// Otherwise treat it as a name
	else
	{
		// Save the old name to restore
		if(FAILED(DmSetXboxNameNoRegister((LPCTSTR)string)) || 
		   FAILED(DmGetAltAddress(&ulTitleAddr)))
		{
			AfxMessageBox(_T("Unable to resolve Xbox name"), MB_OK | MB_ICONERROR);
			return FALSE;
		}
		sa.sin_addr.s_addr = htonl(ulTitleAddr);
	}

	// Create the socket
	m_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(m_socket == INVALID_SOCKET)
	{
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					  FORMAT_MESSAGE_FROM_SYSTEM | 
					  FORMAT_MESSAGE_IGNORE_INSERTS,
					  NULL, (unsigned long)WSAGetLastError(),
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					  (LPTSTR)&lpMsgBuf, 0, NULL);
		AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
		LocalFree(lpMsgBuf);
		return FALSE;
	}

	// Bind the socket
	memset(&bindSockaddr, 0, sizeof(SOCKADDR));
	bindSockaddr.sa_family = AF_INET;
	ret = bind(m_socket, (LPSOCKADDR)&bindSockaddr, sizeof(SOCKADDR));
	if(ret == SOCKET_ERROR)
	{
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					  FORMAT_MESSAGE_FROM_SYSTEM | 
					  FORMAT_MESSAGE_IGNORE_INSERTS,
					  NULL, (unsigned long)WSAGetLastError(),
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					  (LPTSTR)&lpMsgBuf, 0, NULL);
		AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
		LocalFree(lpMsgBuf);
		return FALSE;
	}

	// Connect
	ret = connect(m_socket, (LPSOCKADDR)&sa, sizeof(SOCKADDR));
	if(SOCKET_ERROR == ret)
	{
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					  FORMAT_MESSAGE_FROM_SYSTEM | 
					  FORMAT_MESSAGE_IGNORE_INSERTS,
					  NULL, (unsigned long)WSAGetLastError(),
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					  (LPTSTR)&lpMsgBuf, 0, NULL);
		AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
		LocalFree(lpMsgBuf);
		return FALSE;
	}
	
	// We are connected
	m_bConnected = TRUE;
	return TRUE;
}

//------------------------------------------------------------------------------
//	CChildView::Disconnect
//------------------------------------------------------------------------------
void
CChildView::Disconnect(void)
/*++

Routine Description:

	Disconnects from an Xbox

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_bConnected)
	{
		shutdown(m_socket, SD_BOTH);
		closesocket(m_socket);
		m_bConnected = FALSE;
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnXboxTransmitImage
//------------------------------------------------------------------------------
void 
CChildView::OnXboxTransmitImage(void) 
/*++

Routine Description:

	Transmits the dsp image to the xbox. This method assumes that a valid image
	is stored on disk and that a connection exists.

Arguments:

	None

Return Value:

	None

--*/
{
	DWORD			i;
	int				ii;
	CFile			file;
	CStdioFile		sFile;
	char*			pBuffer;
	DWORD			length;
	LPVOID			lpMsgBuf;
	char			header[36];
	CString			string;
	CString			name;
	CString			index;
	DWORD			e;
	char*			pEffectName[1024];	// No more than 1024 effects per file
	char*			pEffectIndex[1024];	// No more than 1024 effects per file
	CString			pEffectName2[1024];	// No more than 1024 effects per file
	DWORD			numEffects	= 0;
	BOOL			error		= FALSE;
	CConnectDialog	dialog(m_xboxName);

	if(!m_pGraph)
		return;

	// If changes have been made, try to rebuild
	if(m_pGraph->GetChangesMade() || !m_pGraph->IsImageSaved())
	{
		if(AfxMessageBox(_T("Changes have been made since you last generated the image.\n"
			   			    "Hit Ok to rebuild."), MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
			return;
		if(!m_pGraph->SaveImage())
			return;
	}

	// Does a potentialy valid destination exist?
	if(m_transmitDestination.GetLength() == 0)
	{
		OnToolsTransmitOptions();
		if(m_transmitDestination.GetLength() == 0)
			return;
	}

	CWaitCursor cursor;
	if(!Connect(m_transmitDestination))
		return;

	// Open the binary file
	file.SetFilePath(m_pGraph->GetBinFilename());
	if(!file.Open(file.GetFilePath(), CFile::modeRead | CFile::typeBinary))
	{
		AfxMessageBox(CString(_T("Unable to open file: ")) + file.GetFilePath(),
					  MB_OK | MB_ICONERROR);
		return;
	}

	// Get the file size and allocate a buffer
	length	= file.GetLength();
	pBuffer	= new char [length+25];

	// Add the other data to the buffer
	memcpy(pBuffer, "DSPIMAGE", 8);
	*(BYTE*)&pBuffer[8]		= cDspImageVersion;
	*(DWORD*)&pBuffer[9]	= m_pGraph->GetI3DL2Index();
	*(DWORD*)&pBuffer[13]	= m_pGraph->GetXTalkIndex();
	memcpy(&pBuffer[length+17], "DSPIMAGE", 8);

	// Read the entire file into a buffer
	if(file.Read(&pBuffer[17], length) != length)
	{
		AfxMessageBox(CString(_T("Error reading dsp file: ")) + file.GetFilePath(),
					  MB_OK | MB_ICONERROR);
		delete [] pBuffer;
		file.Close();
		return;
	}
	file.Close();

	// Adjust the length for additional info
	length += 25;

	// Build the header block
	memcpy(header, "DSPBUILDER", 10);
	strncpy(&header[10], "DSPIMAGE", 8);
	*(DWORD*)&header[18] = length;
	*(DWORD*)&header[22] = GetCRC(pBuffer, length);
	memcpy(&header[26], "DSPBUILDER", 10);

	// Send the header
	if(send(m_socket, header, 36, 0) == SOCKET_ERROR)
	{
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					  FORMAT_MESSAGE_FROM_SYSTEM | 
					  FORMAT_MESSAGE_IGNORE_INSERTS,
					  NULL, (unsigned long)WSAGetLastError(),
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					  (LPTSTR)&lpMsgBuf, 0, NULL);
		AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
		LocalFree(lpMsgBuf);
		error = TRUE;
	}

	// Send the data block
	else if(send(m_socket, pBuffer, (int)length, 0) == SOCKET_ERROR)
	{
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					  FORMAT_MESSAGE_FROM_SYSTEM | 
					  FORMAT_MESSAGE_IGNORE_INSERTS,
					  NULL, (unsigned long)WSAGetLastError(),
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					  (LPTSTR)&lpMsgBuf, 0, NULL);
		AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
		LocalFree(lpMsgBuf);
		error = TRUE;
	}
	
	// Free memory
	delete [] pBuffer;

	if(!error)
	{
		// Open the header file
		sFile.SetFilePath(m_pGraph->GetHFilename());
		if(!sFile.Open(sFile.GetFilePath(), CFile::modeRead | CFile::typeText))
		{
			AfxMessageBox(CString(_T("Unable to open file: ")) + sFile.GetFilePath(),
						  MB_OK | MB_ICONERROR);
			return;
		}

		// Parse the file and find the effects indices
		while(sFile.ReadString(string))
		{
			// Look for the index block
			// All lines after it will contain the names and indices
			if((string.Find(_T("typedef enum _DSP_IMAGE_")) == 0) && 
			   (string.Find(_T("_INDICES {")) != -1))
			{
				while(sFile.ReadString(string))
				{
					// Clean up the string
					string.TrimLeft();
					string.TrimRight();

					// Is an effect name/index pair found
					ii = string.Find(_T(" = "));
					if(ii == -1)
						break;

					name	= string.Left(ii);
					index	= string.Right(string.GetLength() - ii - 3);
					ii		= index.Find(',');
					if(ii != -1)
						index.Delete(ii, index.GetLength() - ii);
					
					pEffectName[numEffects] = new char [(unsigned int)name.GetLength() + 1];
					ASSERT(pEffectName[numEffects] != NULL);
					pEffectIndex[numEffects] = new char [(unsigned int)index.GetLength() + 1];
					ASSERT(pEffectIndex[numEffects] != NULL);

					// For now (this is crap) convert to pure ascii
					for(i=0; i<(DWORD)name.GetLength(); ++i)
						pEffectName[numEffects][i] = (char)(name.GetAt((int)i) & 0xff);
					pEffectName[numEffects][i] = 0;
					for(i=0; i<(DWORD)index.GetLength(); ++i)
						pEffectIndex[numEffects][i] = (char)(index.GetAt((int)i) & 0xff);
					pEffectIndex[numEffects][i] = 0;

					pEffectName2[numEffects] = name;
					++numEffects;
				}
				break;
			}
		} 
		sFile.Close();

		// Calculate the buffer size to transmit
		// Intial 25 bytes are for header/trailer 
		// (8x2) version (1) and one size values (4)
		for(length=21, i=0; i<numEffects; ++i)
		{
			// Effect name + null
			length += strlen(pEffectName[i]) + 1;

			// Effect index + null
			length += strlen(pEffectIndex[i]) + 1;

			// Set the indices for each module
			m_pGraph->SetModuleIndex(pEffectName2[i], (DWORD)atoi(pEffectIndex[i]));
		}

		// Get the file size and allocate a buffer
		pBuffer	= new char [length];

		// Add the other data to the buffer
		memcpy(pBuffer, "DSPINDEX", 8);
		*(BYTE*)&pBuffer[8]		= cDspIndexVersion;
		*(DWORD*)&pBuffer[9]	= numEffects;
		memcpy(&pBuffer[length-8], "DSPINDEX", 8);

		// Fill the effects into the buffer
		for(i=13, e=0; e<numEffects; ++e)
		{
			for(ii=0; pEffectName[e][ii] != 0; ++ii, ++i)
				pBuffer[i] = pEffectName[e][ii];
			pBuffer[i++] = pEffectName[e][ii];
	
			for(ii=0; pEffectIndex[e][ii] != 0; ++ii, ++i)
				pBuffer[i] = pEffectIndex[e][ii];
			pBuffer[i++] = pEffectIndex[e][ii];
		}

		// Build the header block
		memcpy(header, "DSPBUILDER", 10);
		memcpy(&header[10], "DSPINDEX", 8);
		*(DWORD*)&header[18] = length;
		*(DWORD*)&header[22] = GetCRC(pBuffer, length);
		memcpy(&header[26], "DSPBUILDER", 10);

		// Send the header
		if(send(m_socket, header, 36, 0) == SOCKET_ERROR)
		{
			FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
						  FORMAT_MESSAGE_FROM_SYSTEM | 
						  FORMAT_MESSAGE_IGNORE_INSERTS,
						  NULL, (unsigned long)WSAGetLastError(),
						  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						  (LPTSTR)&lpMsgBuf, 0, NULL);
			AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
			LocalFree(lpMsgBuf);
			error = TRUE;
		}

		// Send the data block
		else if(send(m_socket, pBuffer, (int)length, 0) == SOCKET_ERROR)
		{
			FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
						  FORMAT_MESSAGE_FROM_SYSTEM | 
						  FORMAT_MESSAGE_IGNORE_INSERTS,
						  NULL, (unsigned long)WSAGetLastError(),
						  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						  (LPTSTR)&lpMsgBuf, 0, NULL);
			AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
			LocalFree(lpMsgBuf);
			error = TRUE;
		}
		
		// Free memory
		delete [] pBuffer;
	}

	// Free resources
	for(i=0; i<numEffects; ++i)
	{
		delete [] pEffectName[i];
		delete [] pEffectIndex[i];
	}
	
	// If any transmission errors occured, disconnect
	if(error)
		Disconnect();
}

//------------------------------------------------------------------------------
//	CChildView::OnFileExit
//------------------------------------------------------------------------------
BOOL
CChildView::Quit(void)
/*++

Routine Description:

	Prompts user to save data and then exits

Arguments:

	None

Return Value:

	TRUE to quit, FALSE otherwise

--*/
{
	if(!m_pGraph)
		return TRUE;

	if(!m_pGraph->IsEmpty() && m_pGraph->GetChangesMade())
	{
		switch(AfxMessageBox(_T("Save changes?"), MB_YESNOCANCEL | MB_ICONEXCLAMATION))
		{
		case IDYES:
			if(!m_pGraph->Save(NULL))
				return FALSE;
			break;
		case IDCANCEL:
			return FALSE;
		default:
			break;
		}
	}
	return TRUE;
}

//------------------------------------------------------------------------------
//	CChildView::OnUpdateXboxTransmitImageUI
//------------------------------------------------------------------------------
void
CChildView::OnUpdateXboxTransmitImageUI(
									    IN CCmdUI*	pCmdUI
									    )
{
	if(!m_pGraph)
		return;

	pCmdUI->Enable((m_pGraph->AreEffectsLoaded() &&  
					(strlen(m_pGraph->GetIniFilename()) > 4)) ? TRUE : FALSE);
}

//------------------------------------------------------------------------------
//	CChildView::OnUpdateFileNewUI
//------------------------------------------------------------------------------
void
CChildView::OnUpdateFileNewUI(
							  IN CCmdUI*	pCmdUI
							  )
{
	if(!m_pGraph)
		return;

	pCmdUI->Enable(m_pGraph->AreEffectsLoaded());
}

//------------------------------------------------------------------------------
//	CChildView::OnUpdateFileSaveUI
//------------------------------------------------------------------------------
void
CChildView::OnUpdateFileSaveUI(
							   IN CCmdUI*	pCmdUI
							   )
{
	if(!m_pGraph)
		return;

	pCmdUI->Enable(m_pGraph->AreEffectsLoaded());
}

//------------------------------------------------------------------------------
//	CChildView::OnUpdateFileOpenUI
//------------------------------------------------------------------------------
void
CChildView::OnUpdateFileOpenUI(
							   IN CCmdUI*	pCmdUI
							   )
{
	if(!m_pGraph)
		return;

	pCmdUI->Enable(m_pGraph->AreEffectsLoaded());
}

//------------------------------------------------------------------------------
//	CChildView::OnUpdateFileGenSaveImgUI
//------------------------------------------------------------------------------
void 
CChildView::OnUpdateFileGenSaveImgUI(
									 IN CCmdUI* pCmdUI
									 )
{
	if(!m_pGraph)
		return;

	pCmdUI->Enable((m_pGraph->AreEffectsLoaded() && 
				    strlen(m_pGraph->GetIniFilename())) ? TRUE : FALSE);
}

//------------------------------------------------------------------------------
//	CChildView::GetStatusBarText
//------------------------------------------------------------------------------
LPCTSTR 
CChildView::GetStatusBarText(void)
{
	if(!m_pGraph)
		return NULL;

	m_statusBarText.Format(_T("DSP Cycles: %d (%d%%) Y Mem Size: %d (%d%%) "
						   "Scratch Length: %d"), 
						   m_pGraph->GetDSPCycles(), 
						   (int)(m_pGraph->GetDSPCyclesPercent() * 100.0f),
						   m_pGraph->GetYMemSize(), 
						   (int)(m_pGraph->GetYMemSizePercent() * 100.0f),
						   m_pGraph->GetScratchLength());
	return (LPCTSTR)m_statusBarText; 
}

//------------------------------------------------------------------------------
//	CChildView::Reset
//------------------------------------------------------------------------------
void
CChildView::Reset(void)
/*++

Routine Description:

	Resets all offsets and scrollbars

Arguments:

	None

Return Value:

	None

--*/
{
	SCROLLINFO	scrollInfo;
	CRect		rect;

	m_offset.x	= 0;
	m_offset.y	= 0;

	// Reset the graph
	if(m_pGraph)
	{
		GetClientRect(rect);
		m_pGraph->SetRect(rect);
	}

	// Vertical scroll bar
	scrollInfo.cbSize		= sizeof(SCROLLINFO);
	scrollInfo.fMask		= SIF_ALL;
	scrollInfo.nMin			= 0;
	scrollInfo.nMax			= MAX(1, m_height - 1);
	scrollInfo.nPage		= (UINT)scrollInfo.nMax;
	scrollInfo.nPos			= 0;
	scrollInfo.nTrackPos	= 0;
	SetScrollInfo(SB_VERT, &scrollInfo);

	// Horizontal scroll bar (hidden for now)
	scrollInfo.cbSize		= sizeof(SCROLLINFO);
	scrollInfo.fMask		= SIF_ALL;
	scrollInfo.nMin			= 0;
	scrollInfo.nMax			= MAX(1, m_width - 1);
	scrollInfo.nPage		= (UINT)scrollInfo.nMax;
	scrollInfo.nPos			= 0;
	scrollInfo.nTrackPos	= 0;
	SetScrollInfo(SB_HORZ, &scrollInfo);
}

//------------------------------------------------------------------------------
//	CChildView::OnToolsDirectories
//------------------------------------------------------------------------------
void 
CChildView::OnToolsDirectories(void)
/*++

Routine Description:

	Displays a dialog that allows the user the ability to select the 
	directory paths for the application

Arguments:

	None

Return Value:

	None

--*/
{
	CDirsDialog	dirsDialog;
	
	if(m_pGraph)
	{
		dirsDialog.SetIniPath(m_pGraph->GetIniFilePath());
		dirsDialog.SetDspCodePath(m_pGraph->GetDspCodePath());

		if(dirsDialog.DoModal() == IDOK)
			m_pGraph->SetPaths(dirsDialog.GetIniPath(), dirsDialog.GetDspCodePath());
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnToolsBuildOptions
//------------------------------------------------------------------------------
void 
CChildView::OnToolsBuildOptions(void)
/*++

Routine Description:

	Displays a dialog that allows the user the ability to select the 
	build options for the image

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->SelectBuildOptions();
}

//------------------------------------------------------------------------------
//	CChildView::OnToolsTransmitOptions
//------------------------------------------------------------------------------
void 
CChildView::OnToolsTransmitOptions(void)
/*++

Routine Description:

	Displays a dialog that allows the user the ability to select the 
	destination of the image

Arguments:

	None

Return Value:

	None

--*/
{
	CConnectDialog	dialog(m_xboxName);

	if(dialog.DoModal() == IDOK)
	{
		// If the name is different, and we are connected to an Xbox, disconnect
		if(m_transmitDestination != dialog.GetName())
			Disconnect();
		m_transmitDestination = dialog.GetName();
	}
}

//------------------------------------------------------------------------------
//	CChildView::OnGraphShowGrid
//------------------------------------------------------------------------------
void
CChildView::OnGraphShowGrid(void)
/*++

Routine Description:

	Toggles the grid display

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->ToggleGrid();
}

//------------------------------------------------------------------------------
//	CChildView::OnToolsSnapToGrid
//------------------------------------------------------------------------------
void
CChildView::OnToolsSnapToGrid(void)
/*++

Routine Description:

	Toggles the snap to grid

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pGraph)
		m_pGraph->ToggleSnapToGrid();
}

//------------------------------------------------------------------------------
//	CChildView::UpdateScrollBars
//------------------------------------------------------------------------------
void
CChildView::UpdateScrollBars(void)
/*++

Routine Description:

	Updates the scrollbars

Arguments:

	None

Return Value:

	None

--*/
{
	int			x;
	int			y;
	SCROLLINFO	scrollInfo;
	CRect		bounds;
	
	if(!m_pGraph)
		return;

	bounds = m_pGraph->GetBounds();

	x	= m_width + m_offset.x;
	y	= m_height + m_offset.y;
	x	= MAX(x, bounds.right);
	y	= MAX(y, bounds.bottom);

	// Adjust the scroll bars
	scrollInfo.cbSize	= sizeof(SCROLLINFO);
	scrollInfo.fMask	= SIF_PAGE | SIF_RANGE;
	scrollInfo.nMin		= 0;
	scrollInfo.nPage	= (UINT)MAX(0, m_height - 1);
	scrollInfo.nMax		= MAX(0, y - 1);
	SetScrollInfo(SB_VERT, &scrollInfo);

	scrollInfo.nPage	= (UINT)MAX(0, m_width - 1);
	scrollInfo.nMax		= MAX(0, x - 1);
	SetScrollInfo(SB_HORZ, &scrollInfo);
}

//------------------------------------------------------------------------------
//	CChildView::TransmitModuleParameters
//------------------------------------------------------------------------------
void
CChildView::TransmitModuleParameters(
									 IN const CModule*	pModule,
									 IN int				index	// = -1
									 )
/*++

Routine Description:

	Transmits the module parameters to a connected Xbox

Arguments:

	IN pModule -	Module whose parameters should be transmitted
	IN index -		Parameter index (-1 for all)

Return Value:

	None

--*/
{
	char	header[36];
	char*	pBuffer;
	DWORD	length;
	DWORD	i;
	DWORD	p;
	LPVOID	lpMsgBuf;
	DWORD	dwFirst;
	DWORD	dwLast;

	// If not connected to the Xbox, just return
	if(!m_bConnected)
		return;
	
	// Special Case: I3DL2
	if(pModule->IsI3DL2())
	{
		length	= 17 + (4 * sizeof(LONG)) + (8 * sizeof(FLOAT));
		pBuffer = new char [length];

		// Head
		memcpy(pBuffer, "I3DL2LIS", 8);

		// Version
		*(BYTE*)&pBuffer[8] = cI3DL2Version;

		// I3DL2 Parameters
		i = 9;
		*(LONG*)&pBuffer[i]  = pModule->GetI3DL2Listener().lRoom; i += sizeof(LONG);
		*(LONG*)&pBuffer[i]  = pModule->GetI3DL2Listener().lRoomHF; i += sizeof(LONG);
		*(FLOAT*)&pBuffer[i] = pModule->GetI3DL2Listener().flRoomRolloffFactor; i += sizeof(FLOAT);
		*(FLOAT*)&pBuffer[i] = pModule->GetI3DL2Listener().flDecayTime; i += sizeof(FLOAT);
		*(FLOAT*)&pBuffer[i] = pModule->GetI3DL2Listener().flDecayHFRatio; i += sizeof(FLOAT);
		*(LONG*)&pBuffer[i]  = pModule->GetI3DL2Listener().lReflections; i += sizeof(LONG);
		*(FLOAT*)&pBuffer[i] = pModule->GetI3DL2Listener().flReflectionsDelay; i += sizeof(FLOAT);
		*(LONG*)&pBuffer[i]  = pModule->GetI3DL2Listener().lReverb; i += sizeof(LONG);
		*(FLOAT*)&pBuffer[i] = pModule->GetI3DL2Listener().flReverbDelay; i += sizeof(FLOAT);
		*(FLOAT*)&pBuffer[i] = pModule->GetI3DL2Listener().flDiffusion; i += sizeof(FLOAT);
		*(FLOAT*)&pBuffer[i] = pModule->GetI3DL2Listener().flDensity; i += sizeof(FLOAT);
		*(FLOAT*)&pBuffer[i] = pModule->GetI3DL2Listener().flHFReference; i += sizeof(FLOAT);

		// Tail
		memcpy(&pBuffer[length-8], "I3DL2LIS", 8);

		// Build the header block
		memcpy(header, "DSPBUILDER", 10);
		memcpy(&header[10], "I3DL2LIS", 8);
		*(DWORD*)&header[18] = length;
		*(DWORD*)&header[22] = GetCRC(pBuffer,length);
		memcpy(&header[26], "DSPBUILDER", 10);
	}

	// All other effects (including IIR2)
	else 
	{
		if((pModule->GetParameters().GetSize() == 0) || (index >= pModule->GetParameters().GetSize()))
			return;
		
		// All parameters?
		if(index == -1)
		{
			dwFirst	= 0;
			dwLast	= pModule->GetParameters().GetSize()-1;
		}
		else
		{
			dwFirst	= (DWORD)index;
			dwLast	= (DWORD)index;
		}

		length	= 21 + (16 * (dwLast - dwFirst + 1));
		pBuffer = new char [length];

		// Head
		memcpy(pBuffer, "FXPARAMS", 8);

		// Version
		*(BYTE*)&pBuffer[8] = cFXParamsVersion;

		// Number of params
		i = 9;
		*(DWORD*)&pBuffer[i] = dwLast - dwFirst + 1; 
		i += sizeof(DWORD);

		// Step through all the params
		for(p=dwFirst; p<=dwLast; ++p)
		{
			// Effect index
			*(DWORD*)&pBuffer[i] = pModule->GetIndex();
			i += sizeof(DWORD);

			// Data offset
			*(DWORD*)&pBuffer[i] = pModule->GetParameters()[p].GetOffset() * sizeof(DWORD) + 
								   (DWORD)pModule->GetInputs().GetSize() * sizeof(DWORD) +
								   (DWORD)pModule->GetOutputs().GetSize() * sizeof(DWORD) +
								   m_dwParamOffset;
			i += sizeof(DWORD);

			// Size of effect data
			*(DWORD*)&pBuffer[i] = sizeof(DWORD);
			i += sizeof(DWORD);

			// Effect data
			*(DWORD*)&pBuffer[i] = pModule->GetParameters()[p].GetValue();
			i += sizeof(DWORD);
		}

		// Tail
		memcpy(&pBuffer[length-8], "FXPARAMS", 8);

		// Build the header block
		memcpy(header, "DSPBUILDER", 10);
		memcpy(&header[10], "FXPARAMS", 8);
		*(DWORD*)&header[18] = length;
		*(DWORD*)&header[22] = GetCRC(pBuffer,length);
		memcpy(&header[26], "DSPBUILDER", 10);
	}
	
	// Send the header
	if(send(m_socket, header, 36, 0) == SOCKET_ERROR)
	{
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					  FORMAT_MESSAGE_FROM_SYSTEM | 
					  FORMAT_MESSAGE_IGNORE_INSERTS,
					  NULL, (unsigned long)WSAGetLastError(),
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					  (LPTSTR)&lpMsgBuf, 0, NULL);
		AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
		LocalFree(lpMsgBuf);
		Disconnect();
	}

	// Send the data block
	else if(send(m_socket, pBuffer, (int)length, 0) == SOCKET_ERROR)
	{
		FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
					  FORMAT_MESSAGE_FROM_SYSTEM | 
					  FORMAT_MESSAGE_IGNORE_INSERTS,
					  NULL, (unsigned long)WSAGetLastError(),
					  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					  (LPTSTR)&lpMsgBuf, 0, NULL);
		AfxMessageBox((LPCTSTR)lpMsgBuf, MB_OK | MB_ICONERROR);
		LocalFree(lpMsgBuf);
		Disconnect();
	}
	
	// Free memory
	delete [] pBuffer;
}

#pragma warning (push)
#pragma warning (disable:4035)
//------------------------------------------------------------------------------
//	GetCRC
//------------------------------------------------------------------------------
DWORD
CChildView::GetCRC(
				   IN const VOID*	pBuffer,
				   IN ULONG			bufferSize
				   ) const
/*++

Routine Description:

	Generates a simple CRC

Arguments:

	IN pBuffer -	Buffer to generate crc for
	IN bufferSize -	Size of buffer in bytes

Return Value:

	None

--*/
{
    __asm {
        mov     ecx, pBuffer
		mov		edx, bufferSize
		xor		eax, eax
        xor     ebx, ebx
        shr     edx, 2      // count /= sizeof(ULONG)
        test    edx, edx
        jz      L2
    L1: add     eax, [ecx]  // eax += *data++
        adc     ebx, 0      // ebx += carry
        add     ecx, 4
        dec     edx
        jnz     L1          // while (--count)
    L2: add     eax, ebx    // take care of accumulated carries
        adc     eax, 0
    }
}
#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\ConnectDialog.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ConnectDialog.cpp

Abstract:

	Dialog to handle connect to Xbox

Author:

	Robert Heitkamp (robheit) 13-Jun-2001

Revision History:

	13-Jun-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "ConnectDialog.h"
#include "resource.h"

//------------------------------------------------------------------------------
//	CConnectDialog::CConnectDialog
//------------------------------------------------------------------------------
CConnectDialog::CConnectDialog(
							   IN LPCTSTR pName
							   ) : 
CDialog(IDD_XBOX_CONNECT)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	SetName(pName);
}

//------------------------------------------------------------------------------
//	CConnectDialog::~CConnectDialog
//------------------------------------------------------------------------------
CConnectDialog::~CConnectDialog(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CConnectDialog::OnInitDialog
//------------------------------------------------------------------------------
BOOL
CConnectDialog::OnInitDialog(void)
/*++

Routine Description:

	Initializes the dialog

Arguments:

	None

Return Value:

	None

--*/
{
	if(CDialog::OnInitDialog())
	{
		SetDlgItemText(IDC_XBOX_NAME, m_name);
		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CConnectDialog::OnOK
//------------------------------------------------------------------------------
void
CConnectDialog::OnOK(void)
/*++

Routine Description:

	Handles the Ok button

Arguments:

	None

Return Value:

	None

--*/
{
	GetDlgItemText(IDC_XBOX_NAME, m_name);
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\ConnectDialog.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ConnectDialog.h

Abstract:

	Dialog to handle connection to Xbox

Author:

	Robert Heitkamp (robheit) 13-Jun-2001

Revision History:

	13-Jun-2001 robheit
		Initial Version

--*/
#if !defined(AFX_CONNECTDIALOG_H__98670C4C_7B34_4304_9BFA_F51E9C7F7E80__INCLUDED_)
#define AFX_CONNECTDIALOG_H__98670C4C_7B34_4304_9BFA_F51E9C7F7E80__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"

//------------------------------------------------------------------------------
//	CConnectDialog
//------------------------------------------------------------------------------
class CConnectDialog : public CDialog  
{
public:

	CConnectDialog(LPCTSTR pName = NULL);
	virtual ~CConnectDialog(void);

	inline void SetName(LPCTSTR pName) { m_name = pName; };
	inline LPCTSTR GetName(void) const { return m_name; };

protected:

	virtual void OnOK(void);
	virtual BOOL OnInitDialog(void);

private:

	CString	m_name;
};

#endif // !defined(AFX_CONNECTDIALOG_H__98670C4C_7B34_4304_9BFA_F51E9C7F7E80__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\DirectoryDialog.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	DirectoryDialog.cpp

Abstract:

	Dialog for directory selection

Author:

	Robert Heitkamp (robheit) 20-Jul-2001

Revision History:

	20-Jul-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "DirectoryDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------------------------
//	Image indexes
//------------------------------------------------------------------------------
#define ILI_HARD_DISK       0
#define ILI_FLOPPY          1
#define ILI_CD_ROM          2
#define ILI_NET_DRIVE       3
#define ILI_CLOSED_FOLDER   4
#define ILI_OPEN_FOLDER     5

//------------------------------------------------------------------------------
//	CDirectoryDialog::CDirectoryDialog
//------------------------------------------------------------------------------
CDirectoryDialog::CDirectoryDialog(
								   IN CWnd*	pParent
								   ) : CDialog(CDirectoryDialog::IDD, pParent)
/*++

Routine Description:

	Constructor

Arguments:

	IN pParent -	Parent window

Return Value:

	None

--*/
{
	//{{AFX_DATA_INIT(CDirectoryDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pTree = NULL;
}


//------------------------------------------------------------------------------
//	CDirectoryDialog::DoDataExchange
//------------------------------------------------------------------------------
void 
CDirectoryDialog::DoDataExchange(
								 IN CDataExchange* pDX
								 )
/*++

Routine Description:

	Handles member variable access

Arguments:

	IN pDX -	Data exchange

Return Value:

	None

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDirectoryDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDirectoryDialog, CDialog)
	//{{AFX_MSG_MAP(CDirectoryDialog)
	ON_NOTIFY(TVN_ITEMEXPANDING, IDC_DIRECTORY_TREE, OnItemExpanding)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------------
//	CDirectoryDialog::OnInitDialog
//------------------------------------------------------------------------------
BOOL 
CDirectoryDialog::OnInitDialog(void)
/*++

Routine Description:

	Sets up the directory tree

Arguments:

	None

Return Value:

	None

--*/
{
	// Get the tree control
	m_pTree = (CTreeCtrl*)GetDlgItem(IDC_DIRECTORY_TREE);

    // Initialize the image list.
    m_ilDrives.Create(IDB_DRIVEIMAGES, 16, 1, RGB (255, 0, 255));
    m_pTree->SetImageList(&m_ilDrives, TVSIL_NORMAL);

    // Populate the tree view with drive items.
    AddDrives();

    // Show the folders on the current drive.
    TCHAR szPath[MAX_PATH];
    ::GetCurrentDirectory(sizeof (szPath) / sizeof (TCHAR), szPath);
    CString strPath = szPath;
    strPath = strPath.Left(3);

    HTREEITEM hItem = m_pTree->GetNextItem(NULL, TVGN_ROOT);
    while(hItem != NULL) 
	{
        if(m_pTree->GetItemText(hItem) == strPath)
            break;
        hItem = m_pTree->GetNextSiblingItem(hItem);
    }

    if(hItem != NULL) 
	{
		m_pTree->Expand(hItem, TVE_EXPAND);
		m_pTree->Select(hItem, TVGN_CARET);
	}

	return TRUE;
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::AddDrives
//------------------------------------------------------------------------------
int 
CDirectoryDialog::AddDrives(void)
/*++

Routine Description:

	Adds the drives to the tree

Arguments:

	None

Return Value:

	The number of drives added

--*/
{
    int		nPos			= 0;
    int		nDrivesAdded	= 0;
    CString string			= _T ("?:\\");
    DWORD	dwDriveList		= ::GetLogicalDrives();

    while(dwDriveList) 
	{
        if(dwDriveList & 1) 
		{
            string.SetAt(0, (TCHAR)(_T ('A') + nPos));
            if(AddDriveItem(string))
                nDrivesAdded++;
        }
        dwDriveList >>= 1;
        nPos++;
    }
    return nDrivesAdded;
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::AddDriveItem
//------------------------------------------------------------------------------
BOOL 
CDirectoryDialog::AddDriveItem(
							   IN LPCTSTR pszDrive
							   )
/*++

Routine Description:

	Addes an individual drive to the tree

Arguments:

	None

Return Value:

	TRUE if a valid item is added

--*/
{
    CString		string;
    HTREEITEM	hItem;

    UINT nType = ::GetDriveType(pszDrive);

	if(!m_pTree)
		return FALSE;

    switch(nType) 
	{
    case DRIVE_REMOVABLE:
        hItem = m_pTree->InsertItem(pszDrive, ILI_FLOPPY, ILI_FLOPPY);
        m_pTree->InsertItem(_T (""), ILI_CLOSED_FOLDER, ILI_CLOSED_FOLDER, hItem);
        break;

    case DRIVE_FIXED:
    case DRIVE_RAMDISK:
        hItem = m_pTree->InsertItem(pszDrive, ILI_HARD_DISK, ILI_HARD_DISK);
        SetButtonState(hItem, pszDrive);
        break;

    case DRIVE_REMOTE:
        hItem = m_pTree->InsertItem(pszDrive, ILI_NET_DRIVE, ILI_NET_DRIVE);
        SetButtonState(hItem, pszDrive);
        break;

    case DRIVE_CDROM:
        hItem = m_pTree->InsertItem(pszDrive, ILI_CD_ROM, ILI_CD_ROM);
        m_pTree->InsertItem(_T (""), ILI_CLOSED_FOLDER, ILI_CLOSED_FOLDER, hItem);
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::SetButtonState
//------------------------------------------------------------------------------
BOOL 
CDirectoryDialog::SetButtonState(
								 IN HTREEITEM	hItem, 
								 IN LPCTSTR		pszPath
								 )
/*++

Routine Description:

	Sets the state of the tree buttons

Arguments:

	IN hItem -		Item
	IN pszPath -	Path

Return Value:

	TRUE on success

--*/
{
    HANDLE			hFind;
    WIN32_FIND_DATA	fd;
    BOOL			bResult = FALSE;

	if(!m_pTree)
		return FALSE;

    CString strPath = pszPath;
    if (strPath.Right (1) != _T ("\\"))
        strPath += _T ("\\");
    strPath += _T ("*.*");

    if((hFind = ::FindFirstFile(strPath, &fd)) == INVALID_HANDLE_VALUE)
        return bResult;

	do 
	{
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
		{
            CString strComp = fd.cFileName;
            if((strComp != _T (".")) && (strComp != _T (".."))) 
			{
                m_pTree->InsertItem(_T (""), ILI_CLOSED_FOLDER, ILI_CLOSED_FOLDER, hItem);
                bResult = TRUE;
                break;
            }
        }
    } 
	while(::FindNextFile (hFind, &fd));

    ::FindClose (hFind);
    return bResult;
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::OnItemExpanding
//------------------------------------------------------------------------------
void 
CDirectoryDialog::OnItemExpanding(
								  IN NMHDR*		pNMHDR, 
								  IN LRESULT*	pResult
								  ) 
/*++

Routine Description:

	Handles the expansion of the nodes

Arguments:

	IN pNMHDR -		?
	IN pResult -	Result of operation, TRUE on success, FALSE on failure

Return Value:

	None

--*/
{
    NM_TREEVIEW*	pNMTreeView	= (NM_TREEVIEW*)(void*)pNMHDR;
    HTREEITEM		hItem		= pNMTreeView->itemNew.hItem;
    CString			string		= GetPathFromItem(hItem);

    *pResult = FALSE;

    if(pNMTreeView->action == TVE_EXPAND) 
	{
        DeleteFirstChild(hItem);
        if(AddDirectories(hItem, string) == 0)
            *pResult = TRUE;
    }

    else if(m_pTree)
	{ 
        DeleteAllChildren(hItem);
        if (m_pTree->GetParentItem(hItem) == NULL)
            m_pTree->InsertItem(_T (""), ILI_CLOSED_FOLDER, ILI_CLOSED_FOLDER, hItem);
        else
            SetButtonState(hItem, string);
    }
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::GetPathFromItem
//------------------------------------------------------------------------------
CString 
CDirectoryDialog::GetPathFromItem(
								  IN HTREEITEM hItem
								  )
/*++

Routine Description:

	Gets a pathname from a tree item

Arguments:

	IN hItem -	Item

Return Value:

	Pathname

--*/
{
    CString		strResult;
    HTREEITEM	hParent;

	if(m_pTree)
	{
		strResult = m_pTree->GetItemText (hItem);
		while ((hParent = m_pTree->GetParentItem (hItem)) != NULL) 
		{
			CString string = m_pTree->GetItemText (hParent);
			if (string.Right (1) != _T ("\\"))
				string += _T ("\\");
			strResult = string + strResult;
			hItem = hParent;
		}
	}
    return strResult;
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::DeleteFirstChild
//------------------------------------------------------------------------------
void 
CDirectoryDialog::DeleteFirstChild(
								   IN HTREEITEM hItem
								   )
/*++

Routine Description:

	Deletes a child node

Arguments:

	IN hItem -	Item to delete

Return Value:

	None

--*/
{
    HTREEITEM hChildItem;
	if(m_pTree && (hChildItem = m_pTree->GetChildItem(hItem)) != NULL)
		m_pTree->DeleteItem(hChildItem);
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::DeleteAllChildren
//------------------------------------------------------------------------------
void 
CDirectoryDialog::DeleteAllChildren(
									IN HTREEITEM hItem
									)
/*++

Routine Description:

	Deletes all childred

Arguments:

	IN hItem -	Item to delete

Return Value:

	None

--*/
{
    HTREEITEM hChildItem;

    if(!m_pTree || (hChildItem = m_pTree->GetChildItem (hItem)) == NULL)
        return;

    do 
	{
        HTREEITEM hNextItem = m_pTree->GetNextSiblingItem(hChildItem);
        m_pTree->DeleteItem (hChildItem);
        hChildItem = hNextItem;
    }
	while(hChildItem != NULL);
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::AddDirectories
//------------------------------------------------------------------------------
int 
CDirectoryDialog::AddDirectories(
								 IN HTREEITEM	hItem, 
								 IN LPCTSTR		pszPath
								 )
/*++

Routine Description:

	Adds directories

Arguments:

	IN hItem -		Item number to add directories to
	IN pszPath -	Pathname to add

Return Value:

	Items added

--*/
{
    HANDLE			hFind;
    WIN32_FIND_DATA	fd;
    HTREEITEM		hNewItem;
    int				nCount	= 0;
    CString			strPath	= pszPath;

	if(!m_pTree)
		return 0;

    if (strPath.Right (1) != _T ("\\"))
        strPath += _T ("\\");
    strPath += _T ("*.*");

    if((hFind = ::FindFirstFile(strPath, &fd)) == INVALID_HANDLE_VALUE) 
	{
        if(m_pTree->GetParentItem(hItem) == NULL)
            m_pTree->InsertItem(_T (""), ILI_CLOSED_FOLDER, ILI_CLOSED_FOLDER, hItem);

		strPath.Format(_T("Please insert a disk into drive %s"), pszPath);
		strPath.Replace(_T(":\\"), _T(":"));
		AfxMessageBox((LPCTSTR)strPath, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
        return 0;
    }

	do 
	{
        if(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) 
		{
            CString strComp = fd.cFileName;
            if((strComp != _T (".")) && (strComp != _T (".."))) 
			{
                hNewItem = m_pTree->InsertItem(fd.cFileName, ILI_CLOSED_FOLDER, ILI_OPEN_FOLDER, hItem);

                CString strNewPath = pszPath;
                if(strNewPath.Right (1) != _T ("\\"))
                    strNewPath += _T ("\\");

                strNewPath += fd.cFileName;
                SetButtonState(hNewItem, strNewPath);
                nCount++;
            }
        }
    } 
	while (::FindNextFile (hFind, &fd));

    ::FindClose (hFind);
    return nCount;
}

//------------------------------------------------------------------------------
//	CDirectoryDialog::OnOK
//------------------------------------------------------------------------------
void 
CDirectoryDialog::OnOK(void) 
{
	if(m_pTree)
		m_directory = GetPathFromItem(m_pTree->GetSelectedItem());
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\DirectoryDialog.h ===
#if !defined(AFX_DIRECTORYDIALOG_H__1C8F71E4_0190_4F03_8FE1_DC34D41C1C0B__INCLUDED_)
#define AFX_DIRECTORYDIALOG_H__1C8F71E4_0190_4F03_8FE1_DC34D41C1C0B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DirectoryDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDirectoryDialog dialog

class CDirectoryDialog : public CDialog
{
// Construction
public:

	CDirectoryDialog(CWnd* pParent = NULL);   // standard constructor
	LPCTSTR GetDirectory(void) const { return (LPCTSTR)m_directory; };

// Dialog Data
	//{{AFX_DATA(CDirectoryDialog)
	enum { IDD = IDD_DIRECTORY_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	virtual BOOL OnInitDialog(void);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDirectoryDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDirectoryDialog)
	afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	int AddDrives(void);
	BOOL AddDriveItem(LPCTSTR pszDrive);
	BOOL SetButtonState(HTREEITEM hItem, LPCTSTR pszPath);
	CString GetPathFromItem(HTREEITEM hItem);
	void DeleteFirstChild(HTREEITEM hItem);
	void DeleteAllChildren(HTREEITEM hItem);
	int AddDirectories(HTREEITEM hItem, LPCTSTR pszPath);


private:

	CImageList	m_ilDrives;
	CTreeCtrl*	m_pTree;
	CString		m_directory;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIRECTORYDIALOG_H__1C8F71E4_0190_4F03_8FE1_DC34D41C1C0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\dspfixup.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	dspfixup.cpp

Abstract:

	xgpimage source code

Author:

	Robert Heitkamp (robheit) 15-Jun-2001

Revision History:

	15-Jun-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "..\xgpimage\dspfixup.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\dspbuilder.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	dspbuilder.cpp

Abstract:

	dspbuilder app class

Author:

	Robert Heitkamp (robheit) 10-Jan-2002

Revision History:

	10-Jan-2002 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "MainFrm.h"
#include "xboxverp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp

BEGIN_MESSAGE_MAP(CDspbuilderApp, CWinApp)
	//{{AFX_MSG_MAP(CDspbuilderApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp construction

CDspbuilderApp::CDspbuilderApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDspbuilderApp object

static CDspbuilderApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp initialization

BOOL CDspbuilderApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Microsoft"));

	// To create the main window, this code creates a new frame window
	// object and then sets it as the application's main window object.
	CMainFrame* pFrame = new CMainFrame;
	m_pMainWnd = pFrame;

	// create and load the frame with its resources
	pFrame->LoadFrame(IDR_MAINFRAME, WS_OVERLAPPEDWINDOW, NULL, NULL);

	// Resize the window to look nice
	RECT rect;
	pFrame->GetWindowRect(&rect);
	pFrame->MoveWindow(rect.left, rect.top, 800, 600);

	// The one and only window has been initialized, so show and update it.
	pFrame->ShowWindow(SW_SHOW);
	pFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp message handlers





/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

//------------------------------------------------------------------------------
//	CAboutDlg::OnInitDialog
//------------------------------------------------------------------------------
BOOL 
CAboutDlg::OnInitDialog(void)
/*++

Routine Description:

	Initializes the dialog by setting the text

Arguments:

	None

Return Value:

	TRUE on success, FALSE on failure

--*/
{
	CStatic*	pStatic;
	CString		string;

	if(CDialog::OnInitDialog())
	{
		string.Format(_T("dspbuilder Version 1.4.%4d"), VER_PRODUCTBUILD);
		pStatic = (CStatic*)GetDlgItem(IDC_ABOUT_VERSION);
		pStatic->SetWindowText(string);

		string.Format(_T("Copyright (C) 2001-2002 %s"), _T(VER_COMPANYNAME_STR));
		pStatic = (CStatic*)GetDlgItem(IDC_ABOUT_COPYRIGHT);
		pStatic->SetWindowText(string);
		return TRUE;
	}

	return FALSE;
}


BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CDspbuilderApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CDspbuilderApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\DirsDialog.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	DirsDialog.cpp

Abstract:

	Dialog for setting the directories needed by dspbuilder

Author:

	Robert Heitkamp (robheit) 20-Jul-2001

Revision History:

	20-Jul-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "DirsDialog.h"
#include "DirectoryDialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------------------------
//	CDirsDialog::CDirsDialog
//------------------------------------------------------------------------------
CDirsDialog::CDirsDialog(
						 IN CWnd*	pParent
						 ) : CDialog(CDirsDialog::IDD, pParent)
/*++

Routine Description:

	Constructor

Arguments:

	IN pParent -	Parent

Return Value:

	None

--*/
{
	//{{AFX_DATA_INIT(CDirsDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pIniEdit		= NULL;
	m_pDspCodeEdit	= NULL;
}

//------------------------------------------------------------------------------
//	CDirsDialog::DoDataExchange
//------------------------------------------------------------------------------
void 
CDirsDialog::DoDataExchange(
							IN CDataExchange* pDX
							)
/*++

Routine Description:

	Handles member variable changes

Arguments:

	IN pDX

Return Value:

	None

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDirsDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDirsDialog, CDialog)
	//{{AFX_MSG_MAP(CDirsDialog)
	ON_BN_CLICKED(IDC_INI_FILE_PATH_BROWSE, OnIniFilePathBrowse)
	ON_BN_CLICKED(IDC_DSP_CODE_PATH_BROWSE, OnDspCodePathBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDirsDialog message handlers

//------------------------------------------------------------------------------
//	CDirsDialog::OnIniFilePathBrowse
//------------------------------------------------------------------------------
void 
CDirsDialog::OnIniFilePathBrowse(void) 
/*++

Routine Description:

	Pops up a directory browser to select a directory

Arguments:

	None

Return Value:

	None

--*/
{
	CDirectoryDialog	directoryDialog;
	
	if(directoryDialog.DoModal() == IDOK)
	{
		m_iniPath = directoryDialog.GetDirectory();
		if(m_pIniEdit)
			m_pIniEdit->SetWindowText((LPCTSTR)m_iniPath);
	}
}

//------------------------------------------------------------------------------
//	CDirsDialog::OnDspCodePathBrowse
//------------------------------------------------------------------------------
void 
CDirsDialog::OnDspCodePathBrowse(void) 
/*++

Routine Description:

	Pops up a directory browser to select a directory

Arguments:

	None

Return Value:

	None

--*/
{
	CDirectoryDialog	directoryDialog;
	
	if(directoryDialog.DoModal() == IDOK)
	{
		m_dspCodePath = directoryDialog.GetDirectory();
		if(m_pDspCodeEdit)
			m_pDspCodeEdit->SetWindowText((LPCTSTR)m_dspCodePath);
	}
}


//------------------------------------------------------------------------------
//	CDirsDialog::OnInitDialog
//------------------------------------------------------------------------------
BOOL
CDirsDialog::OnInitDialog(void)
/*++

Routine Description:

	Initializes the dialog

Arguments:

	None

Return Value:

	None

--*/
{
	m_pIniEdit		= (CEdit*)GetDlgItem(IDC_INI_FILE_PATH_EDIT);
	m_pDspCodeEdit	= (CEdit*)GetDlgItem(IDC_DSP_CODE_PATH_EDIT);

	if(m_pIniEdit)
		m_pIniEdit->SetWindowText((LPCTSTR)m_iniPath);
	if(m_pDspCodeEdit)
		m_pDspCodeEdit->SetWindowText((LPCTSTR)m_dspCodePath);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CDirsDialog::OnOK
//------------------------------------------------------------------------------
void 
CDirsDialog::OnOK() 
{
	if(m_pIniEdit)
		m_pIniEdit->GetWindowText(m_iniPath);
	if(m_pDspCodeEdit)
		m_pDspCodeEdit->GetWindowText(m_dspCodePath);
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\DirsDialog.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	DirsDialog.h

Abstract:

	Dialog for setting the directories needed by dspbuilder

Author:

	Robert Heitkamp (robheit) 20-Jul-2001

Revision History:

	20-Jul-2001 robheit
		Initial Version

--*/
#if !defined(AFX_DIRSDIALOG_H__5671EA07_280C_4BCF_B7DA_1388F011A4B6__INCLUDED_)
#define AFX_DIRSDIALOG_H__5671EA07_280C_4BCF_B7DA_1388F011A4B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	CDirsDialog
//------------------------------------------------------------------------------
class CDirsDialog : public CDialog
{
public:

	CDirsDialog(CWnd* pParent = NULL);   // standard constructor

	LPCTSTR GetIniPath(void) const { return (LPCTSTR)m_iniPath; };
	LPCTSTR GetDspCodePath(void) const { return (LPCTSTR)m_dspCodePath; };
	void SetIniPath(LPCTSTR pPath) { m_iniPath = pPath; };
	void SetDspCodePath(LPCTSTR pPath) { m_dspCodePath = pPath; };

// Dialog Data
	//{{AFX_DATA(CDirsDialog)
	enum { IDD = IDD_DIRS_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDirsDialog)
	protected:
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDirsDialog)
	afx_msg void OnIniFilePathBrowse();
	afx_msg void OnDspCodePathBrowse();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

	CString	m_iniPath;
	CString	m_dspCodePath;
	CEdit*	m_pIniEdit;
	CEdit*	m_pDspCodeEdit;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIRSDIALOG_H__5671EA07_280C_4BCF_B7DA_1388F011A4B6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\dspbuilder.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	dspbuilder.h

Abstract:

	Main head file

Author:

	Robert Heitkamp (robheit) 08-Oct-2001

Revision History:

	08-Oct-2001 robheit
		Initial Version

--*/

#if !defined(AFX_DSPBUILDER_H__A4399BA9_E747_41EE_86C6_5881A0DA3E7E__INCLUDED_)
#define AFX_DSPBUILDER_H__A4399BA9_E747_41EE_86C6_5881A0DA3E7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <afxwin.h>         // MFC core and standard components
#include <afxcmn.h>
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls

#include "xboxverp.h"
#include <stdio.h>
#include <stdlib.h>
#include "xboxdbg.h"
#include "dsfxparmp.h"

#include "parser.h"
#include "..\inc\dsp.h"
#include "..\inc\cipher.h"


#include "resource.h"       // main symbols

//------------------------------------------------------------------------------
//	Globals Defines:
//------------------------------------------------------------------------------
#define MAX_SIZE	65535
#define SCALE		13

//------------------------------------------------------------------------------
//	Globals Macros:
//------------------------------------------------------------------------------
#define MAX(a,b) (((a) >= (b)) ? (a) : (b))
#define MIN(a,b) (((a) <= (b)) ? (a) : (b))
#define MEDIAN(a,b) (((a) <= (b)) ? (((b) - (a)) / 2 + (a)) : (((a) - (b)) / 2 + (b)))

//------------------------------------------------------------------------------
//	Globals Methods
//------------------------------------------------------------------------------
inline BOOL IsPointInRect(int x, int y, const CRect& r)
	{ return ((x >= r.left) && (x <= r.right) && (y >= r.top) && (y <= r.bottom)); };

//------------------------------------------------------------------------------
//	CDspbuilderApp
//------------------------------------------------------------------------------
class CDspbuilderApp : public CWinApp
{
public:
	CDspbuilderApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDspbuilderApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

public:
	//{{AFX_MSG(CDspbuilderApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DSPBUILDER_H__A4399BA9_E747_41EE_86C6_5881A0DA3E7E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\EffectNameDialog.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	EffectNameDialog.cpp

Abstract:

	Dialog to handle effect names

Author:

	Robert Heitkamp (robheit) 12-Feb-2002

Revision History:

	12-Feb-2002 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <math.h>
#include "resource.h"
#include "EffectNameDialog.h"

//------------------------------------------------------------------------------
//	Message Map
//------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CEffectNameDialog,CDialog)
	//{{AFX_MSG_MAP(CEffectNameDialog)
	ON_COMMAND(IDDEFAULT, OnDefault)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------------
//	CEffectNameDialog::CEffectNameDialog
//------------------------------------------------------------------------------
CEffectNameDialog::CEffectNameDialog(
								     IN LPCTSTR	pEffect,
									 IN LPCTSTR	pName
								     ) : CDialog(IDD_EFFECT_NAME_DIALOG)
/*++

Routine Description:

	Constructor

Arguments:

	IN pEffect -	True name of effect
	IN pName -		User name of effect

Return Value:

	None

--*/
{
	m_effect	= pEffect;
	m_name		= pName;
}

//------------------------------------------------------------------------------
//	CEffectNameDialog::~CEffectNameDialog
//------------------------------------------------------------------------------
CEffectNameDialog::~CEffectNameDialog(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CEffectNameDialog::OnInitDialog
//------------------------------------------------------------------------------
BOOL
CEffectNameDialog::OnInitDialog(void)
/*++

Routine Description:

	Initializes the dialog

Arguments:

	None

Return Value:

	None

--*/
{
	if(CDialog::OnInitDialog())
	{
		SetDlgItemText(IDC_EFFECT_NAME_EDIT, m_name);
		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CEffectNameDialog::OnOK
//------------------------------------------------------------------------------
void
CEffectNameDialog::OnOK(void)
/*++

Routine Description:

	Handles the Ok button

Arguments:

	None

Return Value:

	None

--*/
{
	GetDlgItemText(IDC_EFFECT_NAME_EDIT, m_name); 
	CDialog::OnOK();
}

//------------------------------------------------------------------------------
//	CEffectNameDialog::OnDefault
//------------------------------------------------------------------------------
void
CEffectNameDialog::OnDefault(void)
/*++

Routine Description:

	Resets the knobs to their original (last applied) settings

Arguments:

	None

Return Value:

	None

--*/
{
	m_name = m_effect;
	SetDlgItemText(IDC_EFFECT_NAME_EDIT, m_name);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\EffectNameDialog.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	EffectNameDialog.h

Abstract:

	Dialog to handle Effect names

Author:

	Robert Heitkamp (robheit) 12-Feb-2002

Revision History:

	12-Feb-2002 robheit
		Initial Version

--*/
#ifndef EFFECT_NAME_DIALOG_H
#define EFFECT_NAME_DIALOG_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <afxtempl.h>
#include "dspbuilder.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//	CEffectNameDialog
//------------------------------------------------------------------------------
class CEffectNameDialog : public CDialog  
{
public:

	CEffectNameDialog(LPCTSTR pEffect, LPCTSTR pName);
	virtual ~CEffectNameDialog(void);

	inline LPCTSTR GetName(void) const { return m_name; };

protected:

	virtual BOOL OnInitDialog(void);
	virtual void OnOK(void);

protected:

	//{{AFX_MSG(CEffectNameDialog)
	afx_msg void OnDefault();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	
	CString	m_name;
	CString	m_effect;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\ExportDialog.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ExportDialog.h

Abstract:

	Export options

Author:

	Robert Heitkamp (robheit) 14-Jun-2001

Revision History:

	14-Jun-2001 robheit
		Initial Version

--*/
#if !defined(AFX_EXPORTDIALOG_H__F52849B5_9623_4305_899A_06AB112B6A88__INCLUDED_)
#define AFX_EXPORTDIALOG_H__F52849B5_9623_4305_899A_06AB112B6A88__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"

//------------------------------------------------------------------------------
//	CExportDialog 
//------------------------------------------------------------------------------
class CExportDialog : public CDialog  
{
public:

	CExportDialog(void);
	CExportDialog(const CStringArray& configs);
	virtual ~CExportDialog(void);

	LPCTSTR GetI3DL2(void) const { return m_i3dl2; };
	BOOL GetPatchXTalkToLFE(void) const { return m_bPatchXtalkToLFE; };
	BOOL GetIncludeXTalk(void) const { return m_bIncludeXtalk; };
	void SetPatchXTalkToLFE(BOOL bFlag) { m_bPatchXtalkToLFE = bFlag; };
	void SetI3DL2(LPCTSTR pReverb) { m_i3dl2 = pReverb; };
	void SetIncludeXTalk(BOOL bFlag) { m_bIncludeXtalk = bFlag; };
	void SetConfigs(const CStringArray& configs) { m_configs.Append(configs); };

protected:

	virtual void OnOK(void);
	virtual BOOL OnInitDialog(void);

private:

	CStringArray	m_configs;
	CString			m_i3dl2;
	BOOL			m_bPatchXtalkToLFE;
	BOOL			m_bIncludeXtalk;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\fxdspimg.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	fxdspimg.cpp

Abstract:

	xgpimage source code

Author:

	Robert Heitkamp (robheit) 15-Jun-2001

Revision History:

	15-Jun-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "..\xgpimage\fxdspimg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Freeze.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Freeze.h

Abstract:

	Controls activity - basically a counter

Author:

	Robert Heitkamp (robheit) 08-Nov-2001

Revision History:

	21-Nov-2001 robheit
		Initial Version

--*/

#if !defined(AFX_FREEZE_H__D4FC802F_3801_4967_A5D7_ED754BFDBD2C__INCLUDED_)
#define AFX_FREEZE_H__D4FC802F_3801_4967_A5D7_ED754BFDBD2C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	CFreeze
//------------------------------------------------------------------------------
class CFreeze  
{
public:

	CFreeze(void)				{ m_freeze = 0; };
	virtual ~CFreeze(void)		{ };

	inline int PushFreeze(void)	{ return ++m_freeze; };
	inline int PopFreeze(void)	{ return ((m_freeze > 0) ? --m_freeze : 0); };
	inline BOOL IsFrozen(void)	{ return ((m_freeze > 0) ? TRUE : FALSE); };
	inline void Freeze(void)	{ m_freeze = INT_MAX; };
//	inline void Thaw(void)		{ m_freeze = 0; };

private:

	int	m_freeze;

};

#endif // !defined(AFX_FREEZE_H__D4FC802F_3801_4967_A5D7_ED754BFDBD2C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\ExportDialog.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ExportDialog.cpp

Abstract:

	Export options dialog

Author:

	Robert Heitkamp (robheit) 14-Jun-2001

Revision History:

	14-Jun-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "ExportDialog.h"
#include "resource.h"

//------------------------------------------------------------------------------
//	CExportDialog::CExportDialog
//------------------------------------------------------------------------------
CExportDialog::CExportDialog(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_bPatchXtalkToLFE	= FALSE;
	m_bIncludeXtalk		= TRUE;
}

//------------------------------------------------------------------------------
//	CExportDialog::CExportDialog
//------------------------------------------------------------------------------
CExportDialog::CExportDialog(
							 IN const CStringArray&	configs
							 ) : CDialog(IDD_EXPORT_DIALOG)
/*++

Routine Description:

	Constructor

Arguments:

	IN configs - Reverb configurations

Return Value:

	None

--*/
{
	SetConfigs(configs);
	m_bPatchXtalkToLFE	= FALSE;
	m_bIncludeXtalk		= TRUE;
}

//------------------------------------------------------------------------------
//	CExportDialog::~CExportDialog
//------------------------------------------------------------------------------
CExportDialog::~CExportDialog(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CExportDialog::OnOK
//------------------------------------------------------------------------------
void
CExportDialog::OnOK(void)
{
	CComboBox*	pComboBox;

	m_bPatchXtalkToLFE	= IsDlgButtonChecked(IDC_PATCH_XTALK_TO_LFE) ? TRUE : FALSE;
	pComboBox			= (CComboBox*)GetDlgItem(IDC_I3DL2_COMBO);
	m_bIncludeXtalk		= IsDlgButtonChecked(IDC_EXPORT_OPTIONS_XTALK) ? TRUE : FALSE;

	if(pComboBox->GetCurSel() == 0)
		m_i3dl2 = _T("");
	else
		m_i3dl2 = m_configs[pComboBox->GetCurSel()-1];

	CDialog::OnOK();
}

//------------------------------------------------------------------------------
//	CExportDialog::OnInitDialog
//------------------------------------------------------------------------------
BOOL
CExportDialog::OnInitDialog(void)
/*++

Routine Description:

	Handles the initialization of the dialog by adding the configs to the
	combo box

Arguments:

	None

Return Value:

	None

--*/
{
	CComboBox*	pComboBox;
	CRect		rect;
	CRect		dRect;
	int			i;

	if(CDialog::OnInitDialog())
	{
		// Setup the list
		pComboBox = (CComboBox*)GetDlgItem(IDC_I3DL2_COMBO);
		pComboBox->ResetContent();
		pComboBox->AddString(_T("<None>"));
		for(i=0; i<m_configs.GetSize(); ++i)
			pComboBox->AddString(m_configs[i]);

		// Select a reverb
		if(m_i3dl2.IsEmpty())
			pComboBox->SetCurSel(0);
		else
		{
			for(i=0; i<m_configs.GetSize(); ++i)
			{
				if(m_i3dl2 == m_configs[i])
				{
					pComboBox->SetCurSel(i+1);
					break;
				}
			}
			if(i == m_configs.GetSize())
			{
				pComboBox->SetCurSel(0);
				m_i3dl2.Empty();
			}
		}

		// Adjust the dropdown height
		GetClientRect(dRect);
		ClientToScreen(dRect);
		pComboBox->GetClientRect(rect);
		pComboBox->ClientToScreen(rect);
		rect.left	-= dRect.left;
		rect.right	-= dRect.left;
		rect.top	-= dRect.top;
		rect.bottom	= rect.top + 100;
		pComboBox->MoveWindow(rect);

		// Check the patch box
		CheckDlgButton(IDC_PATCH_XTALK_TO_LFE, (unsigned int)m_bPatchXtalkToLFE);

		// Include Xtalk?
		CheckDlgButton(IDC_EXPORT_OPTIONS_XTALK, (unsigned int)m_bIncludeXtalk);
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Graph.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Graph.cpp

Abstract:

	Graph of effects

Author:

	Robert Heitkamp (robheit) 08-Nov-2001

Revision History:

	08-Nov-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "Graph.h"
#include "Module.h"
#include "parser.h"
#include "ExportDialog.h"
#include "ChildView.h"
#include "PatchCord.h"
#include "Jack.h"

//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define SECTION_MAX_SIZE		4096
#define INPUT_MIXBIN_MASK		0x0400
#define OUTPUT_MIXBIN_MASK		0x0800
#define TOLERANCE				2

//------------------------------------------------------------------------------
//	Stuff:
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define CI(x, y) (((x) * m_gridHeight) + (y))

//------------------------------------------------------------------------------
//	Structures
//------------------------------------------------------------------------------
struct EffectChainBucket
{
	CArray<CModule*, CModule*>	effects;
	CArray<int, int>			inputs;	 // Negative values are temp mixbins
	CArray<int, int>			outputs; // Negative values are temp mixbins
	CStringArray				stateFiles;
	CStringArray				stateFilePaths;

	EffectChainBucket& operator = (const EffectChainBucket& ecb)
	{
		effects.Copy(ecb.effects);
		inputs.Copy(ecb.inputs);
		outputs.Copy(ecb.outputs);
		stateFiles.Copy(ecb.stateFiles);
		stateFilePaths.Copy(ecb.stateFilePaths);
		return *this;
	}
};

//------------------------------------------------------------------------------
//	CGraph::CGraph
//------------------------------------------------------------------------------
CGraph::CGraph(
			   IN CChildView*	pParent
			   )
/*++

Routine Description:

	Constructor

Arguments:

	IN pParent -	Parent window of the graph

Return Value:

	None

--*/
{
	int		i;
	LPCTSTR	mixbins[] = // These MUST remain in the same order, if their
	{					// order or content changes, InsertModule() must be
		_T("I3DL2"),	// updated
		_T("FX Send 0"), 
		_T("FX Send 1"),
		_T("FX Send 2"),
		_T("FX Send 3"),
		_T("FX Send 4"),
		_T("FX Send 5"),
		_T("FX Send 6"),
		_T("FX Send 7"),
		_T("FX Send 8"),
		_T("FX Send 9"),
		_T("FX Send 10"),
		_T("FX Send 11"),
		_T("FX Send 12"),
		_T("FX Send 13"),
		_T("FX Send 14"),
		_T("FX Send 15"),
		_T("FX Send 16"),
		_T("FX Send 17"),
		_T("FX Send 18"),
		_T("FX Send 19"),
	};

	// Intitialize a few things
	m_pXTalk			= NULL;
	m_pI3DL2			= NULL;
	m_pI3DL2_24K		= NULL;
	m_p2x1Mixer			= NULL;
	m_bEffectsLoaded	= FALSE;
	m_bChangesMade		= FALSE;
	m_bInsertModules	= FALSE;
	m_bLeftMouseDown	= FALSE;
	m_bDrawGrid			= FALSE;
	m_bSnapToGrid		= TRUE;
	m_snapSize			= SCALE;
	m_bDeleteConfigMenu	= FALSE;
	m_bUseOffset		= FALSE;
	m_bDrawLine			= FALSE;
	m_bDrawComplexLine	= FALSE;
	m_bStartDrawLine	= FALSE;
	m_bDragPatch		= FALSE;
	m_bImageSaved		= FALSE;
	m_bPatchXtalkToLFE	= FALSE;
	m_bIncludeXtalk		= TRUE;
	m_pGrid				= NULL;
	m_bDead				= FALSE;
	m_imageBuilder		= new CWinDspImageBuilder;
	m_rect.SetRect(0, 0, 0, 0);
	SetParent(pParent);

	// Set the paths to the effects files
	SetPaths();

	// Load all the effects
	if(!LoadEffects())
	{
		AfxMessageBox(_T("Unable to load effects. Please specify a valid "
					     "directory."), MB_OK | MB_ICONERROR | MB_APPLMODAL);
	}

	// Create the mixbins
	CreateMixbins();

	// Create the effects menu
	m_moduleMenu.CreatePopupMenu();
	m_moduleMenu.AppendMenu(MF_STRING, ID_EFFECTS_PROPERTIES, _T("&Properties..."));
	m_moduleMenu.AppendMenu(MF_STRING, ID_EFFECTS_NAME, _T("&Name..."));
	m_moduleMenu.AppendMenu(MF_STRING, ID_EFFECTS_DELETE, _T("&Delete"));
	m_moduleMenu.AppendMenu(MF_STRING, ID_EFFECTS_DISCONNECT_ALL, _T("Disconnect &All"));
	m_moduleMenu.AppendMenu(MF_STRING, ID_EFFECTS_DISCONNECT_INPUTS, _T("Disconnect &Inputs"));
	m_moduleMenu.AppendMenu(MF_STRING, ID_EFFECTS_DISCONNECT_OUTPUTS,_T("Disconnect &Outputs"));

	// Patch cord menu
	m_patchCordMenu.CreatePopupMenu();
	m_patchCordMenu.AppendMenu(MF_STRING, ID_PATCH_DISCONNECT, _T("&Disconnect"));
//	m_patchCordMenu.AppendMenu(MF_STRING, ID_PATCH_OVERWRITE, _T("&Overwrite"));

	// Speaker menus
	m_inputSpeakerMenu.CreatePopupMenu();
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 0 | INPUT_MIXBIN_MASK, _T("All"));
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 1 | INPUT_MIXBIN_MASK, _T("Front + Rear"));
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 2 | INPUT_MIXBIN_MASK, _T("Front"));
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 3 | INPUT_MIXBIN_MASK, _T("Rear"));
	m_inputSpeakerMenu.AppendMenu(MF_SEPARATOR);
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 4 | INPUT_MIXBIN_MASK, _T("Front Left"));
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 5 | INPUT_MIXBIN_MASK, _T("Front Right"));
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 6 | INPUT_MIXBIN_MASK, _T("Center"));
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 7 | INPUT_MIXBIN_MASK, _T("LFE"));
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 8 | INPUT_MIXBIN_MASK, _T("Back Left"));
	m_inputSpeakerMenu.AppendMenu(MF_STRING, 9 | INPUT_MIXBIN_MASK, _T("Back Right"));

	m_outputSpeakerMenu.CreatePopupMenu();
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 0 | OUTPUT_MIXBIN_MASK, _T("All"));
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 1 | OUTPUT_MIXBIN_MASK, _T("Front + Rear"));
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 2 | OUTPUT_MIXBIN_MASK, _T("Front"));
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 3 | OUTPUT_MIXBIN_MASK, _T("Rear"));
	m_outputSpeakerMenu.AppendMenu(MF_SEPARATOR);
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 4 | OUTPUT_MIXBIN_MASK, _T("Front Left"));
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 5 | OUTPUT_MIXBIN_MASK, _T("Front Right"));
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 6 | OUTPUT_MIXBIN_MASK, _T("Center"));
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 7 | OUTPUT_MIXBIN_MASK, _T("LFE"));
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 8 | OUTPUT_MIXBIN_MASK, _T("Back Left"));
	m_outputSpeakerMenu.AppendMenu(MF_STRING, 9 | OUTPUT_MIXBIN_MASK, _T("Back Right"));

	// XTalk Menus
	m_inputXtalkMenu.CreatePopupMenu();
	m_inputXtalkMenu.AppendMenu(MF_STRING, 10 | INPUT_MIXBIN_MASK, _T("All"));
	m_inputXtalkMenu.AppendMenu(MF_SEPARATOR);
	m_inputXtalkMenu.AppendMenu(MF_STRING, 11 | INPUT_MIXBIN_MASK, _T("Front Left"));
	m_inputXtalkMenu.AppendMenu(MF_STRING, 12 | INPUT_MIXBIN_MASK, _T("Front Right"));
	m_inputXtalkMenu.AppendMenu(MF_STRING, 13 | INPUT_MIXBIN_MASK, _T("Back Left"));
	m_inputXtalkMenu.AppendMenu(MF_STRING, 14 | INPUT_MIXBIN_MASK, _T("Back Right"));

	m_outputXtalkMenu.CreatePopupMenu();
	m_outputXtalkMenu.AppendMenu(MF_STRING, 10 | OUTPUT_MIXBIN_MASK, _T("All"));
	m_outputXtalkMenu.AppendMenu(MF_SEPARATOR);
	m_outputXtalkMenu.AppendMenu(MF_STRING, 11 | OUTPUT_MIXBIN_MASK, _T("Front Left"));
	m_outputXtalkMenu.AppendMenu(MF_STRING, 12 | OUTPUT_MIXBIN_MASK, _T("Front Right"));
	m_outputXtalkMenu.AppendMenu(MF_STRING, 13 | OUTPUT_MIXBIN_MASK, _T("Back Left"));
	m_outputXtalkMenu.AppendMenu(MF_STRING, 14 | OUTPUT_MIXBIN_MASK, _T("Back Right"));

	// Insert mixbin menus
	m_inputMixbinMenu.CreatePopupMenu();
	m_outputMixbinMenu.CreatePopupMenu();

	m_inputMixbinMenu.AppendMenu(MF_POPUP,  (UINT)m_inputSpeakerMenu.Detach(), _T("Speakers"));
	m_inputMixbinMenu.AppendMenu(MF_POPUP,  (UINT)m_inputXtalkMenu.Detach(), _T("XTalk"));
	m_outputMixbinMenu.AppendMenu(MF_POPUP,  (UINT)m_outputSpeakerMenu.Detach(), _T("Speakers"));
	m_outputMixbinMenu.AppendMenu(MF_POPUP,  (UINT)m_outputXtalkMenu.Detach(), _T("XTalk"));

	// Add all the mixbins to the insert mixbin menu
	for(i=0; i<(int)(sizeof(mixbins) / sizeof(mixbins[0])); ++i)
	{
		m_inputMixbinMenu.AppendMenu(MF_STRING, (UINT)(i + 15) | INPUT_MIXBIN_MASK, mixbins[i]);
		m_outputMixbinMenu.AppendMenu(MF_STRING, (UINT)(i + 15) | OUTPUT_MIXBIN_MASK, mixbins[i]);
	}

	// Insert effects menu
	m_effectMenu.CreatePopupMenu();

	// Add all the effects to the insert effects menu
	for(i=0; i<m_effects.GetSize(); ++i)
		m_effectMenu.AppendMenu(MF_STRING, (UINT)(i+1), m_effects[i]->GetEffectName());

	// Grid menu (root menu)
	m_rootMenu.CreatePopupMenu();
	m_rootMenu.AppendMenu(MF_POPUP, (UINT)m_inputMixbinMenu.Detach(), _T("Insert &Input Mixbin"));
	m_rootMenu.AppendMenu(MF_POPUP, (UINT)m_outputMixbinMenu.Detach(), _T("Insert &Output Mixbin"));
	m_rootMenu.AppendMenu(MF_POPUP, (UINT)m_effectMenu.Detach(), _T("Insert &Effect"));
	m_rootMenu.AppendMenu(MF_STRING, ID_GRID_DISCONNECT_ALL, _T("Disconnect &All"));
	m_rootMenu.AppendMenu(MF_STRING, ID_GRID_DELETE_ALL, _T("&Delete All"));
	m_rootMenu.AppendMenu(MF_STRING, ID_GRID_SHOW_GRID, _T("&Show Grid"));

	// Create the font
	m_font.CreatePointFont(80, _T("Arial"));

	// Start it up...
	SetTitle();
}

//------------------------------------------------------------------------------
//	CGraph::~CGraph
//------------------------------------------------------------------------------
CGraph::~CGraph(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	int			i;
	CModule*	pModule;
	CPatchCord*	pPatchCord;

	// I am dead
	m_bDead = TRUE;

	// Stop all drawing
	Freeze();

	// Delete the imagebuilder
	delete m_imageBuilder;

	// Free data
	ClearEffects();
	ClearMixbins();

	// Delete modules
	for(i=m_modules.GetSize()-1; i>=0; --i)
	{
		pModule = m_modules[i];
		m_modules.RemoveAt(i);
		delete pModule;
	}

	// Delete any patch cords that are left
	for(i=m_patchCords.GetSize()-1; i>=0; --i)
	{
		pPatchCord = m_patchCords[i];
		m_patchCords.RemoveAt(i);
		delete pPatchCord;
	}
}

//------------------------------------------------------------------------------
//	CGraph::Draw
//------------------------------------------------------------------------------
void
CGraph::Draw(
			 IN const CRect&	rect,
			 IN CDC*			pDC
			 )
/*++

Routine Description:

	Draws the graph and its contents

Arguments:

	None

Return Value:

	None

--*/
{
	int		i;
	BOOL	deleteDC;;
	CFont*	oldFont;
	int		x;
	int		y;
	CRect	bigRect = rect;

	if(m_bDead || IsFrozen())
		return;

	// Create a device context?
	if(pDC == NULL)
	{
		pDC			= new CClientDC(m_pParent);
		deleteDC	= TRUE;
	}
	else
		deleteDC = FALSE;

	// Adjust the origin
	pDC->SetWindowOrg(m_rect.left, m_rect.top);	

	bigRect.InflateRect(5,5,5,5);

	// If no DC is specified, clear the region manually
	if(deleteDC)
		pDC->FillSolidRect(bigRect, RGB(255, 255, 255));
	
	// Select the font
	oldFont = pDC->SelectObject(&m_font);

	// Draw the grid?
	if(m_bDrawGrid)
	{
		for(x=bigRect.left - (bigRect.left % SCALE); x<=bigRect.right; x+=SCALE)
		{
			for(y=bigRect.top - (bigRect.top % SCALE); y<=bigRect.bottom; y+=SCALE)
				pDC->SetPixel(x, y, RGB(0, 128, 128));
		}
	}

	// Draw all modules within the rect
	for(i=0; i<m_modules.GetSize(); ++i)
	{
		if(IntersectRects(bigRect, m_modules[i]->GetRect()))
			m_modules[i]->Draw(pDC);
	}

	// Draw all the patch cords
	for(i=0; i<m_patchCords.GetSize(); ++i)
	{
		if(IntersectRects(bigRect, m_patchCords[i]->GetRect()))
			m_patchCords[i]->Draw(pDC);
	}

	// Draw a moving modules
	if(m_moveModules.GetSize())
	{
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			if(IntersectRects(bigRect, m_moveModules[i]->GetRect()))
				m_moveModules[i]->Draw(pDC);
		}
	}

	// Restore
	pDC->SelectObject(oldFont);

	// Delete the dc?
	if(deleteDC)
		delete pDC;
}

//------------------------------------------------------------------------------
//	CGraph::ToggleGrid
//------------------------------------------------------------------------------
void
CGraph::ToggleGrid(void)
/*++

Routine Description:

	Toggles the state of the grid

Arguments:

	None

Return Value:

	None

--*/
{	
	m_bDrawGrid = !m_bDrawGrid;
	Draw(m_rect);
}

//------------------------------------------------------------------------------
//	CGraph::DeletePatchCord
//------------------------------------------------------------------------------
void 
CGraph::DeletePatchCord(
						IN CPatchCord*	pPatchCord
						)
/*++

Routine Description:

	Deletes a patch cord and redraws the exposed region

Arguments:

	IN pPatchCord -	Patch cord to delete

Return Value:

	None

--*/
{
	int						i;
	int						ii;
	CPatchCord*				pJoin[2] = {NULL, NULL};
	CPatchCord::PatchNode*	pNode;
	int						count;
	BOOL					bEnd;

	for(i=0; i<m_patchCords.GetSize(); ++i)
	{
		if(m_patchCords[i] == pPatchCord)
		{
			m_patchCords.RemoveAt(i);
			Draw(pPatchCord->GetRect());
			break;
		}
	}

	// If the patch cord is connected to only 2 other patch cords, those
	// two cords will need to be joined
	for(ii=0; ii<2; ++ii)
	{
		if(ii)
			bEnd = TRUE;
		else
			bEnd = FALSE;

		for(count=0, pNode = pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(pNode->bEnd == bEnd)
			{
				if(count < 2)
					pJoin[count] = pNode->pPatchCord;
				++count;
			}
		}

		if(count == 2)
		{
			// Remove pPatchCord from both
			pJoin[0]->RemovePatchCord(pPatchCord);
			pJoin[1]->RemovePatchCord(pPatchCord);
			pPatchCord->RemovePatchCord(pJoin[0]);
			pPatchCord->RemovePatchCord(pJoin[1]);

			// Remove B from the list
			for(i=0; i<m_patchCords.GetSize(); ++i)
			{
				if(m_patchCords[i] == pJoin[1])
				{
					m_patchCords.RemoveAt(i);
					break;
				}
			}

			// Join B to A (which will delete B)
			pJoin[0]->Join(pJoin[1]);

			Draw(pJoin[0]->GetRect());
		}
	}

	delete pPatchCord;

	ValidateGraph();
}

//------------------------------------------------------------------------------
//	CGraph::SetRect
//------------------------------------------------------------------------------
void 
CGraph::SetRect(
				const CRect&	rect
				)
/*++

Routine Description:

	Sets the visible rect

Arguments:

	IN rect -	Rect

Return Value:

	None

--*/
{
	m_mouse		-= m_rect.TopLeft();
	m_upperLeft	-= m_rect.TopLeft();
	m_rect		= rect;
	m_mouse		+= m_rect.TopLeft();
	m_upperLeft	+= m_rect.TopLeft();
}

//------------------------------------------------------------------------------
//	CGraph::GetBounds
//------------------------------------------------------------------------------
const CRect&
CGraph::GetBounds(void)
/*++

Routine Description:

	Returns the bounds of all the data

Arguments:

	None

Return Value:

	The data bounds

--*/
{
	int	i;

	m_bounds.SetRect(0, 0, 0, 0);

	for(i=0; i<m_modules.GetSize(); ++i)
		m_bounds.UnionRect(m_bounds, m_modules[i]->GetRect());

	for(i=0; i<m_patchCords.GetSize(); ++i)
		m_bounds.UnionRect(m_bounds, m_patchCords[i]->GetRect());

	return m_bounds;
}

//------------------------------------------------------------------------------
//	CGraph::SetPaths
//------------------------------------------------------------------------------
void 
CGraph::SetPaths(
				 IN LPCTSTR	pIniPath,
				 IN LPCTSTR	pDspCodePath
				 )
/*++

Routine Description:

	Saves the ini and dsp paths to the registry

Arguments:

	None

Return Value:

	None

--*/
{
	int		i;
	HKEY	hKey;

	if(m_iniPath != pIniPath)
	{
		if(!IsEmpty())
		{
			if(AfxMessageBox(_T("Changing the INI File Path will invalidate your current image. Do you wish to continue?"), MB_YESNO | MB_APPLMODAL | MB_ICONQUESTION) == IDCANCEL)
				return;
			
			// Start fresh
			New(FALSE);
		}

		m_iniPath = pIniPath;

		// Clear the effects menu
		m_rootMenu.DeleteMenu(2, MF_BYPOSITION);

		if(LoadEffects())
		{
			// Insert effects menu
			if(m_effectMenu.CreatePopupMenu())
			{
				// Add all the effects to the insert effects menu
				for(i=0; i<m_effects.GetSize(); ++i)
					m_effectMenu.AppendMenu(MF_STRING, (UINT)(i+1), m_effects[i]->GetEffectName());
				m_rootMenu.InsertMenu(2, MF_BYPOSITION | MF_POPUP, (UINT)m_effectMenu.Detach(), _T("&Insert Effect"));
			}
		}
		else
			AfxMessageBox(_T("Unable to load effects. Please specify a valid directory."), MB_OK | MB_ICONERROR | MB_APPLMODAL);
	}
	m_dspCodePath = pDspCodePath;

	// Update the registry
	if(RegCreateKeyEx(HKEY_CURRENT_USER,  
					  _T("Software\\Microsoft\\dspbuilder"), 
					  0, NULL, REG_OPTION_NON_VOLATILE,
					  KEY_WRITE, NULL, &hKey, NULL) == ERROR_SUCCESS)
	{
		RegSetValueEx(hKey, _T("iniPath"), NULL, REG_SZ, 
					  (const unsigned char*)(LPCTSTR)m_iniPath, 
					  (unsigned long)m_iniPath.GetLength()+1);
		RegSetValueEx(hKey, _T("dspCodePath"), NULL, REG_SZ,
					  (const unsigned char*)(LPCTSTR)m_dspCodePath, 
					  (unsigned long)m_dspCodePath.GetLength()+1);

		RegCloseKey(hKey);
	}
}

//------------------------------------------------------------------------------
//	CGraph::IsEmpty
//------------------------------------------------------------------------------
BOOL 
CGraph::IsEmpty(void) const
/*++

Routine Description:

	Returns TRUE if the graph is empty

Arguments:

	None

Return Value:

	TRUE if the graph is empty, FALSE otherwise

--*/
{
	return (m_modules.GetSize() == 0);
}

//------------------------------------------------------------------------------
//	CGraph::New
//------------------------------------------------------------------------------
BOOL 
CGraph::New(
			IN BOOL	bAllowCancel
			)
/*++

Routine Description:

	Nukes the graph and restarts fresh

Arguments:

	IN bAllowCancel -	TRUE to allow the user to cancel if changes are made

Return Value:

	Nothing

--*/
{
	int			i;
	UINT		flags;
	CModule*	pModule;
	CPatchCord*	pPatchCord;

	// Prompt to save
	if(!IsEmpty() && m_bChangesMade)
	{	
		if(bAllowCancel)
			flags = MB_YESNOCANCEL | MB_APPLMODAL | MB_ICONQUESTION;
		else
			flags = MB_YESNO | MB_APPLMODAL | MB_ICONQUESTION;
		switch(AfxMessageBox(_T("Save changes?"), flags))
		{
		case IDYES:
			if(!Save(m_filename))
				return FALSE;
			break;
		case IDCANCEL:
			return FALSE;
		default:
			break;
		}
	}

	// Stop all drawing
	PushFreeze();

	// Delete modules
	for(i=m_modules.GetSize()-1; i>=0; --i)
	{
		pModule = m_modules[i];
		m_modules.RemoveAt(i);
		delete pModule;
	}

	// Delete any patch cords that are left
	for(i=m_patchCords.GetSize()-1; i>=0; --i)
	{
		pPatchCord = m_patchCords[i];
		m_patchCords.RemoveAt(i);
		delete pPatchCord;
	}

	// Reset in use flags
	for(i=0; i<m_inputMixbinInUse.GetSize(); ++i)
		m_inputMixbinInUse[i] = FALSE;
	for(i=0; i<m_outputMixbinInUse.GetSize(); ++i)
		m_outputMixbinInUse[i] = FALSE;

	m_pParent->Reset();

	PopFreeze();
	Draw(m_rect);

	m_filename.Empty();
	m_bChangesMade	= FALSE;
	m_bImageSaved	= FALSE;
	SetTitle();

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::Save
//------------------------------------------------------------------------------
BOOL 
CGraph::Save(
			 IN LPCTSTR	pFilename
			 )
/*++

Routine Description:

	Saves the graph 

Arguments:

	IN pFilename -	File to save to

Return Value:

	TRUE if the save succeeded, FALSE otherwise

--*/
{
	CFile	file;
	CString	string;
	BYTE	b;
	WORD	word;
	int		i;

	if(pFilename && strlen(pFilename))
		m_filename = pFilename;

	// Was a filename specified?
	else if(m_filename.IsEmpty())
	{
		CFileDialog	fileDialog(FALSE, _T("fx"), NULL, OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST,
							   _T("DSP Builder Files (.fx)|*.fx|All Files (*.*)|*.*||"));
		if(fileDialog.DoModal() != IDOK)
			return FALSE;
		m_filename		= fileDialog.GetPathName();
		m_bImageSaved	= FALSE;
	}

	SetTitle();

	// Open the file
	if(!file.Open(m_filename, CFile::modeWrite | CFile::modeCreate | CFile::typeBinary))
	{
		string.Format(_T("Unable to open file: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}

	// Write the header
	file.Write("DSPBUILDER", 10);

	// Write the version
	b = cFileVersion;
	file.Write(&b, sizeof(b));

	// Save the build options
	file.Write((LPCTSTR)m_i3dl2Config, ((unsigned)m_i3dl2Config.GetLength() + 1) * sizeof(TCHAR));
	b = (BYTE)(m_bPatchXtalkToLFE ? 1 : 0);
	file.Write(&b, sizeof(b));
	b = (BYTE)(m_bIncludeXtalk ? 1 : 0);
	file.Write(&b, sizeof(b));

	// Write the number of modules
	word = (WORD)m_modules.GetSize();
	file.Write(&word, sizeof(word));

	// Write all the modules
	for(i=0; i<m_modules.GetSize(); ++i)
		m_modules[i]->Write(file);
	
	// Write the number of patch cords
	word = (WORD)m_patchCords.GetSize();
	file.Write(&word, sizeof(word));

	// Write the patch cords
	for(i=0; i<m_patchCords.GetSize(); ++i)
		m_patchCords[i]->Write(file);

	m_bChangesMade = FALSE;
	file.Close();

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::SelectBuildOptions
//------------------------------------------------------------------------------
BOOL
CGraph::SelectBuildOptions(void)
/*++

Routine Description:

	Selects the build options

Arguments:

	None

Return Value:

	TRUE on Ok, FALSE on Cancel

--*/
{
	CStringArray	strings24k;
	int				i;

	// Prompt for export options
	if(m_pI3DL2_24K)
	{
		for(i=0; i<m_pI3DL2_24K->GetNumConfigs(); ++i)
			strings24k.Add(m_pI3DL2_24K->GetConfigs()[i].name);
	}

	CExportDialog	exportDialog(strings24k);	
	exportDialog.SetPatchXTalkToLFE(m_bPatchXtalkToLFE);
	exportDialog.SetI3DL2(m_i3dl2Config);
	exportDialog.SetIncludeXTalk(m_bIncludeXtalk);
	if(exportDialog.DoModal() == IDCANCEL)
		return FALSE;

	m_i3dl2Config		= exportDialog.GetI3DL2();
	m_bPatchXtalkToLFE	= exportDialog.GetPatchXTalkToLFE();
	m_bIncludeXtalk		= exportDialog.GetIncludeXTalk();
	m_bChangesMade		= TRUE;
	SetTitle();
	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::Open
//------------------------------------------------------------------------------
BOOL 
CGraph::Open(
			 IN LPCTSTR	pFilename
			 )
/*++

Routine Description:

	Opens a grid file

Arguments:

	IN pFilename -	File to open

Return Value:

	TRUE if the open succeeded, FALSE otherwise

--*/
{
	CFile	file;
	CString	filename;
	CString	string;
	BYTE	b;
	char	header[11];

	if(pFilename && strlen(pFilename))
		filename = pFilename;
	else
		filename = m_filename;

	// Was a filename specified?
	if(filename.IsEmpty())
	{
		CFileDialog	fileDialog(TRUE, _T("fx"), NULL, OFN_PATHMUSTEXIST,
							   _T("DSP Builder Files (.fx)|*.fx|All Files (*.*)|*.*||"));
		if(fileDialog.DoModal() != IDOK)
			return FALSE;
		filename = fileDialog.GetPathName();
	}

	// If this is the same file, turn off changes made to prevent a save
	if(filename == m_filename)
		m_bChangesMade = FALSE;

	// Open the file
	if(!file.Open(filename, CFile::modeRead | CFile::typeBinary))
	{
		string.Format(_T("Unable to open file: %s"), (LPCTSTR)filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}

	// Read the header
	if(file.Read(header, 10) != 10)
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}
	header[10]	= '\0';
	string		= header;
	if(string != "DSPBUILDER")
	{
		string.Format(_T("File %s is not a valid DSP file"), (LPCTSTR)filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}

	// Read the version
	if(file.Read(&b, sizeof(b)) != sizeof(b))
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}

	// Old Version? give warning
	if((b == 1) || (b == 3))
	{
		if(AfxMessageBox(_T("You are attempting to load an older file version.\n"
						    "When you save the file, it will be saved in the new format."),
						 MB_OKCANCEL | MB_ICONINFORMATION | MB_APPLMODAL) == IDCANCEL)
			return FALSE;
	}
	else if(b == 2)
	{
		if(AfxMessageBox(_T("You are attempting to load an older file version.\n"
						    "When you save the file, it will be saved in the new format.\n"
						    "You will also need to rebuild the image before transmitting."), 
						 MB_OKCANCEL | MB_ICONINFORMATION | MB_APPLMODAL) == IDCANCEL)
			return FALSE;
	}

	New(FALSE);
	m_filename = filename;

	switch(b)
	{
	case 1:
		if(!ReadVersion1(file))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			New(FALSE);
			return FALSE;
		}
		break;
	case 2:
		if(!ReadVersion2or3or4(file, b))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			New(FALSE);
			return FALSE;
		}
		m_bChangesMade = TRUE;
		break;
	case 3:
	case 4:
		if(!ReadVersion2or3or4(file, b))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			New(FALSE);
			return FALSE;
		}
		break;
	default:
		string.Format(_T("Unsupported DSP file version: %s"), (LPCTSTR)filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}

	file.Close();
	SetTitle();

	// Update the used mixbin info
	SetInUse();

	// See if the .ini .bin and .h files exist
	m_bImageSaved = FALSE;
	if(file.Open(GetBinFilename(), CFile::modeRead))
	{
		if(file.GetLength() != 0)
		{
			file.Close();
			if(file.Open(GetIniFilename(), CFile::modeRead))
			{
				if(file.GetLength() != 0)
				{
					file.Close();
					if(file.Open(GetHFilename(), CFile::modeRead))
					{
						if(file.GetLength() != 0)
							m_bImageSaved = TRUE;
						file.Close();
					}
				}
				else
					file.Close();
			}
		}
		else
			file.Close();
	}

	m_pParent->UpdateScrollBars();
	ValidateGraph();
	Draw(m_rect);
	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::GetDSPCycles
//------------------------------------------------------------------------------
int 
CGraph::GetDSPCycles(void) const
/*++

Routine Description:

	Returns the total DSP cycles

Arguments:

	None

Return Value:

	Total DSP Cycles

--*/
{
	int	i;
	int	total = 0;

	for(i=0; i<m_modules.GetSize(); ++i)
		total += m_modules[i]->GetDSPCycles();

	// Adjust for the addition of an i3dl2 reverb
	if(m_i3dl2Config.GetLength() && m_pI3DL2_24K)
		total += m_pI3DL2_24K->GetDSPCycles();

	// Adjust for the addition of XTalk
	if(m_bIncludeXtalk && m_pXTalk)
		total += m_pXTalk->GetDSPCycles();

	// Adjust for the addition of the Patch XTalk to LFE
	if(m_bPatchXtalkToLFE && m_p2x1Mixer)
		total += m_p2x1Mixer->GetDSPCycles() * 2;

	return total;
}

//------------------------------------------------------------------------------
//	CGraph::GetYMemSize
//------------------------------------------------------------------------------
int 
CGraph::GetYMemSize(void) const
/*++

Routine Description:

	Returns the total Y Mem size

Arguments:

	None

Return Value:

	Total Y Mem size

--*/
{
	int	i;
	int	total = 0;

	for(i=0; i<m_modules.GetSize(); ++i)
		total += m_modules[i]->GetYMemSize();
	return total;
}

//------------------------------------------------------------------------------
//	CGraph::GetScratchLength
//------------------------------------------------------------------------------
int 
CGraph::GetScratchLength(void) const
/*++

Routine Description:

	Returns the total Scratch length

Arguments:

	None

Return Value:

	Total Scratch length

--*/
{
	int	i;
	int	total = 0;

	for(i=0; i<m_modules.GetSize(); ++i)
		total += m_modules[i]->GetScratchLength();
	return total;
}

//------------------------------------------------------------------------------
//	CGraph::GetDSPCyclesPercent
//------------------------------------------------------------------------------
float 
CGraph::GetDSPCyclesPercent(void) const
/*++

Routine Description:

	Returns the dsp cycles as a percent of max

Arguments:

	None

Return Value:

	Percent of dsp cycles used

--*/
{
	return (float(GetDSPCycles()) / float(DSP_MAXCYCLES_AVAILABLE));
}

//------------------------------------------------------------------------------
//	CGraph::GetYMemSizePercent
//------------------------------------------------------------------------------
float 
CGraph::GetYMemSizePercent(void) const
/*++

Routine Description:

	Returns the y mem size as a percent of max

Arguments:

	None

Return Value:

	Percent of y mem size used

--*/
{
	return (float(GetYMemSize()) / float(DSP_YMEMORY_SIZE));
}

#if 0
//------------------------------------------------------------------------------
//	CGraph::GetScratchLengthPercent
//------------------------------------------------------------------------------
float 
CGraph::GetScratchLengthPercent(void) const
/*++

Routine Description:

	Returns the scratch length as a percent of max

Arguments:

	None

Return Value:

	Percent of scratch length used

--*/
{
	return (float(GetScratchLength()) / float(...));
}
#endif

//------------------------------------------------------------------------------
//	CGraph::ReadString
//------------------------------------------------------------------------------
BOOL 
CGraph::ReadString(
				   IN CFile&	file, 
				   OUT CString&	string
				   )
/*++

Routine Description:

	Reads a string from a file

Arguments:

	IN file -		File to read from
	OUT string -	String read

Return Value:

	TRUE on success, FALSE on failure

--*/
{
	int		i;
	BOOL	ret = TRUE;
	TCHAR	buffer[1024];

	for(i=0; ret && i<1024; ++i)
	{
		ret = (file.Read(&buffer[i], sizeof(TCHAR)) == sizeof(TCHAR));
		if(buffer[i] == '\0')
			break;
	}
	if(ret)
		string = buffer;
	return ret;
}
	
//------------------------------------------------------------------------------
//	CGraph::ShortestPath
//------------------------------------------------------------------------------
void 
CGraph::ShortestPath(
					 IN const CJack*						pA, 
					 IN const CJack*						pB, 
					 OUT CArray<CPatchCord*, CPatchCord*>&	path
					 )
/*++

Routine Description:

	Generates the shortest path between pA and pB

Arguments:

	IN pA -		Jack A
	IN pB -		Jack B
	OUT path -	Path between the two (this will include the patch cords of
				pA and pB)

Return Value:

	None

--*/
{
#if 0
	int									i;
	CArray<CPatchCord*, CPatchCord*>	patchCords;

	// Generate the connection array
	pA->GetPatchCord()->GetPatchCords(patchCords);

	// Quick sanity check - make sure pB is in the list
	for(i=0; i<patchCords.GetSize(); ++i)
	{
		if(patchCords[i] == pB->GetPatchCord())
			break;
	}
	if(i == patchCords.GetSize())
		return;

#endif

	// TODO:

#if 0
struct Vert;
struct Node 
{ 
	Vert*	pVert;
	Node*	pNext;
};
struct Vert
{
	char	c;
	Node*	pNode;
	BOOL	bInTree;
};
struct TreeNode
{
	char		c;
	Vert*		pVert;
	TreeNode*	pNext;
	TreeNode*	pChild;
	TreeNode*	pParent;
};
struct QueueNode
{
	TreeNode*	pNode;
	QueueNode*	pNext;
};

static QueueNode*	queue			= NULL;
static QueueNode*	queueIn			= NULL;
static QueueNode*	queueOut		= NULL;
static int index(char c)
{
	return c - 'A';
}
static void queueinit(void)
{
	QueueNode*	pNode;
	QueueNode*	pFirst = NULL;
	int		i;
	for(i=0; i<1024; ++i)
	{
		pNode			= new QueueNode;
		pNode->pNext	= queue;
		if(pFirst == NULL)
			pFirst = pNode;
		queue = pNode;
	}
	pFirst->pNext	= queue;
	queueIn			= queue;
	queueOut		= queue;
}
static BOOL queueempty(void)
{
	return (queueIn == queueOut) ? TRUE : FALSE;
}
static void put(TreeNode* pTreeNode)
{
	queueIn->pNode	= pTreeNode;
	queueIn			= queueIn->pNext;
}
static TreeNode* get(void)
{
	TreeNode* pNode = queueOut->pNode;
	queueOut = queueOut->pNext;
	return pNode;
}

static void BuildTree(void)
{
	int			i;
	int			x;
	int			y;
	Node*		pNode;
	Vert*		pVerts;
	TreeNode*	pTree;
	TreeNode*	pTreeNode;
	TreeNode*	pChildTreeNode;
	char		charEdges[]	= "FAAGABACLMJMJLJKEDFDHIFEGEDHDIEH";
	char		charVerts[]	= "ABCDEFGHIJKLM";
	int			numVerts	= sizeof(charVerts) - 1;//strlen(charVerts);
	int			numEdges	= (sizeof(charEdges)-1) / 2;

	pVerts = new Vert [numVerts];
	for(i=0; i<numVerts; ++i)
	{
		pVerts[i].c			= charVerts[i];
		pVerts[i].pNode		= NULL;
		pVerts[i].bInTree	= FALSE;
	}

	for(i=0; i<numEdges; ++i)
	{
		x	= index(charEdges[i*2]);
		y	= index(charEdges[i*2+1]);

		pNode			= new Node;
		pNode->pVert	= &pVerts[x];
		pNode->pNext	= pVerts[y].pNode;
		pVerts[y].pNode	= pNode;

		pNode			= new Node;
		pNode->pVert	= &pVerts[y];
		pNode->pNext	= pVerts[x].pNode;
		pVerts[x].pNode	= pNode;
	}

	queueinit();

	pTreeNode					= new TreeNode;
	pTreeNode->c				= pVerts[0].c;
	pTreeNode->pVert			= &pVerts[0];
	pTreeNode->pNext			= NULL;
	pTreeNode->pChild			= NULL;
	pTreeNode->pParent			= NULL;
	pTreeNode->pVert->bInTree	= TRUE;
	pTree						= pTreeNode;
	put(pTreeNode);
	while(!queueempty())
	{
		pTreeNode = get();
		for(pNode=pTreeNode->pVert->pNode; pNode; pNode=pNode->pNext)
		{
			if(!pNode->pVert->bInTree)
			{
				pChildTreeNode					= new TreeNode;
				pChildTreeNode->c				= pNode->pVert->c;
				pChildTreeNode->pChild			= NULL;
				pChildTreeNode->pNext			= pTreeNode->pChild;
				pChildTreeNode->pParent			= pTreeNode;
				pChildTreeNode->pVert			= pNode->pVert;
				pChildTreeNode->pVert->bInTree	= TRUE;
				pTreeNode->pChild				= pChildTreeNode;
				put(pChildTreeNode);
			}
		}
	}
}
#endif
}

//------------------------------------------------------------------------------
//	CGraph::GetIniFilename
//------------------------------------------------------------------------------
LPCTSTR 
CGraph::GetIniFilename(void) const
/*++

Routine Description:

	Returns the ini filename

Arguments:

	None

Return Value:

	The ini filename if a dsp file exists, An empty string otherwuise

--*/
{
	static CString	filename;
	int				index;

	filename	= (LPCTSTR)m_filename;
	index		= filename.ReverseFind('.');
	if(index != -1)
		filename.Delete(index, filename.GetLength()-index);
	filename += _T(".ini");

	return (LPCTSTR)filename;
}

//------------------------------------------------------------------------------
//	CGraph::SaveImage
//------------------------------------------------------------------------------
BOOL 
CGraph::SaveImage(void)
/*++

Routine Description:

	Saves the grid as a dsp image.

Arguments:

	Nothing

Return Value:

	TRUE on success, FALSE on failure

--*/
{
	if(IsGraphValid())
	{
		if(!strcmp(GetIniFilename(), _T(".ini")))
		{
			if(!Save(NULL))
				return FALSE;
		}
		return BuildEffectChains(GetIniFilename());
	}

	AfxMessageBox(_T("The grid is invalid and cannot be saved as a DSP Image."), 
				  MB_OK | MB_ICONERROR | MB_APPLMODAL);
	return FALSE;
}

//------------------------------------------------------------------------------
//	CGraph::IsGraphValid
//------------------------------------------------------------------------------
BOOL 
CGraph::IsGraphValid(void)
/*++

Routine Description:

	Checks to see if the graph if valid. A graph is valid if there are no 
	invalid	patch cords

Arguments:

	None

Return Value:

	TRUE if the graph is valid, FALSE otherwise

--*/
{
	int	i;	

	ValidateGraph();
	for(i=0; i<m_patchCords.GetSize(); ++i)
	{
		if(m_patchCords[i]->IsInvalid())
			return FALSE;
	}

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::MarkPatchCords
//------------------------------------------------------------------------------
void 
CGraph::MarkPatchCords(
					   IN BOOL mark
					   )
/*++

Routine Description:

	Marks all the patch cords

Arguments:

	IN mark -	Mark to use

Return Value:

	None

--*/
{
	int	i;

	for(i=0; i<m_patchCords.GetSize(); ++i)
		m_patchCords[i]->Mark(mark);
}

//------------------------------------------------------------------------------
//	CGraph::GetBinFilename
//------------------------------------------------------------------------------
LPCTSTR 
CGraph::GetBinFilename(void) const
/*++

Routine Description:

	Returns the bin filename

Arguments:

	None

Return Value:

	The bin filename if a dsp file exists, An empty string otherwuise

--*/
{
	static CString	filename;
	int				index;

	filename	= (LPCTSTR)m_filename;
	index		= filename.ReverseFind('.');
	if(index != -1)
		filename.Delete(index, filename.GetLength()-index);
	filename += _T(".bin");

	return (LPCTSTR)filename;
}

//------------------------------------------------------------------------------
//	CGraph::GetHFilename
//------------------------------------------------------------------------------
LPCTSTR 
CGraph::GetHFilename(void) const
/*++

Routine Description:

	Returns the header filename

Arguments:

	None

Return Value:

	The header filename if a dsp file exists, An empty string otherwuise

--*/
{
	static CString	filename;
	int				index;

	filename	= (LPCTSTR)m_filename;
	index		= filename.ReverseFind('.');
	if(index != -1)
		filename.Delete(index, filename.GetLength()-index);
	filename += _T(".h");

	return (LPCTSTR)filename;
}

//------------------------------------------------------------------------------
//	CGraph::SetModuleIndex
//------------------------------------------------------------------------------
void 
CGraph::SetModuleIndex(
					   IN LPCTSTR	pIniName, 
					   IN DWORD		index
					   )
/*++

Routine Description:

	Sets the effect index for a module

Arguments:

	IN pIniName -	Ini name of effect (unique)
	IN index -		Index to set

Return Value:

	None

--*/
{
	int	m;

	for(m=0; m<m_modules.GetSize(); ++m)
	{
		if(!strcmp(m_modules[m]->GetIniName(), pIniName))
		{
			m_modules[m]->SetIndex(index);
			return;
		}
	}
}

//------------------------------------------------------------------------------
//	CGraph::TransmitModuleParameters
//------------------------------------------------------------------------------
void 
CGraph::TransmitModuleParameters(
								 IN const CModule*	pModule,
								 IN int				index	// = -1
								 ) const 
/*++

Routine Description:

	Transmits a module's parameters to the Xbox

Arguments:

	IN pModule -	Module whose parameters will be transmitted
	IN index -		Effect index to transmit (-1 for all)

Return Value:

	None

--*/
{
	m_pParent->TransmitModuleParameters(pModule, index); 
}

//------------------------------------------------------------------------------
//	CGraph::GetPatchCordFromId
//------------------------------------------------------------------------------
CPatchCord* 
CGraph::GetPatchCordFromId(
						   IN DWORD id
						   ) const
/*++

Routine Description:

	Returns a pointer to a patch cord from its id

Arguments:

	IN id -	Id of patch cord

Return Value:

	Pointer to the patch cord (or NULL)

--*/
{
	int	i;
	int	ii;

	// Check for normal patches
	for(i=0; i<m_patchCords.GetSize(); ++i)
	{
		if(m_patchCords[i]->GetId() == id)
			return m_patchCords[i];
	}

	// Check jacks on modules
	for(i=0; i<m_modules.GetSize(); ++i)
	{
		for(ii=0; ii<m_modules[i]->GetInputs().GetSize(); ++ii)
		{
			if(id == m_modules[i]->GetInputs()[ii]->GetOwnPatchCord()->GetId())
				return m_modules[i]->GetInputs()[ii]->GetOwnPatchCord();
		}
		for(ii=0; ii<m_modules[i]->GetOutputs().GetSize(); ++ii)
		{
			if(id == m_modules[i]->GetOutputs()[ii]->GetOwnPatchCord()->GetId())
				return m_modules[i]->GetOutputs()[ii]->GetOwnPatchCord();
		}
	}

	return NULL;
}

//------------------------------------------------------------------------------
//	CGraph::GetModuleFromId
//------------------------------------------------------------------------------
CModule* 
CGraph::GetModuleFromId(
						IN DWORD id
						) const
/*++

Routine Description:

	Returns a pointer to a module from its id

Arguments:

	IN id -	Id of module

Return Value:

	Pointer to the module (or NULL)

--*/
{
	int	i;

	for(i=0; i<m_modules.GetSize(); ++i)
	{
		if(m_modules[i]->GetId() == id)
			return m_modules[i];
	}

	return NULL;
}

//------------------------------------------------------------------------------
//	CGraph::GetJackFromId
//------------------------------------------------------------------------------
CJack* 
CGraph::GetJackFromId(
					  IN DWORD id
					  ) const
/*++

Routine Description:

	Returns a pointer to a jack from its id

Arguments:

	IN id -	Id of jack 

Return Value:

	Pointer to the jack (or NULL)

--*/
{
	int	m;
	int	i;

	for(m=0; m<m_modules.GetSize(); ++m)
	{
		for(i=0; i<m_modules[m]->GetInputs().GetSize(); ++i)
		{
			if(m_modules[m]->GetInputs()[i]->GetId() == id)
				return m_modules[m]->GetInputs()[i];
		}
		for(i=0; i<m_modules[m]->GetOutputs().GetSize(); ++i)
		{
			if(m_modules[m]->GetOutputs()[i]->GetId() == id)
				return m_modules[m]->GetOutputs()[i];
		}
	}

	return NULL;
}

//------------------------------------------------------------------------------
//	CGraph::LoadEffects
//------------------------------------------------------------------------------
BOOL
CGraph::LoadEffects(void)
/*++

Routine Description:

	Loads all effects defined by ".ini" files in the ENV_VAR_INI_PATH directory

Arguments:

	None

Return Value:

	TRUE on success, FALSE otherwise

--*/
{
	CString			pathName;
	HANDLE			fileHandle;
	WIN32_FIND_DATA	findData;
	CHAR*			lpResult;
	CString			name;
	CString			string;
	int				i;
	int				j;
	int				dspCycles;
	int				yMemSize;
	int				scratchLength;
	int				numInputs;
	int				numOutputs;
	CString			dspCode;
	CStringArray	inputs;
	CStringArray	outputs;
	CString			config;
	CStringArray	nameList;
	CStringArray	dspCodeList;
	BOOL			bConfig;
	CModule*		pModule;
	CModule*		pTemp;
	
	// Clear the effects list
	ClearEffects();

	// Find all "*.ini" files in the ini directory
	pathName.Format(_T("%s\\*.ini"), (LPCTSTR)m_iniPath);
	fileHandle = FindFirstFile(pathName, &findData);
	if(fileHandle != INVALID_HANDLE_VALUE)
	{
		// Memory for GetPrivateProfileSection() and GetPrivateProfileString
		lpResult = new CHAR [SECTION_MAX_SIZE];

		// Loop through all the files
		do
		{
			// Full filename
			pathName.Format(_T("%s\\%s"), (LPCTSTR)m_iniPath, 
							findData.cFileName);

			// First pass to see if this is a valid file is to check 
			// for the fstate section
			if(GetPrivateProfileSection(FXSTATE_SECTION_NAME, lpResult, 
										SECTION_MAX_SIZE, pathName) == 0)
				continue;

			// Name
			GetPrivateProfileString(FXSTATE_SECTION_NAME, FXSTATE_EFFECT_NAME,
								    _T("<Unknown Effect>"), lpResult, 
									SECTION_MAX_SIZE, pathName);
			name = lpResult;

			// DSP Code
			GetPrivateProfileString(FXSTATE_SECTION_NAME, FXPARAM_DSPCODE_NAME,
								    _T("<dspFilename>"), lpResult, SECTION_MAX_SIZE, 
								    pathName);
			dspCode = lpResult;

			// Has this effect been loaded before?
			for(bConfig=FALSE, i=0; !bConfig && i<nameList.GetSize(); ++i)
			{
				if((nameList[i] == name) && (dspCodeList[i] == dspCode))
					bConfig = TRUE;
			}

			// Configuration
			GetPrivateProfileString(FXSTATE_SECTION_NAME, FX_CONFIG_NAME,
								    _T(""), lpResult, SECTION_MAX_SIZE, 
								    pathName);
			config = lpResult;

			// DSP Cycles
			dspCycles = (int)GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
												  FXPARAM_DSPCYCLES_NAME,
												  0, pathName);

			// Y mem size
			yMemSize = (int)GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
											     FXPARAM_YMEMORY_SIZE,
												 0, pathName);
			
			// Scratch size
			scratchLength = (int)GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
													  FXPARAM_SCRATCH_LENGTH,
													  0, pathName);

			// Num Inputs & Outputs (special case for i3dl2 reverb
			if((name == _T("I3DL2 Reverb")) || (name == _T("I3DL2 24K Reverb")))
			{
				numInputs	= 2;
				numOutputs	= 4;
			}
			else if(name == _T("Simple Reverb"))
			{
				numInputs	= 1;
				numOutputs	= 4;
			}
			else
			{
				numInputs = (int)GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
													  FXPARAM_NUMINPUTS_NAME,
													  0, pathName);
				numOutputs = (int)GetPrivateProfileInt(FXSTATE_SECTION_NAME, 
													   FXPARAM_NUMOUTPUTS_NAME,
													   0, pathName);
			}
			inputs.SetSize(numInputs);
			outputs.SetSize(numOutputs);

			// Inputs
			for(i=0; i<numInputs; ++i)
			{
				string.Format(_T("FX_INPUT%d_NAME"), i);
				GetPrivateProfileString(FXSTATE_SECTION_NAME, string,
										_T("In"), lpResult, SECTION_MAX_SIZE, 
										pathName);
				inputs[i] = lpResult;
			}

			// Outputs
			for(i=0; i<numOutputs; ++i)
			{
				string.Format(_T("FX_OUTPUT%d_NAME"), i);
				GetPrivateProfileString(FXSTATE_SECTION_NAME, string,
										_T("Out"), lpResult, SECTION_MAX_SIZE, 
										pathName);
				outputs[i] = lpResult;
			}

			// If this is just another config, add the config to the effect
			if(bConfig)
			{
				if(config != _T(""))
				{
					// Find the effect
					for(i=0; i<m_effects.GetSize(); ++i)
					{
						if((m_effects[i]->GetEffectName() == name) &&
						   (m_effects[i]->GetDSPCode() == dspCode))
						{
							// Add the configuration
							m_effects[i]->AddConfiguration(config, findData.cFileName);
							break;
						}
					}
				}
			}

			// Otherwise, create a new effect if it has ins and outs
			else if((numInputs > 0) || (numOutputs > 0))
			{
				// Add the effect to the list
				nameList.Add((LPCTSTR)name);
				dspCodeList.Add((LPCTSTR)dspCode);

				// Create the module
				pModule = new CModule(this, CModule::EFFECT, 
									  CModule::COLOR_EFFECT, name, dspCycles, 
									  yMemSize, scratchLength, dspCode, findData.
									  cFileName, &inputs, &outputs);

				// Set the module parameters
				string.Format(_T("%s\\%s"), m_iniPath, findData.cFileName);
				pModule->SetParameters(m_imageBuilder, string);

				// Add it to the list
				m_effects.Add(pModule);

				// Set the configuration
				if(config != _T(""))
					pModule->AddConfiguration(config, findData.cFileName);

				// Is this an I3DL2 Reverb
				if(name == _T("I3DL2 Reverb"))
					m_pI3DL2 = pModule;
				else if(name == _T("I3DL2 24K Reverb"))
					m_pI3DL2_24K = pModule;

				// Or the mixer
				else if(name == _T("2x1 Mixer"))
					m_p2x1Mixer = pModule;

				// Or crosstalk?
				else if(name.CompareNoCase("xtalk") == 0)
					m_pXTalk = pModule;
			}
		}
		while(FindNextFile(fileHandle, &findData));
		FindClose(fileHandle);

		// Free memory
		delete [] lpResult;

		// Sort the effects list
		for(i=m_effects.GetSize()-1; i>=1; --i)
		{
			for(j=1; j<=i; ++j)
			{
				if(Compare(m_effects[j-1]->GetEffectName(), 
						   m_effects[j]->GetEffectName()) > 0)
				{
					pTemp			= m_effects[j-1];
					m_effects[j-1]	= m_effects[j];
					m_effects[j]	= pTemp;
				}
			}
		}

		// Set all configurations to "default"
		for(i=0; i<m_effects.GetSize(); ++i)
		{
			for(j=0; j<m_effects[i]->GetNumConfigs(); ++j)
			{
				if(!m_effects[i]->GetConfigs()[j].name.CompareNoCase(_T("default")))
				{
					m_effects[i]->SetActiveConfig(j);
					break;
				}
			}
		}

		// Were any effects loaded?
		m_bEffectsLoaded = (m_effects.GetSize() > 0) ? TRUE : FALSE;
	}

	return m_bEffectsLoaded;
}

//------------------------------------------------------------------------------
//	CGraph::ClearEffects
//------------------------------------------------------------------------------
void
CGraph::ClearEffects(void)
/*++

Routine Description:

	Clears all effects

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	// Effects
	for(i=0; i<m_effects.GetSize(); ++i)
		delete m_effects[i];
	m_effects.RemoveAll();

	// Set the effects loaded flag
	m_bEffectsLoaded = FALSE;

	// Reset some pointers
	m_pXTalk		= NULL;
	m_pI3DL2		= NULL;
	m_pI3DL2_24K	= NULL;
	m_p2x1Mixer		= NULL;
}

//------------------------------------------------------------------------------
//	CGraph::CreateMixbins
//------------------------------------------------------------------------------
void
CGraph::CreateMixbins(void)
/*++

Routine Description:

	Creates all the mixbins

Arguments:

	None

Return Value:

	None

--*/
{
	int					i;
	CStringArray		strings;
	CModule*			pModule;
	CModule::ColorFlag	colorFlag;
	LPCTSTR				mixbins[] =		// These must remain in the same order
	{									// If their order changes, InsertModule()
		_T("Speaker: Front Left"),		// must be updated
		_T("Speaker: Front Right"),
		_T("Speaker: Center"),
		_T("Speaker: LFE"),
		_T("Speaker: Back Left"),
		_T("Speaker: Back Right"),
		_T("XTalk: Front Left"),
		_T("XTalk: Front Right"),
		_T("XTalk: Back Left"),
		_T("XTalk: Back Right"),
		_T("I3DL2 Send"),
		_T("FX Send 0"),
		_T("FX Send 1"),
		_T("FX Send 2"),
		_T("FX Send 3"),
		_T("FX Send 4"),
		_T("FX Send 5"),
		_T("FX Send 6"),
		_T("FX Send 7"),
		_T("FX Send 8"),
		_T("FX Send 9"),
		_T("FX Send 10"),
		_T("FX Send 11"),
		_T("FX Send 12"),
		_T("FX Send 13"),
		_T("FX Send 14"),
		_T("FX Send 15"),
		_T("FX Send 16"),
		_T("FX Send 17"),
		_T("FX Send 18"),
		_T("FX Send 19")
	};

	// Clear the lists
	ClearMixbins();

	// Create the Input Mixbins
	strings.Add(CString(_T("Out")));
	for(i=0; i<(int)(sizeof(mixbins) / sizeof(mixbins[0])); ++i)
	{
		if(i <= 5)
			colorFlag = CModule::COLOR_SPEAKER;
		else if(i <= 9)
			colorFlag = CModule::COLOR_XTALK;
		else if(i == 10)
			colorFlag = CModule::COLOR_I3DL2;
		else
			colorFlag = CModule::COLOR_FXSEND;
		pModule = new CModule(this, CModule::INPUT_MIXBIN, colorFlag, 
							  mixbins[i], 0, 0, 0, NULL, NULL, NULL, &strings);
		m_inputMixbins.Add(pModule);
		m_inputMixbinInUse.Add(FALSE);
		pModule->SetMixbin(i);
	}

	// Create the Output Mixbins
	strings[0] = _T("In");
	for(i=0; i<(int)(sizeof(mixbins) / sizeof(mixbins[0])); ++i)
	{
		if(i <= 5)
			colorFlag = CModule::COLOR_SPEAKER;
		else if(i <= 9)
			colorFlag = CModule::COLOR_XTALK;
		else if(i == 10)
			colorFlag = CModule::COLOR_I3DL2;
		else
			colorFlag = CModule::COLOR_FXSEND;
		pModule = new CModule(this, CModule::OUTPUT_MIXBIN, colorFlag, 
							  mixbins[i], 0, 0, 0, NULL, NULL, &strings, NULL);
		m_outputMixbins.Add(pModule);
		m_outputMixbinInUse.Add(FALSE);
		pModule->SetMixbin(i);
	}
}

//------------------------------------------------------------------------------
//	CGraph::ClearMixbins
//------------------------------------------------------------------------------
void
CGraph::ClearMixbins(void)
/*++

Routine Description:

	Clears all mixbins

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	// Input mixbins
	for(i=0; i<m_inputMixbins.GetSize(); ++i)
		delete m_inputMixbins[i];
	m_inputMixbins.RemoveAll();

	// Output mixbins
	for(i=0; i<m_outputMixbins.GetSize(); ++i)
		delete m_outputMixbins[i];
	m_outputMixbins.RemoveAll();

	// In Use flags
	m_inputMixbinInUse.RemoveAll();
	m_outputMixbinInUse.RemoveAll();
}

//------------------------------------------------------------------------------
//	CGraph::SetPaths
//------------------------------------------------------------------------------
void
CGraph::SetPaths(void)
/*++

Routine Description:

	Sets the paths for the effects state files

Arguments:

	None

Return Value:

	None

--*/
{
	TCHAR	buffer[1024];
	HKEY	hKey;
	DWORD	type;
	DWORD	size;

	// First try the registry
	if(RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Microsoft\\dspbuilder"), 
					  0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
	{
		// INI Path
		size = sizeof(buffer);
		if(RegQueryValueEx(hKey, _T("iniPath"), NULL, &type,
						   (unsigned char*)buffer, &size) == ERROR_SUCCESS)
		{
			m_iniPath = buffer;
		}

		// DSP Code Path
		size = sizeof(buffer);
		if(RegQueryValueEx(hKey, _T("dspCodePath"), NULL, &type,
						   (unsigned char*)buffer, &size) == ERROR_SUCCESS)
		{
			m_dspCodePath = buffer;
		}
		RegCloseKey(hKey);
	}
			
	// Then try environment variables
	if(m_iniPath.IsEmpty() && 
	   (GetEnvironmentVariable("_XGPIMAGE_INI_PATH", buffer, 
							   sizeof(buffer) / sizeof(buffer[0])) != 0))
	{
		m_iniPath = buffer;
	}
	if(m_dspCodePath.IsEmpty() && 
	   (GetEnvironmentVariable("_XGPIMAGE_DSP_CODE_PATH", buffer, 
							   sizeof(buffer) / sizeof(buffer[0])) != 0))
	{
		m_dspCodePath = buffer;
	}

	// Then try XDK install path
	if(m_iniPath.IsEmpty())
	{
		if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\XboxSDK\\", 
						0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
		{
			size = sizeof(buffer);
			if(RegQueryValueEx(hKey, _T("InstallPath"), NULL, &type,
							   (unsigned char*)buffer, 
							   &size) == ERROR_SUCCESS)
			{
				m_iniPath	= buffer;
				m_iniPath	+= "\\source\\dsound\\dsp\\ini";
			}
			RegCloseKey(hKey);
		}
	}
	if(m_dspCodePath.IsEmpty())
	{
		if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\XboxSDK\\", 
						0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
		{
			size = sizeof(buffer);
			if(RegQueryValueEx(hKey, _T("InstallPath"), NULL, &type,
							   (unsigned char*)buffer, 
							   &size) == ERROR_SUCCESS)
			{
				m_dspCodePath	= buffer;
				m_dspCodePath	+= "\\source\\dsound\\dsp\\bin";
			}
			RegCloseKey(hKey);
		}
	}

	// Now just use the current directory
	if(m_iniPath.IsEmpty() && 
	   (GetCurrentDirectory(sizeof(buffer) / sizeof(buffer[0]), buffer) != 0))
	{
		m_iniPath = buffer;
	}
	if(m_dspCodePath.IsEmpty() && 
	   (GetCurrentDirectory(sizeof(buffer) / sizeof(buffer[0]), buffer) != 0))
	{
		m_dspCodePath = buffer;
	}
}

//------------------------------------------------------------------------------
//	CGraph::Compare
//------------------------------------------------------------------------------
int
CGraph::Compare(
			   IN LPCTSTR	pString1,
			   IN LPCTSTR	pString2
			   ) const
/*++

Routine Description:

	Does a case insenstive compare of two strings

Arguments:

	IN pString1 -	String 1
	IN pString2 -	String 2

Return Value:

	< 0	if pString1 < pString2
	0	if pString1 > pString2
	> 0	if pString1 < pString2


--*/
{
	CString	string1 = pString1;
	return string1.CompareNoCase(pString2);
}

//------------------------------------------------------------------------------
//	CGraph::InsertModule
//------------------------------------------------------------------------------
void
CGraph::InsertModule(
					 IN const CPoint&	point,
					 IN int				index
					 )
/*++

Routine Description:

	Inserts a module into the grid

Arguments:

	IN index -	Index of effect

Return Value:

	None

--*/
{
	CModule*					pModule;
	int							i;
	CPoint						upperLeft;
	CArray<CModule*, CModule*&>	insert;
	CModule::State				state	= CModule::OK;
	int							dy		= m_bSnapToGrid ? SCALE : 3;

	// Make sure the move modules list is clear
	m_moveModules.RemoveAll();

	// Flag to begin insert mode
	m_bInsertModules	= TRUE;
	m_bUseOffset		= FALSE;

	// Save the mouse location
	SetMouse(point);

	// Input mixbin?
	if(index & INPUT_MIXBIN_MASK)
	{
		index ^= INPUT_MIXBIN_MASK;

		switch(index)
		{
		case 0:		// All speakers
			for(i=0; i<=5; ++i)
				insert.Add(m_inputMixbins[i]);
			break;
		case 1:	// Front & Rear speakers
			insert.Add(m_inputMixbins[0]);
			insert.Add(m_inputMixbins[1]);
			insert.Add(m_inputMixbins[4]);
			insert.Add(m_inputMixbins[5]);
			break;

		case 2:		// Front speakers
			insert.Add(m_inputMixbins[0]);
			insert.Add(m_inputMixbins[1]);
			break;
		case 3:		// Rear speakers
			insert.Add(m_inputMixbins[4]);
			insert.Add(m_inputMixbins[5]);
			break;
		case 4:		// Front Left
		case 5:		// Front Right
		case 6:		// Center
		case 7:		// LFE
		case 8:		// Back Left
		case 9:		// Back Right
			insert.Add(m_inputMixbins[index-4]);
			break;
		case 10:	// All Xtalk
			for(i=6; i<=9; ++i)
				insert.Add(m_inputMixbins[i]);
			break;
		case 11:	// XTalk Front Left
		case 12:	// XTalk Front Right
		case 13:	// XTalk Back Left
		case 14:	// XTalk Back Right
			insert.Add(m_inputMixbins[index-5]);
			break;
		case 15:	// I3DL2
			insert.Add(m_inputMixbins[10]);
			break;
		default:	// FX Sends
			insert.Add(m_inputMixbins[index-5]);
			break;
		}
	}

	// Output mixbin?
	else if(index & OUTPUT_MIXBIN_MASK)
	{
		index ^= OUTPUT_MIXBIN_MASK;

		switch(index)
		{
		case 0:		// All speakers
			for(i=0; i<=5; ++i)
				insert.Add(m_outputMixbins[i]);
			break;
		case 1:		// Front & Rear speakers
			insert.Add(m_outputMixbins[0]);
			insert.Add(m_outputMixbins[1]);
			insert.Add(m_outputMixbins[4]);
			insert.Add(m_outputMixbins[5]);
			break;
		case 2:		// Front speakers
			insert.Add(m_outputMixbins[0]);
			insert.Add(m_outputMixbins[1]);
			break;
		case 3:		// Rear speakers
			insert.Add(m_outputMixbins[4]);
			insert.Add(m_outputMixbins[5]);
			break;
		case 4:		// Front Left
		case 5:		// Front Right
		case 6:		// Center
		case 7:		// LFE
		case 8:		// Back Left
		case 9:		// Back Right
			insert.Add(m_outputMixbins[index-4]);
			break;
		case 10:		// All Xtalk
			for(i=6; i<=9; ++i)
				insert.Add(m_outputMixbins[i]);
			break;
		case 11:	// XTalk Front Left
		case 12:	// XTalk Front Right
		case 13:	// XTalk Back Left
		case 14:	// XTalk Back Right
			insert.Add(m_outputMixbins[index-5]);
			break;
		case 15:	// I3DL2
			insert.Add(m_outputMixbins[10]);
			break;
		default:	// FX Sends
			insert.Add(m_outputMixbins[index-5]);
			break;
		}
	}

	// Or just an effect?
	else
	{
		if((index > 0) && (index <= m_effects.GetSize()))
			insert.Add(m_effects[index-1]);
	}

	// Any modules to insert?
	if(insert.GetSize() == 0)
		return;

	// First module to add
	pModule = new CModule(*insert[0]);

	// Upper left will be based on the first module
	CalcUpperLeft(pModule);
	upperLeft = m_upperLeft;

	// Set it's position and state
	pModule->Move(m_upperLeft);
	state = IsPlacementValid(pModule) ? state : CModule::INVALID;

	// Put the module in the move list
	m_moveModules.Add(pModule);

	// Now add all the speaker mixbins
	for(i=1; i<insert.GetSize(); ++i)
	{
		// Adjust the position
		upperLeft.y += pModule->GetRect().Height() + dy;

		// First module will be front left speaker
		pModule = new CModule(*insert[i]);

		// Set it's position and state
		pModule->Move(upperLeft);
		state = IsPlacementValid(pModule) ? state : CModule::INVALID;

		// Put the module in the move list
		m_moveModules.Add(pModule);
	}

	// Set the state of all modules
	for(i=0; i<m_moveModules.GetSize(); ++i)
		m_moveModules[i]->SetState(state);

	m_bChangesMade = TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::DeleteModule
//------------------------------------------------------------------------------
void 
CGraph::DeleteModule(
					 IN CModule* pModule
					 )
/*++

Routine Description:

	Deletes a module from the modules list and redraws the exposed region

Arguments:

	IN pModule -	Module to delete

ReturnValue:

	None

--*/
{
	int		i;
	
	// Remove the module from the list
	for(i=0; i<m_modules.GetSize(); ++i)
	{
		if(m_modules[i] == pModule)
		{
			m_modules.RemoveAt(i);
			Draw(pModule->GetRect());
			break;
		}
	}

	// Is this an input mixbin?
	if(pModule->GetType() == CModule::INPUT_MIXBIN)
		m_inputMixbinInUse[pModule->GetMixbin()] = FALSE;

	// Or an output mixbin
	else if(pModule->GetType() == CModule::OUTPUT_MIXBIN)
		m_outputMixbinInUse[pModule->GetMixbin()] = FALSE;

	// This delete will force redraws of the removed patch cords
	delete pModule;

	m_bChangesMade = TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::SetMouse
//------------------------------------------------------------------------------
void 
CGraph::SetMouse(
				 IN const CPoint&	point
				 )
/*++

Routine Description:

	Sets a valid mouse location based on a scrolled display

Arguments:

	IN point -	Window coordinate

ReturnValue:

	None

--*/
{
	m_mouse = point + m_rect.TopLeft();
}

//------------------------------------------------------------------------------
//	CGraph::GetPatchCord
//------------------------------------------------------------------------------
CPatchCord* 
CGraph::GetPatchCord(
					 IN const CPoint&	point
					 ) const
/*++

Routine Description:

	Returns a patch cord at the given point if one exists

Arguments:

	IN point -	Window coordinate

ReturnValue:

	patch cord or NULL

--*/
{
	int	i;

	// First check for an exact hit
	for(i=0; i<m_patchCords.GetSize(); ++i)
	{
		if(m_patchCords[i]->IsPointOnLine(point, 0))
			return m_patchCords[i];
	}

	// Then check for a close hit (within TOLERANCE pixels)
	for(i=0; i<m_patchCords.GetSize(); ++i)
	{
		if(m_patchCords[i]->IsPointOnLine(point, TOLERANCE))
			return m_patchCords[i];
	}

	return NULL;
}

//------------------------------------------------------------------------------
//	CGraph::DrawPatchLine
//------------------------------------------------------------------------------
void
CGraph::DrawPatchLine(void)
/*++

Routine Description:

	Draws a rubberband line representing a new patch cord

Arguments:

	None

Return Value:

	None

--*/
{
	CClientDC	dc(m_pParent);
	CPen*		oldPen;
	int			oldROP;

	// Set the window origin
	dc.SetWindowOrg(m_rect.left, m_rect.top);	

	// Setup
	oldPen	= (CPen*)dc.SelectStockObject(WHITE_PEN);
	oldROP	= dc.SetROP2(R2_XORPEN);

	// Draw
	dc.Polyline(m_patchLine.points.GetData(), m_patchLine.points.GetSize());

	// Restore
	dc.SetROP2(oldROP);
	dc.SelectObject(oldPen);
}


//------------------------------------------------------------------------------
//	CGraph::IsPlacementValid
//------------------------------------------------------------------------------
BOOL 
CGraph::IsPlacementValid(
						 IN const CModule*	pModule,
						 IN const CModule*	pOriginalModule
						 ) const
/*++

Routine Description:

	Determines if the placement of a module is valid. A module that
	will be moved cannot be placed within 3 pixels of any other modules or
	patch cords.

Arguments:

	IN pModule -		Module to test
	IN pOriginalModule -	Original module

ReturnValue:

	TRUE if the module can be placed at the given location, FALSE otherwise

--*/
{
	int		i;
	CRect	rect = pModule->GetRect();
	
	// Generate a bounding rect 3 pixels bigger than its current rect
	rect.InflateRect(3, 3, 3, 3);

	// Is the module within 3 pixels of another module that is not being moved
	for(i=0; i<m_modules.GetSize(); ++i)
	{
		if((m_modules[i]->GetState() != CModule::MOVING) && 
		   IntersectRects(rect, m_modules[i]->GetRect()))
			return FALSE;
	}

	// Is it within 3 pixels of any patch cords that is not connected to it
	for(i=0; i<m_patchCords.GetSize(); ++i)
	{
		// This test is not a bounding box check
		if(m_patchCords[i]->IntersectRect(rect) && 
		   ((pOriginalModule == NULL) || (!m_patchCords[i]->IsPatchedToModule(pOriginalModule))))
		{
			return FALSE;
		}
	}

	// Will the module fit within graph?
	if((pModule->GetRect().left < 0) || (pModule->GetRect().top < 0) ||
	   (pModule->GetRect().right > MAX_SIZE) || 
	   (pModule->GetRect().bottom > MAX_SIZE))
	{
	   return FALSE;
	}

	// Otherwise it's good
	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::IntersectRects
//------------------------------------------------------------------------------
BOOL 
CGraph::IntersectRects(
					   IN const CRect&	rect0,
					   IN const CRect&	rect1
					   ) const
/*++

Routine Description:

	Returns TRUE if the two rectangles intersect

Arguments:

	IN rect0 -	Rect0
	IN rect1 -	Rect1

ReturnValue:

	TRUE if the rectangle intersect, FALSE otherwise

--*/
{
	CRect	rect;

	return rect.IntersectRect(rect0, rect1);
}

//------------------------------------------------------------------------------
//	CGraph::CalcUpperLeft
//------------------------------------------------------------------------------
void
CGraph::CalcUpperLeft(
					  IN const CModule*	pModule
					  )
/*++

Routine Description:

	Given a module and this method calculates the upper left corner of the 
	module using the current mouse position as the center of the module

Arguments:

	IN pModule -	Module

ReturnValue:

	None

--*/
{
	if(m_bUseOffset)
		m_upperLeft = m_mouse - m_offset;
	else
	{
		m_upperLeft.x	= m_mouse.x - (pModule->GetRect().Width() / 2),
		m_upperLeft.y	= m_mouse.y - (pModule->GetRect().Height() / 2);
	}

	if(m_bSnapToGrid)
	{
		m_upperLeft.x = m_upperLeft.x / m_snapSize * m_snapSize;
		m_upperLeft.y = m_upperLeft.y / m_snapSize * m_snapSize;
	}
}

//------------------------------------------------------------------------------
//	CGraph::GetModule
//------------------------------------------------------------------------------
CModule*
CGraph::GetModule(
				  IN const CPoint&	point
				  ) const
/*++

Routine Description:

	Returns the module under the point.

Arguments:

	IN point -	Point

ReturnValue:

	NULL if no module is under the point, otherwise the module

--*/
{
	int		i;
	
	for(i=0; i<m_modules.GetSize(); ++i)
	{
		if(IsPointInRect(point.x, point.y, m_modules[i]->GetRect()))
			return m_modules[i];
	}
	return NULL;
}

//------------------------------------------------------------------------------
//	CGraph::NewPatchCord
//------------------------------------------------------------------------------
CPatchCord*
CGraph::NewPatchCord(void)
/*++

Routine Description:

	Creates a new patch cord from the existing patch line

Arguments:

	None

ReturnValue:

	The new patch cord

--*/
{
	CPatchCord*	pPatchCord;
	CPatchCord*	pSplitPatchCord	= NULL;
	CRect		rect;

	// If a cord is dangling, abort
	if((m_patchLine.firstPatchEnd == CGraph::PATCHEND_NONE) ||
	   (m_patchLine.lastPatchEnd == CGraph::PATCHEND_NONE))
	{
	   return NULL;
	}

	// If the patch cord will be patched at both ends to the same jack, abort
	else if(m_patchLine.pFirstJack && 
		    (m_patchLine.pFirstJack == m_patchLine.pLastJack))
	{
		return NULL;
	}

	// If either end of the patch line is being connected to a jack that
	// is already patched, just abort
	else if(((m_patchLine.pFirstJack) && (m_patchLine.pFirstJack->IsPatched())) ||
			((m_patchLine.pLastJack) && (m_patchLine.pLastJack->IsPatched())))
	{
		AfxMessageBox(_T("You cannot connect a patch cord to a jack that has already been patched. "
					     "Try connecting to a patch cord instead."),
					  MB_OK | MB_ICONWARNING | MB_APPLMODAL);
		return NULL;
	}

	// If this is a direct connect between two mixbins, abort
	else if((m_patchLine.pFirstJack && m_patchLine.pLastJack) &&
		    (((m_patchLine.pFirstJack->GetModule()->GetType() == CModule::INPUT_MIXBIN) ||
			  (m_patchLine.pFirstJack->GetModule()->GetType() == CModule::OUTPUT_MIXBIN)) &&
			 ((m_patchLine.pLastJack->GetModule()->GetType() == CModule::INPUT_MIXBIN) ||
			  (m_patchLine.pLastJack->GetModule()->GetType() == CModule::OUTPUT_MIXBIN))))
	{
		AfxMessageBox(_T("You cannot connect two mixbins."),
					  MB_OK | MB_ICONWARNING | MB_APPLMODAL);
		return NULL;
	}

	// If the patch cord will be patched at both ends to the same patch cord, abort
	else if(m_patchLine.pFirstPatchCord && 
		    (m_patchLine.pFirstPatchCord == m_patchLine.pLastPatchCord))
	{
		AfxMessageBox(_T("You cannot connect both ends of the patch cord to the same patch cord."),
					  MB_OK | MB_ICONWARNING | MB_APPLMODAL);
		return NULL;
	}

	// If the patch cord is connected to the input and output of the same module, abort
	else if((m_patchLine.pFirstJack && m_patchLine.pLastJack) &&
			(m_patchLine.pFirstJack->GetModule() == m_patchLine.pLastJack->GetModule()) &&
			(m_patchLine.pFirstJack->GetInput() != m_patchLine.pLastJack->GetInput()))
	{
		AfxMessageBox(_T("You cannot connect output of an effect to its own input."),
					  MB_OK | MB_ICONWARNING | MB_APPLMODAL);
		return NULL;
	}

	// Create the new patch cord
	pPatchCord = new CPatchCord;
	pPatchCord->SetPoints(m_patchLine.points);
	rect = pPatchCord->GetRect();

	// Connect the first end
	switch(m_patchLine.firstPatchEnd)
	{
	case CGraph::PATCHEND_INPUT:
	case CGraph::PATCHEND_OUTPUT:
		m_patchLine.pFirstJack->Connect(pPatchCord, FALSE);
		break;

	case CGraph::PATCHEND_HORIZONTAL:
	case CGraph::PATCHEND_VERTICAL:
	case CGraph::PATCHEND_POINT:
		rect.UnionRect(rect, m_patchLine.pFirstPatchCord->GetRect());
		pSplitPatchCord = m_patchLine.pFirstPatchCord->Connect(pPatchCord, m_patchLine.points[0], FALSE);
		if(pSplitPatchCord)
			m_patchCords.Add(pSplitPatchCord);
		break;
	default:
		break;
	}
	
	// Connect the last end
	switch(m_patchLine.lastPatchEnd)
	{
	case CGraph::PATCHEND_INPUT:
	case CGraph::PATCHEND_OUTPUT:
		m_patchLine.pLastJack->Connect(pPatchCord, TRUE);
		break;

	case CGraph::PATCHEND_HORIZONTAL:
	case CGraph::PATCHEND_VERTICAL:
	case CGraph::PATCHEND_POINT:
		rect.UnionRect(rect, m_patchLine.pLastPatchCord->GetRect());
		pSplitPatchCord = m_patchLine.pLastPatchCord->Connect(pPatchCord, m_patchLine.points[m_patchLine.points.GetSize()-1], TRUE);
		if(pSplitPatchCord)
			m_patchCords.Add(pSplitPatchCord);
		break;
	default:
		break;
	}

	// Add the patch cord to the list
	m_patchCords.Add(pPatchCord);
	m_bChangesMade = TRUE;

	// Enable overwrite?
//	pPatchCord->SetOverwriteEnable();

	// Validate the new layout
	ValidateGraph();

	// Redraw
	Draw(rect);

	return pPatchCord;
}

//------------------------------------------------------------------------------
//	CGraph::UpdatePatchLine
//------------------------------------------------------------------------------
void
CGraph::UpdatePatchLine(void)
/*++

Routine Description:

	Updates the points on the patch line based on the drawline state

Arguments:

	None

ReturnValue:

	None

--*/
{
	BOOL	bVertical;
	int		last = m_patchLine.points.GetSize() - 1;
	
	// Last point will almost always be where the mouse is
	switch(m_patchLine.lastPatchEnd)
	{
	case CGraph::PATCHEND_INPUT:
		m_patchLine.points[last].x = m_patchLine.pLastJack->GetModule()->GetRect().left;
		m_patchLine.points[last].y = m_patchLine.pLastJack->GetY();
		break;
	case CGraph::PATCHEND_OUTPUT:
		m_patchLine.points[last].x = m_patchLine.pLastJack->GetModule()->GetRect().right - 1;
		m_patchLine.points[last].y = m_patchLine.pLastJack->GetY();
		break;
	case CGraph::PATCHEND_HORIZONTAL:
		if(m_patchLine.points[last].x == m_patchLine.points[last-1].x)
		{
			m_patchLine.points[last].x = m_mouse.x;
			m_patchLine.points[last].y = m_patchLine.pLastPatchCord->GetLastPoint().y;
		}
		else
			m_patchLine.points[last] = m_mouse;
		break;
	case CGraph::PATCHEND_VERTICAL:
		if(m_patchLine.points[last].y == m_patchLine.points[last-1].y)
		{
			m_patchLine.points[last].x = m_patchLine.pLastPatchCord->GetLastPoint().x;
			m_patchLine.points[last].y = m_mouse.y;
		}
		else
			m_patchLine.points[last] = m_mouse;
		break;
	case CGraph::PATCHEND_POINT:
		m_patchLine.points[last] = m_patchLine.pLastPatchCord->GetLastPoint();
		break;
	default:
		m_patchLine.points[last] = m_mouse;
	}

	// Complex line?
	if(m_bDrawComplexLine)
	{
		// Are there more than 3 points?
		if(m_patchLine.points.GetSize() > 3)
		{
			if(m_patchLine.points[last-2].x == m_patchLine.points[last-3].x)
				bVertical = TRUE;
			else
				bVertical = FALSE;
		}

		// Just use the first point info
		else
		{
			switch(m_patchLine.firstPatchEnd)
			{
				case CGraph::PATCHEND_VERTICAL:
				case CGraph::PATCHEND_INPUT:
				case CGraph::PATCHEND_OUTPUT:
					bVertical = TRUE;
					break;
				default: // Graph::HORIZONTAL:
					bVertical = FALSE;
					break;
			}
		}

		if(bVertical)
		{
			m_patchLine.points[last-1].x	= m_patchLine.points[last].x;
			m_patchLine.points[last-1].y	= m_patchLine.points[last-2].y;
		}
		else
		{
			m_patchLine.points[last-1].x	= m_patchLine.points[last-2].x;
			m_patchLine.points[last-1].y	= m_patchLine.points[last].y;
		}
	}

	// Simple line
	else
	{
		// Make sure there are 4 points in the line
		if(m_patchLine.points.GetSize() == 3)
			m_patchLine.points.Add(m_patchLine.points[2]);
		
		// Set the other 2 points based on the state of the line
		switch(m_patchLine.firstPatchEnd)
		{
		case CGraph::PATCHEND_HORIZONTAL:
		case CGraph::PATCHEND_POINT:
			switch(m_patchLine.lastPatchEnd)
			{
				case CGraph::PATCHEND_NONE:
				case CGraph::PATCHEND_VERTICAL:
				case CGraph::PATCHEND_INPUT:
				case CGraph::PATCHEND_OUTPUT:
					m_patchLine.points[1]	= m_patchLine.points[0];
					m_patchLine.points[2].x	= m_patchLine.points[0].x;
					m_patchLine.points[2].y	= m_patchLine.points[3].y;
					break;
				case CGraph::PATCHEND_HORIZONTAL:
				case CGraph::PATCHEND_POINT:
					m_patchLine.points[1].x	= m_patchLine.points[0].x;
					m_patchLine.points[1].y	= MEDIAN(m_patchLine.points[0].y, m_patchLine.points[3].y);
					m_patchLine.points[2].x	= m_patchLine.points[3].x;
					m_patchLine.points[2].y	= m_patchLine.points[1].y;
					break;
				default:
					break;
			}
			break;
		case CGraph::PATCHEND_VERTICAL:
		case CGraph::PATCHEND_INPUT:
		case CGraph::PATCHEND_OUTPUT:
			switch(m_patchLine.lastPatchEnd)
			{
				case CGraph::PATCHEND_NONE:
				case CGraph::PATCHEND_VERTICAL:
				case CGraph::PATCHEND_INPUT:
				case CGraph::PATCHEND_OUTPUT:
					m_patchLine.points[1].x	= MEDIAN(m_patchLine.points[0].x, m_patchLine.points[3].x);
					m_patchLine.points[1].y	= m_patchLine.points[0].y;
					m_patchLine.points[2].x	= m_patchLine.points[1].x;
					m_patchLine.points[2].y	= m_patchLine.points[3].y;
					break;
				case CGraph::PATCHEND_HORIZONTAL:
				case CGraph::PATCHEND_POINT:
					m_patchLine.points[1]	= m_patchLine.points[0];
					m_patchLine.points[2].y	= m_patchLine.points[0].y;
					m_patchLine.points[2].x	= m_patchLine.points[3].x;
					break;
				default: break;
			}
			break;
		default:
			break;
		}
	}
}

//------------------------------------------------------------------------------
//	CGraph::ValidateGraph
//------------------------------------------------------------------------------
void
CGraph::ValidateGraph(void)
/*++

Routine Description:

	Examines the content of the graph to determine if the layout is valid.
	Any patch cords that are in question, will be marked invalid.

Arguments:

	None

Return Value:

	None

--*/
{
	int						m;
	int						i;
	int						c;
	CArray<CJack*, CJack*>	list;
	CJack*					pJack;
	CModule*				pModule;

	if(m_bDead)
		return;

	// First mark all patch cords as valid
	for(i=0; i<m_patchCords.GetSize(); ++i)
		m_patchCords[i]->SetInvalid(FALSE);

	// Check every module
	for(m=0; m<m_modules.GetSize(); ++m)
	{
		pModule = m_modules[m];

		// Check all inputs on the module
		for(i=0; i<pModule->GetInputs().GetSize(); ++i)
		{
			pJack = pModule->GetInputs()[i];

			// Get all the connections
			pJack->GetConnections(list);

			// Loop through all the connections
			for(c=0; c<list.GetSize(); ++c)
			{
				// A mixbin cannot be connected to another mixbin
				// An effect input cannot be connected to own output (yet)
				// An effect input cannot be connected to an output mixbin
				if(((pModule->GetType() == CModule::OUTPUT_MIXBIN) &&
					((list[c]->GetModule()->GetType() == CModule::INPUT_MIXBIN) ||
					 (list[c]->GetModule()->GetType() == CModule::OUTPUT_MIXBIN))) ||
				   ((pModule->GetType() == CModule::EFFECT) &&
					(((list[c]->GetModule() == pModule) && !list[c]->GetInput()) ||
					 (list[c]->GetModule()->GetType() == CModule::OUTPUT_MIXBIN))))
				{
					pJack->Invalidate();
					break;
				}
			}
		}

		// Check all outputs on the module
		for(i=0; i<pModule->GetOutputs().GetSize(); ++i)
		{
			pJack = pModule->GetOutputs()[i];

			// Get all the connections
			pJack->GetConnections(list);

			// Loop through all the connections
			for(c=0; c<list.GetSize(); ++c)
			{
				// A mixbin cannot be connected to another mixbin
				// An effect output cannot be connected to own input (yet)
				// An effect output cannot be connected to a input mixbin
				if(((pModule->GetType() == CModule::INPUT_MIXBIN) &&
					((list[c]->GetModule()->GetType() == CModule::INPUT_MIXBIN) ||
					 (list[c]->GetModule()->GetType() == CModule::OUTPUT_MIXBIN))) ||
				   ((pModule->GetType() == CModule::EFFECT) &&
					(((list[c]->GetModule() == pModule) && list[c]->GetInput()) ||
					 (list[c]->GetModule()->GetType() == CModule::INPUT_MIXBIN))))
				{
					pJack->Invalidate();
					break;
				}
			}
		}
	}

	// For now, just redraw everything
	Draw(m_rect);
}

//------------------------------------------------------------------------------
//	CGraph::SetTitle
//------------------------------------------------------------------------------
void
CGraph::SetTitle(void)
{
	CString	title;
	int		index;
	CString	buildOptions;

	buildOptions.Format(_T("  [Reverb: %s, LFE: %s, XTalk: %s]"),
						m_i3dl2Config.GetLength() ? m_i3dl2Config : _T("<None>"), 
						m_bPatchXtalkToLFE ? _T("Yes") : _T("No"),
						m_bIncludeXtalk ? _T("Yes") : _T("No"));

	if(m_filename.IsEmpty())
		title = _T("dspbuilder");
	else
	{
		title.Format(_T("dspbuilder: %s"), m_filename);
		index = title.ReverseFind('.');
		if(index != -1)
			title.Delete(index, title.GetLength()-index);
	}
	title += buildOptions;
	m_pParent->GetParent()->SetWindowText((LPCTSTR)title);
}

//------------------------------------------------------------------------------
//	CGraph::EnableMixbinsOnMen
//------------------------------------------------------------------------------
void
CGraph::EnableMixbinsOnMenu(void)
/*++

Routine Description:

	Enables and disables individual items on the mixbins menu

Arguments:

	None

Return Value:

	None

--*/
{
	int		i;
	int		m;
	UINT	mask	= INPUT_MIXBIN_MASK;
	BOOL*	mixbin	= m_inputMixbinInUse.GetData();

	// First enable them all
	for(i=0; i<35; ++i)
	{
		m_rootMenu.EnableMenuItem(i | INPUT_MIXBIN_MASK, MF_ENABLED);
		m_rootMenu.EnableMenuItem(i | OUTPUT_MIXBIN_MASK, MF_ENABLED);
	}

	for(i=0; i<2; ++i)
	{
		if(mixbin[0])	// Front Left
		{
			m_rootMenu.EnableMenuItem(0 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(1 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(2 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(4 | mask, MF_GRAYED);
		}
		if(mixbin[1])	// Front Right
		{
			m_rootMenu.EnableMenuItem(0 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(1 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(2 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(5 | mask, MF_GRAYED);
		}
		if(mixbin[2])	// Center
		{
			m_rootMenu.EnableMenuItem(0 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(6 | mask, MF_GRAYED);
		}
		if(mixbin[3])	// LFE
		{
			m_rootMenu.EnableMenuItem(0 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(7 | mask, MF_GRAYED);
		}
		if(mixbin[4])	// Back Left
		{
			m_rootMenu.EnableMenuItem(0 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(1 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(3 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(8 | mask, MF_GRAYED);
		}
		if(mixbin[5])	// Back Right
		{
			m_rootMenu.EnableMenuItem(0 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(1 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(3 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(9 | mask, MF_GRAYED);
		}
		if(mixbin[6])	// XTalk Front Left
		{
			m_rootMenu.EnableMenuItem(10 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(11 | mask, MF_GRAYED);
		}
		if(mixbin[7])	// XTalk Front Right
		{
			m_rootMenu.EnableMenuItem(10 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(12 | mask, MF_GRAYED);
		}
		if(mixbin[8])	// XTalk Back Left
		{
			m_rootMenu.EnableMenuItem(10 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(13 | mask, MF_GRAYED);
		}
		if(mixbin[9])	// XTalk Back Right
		{
			m_rootMenu.EnableMenuItem(10 | mask, MF_GRAYED);
			m_rootMenu.EnableMenuItem(14 | mask, MF_GRAYED);
		}
		if(mixbin[10])	// I3DL2
			m_rootMenu.EnableMenuItem(15 | mask, MF_GRAYED);
		
		for(m=11; m<31; ++m)
		{
			if(mixbin[m])
				m_rootMenu.EnableMenuItem(((unsigned)m+5) | mask, MF_GRAYED);
		}

		// Next pass is output
		mixbin	= m_outputMixbinInUse.GetData();
		mask	= OUTPUT_MIXBIN_MASK;
	}
}

//------------------------------------------------------------------------------
//	CGraph::ReadVersion1
//------------------------------------------------------------------------------
BOOL
CGraph::ReadVersion1(
					 IN OUT CFile&	file
					 )
/*++

Routine Description:

	Reads and converts a version 1 file to a version 2 file

Arguments:

	IN file -	File to read

Return Value:

	None

--*/
{
	CString					filename;
	BYTE					b;
	WORD					word;
	int						width;
	int						height;
	BYTE*					pByte;
	int						numCells;
	int						numEffects;
	CString					string;
	CString					effectName;
	CString					config;
	char*					buffer;
	int						left;
	int						top;
	int						numInputs;
	int						numOutputs;
	int						i;
	CModule*				pModule;
	int						e;
	int						ii;
	BOOL					missingEffects	= FALSE;
	BOOL					missingConfigs	= FALSE;
	int						x;
	int						y;
	CPatchCord*				pPatchCord;
	CArray<CPoint, CPoint&>	points;

	filename = file.GetFilePath();

	// Read the width
	if(file.Read(&word, sizeof(word)) != sizeof(word))
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}
	width = word;

	// Read the height
	if(file.Read(&word, sizeof(word)) != sizeof(word))
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}
	height		= word;
	numCells	= width * height;

	// Allocate the cells
	if(numCells <= 0)
	{
		string.Format(_T("Invalid width / height: %s"), (LPCTSTR)filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		return FALSE;
	}
	
	pByte = new BYTE [(unsigned)numCells];

	// Read the cells
	if(file.Read(pByte, (UINT)numCells) != (UINT)numCells)
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		delete [] pByte;
		return FALSE;
	}

	// Process the Cells and generate the patch cords
	m_gridWidth		= width;
	m_gridHeight	= height;
	m_pGrid			= new CGraph::Grid [(unsigned)(m_gridWidth * m_gridHeight)];

	// Fill the grid
	for(i=0, x=0; x<m_gridWidth; ++x)
	{
		for(y=0; y<m_gridHeight; ++y, ++i)
		{
			ii = 0;
			if(pByte[i] & (1 << 3))
			{
				m_pGrid[i].bLeft = TRUE;
				++ii;
			}
			if(pByte[i] & (1 << 2))
			{
				m_pGrid[i].bRight = TRUE;
				++ii;
			}
			if(pByte[i] & (1 << 1))
			{
				m_pGrid[i].bTop = TRUE;
				++ii;
			}
			if(pByte[i] & 1)
			{
				m_pGrid[i].bBottom = TRUE;
				++ii;
			}
			if((pByte[i] & (1 << 4)) && (ii >= 3))
				m_pGrid[i].bJoined = TRUE;
		}
	}
	delete [] pByte;

	// Read all the effects
	if(file.Read(&word, sizeof(word)) != sizeof(word))
	{
		string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
		AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
		delete [] m_pGrid;
		m_pGrid = NULL;
		return FALSE;
	}
	numEffects = word;

	for(i=0; i<numEffects; ++i)
	{
		// Effect Name (word, string)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		buffer = new char [word+1];
		if(file.Read(buffer, word + 1) != (UINT)(word+1))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			delete [] buffer;
			return FALSE;
		}
		effectName = buffer;
		delete [] buffer;

		// Configuration
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		if (word != 0)
		{
			buffer = new char [word+1];
			if(file.Read(buffer, word + 1) != (UINT)(word+1))
			{
				string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
				AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
				delete [] m_pGrid;
				m_pGrid = NULL;
				delete [] buffer;
				return FALSE;
			}
			config = buffer;
			delete [] buffer;
		}
		else
			config = _T("");

		// Grid Location (word, word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		left = word;
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		top = word;

		// Num Inputs (word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		numInputs = word;

		// Num Outputs (word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		numOutputs = word;

		// Width (word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		width = word;

		// Height (word)
		if(file.Read(&word, sizeof(word)) != sizeof(word))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)m_filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		height = word;

		// Try to find the effect in the effects list
		for(e=0; e<m_effects.GetSize(); ++e)
		{
			string = m_effects[e]->GetEffectName();

			// The following need to match: name, numInputs & numOutputs
			if((effectName == m_effects[e]->GetEffectName()) &&
			   (m_effects[e]->GetInputs().GetSize() == numInputs) &&
			   (m_effects[e]->GetOutputs().GetSize() == numOutputs))
			   break;
		}

		// If the effect was found add it
		if(e != m_effects.GetSize())
		{
			pModule = new CModule(*m_effects[e]);
			m_modules.Add(pModule);
			pModule->Move(CPoint((left+1)*SCALE, (top+1)*SCALE));

			// Look up the configuration
			if(config != _T(""))
			{
				for(ii=0; ii<pModule->GetConfigs().GetSize(); ++ii)
				{
					if(pModule->GetConfigs()[ii].name == config)
					{
						pModule->SetActiveConfig(ii);
						break;
					}
				}
				if(ii == pModule->GetConfigs().GetSize())
					missingConfigs = TRUE;
			}

			// Add the effect to the grid
			for(x=left; x<left+width; ++x)
			{
				for(y=top; y<top+height; ++y)
					m_pGrid[CI(x,y)].pModule = pModule;
			}

			// Setup the inputs/outputs
			for(y=0; y<pModule->GetInputs().GetSize(); ++y)
			{
				m_pGrid[CI(left, top+y+1)].bLeft	= TRUE;
				m_pGrid[CI(left, top+y+1)].index	= y;
			}
			for(y=0; y<pModule->GetOutputs().GetSize(); ++y)
			{
				m_pGrid[CI(left+width-1, top+y+1)].bRight	= TRUE;
				m_pGrid[CI(left+width-1, top+y+1)].index	= y;
			}
		}

		// Otherwise drop it and set a flag to display an error
		else
			missingEffects = TRUE;
	}

	// Read the Input Mixbin locations
	for(i=0; i<26; ++i)
	{
		if(file.Read(&b, sizeof(b)) != sizeof(b))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		if(b >= 26)
		{
			string.Format(_T("Invalid input mixbin index: %s"), (LPCTSTR)filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}

		// Speakers
		if(b <= 5)	
			ii = b;

		// FX Sends
		else	
			ii = (int)b + 5;
		
		pModule = new CModule(*m_inputMixbins[ii]);
		m_modules.Add(pModule);
		pModule->Move(CPoint(SCALE, (i*4+1)*SCALE));

		for(x=0; x<9; ++x)
		{
			for(y=0; y<3; ++y)
				m_pGrid[CI(x, i*4+y)].pModule = pModule;
		}

		// Setup the output
		m_pGrid[CI(8, i*4+1)].bRight	= TRUE;
		m_pGrid[CI(8, i*4+1)].index		= 0;
	}
	
	// Read the Output Mixbin locations
	for(i=0; i<26; ++i)
	{
		if(file.Read(&b, sizeof(b)) != sizeof(b))
		{
			string.Format(_T("Error reading: %s"), (LPCTSTR)filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}
		if(b >= 26)
		{
			string.Format(_T("Invalid output mixbin index: %s"), (LPCTSTR)filename);
			AfxMessageBox(string, MB_OK | MB_ICONERROR | MB_APPLMODAL);
			delete [] m_pGrid;
			m_pGrid = NULL;
			return FALSE;
		}

		// Speakers
		if(b <= 5)	
			ii = b;

		// FX Sends
		else	
			ii = (int)b + 5;
		
		pModule = new CModule(*m_outputMixbins[ii]);
		m_modules.Add(pModule);
		pModule->Move(CPoint((m_gridWidth-8)*SCALE, (i*4+1)*SCALE));

		for(x=m_gridWidth-9; x<m_gridWidth; ++x)
		{
			for(y=0; y<3; ++y)
				m_pGrid[CI(x, i*4+y)].pModule = pModule;
		}

		// Setup the inputs
		m_pGrid[CI(m_gridWidth-9, i*4+1)].bLeft	= TRUE;
		m_pGrid[CI(m_gridWidth-9, i*4+1)].index	= 0;
	}

	// Generate the patch cords from the grid
	for(y=0; y<m_gridHeight; ++y)
	{
		for(x=0; x<m_gridWidth; ++x)
		{
			ii = CI(x, y);
			if((m_pGrid[ii].pModule || m_pGrid[ii].bJoined) && 
			   (m_pGrid[ii].bLeft || m_pGrid[ii].bRight || m_pGrid[ii].bTop || 
			    m_pGrid[ii].bBottom))
			{
				TraceAndBuildPatchCord(x, y);
			}
		}
	}

	// Connect joined cell patch cords
	for(i=m_gridWidth*m_gridHeight-1; i>=0; --i)
	{
		if(m_pGrid[i].bJoined)
		{
			if(m_pGrid[i].pPatchCordLeft)
			{
				if(m_pGrid[i].pPatchCordTop)
					m_pGrid[i].pPatchCordLeft->AddPatchCord(m_pGrid[i].pPatchCordTop, m_pGrid[i].bEndLeft);
				if(m_pGrid[i].pPatchCordRight)
					m_pGrid[i].pPatchCordLeft->AddPatchCord(m_pGrid[i].pPatchCordRight, m_pGrid[i].bEndLeft);
				if(m_pGrid[i].pPatchCordBottom)
					m_pGrid[i].pPatchCordLeft->AddPatchCord(m_pGrid[i].pPatchCordBottom, m_pGrid[i].bEndLeft);
			}
			if(m_pGrid[i].pPatchCordRight)
			{
				if(m_pGrid[i].pPatchCordTop)
					m_pGrid[i].pPatchCordRight->AddPatchCord(m_pGrid[i].pPatchCordTop, m_pGrid[i].bEndRight);
				if(m_pGrid[i].pPatchCordLeft)
					m_pGrid[i].pPatchCordRight->AddPatchCord(m_pGrid[i].pPatchCordLeft, m_pGrid[i].bEndRight);
				if(m_pGrid[i].pPatchCordBottom)
					m_pGrid[i].pPatchCordRight->AddPatchCord(m_pGrid[i].pPatchCordBottom, m_pGrid[i].bEndRight);
			}
			if(m_pGrid[i].pPatchCordTop)
			{
				if(m_pGrid[i].pPatchCordLeft)
					m_pGrid[i].pPatchCordTop->AddPatchCord(m_pGrid[i].pPatchCordLeft, m_pGrid[i].bEndTop);
				if(m_pGrid[i].pPatchCordRight)
					m_pGrid[i].pPatchCordTop->AddPatchCord(m_pGrid[i].pPatchCordRight, m_pGrid[i].bEndTop);
				if(m_pGrid[i].pPatchCordBottom)
					m_pGrid[i].pPatchCordTop->AddPatchCord(m_pGrid[i].pPatchCordBottom, m_pGrid[i].bEndTop);
			}
			if(m_pGrid[i].pPatchCordBottom)
			{
				if(m_pGrid[i].pPatchCordTop)
					m_pGrid[i].pPatchCordBottom->AddPatchCord(m_pGrid[i].pPatchCordTop, m_pGrid[i].bEndBottom);
				if(m_pGrid[i].pPatchCordRight)
					m_pGrid[i].pPatchCordBottom->AddPatchCord(m_pGrid[i].pPatchCordRight, m_pGrid[i].bEndBottom);
				if(m_pGrid[i].pPatchCordLeft)
					m_pGrid[i].pPatchCordBottom->AddPatchCord(m_pGrid[i].pPatchCordLeft, m_pGrid[i].bEndBottom);
			}
		}
	}

	// Add the patch cords to list
	for(i=m_gridWidth*m_gridHeight-1; i>=0; --i)
	{
		if(m_pGrid[i].pPatchCordLeft && (m_pGrid[i].pModule == NULL))
		{
			for(ii=0; ii<m_patchCords.GetSize(); ++ii)
			{
				if(m_patchCords[ii] == m_pGrid[i].pPatchCordLeft)
					break;
			}
			if(ii == m_patchCords.GetSize())
				m_patchCords.Add(m_pGrid[i].pPatchCordLeft);
		}
		if(m_pGrid[i].pPatchCordRight && (m_pGrid[i].pModule == NULL))
		{
			for(ii=0; ii<m_patchCords.GetSize(); ++ii)
			{
				if(m_patchCords[ii] == m_pGrid[i].pPatchCordRight)
					break;
			}
			if(ii == m_patchCords.GetSize())
				m_patchCords.Add(m_pGrid[i].pPatchCordRight);
		}
		if(m_pGrid[i].pPatchCordTop&& (m_pGrid[i].pModule == NULL))
		{
			for(ii=0; ii<m_patchCords.GetSize(); ++ii)
			{
				if(m_patchCords[ii] == m_pGrid[i].pPatchCordTop)
					break;
			}
			if(ii == m_patchCords.GetSize())
				m_patchCords.Add(m_pGrid[i].pPatchCordTop);
		}
		if(m_pGrid[i].pPatchCordBottom && (m_pGrid[i].pModule == NULL))
		{
			for(ii=0; ii<m_patchCords.GetSize(); ++ii)
			{
				if(m_patchCords[ii] == m_pGrid[i].pPatchCordBottom)
					break;
			}
			if(ii == m_patchCords.GetSize())
				m_patchCords.Add(m_pGrid[i].pPatchCordBottom);
		}
	}

	// Remove all the disconnected patch cords
	for(i=m_patchCords.GetSize()-1; i>=0; --i)
	{
		if(!m_patchCords[i]->IsPatchedAtEnds())
		{
			pPatchCord = m_patchCords[i];
			m_patchCords.RemoveAt(i);
			delete pPatchCord;
		}
	}

	// Free resources
	delete [] m_pGrid;
	m_pGrid = NULL;
	
	// Remove unpatched mixbins
	for(i=m_modules.GetSize()-1; i>=0; --i)
	{
		if(((m_modules[i]->GetType() == CModule::INPUT_MIXBIN) ||
			(m_modules[i]->GetType() == CModule::OUTPUT_MIXBIN)) &&
			!m_modules[i]->IsPatched())
		{
			pModule = m_modules[i];
			m_modules.RemoveAt(i);
			delete pModule;
		}
	}

	// Display errors
	if(missingEffects)
	{
		AfxMessageBox(_T("One or more of the effects in the file are "
						 "not currently available and will not be shown."),
					  MB_OK | MB_ICONERROR | MB_APPLMODAL);
	}
	if(missingConfigs)
	{
		AfxMessageBox(_T("One or more of the effects in the file are missing "
						 "configurations and will be set to their default."),
					  MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
	}
	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::ReadVersion2or3or4
//------------------------------------------------------------------------------
BOOL
CGraph::ReadVersion2or3or4(
						   IN OUT CFile&	file,
						   IN BYTE			version
						   )
/*++

Routine Description:

	Reads a version 2 file

Arguments:

	IN file -		File to read
	IN version -	File version

Return Value:

	TRUE on success, FALSE on failure

--*/
{
	WORD		word;
	BYTE		byte;
	int			i;	
	CModule*	pModule;
	CPatchCord*	pPatchCord;
	CString		filePath;

	// Read the build options
	if(version >= 4)
	{
		if(!CGraph::ReadString(file, m_i3dl2Config))
			return FALSE;

		if(file.Read(&byte, sizeof(byte)) != sizeof(byte))
			return FALSE;
		m_bPatchXtalkToLFE = byte ? TRUE : FALSE;

		if(file.Read(&byte, sizeof(byte)) != sizeof(byte))
			return FALSE;
		m_bIncludeXtalk = byte ? TRUE : FALSE;
	}

	// Read the number of modules
	if(file.Read(&word, sizeof(word)) != sizeof(word))
		return FALSE;

	// Read all the modules
	for(i=0; i<word; ++i)
	{
		pModule = new CModule();
		if(!pModule->Read(file, version))
		{
			for(i=m_modules.GetSize()-1; i>=0; --i)
			{
				pModule = m_modules[i];
				m_modules.RemoveAt(i);
				delete pModule;
			}
			return FALSE;
		}
		m_modules.Add(pModule);
	}
	
	// Read the number of patch cords
	if(file.Read(&word, sizeof(word)) != sizeof(word))
		return FALSE;

	// Write the patch cords
	for(i=0; i<word; ++i)
	{
		pPatchCord = new CPatchCord();
		if(!pPatchCord->Read(file, version))
		{
			for(i=m_modules.GetSize()-1; i>=0; --i)
			{
				pModule = m_modules[i];
				m_modules.RemoveAt(i);
				delete pModule;
			}
			for(i=m_patchCords.GetSize()-1; i>=0; --i)
			{
				pPatchCord = m_patchCords[i];
				m_patchCords.RemoveAt(i);
				delete pPatchCord;
			}
			return FALSE;
		}
		m_patchCords.Add(pPatchCord);
	}

	// Adjust all the pointers
	for(i=0; i<m_patchCords.GetSize(); ++i)
		m_patchCords[i]->FixPointers(this);
	for(i=0; i<m_modules.GetSize(); ++i)
		m_modules[i]->FixPointers(this);
	
	// Read module parameters
	for(i=0; i<m_modules.GetSize(); ++i)
	{
		filePath.Format(_T("%s\\%s"), m_iniPath, m_modules[i]->GetStateFilename());
		m_modules[i]->SetParameters(m_imageBuilder, filePath);
	}

	// Older versions need the overwrite enable flag generated
//	if(version < 4)
//	{
//		for(i=0; i<m_patchCords.GetSize(); ++i)
//			m_patchCords[i]->SetOverwriteEnable();
//	}

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::BuildEffectChains
//------------------------------------------------------------------------------
BOOL
CGraph::BuildEffectChains(
						  LPCTSTR	pFilename
						  )
/*++

Routine Description:

	Builds a list of effect chains by examining the grid.
	This method assumes there are no invalid cells in the grid.

Arguments:

	IN pFilename -	File to save to

Return Value:

	TRUE on success, FALSE on failure

--*/
{
	int						e;
	int						i;
	int						o;
	int						m;
	int						b;
	int						ii;
	int						oo;
	int						bb;
	int						c;
	int						oldTempMixbin;
	CModule*				pEffect;
	int						itm;
	EffectChainBucket		bucket;
	BOOL					found;
	int*					bins;
	int						numBins;
    int						err;
	char*					argv[4];
	CString					string;
	CStdioFile				file;
	int						totalTempMixbins;
	BOOL					bI3DL2;
	BOOL					flag;
	BOOL					b24k = TRUE;
	int						graph;
	int						extraTempMixbins;
	int						nullInput			= -1;	// Initialized to shut the compiler up
	int						nullOutput			= -1;	// Initialized to shut the compiler up
	int						nullMixbins			= 0;
	int						rvbTempMixbins		= 0;
	int						tempMixbin			= -1;
	BOOL					bNullInput			= FALSE;
	BOOL					bNullOutput			= FALSE;
	DWORD					dwEffectIndex		= 0;
	BOOL*					pbCleared			= NULL;
	BOOL					bInternalI3DL2		= FALSE;
	BOOL					bSimpleReverb		= FALSE;
	BOOL					bExtraMixbins		= FALSE;
	BOOL					bCustomStateFiles	= FALSE;
	int						extra;
	int						mixbin;
	CString					statefile;
	CArray<CJack*, CJack*>	connections;
	CString					statePath;
	CArray<EffectChainBucket, EffectChainBucket&> buckets;

	m_bImageSaved = FALSE;

	// Build options
	if(m_i3dl2Config != _T(""))
		bI3DL2 = TRUE;
	else
		bI3DL2 = FALSE;

	if(!file.Open(pFilename, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
	{
		AfxMessageBox(CString(_T("Unable to open file: ")) + file.GetFilePath(), MB_OK | MB_ICONERROR);
		return FALSE;
	}

	// First initialize all connections
	for(m=0; m<m_modules.GetSize(); ++m)
	{
		// Only process effects
		if(m_modules[m]->GetType() == CModule::EFFECT)
		{
			for(i=0; i<m_modules[m]->GetInputs().GetSize(); ++i)
				m_modules[m]->GetInputs()[i]->SetMixbin(INT_MAX);
			for(o=0; o<m_modules[m]->GetOutputs().GetSize(); ++o)
				m_modules[m]->GetOutputs()[o]->SetMixbin(INT_MAX);
		}
		else
		{
			for(i=0; i<m_modules[m]->GetInputs().GetSize(); ++i)
				m_modules[m]->GetInputs()[i]->SetMixbin(m_modules[m]->GetMixbin());
			for(o=0; o<m_modules[m]->GetOutputs().GetSize(); ++o)
				m_modules[m]->GetOutputs()[o]->SetMixbin(m_modules[m]->GetMixbin());
		}
	}

	// Build the connection graph
	for(m=0; m<m_modules.GetSize(); ++m)
	{
		// Only process effects
		if(m_modules[m]->GetType() != CModule::EFFECT)
			continue;

		// Only process connected effects
		if(!m_modules[m]->IsConnected())
			continue;

		// Check all the effect's inputs
		for(i=0; i<m_modules[m]->GetInputs().GetSize(); ++i)
		{
			// Only process unconnected inputs
			if(m_modules[m]->GetInputs()[i]->GetMixbin() != INT_MAX)
				continue;

			// Get the list of connections for the input
			m_modules[m]->GetInputs()[i]->GetConnections(connections);

			// Any connections?
			if(connections.GetSize())
			{
				for(itm=INT_MAX, c=0; c<connections.GetSize(); ++c)
				{
					if(connections[c]->GetMixbin() != INT_MAX)
					{
						ASSERT(itm == INT_MAX);
						itm = connections[c]->GetMixbin();
					}
				}

				// If no mixbins were assigned, create a new tempmixbin
				if(itm == INT_MAX)
					itm = tempMixbin--;

				// Aassign all mixbins
				m_modules[m]->GetInputs()[i]->SetMixbin(itm);
				for(c=0; c<connections.GetSize(); ++c)
					connections[c]->SetMixbin(itm);
			}

			// If no connections were found flag for a null input
			else
				bNullInput = TRUE;
		}

		// Check all the effect's outputs
		for(o=0; o<m_modules[m]->GetOutputs().GetSize(); ++o)
		{
			// Only process unconnected outputs
			if(m_modules[m]->GetOutputs()[o]->GetMixbin() != INT_MAX)
				continue;

			// Get the list of connections for the output
			m_modules[m]->GetOutputs()[o]->GetConnections(connections);

			// Any connections?
			if(connections.GetSize())
			{
				for(itm=INT_MAX, c=0; c<connections.GetSize(); ++c)
				{
					if(connections[c]->GetMixbin() != INT_MAX)
					{
						ASSERT(itm == INT_MAX);
						itm = connections[c]->GetMixbin();
					}
				}

				// If no mixbins were assigned, create a new tempmixbin
				if(itm == INT_MAX)
					itm = tempMixbin--;

				// Aassign all mixbins
				m_modules[m]->GetOutputs()[o]->SetMixbin(itm);
				for(c=0; c<connections.GetSize(); ++c)
					connections[c]->SetMixbin(itm);
			}

			// If no connections were found flag for a null output
			else
				bNullOutput = TRUE;
		}
	}

	// Build a list of used tempmixbins
	numBins	= -(tempMixbin + 1);
	bins	= new int [(unsigned)numBins];
	ASSERT(bins != NULL);
	for(b=0; b<numBins; ++b)
		bins[b] = 0;
	
	// Sort the effects into buckets to build the chains
	for(m=0; m<m_modules.GetSize(); ++m)
	{
		// Only process effects
		if(m_modules[m]->GetType() != CModule::EFFECT)
			continue;

		// Only process connected effects
		if(!m_modules[m]->IsConnected())
			continue;

		// Find the right bucket to insert the effect into
		for(found=FALSE, b=0; !found && b<buckets.GetSize(); ++b)
		{
			// The first bucket that this effect does not have any 
			// dependencies and insert it
			for(found=TRUE, i=0; found && i<buckets[b].effects.GetSize(); ++i)
			{
				if(DoesModuleDependOnModule(m_modules[m], buckets[b].effects[i]))
					found = FALSE;
			}

			// Was a bucket found?
			if(found)
			{
				// Search for reverse dependencies
				for(i=0; found && i<buckets[b].effects.GetSize(); ++i)
				{
					if(DoesModuleDependOnModule(buckets[b].effects[i], m_modules[m]))
						found = FALSE;
				}

				// If no reverse dependencies were found, insert the effect into this bucket
				if(found)
					buckets[b].effects.InsertAt(buckets[b].effects.GetSize(), m_modules[m]);

				// Otherwise, insert a new bucket and place the effect into it
				else
				{
					bucket.effects.RemoveAll();
					bucket.inputs.RemoveAll();
					bucket.outputs.RemoveAll();
					bucket.effects.InsertAt(0, m_modules[m]);
					buckets.InsertAt(b, bucket);
					found = TRUE;
				}
			}
		}

		// Was the effect inserted?
		if(!found)
		{
			bucket.effects.RemoveAll();
			bucket.inputs.RemoveAll();
			bucket.outputs.RemoveAll();
			bucket.effects.InsertAt(0, m_modules[m]);
			buckets.InsertAt(b, bucket);
		}
	}

	// Step through all the buckets and update the input and output lists
	for(b=0; b<buckets.GetSize(); ++b)
	{
		// Step through the effects in the bucket
		for(e=0; e<buckets[b].effects.GetSize(); ++e)
		{
			// Look through the inputs of the effect
			for(i=0; i<buckets[b].effects[e]->GetInputs().GetSize(); ++i)
			{
				// Is the input in the inputs list?
				for(ii=0; ii<buckets[b].inputs.GetSize(); ++ii)
				{
					if(buckets[b].effects[e]->GetInputs()[i]->GetMixbin() == buckets[b].inputs[ii])
						break;
				}

				// Not in the list? Add it
				if(ii == buckets[b].inputs.GetSize())
				{
					buckets[b].inputs.InsertAt(buckets[b].inputs.GetSize(), 
											   buckets[b].effects[e]->GetInputs()[i]->GetMixbin());
				}
			}

			// Look through the outputs of the effect
			for(o=0; o<buckets[b].effects[e]->GetOutputs().GetSize(); ++o)
			{
				// Is the input in the inputs list?
				for(oo=0; oo<buckets[b].outputs.GetSize(); ++oo)
				{
					if(buckets[b].effects[e]->GetOutputs()[o]->GetMixbin() == buckets[b].outputs[oo])
						break;
				}

				// Not in the list? Add it
				if(oo == buckets[b].outputs.GetSize())
				{
					buckets[b].outputs.InsertAt(buckets[b].outputs.GetSize(), 
											    buckets[b].effects[e]->GetOutputs()[o]->GetMixbin());
				}
			}
		}
	}

	// Remove extra temp mixbins
	for(b=0; b<buckets.GetSize(); ++b)
	{
		// Examine all the outputs in this bucket
		for(o=0; o<buckets[b].outputs.GetSize(); ++o)
		{
			// Only examine temp mixbins (negative values)
			if(buckets[b].outputs[o] < 0)
			{
				// Step through all previous buckets, looking for a bucket
				// with a duplicate output. If a duplicate is found, this temp mixbin
				// must be kept. If one is not found, try to find an available temp mixbin
				// that is no longer in use
				for(found=FALSE, bb=0; !found && bb<b; ++bb)
				{
					// Examine all the outputs of the bucket
					for(oo=0; oo<buckets[bb].outputs.GetSize(); ++oo)
					{
						if(buckets[bb].outputs[oo] == buckets[b].outputs[o])
							found = TRUE;
					}
				}

				// If not found, try to replace the temp mixbin
				if(!found)
				{
					// Start with the lowest numbered mixbin
					tempMixbin = -1;

					// If the search makes it's way to this mixbin, just bail
					found = TRUE;
					while(found && (buckets[b].outputs[o] != tempMixbin))
					{
						// Otherwise, look at this and all subsequent mixbins
						// and see if any rely on tempMixbin as an input
						// If none do, tempMixbin is a good choice
						for(bb=b; bb<buckets.GetSize(); ++bb)
						{
							// Examine all the inputs in the bucket
							for(i=0; i<buckets[bb].inputs.GetSize(); ++i)
							{
								if(buckets[bb].inputs[i] == tempMixbin)
									break;
							}
							if(i != buckets[bb].inputs.GetSize())
								break;
						}
						if(bb == buckets.GetSize())
							found = FALSE;
						else
							--tempMixbin;
					}

					// Is tempMixbin a good new choice?
					if(!found)
					{
						// Replace all occurences of the mixbin with
						// tempMixbin in this and all subsequent buckets
						oldTempMixbin = buckets[b].outputs[o];
						for(bb=b; bb<buckets.GetSize(); ++bb)
						{
							// Replace all inputs
							for(ii=0; ii<buckets[bb].inputs.GetSize(); ++ii)
							{
								if(buckets[bb].inputs[ii] == oldTempMixbin)
									buckets[bb].inputs[ii] = tempMixbin;
							}

							// Replace all outputs
							for(oo=0; oo<buckets[bb].outputs.GetSize(); ++oo)
							{
								if(buckets[bb].outputs[oo] == oldTempMixbin)
									buckets[bb].outputs[oo] = tempMixbin;
							}

							// Do the same for the real effects in the bucket
							for(e=0; e<buckets[bb].effects.GetSize(); ++e)
							{
								for(ii=0; ii<buckets[bb].effects[e]->GetInputs().GetSize(); ++ii)
								{
									if(buckets[bb].effects[e]->GetInputs()[ii]->GetMixbin() == oldTempMixbin)
										buckets[bb].effects[e]->GetInputs()[ii]->SetMixbin(tempMixbin);
								}
								for(oo=0; oo<buckets[bb].effects[e]->GetOutputs().GetSize(); ++oo)
								{
									if(buckets[bb].effects[e]->GetOutputs()[oo]->GetMixbin() == oldTempMixbin)
										buckets[bb].effects[e]->GetOutputs()[oo]->SetMixbin(tempMixbin);
								}
							}
						}
					}
				}
			}
		}
	}

	// Figure out which temp mixbins are being used
	for(b=0; b<buckets.GetSize(); ++b)
	{
		// Step through all the effects in the bucket
		for(e=0; e<buckets[b].effects.GetSize(); ++e)
		{
			// Step through all the inputs
			for(i=0; i<buckets[b].effects[e]->GetInputs().GetSize(); ++i)
			{
				// Is this a temp mixbin?
				if(buckets[b].effects[e]->GetInputs()[i]->GetMixbin() < 0)
					++bins[-(buckets[b].effects[e]->GetInputs()[i]->GetMixbin() + 1)];
			}

			// Step through all the outputs
			for(o=0; o<buckets[b].effects[e]->GetOutputs().GetSize(); ++o)
			{
				// Is this a temp mixbin?
				if(buckets[b].effects[e]->GetOutputs()[o]->GetMixbin() < 0)
					++bins[-(buckets[b].effects[e]->GetOutputs()[o]->GetMixbin() + 1)];
			}
		}
	}

	// Remove unused tempmixbins to compress the list of bins
	for(itm=0, bb=0; bb<numBins; ++bb)
	{
		// If this mixbin is not used, decrement all other tempmixbins larger than this
		if(bins[bb] == 0)
		{
			tempMixbin = -(bb + 1);
			for(b=0; b<buckets.GetSize(); ++b)
			{
				// Step through all the effects in the bucket
				for(e=0; e<buckets[b].effects.GetSize(); ++e)
				{
					// Step through all the inputs
					for(i=0; i<buckets[b].effects[e]->GetInputs().GetSize(); ++i)
					{
						// Is this a temp mixbin, and is does it need adjusting?
						mixbin = buckets[b].effects[e]->GetInputs()[i]->GetMixbin();
						if(mixbin < tempMixbin)
							buckets[b].effects[e]->GetInputs()[i]->SetMixbin(mixbin+1);
					}

					// Step through all the outputs
					for(o=0; o<buckets[b].effects[e]->GetOutputs().GetSize(); ++o)
					{
						// Is this a temp mixbin, and is does it need adjusting?
						mixbin = buckets[b].effects[e]->GetOutputs()[o]->GetMixbin();
						if(mixbin < tempMixbin)
							buckets[b].effects[e]->GetOutputs()[o]->SetMixbin(mixbin+1);
					}
				}
			}

		}
		else
			++itm;
	}
	delete [] bins;

	// Write the file
	try
	{
		// header
		file.WriteString(_T("[MAIN]\n"));

		// Name it the same as the ini file
		string.Format(_T("IMAGE_FRIENDLY_NAME=%s\n"), file.GetFileTitle());

		// CString::GetFileTitle() is not supposed to return a file extension but is
		// The following lines remove the extension if it exists
		i = string.Find(_T(".ini\n"));
		if(i == (string.GetLength() - 5))
			string.Delete(i, 4);

		file.WriteString(string);

		// Look for an I3DL2 Reverb in the scene
		for(b=0; b<buckets.GetSize(); ++b)
		{
			for(e=0; e<buckets[b].effects.GetSize(); ++e)
			{
//				if(!strcmp(buckets[b].effects[e]->GetEffectName(), _T("I3DL2 Reverb")) ||
//				   !strcmp(buckets[b].effects[e]->GetEffectName(), _T("I3DL2 24K Reverb")))
				if(buckets[b].effects[e]->IsI3DL2())
				{
					bInternalI3DL2	= TRUE;
					bExtraMixbins	= TRUE;
					numBins			= 0;

					// Count the number of tempbins already attached to the reverb
					for(i=0; i<buckets[b].effects[e]->GetInputs().GetSize(); ++i)
					{
						if(buckets[b].effects[e]->GetInputs()[i]->GetMixbin() < 0)
							++numBins;
					}
					for(i=0; i<buckets[b].effects[e]->GetOutputs().GetSize(); ++i)
					{
						if(buckets[b].effects[e]->GetOutputs()[i]->GetMixbin() < 0)
							++numBins;
					}
					if(numBins > rvbTempMixbins)
						rvbTempMixbins = numBins;
				}
			}
		}
		
		if(bI3DL2)
			bExtraMixbins = TRUE;

		// Look for a Simple Reverb in the scene
		for(b=0; b<buckets.GetSize(); ++b)
		{
			for(e=0; e<buckets[b].effects.GetSize(); ++e)
			{
				if(!strcmp(buckets[b].effects[e]->GetEffectName(), _T("Simple Reverb")))
				{
					bSimpleReverb	= TRUE;
					bExtraMixbins	= TRUE;
					numBins			= 0;

					// Count the number of tempbins already attached to the reverb
					for(i=0; i<buckets[b].effects[e]->GetInputs().GetSize(); ++i)
					{
						if(buckets[b].effects[e]->GetInputs()[i]->GetMixbin() < 0)
							++numBins;
					}
					for(i=0; i<buckets[b].effects[e]->GetOutputs().GetSize(); ++i)
					{
						if(buckets[b].effects[e]->GetOutputs()[i]->GetMixbin() < 0)
							++numBins;
					}
					if(numBins > rvbTempMixbins)
						rvbTempMixbins = numBins;
				}
			}
		}
		
		// Number of temp mixbins
		totalTempMixbins = itm;
		if(bNullInput)
		{
			nullInput = totalTempMixbins++;
			++nullMixbins;
		}
		if(bNullOutput)
		{
			nullOutput = totalTempMixbins++;
			++nullMixbins;
		}

		// Extra tempmixbins
		if(bExtraMixbins)
		{
			if(bInternalI3DL2 || bI3DL2)
				extraTempMixbins = (totalTempMixbins < 31) ? (31 - (totalTempMixbins - rvbTempMixbins - nullMixbins)) : 0;
			else if(bSimpleReverb)
				extraTempMixbins = (totalTempMixbins < 8) ? (8 - (totalTempMixbins - rvbTempMixbins - nullMixbins)) : 0;
			else
				extraTempMixbins = 0;
		}
		else
			extraTempMixbins = 0;

		string.Format(_T("FX_NUMTEMPBINS=%d\n"), totalTempMixbins + extraTempMixbins);
		file.WriteString(string);

		// Allocate the buffer 
		pbCleared = new BOOL [(unsigned)totalTempMixbins];
		ASSERT(pbCleared != NULL);
		for(i=0; i<totalTempMixbins; ++i)
			pbCleared[i] = FALSE;

		// Write the graph names
		for(graph=0, b=0; b<buckets.GetSize(); ++b)
		{
			for(e=0; e<buckets[b].effects.GetSize(); ++e, ++graph)
			{
				string.Format(_T("GRAPH%d=Graph%d\n"), graph, graph);
				file.WriteString(string);
			}
		}
		
		// I3DL2 Reverb or XTalk?
		if(bI3DL2 || m_bIncludeXtalk || m_bPatchXtalkToLFE)
		{
			string.Format(_T("GRAPH%d=Graph%d\n"), graph, graph);
			file.WriteString(string);
		}

		file.WriteString(_T("\n"));

		// Write the graphs
		for(graph=0, b=0; b<buckets.GetSize(); ++b)
		{
			for(e=0; e<buckets[b].effects.GetSize(); ++e, ++graph)
			{
				string.Format(_T("[Graph%d]\n"), graph);
				file.WriteString(string);
				string.Format(_T("FX0=%s\n\n"), buckets[b].effects[e]->GetName());
				string.Remove(' ');
				file.WriteString(string);
			}
		}

		// I3DL2 Reverb, XTalk, or XTalk2LFE?
		if(bI3DL2 || m_bIncludeXtalk || m_bPatchXtalkToLFE)
		{
			string.Format(_T("[Graph%d]\n"), graph);
			file.WriteString(string);
			b = 0;
			if(bI3DL2)
			{
				if(b24k)
					string.Format(_T("FX%d=I3DL2Reverb24K\n"), b++);
				else
					string.Format(_T("FX%d=I3DL2Reverb\n"), b++);
				file.WriteString(string);
			}
			if(m_bIncludeXtalk)
			{
				string.Format(_T("FX%d=XTalk\n"), b++);
				file.WriteString(string);
			}
			if(m_bPatchXtalkToLFE)
			{
				string.Format(_T("FX%d=XTalk2LFE_A\n"), b++);
				file.WriteString(string);
				string.Format(_T("FX%d=XTalk2LFE_B\n"), b++);
				file.WriteString(string);
			}
			file.WriteString(_T("\n"));
		}

		// Determine the path to the state files
		statePath	= file.GetFilePath();
		ii			= statePath.ReverseFind('\\');
		if(ii)
			statePath.Delete(ii, statePath.GetLength()-ii);

		// If any of the effect paramaters are not their default, custom state files will
		// need to be used
		for(bCustomStateFiles=FALSE, graph=0, b=0; !bCustomStateFiles && b<buckets.GetSize(); ++b)
		{
			for(e=0; !bCustomStateFiles && e<buckets[b].effects.GetSize(); ++e, ++graph)
			{
				pEffect = buckets[b].effects[e];
				if(pEffect->AreParametersModified())
					bCustomStateFiles = TRUE;
			}
		}

		// Write the state files
		if(bCustomStateFiles)
		{
			for(graph=0, b=0; bCustomStateFiles && b<buckets.GetSize(); ++b)
			{
				for(e=0; bCustomStateFiles && e<buckets[b].effects.GetSize(); ++e, ++graph)
				{
					pEffect = buckets[b].effects[e];
			
					// Generate the state ini file
					string	= file.GetFileTitle();
					ii		= string.ReverseFind('.');
					if(ii)
						string.Delete(ii, string.GetLength()-ii);
					statefile.Format(_T("%s%d%sstate.ini"), string, graph, pEffect->GetName());
					statefile.Remove(' ');
					buckets[b].stateFiles.Add(statefile);

					string.Format(_T("%s\\%s"), statePath, statefile);
					buckets[b].stateFilePaths.Add(string);

					if(!pEffect->WriteStateFile(string))
						bCustomStateFiles = FALSE;
				}
			}
		}
			
		if(bCustomStateFiles)
		{
			if(bI3DL2)
			{
				if(b24k)
					pEffect = m_pI3DL2_24K;
				else
					pEffect = m_pI3DL2;
				for(i=0; i<pEffect->GetNumConfigs(); ++i)
				{
					if(pEffect->GetConfigs()[i].name == m_i3dl2Config)
						break;
				}
				if(i == pEffect->GetNumConfigs())
					i = 0;
				string.Format(_T("%s\\%s"), GetIniFilePath(), pEffect->GetConfigs()[i].stateFilename);
				statefile.Format(_T("%s\\%s"), statePath, pEffect->GetConfigs()[i].stateFilename);
				if(!CopyFile(string, statefile, FALSE))
					bCustomStateFiles = FALSE;
				else
					SetFileAttributes(statefile, FILE_ATTRIBUTE_NORMAL);
			}

			// XTalk?
			if(m_bIncludeXtalk)
			{
				string.Format(_T("%s\\%s"), GetIniFilePath(), m_pXTalk->GetStateFilename());
				statefile.Format(_T("%s\\%s"), statePath, m_pXTalk->GetStateFilename());
				if(!CopyFile(string, statefile, FALSE))
					bCustomStateFiles = FALSE;
				else
					SetFileAttributes(statefile, FILE_ATTRIBUTE_NORMAL);
			}

			// XTalk2LFE
			if(m_bPatchXtalkToLFE)
			{
				string.Format(_T("%s\\%s"), GetIniFilePath(), m_p2x1Mixer->GetStateFilename());
				statefile.Format(_T("%s\\%s"), statePath, m_p2x1Mixer->GetStateFilename());
				CopyFile(string, statefile, FALSE);
				if(!CopyFile(string, statefile, FALSE))
					bCustomStateFiles = FALSE;
				else
					SetFileAttributes(statefile, FILE_ATTRIBUTE_NORMAL);
			}
		}

		// Was there an error generating the state ini files?
		if(!bCustomStateFiles)
		{
			// Delete them all
			for(graph=0, b=0; b<buckets.GetSize(); ++b)
			{
				for(e=0; e<buckets[b].stateFilePaths.GetSize(); ++e, ++graph)
					CFile::Remove(buckets[b].stateFilePaths[e]);
				buckets[b].stateFilePaths.RemoveAll();
				buckets[b].stateFiles.RemoveAll();
			}
		}

		for(graph=0, b=0; b<buckets.GetSize(); ++b)
		{
			for(e=0; e<buckets[b].effects.GetSize(); ++e, ++graph)
			{
				pEffect = buckets[b].effects[e];

				// I3DL2 Reverb special case
//				if(!strcmp(pEffect->GetEffectName(), _T("I3DL2 Reverb")) ||
//				   !strcmp(pEffect->GetEffectName(), _T("I3DL2 24K Reverb")))
				if(pEffect->IsI3DL2())
				{
					flag	= TRUE;
					extra	= 31;
				}
				else if(!strcmp(pEffect->GetEffectName(), _T("Simple Reverb")))
				{
					flag	= TRUE;
					extra	= 8;
				}
				else
				{
					flag	= FALSE;
					extra	= 0;
				}

				string.Format(_T("[Graph%d_FX0_%s]\n"), graph, pEffect->GetName());
				string.Remove(' ');
				file.WriteString(string);

				// Generate and save the ini name (used in parameter transmission)
				string.Format(_T("Graph%d_%s"), graph, pEffect->GetName());
				string.Remove(' ');
				pEffect->SetIniName(string);

				// If any of the outputs are to tempmixbins that have not been cleared, set mixoutput
				// to 0, otherwise set it to 0
				for(o=0; o<pEffect->GetOutputs().GetSize(); ++o)
				{
					if(pEffect->GetOutputs()[o]->GetMixbin() == INT_MAX)
					{
						if(!pbCleared[nullOutput])
						{
							file.WriteString(_T("FX_MIXOUTPUT=0\n"));
							pbCleared[nullOutput] = TRUE;
							break;
						}
					}
					else if(pEffect->GetOutputs()[o]->GetMixbin() < 0)
					{
						if(!pbCleared[-(pEffect->GetOutputs()[o]->GetMixbin() + 1)])
						{
							file.WriteString(_T("FX_MIXOUTPUT=0\n"));
							pbCleared[-(pEffect->GetOutputs()[o]->GetMixbin() + 1)] = TRUE;
							break;
						}
					}
				}
				if(o == pEffect->GetOutputs().GetSize())
					file.WriteString(_T("FX_MIXOUTPUT=1\n"));
				string.Format(_T("FX_DSPCODE=%s\n"), pEffect->GetDSPCode());
				file.WriteString(string);
				if(bCustomStateFiles)
					string.Format(_T("FX_DSPSTATE=%s\n"), buckets[b].stateFiles[e]);
				else
					string.Format(_T("FX_DSPSTATE=%s\n"), pEffect->GetStateFilename());
				file.WriteString(string);
				string.Format(_T("FX_NUMINPUTS=%d\n"), pEffect->GetInputs().GetSize());
				file.WriteString(string);
				if(flag)
					string.Format(_T("FX_NUMOUTPUTS=%d\n"), pEffect->GetOutputs().GetSize() + extra);
				else
					string.Format(_T("FX_NUMOUTPUTS=%d\n"), pEffect->GetOutputs().GetSize());
				file.WriteString(string);
				for(i=0; i<pEffect->GetInputs().GetSize(); ++i)
				{
					if(pEffect->GetInputs()[i]->GetMixbin() == INT_MAX)
						string.Format("FX_INPUT%d=GPTEMPBIN%d\n", i, nullInput);
					else if(pEffect->GetInputs()[i]->GetMixbin() >= 0)
						string.Format("FX_INPUT%d=VPMIXBIN_%s\n", i, GetMixbinName(pEffect->GetInputs()[i]->GetMixbin()));
					else
						string.Format("FX_INPUT%d=GPTEMPBIN%d\n", i, -(pEffect->GetInputs()[i]->GetMixbin() + 1));
					file.WriteString(string);
				}
				for(o=0; o<pEffect->GetOutputs().GetSize(); ++o)
				{
					if(pEffect->GetOutputs()[o]->GetMixbin() == INT_MAX)
						string.Format("FX_OUTPUT%d=GPTEMPBIN%d\n", o, nullOutput);
					else if(pEffect->GetOutputs()[o]->GetMixbin() >= 0)
						string.Format("FX_OUTPUT%d=GPMIXBIN_%s\n", o, GetMixbinName(pEffect->GetOutputs()[o]->GetMixbin()));
					else
						string.Format("FX_OUTPUT%d=GPTEMPBIN%d\n", o, -(pEffect->GetOutputs()[o]->GetMixbin() + 1));
					file.WriteString(string);
				}

				if(flag)
				{
					for(o=0; o<extra; ++o)
					{
						string.Format("FX_OUTPUT%d=GPTEMPBIN%d\n", o+pEffect->GetOutputs().GetSize(), o+totalTempMixbins);
						file.WriteString(string);
					}
				}

				file.WriteString(_T("\n"));
				++dwEffectIndex;
			}
		}

		// FX index for special additions below
		e = 0;

		// Special I3DL2 Reverb
		if(bI3DL2)
		{
			if(b24k)
			{
				string.Format(_T("[Graph%d_FX%d_I3DL2Reverb24K]\n"), graph, e++);
				pEffect = m_pI3DL2_24K;
			}
			else
			{
				string.Format(_T("[Graph%d_FX%d_I3DL2Reverb]\n"), graph, e++);
				pEffect = m_pI3DL2;
			}
			file.WriteString(string);
			file.WriteString(_T("FX_MIXOUTPUT=1\n"));
			string.Format(_T("FX_DSPCODE=%s\n"), pEffect->GetDSPCode());
			file.WriteString(string);
			for(i=0; i<pEffect->GetNumConfigs(); ++i)
			{
				if(pEffect->GetConfigs()[i].name == m_i3dl2Config)
					break;
			}
			if(i == pEffect->GetNumConfigs())
				i = 0;
			string.Format(_T("FX_DSPSTATE=%s\n"), pEffect->GetConfigs()[i].stateFilename);
			file.WriteString(string);
			file.WriteString(_T("FX_NUMINPUTS=2\n"));
			file.WriteString(_T("FX_NUMOUTPUTS=35\n"));
			file.WriteString("FX_INPUT0=VPMIXBIN_I3DL2SEND\n");
			file.WriteString("FX_INPUT1=VPMIXBIN_I3DL2SEND\n");
			file.WriteString("FX_OUTPUT0=GPMIXBIN_XTLK_FL\n");
			file.WriteString("FX_OUTPUT1=GPMIXBIN_XTLK_FR\n");
			file.WriteString("FX_OUTPUT2=GPMIXBIN_XTLK_BL\n");
			file.WriteString("FX_OUTPUT3=GPMIXBIN_XTLK_BR\n");
			for(o=0; o<31; ++o)
			{
				string.Format("FX_OUTPUT%d=GPTEMPBIN%d\n", o+4, o);
				file.WriteString(string);
			}
			file.WriteString(_T("\n"));
			m_dwI3DL2Index = dwEffectIndex++;
		}

		// XTalk?
		if(m_bIncludeXtalk)
		{
			string.Format(_T("[Graph%d_FX%d_XTalk]\n"), graph, e++);
			file.WriteString(string);
			file.WriteString(_T("FX_MIXOUTPUT=1\n"));
			string.Format(_T("FX_DSPCODE=%s\n"), m_pXTalk->GetDSPCode());
			file.WriteString(string);
			string.Format(_T("FX_DSPSTATE=%s\n"), m_pXTalk->GetStateFilename());
			file.WriteString(string);
			file.WriteString(_T("FX_NUMINPUTS=4\n"));
			file.WriteString(_T("FX_NUMOUTPUTS=4\n"));
			file.WriteString(_T("FX_INPUT0=VPMIXBIN_XTLK_FL\n"));
			file.WriteString(_T("FX_INPUT1=VPMIXBIN_XTLK_FR\n"));
			file.WriteString(_T("FX_INPUT2=VPMIXBIN_XTLK_BL\n"));
			file.WriteString(_T("FX_INPUT3=VPMIXBIN_XTLK_BR\n"));
			file.WriteString(_T("FX_OUTPUT0=GPMIXBIN_FRONTLEFT\n"));
			file.WriteString(_T("FX_OUTPUT1=GPMIXBIN_FRONTRIGHT\n"));
			file.WriteString(_T("FX_OUTPUT2=GPMIXBIN_BACKLEFT\n"));
			file.WriteString(_T("FX_OUTPUT3=GPMIXBIN_BACKRIGHT\n"));
			file.WriteString(_T("\n"));
			m_dwXTalkIndex = dwEffectIndex++;
		}

		// XTalk2LFE
		if(m_bPatchXtalkToLFE)
		{
			string.Format(_T("[Graph%d_FX%d_XTalk2LFE_A]\n"), graph, e++);
			pEffect = m_p2x1Mixer;
			file.WriteString(string);
			file.WriteString(_T("FX_MIXOUTPUT=1\n"));
			string.Format(_T("FX_DSPCODE=%s\n"), pEffect->GetDSPCode());
			file.WriteString(string);
			string.Format(_T("FX_DSPSTATE=%s\n"), pEffect->GetStateFilename());
			file.WriteString(string);
			file.WriteString(_T("FX_NUMINPUTS=2\n"));
			file.WriteString(_T("FX_NUMOUTPUTS=1\n"));
			file.WriteString("FX_INPUT0=GPMIXBIN_XTLK_FL\n");
			file.WriteString("FX_INPUT1=GPMIXBIN_XTLK_FR\n");
			file.WriteString("FX_OUTPUT0=GPMIXBIN_LFE\n");
			file.WriteString(_T("\n"));

			string.Format(_T("[Graph%d_FX%d_XTalk2LFE_B]\n"), graph, e++);
			pEffect = m_p2x1Mixer;
			file.WriteString(string);
			file.WriteString(_T("FX_MIXOUTPUT=1\n"));
			string.Format(_T("FX_DSPCODE=%s\n"), pEffect->GetDSPCode());
			file.WriteString(string);
			string.Format(_T("FX_DSPSTATE=%s\n"), pEffect->GetStateFilename());
			file.WriteString(string);
			file.WriteString(_T("FX_NUMINPUTS=2\n"));
			file.WriteString(_T("FX_NUMOUTPUTS=1\n"));
			file.WriteString("FX_INPUT0=GPMIXBIN_XTLK_BL\n");
			file.WriteString("FX_INPUT1=GPMIXBIN_XTLK_BR\n");
			file.WriteString("FX_OUTPUT0=GPMIXBIN_LFE\n");
			file.WriteString(_T("\n"));
		}
	}
	catch (CFileException ex)
	{
		AfxMessageBox(CString(_T("Error writing DSP Image File: ")) + file.GetFilePath(), MB_OK | MB_ICONERROR);
		if(pbCleared)
			delete [] pbCleared;
		return FALSE;
	}

	// Free resources
	if(pbCleared)
		delete [] pbCleared;

	// Get the filename and close the file
	string = file.GetFilePath();
	file.Close();

	// Now that the .ini file has been written, compile it...

	// Set the paths
	if(bCustomStateFiles)
		m_imageBuilder->SetIniPath(statePath);
	else
		m_imageBuilder->SetIniPath(m_iniPath);
	m_imageBuilder->SetDspCodePath(m_dspCodePath);

	// Build the argument list for CDspImageBuilder
	argv[0] = new char [11];
	strcpy(argv[0], "dspbuilder");

	argv[1] = new char [(unsigned)string.GetLength()+1];
	strcpy(argv[1], (LPCTSTR)string);

	string.Replace(_T(".ini"), _T(".bin"));
	argv[2] = new char [(unsigned)string.GetLength()+1];
	strcpy(argv[2], (LPCTSTR)string);
		
	string.Replace(_T(".bin"), _T(".h"));
	argv[3] = new char [(unsigned)string.GetLength()+1];
	strcpy(argv[3], (LPCTSTR)string);

	m_imageBuilder->ClearText();
    err = m_imageBuilder->ParseCommandLine(4, argv);

	// Free the argument list
	delete [] argv[0];
	delete [] argv[1];
	delete [] argv[2];
	delete [] argv[3];

    if (err != ERROR_SUCCESS) 
        return FALSE;
    
    // Parse the actual file and assemble the dsp image
    err = m_imageBuilder->ParseInputFile();
    if (err != ERROR_SUCCESS) 
	{
		m_imageBuilder->ShowDialog();
		AfxMessageBox(_T("Failed parsing input file"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    // Parsing complete.
	// at this point we should have Graphs created with an array of FX in each
	// the next step is to validate the FX chain and claculate the resource reqs
	err = m_imageBuilder->ValidateFxGraphs();
    if (err != ERROR_SUCCESS) 
	{
		m_imageBuilder->ShowDialog();
		//AfxMessageBox(_T("Validation of FX chains returned error"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    err = m_imageBuilder->BuildDspImage();
    if (err != ERROR_SUCCESS) 
	{
		m_imageBuilder->ShowDialog();
		//AfxMessageBox(_T("Failed to created DSP image"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

    err = m_imageBuilder->CreateEnumHeader();
    if (err != ERROR_SUCCESS) 
	{
		m_imageBuilder->ShowDialog();
		//AfxMessageBox(_T("Failed to created C Language enumeration header"), MB_OK | MB_ICONERROR);
        return FALSE;
    }

	// Display any messages
	m_imageBuilder->ShowDialog();

	// Workaround a CDspImageBuilder bug:
	delete m_imageBuilder;
	m_imageBuilder = new CWinDspImageBuilder;

	m_bImageSaved	= TRUE;
	m_bChangesMade	= FALSE;

	// Resave the file to update ini names and indices
	Save(NULL);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CGraph::DoesModuleDependOnModule
//------------------------------------------------------------------------------
BOOL 
CGraph::DoesModuleDependOnModule(
								 IN const CModule*	pM0,
								 IN const CModule*	pM1
								 )
/*++

Routine Description:

	Tests to see if module pE0 depends on pE1. A dependency exists if any input
	of pE0 can be traced to an output (possibly through other modules) of pE1.

Arguments:

	IN pM0 -	Module to lookup
	IN pM1 -	Module to attempt to trace to

ReturnValue:

	TRUE if pE0 depends on pE1, FALSE otherwise

--*/
{
	int	i;
	int	o;

	for(i=0; i<pM0->GetInputs().GetSize(); ++i)
	{
		for(o=0; o<pM1->GetOutputs().GetSize(); ++o)
		{
			if(CanJackBeRoutedToJack(pM0->GetInputs()[i], pM1->GetOutputs()[o]))
				return TRUE;
		}
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CGraph::CanJackBeRoutedToJack
//------------------------------------------------------------------------------
BOOL
CGraph::CanJackBeRoutedToJack(
							  IN CJack*			pJack0,
							  IN const CJack*	pJack1
							  )
/*++

Routine Description:

	Determines if one jack is connected to another even through other effects

Arguments:

	IN pJack0 -	First jack
	IN pJack1 -	Second jack

Return Value:

	TRUE if a route can be traced between the, FALSE otherwise

--*/
{
	int						i;
	CArray<CJack*, CJack*>	connections;

	// Get the connections list
	pJack0->GetAllConnections(connections);

	// Are they connected?
	for(i=0; i<connections.GetSize(); ++i)
	{
		if(connections[i] == pJack1)
			return TRUE;
	}

	// 
	return FALSE;
}

//------------------------------------------------------------------------------
//	CGraph::GetMixbinName
//------------------------------------------------------------------------------
LPCTSTR 
CGraph::GetMixbinName(
					  IN int mixbin
					  ) const
/*++

Routine Description:

	Returns an xgpimage friendly mixbin name

Arguments:

	IN mixbin -	Mixbin index

Return Value:

	mixbin name

--*/
{
	switch(mixbin)
	{
	case 0:
		return _T("FRONTLEFT");
	case 1:
		return _T("FRONTRIGHT");
	case 2:
		return _T("CENTER");
	case 3:
		return _T("LFE");
	case 4:
		return _T("BACKLEFT");
	case 5:
		return _T("BACKRIGHT");
	case 6:
		return _T("XTLK_FL");
	case 7:
		return _T("XTLK_FR");
	case 8:
		return _T("XTLK_BL");
	case 9:
		return _T("XTLK_BR");
	case 10:
		return _T("I3DL2SEND");
	case 11:
		return _T("FXSEND0");
	case 12:
		return _T("FXSEND1");
	case 13:
		return _T("FXSEND2");
	case 14:
		return _T("FXSEND3");
	case 15:
		return _T("FXSEND4");
	case 16:
		return _T("FXSEND5");
	case 17:
		return _T("FXSEND6");
	case 18:
		return _T("FXSEND7");
	case 19:
		return _T("FXSEND8");
	case 20:
		return _T("FXSEND9");
	case 21:
		return _T("FXSEND10");
	case 22:
		return _T("FXSEND11");
	case 23:
		return _T("FXSEND12");
	case 24:
		return _T("FXSEND13");
	case 25:
		return _T("FXSEND14");
	case 26:
		return _T("FXSEND15");
	case 27:
		return _T("FXSEND16");
	case 28:
		return _T("FXSEND17");
	case 29:
		return _T("FXSEND18");
	case 30:
		return _T("FXSEND19");
	default:
		break;
	}
	return _T("Unknown");
}

//------------------------------------------------------------------------------
//	CGraph::SetInUse
//------------------------------------------------------------------------------
void 
CGraph::SetInUse(void)
/*++

Routine Description:

	Adjusts the list of in use mixbins

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	// Clear the inuse array
	for(i=0; i<m_inputMixbinInUse.GetSize(); ++i)
		m_inputMixbinInUse[i] = FALSE;
	for(i=0; i<m_outputMixbinInUse.GetSize(); ++i)
		m_outputMixbinInUse[i] = FALSE;

	// Set the in use flags
	for(i=0; i<m_modules.GetSize(); ++i)
	{
		if(m_modules[i]->GetType() == CModule::INPUT_MIXBIN)
			m_inputMixbinInUse[m_modules[i]->GetMixbin()] = TRUE;
		else if(m_modules[i]->GetType() == CModule::OUTPUT_MIXBIN)
			m_outputMixbinInUse[m_modules[i]->GetMixbin()] = TRUE;
	}
}

//------------------------------------------------------------------------------
//	CGraph::TraceAndBuildPatchCord
//------------------------------------------------------------------------------
void
CGraph::TraceAndBuildPatchCord(
							   IN int	x,
							   IN int	y
							   )
/*++

Routine Description:

	Traces a cell based patch cord and builds a real patch cord

Arguments:

	IN x -			X coordinate on grid
	IN y -			Y coordinate on grid

Return Value:

	None

--*/
{
	CPatchCord*				pPatchCord;
	CArray<CPoint, CPoint&>	points;
	CPoint					point;

	if(!m_pGrid)
		return;

	// Is it part of a module
	if(m_pGrid[CI(x,y)].pModule)
	{
		// Is this an output?
		if(m_pGrid[CI(x,y)].bRight)
		{
			// Is the cell to the right valid?
			// Is the cell on the right patched to this output?
			// Has the patchcord for the cell to the right not been generated?
			if((x < (m_gridWidth-1)) &&  (m_pGrid[CI(x+1, y)].bLeft) &&  (!m_pGrid[CI(x+1, y)].pPatchCordLeft))
			{
				// Create a patch cord for the right cell
				pPatchCord = new CPatchCord;

				// Add a patchord to the beginning
				m_pGrid[CI(x,y)].pModule->GetOutputs()[m_pGrid[CI(x,y)].index]->Connect(pPatchCord, FALSE);

				// Add an endpoint
				point.x = (x+2) * SCALE;
				point.y	= ((y+1) * SCALE) + (SCALE/2);
				points.Add(point);

				// Trace and mark the remainder of this patch cord
				TraceAndMarkPatchCord(x+1, y, pPatchCord, CGraph::LEFT, points);
				pPatchCord->SetPoints(points);
				points.RemoveAll();
			}
		}

		// Input
		else if(m_pGrid[CI(x,y)].bLeft)
		{
			// Is the left cell valid?
			// Is the left cell patched to this?
			// Has a patch cord not been generated for the left cell?
			if((x > 0) && (m_pGrid[CI(x-1, y)].bRight) &&  (!m_pGrid[CI(x-1, y)].pPatchCordRight))
			{
				// Create a patch cord for the right cell
				pPatchCord = new CPatchCord;

				// Add a patchord to the beginning
				m_pGrid[CI(x,y)].pModule->GetInputs()[m_pGrid[CI(x,y)].index]->Connect(pPatchCord, FALSE);

				// Add an endpoint
				point.x	= ((x+1) * SCALE) - 1;
				point.y	= ((y+1) * SCALE) + (SCALE/2);
				points.Add(point);

				// Trace and mark the remainder of this patch cord
				TraceAndMarkPatchCord(x-1, y, pPatchCord, CGraph::RIGHT, points);
				pPatchCord->SetPoints(points);
				points.RemoveAll();
			}
		}
	}

	// Or a junction
	else if(m_pGrid[CI(x,y)].bJoined)
	{
		point.x	= ((x+1) * SCALE) + (SCALE/2);
		point.y	= ((y+1) * SCALE) + (SCALE/2);

		// Patch Left?
		// Not patched yet?
		// Valid patch to left?
		if(m_pGrid[CI(x,y)].bLeft && !m_pGrid[CI(x,y)].pPatchCordLeft && (x > 0) && m_pGrid[CI(x-1, y)].bRight)
		{
			m_pGrid[CI(x,y)].bEndLeft = FALSE;

			// Create a patch cord for the right cell
			pPatchCord = new CPatchCord;
			m_pGrid[CI(x,y)].pPatchCordLeft = pPatchCord;

			// Add an endpoint
			points.Add(point);

			// Trace and mark the remainder of this patch cord
			TraceAndMarkPatchCord(x-1, y, pPatchCord, CGraph::RIGHT, points);
			pPatchCord->SetPoints(points);
			points.RemoveAll();
		}

		// Patch Right?
		// Not patched yet?
		// Valid patch to right?
		if(m_pGrid[CI(x,y)].bRight && !m_pGrid[CI(x,y)].pPatchCordRight && (x+1 < m_gridWidth) && m_pGrid[CI(x+1, y)].bLeft)
		{
			m_pGrid[CI(x,y)].bEndRight = FALSE;

			// Create a patch cord for the right cell
			pPatchCord = new CPatchCord;
			m_pGrid[CI(x,y)].pPatchCordRight = pPatchCord;

			// Add an endpoint
			points.Add(point);

			// Trace and mark the remainder of this patch cord
			TraceAndMarkPatchCord(x+1, y, pPatchCord, CGraph::LEFT, points);
			pPatchCord->SetPoints(points);
			points.RemoveAll();
		}

		// Patch Top?
		// Not patched yet?
		// Valid patch to top?
		if(m_pGrid[CI(x,y)].bTop && !m_pGrid[CI(x,y)].pPatchCordTop && (y > 0) && m_pGrid[CI(x, y-1)].bBottom)
		{
			m_pGrid[CI(x,y)].bEndTop = FALSE;

			// Create a patch cord for the right cell
			pPatchCord = new CPatchCord;
			m_pGrid[CI(x,y)].pPatchCordTop = pPatchCord;

			// Add an endpoint
			points.Add(point);

			// Trace and mark the remainder of this patch cord
			TraceAndMarkPatchCord(x, y-1, pPatchCord, CGraph::BOTTOM, points);
			pPatchCord->SetPoints(points);
			points.RemoveAll();
		}

		// Patch Bottom?
		// Not patched yet?
		// Valid patch to bottom?
		if(m_pGrid[CI(x,y)].bBottom && !m_pGrid[CI(x,y)].pPatchCordBottom && (y+1 < m_gridHeight) && m_pGrid[CI(x, y+1)].bTop)
		{
			m_pGrid[CI(x,y)].bEndBottom = FALSE;

			// Create a patch cord for the right cell
			pPatchCord = new CPatchCord;
			m_pGrid[CI(x,y)].pPatchCordBottom = pPatchCord;

			// Add an endpoint
			points.Add(point);

			// Trace and mark the remainder of this patch cord
			TraceAndMarkPatchCord(x, y+1, pPatchCord, CGraph::TOP, points);
			pPatchCord->SetPoints(points);
			points.RemoveAll();
		}
	}
}

//------------------------------------------------------------------------------
//	CGraph::TraceAndMarkPatchCord
//------------------------------------------------------------------------------
void
CGraph::TraceAndMarkPatchCord(
							  IN int							x,
							  IN int							y,
							  IN CPatchCord*					pPatchCord,
							  IN CGraph::Direction				from,
							  IN OUT CArray<CPoint, CPoint&>&	points
							  )
/*++

Routine Description:

	Traces a cell-based patch cord and continues to build the patchcord

Arguments:

	IN x -			X location in grid
	IN y -			Y location in grid
	IN pPatchCord -	Patch cord to assign
	IN from	-		Direction travelling from
	IN points -		Points array

Return Value:

	None

--*/
{
	CPoint	center(((x+1) * SCALE) + (SCALE / 2), ((y+1) * SCALE) + (SCALE / 2));

	if(!m_pGrid)
		return;

	// Is this a module?
	if(m_pGrid[CI(x,y)].pModule)
	{
		// Can only come from the left or right
		switch(from)
		{
		case CGraph::LEFT:
			// This is not the center
			center.x	= (x+1)*SCALE;
			center.y	= ((y+1)*SCALE) + (SCALE/2);
			points.Add(center);
			m_pGrid[CI(x,y)].pModule->GetInputs()[m_pGrid[CI(x,y)].index]->Connect(pPatchCord, TRUE);
			break;

		case CGraph::RIGHT:
			// This is not the center
			center.x	= (x+2)*SCALE-1;
			center.y	= ((y+1)*SCALE) + (SCALE/2);
			points.Add(center);
			m_pGrid[CI(x,y)].pModule->GetOutputs()[m_pGrid[CI(x,y)].index]->Connect(pPatchCord, TRUE);
			break;
		case CGraph::TOP:
		case CGraph::BOTTOM:
		default:
			break;
		}
		return;
	}

	switch(from)
	{
	case CGraph::LEFT:
		if(!m_pGrid[CI(x,y)].bLeft)
			return;

		m_pGrid[CI(x,y)].pPatchCordLeft = pPatchCord;

		if(m_pGrid[CI(x,y)].bJoined)
		{
			m_pGrid[CI(x,y)].bEndLeft = TRUE;
			points.Add(center);
			return;
		}
		else if(m_pGrid[CI(x,y)].bRight)
		{
			m_pGrid[CI(x,y)].pPatchCordRight = pPatchCord;
			if((x+1 < m_gridWidth) && (m_pGrid[CI(x+1, y)].bLeft))
				TraceAndMarkPatchCord(x+1, y, pPatchCord, LEFT, points);
			else
				points.Add(center);
		}
		else if(m_pGrid[CI(x,y)].bTop)
		{
			m_pGrid[CI(x,y)].pPatchCordTop = pPatchCord;
			points.Add(center);
			if((y-1 >= 0) && (m_pGrid[CI(x, y-1)].bBottom))
				TraceAndMarkPatchCord(x, y-1, pPatchCord, BOTTOM, points);
		}
		else if(m_pGrid[CI(x,y)].bBottom)
		{
			m_pGrid[CI(x,y)].pPatchCordBottom = pPatchCord;
			points.Add(center);
			if((y+1 < m_gridHeight) && (m_pGrid[CI(x, y+1)].bTop))
				TraceAndMarkPatchCord(x, y+1, pPatchCord, TOP, points);
		}
		else
			points.Add(center);
		break;

	case CGraph::RIGHT:
		if(!m_pGrid[CI(x,y)].bRight)
			return;

		m_pGrid[CI(x,y)].pPatchCordRight = pPatchCord;

		if(m_pGrid[CI(x,y)].bJoined)
		{
			m_pGrid[CI(x,y)].bEndRight = TRUE;
			points.Add(center);
			return;
		}
		else if(m_pGrid[CI(x,y)].bLeft)
		{
			m_pGrid[CI(x,y)].pPatchCordLeft = pPatchCord;
			if((x-1 >= 0) && (m_pGrid[CI(x-1, y)].bRight))
				TraceAndMarkPatchCord(x-1, y, pPatchCord, RIGHT, points);
			else
				points.Add(center);
		}
		else if(m_pGrid[CI(x,y)].bTop)
		{
			m_pGrid[CI(x,y)].pPatchCordTop = pPatchCord;
			points.Add(center);
			if((y-1 >= 0) && (m_pGrid[CI(x, y-1)].bBottom))
				TraceAndMarkPatchCord(x, y-1, pPatchCord, BOTTOM, points);
		}
		else if(m_pGrid[CI(x,y)].bBottom)
		{
			m_pGrid[CI(x,y)].pPatchCordBottom = pPatchCord;
			points.Add(center);
			if((y+1 < m_gridHeight) && (m_pGrid[CI(x, y+1)].bTop))
				TraceAndMarkPatchCord(x, y+1, pPatchCord, TOP, points);
		}
		else
			points.Add(center);
		break;

	case CGraph::TOP:
		if(!m_pGrid[CI(x,y)].bTop)
			return;

		m_pGrid[CI(x,y)].pPatchCordTop = pPatchCord;

		if(m_pGrid[CI(x,y)].bJoined)
		{
			m_pGrid[CI(x,y)].bEndTop = TRUE;
			points.Add(center);
			return;
		}
		else if(m_pGrid[CI(x,y)].bBottom)
		{
			m_pGrid[CI(x,y)].pPatchCordBottom = pPatchCord;
			if((y+1 < m_gridHeight) && (m_pGrid[CI(x, y+1)].bTop))
				TraceAndMarkPatchCord(x, y+1, pPatchCord, TOP, points);
			else
				points.Add(center);
		}
		else if(m_pGrid[CI(x,y)].bLeft)
		{
			m_pGrid[CI(x,y)].pPatchCordLeft = pPatchCord;
			points.Add(center);
			if((x-1 >= 0) && (m_pGrid[CI(x-1, y)].bRight))
				TraceAndMarkPatchCord(x-1, y, pPatchCord, RIGHT, points);
		}
		else if(m_pGrid[CI(x,y)].bRight)
		{
			m_pGrid[CI(x,y)].pPatchCordRight = pPatchCord;
			points.Add(center);
			if((x+1 < m_gridWidth) && (m_pGrid[CI(x+1, y)].bLeft))
				TraceAndMarkPatchCord(x+1, y, pPatchCord, LEFT, points);
		}
		else
			points.Add(center);
		break;

	case CGraph::BOTTOM:
		if(!m_pGrid[CI(x,y)].bBottom)
			return;

		m_pGrid[CI(x,y)].pPatchCordBottom = pPatchCord;

		if(m_pGrid[CI(x,y)].bJoined)
		{
			m_pGrid[CI(x,y)].bEndBottom = TRUE;
			points.Add(center);
			return;
		}
		else if(m_pGrid[CI(x,y)].bTop)
		{
			m_pGrid[CI(x,y)].pPatchCordTop = pPatchCord;
			if((y-1 >= 0) && (m_pGrid[CI(x, y-1)].bBottom))
				TraceAndMarkPatchCord(x, y-1, pPatchCord, BOTTOM, points);
			else
				points.Add(center);
		}
		else if(m_pGrid[CI(x,y)].bLeft)
		{
			m_pGrid[CI(x,y)].pPatchCordLeft = pPatchCord;
			points.Add(center);
			if((x-1 >= 0) && (m_pGrid[CI(x-1, y)].bRight))
				TraceAndMarkPatchCord(x-1, y, pPatchCord, RIGHT, points);
		}
		else if(m_pGrid[CI(x,y)].bRight)
		{
			m_pGrid[CI(x,y)].pPatchCordRight = pPatchCord;
			points.Add(center);
			if((x+1 < m_gridWidth) && (m_pGrid[CI(x+1, y)].bLeft))
				TraceAndMarkPatchCord(x+1, y, pPatchCord, LEFT, points);
		}
		else
			points.Add(center);
		break;
	default:
		break;
	}
}

//------------------------------------------------------------------------------
//	CGraph::OnLButtonDown
//------------------------------------------------------------------------------
void
CGraph::OnLButtonDown(
					  IN UINT			nFlags,
					  IN const CPoint&	point
					  )
/*++

Routine Description:

	Left mouse down:
		Select Module
		Drag Module
		Draw Patch Cord
		Connect / Disconnect Patch Cord
		Drop Module

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	CModule*	pModule;
	CPatchCord*	pPatchCord;
	CJack*		pJack;
	CPoint		patchPoint;

	m_bLeftMouseDown = TRUE;

	// If any other button is down besides the left mouse, ignore
	if((nFlags & MK_MBUTTON) || (nFlags & MK_RBUTTON))
		return;

	// Set the mouse position
	SetMouse(point);

	// See what was hit
	pModule		= GetModule(m_mouse);
	pPatchCord	= GetPatchCord(m_mouse);
	if(pModule)
		pJack = pModule->GetJack(m_mouse, TRUE);
	else
		pJack = NULL;

	// Drawing a complex line?
	if(m_bDrawComplexLine)
	{
		DrawPatchLine();

		// If the last two points are within 2 pixels, merge them
		if((abs(m_patchLine.points[m_patchLine.points.GetSize()-1].x -
				m_patchLine.points[m_patchLine.points.GetSize()-2].x) <= 2) &&
		   (abs(m_patchLine.points[m_patchLine.points.GetSize()-1].y -
				m_patchLine.points[m_patchLine.points.GetSize()-2].y) <= 2))
		{
			m_patchLine.points.RemoveAt(m_patchLine.points.GetSize()-1);
		}

		// Was the click over a module?
		if(pModule)
		{
			m_bDrawComplexLine	= FALSE;
			m_bStartDrawLine	= FALSE;

			// Was a jack hit?
			if(pJack)
				NewPatchCord();
		}

		// Or was it over a patch cord?
		else if(pPatchCord)
		{
			m_bDrawComplexLine	= FALSE;
			m_bStartDrawLine	= FALSE;

			NewPatchCord();
		}

		// Otherwise, just keep adding points
		else
		{
			// Add one more points
			m_patchLine.points.Add(m_mouse);
			DrawPatchLine();
		}
	}

	// Insert an effect?
	else if(m_bInsertModules)
		DropModules();

	// Move a module?
	else if(pModule)
	{
		// Was a patch on the module selected?
		if(pJack)
		{
			// Clear the line
			m_patchLine.points.RemoveAll();

			if(pJack->GetInput())
			{
				m_patchLine.firstPatchEnd	= CGraph::PATCHEND_INPUT;
				patchPoint.x				= pModule->GetRect().left;
				patchPoint.y				= pJack->GetY();
			}
			else
			{
				m_patchLine.firstPatchEnd	= CGraph::PATCHEND_OUTPUT;
				patchPoint.x				= pModule->GetRect().right;
				patchPoint.y				= pJack->GetY();
			}

			m_patchLine.lastPatchEnd	= m_patchLine.firstPatchEnd;
			m_patchLine.pFirstJack		= pJack;
			m_patchLine.pLastJack		= pJack;
			m_patchLine.pFirstPatchCord	= NULL;
			m_patchLine.pLastPatchCord	= NULL;
			m_patchLine.points.Add(patchPoint);
			m_patchLine.points.Add(patchPoint);
			m_patchLine.points.Add(patchPoint);

			m_bDrawLine			= TRUE;
			m_bDrawComplexLine	= TRUE;
			m_bStartDrawLine	= TRUE;
			DrawPatchLine();
		}

		// Otherwise, just pick up and move the module
		else
		{
			// Make sure the list is empty
			m_moveModules.RemoveAll();
			m_originalModules.RemoveAll();

			// Set the state
			pModule->SetState(CModule::MOVING);

			// Save the original link
			m_originalModules.Add(pModule);

			// Copy the module
			pModule = new CModule(*pModule);

			// Set the state
			pModule->SetState(CModule::MOVING);

			// Add the module to the move list
			m_moveModules.Add(pModule);
			
			// Use offsets for positioning module
			m_bUseOffset	= TRUE;
			m_offset		= m_mouse - pModule->GetRect().TopLeft();

			CalcUpperLeft(pModule);
		}
	}

	else if(pPatchCord)
	{
		// Clear the line
		m_patchLine.points.RemoveAll();

		switch(pPatchCord->GetLastPointOn())
		{
		case CPatchCord::POINTON_HORIZONTAL:
			m_patchLine.firstPatchEnd = CGraph::PATCHEND_HORIZONTAL;
			break;
		case CPatchCord::POINTON_VERTICAL:
			m_patchLine.firstPatchEnd = CGraph::PATCHEND_VERTICAL;
			break;
		case CPatchCord::POINTON_POINT:
			m_patchLine.firstPatchEnd = CGraph::PATCHEND_POINT;
			break;
		case CPatchCord::POINTON_NONE:
		default:
			break;
		}
		patchPoint = pPatchCord->GetLastPoint();

		m_patchLine.lastPatchEnd	= m_patchLine.firstPatchEnd;
		m_patchLine.pFirstJack		= NULL;
		m_patchLine.pLastJack		= NULL;
		m_patchLine.pFirstPatchCord	= pPatchCord;
		m_patchLine.pLastPatchCord	= pPatchCord;
		m_patchLine.points.Add(patchPoint);
		m_patchLine.points.Add(patchPoint);
		m_patchLine.points.Add(patchPoint);

		m_bDrawLine			= TRUE;
		m_bDrawComplexLine	= TRUE;
		m_bStartDrawLine	= TRUE;
		DrawPatchLine();
	}
}

//------------------------------------------------------------------------------
//	CGraph::OnLButtonUp
//------------------------------------------------------------------------------
void
CGraph::OnLButtonUp(
				   IN UINT,
				   IN const CPoint&	point
				   )
/*++

Routine Description:

	Left mouse up:
		Drop module

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	int		i;
	CRect	rect(0,0,0,0);

	m_bLeftMouseDown = FALSE;
	SetMouse(point);

	// Beginning of line?
	if(m_bStartDrawLine)
	{
		m_bDrawLine			= FALSE;
		m_bStartDrawLine	= FALSE;
	}

	// Dragging a patch cord?
	else if(m_bDragPatch)
	{
		CClientDC	dc(m_pParent);
		m_pDragPatch->DrawXOR(&dc);
		m_bDragPatch = FALSE;
	}

	// Drawing a complex line?
	else if(m_bDrawComplexLine)
		return;

	// Drawing a patch cord?
	else if(m_bDrawLine)
	{
		// Erase the line
		DrawPatchLine();
		m_bDrawLine			= FALSE;
		m_bStartDrawLine	= FALSE;

		NewPatchCord();
	}

	// Inserting a module? (this is new)
	else if(m_bInsertModules)
		return;

	// Was a module being moved?
	else if(m_moveModules.GetSize())
	{
		// If the mouse is out of the window, dump the modules
		if(!IsPointInRect(m_mouse.x, m_mouse.y, m_rect))
		{
			for(i=0; i<m_moveModules.GetSize(); ++i)
			{
				rect.UnionRect(rect, m_moveModules[i]->GetRect());
				delete m_moveModules[i];
			}
			m_moveModules.RemoveAll();
			Draw(rect);
			return;
		}

		// If any of the states are invalid, just dump the modules
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			if(m_moveModules[i]->GetState() == CModule::INVALID)
				break;
		}
		
		// Were there any invalid modules?
		if((i != m_moveModules.GetSize()) || (m_originalModules.GetSize() != m_moveModules.GetSize()))
		{
			for(i=0; i<m_moveModules.GetSize(); ++i)
			{
				rect.UnionRect(rect, m_moveModules[i]->GetRect());
				delete m_moveModules[i];
			}
			m_moveModules.RemoveAll();
			Draw(rect);

			// Reset all moving modules to OK
			for(i=0; i<m_modules.GetSize(); ++i)
			{
				if(m_modules[i]->GetState() == CModule::MOVING)
					m_modules[i]->SetState(CModule::OK);
			}
			return;
		}

		// Did the modules really move?
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			if(m_moveModules[i]->GetRect() != m_originalModules[i]->GetRect())
				break;
		}

		// If they did not move, don't do anything
		if(i == m_moveModules.GetSize())
		{
			// Suspend updates
			PushFreeze();

			for(i=0; i<m_moveModules.GetSize(); ++i)
			{
				rect.UnionRect(rect, m_moveModules[i]->GetRect());
				rect.UnionRect(rect, m_originalModules[i]->GetRect());
				m_originalModules[i]->SetState(CModule::OK);
				delete m_moveModules[i];
			}
			m_moveModules.RemoveAll();
			m_originalModules.RemoveAll();

			// Resume updates
			PopFreeze();

			// Redraw
			Draw(rect);
			return;
		}

		for(i=0; i<m_originalModules.GetSize(); ++i)
			m_originalModules[i]->Disconnect();

		// Suspend updates
		PushFreeze();

		// Update the draw rect
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			rect.UnionRect(rect, m_moveModules[i]->GetRect());
			rect.UnionRect(rect, m_originalModules[i]->GetRect());
		}

		// Delete all move modules
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			m_originalModules[i]->SetState(CModule::OK);
			m_originalModules[i]->SetRect(m_moveModules[i]->GetRect());
			delete m_moveModules[i];
		}

		// Clear the originals list
		m_originalModules.RemoveAll();
		m_moveModules.RemoveAll();

		// Resume updates
		PopFreeze();

		// Redraw
		Draw(rect);

		m_bChangesMade		= TRUE;

		m_pParent->UpdateScrollBars();
	}
}

//------------------------------------------------------------------------------
//	CGraph::OnRButtonDown
//------------------------------------------------------------------------------
void
CGraph::OnRButtonDown(
					 IN UINT			nFlags,
					 IN const CPoint&	point
					 )
/*++

Routine Description:

	Right Mouse down: Popup menus

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	int						i;
	int						nCmd;
	CPoint					menuPoint	= point;
	CRect					rect(0, 0, 0, 0);
	CModule*				pModule;
	CPatchCord*				pPatchCord;
	CArray<CJack*, CJack*>	jackList;

	// If any other button is down besides left mouse or any key is down, ignore
	if((nFlags & MK_MBUTTON) || (nFlags & MK_LBUTTON) || (nFlags & MK_CONTROL) ||
	   (nFlags & MK_SHIFT))
		return;

	// If a complex line was being drawn cancel it
	CancelDrawComplexLine();

	// Convert the point
	m_pParent->ClientToScreen(&menuPoint);

	// Set the mouse position
	SetMouse(point);

	// See what was hit
	pModule		= GetModule(m_mouse);
	pPatchCord	= GetPatchCord(m_mouse);

#if 1
	if(m_bInsertModules)
		DropModules();
	else
#else	// The old way
	// If modules were being moved, cancel it
	if(m_moveModules.GetSize())
	{
		for(i=0; i<m_originalModules.GetSize(); ++i)
		{
			rect.UnionRect(rect, m_originalModules[i]->GetRect());
			m_originalModules[i]->SetState(CModule::OK);
		}
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			rect.UnionRect(rect, m_moveModules[i]->GetRect());
			delete m_moveModules[i];
		}
		m_moveModules.RemoveAll();
		Draw(rect);
	}
#endif

	// Was a module hit?
	if(pModule)
	{
		if(m_bDeleteConfigMenu)
		{
			m_moduleMenu.DeleteMenu(2, MF_BYPOSITION);
			m_bDeleteConfigMenu = FALSE;
		}

		// Setup configurations
		if(pModule->GetNumConfigs() != 0)
		{
			m_configMenu.CreatePopupMenu();
			for(i=0; i<pModule->GetNumConfigs(); ++i)
				m_configMenu.AppendMenu(MF_STRING, (UINT)(-(i+1)), pModule->GetConfigs()[i].name);
			m_moduleMenu.InsertMenu(2, MF_BYPOSITION | MF_POPUP, (UINT)m_configMenu.Detach(), _T("&Configuration"));
			m_moduleMenu.EnableMenuItem(ID_EFFECTS_CONFIGS, MF_ENABLED);
			m_bDeleteConfigMenu = TRUE;
		}

		m_moduleMenu.EnableMenuItem(ID_EFFECTS_PROPERTIES, pModule->HasProperties() ? MF_ENABLED : MF_GRAYED);
		m_moduleMenu.EnableMenuItem(ID_EFFECTS_NAME, (pModule->GetMixbin() == -1) ? MF_ENABLED : MF_GRAYED);
		m_moduleMenu.EnableMenuItem(ID_EFFECTS_DISCONNECT_ALL, pModule->IsPatched() ? MF_ENABLED : MF_GRAYED);
		m_moduleMenu.EnableMenuItem(ID_EFFECTS_DISCONNECT_INPUTS, pModule->AreInputsPatched() ? MF_ENABLED : MF_GRAYED);
		m_moduleMenu.EnableMenuItem(ID_EFFECTS_DISCONNECT_OUTPUTS, pModule->AreOutputsPatched() ? MF_ENABLED : MF_GRAYED);
		nCmd = m_moduleMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | 
											TPM_RIGHTBUTTON | TPM_RETURNCMD |
											TPM_NONOTIFY,
											menuPoint.x, menuPoint.y, m_pParent);

		if(nCmd < 0)
		{
			if(pModule->GetActiveConfig() != -(nCmd+1))
			{
				m_bChangesMade		= TRUE;
				pModule->SetActiveConfig(-(nCmd+1));
				Draw(pModule->GetRect());
			}
		}
		else
		{
			switch(nCmd)
			{
			case ID_EFFECTS_PROPERTIES:
				pModule->ShowProperties();
				break;
			case ID_EFFECTS_NAME:
				pModule->SetEffectName();
				break;
			case ID_EFFECTS_DELETE:
				DeleteModule(pModule);
				break;
			case ID_EFFECTS_DISCONNECT_ALL:
				pModule->Disconnect();
				m_bChangesMade = TRUE;
				break;
			case ID_EFFECTS_DISCONNECT_INPUTS:
				pModule->DisconnectInputs();
				m_bChangesMade = TRUE;
				break;
			case ID_EFFECTS_DISCONNECT_OUTPUTS:
				pModule->DisconnectOutputs();
				m_bChangesMade = TRUE;
				break;
			default:
				break;
			}
		}
	}

	// Or was a patch cord hit?
	else if(pPatchCord)
	{
		m_patchCordMenu.EnableMenuItem(ID_PATCH_DISCONNECT, MF_ENABLED);
//		m_patchCordMenu.CheckMenuItem(ID_PATCH_OVERWRITE, pPatchCord->GetOverwrite() ? MF_CHECKED : MF_UNCHECKED);
//		m_patchCordMenu.EnableMenuItem(ID_PATCH_OVERWRITE, !pPatchCord->IsInvalid() && pPatchCord->GetOverwriteEnable() ? MF_ENABLED : MF_GRAYED);
		nCmd = m_patchCordMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | 
											  TPM_RIGHTBUTTON | TPM_RETURNCMD |
											  TPM_NONOTIFY,
											  menuPoint.x, menuPoint.y, m_pParent);
		if(nCmd == ID_PATCH_DISCONNECT)
		{
			DeletePatchCord(pPatchCord);
			m_bChangesMade = TRUE;
		}
//		else if(nCmd == ID_PATCH_OVERWRITE)
//		{
//			Draw(pPatchCord->SetOverwrite(!pPatchCord->GetOverwrite()));
//			m_bChangesMade = TRUE;
//		}
	}

	// Otherwise, popup the root menu
	else
	{
		// Setup the menu
		m_rootMenu.CheckMenuItem(ID_GRID_SHOW_GRID, 
								 m_bDrawGrid ? MF_CHECKED : MF_UNCHECKED);	
		m_rootMenu.EnableMenuItem(ID_GRID_DELETE_ALL, 
								  m_modules.GetSize() > 0 ? MF_ENABLED : MF_GRAYED);
		m_rootMenu.EnableMenuItem(ID_GRID_DISCONNECT_ALL, 
								  IsPatched() ? MF_ENABLED : MF_GRAYED);
		m_rootMenu.EnableMenuItem(ID_GRID_INSERT_EFFECT, MF_ENABLED);

		// Enable/Disable mixbin items
		EnableMixbinsOnMenu();

		// Popup the menu
		nCmd = m_rootMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | 
										 TPM_RIGHTBUTTON | TPM_RETURNCMD |
										 TPM_NONOTIFY,
										 menuPoint.x, menuPoint.y, m_pParent);

		// Show grid?
		if(nCmd == ID_GRID_SHOW_GRID)
			ToggleGrid();

		// Disconnect all patch cords?
		else if(nCmd == ID_GRID_DISCONNECT_ALL)
		{
			if(m_patchCords.GetSize())
			{
				for(i=m_patchCords.GetSize()-1; i>=0; --i)
				{
					rect.UnionRect(rect, m_patchCords[i]->GetRect());
					pPatchCord = m_patchCords[i];
					m_patchCords.RemoveAt(i);
					delete pPatchCord;
				}
				Draw(rect);
				m_bChangesMade = TRUE;
				Draw(m_rect);
			}
		}

		else if(nCmd == ID_GRID_DELETE_ALL)
		{
			if(m_modules.GetSize())
			{
				for(i=m_modules.GetSize()-1; i>=0; --i)
				{
					rect.UnionRect(rect, m_modules[i]->GetRect());
					pModule = m_modules[i];
					m_modules.RemoveAt(i);
					delete pModule;
				}
				SetInUse();
				m_bChangesMade = TRUE;
				Draw(m_rect);
			}
		}

		else
			InsertModule(point, nCmd);
	}
}

//------------------------------------------------------------------------------
//	CGraph::OnMouseMove
//------------------------------------------------------------------------------
void 
CGraph::OnMouseMove(
				   IN UINT,
				   IN const CPoint&	point
				   )
/*++

Routine Description:

	Moves a module, or draws a patch cord

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

Return Value:

	None

--*/
{
	int				i;
	CPoint			upperLeft;
	CModule*		pModule;
	CPatchCord*		pPatchCord;
	CJack*			pJack;
	CRect			rect(0, 0, 0, 0);
	CModule::State	state	= CModule::MOVING;
	int				dy		= m_bSnapToGrid ? SCALE : 3;

	// Set the mouse position
	SetMouse(point);
	
	// Has line drawing just began?
	if(m_bStartDrawLine)
	{
		if((abs(m_mouse.x - m_patchLine.points[0].x) > 2) ||
		   (abs(m_mouse.y - m_patchLine.points[0].y) > 2))
		{
			m_bStartDrawLine = FALSE;

			if(m_bLeftMouseDown)
				m_bDrawComplexLine = FALSE;
		}
	}

	// Drawing a line?
	if(m_bDrawLine || m_bDrawComplexLine)
	{
		// Clear the current line
		DrawPatchLine();

		// Where is the mouse?
		pModule		= GetModule(m_mouse);
		pPatchCord	= GetPatchCord(m_mouse);

		// Over a module?
		if(pModule)
		{
			// Over a jack?
			pJack = pModule->GetJack(m_mouse, FALSE);
			if(pJack)
				m_patchLine.lastPatchEnd = pJack->GetInput() ? CGraph::PATCHEND_INPUT : CGraph::PATCHEND_OUTPUT;
			else
				m_patchLine.lastPatchEnd = CGraph::PATCHEND_NONE;
			m_patchLine.pLastJack		= pJack;
			m_patchLine.pLastPatchCord	= NULL;
		}

		// Over a patch cord?
		else if(pPatchCord)
		{
			switch(pPatchCord->GetLastPointOn())
			{
			case CPatchCord::POINTON_HORIZONTAL:
				m_patchLine.lastPatchEnd = CGraph::PATCHEND_HORIZONTAL;
				break;
			case CPatchCord::POINTON_VERTICAL:
				m_patchLine.lastPatchEnd = CGraph::PATCHEND_VERTICAL;
				break;
			case CPatchCord::POINTON_POINT:
				m_patchLine.lastPatchEnd = CGraph::PATCHEND_POINT;
				break;
			case CPatchCord::POINTON_NONE:
			default:
				break;
			}
			m_patchLine.pLastJack		= NULL;
			m_patchLine.pLastPatchCord	= pPatchCord;
		}

		// Over nothing
		else
		{
			m_patchLine.lastPatchEnd	= CGraph::PATCHEND_NONE;
			m_patchLine.pLastJack		= NULL;
			m_patchLine.pLastPatchCord	= NULL;
		}

		UpdatePatchLine();
		DrawPatchLine();
	}

	// Drag a patch cord
	else if(m_bDragPatch)
	{
		// TODO:
	}

	// Moving modules?
	else if(m_moveModules.GetSize())
	{
		// Some calculations		
		CalcUpperLeft(m_moveModules[0]);
		upperLeft = m_upperLeft;
		
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			// Generate the current invalidation rect
			rect.UnionRect(rect, m_moveModules[i]->GetRect());

			// Move the modules
			m_moveModules[i]->Move(upperLeft);

			// Generate the new invalidation rect
			rect.UnionRect(rect, m_moveModules[i]->GetRect());

			// Check the state - any invalid state will set all to invalid
			if(m_originalModules.GetSize())
				state = IsPlacementValid(m_moveModules[i], m_originalModules[i]) ? state : CModule::INVALID;
			else
				state = IsPlacementValid(m_moveModules[i]) ? state : CModule::INVALID;

			// Adjust the position
			upperLeft.y += m_moveModules[i]->GetRect().Height() + dy;
		}

		// Update the states
		for(i=0; i<m_moveModules.GetSize(); ++i)
			m_moveModules[i]->SetState(state);

		// Draw
		Draw(rect);
	}
}

//------------------------------------------------------------------------------
//	CGraph::OnLButtonDblClk
//------------------------------------------------------------------------------
void
CGraph::OnLButtonDblClk(
					    IN UINT,
					    IN const CPoint&
					    )
/*++

Routine Description:

	Left mouse double click:
		Terminate complex patch cord drawing

Arguments:

	IN nFlags -	Flags
	IN point -	Point where mouse was clicked

ReturnValue:

	None

--*/
{
	CancelDrawComplexLine();
}

//------------------------------------------------------------------------------
//	CGraph::DropModules
//------------------------------------------------------------------------------
void
CGraph::DropModules(void)
/*++

Routine Description:

	Drops all moving modules into the graph

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	if(m_moveModules.GetSize())
	{
		// Check for an invalid module
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			if(m_moveModules[i]->GetState() == CModule::INVALID)
			{
				SetInUse();
				return;
			}
		}

		// Add the modules to the modules list
		for(i=0; i<m_moveModules.GetSize(); ++i)
		{
			m_moveModules[i]->SetState(CModule::OK);
			m_modules.Add(m_moveModules[i]);
		}
		SetInUse();

		// Clear the move list
		m_moveModules.RemoveAll();

		m_bChangesMade = TRUE;
	}

	// Set some flags
	m_bInsertModules = FALSE;
}

//------------------------------------------------------------------------------
//	CGraph::CancelDrawComplexLine
//------------------------------------------------------------------------------
void 
CGraph::CancelDrawComplexLine(void)
/*++

Routine Description:

	Cancels the drawing of a complex line

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_bDrawComplexLine)
	{
		DrawPatchLine();
		m_patchLine.points.RemoveAll();
		m_bDrawComplexLine	= FALSE;
		m_bStartDrawLine	= FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Jack.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Jack.h

Abstract:

	A jack to connect a patch cord to a module

Author:

	Robert Heitkamp (robheit) 08-Nov-2001

Revision History:

	22-Nov-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Jack.h"
#include "Module.h"
#include "Graph.h"

//------------------------------------------------------------------------------
//	CJack::CJack
//------------------------------------------------------------------------------
CJack::CJack(
			 IN CModule*	pModule
			 ) : CUnique()
/*++

Routine Description:

	Constructor

Arguments:

	IN pModule -	Module

Return Value:

	None

--*/

{
	m_pPatchCord	= new CPatchCord(this);
	m_mixbin		= 0;
	m_bInput		= FALSE;
	m_line[0].x		= 0;
	m_line[0].y		= 0;
	m_textFlag		= 0;
	m_bBadData		= FALSE;
	m_pModule		= pModule;
	m_bOverwrite	= FALSE;
	m_rect.SetRect(0,0,0,0);
}

#if 0
//------------------------------------------------------------------------------
//	CJack::CJack
//------------------------------------------------------------------------------
CJack::CJack(
			 IN const CJack&	jack
			 ) : CUnique()
/*++

Routine Description:

	Constructor

Arguments:

	IN jack -	Jack to copy

Return Value:

	None

--*/

{
	m_bBadData		= FALSE;
	m_pPatchCord	= new CPatchCord(this);
	*this			= jack;
}
#endif

//------------------------------------------------------------------------------
//	CJack::~CJack
//------------------------------------------------------------------------------
CJack::~CJack(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	delete m_pPatchCord;
}

#pragma warning(push)
#pragma warning(disable:4701)
//------------------------------------------------------------------------------
//	CJack::Draw
//------------------------------------------------------------------------------
void
CJack::Draw(
			IN CDC*	pDC
			)
/*++

Routine Description:

	Draws the jack (a simple line).

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	COLORREF	oldTextColor;
	CPen*		oldPen;
	CPen		pen;

	if(m_bOverwrite)
	{
		oldTextColor = pDC->SetTextColor(RGB(0,0,255));
		pen.CreatePen(PS_SOLID, 3, RGB(0, 0, 255));
		oldPen = (CPen*)pDC->SelectObject(&pen);
	}

	pDC->Polyline((LPPOINT)m_line, 2);
	pDC->DrawText(m_name, m_rect, m_textFlag);

	if(m_bOverwrite)
	{
		pDC->SetTextColor(oldTextColor);
		pDC->SelectObject(oldPen );
	}
}
#pragma warning(pop)

//------------------------------------------------------------------------------
//	CJack::GetPatchCord
//------------------------------------------------------------------------------
CPatchCord*
CJack::GetPatchCord(void) const
/*++

Routine Description:

	Returns the patch cord connected to the jack or NULL of one is not
	connected. A Jack can only ever have one patch cord connected.

Arguments:

	None

Return Value:

	The patch cord or NULL

--*/
{
	if(m_pPatchCord->GetPatchNode())
		return m_pPatchCord->GetPatchNode()->pPatchCord;
	return NULL;
}

//------------------------------------------------------------------------------
//	CJack::operator =
//------------------------------------------------------------------------------
CJack&
CJack::operator = (
				   IN const CJack&	jack
				   )
/*++

Routine Description:

	Assignment operator. This does not duplicated any patch cords connected
	to this or the module. The module is left alone, and the patch cords are
	cleared. The id is left alone as well.

Arguments:

	IN jack -	Jack

Return Value:

	A reference to this

--*/
{
	m_name		= jack.m_name;
	m_rect		= jack.m_rect;
	m_mixbin	= jack.m_mixbin;
	m_bInput	= jack.m_bInput;
	m_line[0]	= jack.m_line[0];
	m_line[1]	= jack.m_line[1];
	m_textFlag	= jack.m_textFlag;
	m_bBadData	= jack.m_bBadData;
	m_pPatchCord->ClearPatch();
	return *this;
}

//------------------------------------------------------------------------------
//	CJack::SetRect
//------------------------------------------------------------------------------
void
CJack::SetRect(
			   IN const CRect&	rect
			   )
/*++

Routine Description:

	Sets the rect for this and generates a horizontal line through the center

Arguments:

	IN rect -	Rect

Return Value:

	None

--*/
{
	m_rect = rect; 
	SetLine();
}

//------------------------------------------------------------------------------
//	CJack::SetInput
//------------------------------------------------------------------------------
void
CJack::SetInput(
			    IN BOOL	input
			    )
/*++

Routine Description:

	Sets the input status of the jack

Arguments:

	IN input -	TRUE for an input jack, FALSE for an output jack

Return Value:

	None

--*/
{
	m_bInput = input;
	if(m_bInput)
		m_textFlag = DT_LEFT | DT_VCENTER | DT_SINGLELINE;
	else
		m_textFlag = DT_RIGHT | DT_VCENTER | DT_SINGLELINE;
	SetLine();
}

//------------------------------------------------------------------------------
//	CJack::SetLine
//------------------------------------------------------------------------------
void
CJack::SetLine(void)
/*++

Routine Description:

	Sets the line location

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_bInput)
	{
		m_line[0].x	= m_rect.left - (SCALE / 2) - 2;
		m_line[1].x	= m_line[0].x + (SCALE / 2);
	}
	else
	{
		m_line[0].x	= m_rect.right + 2;
		m_line[1].x	= m_rect.right + (SCALE / 2) + 3;
	}
	m_line[0].y	= (m_rect.bottom - m_rect.top) / 2 + m_rect.top;
	m_line[1].y	= m_line[0].y;
}

//------------------------------------------------------------------------------
//	CJack::Connect
//------------------------------------------------------------------------------
void 
CJack::Connect(
			   IN CPatchCord*	pPatchCord, 
			   IN BOOL			bEnd
			   )
/*++

Routine Description:

	Connects a patch cord to this. This method also connects this to the 
	patch cord. 

	DO NOT CALL THIS METHOD IF THIS IS ALREADY CONNECTED.

Arguments:

	IN pPatchCord -	Patch cord to connect
	IN bEnd -		TRUE to connect this to the end of pPatchCord,
					FALSE to connect this to the beggining of pPatchCord

Return Value:

	None

--*/
{
//	ASSERT(!m_pPatchCord->IsPatched());
	m_pPatchCord->AddPatchCord(pPatchCord, TRUE); 
	pPatchCord->AddPatchCord(m_pPatchCord, bEnd); 
}

//------------------------------------------------------------------------------
//	CJack::Write
//------------------------------------------------------------------------------
void 
CJack::Write(
		     IN CFile& file
		     )
/*++

Routine Description:

	Writes the object to a file

Arguments:

	IN file -	File to write to

Return Value:

	None

--*/
{
	DWORD	id;

	try
	{
		// Write the id
		CUnique::Write(file);

		// Write the module
		id = m_pModule ? m_pModule->GetId() : 0;
		file.Write(&id, sizeof(id));

		// Write the name
		file.Write((LPCTSTR)m_name, ((unsigned)m_name.GetLength() + 1) * sizeof(TCHAR));

		// Write the patch
		m_pPatchCord->Write(file);

		// Write the rect
		file.Write((LPRECT)m_rect, sizeof(RECT));

		// mixbin
		file.Write(&m_mixbin, sizeof(m_mixbin));

		// bInput
		file.Write(&m_bInput, sizeof(m_bInput));

		// m_bOverwrite
		file.Write(&m_bOverwrite, sizeof(m_bOverwrite));

		// line
		file.Write(&m_line[0].x, sizeof(m_line[0].x));
		file.Write(&m_line[0].y, sizeof(m_line[0].y));
		file.Write(&m_line[1].x, sizeof(m_line[1].x));
		file.Write(&m_line[1].y, sizeof(m_line[1].y));

		// text flag
		file.Write(&m_textFlag, sizeof(m_textFlag));
	}
	catch(...)
	{
		throw;
	}
}

//------------------------------------------------------------------------------
//	CJack::FixPointers
//------------------------------------------------------------------------------
void 
CJack::FixPointers(
				   IN const CGraph* pGraph
				   )
/*++

Routine Description:

	Fixes pointer from a read

Arguments:

	IN pGraph -		Graph to use to correct pointers

Return Value:

	None

--*/
{
	m_pModule = pGraph->GetModuleFromId((DWORD)m_pModule);
	m_pPatchCord->FixPointers(pGraph);

	m_bBadData = FALSE;
}

//------------------------------------------------------------------------------
//	CJack::Read
//------------------------------------------------------------------------------
BOOL
CJack::Read(
			IN CFile&	file,
			IN BYTE		version
			)
/*++

Routine Description:

	Constructor. Reads from a file

Arguments:

	IN file -		File to read from
	IN version -	File version

Return Value:

	None

--*/
{
	m_bBadData = TRUE;

	// Read the id
	if(!CUnique::Read(file, version))
		return FALSE;

	// Read the module
	if(file.Read(&m_pModule, sizeof(DWORD)) != sizeof(DWORD))
		return FALSE;

	// Read the name
	if(!CGraph::ReadString(file, m_name))
		return FALSE;

	// Read the patch
	if(!m_pPatchCord->Read(file, version))
	{
		delete m_pPatchCord;
		m_pPatchCord = NULL;
		return FALSE;
	}

	// Read the rect
	if(file.Read((LPRECT)m_rect, sizeof(RECT)) != sizeof(RECT))
		return FALSE;

	// mixbin
	if(file.Read(&m_mixbin, sizeof(m_mixbin)) != sizeof(m_mixbin))
		return FALSE;

	// bInput
	if(file.Read(&m_bInput, sizeof(m_bInput)) != sizeof(m_bInput))
		return FALSE;

	if(version >= 4)
	{
		if(file.Read(&m_bOverwrite, sizeof(m_bOverwrite)) != sizeof(m_bOverwrite))
			return FALSE;
	}

	// line
	if(file.Read(&m_line[0].x, sizeof(m_line[0].x)) != sizeof(m_line[0].x))
		return FALSE;
	if(file.Read(&m_line[0].y, sizeof(m_line[0].y)) != sizeof(m_line[0].y))
		return FALSE;
	if(file.Read(&m_line[1].x, sizeof(m_line[1].x)) != sizeof(m_line[1].x))
		return FALSE;
	if(file.Read(&m_line[1].y, sizeof(m_line[1].y)) != sizeof(m_line[1].y))
		return FALSE;

	// text flag
	if(file.Read(&m_textFlag, sizeof(m_textFlag)) != sizeof(m_textFlag))
		return FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//	CJack::GetConnections
//------------------------------------------------------------------------------
void 
CJack::GetConnections(
					  IN OUT CArray<CJack*, CJack*>&	list,
					  IN BOOL							bClearList,		 // = TRUE
					  IN BOOL							bClearPatchCords // = TRUE
					  )
/*++

Routine Description:

	Builds a list of all jacks connected to this.

Arguments:

	IN OUT list -	List of jacks connected to this

Return Value:

	None

--*/
{
	// Make sure the list is clear
	if(bClearList)
		list.RemoveAll();

	if(!m_pModule)
		return;

	// Clear all patch cords
	if(bClearPatchCords)
		m_pModule->GetGraph()->MarkPatchCords(FALSE);
	m_pPatchCord->Mark(TRUE);

	// Build list
	if(m_pPatchCord->GetPatchNode())
		m_pPatchCord->GetPatchNode()->pPatchCord->GetConnections(list);

	// Clear all patch cords
	if(bClearPatchCords)
		m_pModule->GetGraph()->MarkPatchCords(FALSE);
	m_pPatchCord->Mark(FALSE);
}	

//------------------------------------------------------------------------------
//	CJack::GetAllConnections
//------------------------------------------------------------------------------
void 
CJack::GetAllConnections(
						 IN OUT CArray<CJack*, CJack*>&	list
						 )
/*++

Routine Description:

	Builds a list of all jacks connected to this, passing through effects if
	needed

Arguments:

	IN OUT list -	List of jacks connected to this

Return Value:

	None

--*/
{
	int			newSize;
	int			l;
	int			io;
	CModule*	pModule;
	int			lastSize = 0;

	// Make sure the list is clear
	list.RemoveAll();

	if(!m_pModule)
		return;

	// Clear all patch cords
	m_pModule->GetGraph()->MarkPatchCords(FALSE);
	m_pPatchCord->Mark(TRUE);

	// Build list
	if(m_pPatchCord->GetPatchNode())
		m_pPatchCord->GetPatchNode()->pPatchCord->GetConnections(list);
	while(lastSize != list.GetSize())
	{
		newSize = list.GetSize();

		// Step through all new additions to the list
		for(l=lastSize; l<newSize; ++l)
		{
			pModule = list[l]->GetModule();

			// If the connection is part of a module, parse the other connections
			if(pModule)
			{
				// Parse the outputs?
				if(list[l]->GetInput())
				{
					for(io=0; io<pModule->GetOutputs().GetSize(); ++io)
						pModule->GetOutputs()[io]->GetConnections(list, FALSE, FALSE);
				}

				// Or the inputs?
				else
				{
					for(io=0; io<pModule->GetInputs().GetSize(); ++io)
						pModule->GetInputs()[io]->GetConnections(list, FALSE, FALSE);
				}
			}
		}

		lastSize = newSize;
	}

	// Clear all patch cords
	m_pModule->GetGraph()->MarkPatchCords(FALSE);
	m_pPatchCord->Mark(FALSE);
}	

//------------------------------------------------------------------------------
//	CJack::Invalidate
//------------------------------------------------------------------------------
void 
CJack::Invalidate(void)
/*++

Routine Description:

	Invalidates all patch cords connected to this

Arguments:

	None

Return Value:

	None

--*/
{
	if(!m_pModule)
		return;

	// Clear all patch cords
	m_pModule->GetGraph()->MarkPatchCords(FALSE);
	m_pPatchCord->Mark(TRUE);

	// Build list
	if(m_pPatchCord->GetPatchNode())
		m_pPatchCord->GetPatchNode()->pPatchCord->Invalidate();

	// Clear all patch cords
	m_pModule->GetGraph()->MarkPatchCords(FALSE);
	m_pPatchCord->Mark(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Graph.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Graph.h

Abstract:

	Graph of effects

Author:

	Robert Heitkamp (robheit) 08-Nov-2001

Revision History:

	08-Nov-2001 robheit
		Initial Version

--*/
#if !defined GRAPH_H
#define GRAPH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <afxtempl.h>
#include "Freeze.h"
#include "WinDspImageBuilder.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CModule;
class CChildView;
class CPatchCord;
class CJack;

//------------------------------------------------------------------------------
//	Constants:
//------------------------------------------------------------------------------
static const BYTE	cFileVersion	= 4;

//------------------------------------------------------------------------------
//	CGraph
//------------------------------------------------------------------------------
class CGraph : public CFreeze
{
public:

	CGraph(CChildView* pParent = NULL);
	virtual ~CGraph(void);

	// Useful public methods:
	void Draw(const CRect&, CDC* pDC = NULL);
	void ToggleGrid(void);
	void DeletePatchCord(CPatchCord*);
	void SetRect(const CRect& rect);
	const CRect& GetBounds(void);
	void SetPaths(LPCTSTR pIniPath, LPCTSTR pDspCodePath);
	BOOL IsEmpty(void) const;
	BOOL New(BOOL bAllowCancel=TRUE);
	BOOL Save(LPCTSTR);
	BOOL SelectBuildOptions(void);
	BOOL Open(LPCTSTR);
	int GetDSPCycles(void) const;
	int GetYMemSize(void) const;
	int GetScratchLength(void) const;
	float GetDSPCyclesPercent(void) const;
	float GetYMemSizePercent(void) const;
//	float GetScratchLengthPercent(void) const;
	LPCTSTR GetIniFilename(void) const;
	BOOL SaveImage(void);
	BOOL IsGraphValid(void);
	void MarkPatchCords(BOOL mark);
	LPCTSTR GetBinFilename(void) const;
	LPCTSTR GetHFilename(void) const;
	void SetModuleIndex(LPCTSTR pIniName, DWORD index);
	void TransmitModuleParameters(const CModule* pModule, int index = -1) const;

	static BOOL	ReadString(CFile& file, CString& string);
	static void ShortestPath(const CJack*, const CJack*, CArray<CPatchCord*, CPatchCord*>& path);

	// Utility methods
	CPatchCord* GetPatchCordFromId(DWORD id) const;
	CModule* GetModuleFromId(DWORD id) const;
	CJack* GetJackFromId(DWORD id) const;

	// Inlined methods
	inline const CRect& GetRect(void) const { return m_rect; };
	inline BOOL IsPatched(void) const { return ((m_patchCords.GetSize() != 0) ? TRUE : FALSE); };
	inline BOOL GetShowGrid(void) const { return m_bDrawGrid; };
	inline void ToggleSnapToGrid(void) { m_bSnapToGrid = !m_bSnapToGrid; };
	inline BOOL GetSnapToGrid(void) const { return m_bSnapToGrid; };
	inline LPCTSTR GetIniFilePath(void) const { return (LPCTSTR)m_iniPath; };
	inline LPCTSTR GetDspCodePath(void) const { return (LPCTSTR)m_dspCodePath; };
	inline BOOL AreEffectsLoaded(void) const { return m_bEffectsLoaded; };
	inline BOOL GetChangesMade(void) const { return m_bChangesMade; };
//	inline void SetIncludeXtalk(BOOL bFlag) { m_bIncludeXtalk = bFlag; };
//	inline BOOL GetIncludeXtalk(void) const { return m_bIncludeXtalk; };
	inline BOOL IsImageSaved(void) const { return m_bImageSaved; };
	inline DWORD GetXTalkIndex(void) const { return m_dwXTalkIndex; };
	inline DWORD GetI3DL2Index(void) const { return m_dwI3DL2Index; };
	inline void ChangesMade(void) { m_bChangesMade = TRUE; };
	inline void SetParent(CChildView* pParent) { m_pParent = pParent; };
	inline CChildView* GetParent(void) const { return m_pParent; };

	// Mouse Handlers
	void OnLButtonDown(UINT nFlags, const CPoint& point);
	void OnRButtonDown(UINT nFlags, const CPoint& point);
	void OnLButtonUp(UINT nFlags, const CPoint& point);
	void OnMouseMove(UINT nFlags, const CPoint& point);
	void OnLButtonDblClk(UINT nFlags, const CPoint& point);

private:

	enum PatchEnd
	{
		PATCHEND_NONE,
		PATCHEND_INPUT,
		PATCHEND_OUTPUT,
		PATCHEND_HORIZONTAL,
		PATCHEND_VERTICAL,
		PATCHEND_POINT
	};

	struct PatchLine
	{
		CArray<CPoint, CPoint&>	points;
		PatchEnd				firstPatchEnd;
		PatchEnd				lastPatchEnd;
		CJack*					pFirstJack;
		CPatchCord*				pFirstPatchCord;
		CJack*					pLastJack;
		CPatchCord*				pLastPatchCord;
	};

	// This is for support of version 1 files
	struct Grid
	{
		Grid(void)
		{
			pModule				= NULL;
			bLeft				= FALSE;
			bRight				= FALSE;
			bTop				= FALSE;
			bBottom				= FALSE;
			bJoined				= FALSE;
			pPatchCordLeft		= NULL;
			pPatchCordRight		= NULL;
			pPatchCordTop		= NULL;
			pPatchCordBottom	= NULL;
			index				= -1;
			bEndLeft			= FALSE;
			bEndRight			= FALSE;
			bEndTop				= FALSE;
			bEndBottom			= FALSE;
		}

		CModule*	pModule;
		BOOL		bLeft;
		BOOL		bRight;
		BOOL		bTop;
		BOOL		bBottom;
		BOOL		bJoined;
		int			index;
		CPatchCord*	pPatchCordLeft;
		CPatchCord*	pPatchCordRight;
		CPatchCord*	pPatchCordTop;
		CPatchCord*	pPatchCordBottom;
		BOOL		bEndLeft;
		BOOL		bEndRight;
		BOOL		bEndTop;
		BOOL		bEndBottom;
	};

	enum Direction
	{
		LEFT,
		RIGHT,
		TOP,
		BOTTOM
	};

private:

	BOOL LoadEffects(void);
	void ClearEffects(void);
	void CreateMixbins(void);
	void ClearMixbins(void);
	void SetPaths(void);
	int Compare(LPCTSTR, LPCTSTR) const;
	void InsertModule(const CPoint& point, int index);
	BOOL IsPlacementValid(const CModule* pMovingModule, const CModule* pOriginalModule=NULL) const;
	BOOL IntersectRects(const CRect& rect0, const CRect& rect1) const;
	void CalcUpperLeft(const CModule* pModule);
	CModule* GetModule(const CPoint& point) const;
	void DeleteModule(CModule* pModule);
	void SetMouse(const CPoint& point);
	CPatchCord* GetPatchCord(const CPoint& point) const;
	void DrawPatchLine(void);
	CPatchCord* NewPatchCord(void);
	void UpdatePatchLine(void);
	void ValidateGraph(void);
	void SetTitle(void);
	void EnableMixbinsOnMenu(void);
	BOOL ReadVersion1(CFile& file);
	BOOL ReadVersion2or3or4(CFile& file, BYTE version);
	BOOL BuildEffectChains(LPCTSTR);
	BOOL DoesModuleDependOnModule(const CModule*, const CModule*);
	BOOL CanJackBeRoutedToJack(CJack* pJack0, const CJack* pJack1);
	LPCTSTR GetMixbinName(int mixbin) const;
	void SetInUse(void);
	void TraceAndBuildPatchCord(int x, int y);
	void TraceAndMarkPatchCord(int x, int y, CPatchCord* pPatchCord, Direction dir, 
							   CArray<CPoint, CPoint&>& points);
	void DropModules(void);
	void CancelDrawComplexLine(void);

private:

	CChildView*							m_pParent;
	CRect								m_rect;
	CRect								m_bounds;
	CMenu								m_moduleMenu;
	CMenu								m_patchCordMenu;
	CMenu								m_rootMenu;
	CMenu								m_effectMenu; 
	CMenu								m_inputMixbinMenu; 
	CMenu								m_outputMixbinMenu; 
	CMenu								m_configMenu;
	CMenu								m_inputSpeakerMenu;
	CMenu								m_inputXtalkMenu;
	CMenu								m_outputSpeakerMenu;
	CMenu								m_outputXtalkMenu;
	CArray<CModule*, CModule*&>			m_effects;
	CArray<CModule*, CModule*&>			m_inputMixbins;
	CArray<CModule*, CModule*&>			m_outputMixbins;
	CFont								m_font;
	CModule*							m_pXTalk;
	CModule*							m_pI3DL2;
	CModule*							m_pI3DL2_24K;
	CModule*							m_p2x1Mixer;
	CString								m_iniPath;
	CString								m_dspCodePath;
	BOOL								m_bEffectsLoaded;
	CArray<CPatchCord*, CPatchCord*&>	m_patchCords;
	CArray<CModule*, CModule*&>			m_modules;
	BOOL								m_bChangesMade;
	CPoint								m_mouse;
	CPoint								m_upperLeft;
	CArray<CModule*, CModule*&>			m_moveModules;
	CArray<CModule*, CModule*&>			m_originalModules;
	BOOL								m_bInsertModules;
	BOOL								m_bLeftMouseDown;
	BOOL								m_bDrawGrid;
	BOOL								m_bSnapToGrid;
	int									m_snapSize;
	BOOL								m_bDeleteConfigMenu;
	BOOL								m_bUseOffset;
	CPoint								m_offset;
	PatchLine							m_patchLine;
	BOOL								m_bDrawLine;
	BOOL								m_bDrawComplexLine;
	BOOL								m_bStartDrawLine;
	BOOL								m_bDragPatch;
	CPatchCord*							m_pDragPatch;
	CString								m_filename;
	BOOL								m_bImageSaved;
	CString								m_i3dl2Config;
	BOOL								m_bPatchXtalkToLFE;
	CArray<BOOL, BOOL>					m_inputMixbinInUse;
	CArray<BOOL, BOOL>					m_outputMixbinInUse;
	DWORD								m_dwXTalkIndex;
	DWORD								m_dwI3DL2Index;
	BOOL								m_bIncludeXtalk;
	CWinDspImageBuilder*				m_imageBuilder;
	CArray<int, int&>					m_inUse;
	Grid*								m_pGrid;
	int									m_gridWidth;
	int									m_gridHeight;
	BOOL								m_bDead;
//	BOOL								m_bDspChangesMade;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Jack.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Jack.h

Abstract:

	A jack to connect a patch cord to a module

Author:

	Robert Heitkamp (robheit) 08-Nov-2001

Revision History:

	22-Nov-2001 robheit
		Initial Version

--*/

#if !defined(AFX_JACK_H__D0FEF4C9_4354_40B5_AB83_7DD99C0E9B8C__INCLUDED_)
#define AFX_JACK_H__D0FEF4C9_4354_40B5_AB83_7DD99C0E9B8C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "PatchCord.h"
#include "Unique.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CModule;

//------------------------------------------------------------------------------
//	CJack:
//------------------------------------------------------------------------------
class CJack : public CUnique
{
public:

	CJack(CModule* pModule=NULL);
//	CJack(const CJack& jack);
	virtual ~CJack(void);

	void Draw(CDC*);
	CPatchCord* GetPatchCord(void) const;
	void SetRect(const CRect& rect);
	void SetInput(BOOL bInput);
	void Connect(CPatchCord* pPatchCord, BOOL bEnd);
	virtual void Write(CFile&); // throw(CFileException);
	void FixPointers(const CGraph* pGraph);
	virtual BOOL Read(CFile& file, BYTE version);
	void GetConnections(CArray<CJack*, CJack*>& list, BOOL bClearList = TRUE, 
						BOOL bClearPatchCords = TRUE);
	void GetAllConnections(CArray<CJack*, CJack*>& list);
						
	void Invalidate(void);

	inline BOOL IsPatched(void) const { return m_pPatchCord->IsPatched(); };
	inline CModule* GetModule(void) const { return m_pModule; };
//	inline void SetModule(CModule* pModule) { m_pModule = pModule; };
	inline void SetName(LPCTSTR pName) { m_name = pName; };
//	inline const CString& GetName(void) const { return m_name; };
//	inline const CRect& GetRect(void) const { return m_rect; };
	inline void SetMixbin(int mixbin) { m_mixbin = mixbin; };
	inline int GetMixbin(void) const { return m_mixbin; };
	
	inline BOOL GetInput(void) const { return m_bInput; };
//	inline void Disconnect(void) { m_pPatchCord->ClearPatch(); };
	inline int GetY(void) const { return m_line[0].y; };
	inline CPatchCord* GetOwnPatchCord(void) const { return m_pPatchCord; };
	inline void SetOverwrite(BOOL bFlag) { m_bOverwrite = bFlag; };
	inline BOOL GetOverwrite(void) const { return m_bOverwrite; };

	// Operators
	CJack& operator = (const CJack&);

private:

	void SetLine(void);

private:

	CModule*	m_pModule;
	CString		m_name;
	CPatchCord*	m_pPatchCord;
	CRect		m_rect;
	int			m_mixbin; // Negative is a temp mixbin
	BOOL		m_bInput;
	CPoint		m_line[2];
	UINT		m_textFlag;
	BOOL		m_bBadData;
	BOOL		m_bOverwrite;
};

#endif // !defined(AFX_JACK_H__D0FEF4C9_4354_40B5_AB83_7DD99C0E9B8C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Knob.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Knob.cpp

Abstract:

	Graphical knob control.

	The layout of angles is as follows

           180
            |
            |
            |
	90 -----+----- 270
            |
            |
            |
            0
Author:

	Robert Heitkamp (robheit) 30-Nov-2001

Revision History:

	30-Nov-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <math.h>
#include "resource.h"
#include "Knob.h"
#include "Module.h"

//------------------------------------------------------------------------------
//	Stuff
//------------------------------------------------------------------------------
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------------------------
//	Macros:
//------------------------------------------------------------------------------
#define MAX(a,b) (((a) >= (b)) ? (a) : (b))

//------------------------------------------------------------------------------
//	Constants
//------------------------------------------------------------------------------
const double cPi		= 3.14159265359;
const double cTwoPi		= cPi * 2.0;

//------------------------------------------------------------------------------
//	Message Map
//------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CKnob, CStatic)
	//{{AFX_MSG_MAP(CKnob)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_SYSCOLORCHANGE()
	ON_EN_CHANGE(1, OnEditChange)
	ON_EN_KILLFOCUS(1, OnEditLoseFocus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------------
//	CKnob::CKnob
//------------------------------------------------------------------------------
CKnob::CKnob(void) : CStatic()
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	HFONT	font;

	m_name				= _T("Knob");
	m_mode				= CKnob::CONTINUOUS;
	m_dataType			= CKnob::TYPE_DOUBLE;
	m_increment			= 0.0;
	m_format			= _T("%.2lf");
	m_radius			= 0.0;
	m_bLeftMouseDown	= FALSE;
	m_pEdit				= NULL;
	m_backgroundColor	= RGB(255,0,0);
	m_minAngle			= 30.0 * cPi / 180.0;
	m_maxAngle			= 330.0 * cPi / 180.0;
	m_textColor			= GetSysColor(COLOR_BTNTEXT);
	m_minPos			= 0.0;
	m_maxPos			= 1.0;
	m_pos				= m_minPos;
	m_lastPos			= m_pos;
	m_default			= 0.0;
	m_angle				= PositionToAngle(m_pos);
	m_bAtomic			= TRUE;
	m_pParent			= NULL;
	m_index				= -1;
	m_bRealtime			= FALSE;

	font = CreateFont(15, 0, 0, 0, 0, 0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
					  PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, 
					  "MS Sans Serif");
	m_font.Attach(font);
}

//------------------------------------------------------------------------------
//	CKnob::CKnob
//------------------------------------------------------------------------------
CKnob::CKnob(
			 IN CModule*	pParent,
			 IN int			index,
			 IN LPCTSTR		pName,
			 IN BOOL		bAtomic,
			 IN DataType	type,
			 IN double		min,
			 IN double		max,
			 IN	double		pos,
			 IN double		def,
			 IN LPCTSTR		pFormat,
			 IN LPCTSTR		pUnits,
			 IN CKnob::Mode	mode,
			 IN double		increment
			 ) : CStatic()
/*++

Routine Description:

	Constructor

Arguments:

	IN pParent -	Parent module
	IN index -		Index (ID)
	IN pName -		Name of knob
	IN bAtomic -	TRUE if the knob is atomic (can be adjusted in realtime)
	IN type -		Type of the data
	IN min -		Min value of the data
	IN max -		Max value of the data
	IN pos -		Current position (min - max)
	IN def -		Default position (min - max)
	IN pFormat -	Format for the data display
	IN pUnits -		Units of the data
	IN mode -		Mode of operation
	IN increment -	Used for DISCRETE mode

Return Value:

	None

--*/
{
	HFONT	font;

	m_pParent			= pParent;
	m_index				= index;
	m_name				= pName;
	m_mode				= mode;
	m_bAtomic			= bAtomic;
	m_dataType			= type;
	m_increment			= increment;
	m_format			= pFormat;
	m_units				= pUnits;
	m_radius			= 0.0;
	m_bLeftMouseDown	= FALSE;
	m_pEdit				= NULL;
	m_backgroundColor	= RGB(255,0,0);
	m_minAngle			= 30.0 * cPi / 180.0;
	m_maxAngle			= 330.0 * cPi / 180.0;
	m_textColor			= GetSysColor(COLOR_BTNTEXT);
	m_bRealtime			= FALSE;

	font = CreateFont(15, 0, 0, 0, 0, 0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
					  PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, 
					  "MS Sans Serif");
	m_font.Attach(font);

	// Min and max
	if(min <= max)
	{
		m_minPos	= min;
		m_maxPos	= max;
	}
	else
	{
		m_minPos	= max;
		m_maxPos	= min;
	}

	// Position
	if(pos < m_minPos)
		m_pos = m_minPos;
	else if(pos > m_maxPos)
		m_pos = m_maxPos;
	else
		m_pos = pos;

	m_lastPos	= m_pos;
	m_default	= def;

	// Angle
	m_angle = PositionToAngle(m_pos);

	// Adjust units - remove "None"
	if(!m_units.CompareNoCase(_T("none")))
		m_units.Empty();
}

//------------------------------------------------------------------------------
//	CKnob::~CKnob
//------------------------------------------------------------------------------
CKnob::~CKnob(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_knobBitmap.DeleteObject();
	m_bumpBitmap.DeleteObject();
	delete m_pEdit;
	m_font.DeleteObject();
}

//------------------------------------------------------------------------------
//	CKnob::Reset
//------------------------------------------------------------------------------
void 
CKnob::Reset(void)
/*++

Routine Description:

	Reset to last applied setting

Arguments:

	None

Return Value:

	None

--*/
{
	m_pos	= m_lastPos;
	m_angle	= PositionToAngle(m_pos);
	UpdateEdit();
	Invalidate(TRUE);
}

//------------------------------------------------------------------------------
//	CKnob::Default
//------------------------------------------------------------------------------
void 
CKnob::Default(void)
/*++

Routine Description:

	Reset to default setting

Arguments:

	None

Return Value:

	None

--*/
{
	m_pos	= m_default;
	m_angle = PositionToAngle(m_pos);
	UpdateEdit();
	Invalidate(TRUE);
}

//------------------------------------------------------------------------------
//	CKnob::PreSubclassWindow
//------------------------------------------------------------------------------
void 
CKnob::PreSubclassWindow(void) 
/*++

Routine Description:

	Set the window style

Arguments:

	None

Return Value:

	None

--*/
{
	CStatic::PreSubclassWindow();

	ModifyStyle(SS_BITMAP, SS_OWNERDRAW | SS_NOTIFY | WS_TABSTOP);
}

//------------------------------------------------------------------------------
//	CKnob::OnCreate
//------------------------------------------------------------------------------
int 
CKnob::OnCreate(LPCREATESTRUCT lpCreateStruct)
/*++

Routine Description:

	Create method

Arguments:

	IN OUT lpCreateStruct -	Creation struct

Return Value:

	None

--*/
{
	// Base class callback
	if (CWnd ::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Create everything
	CreateBitmaps();
	return 0;
}

//------------------------------------------------------------------------------
//	CKnob::OnPaint
//------------------------------------------------------------------------------
void 
CKnob::OnPaint() 
/*++

Routine Description:

	Draws the knob

Arguments:

	None

Return Value:

	None

--*/
{
	CDC			memDC;
	CPaintDC	dc(this);
	CBitmap*	pOldBitmap;
    CString		string;
	CFont*		pOldFont;
	CPoint		point;

	dc.SetBkColor(::GetSysColor(COLOR_BTNFACE));
	dc.SetTextColor(m_textColor);

	// Draw the name
	pOldFont = dc.SelectObject(&m_font);
	dc.DrawText(m_name, m_nameRect, DT_NOPREFIX | DT_NOCLIP | DT_SINGLELINE | DT_VCENTER | DT_CENTER);

	// Draw the units
	dc.DrawText(m_units, m_unitsRect, DT_NOPREFIX | DT_NOCLIP | DT_SINGLELINE | DT_VCENTER | DT_CENTER);
	dc.SelectObject(pOldFont);

	// Create memory dc
	VERIFY(memDC.CreateCompatibleDC(&dc));

	// Draw the bitmap
	pOldBitmap = memDC.SelectObject(&m_knobBitmap);
	dc.BitBlt(m_knobRect.left, m_knobRect.top, m_knobRect.Width(), m_knobRect.Height(), &memDC, 0, 0, SRCCOPY);

	// Draw the bump
	memDC.SelectObject(&m_bumpBitmap);
	point = AngleToPoint(m_angle);
	dc.BitBlt(point.x - m_bumpCenter.x, point.y - m_bumpCenter.y, 
			  m_bumpRect.Width(), m_bumpRect.Height(), &memDC, 0, 0, SRCCOPY);

	// Restore
	if(pOldBitmap != NULL)
		memDC.SelectObject(memDC);
}

//------------------------------------------------------------------------------
//	CKnob::OnLButtonDown
//------------------------------------------------------------------------------
void 
CKnob::OnLButtonDown(
					 IN UINT	nFlags, 
					 IN CPoint	point
					 ) 
/*++

Routine Description:

	Capture the mouse

Arguments:

	IN nFlags -	Flags
	IN point -	Mouse location

Return Value:

	None

--*/
{
	double	distance;

	// Find the distance to the center
	distance = sqrt(((double)(point.x - m_knobCenter.x) * (double)(point.x - m_knobCenter.x)) +
					((double)(point.y - m_knobCenter.y) * (double)(point.y - m_knobCenter.y)));

	// Is the mouse within the knob?
	if((distance > (m_radius * 0.01f)) && (distance < (m_radius * 1.1f)))
	{
		m_bLeftMouseDown = TRUE;
		if(GetSafeHwnd() != ::GetCapture())
			SetCapture();

		// Adjust the angle
		UpdatePoint(point);
	}
	SetFocus();
	CStatic::OnLButtonDown(nFlags, point);
}

//------------------------------------------------------------------------------
//	CKnob::OnLButtonUp
//------------------------------------------------------------------------------
void 
CKnob::OnLButtonUp(
				   IN UINT		nFlags, 
				   IN CPoint	point
				   )
/*++

Routine Description:

	Release the mouse

Arguments:

	IN nFlags -	Flags
	IN point -	Mouse location

Return Value:

	None

--*/
{
	m_bLeftMouseDown = FALSE;
	ReleaseCapture();
	CStatic::OnLButtonUp(nFlags, point);
}

//------------------------------------------------------------------------------
//	CKnob::OnMouseMove
//------------------------------------------------------------------------------
void 
CKnob::OnMouseMove(
				   IN UINT		nFlags, 
				   IN CPoint	point
				   )
/*++

Routine Description:

	Adjust the knob

Arguments:

	IN nFlags -	Flags
	IN point -	Mouse location

Return Value:

	None

--*/
{
	if((nFlags & MK_LBUTTON) && (m_bLeftMouseDown))
		UpdatePoint(point);

	CStatic::OnMouseMove(nFlags, point);
}

//------------------------------------------------------------------------------
//	CKnob::OnSysColorChange
//------------------------------------------------------------------------------
void 
CKnob::OnSysColorChange() 
/*++

Routine Description:

	Handles system color change requests

Arguments:

	None

Return Value:

	None

--*/
{
	CStatic::OnSysColorChange();
	m_knobBitmap.DeleteObject();
	m_bumpBitmap.DeleteObject();
	CreateBitmaps();
	Invalidate(TRUE);
}

//------------------------------------------------------------------------------
//	CKnob::OnEditChange
//------------------------------------------------------------------------------
void
CKnob::OnEditChange(void)
/*++

Routine Description:

	Handles changes to the edit

Arguments:

	None

Return Value:

	None

--*/
{
	CString	string;

	if(m_pEdit)
	{
		m_pEdit->GetWindowText(string);
		m_pos	= atof(string);
		if(m_pos < m_minPos)
			m_pos = m_minPos;
		else if(m_pos > m_maxPos)
			m_pos = m_maxPos;
		m_angle	= PositionToAngle(m_pos);
		Invalidate(TRUE);
	}
}

//------------------------------------------------------------------------------
//	CKnob::OnEditLoseFocus
//------------------------------------------------------------------------------
void
CKnob::OnEditLoseFocus(void)
/*++

Routine Description:

	Updates the display when the edit loses focus

Arguments:

	None

Return Value:

	None

--*/
{
	UpdateEdit();
}

//------------------------------------------------------------------------------
//	CKnob::CreateBitmaps
//------------------------------------------------------------------------------
void 
CKnob::CreateBitmaps(void)
/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
{
	BITMAP		bitmap;
	CString		string;
	CSize		nameSize;
	CSize		unitsSize;
	CDC			memDC;
	CBitmap*	pOldBitmap;
	int			x;
	int			y;
	COLORREF	color;
	int			width;
	CRect		rect;
	CClientDC	dc(this);
	CFont*		pOldFont;

	// Get the position
	GetWindowRect(&m_rect);
	ScreenToClient(&m_rect);

	// Load the bitmaps
	VERIFY(m_knobBitmap.LoadBitmap(IDB_KNOB) != FALSE);
	VERIFY(m_bumpBitmap.LoadBitmap(IDB_KNOB_BUMP) != FALSE);

	pOldFont = dc.SelectObject(&m_font);

	// Read the sizes
	m_knobBitmap.GetBitmap(&bitmap);
	nameSize	= dc.GetTextExtent(m_name);
	unitsSize	= dc.GetTextExtent(m_units);

	dc.SelectObject(pOldFont);
	
	width = MAX(bitmap.bmWidth, nameSize.cx);
	width = MAX(width, unitsSize.cx);

	// name rect
	m_nameRect.left		= m_rect.left;
	m_nameRect.top		= m_rect.top;
	m_nameRect.right	= m_nameRect.left + width;
	m_nameRect.bottom	= m_nameRect.top + nameSize.cy;

	// Knob rect
	m_knobRect.left		= m_rect.left + ((width - bitmap.bmWidth) / 2);
	m_knobRect.top		= m_nameRect.bottom;
	m_knobRect.right	= m_knobRect.left + width;
	m_knobRect.bottom	= m_knobRect.top + bitmap.bmHeight;

	// edit rect
	rect.left			= m_rect.left;
	rect.top			= m_knobRect.bottom + 5;
	rect.right			= rect.left + width;
	rect.bottom			= rect.top + MAX(nameSize.cy, unitsSize.cy);

	// Units rect
	m_unitsRect.left	= m_rect.left;
	m_unitsRect.top		= rect.bottom;
	m_unitsRect.right	= m_unitsRect.left + width;
	m_unitsRect.bottom	= m_unitsRect.top + unitsSize.cy;

	// Now, update the entire rect
	m_rect.right		= m_rect.left + width;
	m_rect.bottom		= m_unitsRect.bottom;

	// Some other calculations
	m_knobCenter.x		= m_rect.Width() / 2;
	m_knobCenter.y		= m_knobRect.top + (m_knobRect.Height() / 2);

	// Radius of knob
	m_radius = (double)bitmap.bmWidth / 2.0;

	// Create the memory dc to draw the bitmap
	VERIFY(memDC.CreateCompatibleDC(&dc));

	// Select the bitmap
	pOldBitmap = memDC.SelectObject(&m_knobBitmap);

	// Replace all pixels in the bitmap background with the screen 
	// background color
	for(x=0; x<bitmap.bmWidth; ++x)
	{
		for(y=0; y<bitmap.bmHeight; ++y)
		{
			color = memDC.GetPixel(x, y);
			if(color == m_backgroundColor)
				memDC.SetPixel(x, y, GetSysColor(COLOR_BTNFACE));
		}
	}

	// Adjust the knob's position
	SetWindowPos(NULL, 0, 0, m_rect.right, m_rect.bottom, 
				 SWP_NOMOVE | SWP_NOZORDER);

	// Set the rect size to the size of the bitmap
	m_bumpBitmap.GetBitmap(&bitmap);
	m_bumpRect.left		= 0;
	m_bumpRect.right	= bitmap.bmWidth;
	m_bumpRect.top		= 0;
	m_bumpRect.bottom	= bitmap.bmHeight;
	m_bumpCenter.x		= m_bumpRect.Width() / 2;
	m_bumpCenter.y		= m_bumpRect.Height() / 2;

	// Select the bitmap
	pOldBitmap = memDC.SelectObject(&m_bumpBitmap);

	// Restore the old bitmap
	memDC.SelectObject(pOldBitmap);

	// Create the edit
	if(!m_pEdit)
	{
		m_pEdit = new CEdit;
		m_pEdit->Create(WS_CHILD | WS_VISIBLE, rect, this, 1);
		m_pEdit->SetFont(&m_font);
		UpdateEdit();
	}
}

//------------------------------------------------------------------------------
//	CKnob::PointToAngle
//------------------------------------------------------------------------------
double
CKnob::PointToAngle(
					IN const CPoint& point
					) const
/*++

Routine Description:

	Converts a mouse point in the bitmap to an angle

Arguments:

	IN point -	Point

Return Value:

	angle

--*/
{
	double	x;
	double	y;
	double	angle;

	// Convert to angle system (described at top of file)
	x	= (double)(point.y - m_knobCenter.y);
	y	= (double)(m_knobCenter.x - point.x);

	if(x == 0.0) 
	{
		// Center: undefined so use angle of 0
		if(y == 0.0)
			angle = 0.0;

		// Otherwise a vertical line (90 or 270)
		else if(y > 0.0)
			angle = cPi / 2.0;
		else
			angle = 3.0 * cPi / 2.0;
	}

	// Horizontal line?
	else if(y == 0.0)
	{
		if(x > 0.0)
			angle = 0.0f;
		else
			angle = cPi;
	}

	// Otherwise, use atan
	else
	{
		angle = atan(y / x);   
		if(x < 0.0)
		{
			if(y > 0.0)
				angle += cPi;
			else
				angle -= cPi;
		}
		while(angle < 0.0)
			angle += cTwoPi;
	}
	
	return angle;
}

//------------------------------------------------------------------------------
//	CKnob::AngleToPoint
//------------------------------------------------------------------------------
CPoint
CKnob::AngleToPoint(
					IN double angle
					) const
/*++

Routine Description:

	Converts an angle to a point on the bitmap suitable to place the bump

Arguments:

	IN angle -	Angle

Return Value:

	Point on bitmap

--*/
{
	int	x = m_knobCenter.x - (int)(m_radius * sin(angle) * 0.7);
	int	y = m_knobCenter.y + (int)(m_radius * cos(angle) * 0.7);
	return CPoint((int)x, (int)y);
}

//------------------------------------------------------------------------------
//	CKnob::UpdateEdit
//------------------------------------------------------------------------------
void 
CKnob::UpdateEdit(void)
/*++

Routine Description:

	Updates the CEdit

Arguments:

	None

Return Value:

	None

--*/
{
	CString	string;

	// Update the edit
	switch(m_dataType)
	{
	case CKnob::TYPE_FLOAT:
		string.Format(m_format, (float)m_pos);
		break;
	case CKnob::TYPE_DOUBLE:
		string.Format(m_format, m_pos);
		break;
	case CKnob::TYPE_CHAR:
	case CKnob::TYPE_INT:
		string.Format(m_format, (int)m_pos);
		break;
	case CKnob::TYPE_UNSIGNED_CHAR:
	case CKnob::TYPE_UNSIGNED_INT:
		string.Format(m_format, (unsigned)m_pos);
		break;
	case CKnob::TYPE_LONG:
		string.Format(m_format, (long)m_pos);
		break;
	case CKnob::TYPE_UNSIGNED_LONG:
		string.Format(m_format, (unsigned long)m_pos);
		break;
	}
	if(m_pEdit)
		m_pEdit->SetWindowText(string);
}

//------------------------------------------------------------------------------
//	CKnob::Update
//------------------------------------------------------------------------------
void
CKnob::UpdatePoint(
				   IN const CPoint&	point
				   )
/*++

Routine Description:

	Updates the knob based on the point

Arguments:

	IN point -	Mouse point

Return Value:

	None

--*/
{
	//Convert xy position to an angle.
	m_angle = PointToAngle(point);
	if(m_angle < m_minAngle)
		m_angle = m_minAngle;
	else if(m_angle > m_maxAngle)
		m_angle = m_maxAngle;

	m_pos = AngleToPosition(m_angle);

	// Update the edit
	UpdateEdit();

	// Send the position
	if(m_pParent && m_bRealtime)
		m_pParent->ChangeParameter(this, TRUE);

	Invalidate();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Knob.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Knob.h

Abstract:

	Graphical knob control

Author:

	Robert Heitkamp (robheit) 30-Nov-2001

Revision History:

	30-Nov-2001 robheit
		Initial Version

--*/

#ifndef KNOB_H
#define KNOB_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "afxwin.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CModule;

//------------------------------------------------------------------------------
//	CKnob
//------------------------------------------------------------------------------
class CKnob : public CStatic
{
public:

	enum DataType
	{
		TYPE_FLOAT,
		TYPE_DOUBLE,
		TYPE_CHAR,
		TYPE_UNSIGNED_CHAR,
		TYPE_INT,
		TYPE_UNSIGNED_INT,
		TYPE_LONG,
		TYPE_UNSIGNED_LONG
	};

	enum Mode
	{
		DISCRETE,	// Invalid for types FLOAT and DOUBLE
		CONTINUOUS
	};

public:

	CKnob(void);
	CKnob(CModule* pParent, int index, LPCTSTR pName, BOOL bAtomic, DataType type, 
		  double min, double max, double pos, double def, LPCTSTR pFormat, 
		  LPCTSTR pUnits, Mode mode=CONTINUOUS, double increment=0.0);
	virtual ~CKnob(void);

	void Reset(void);
	void Default(void);

	// Inlined methods
	inline double GetPos(void) const { return m_pos; };
//	inline double GetMin(void) const { return m_minPos; };
//	inline double GetMax(void) const { return m_maxPos; };
//	inline double GetDefault(void) const { return m_default; };
	inline DataType GetDataType(void) const { return m_dataType; };
//	inline double GetLastPos(void) const { return m_lastPos; };
	inline void SetLastPos(double pos) { m_lastPos = pos; };
	inline BOOL GetAtomic(void) const { return m_bAtomic; };
	inline int GetIndex(void) const { return m_index; };
	inline void EnableRealtime(BOOL bEnable) { m_bRealtime = bEnable; };
	
protected:

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKnob)
	protected:
	virtual void PreSubclassWindow();
	//}}AFX_VIRTUAL

	// Generated message map functions
	//{{AFX_MSG(CKnob)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnSysColorChange();
	afx_msg void OnEditChange();
	afx_msg void OnEditLoseFocus();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	
	void CreateBitmaps(void);
	double PointToAngle(const CPoint& point) const;
	CPoint AngleToPoint(double angle) const;
	void UpdateEdit(void);
	void UpdatePoint(const CPoint& point);

	inline double PositionToAngle(double pos) const { return (((pos - m_minPos) / (m_maxPos - m_minPos)) * (m_maxAngle - m_minAngle) + m_minAngle); };
	inline double AngleToPosition(double angle) const { return (((angle - m_minAngle) / (m_maxAngle - m_minAngle)) * (m_maxPos - m_minPos) + m_minPos); };
	
private:

	CModule*	m_pParent;
	int			m_index;
	CString		m_name;
	CString		m_units;
	Mode		m_mode;
	double		m_increment;
	CBitmap		m_knobBitmap;
	CBitmap		m_bumpBitmap;
	double		m_angle;
	double		m_radius;
	double		m_minPos;
	double		m_maxPos;
	double		m_pos;
	CRect		m_rect;
	CRect		m_knobRect;
	CRect		m_nameRect;
	CRect		m_unitsRect;
	CRect		m_bumpRect;
	CFont		m_font;
	CPoint		m_knobCenter;
	CPoint		m_bumpCenter;
	BOOL		m_bLeftMouseDown;
	COLORREF	m_backgroundColor;
	COLORREF	m_textColor;
	double		m_minAngle;
	double		m_maxAngle;
	DataType	m_dataType;
	CEdit*		m_pEdit;
	CString		m_format;
	double		m_default;
	double		m_lastPos;
	BOOL		m_bAtomic;
	BOOL		m_bRealtime;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\MainFrm.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MainFrm.cpp

Abstract:

	Implementation of the CMainFrame class

Author:

	Robert Heitkamp (robheit) 16-Jul-2001

Revision History:

	16-Jul-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "MainFrm.h"

//------------------------------------------------------------------------------
//	Debug defines
//------------------------------------------------------------------------------
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------------------------
//	Implementation
//------------------------------------------------------------------------------
IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

//------------------------------------------------------------------------------
//	Message Map
//------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_WM_INITMENUPOPUP()
	ON_COMMAND(ID_APP_EXIT, OnAppExit)
	ON_UPDATE_COMMAND_UI(IDS_STATUS_BAR_TEXT, OnUpdateStatusBar)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_SEPARATOR,
//	ID_INDICATOR_CAPS,
//	ID_INDICATOR_NUM,
//	ID_INDICATOR_SCRL,
};

//------------------------------------------------------------------------------
//	CMainFrame::CMainFrame
//------------------------------------------------------------------------------
CMainFrame::CMainFrame(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CMainFrame::~CMainFrame
//------------------------------------------------------------------------------
CMainFrame::~CMainFrame(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CMainFrame::OnCreate
//------------------------------------------------------------------------------
int 
CMainFrame::OnCreate(
					 IN LPCREATESTRUCT lpCreateStruct
					 )
/*++

Routine Description:

	Handles the creation event.

Arguments:

	IN lpCreateStruct -	Construction parameters

Return Value:

	0 on success, any other value on error

--*/
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// create a view to occupy the client area of the frame
	if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
						  CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
	{
		TRACE0("Failed to create view window\n");
		return -1;
	}
	
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | 
							   CBRS_TOP | CBRS_GRIPPER | CBRS_TOOLTIPS | 
							   CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) || 
		!m_wndStatusBar.SetIndicators(indicators, 
									  sizeof(indicators) / sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_wndStatusBar.SetPaneInfo(1, IDS_STATUS_BAR_TEXT, SBPS_NORMAL, 400);
	m_wndStatusBar.SetPaneText(1, _T("MyText"));

	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

//------------------------------------------------------------------------------
//	CMainFrame::PreCreateWindow
//------------------------------------------------------------------------------
BOOL 
CMainFrame::PreCreateWindow(
							IN CREATESTRUCT& cs
							)
/*++

Routine Description:

	Called before the window is created

Arguments:

	IN cs -	Create data

Return Value:

	FALSE on error, TRUE on success

--*/
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;

	cs.dwExStyle &= ~WS_EX_CLIENTEDGE;

//	cs.lpszClass = AfxRegisterWndClass(0);
	return TRUE;
}

#ifdef _DEBUG
//------------------------------------------------------------------------------
//	CMainFrame::AssertValid
//------------------------------------------------------------------------------
void 
CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

//------------------------------------------------------------------------------
//	CMainFrame::Dump
//------------------------------------------------------------------------------
void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

//------------------------------------------------------------------------------
//	CMainFrame::OnSetFocus
//------------------------------------------------------------------------------
void 
CMainFrame::OnSetFocus(
					   IN CWnd*
					   )
/*++

Routine Description:

	Called when the window gains focus

Arguments:

	IN pOldWnd -	Prevoous window

Return Value:

	None

--*/
{
	// Forward focus to the view window
	m_wndView.SetFocus();
}

//------------------------------------------------------------------------------
//	CMainFrame::OnCmdMsg
//------------------------------------------------------------------------------
BOOL 
CMainFrame::OnCmdMsg(
					 IN UINT				nID, 
					 IN int					nCode, 
					 IN void*				pExtra, 
					 IN AFX_CMDHANDLERINFO*	pHandlerInfo
					 )
/*++

Routine Description:

	Handles all command messages

Arguments:

	IN nID -			ID
	IN nCode -			Code
	IN pExtra -			Extra data
	IN pHandlerInfo -	Handler info

Return Value:

	TRUE if the message is handled; otherwise FALSE

--*/
{
	// let the view have first crack at the command
	if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	// otherwise, do default handling
	return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

//------------------------------------------------------------------------------
//	CMainFrame::OnInitMenuPopup
//------------------------------------------------------------------------------
void 
CMainFrame::OnInitMenuPopup(
							IN CMenu*	pPopupMenu, 
							IN UINT		nIndex, 
							IN BOOL		bSysMenu
							)
/*++

Routine Description:

	Handles popup menus. Basically ensure the right items are checked

Arguments:

	IN pPopupMenu -	Menu
	IN nIndex -		Menu index
	IN bSysMenu -	TRUE if the system menu, FALSE othereise

Return Value:

	None

--*/
{
	CWnd::OnInitMenuPopup(pPopupMenu, nIndex, bSysMenu);
	if(!bSysMenu)
	{
		// View menu?
		if(nIndex == 1)
		{
			// Status bar
			if(m_wndStatusBar.IsWindowVisible())
				pPopupMenu->CheckMenuItem(ID_VIEW_STATUS_BAR, MF_CHECKED);
			else
				pPopupMenu->CheckMenuItem(ID_VIEW_STATUS_BAR, MF_UNCHECKED);

			// Toolbar
			if(m_wndToolBar.IsWindowVisible())
				pPopupMenu->CheckMenuItem(ID_VIEW_TOOLBAR, MF_CHECKED);
			else
				pPopupMenu->CheckMenuItem(ID_VIEW_TOOLBAR, MF_UNCHECKED);
		}

		// All other menus
		m_wndView.EnableMenuItem(pPopupMenu, nIndex);
	}
}

//------------------------------------------------------------------------------
//	CMainFrame::OnAppExit
//------------------------------------------------------------------------------
void
CMainFrame::OnAppExit(void)
/*++

Routine Description:

	Handles exit requests

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_wndView.Quit())
		PostMessage(WM_CLOSE, 0, 0);
}

//------------------------------------------------------------------------------
//	CMainFrame::OnUpdateStatusBar
//------------------------------------------------------------------------------
void
CMainFrame::OnUpdateStatusBar(
							  IN CCmdUI*	pCmdUI
							  )
/*++

Routine Description:

	Upates the text in the status bar

Arguments:

	IN pCmdUI -	ON_UPDATE_COMMAND_UI handler	

Return Value:

	None

--*/
{
	pCmdUI->SetText(m_wndView.GetStatusBarText());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\MainFrm.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MainFrm.h

Abstract:

	Interface of the CMainFrame class

Author:

	Robert Heitkamp (robheit) 16-Jul-2001

Revision History:

	16-Jul-2001 robheit
		Initial Version

--*/
#if !defined(AFX_MAINFRM_H__16B9FE59_8061_4B61_B67C_F25B1395FB45__INCLUDED_)
#define AFX_MAINFRM_H__16B9FE59_8061_4B61_B67C_F25B1395FB45__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "ChildView.h"

//------------------------------------------------------------------------------
//	CMainFrame 
//------------------------------------------------------------------------------
class CMainFrame : public CFrameWnd
{
public:

	CMainFrame();
	virtual ~CMainFrame();

public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

	void OnUpdateStatusBar(CCmdUI* pCmdUI);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected: 

	DECLARE_DYNAMIC(CMainFrame)

protected:

	CStatusBar	m_wndStatusBar;
	CToolBar	m_wndToolBar;
	CChildView	m_wndView;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd *pOldWnd);
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	afx_msg void OnAppExit(void);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__16B9FE59_8061_4B61_B67C_F25B1395FB45__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Parameter.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Parameter.cpp

Abstract:

	Effect Parameters

Author:

	Robert Heitkamp (robheit) 29-Nov-2001

Revision History:

	29-Nov-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Parameter.h"

//------------------------------------------------------------------------------
//	CParameter::CParameter
//------------------------------------------------------------------------------
CParameter::CParameter(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_dwOffset	= 0;
	m_dwDefault	= 0;
	m_dwType	= 0;
	m_dwMin		= 0;
	m_dwMax		= 0;
	m_bAtomic	= FALSE;
	m_dwValue	= 0;
}

#if 0
//------------------------------------------------------------------------------
//	CParameter::CParameter
//------------------------------------------------------------------------------
CParameter::CParameter(
					   IN const CParameter& param
					   )
/*++

Routine Description:

	Copy constructor

Arguments:

	IN param -	Class to copy

Return Value:

	None

--*/
{
	*this = param;
}

//------------------------------------------------------------------------------
//	CParameter::CParameter
//------------------------------------------------------------------------------
CParameter::CParameter(
					   IN const FX_PARAM_DESCRIPTION& param
					   )
/*++

Routine Description:

	Copy constructor

Arguments:

	IN param -	Class to copy

Return Value:

	None

--*/
{
	*this = param;
}
#endif

//------------------------------------------------------------------------------
//	CParameter::~CParameter
//------------------------------------------------------------------------------
CParameter::~CParameter(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CParameter::operator =
//------------------------------------------------------------------------------
CParameter&
CParameter::operator = (
						IN const CParameter& param
						)
/*++

Routine Description:

	Assignment operator

Arguments:

	IN param -	Parameter to copy

Return Value:

	None

--*/
{
	m_name			= param.m_name;
	m_description	= param.m_description;
	m_units			= param.m_units;
	m_dwOffset		= param.m_dwOffset;
	m_dwDefault		= param.m_dwDefault;
    m_dwType		= param.m_dwType;
    m_dwMin			= param.m_dwMin;
    m_dwMax			= param.m_dwMax;
    m_bAtomic		= param.m_bAtomic;
	m_dwValue		= param.m_dwValue;

	return *this;
}

//------------------------------------------------------------------------------
//	CParameter::operator =
//------------------------------------------------------------------------------
CParameter&
CParameter::operator = (
						IN const FX_PARAM_DESCRIPTION& param
						)
/*++

Routine Description:

	Assignment operator

Arguments:

	IN param -	Parameter to copy

Return Value:

	None

--*/
{
	m_name			= param.ParameterName;
	m_description	= param.ParameterDesc;
	m_units			= param.UnitsName;
	m_dwOffset		= param.dwOffset;
	m_dwDefault		= param.dwDefaultValue;
    m_dwType		= param.dwParameterType;
    m_dwMin			= param.dwParameterMin;
    m_dwMax			= param.dwParameterMax;
    m_bAtomic		= param.bIsAtomic;
	m_dwValue		= m_dwDefault;

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Module.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Module.cpp

Abstract:

	Module composed of multiple cells

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <math.h>
#include "dspbuilder.h"
#include "Module.h"
#include "PatchCord.h"
#include "Graph.h"
#include "Jack.h"
#include "ParameterDialog.h"
#include "Knob.h"
#include "ChildView.h"
#include "EffectNameDialog.h"
#include "WinDspImageBuilder.h"

//------------------------------------------------------------------------------
//	DSound defines (taken from dsound.h)
//------------------------------------------------------------------------------
#define I3DL2LISTENER_MINROOM                     -10000
#define I3DL2LISTENER_MAXROOM                     0
#define I3DL2LISTENER_DEFAULTROOM                 -10000
#define I3DL2LISTENER_MINROOMHF                   -10000
#define I3DL2LISTENER_MAXROOMHF                   0
#define I3DL2LISTENER_DEFAULTROOMHF               0
#define I3DL2LISTENER_MINROOMROLLOFFFACTOR        0.0f
#define I3DL2LISTENER_MAXROOMROLLOFFFACTOR        10.0f
#define I3DL2LISTENER_DEFAULTROOMROLLOFFFACTOR    0.0f
#define I3DL2LISTENER_MINDECAYTIME                0.1f
#define I3DL2LISTENER_MAXDECAYTIME                20.0f
#define I3DL2LISTENER_DEFAULTDECAYTIME            1.0f
#define I3DL2LISTENER_MINDECAYHFRATIO             0.1f
#define I3DL2LISTENER_MAXDECAYHFRATIO             2.0f
#define I3DL2LISTENER_DEFAULTDECAYHFRATIO         0.5f
#define I3DL2LISTENER_MINREFLECTIONS              -10000
#define I3DL2LISTENER_MAXREFLECTIONS              1000
#define I3DL2LISTENER_DEFAULTREFLECTIONS          -10000
#define I3DL2LISTENER_MINREFLECTIONSDELAY         0.0f
#define I3DL2LISTENER_MAXREFLECTIONSDELAY         0.3f
#define I3DL2LISTENER_DEFAULTREFLECTIONSDELAY     0.02f
#define I3DL2LISTENER_MINREVERB                   -10000
#define I3DL2LISTENER_MAXREVERB                   2000
#define I3DL2LISTENER_DEFAULTREVERB               -10000
#define I3DL2LISTENER_MINREVERBDELAY              0.0f
#define I3DL2LISTENER_MAXREVERBDELAY              0.1f
#define I3DL2LISTENER_DEFAULTREVERBDELAY          0.04f
#define I3DL2LISTENER_MINDIFFUSION                0.0f
#define I3DL2LISTENER_MAXDIFFUSION                100.0f
#define I3DL2LISTENER_DEFAULTDIFFUSION            100.0f
#define I3DL2LISTENER_MINDENSITY                  0.0f
#define I3DL2LISTENER_MAXDENSITY                  100.0f
#define I3DL2LISTENER_DEFAULTDENSITY              100.0f
#define I3DL2LISTENER_MINHFREFERENCE              20.0f
#define I3DL2LISTENER_MAXHFREFERENCE              20000.0f
#define I3DL2LISTENER_DEFAULTHFREFERENCE          5000.0f

static const CModule::I3DL2Listener cListenerDefault			= { -1000,   -100, 0.0f, 1.49f, 0.83f,  -2602, 0.007f,    200, 0.011f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerGeneric			= { -1000,   -100, 0.0f, 1.49f, 0.83f,  -2602, 0.007f,    200, 0.011f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerPaddedCell			= { -1000,  -6000, 0.0f, 0.17f, 0.10f,  -1204, 0.001f,    207, 0.002f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerRoom				= { -1000,   -454, 0.0f, 0.40f, 0.83f,  -1646, 0.002f,     53, 0.003f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerBathroom			= { -1000,  -1200, 0.0f, 1.49f, 0.54f,   -370, 0.007f,   1030, 0.011f, 100.0f,  60.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerLivingRoom			= { -1000,  -6000, 0.0f, 0.50f, 0.10f,  -1376, 0.003f,  -1104, 0.004f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerStoneRoom			= { -1000,   -300, 0.0f, 2.31f, 0.64f,   -711, 0.012f,     83, 0.017f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerAuditorium			= { -1000,   -476, 0.0f, 4.32f, 0.59f,   -789, 0.020f,   -289, 0.030f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerConcertHall		= { -1000,   -500, 0.0f, 3.92f, 0.70f,  -1230, 0.020f,     -2, 0.029f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerCave				= { -1000,      0, 0.0f, 2.91f, 1.30f,   -602, 0.015f,   -302, 0.022f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerArena				= { -1000,   -698, 0.0f, 7.24f, 0.33f,  -1166, 0.020f,     16, 0.030f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerHangar				= { -1000,  -1000, 0.0f,10.05f, 0.23f,   -602, 0.020f,    198, 0.030f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerCarpetedHallway	= { -1000,  -4000, 0.0f, 0.30f, 0.10f,  -1831, 0.002f,  -1630, 0.030f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerHallway			= { -1000,   -300, 0.0f, 1.49f, 0.59f,  -1219, 0.007f,    441, 0.011f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerStoneCorridor		= { -1000,   -237, 0.0f, 2.70f, 0.79f,  -1214, 0.013f,    395, 0.020f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerAlley				= { -1000,   -270, 0.0f, 1.49f, 0.86f,  -1204, 0.007f,     -4, 0.011f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerForest				= { -1000,  -3300, 0.0f, 1.49f, 0.54f,  -2560, 0.162f,   -613, 0.088f,  79.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerCity				= { -1000,   -800, 0.0f, 1.49f, 0.67f,  -2273, 0.007f,  -2217, 0.011f,  50.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerMountains			= { -1000,  -2500, 0.0f, 1.49f, 0.21f,  -2780, 0.300f,  -2014, 0.100f,  27.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerQuarry				= { -1000,  -1000, 0.0f, 1.49f, 0.83f, -10000, 0.061f,    500, 0.025f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerPlain				= { -1000,  -2000, 0.0f, 1.49f, 0.50f,  -2466, 0.179f,  -2514, 0.100f,  21.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerParkingLot			= { -1000,      0, 0.0f, 1.65f, 1.50f,  -1363, 0.008f,  -1153, 0.012f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerSewerPipe			= { -1000,  -1000, 0.0f, 2.81f, 0.14f,    429, 0.014f,    648, 0.021f,  80.0f,  60.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerUnderWater			= { -1000,  -4000, 0.0f, 1.49f, 0.10f,   -449, 0.007f,   1700, 0.011f, 100.0f, 100.0f, 5000.0f };
static const CModule::I3DL2Listener cListenerNoReverb			= { -10000, -10000, 0.0f, 1.00f, 1.00f, -10000, 0.000f, -10000, 0.000f,   0.0f,   0.0f, 5000.0f };

//------------------------------------------------------------------------------
//	Stuff
//------------------------------------------------------------------------------
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	Constants
//------------------------------------------------------------------------------
static const double cPi			= 3.14159265358979323846;
static const double cTwoPi		= 2.0 * cPi;
//static const double cFs			= 48000.0;
//static const double	cScale24	= 1.0;

//------------------------------------------------------------------------------
//	Static Member Variables:
//------------------------------------------------------------------------------
CFont* CModule::m_stateFont = NULL;
int CModule::m_stateFontRef	= 0;

//------------------------------------------------------------------------------
//	CModule::CModule
//------------------------------------------------------------------------------
CModule::CModule(
				 IN CGraph*				pGraph,
				 IN CModule::Type		type,
				 IN CModule::ColorFlag	colorFlag,
				 IN LPCTSTR				pName,
				 IN int					dspCycles,
				 IN int					yMemSize,
				 IN int					scratchLength,
				 IN LPCTSTR				dspCode,
				 IN LPCTSTR				stateFilename,
				 IN const CStringArray*	pInputs,
				 IN const CStringArray*	pOutputs
				 ) : CUnique()
/*++

Routine Description:

	Constructor

Arguments:

	IN pGraph -			Graph this module will belong to
	IN id -				ID of module
	IN type -			Type of module
	IN pName -			Name of module
	IN dspCycles -		DSP Cycles
	IN yMemSize -		Y mem size
	IN scratchLength -	Scratch Length
	IN dspCode -		DSP filename (NULL for none)
	IN stateFilename -	State filename (NULL for none)
	IN pInputs -		List of input names (NULL terminated)
	IN pOutputs -		List of ouput names (NULL terminated)

Return Value:

	None

--*/
{
	int		i;
	int		numInputs	= pInputs ? pInputs->GetSize() : 0;
	int		numOutputs	= pOutputs ? pOutputs->GetSize() : 0;
	CJack*	pJack;

	Initialize();

	m_colorFlag		= colorFlag;
	m_type			= type;
	m_pGraph		= pGraph;
	m_dspCode		= dspCode;
	m_stateFilename	= stateFilename;
	m_dspCycles		= dspCycles;
	m_yMemSize		= yMemSize;
	m_scratchLength	= scratchLength;
	m_name			= pName;
	m_effectName	= pName;
	SetDisplayName();

	if(m_type == CModule::EFFECT)
	{
		m_stats.Format(_T("DSP: %d  YMem: %d  Scr: %d"), 
			m_dspCycles, m_yMemSize, m_scratchLength);
	}

	// Build the module based on type
	m_rect.left = 0;
	m_rect.top	= 0;
	switch(m_type)
	{
	case CModule::INPUT_MIXBIN:
		m_rect.right	= 9 * SCALE;
		m_rect.bottom	= 3 * SCALE;
		break;

	case CModule::OUTPUT_MIXBIN:
		m_rect.right	= 9 * SCALE;
		m_rect.bottom	= 3 * SCALE;
		break;

	case CModule::EFFECT:
		m_rect.right	= 16 * SCALE;
		m_rect.bottom	= ((numInputs > numOutputs) ? 
						   (numInputs > 1 ? numInputs + 2 : 3) :
						   (numOutputs > 1 ? numOutputs + 2 : 3)) * SCALE;
		break;
	}
	CreatePenAndBrush();

	// Inputs
	for(i=0; i<numInputs; ++i)
	{
		pJack = new CJack(this);
		pJack->SetName((*pInputs)[i]);
		pJack->SetInput(TRUE);
		m_inputs.Add(pJack);
	}

	// Outputs
	for(i=0; i<numOutputs; ++i)
	{
		pJack = new CJack(this);
		pJack->SetName((*pOutputs)[i]);
		pJack->SetInput(FALSE);
		m_outputs.Add(pJack);
	}

	// Set the location
	SetRect(m_rect);

	// Special Case: IIR2?
	if(!m_effectName.CompareNoCase(_T("iir2")))
		m_bIIR2 = TRUE;
	else if(!m_effectName.CompareNoCase(_T("i3dl2 reverb")) ||
			!m_effectName.CompareNoCase(_T("i3dl2 24k reverb")))
	{
		m_bI3DL2 = TRUE;
		SetI3DL2Parameters();
	}
}

//------------------------------------------------------------------------------
//	CModule::CModule
//------------------------------------------------------------------------------
CModule::CModule(
				 IN const CModule&	module
				 ) : CUnique()
/*++

Routine Description:

	Copy constructor. This method will not copy patches.

Arguments:

	IN module -	Module to copy

Return Value:

	None

--*/
{
	int		i;
	CJack*	pJack;

	Initialize();

	m_type					= module.m_type;
	m_colorFlag				= module.m_colorFlag;
	m_state					= module.m_state;
	m_pGraph				= module.m_pGraph;
	m_stats					= module.m_stats;
	m_dspCode				= module.m_dspCode;
	m_stateFilename			= module.m_stateFilename;
	m_dspCycles				= module.m_dspCycles;
	m_yMemSize				= module.m_yMemSize;
	m_scratchLength			= module.m_scratchLength;
	m_activeConfig			= module.m_activeConfig;
	m_mixbin				= module.m_mixbin;
	m_fIIR2Frequency		= module.m_fIIR2Frequency;
	m_fIIR2Q				= module.m_fIIR2Q;
	m_I3DL2Listener			= module.m_I3DL2Listener;
	m_I3DL2ListenerDefault	= module.m_I3DL2ListenerDefault;
	m_name					= module.m_name;
	m_effectName			= module.m_effectName;
	SetDisplayName();

	// Copy the configs
	if(module.m_configs.GetSize() != 0)
	{
		m_configs.SetSize(module.m_configs.GetSize());
		for(i=0; i<module.m_configs.GetSize(); ++i)
			m_configs[i] = module.m_configs[i];
	}

	CreatePenAndBrush();

	// Inputs
	for(i=0; i<module.m_inputs.GetSize(); ++i)
	{
		pJack	= new CJack(this);
		*pJack	= *module.m_inputs[i];
		m_inputs.Add(pJack);
	}

	// Outputs
	for(i=0; i<module.m_outputs.GetSize(); ++i)
	{
		pJack	= new CJack(this);
		*pJack	= *module.m_outputs[i];
		m_outputs.Add(pJack);
	}

	// Parameters
	m_parameters.Copy(module.m_parameters);

	SetRect(module.m_rect);

	// Special Case: IIR2?
	if(!m_effectName.CompareNoCase(_T("iir2")))
		m_bIIR2 = TRUE;

	else if(!m_effectName.CompareNoCase(_T("i3dl2 reverb")) ||
			!m_effectName.CompareNoCase(_T("i3dl2 24k reverb")))
	{
		m_bI3DL2 = TRUE;
		SetI3DL2Parameters();
	}
}

//------------------------------------------------------------------------------
//	CModule::CModule
//------------------------------------------------------------------------------
CModule::CModule(void) : CUnique()
/*++

Routine Description:

	Constructor. Does almost nothing

Arguments:

	None

Return Value:

	None

--*/
{
	Initialize();
}

//------------------------------------------------------------------------------
//	CModule::~CModule
//------------------------------------------------------------------------------
CModule::~CModule(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	// Destroy the dialog
	if(m_pParameterDialog)
		m_pParameterDialog->DestroyWindow();

	if(!m_bBadData)
		Disconnect();

	// Delete the font?
	--m_stateFontRef;
	if(m_stateFontRef == 0)
	{
		delete m_stateFont;
		m_stateFont = NULL;
	}

	// Delete all the patches & connections
	for(i=0; i<m_outputs.GetSize(); ++i)
		delete m_outputs[i];
	m_outputs.RemoveAll();

	for(i=0; i<m_inputs.GetSize(); ++i)
		delete m_inputs[i];
	m_inputs.RemoveAll();

	m_configs.RemoveAll();

	m_parameters.RemoveAll();
}

//------------------------------------------------------------------------------
//	CModule::SetLocation
//------------------------------------------------------------------------------
void
CModule::SetRect(
				 IN const CRect&	rect
				 )
/*++

Routine Description:

	Sets the location of the module

Arguments:

	IN rect -	Rect

Return Value:

	None

--*/
{
	int	y;
	int	i;

	m_rect = rect;

	// Calculate the name rectangle
	m_nameRect.top		= m_rect.top;
	m_nameRect.left		= m_rect.left;
	m_nameRect.bottom	= m_nameRect.top + SCALE;
	m_nameRect.right	= m_rect.right;

	// Calculate the config rectangle
	m_configRect.top	= m_rect.top + SCALE;
	m_configRect.left	= m_rect.left;
	m_configRect.bottom	= m_configRect.top + SCALE;
	m_configRect.right	= m_rect.right;

	// Calculate the stats rectangle
	m_statsRect.top		= m_rect.bottom - SCALE;
	m_statsRect.left	= m_rect.left;
	m_statsRect.bottom	= m_rect.bottom;
	m_statsRect.right	= m_rect.right;

	// Calculate the rectangles for the connection labels
	for(y=m_rect.top+SCALE, i=0; i<m_inputs.GetSize(); ++i, y+=SCALE)
	{
		m_inputs[i]->SetRect(CRect(m_rect.left + (SCALE / 2) + 2, y,
								   m_rect.right - (SCALE / 2) - 3, y + SCALE));
	}
	for(y=m_rect.top+SCALE, i=0; i<m_outputs.GetSize(); ++i, y+=SCALE)
	{
		m_outputs[i]->SetRect(CRect(m_rect.left + (SCALE / 2) + 2, y,
									m_rect.right - (SCALE / 2) - 3, y + SCALE));
	}
}

//------------------------------------------------------------------------------
//	CModule::Draw
//------------------------------------------------------------------------------
void
CModule::Draw(
			  IN CDC*	pDC
			  )
/*++

Routine Description:

	Draws the modules.
	Draws the outline, the filled interior and the name(s) of the module

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	int				i;
	CPen*			oldPen;
	CBrush*			oldBrush;
	static CPoint	point(10, 10);

	// Setup to draw
	oldPen = pDC->SelectObject(&m_pen);
	if(m_state == CModule::OK)
		oldBrush = (CBrush*)pDC->SelectObject(&m_brush);
	else if((m_state == CModule::MOVING) || m_bHighlight)
		oldBrush = (CBrush*)pDC->SelectObject(&m_movingBrush);
	else
		oldBrush = (CBrush*)pDC->SelectStockObject(NULL_BRUSH);

	// Draw
	pDC->RoundRect(m_rect, point);

	// Draw the state
	if(m_state == CModule::INVALID)
	{
		int		offset = SCALE / 2;
		CPen	pen(PS_SOLID, 7, RGB(255, 0, 0));
		CPen*	statePen = pDC->SelectObject(&pen);

		pDC->MoveTo(m_rect.left + offset, m_rect.top + offset);
		pDC->LineTo(m_rect.right - offset, m_rect.bottom - offset);
		pDC->MoveTo(m_rect.left + offset, m_rect.bottom - offset);
		pDC->LineTo(m_rect.right - offset, m_rect.top + offset);
		
		pDC->SelectObject(statePen);
	}

	// Draw the name
	pDC->SetTextColor(RGB(0,0,0));
	pDC->SetBkMode(TRANSPARENT);
	if(m_state != CModule::MOVING)
		pDC->DrawText(m_displayName, m_nameRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
	else
		pDC->DrawText(m_movingName, m_nameRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

	// Draw the configuration
	if(m_activeConfig != -1)
		pDC->DrawText(m_configs[m_activeConfig].name, m_configRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

	// Draw the connections
	for(i=0; i<m_inputs.GetSize(); ++i)
		m_inputs[i]->Draw(pDC);
	for(i=0; i<m_outputs.GetSize(); ++i)
		m_outputs[i]->Draw(pDC);

	// Draw the statistics
	pDC->DrawText(m_stats, m_statsRect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

	// Restore the graphics state
	pDC->SelectObject(oldPen);
	pDC->SelectObject(oldBrush);
}

//------------------------------------------------------------------------------
//	CModule::AreInputsPatched
//------------------------------------------------------------------------------
BOOL 
CModule::AreInputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if any of the inputs are patched

Arguments:

	None

ReturnValue:

	TRUE if any of the inputs are patched

--*/
{
	int	i;

	for(i=0; i<m_inputs.GetSize(); ++i)
	{
		if(m_inputs[i]->IsPatched())
			return TRUE;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CModule::AreOutputsPatched
//------------------------------------------------------------------------------
BOOL 
CModule::AreOutputsPatched(void) const
/*++

Routine Description:

	Returns TRUE if any of the outputs are patched

Arguments:

	None

ReturnValue:

	TRUE if any of the outputs are patched

--*/
{
	int	i;

	for(i=0; i<m_outputs.GetSize(); ++i)
	{
		if(m_outputs[i]->IsPatched())
			return TRUE;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CModule::IsPatched
//------------------------------------------------------------------------------
BOOL 
CModule::IsPatched(void) const
/*++

Routine Description:

	Returns TRUE if any of the inputs or outputs of the module are patched

Arguments:

	None

ReturnValue:

	TRUE if the module is patched

--*/
{
	return AreInputsPatched() || AreOutputsPatched();
}

//------------------------------------------------------------------------------
//	CModule::Disconnect
//------------------------------------------------------------------------------
void 
CModule::Disconnect(void)
/*++

Routine Description:

	Disconnect all connections

Arguments:

	None

ReturnValue:

	None

--*/
{
	DisconnectInputs();
	DisconnectOutputs();
}

//------------------------------------------------------------------------------
//	CModule::DisconnectInputs
//------------------------------------------------------------------------------
void 
CModule::DisconnectInputs(void)
/*++

Routine Description:

	Disconnects all inputs

Arguments:

	None

ReturnValue:

	None

--*/
{
	int i;

	for(i=0; i<m_inputs.GetSize(); ++i)
	{
		if(m_inputs[i]->IsPatched())
			m_pGraph->DeletePatchCord(m_inputs[i]->GetPatchCord());
	}
}

//------------------------------------------------------------------------------
//	CModule::DisconnectOutputs
//------------------------------------------------------------------------------
void 
CModule::DisconnectOutputs(void)
/*++

Routine Description:

	Disconnects all outputs

Arguments:

	None

ReturnValue:

	None

--*/
{
	int i;

	if(m_bBadData)
		return;

	for(i=0; i<m_outputs.GetSize(); ++i)
	{
		if(m_outputs[i]->IsPatched())
			m_pGraph->DeletePatchCord(m_outputs[i]->GetPatchCord());
	}
}

//------------------------------------------------------------------------------
//	CModule::IsConnected
//------------------------------------------------------------------------------
BOOL 
CModule::IsConnected(void) const
/*++

Routine Description:

	Returns TRUE if the module is connected to a valid input or output

Arguments:

	None

Return Value:

	TRUE if the module is connected to a valid input or output, FALSE otherwise

--*/
{
	int		i;

	// TODO: Check state of patches to see they are valid, not disconnected or 
	// invalid
	for(i=0; i<m_inputs.GetSize(); ++i)
	{
		if(m_inputs[i]->IsPatched())
			return TRUE;
	}
	for(i=0; i<m_outputs.GetSize(); ++i)
	{
		if(m_outputs[i]->IsPatched())
			return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CModule::AddConfiguration
//------------------------------------------------------------------------------
void 
CModule::AddConfiguration(
						  IN LPCTSTR	pName,
						  IN LPCTSTR	pStateFilename
						  )
/*++

Routine Description:

	Adds a configuration to the effect

Arguments:

	IN pName -			Name of configuration
	IN pStateFilename -	State Filename

Return Value:

	None

--*/
{
	Config	config;

	config.name				= pName;
	config.stateFilename	= pStateFilename;
	m_configs.Add(config);

	if(m_activeConfig == -1)
		m_activeConfig = 0;
}

//------------------------------------------------------------------------------
//	CModule::GetStateFilename
//------------------------------------------------------------------------------
LPCTSTR 
CModule::GetStateFilename(void) const 
/*++

Routine Description:

	Returns the state filename

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_activeConfig == -1)
		return (LPCTSTR)m_stateFilename; 
	return m_configs[m_activeConfig].stateFilename;
}

//------------------------------------------------------------------------------
//	CModule::Move
//------------------------------------------------------------------------------
void 
CModule::Move(
			  IN const CPoint&	point
			  )
/*++

Routine Description:

	Moves the module to a new location

Arguments:

	IN point -	New upper left corner

Return Value:

	None

--*/
{
	SetRect(CRect(point.x, point.y, m_rect.Width() + point.x, 
				  m_rect.Height() + point.y));
}

//------------------------------------------------------------------------------
//	CModule::GetJack
//------------------------------------------------------------------------------
CJack*
CModule::GetJack(
				 IN const CPoint&	point,
				 IN BOOL			bSmallJacks
				 ) const
/*++

Routine Description:

	Returns a jack for the point

Arguments:

	IN point -			Point to query
	IN bSmallJacks -	Assume the jacks are small

Return Value:

	The jack or NULL

--*/
{
	int	index;
	
	if(::IsPointInRect(point.x, point.y, m_rect))
	{
		// Use the small jacks for picking?
		if(bSmallJacks)
		{
			if(point.x <= (m_rect.left + SCALE))
			{
				// One input?
				if(m_inputs.GetSize() == 1)
					return m_inputs[0];

				// Many inputs?
				else
				{
					index = (point.y - m_rect.top) / SCALE - 1;
					if((index >= 0) && (index < m_inputs.GetSize()))
						return m_inputs[index];
				}
			}

			// Output?
			else if(point.x >= (m_rect.right - SCALE))
			{
				// One output?
				if(m_outputs.GetSize() == 1)
					return m_outputs[0];

				// Many outputs?
				else
				{
					index = (point.y - m_rect.top) / SCALE - 1;
					if((index >= 0) && (index < m_outputs.GetSize()))
						return m_outputs[index];
				}
			}
		}

		// Otherwise, use the entire rect as a pick target
		else
		{
			// Any inputs?
			if(m_inputs.GetSize())
			{
				// Inputs and outputs
				if(m_outputs.GetSize())
				{
					// Input?
					if(point.x <= m_rect.CenterPoint().x)
					{
						// One input?
						if(m_inputs.GetSize() == 1)
							return m_inputs[0];

						// Many inputs?
						else
						{
							index = (point.y - m_rect.top) / SCALE - 1;
							if((index >= 0) && (index < m_inputs.GetSize()))
								return m_inputs[index];
						}
					}

					// Output?
					else if(point.x >= m_rect.CenterPoint().x)
					{
						// One output?
						if(m_outputs.GetSize() == 1)
							return m_outputs[0];

						// Many outputs?
						else
						{
							index = (point.y - m_rect.top) / SCALE - 1;
							if((index >= 0) && (index < m_outputs.GetSize()))
								return m_outputs[index];
						}
					}
				}

				// Only inputs
				else
				{
					// One input?
					if(m_inputs.GetSize() == 1)
						return m_inputs[0];

					// Many inputs
					else
					{
						index = (point.y - m_rect.top) / SCALE - 1;
						if((index >= 0) && (index < m_inputs.GetSize()))
							return m_inputs[index];
					}
				}
			}

			// Only outputs
			else if(m_outputs.GetSize())
			{
				// One outputs
				if(m_outputs.GetSize() == 1)
					return m_outputs[0];

				// Many outputs
				else
				{
					index = (point.y - m_rect.top) / SCALE - 1;
					if((index >= 0) && (index < m_outputs.GetSize()))
						return m_outputs[index];
				}
			}
		}
	}
	return NULL;
}

#if 0
//------------------------------------------------------------------------------
//	CModule::GetJack
//------------------------------------------------------------------------------
CJack*
CModule::GetJack(
				 IN const CPatchCord*	pPatchCord
				 ) const
/*++

Routine Description:

	Returns the jack that contains the patch cord

Arguments:

	IN pPatchCord -	Patch cord to look up

Return Value:

	The jack or NULL

--*/
{
	int	i;

	for(i=0; i<m_inputs.GetSize(); ++i)
	{
		if(m_inputs[i]->GetOwnPatchCord() == pPatchCord)
			return m_inputs[i];
	}
	for(i=0; i<m_outputs.GetSize(); ++i)
	{
		if(m_outputs[i]->GetOwnPatchCord() == pPatchCord)
			return m_outputs[i];
	}

	// This should never be hit
	return NULL;
}
#endif

//------------------------------------------------------------------------------
//	CModule::SetState
//------------------------------------------------------------------------------
void 
CModule::SetState(
				  IN State state
				  )
/*++
Routine Description:

	Sets the state of the module

Arguments:

	IN state -	State

Return Value:

	None

--*/
{
	if(m_state != state)
	{
		m_state = state;
		m_pGraph->Draw(m_rect);
	}
}

//------------------------------------------------------------------------------
//	CModule::Write
//------------------------------------------------------------------------------
void 
CModule::Write(
			   IN CFile& file
			   )
/*++

Routine Description:

	Writes the object to a file

Arguments:

	IN file -	File to write to

Return Value:

	None

--*/
{
	WORD	word;
	DWORD	dword;
	CString	string;
	int		i;

	try
	{
		// name
		file.Write((LPCTSTR)m_name, ((unsigned)m_name.GetLength() + 1) * sizeof(TCHAR));

		// effect name
		file.Write((LPCTSTR)m_effectName, ((unsigned)m_effectName.GetLength() + 1) * sizeof(TCHAR));

		// Write the id
		CUnique::Write(file);

		// ini name
		file.Write((LPCTSTR)m_iniName, ((unsigned)m_iniName.GetLength() + 1) * sizeof(TCHAR));

		// Write the index
		file.Write(&m_index, sizeof(m_index));

		// Type
		file.Write(&m_type, sizeof(m_type));

		// State
		file.Write(&m_state, sizeof(m_state));

		// Rect
		file.Write((LPRECT)m_rect, sizeof(RECT));

		// nameRect
		file.Write((LPRECT)m_nameRect, sizeof(RECT));

		// config rect
		file.Write((LPRECT)m_configRect, sizeof(RECT));

		// stats
		file.Write((LPCTSTR)m_stats, ((unsigned)m_stats.GetLength() + 1) * sizeof(TCHAR));

		// stats rect
		file.Write((LPRECT)m_statsRect, sizeof(RECT));

		// dspcode
		file.Write((LPCTSTR)m_dspCode, ((unsigned)m_dspCode.GetLength() + 1) * sizeof(TCHAR));

		// state filename
		file.Write((LPCTSTR)m_stateFilename, ((unsigned)m_stateFilename.GetLength() + 1) * sizeof(TCHAR));

		// dsp cycles
		file.Write(&m_dspCycles, sizeof(m_dspCycles));

		// ymemsize
		file.Write(&m_yMemSize, sizeof(m_yMemSize));

		// Scratch size
		file.Write(&m_scratchLength, sizeof(m_scratchLength));

		// activeconfig
		file.Write(&m_activeConfig, sizeof(m_activeConfig));

		// colorflag
		file.Write(&m_colorFlag, sizeof(m_colorFlag));

		// mixbin
		file.Write(&m_mixbin, sizeof(m_mixbin));

		// iir2 frequency
		file.Write(&m_fIIR2Frequency, sizeof(m_fIIR2Frequency));

		// iir2 Q
		file.Write(&m_fIIR2Q, sizeof(m_fIIR2Q));

		// iir2 Gain DB
		file.Write(&m_fIIR2GainDB, sizeof(m_fIIR2GainDB));

		// iir2 frequency default
		file.Write(&m_fIIR2Frequency, sizeof(m_fIIR2FrequencyDefault));

		// iir2 Q default
		file.Write(&m_fIIR2QDefault, sizeof(m_fIIR2QDefault));

		// iir2 gain db default
		file.Write(&m_fIIR2GainDBDefault, sizeof(m_fIIR2GainDBDefault));

		// inputs
		word = (WORD)m_inputs.GetSize();
		file.Write(&word, sizeof(word));
		for(i=0; i<m_inputs.GetSize(); ++i)
			m_inputs[i]->Write(file);

		// outputs
		word = (WORD)m_outputs.GetSize();
		file.Write(&word, sizeof(word));
		for(i=0; i<m_outputs.GetSize(); ++i)
			m_outputs[i]->Write(file);

		// configs
		word = (WORD)m_configs.GetSize();
		file.Write(&word, sizeof(word));
		for(i=0; i<m_configs.GetSize(); ++i)
		{
			file.Write((LPCTSTR)m_configs[i].name, ((unsigned)m_configs[i].name.GetLength() + 1) * sizeof(TCHAR));
			file.Write((LPCTSTR)m_configs[i].stateFilename, ((unsigned)m_configs[i].stateFilename.GetLength() + 1) * sizeof(TCHAR));
		}

		// Write the current parameter settings
		word = (WORD)m_parameters.GetSize();
		file.Write(&word, sizeof(word));
		for(i=0; i<m_parameters.GetSize(); ++i)
		{
			string = m_parameters[i].GetName();
			file.Write((LPCTSTR)string, ((unsigned)string.GetLength() + 1) * sizeof(TCHAR));
			dword = m_parameters[i].GetOffset();
			file.Write(&dword, sizeof(dword));
			dword = m_parameters[i].GetValue();
			file.Write(&dword, sizeof(dword));
		}
	}
	catch(...)
	{
		throw;
	}
}

//-----------------------------------------------------------------o-------------
//	CModule::FixPointers
//------------------------------------------------------------------------------
void 
CModule::FixPointers(
					 IN const CGraph* pGraph
					 )
/*++

Routine Description:

	Fixes the internal pointers from a read

Arguments:

	IN pGraph -	Graph to use to correct pointers

Return Value:

	None

--*/
{
	int	i;

	m_pGraph = (CGraph*)pGraph;

	for(i=0; i<m_inputs.GetSize(); ++i)
		m_inputs[i]->FixPointers(pGraph);
	for(i=0; i<m_outputs.GetSize(); ++i)
		m_outputs[i]->FixPointers(pGraph);

	m_bBadData = FALSE;
}

//------------------------------------------------------------------------------
//	CModule::Read
//------------------------------------------------------------------------------
BOOL
CModule::Read(
			  IN CFile& file,
			  IN BYTE	version
			  )
/*++

Routine Description:

	Constructor. Reads from a file

Arguments:

	IN file -		File to read from
	IN version -	File version

Return Value:

	None

--*/
{
	int				i;
	WORD			word;
	DWORD			dwOffset;
	DWORD			dwValue;
	CString			string;
	CJack*			pJack;
	CModule::Config	config;
	CParameter		param;
	BOOL			ret	= TRUE;
	
	m_bBadData = TRUE;

	// name
	if(!CGraph::ReadString(file, m_name))
		return FALSE;

	// effect name
	if(version >= 4)
	{
		if(!CGraph::ReadString(file, m_effectName))
			return FALSE;
	}
	else
		m_effectName = m_name;

	// Special Case: IIR2?
	if(!m_effectName.CompareNoCase(_T("iir2")))
		m_bIIR2 = TRUE;

	// Special Case: I3DL2
	else if(!m_effectName.CompareNoCase(_T("i3dl2 reverb")) ||
			!m_effectName.CompareNoCase(_T("i3dl2 24k reverb")))
	{
		m_bI3DL2 = TRUE;
	}

	// Read the id
	if(!CUnique::Read(file, version))
		return FALSE;
	
	// Version 3 or newer?
	if(version >= 3)
	{
		// ini name
		if(!CGraph::ReadString(file, m_iniName))
			return FALSE;

		// index
		if(file.Read(&m_index, sizeof(m_index)) != sizeof(m_index))
			return FALSE;
	}

	// Type
	if(file.Read(&m_type, sizeof(m_type)) != sizeof(m_type))
		return FALSE;

	// State
	if(file.Read(&m_state, sizeof(m_state)) != sizeof(m_state))
		return FALSE;

	// Rect
	if(file.Read((LPRECT)m_rect, sizeof(RECT)) != sizeof(RECT))
		return FALSE;

	// nameRect
	if(file.Read((LPRECT)m_nameRect, sizeof(RECT)) != sizeof(RECT))
		return FALSE;

	// config rect
	if(file.Read((LPRECT)m_configRect, sizeof(RECT)) != sizeof(RECT))
		return FALSE;

	// stats
	if(!CGraph::ReadString(file, m_stats))
		return FALSE;

	// stats rect
	if(file.Read((LPRECT)m_statsRect, sizeof(RECT)) != sizeof(RECT))
		return FALSE;

	// dspcode
	if(!CGraph::ReadString(file, m_dspCode))
		return FALSE;

	// state filename
	if(!CGraph::ReadString(file, m_stateFilename))
		return FALSE;

	// dsp cycles
	if(file.Read(&m_dspCycles, sizeof(m_dspCycles)) != sizeof(m_dspCycles))
		return FALSE;

	// ymemsize
	if(file.Read(&m_yMemSize, sizeof(m_yMemSize)) != sizeof(m_yMemSize))
		return FALSE;

	// Scratch size
	if(file.Read(&m_scratchLength, sizeof(m_scratchLength)) != sizeof(m_scratchLength))
		return FALSE;

	// activeconfig
	if(file.Read(&m_activeConfig, sizeof(m_activeConfig)) != sizeof(m_activeConfig))
		return FALSE;

	// colorflag
	if(file.Read(&m_colorFlag, sizeof(m_colorFlag)) != sizeof(m_colorFlag))
		return FALSE;

	// mixbin
	if(file.Read(&m_mixbin, sizeof(m_mixbin)) != sizeof(m_mixbin))
		return FALSE;

	// Version 3 or newer?
	if(version >= 3)
	{
		// iir2 frequency
		if(file.Read(&m_fIIR2Frequency, sizeof(m_fIIR2Frequency)) != sizeof(m_fIIR2Frequency))
			return FALSE;

		// iir2 Q
		if(file.Read(&m_fIIR2Q, sizeof(m_fIIR2Q)) != sizeof(m_fIIR2Q))
			return FALSE;

		// iir2 Gain DB
		if(file.Read(&m_fIIR2GainDB, sizeof(m_fIIR2GainDB)) != sizeof(m_fIIR2GainDB))
			return FALSE;

		// iir2 frequency default
		if(file.Read(&m_fIIR2FrequencyDefault, sizeof(m_fIIR2FrequencyDefault)) != sizeof(m_fIIR2FrequencyDefault))
			return FALSE;

		// iir2 Q default
		if(file.Read(&m_fIIR2QDefault, sizeof(m_fIIR2QDefault)) != sizeof(m_fIIR2QDefault))
			return FALSE;

		// iir2 gain db default
		if(file.Read(&m_fIIR2GainDBDefault, sizeof(m_fIIR2GainDBDefault)) != sizeof(m_fIIR2GainDBDefault))
			return FALSE;
	}

	// inputs
	if(file.Read(&word, sizeof(word)) != sizeof(word))
		return FALSE;
	for(i=0; ret && i<word; ++i)
	{
		pJack	= new CJack(this);
		ret		= pJack->Read(file, version);
		if(ret)
			m_inputs.Add(pJack);
		else
			delete pJack;
	}

	// outputs
	if(ret)
	{
		ret = (file.Read(&word, sizeof(word)) == sizeof(word));
		for(i=0; ret && i<word; ++i)
		{
			pJack	= new CJack(this);
			ret		= pJack->Read(file, version);
			if(ret)
				m_outputs.Add(pJack);
			else
				delete pJack;
		}
	}

	// configs
	if(ret)
	{
		ret = (file.Read(&word, sizeof(word)) == sizeof(word));
		for(i=0; ret && i<word; ++i)
		{
			ret = CGraph::ReadString(file, config.name);
			if(ret)
			{
				ret = CGraph::ReadString(file, config.stateFilename);
				if(ret)
					AddConfiguration(config.name, config.stateFilename);
			}
		}
	}

	// Read the current parameter settings
	if(ret)
	{
		ret = (file.Read(&word, sizeof(word)) == sizeof(word));
		for(i=0; ret && i<word; ++i)
		{
			ret = CGraph::ReadString(file, string);
			if(ret)
			{
				ret = (file.Read(&dwOffset, sizeof(dwOffset)) == sizeof(dwOffset));
				if(ret)
				{
					ret = (file.Read(&dwValue, sizeof(dwValue)) == sizeof(dwValue));
					if(ret)
					{
						param.SetName(string);
						param.SetOffset(dwOffset);
						param.SetValue(dwValue);
						m_parameters.Add(param);
					}
				}
			}
		}
	}

	// Success?
	if(ret)
	{
		SetDisplayName();
		CreatePenAndBrush();

		// Is this an IIR2?
		if(m_bIIR2)
		{
			ReorderIIR2Params();
			ConvertToIIR2();
		}

		// Or an i3dl2 reverb?
		else if(m_bI3DL2)
			SetI3DL2Parameters();

		return TRUE;
	}

	// Error cleanup
	for(i=0; i<m_inputs.GetSize(); ++i)
		delete m_inputs[i];
	m_inputs.RemoveAll();
	for(i=0; i<m_outputs.GetSize(); ++i)
		delete m_outputs[i];
	m_outputs.RemoveAll();
	m_configs.RemoveAll();
	m_parameters.RemoveAll();

	return FALSE;
}

//------------------------------------------------------------------------------
//	CModule::SetParameters
//------------------------------------------------------------------------------
BOOL
CModule::SetParameters(
					   IN CWinDspImageBuilder*	pImageBuilder, 
					   IN const char*			pFilename
					   )
/*++

Routine Description:

	Sets the effect parameters by calling a CWinDspImageBuilder method

Arguments:

	IN pImageBuilder -	CWinDspImageBuilder to call
	IN pFilename -		Filename

Return Value:

	TRUE on success, FALSE on failure

--*/
{
	FX_STATE_PARAMETERS*			pStateParms;
	int								i;
	CParameter						parm;
	CArray<CParameter, CParameter&>	tempParms;
	int								p;
	CString							string;

	if(!pImageBuilder)
		return FALSE;

	// Copy existing parms to update loaded values
	if(m_parameters.GetSize())
	{
		tempParms.Copy(m_parameters);
		m_parameters.RemoveAll();
	}

	// Read the parameters
	if(pImageBuilder->ParseParameterDescriptions(pFilename, &pStateParms) != ERROR_SUCCESS)
	{
		if(pStateParms)
			delete pStateParms;
		return FALSE;
	}

	for(i=0; i<(int)pStateParms->dwNumParams; ++i)
	{
		parm = pStateParms->aParamDescriptions[i];
		m_parameters.Add(parm);
	}

	// Look through the saved parameters and update the loaded ones
	for(i=0; i<tempParms.GetSize(); ++i)
	{
		string = tempParms[i].GetName();
		for(p=0; p<m_parameters.GetSize(); ++p)
		{
			// Does the name and offset match?
			if((string.Compare(m_parameters[p].GetName()) == 0) &&
			   (tempParms[i].GetOffset() == m_parameters[p].GetOffset()))
			{
				m_parameters[p].SetValue(tempParms[i].GetValue());
				break;
			}
		}
	}

	delete pStateParms;

	if(m_bIIR2)
		ReorderIIR2Params();

	return TRUE;
}

//------------------------------------------------------------------------------
//	CModule::ShowProperties
//------------------------------------------------------------------------------
void
CModule::ShowProperties(void)
/*++

Routine Description:

	Displays a properties dialog that allow the user to edit the parameters

Arguments:

	None

Return Value:

	None

--*/
{
	int					i;
	CKnob*				pKnob;
	double				fVal;
	double				fDefault;
	double				fMin;
	double				fMax;
	CKnob::DataType		type;
	CString				format;
	CRect				rect;
	LONG				x;
	LONG				y;

	// If the dialog already exists, just bring it to the top
	if(m_pParameterDialog)
	{
		m_pParameterDialog->BringWindowToTop();
		return;
	}

	// Create the dialog
	m_pParameterDialog = new CParameterDialog(this, m_displayName);
	m_pParameterDialog->Create(IDD_PARAMETER_DIALOG);

	// Special Cases: IIR2
	if(m_bIIR2)
	{
		pKnob = new CKnob(this, 0, _T("Frequency"), TRUE, CKnob::TYPE_FLOAT, 0.0, 20000.0, 
						  m_fIIR2Frequency, m_fIIR2FrequencyDefault, 
						  _T("%.0lf"), _T("Hz"));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 1, _T("Q"), TRUE, CKnob::TYPE_FLOAT, 0.01, 30.0, m_fIIR2Q, 
						  m_fIIR2QDefault, _T("%.2lf"), _T(""));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 2, _T("Gain"), TRUE, CKnob::TYPE_FLOAT, -30.0, 30.0, 
						  m_fIIR2GainDB, m_fIIR2GainDBDefault, _T("%.1lf"),
						  _T("DB"));
		m_pParameterDialog->AddKnob(pKnob);
	}

	else if(m_bI3DL2)
	{
		pKnob = new CKnob(this, 0, _T("Room"), TRUE, CKnob::TYPE_LONG, 
						  (double)I3DL2LISTENER_MINROOM, 
						  (double)I3DL2LISTENER_MAXROOM, 
						  (double)m_I3DL2Listener.lRoom, 
						  (double)m_I3DL2ListenerDefault.lRoom,
						  _T("%ld"), _T("mB"));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 1, _T("Room HF"), TRUE, CKnob::TYPE_LONG, 
						  (double)I3DL2LISTENER_MINROOMHF,
						  (double)I3DL2LISTENER_MAXROOMHF, 
						  (double)m_I3DL2Listener.lRoomHF, 
						  (double)m_I3DL2ListenerDefault.lRoomHF, 
						  _T("%ld"), _T("mB"));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 2, _T("Room Rolloff"), TRUE, CKnob::TYPE_FLOAT, 
						  (double)I3DL2LISTENER_MINROOMROLLOFFFACTOR, 
						  (double)I3DL2LISTENER_MAXROOMROLLOFFFACTOR, 
						  (double)m_I3DL2Listener.flRoomRolloffFactor, 
						  (double)m_I3DL2ListenerDefault.flRoomRolloffFactor, 
						  _T("%.2lf"), _T(""));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 3, _T("Decay Time"), TRUE, CKnob::TYPE_FLOAT, 
						  (double)I3DL2LISTENER_MINDECAYTIME, 
						  (double)I3DL2LISTENER_MAXDECAYTIME, 
						  (double)m_I3DL2Listener.flDecayTime, 
						  (double)m_I3DL2ListenerDefault.flDecayTime, 
						  _T("%.3lf"), _T("Seconds"));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 4, _T("Decay HF Ratio"), TRUE, CKnob::TYPE_FLOAT, 
						  (double)I3DL2LISTENER_MINDECAYHFRATIO, 
						  (double)I3DL2LISTENER_MAXDECAYHFRATIO, 
						  (double)m_I3DL2Listener.flDecayHFRatio, 
						  (double)m_I3DL2ListenerDefault.flDecayHFRatio, 
						  _T("%.2lf"), _T(""));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 5, _T("Reflections"), TRUE, CKnob::TYPE_LONG, 
						  (double)I3DL2LISTENER_MINREFLECTIONS,
						  (double)I3DL2LISTENER_MAXREFLECTIONS, 
						  (double)m_I3DL2Listener.lReflections, 
						  (double)m_I3DL2ListenerDefault.lReflections, 
						  _T("%ld"), _T(""));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 6, _T("Reflections Delay"), TRUE, CKnob::TYPE_LONG, 
						  (double)I3DL2LISTENER_MINREFLECTIONSDELAY * 1000.0,// Convert to ms
						  (double)I3DL2LISTENER_MAXREFLECTIONSDELAY * 1000.0,// Convert to ms
						  (double)m_I3DL2Listener.flReflectionsDelay * 1000.0,// Convert to ms
						  (double)m_I3DL2ListenerDefault.flReflectionsDelay * 1000.0,// Convert to ms
						  _T("%ld"), _T("ms"));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 7, _T("Reverb"), TRUE, CKnob::TYPE_LONG, 
						  (double)I3DL2LISTENER_MINREVERB,
						  (double)I3DL2LISTENER_MAXREVERB, 
						  (double)m_I3DL2Listener.lReverb, 
						  (double)m_I3DL2ListenerDefault.lReverb, 
						  _T("%ld"), _T(""));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 8, _T("Reverb Delay"), TRUE, CKnob::TYPE_LONG, 
						  (double)I3DL2LISTENER_MINREVERBDELAY * 1000.0,// Convert to ms
						  (double)I3DL2LISTENER_MAXREVERBDELAY * 1000.0,// Convert to ms 
						  (double)m_I3DL2Listener.flReverbDelay * 1000.0,// Convert to ms 
						  (double)m_I3DL2ListenerDefault.flReverbDelay * 1000.0,// Convert to ms 
						  _T("%ld"), _T("ms"));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 9, _T("Diffusion"), TRUE, CKnob::TYPE_FLOAT, 
						  (double)I3DL2LISTENER_MINDIFFUSION,
						  (double)I3DL2LISTENER_MAXDIFFUSION, 
						  (double)m_I3DL2Listener.flDiffusion, 
						  (double)m_I3DL2ListenerDefault.flDiffusion, 
						  _T("%.1lf"), _T("%"));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 10, _T("Density"), TRUE, CKnob::TYPE_FLOAT, 
						  (double)I3DL2LISTENER_MINDENSITY,
						  (double)I3DL2LISTENER_MAXDENSITY, 
						  (double)m_I3DL2Listener.flDensity, 
						  (double)m_I3DL2ListenerDefault.flDensity, 
						  _T("%.1lf"), _T("%"));
		m_pParameterDialog->AddKnob(pKnob);
		pKnob = new CKnob(this, 11, _T("HF Reference"), TRUE, CKnob::TYPE_LONG, 
						  (double)I3DL2LISTENER_MINHFREFERENCE,
						  (double)I3DL2LISTENER_MAXHFREFERENCE, 
						  (double)m_I3DL2Listener.flHFReference, 
						  (double)m_I3DL2ListenerDefault.flHFReference, 
						  _T("%ld"), _T("Hz"));
		m_pParameterDialog->AddKnob(pKnob);
	}

	// If there are no parameters, there will be no dialog
	else if(m_parameters.GetSize() != 0)
	{
		// Create the knobs for all the parameters
		for(i=0; i<m_parameters.GetSize(); ++i)
		{
			// Float data?
			if(m_parameters[i].GetType() == DSFX_PARAM_TYPE_FLOAT)
			{
				type		= CKnob::TYPE_DOUBLE;
				fMin		= ToDouble(m_parameters[i].GetMin());
				fMax		= ToDouble(m_parameters[i].GetMax());
				fVal		= ToDouble(m_parameters[i].GetValue());
				fDefault	= ToDouble(m_parameters[i].GetDefault());
				if(fabs(fMax - fMin) < 1.0)
					format = _T("%.2le");
				else
					format = _T("%.2lf");
			}

			// Integer data
			else
			{
				type		= CKnob::TYPE_UNSIGNED_LONG;
				format		= _T("%lu");
				fMin		= m_parameters[i].GetMin();
				fMax		= m_parameters[i].GetMax();
				fVal		= (double)m_parameters[i].GetValue();
				fDefault	= (double)m_parameters[i].GetDefault();
			}

			pKnob = new CKnob(this, i, m_parameters[i].GetName(), 
							  m_parameters[i].GetAtomic(), type, fMin, fMax, fVal, 
							  fDefault, format, m_parameters[i].GetUnits());
			m_pParameterDialog->AddKnob(pKnob);
		}
	}

	else 
		return;

	// Update the dialog
	m_pParameterDialog->UpdateKnobs();
	m_pParameterDialog->SetRealtime(m_bRealtime);
	m_bRealtime = m_pParameterDialog->GetRealtime();

	// Place the dialog
	rect = m_rect;
	m_pGraph->GetParent()->ClientToScreen(&rect);
	x = (rect.right + rect.left) / 2;
	y = (rect.bottom + rect.top) / 2;
	m_pParameterDialog->GetWindowRect(&rect);
	m_pParameterDialog->MoveWindow(x, y, rect.Width(), rect.Height());

	// Display the dialog
	m_pParameterDialog->ShowWindow(SW_SHOW);
}

//------------------------------------------------------------------------------
//	CModule::SetEffectName
//------------------------------------------------------------------------------
void 
CModule::SetEffectName(void)
/*++

Routine Description:

	Pops up a dialog that allows the user to select a new name for the effect

Arguments:

	None

Return Value:

	None

--*/
{
	CEffectNameDialog	dialog(m_effectName, m_name);

	if(dialog.DoModal() == IDOK)
	{
		m_name = dialog.GetName();
		SetDisplayName();
		if(m_pGraph)
			m_pGraph->Draw(m_rect);
		
		// If the properties dialog is visible change the name there as well
		if(m_pParameterDialog)
			m_pParameterDialog->SetWindowText(m_name);
	}
}

//------------------------------------------------------------------------------
//	CModule::ChangeParameter
//------------------------------------------------------------------------------
void 
CModule::ChangeParameter(
						 IN const CKnob*	pKnob, 
						 IN BOOL			bTransmit
						 )
/*++

Routine Description:

	Changes the value of a parameter

Arguments:

	IN index -	Index of parameter to change

Return Value:

	None

--*/
{
	DWORD	dwValue;

	if(pKnob == NULL)
	{
		if(bTransmit)
			m_pGraph->TransmitModuleParameters(this);
		return;
	}

	// Special Case: IIR2
	if(m_bIIR2)
	{
		switch(pKnob->GetIndex())
		{
		case 0:	// Frequency
			m_fIIR2Frequency = pKnob->GetPos();
			break;
		case 1:	// Q
			m_fIIR2Q = pKnob->GetPos();
			break;
		case 2:	// Gain DB
			m_fIIR2GainDB = pKnob->GetPos();
			break;
		default:
			break;
		}

		ConvertToIIR2();
		m_pGraph->ChangesMade();

		if(bTransmit)
			m_pGraph->TransmitModuleParameters(this);
	}

	// Special Case: I3DL2
	else if(m_bI3DL2)
	{
		switch(pKnob->GetIndex())
		{
		case 0:
			m_I3DL2Listener.lRoom = (LONG)pKnob->GetPos();
			break;
		case 1:
			m_I3DL2Listener.lRoomHF = (LONG)pKnob->GetPos();
			break;
		case 2:
			m_I3DL2Listener.flRoomRolloffFactor = (FLOAT)pKnob->GetPos();
			break;
		case 3:
			m_I3DL2Listener.flDecayTime = (FLOAT)pKnob->GetPos();
			break;
		case 4:
			m_I3DL2Listener.flDecayHFRatio = (FLOAT)pKnob->GetPos();
			break;
		case 5:
			m_I3DL2Listener.lReflections = (LONG)pKnob->GetPos();
			break;
		case 6:
			m_I3DL2Listener.flReflectionsDelay = (FLOAT)(pKnob->GetPos() / 1000.0); // Convert to seconds
			break;
		case 7:
			m_I3DL2Listener.lReverb = (LONG)pKnob->GetPos();
			break;
		case 8:
			m_I3DL2Listener.flReverbDelay = (FLOAT)(pKnob->GetPos() / 1000.0); // Convert to seconds
			break;
		case 9:
			m_I3DL2Listener.flDiffusion = (FLOAT)pKnob->GetPos();
			break;
		case 10:
			m_I3DL2Listener.flDensity = (FLOAT)pKnob->GetPos();
			break;
		case 11:
			m_I3DL2Listener.flHFReference = (FLOAT)pKnob->GetPos();
			break;
		default:
			break;
		}

		// Since these changes cannot be saved, don't mark changes made
		//m_pGraph->ChangesMade();

		if(bTransmit)
			m_pGraph->TransmitModuleParameters(this);

	}

	else
	{
		if((pKnob->GetIndex() >= 0) && (pKnob->GetIndex() < m_parameters.GetSize()))
		{
			if(m_parameters[pKnob->GetIndex()].GetType() == DSFX_PARAM_TYPE_FLOAT)
				dwValue = ToDWORD(pKnob->GetPos());
			else
				dwValue = (DWORD)pKnob->GetPos();

			m_parameters[pKnob->GetIndex()].SetValue(dwValue);
			m_pGraph->ChangesMade();

			if(bTransmit)
				m_pGraph->TransmitModuleParameters(this, pKnob->GetIndex());
		}
	}
}

//------------------------------------------------------------------------------
//	CModule::WriteStateFile
//------------------------------------------------------------------------------
BOOL
CModule::WriteStateFile(
						IN LPCTSTR	pFilePath
						)
/*++

Routine Description:

	Generates a state file for the current parameters

Arguments:

	IN pFilePath -	Path to file
	
Return Value:

	TRUE on success, FALSE on failure

--*/
{
	CStdioFile	inFile;
	CStdioFile	outFile;
	CString		string;
	CString		line;
	BOOL		bModified;
	int			i;
	int			index;
	CString		key;

	// Open the real state ini file
	string.Format(_T("%s\\%s"), m_pGraph->GetIniFilePath(), m_stateFilename);
	if(!inFile.Open(string, CFile::modeRead | CFile::typeText))
		return FALSE;

	// Open the output file
	if(!outFile.Open(pFilePath, CFile::modeWrite | CFile::modeCreate | CFile::typeText))
	{
		inFile.Close();
		return FALSE;
	}

	// Are there any modifiable parameters, or modified parameters
	for(bModified=FALSE, i=0; !bModified && i<m_parameters.GetSize(); ++i)
	{
		if(m_parameters[i].GetValue() != m_parameters[i].GetDefault())
			bModified = TRUE;
	}

	// If the parameters have been modified, write a modified file
	if(bModified)
	{
		// Read the file
		while(inFile.ReadString(line))
		{
			line.TrimLeft();
			line.TrimRight();
			string = line.Left(8);
			if(!string.CompareNoCase(_T("fx_param")))
			{
				string = line.Right(line.GetLength()-8);
				index = atoi(string);

				if(index < m_parameters.GetSize())
				{
					string = line.Left(line.Find('='));
					string.TrimRight();

					// Find the key
					key.Format(_T("FX_PARAM%d"), index);

					if(string == key)
					{
						string.Format(_T("FX_PARAM%d=%lu"), index, 
									  (DWORD)m_parameters[index].GetValue());
						outFile.WriteString(string);
					}
					else
						outFile.WriteString(line);	
				}
				else
					outFile.WriteString(line);
			}
			else
				outFile.WriteString(line);	
			outFile.WriteString(_T("\n"));	
		}
	}

	// If no parameters are modifed, just copy the file
	else
	{
		while(inFile.ReadString(line))
		{
			outFile.WriteString(line);
			outFile.WriteString(_T("\n"));	
		}
	}

	inFile.Close();
	outFile.Close();
	return TRUE;
}

//------------------------------------------------------------------------------
//	CModule::SetActiveConfig
//------------------------------------------------------------------------------
void 
CModule::SetActiveConfig(
						 IN int	config
						 )
/*++

Routine Description:

	Sets the active configuration

Arguments:

	IN config -	Must be < m_configs.GetSize() and > 0

Return Value:

	None

--*/
{
	m_activeConfig = config;
	
	if(m_bI3DL2)
		SetI3DL2Parameters();
}

//------------------------------------------------------------------------------
//	CModule::AreParametersModified
//------------------------------------------------------------------------------
BOOL 
CModule::AreParametersModified(void) const
/*++

Routine Description:

	Returns TRUE if any of the modules parameters have been modified

Arguments:

	None

Return Value:

	TRUE if any parameter is not a default parameter, FALSE otherwise

--*/
{
	int	i;

	for(i=0; i<m_parameters.GetSize(); ++i)
	{
		if(m_parameters[i].GetValue() != m_parameters[i].GetDefault())
			return TRUE;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CModule::ParameterDialogDestroyed
//------------------------------------------------------------------------------
void 
CModule::ParameterDialogDestroyed(void)
/*++

Routine Description:

	Called whenthe parameters dialog is destroyed

Arguments:

	None

Return Value:

	None

--*/
{
	m_pParameterDialog = NULL;
}

//------------------------------------------------------------------------------
//	CModule::CreatePenAndBrush
//------------------------------------------------------------------------------
void 
CModule::CreatePenAndBrush(void)
/*++

Routine Description:

	Creates a pen and brush based on the type of module

Arguments:

	None

Return Value:

	None

--*/
{
	m_movingBrush.CreateSolidBrush(RGB(100, 200, 100));

	switch(m_type)
	{
	case CModule::INPUT_MIXBIN:
		m_pen.CreatePen(PS_SOLID, 1, RGB(128, 64, 0));

		if(m_colorFlag == CModule::COLOR_SPEAKER)
			m_brush.CreateSolidBrush(RGB(255, 110, 90));
		else if(m_colorFlag == CModule::COLOR_XTALK)
			m_brush.CreateSolidBrush(RGB(255, 130, 90));
		else if(m_colorFlag == CModule::COLOR_I3DL2)
			m_brush.CreateSolidBrush(RGB(255, 150, 90));
		else 
			m_brush.CreateSolidBrush(RGB(255, 180, 90));
		break;

	case CModule::OUTPUT_MIXBIN:
		m_pen.CreatePen(PS_SOLID, 1, RGB(128, 90, 0));

		if(m_colorFlag == CModule::COLOR_SPEAKER)
			m_brush.CreateSolidBrush(RGB(255, 130, 120));
		else if(m_colorFlag == CModule::COLOR_XTALK)
			m_brush.CreateSolidBrush(RGB(255, 150, 120));
		else if(m_colorFlag == CModule::COLOR_I3DL2)
			m_brush.CreateSolidBrush(RGB(255, 170, 120));
		else 
			m_brush.CreateSolidBrush(RGB(255, 200, 120));
		break;

	case CModule::EFFECT:
		m_pen.CreatePen(PS_SOLID, 1, RGB(0, 64, 128));
		m_brush.CreateSolidBrush(RGB(120, 200, 255));
		break;
	}
}

//------------------------------------------------------------------------------
//	CModule::ConvertToIIR2
//------------------------------------------------------------------------------
void 
CModule::ConvertToIIR2(void)
/*++

Routine Description:

	Converts from frequency and Q to the 5 iir2 parameters

Arguments:

	None

Return Value:

	None

--*/
{
	double	x0;
	double	x1;
	double	x2;
	double	z0;
	double	z2;
    double	z0m1;
	double	gm1;
	double	q		= m_fIIR2Q;
	double	f		= m_fIIR2Frequency / 48000.0;
    double	g		= pow(10.0, m_fIIR2GainDB * (1.0 / 40.0));
    double	wc		= cTwoPi * f;
    double	alpha	= (sinh(1.0 / (q + q)) * sin(wc));

    x0		= 1.0 + (alpha * g);
    x1		= -2.0 * cos(wc);
    x2		= 1.0 - (alpha * g);
    gm1		= alpha / g;
    z0		= 1.0 + gm1;
    z2		= 1.0 - gm1;
    z0m1	= 0.5 / z0;

	m_parameters[2].SetValue(ToDWORD(x0 * z0m1));		// b0
	m_parameters[3].SetValue(ToDWORD(x1 * z0m1));		// b1
	m_parameters[4].SetValue(ToDWORD(x2 * z0m1));		// b2
	m_parameters[0].SetValue(ToDWORD(-(x1 * z0m1)));	// a1 = -b1
	m_parameters[1].SetValue(ToDWORD(-z2 * z0m1));		// a2
}

#if 0
ComputeIIR2Hz_Parametric(float *h, float frequency, float q, float gainDB)
// h			  ptr to five coefficients: b0,b1,b2,a1,a2
// frequency        fc/fs normalized frequency
// q                fc/dF range [0 .. N], where dF = bandwidth
// gainDB           gain (Decibels) range [-N .. N]
{
    float x[3], z[3];
    float G     = (float) pow(10.0, gainDB*(1.0/40.0));
    float wc    = kTwoPif*frequency;
    float cosWc = (float) cos(wc);
    float alpha = (float)(sinh(1.0/(q+q))*sin(wc));
    float z0m1, Gm1;

    x0 =  1.0f + alpha*G;
    x1 = -2.0f * cosWc;
    x2 =  1.0f - alpha*G;
    
    Gm1 = alpha/G;
    z0 =  1.0f + Gm1;
//z[1] =  -2.0 * cosWc; // a1 = b1
    z2 =  1.0f - Gm1;
    
    z0m1 = 0.5f / z0;	// was 1.0/a[0],  0.5 to scale into frac2.22 format

    B0 = (x0 * z0m1);
    B1 = (x1 * z0m1);
    B2 = (x2 * z0m1);
    
    A1 = (-B1     ); // a1 = b1
    A2 = (-z2 * z0m1);
#endif

#if 0
//------------------------------------------------------------------------------
//	CModule::ConvertFromIIR2
//------------------------------------------------------------------------------
void 
CModule::ConvertFromIIR2(
						 OUT double&	freq, 
						 OUT double&	q,
						 OUT double&	gain,
						 IN double		a1,
						 IN double		a2,
						 IN double		,
						 IN double		, 
						 IN double		
						 )
/*++

Routine Description:

	Converts to frequency and Q from the 5 iir2 parameters

Arguments:

	OUT freq -	Frequency 
	OUT q -		Q
	OUT gain -	Gain (DB)
	IN a1 -		A1
	IN a2 -		A2
	IN b0 -		B0	(Ignored)
	IN b1 -		B1	(Ignored)
	IN b2 -		B2	(Ignored)

Return Value:

	None

--*/
{
	double	wc;
	double	d;
	double	t;
	double	beta;
	double	gamma;

	gamma	= a1 / cScale24;
	beta	= -a2 / cScale24;
	
	t		= (1.0 - (2.0 * beta)) / ((2.0 * beta) + 1);
	wc		= acos(gamma / (0.5 + beta));
	d		= (2.0 * t) / sin(wc);

	// Result
	freq	= wc / cTwoPi * cFs;
	q		= wc / (2.0 * atan((d * sin(wc)) / 2.0));
}
#endif

#if 0

f = cTwoPi * frequency;
q = Q + Q;
g = gainDB * 0.025;

b0 = (1.0 + ((sinh(1.0 / q) * sin(f)) * pow(10.0, g)) ) * (0.5 / (1.0 + ((sinh(1.0 / q) * sin(f)) / pow(10.0, g))));

b1 = (-2.0 * cos(f)) * (0.5 / (1.0 + ((sinh(1.0 / q) * sin(f)) / pow(10.0, g))));

b2 = (1.0 - ((sinh(1.0 / q) * sin(f)) * pow(10.0, g))) * (0.5 / (1.0 + ((sinh(1.0 / q) * sin(f)) / pow(10.0, g))));

a1 = -b1;

a2 = -(1.0 - ((sinh(1.0 / q) * sin(f)) / pow(10.0, g))) * (0.5 / (1.0 + ((sinh(1.0 / q) * sin(f)) / pow(10.0, g))));






sinh(x) = (pow(e, x) - pow(e, -x)) / 2.0

log(pow(e, x)) = x







    double	g		= pow(10.0, gain * (1.0 / 40.0));
    double	wc		= cTwoPi * freq;
    double	cosWc	= cos(wc);
    double	alpha	= (sinh(1.0 / (q + q)) * sin(wc));

    x0 = (1.0 + (alpha * g));
    x1 = (-2.0 * cosWc);
    x2 = (1.0 - (alpha * g));
    
    gm1	= (alpha / g);
    y0	= (1.0 + gm1);
    y2	= (1.0 - gm1);
    
    y0m1	= (0.5 / y0);
    b0		= (1.0 + (alpha * g)) * (0.5 / (1.0 + (alpha / g)));
    b1		= x1 * y0m1;
    b2		= x2 * y0m1;
    a1		= -b1;
    a2		= -y2 * y0m1;
}
#endif

//------------------------------------------------------------------------------
//	CModule::ReorderIIR2Params
//------------------------------------------------------------------------------
void
CModule::ReorderIIR2Params(void)
/*++

Routine Description:

	Reorders the IIR2 params to be in the following order: a1 a2 b0 b1 b2 and
	generates frequency and Q from the values

Arguments:

	None

Return Value:

	None

--*/
{
	CParameter	param;
	CString		string;
	int			i;
	int			ii;
	TCHAR*		list[5] = {_T("iir2 a1"), _T("iir2 a2"), _T("iir2 b0"), _T("iir2 b1"), _T("iir2 b2")};

	for(i=0; i<4; ++i)
	{
		string = m_parameters[i].GetName();
		if(string.CompareNoCase(list[i]) != 0)
		{
			param = m_parameters[i];
			for(ii=i+1; ii<5; ++ii)
			{
				string = m_parameters[ii].GetName();
				if(string.CompareNoCase(list[i]) == 0)
				{
					m_parameters[i] = m_parameters[ii];
					m_parameters[ii] = param;
					break;
				}
			}
		}
	}

//	ConvertFromIIR2(m_fIIR2Frequency, m_fIIR2Q, m_fIIR2GainDB,
//					ToDouble(m_parameters[0].GetValue()), 
//					ToDouble(m_parameters[1].GetValue()), 
//					ToDouble(m_parameters[2].GetValue()),
//					ToDouble(m_parameters[3].GetValue()), 
//					ToDouble(m_parameters[4].GetValue()));
}

//------------------------------------------------------------------------------
//	CModule::ToDouble
//------------------------------------------------------------------------------
double 
CModule::ToDouble(
				  IN DWORD dwVal
				  )
/*++

Routine Description:

	Converts a 24bit DWORD float to a double

Arguments:

	IN val -	Value to convert

Return Value:

	None

--*/
{
	if(dwVal >= 0x800000)
		return -((0xFFFFFF - dwVal) / (double)0x800000);

	return ((double)dwVal / (double)0x800000);
}

//------------------------------------------------------------------------------
//	CModule::ToDWORD
//------------------------------------------------------------------------------
DWORD 
CModule::ToDWORD(
				 IN double fVal
				 )
/*++

Routine Description:

	Converts a double to a 24bit DWORD

Arguments:

	IN val -	Value to convert

Return Value:

	None

--*/
{
	if(fVal >= 1.0)
		return 0x7FFFFF;

	else if (fVal <= -1.0)
		return 0x800000;

	if(fVal > 0.0)
		return 0xffffff & (DWORD)((double)0x800000 * fVal);

	return (0xFFFFFF - (DWORD)(-fVal * (double)0x800000));
}

//------------------------------------------------------------------------------
//	CModule::SetI3DL2Parameters
//------------------------------------------------------------------------------
void
CModule::SetI3DL2Parameters(void)
/*++

Routine Description:

	Sets the i3dl2 parameters based on the active configuration

Arguments:

	None

Return Value:

	None

--*/
{
	if(!m_bI3DL2)
		return;

	if(m_activeConfig >= 0)
	{
		if(!m_configs[m_activeConfig].name.CompareNoCase(_T("default")))
			m_I3DL2Listener = cListenerDefault;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("generic")))
			m_I3DL2Listener = cListenerGeneric;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("padded cell")))
			m_I3DL2Listener = cListenerPaddedCell;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("room")))
			m_I3DL2Listener = cListenerRoom;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("bathroom")))
			m_I3DL2Listener = cListenerBathroom;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("living room")))
			m_I3DL2Listener = cListenerLivingRoom;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("stoneroom")))
			m_I3DL2Listener = cListenerStoneRoom;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("auditorium")))
			m_I3DL2Listener = cListenerAuditorium;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("concert hall")))
			m_I3DL2Listener = cListenerConcertHall;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("cave")))
			m_I3DL2Listener = cListenerCave;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("arena")))
			m_I3DL2Listener = cListenerArena;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("hangar")))
			m_I3DL2Listener = cListenerHangar;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("carpeted hallway")))
			m_I3DL2Listener = cListenerCarpetedHallway;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("hallway")))
			m_I3DL2Listener = cListenerHallway;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("stone corridor")))
			m_I3DL2Listener = cListenerStoneCorridor;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("alley")))
			m_I3DL2Listener = cListenerAlley;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("forest")))
			m_I3DL2Listener = cListenerForest;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("city")))
			m_I3DL2Listener = cListenerCity;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("mountains")))
			m_I3DL2Listener = cListenerMountains;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("quarry")))
			m_I3DL2Listener = cListenerQuarry;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("plain")))
			m_I3DL2Listener = cListenerPlain;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("parkinglot")))
			m_I3DL2Listener = cListenerParkingLot;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("sewer pipe")))
			m_I3DL2Listener = cListenerSewerPipe;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("underwater")))
			m_I3DL2Listener = cListenerUnderWater;
		else if(!m_configs[m_activeConfig].name.CompareNoCase(_T("no reverb")))
			m_I3DL2Listener = cListenerNoReverb;
		else
		{
			m_I3DL2Listener.lRoom				= I3DL2LISTENER_DEFAULTROOM;
			m_I3DL2Listener.lRoomHF				= I3DL2LISTENER_DEFAULTROOMHF;
			m_I3DL2Listener.flRoomRolloffFactor	= I3DL2LISTENER_DEFAULTROOMROLLOFFFACTOR;
			m_I3DL2Listener.flDecayTime			= I3DL2LISTENER_DEFAULTDECAYTIME;
			m_I3DL2Listener.flDecayHFRatio		= I3DL2LISTENER_DEFAULTDECAYHFRATIO;
			m_I3DL2Listener.lReflections		= I3DL2LISTENER_DEFAULTREFLECTIONS;
			m_I3DL2Listener.flReflectionsDelay	= I3DL2LISTENER_DEFAULTREFLECTIONSDELAY;
			m_I3DL2Listener.lReverb				= I3DL2LISTENER_DEFAULTREVERB;
			m_I3DL2Listener.flReverbDelay		= I3DL2LISTENER_DEFAULTREVERBDELAY;
			m_I3DL2Listener.flDiffusion			= I3DL2LISTENER_DEFAULTDIFFUSION;
			m_I3DL2Listener.flDensity			= I3DL2LISTENER_DEFAULTDENSITY;
			m_I3DL2Listener.flHFReference		= I3DL2LISTENER_DEFAULTHFREFERENCE;
		}
	}
	else
	{
		m_I3DL2Listener.lRoom				= I3DL2LISTENER_DEFAULTROOM;
		m_I3DL2Listener.lRoomHF				= I3DL2LISTENER_DEFAULTROOMHF;
		m_I3DL2Listener.flRoomRolloffFactor	= I3DL2LISTENER_DEFAULTROOMROLLOFFFACTOR;
		m_I3DL2Listener.flDecayTime			= I3DL2LISTENER_DEFAULTDECAYTIME;
		m_I3DL2Listener.flDecayHFRatio		= I3DL2LISTENER_DEFAULTDECAYHFRATIO;
		m_I3DL2Listener.lReflections		= I3DL2LISTENER_DEFAULTREFLECTIONS;
		m_I3DL2Listener.flReflectionsDelay	= I3DL2LISTENER_DEFAULTREFLECTIONSDELAY;
		m_I3DL2Listener.lReverb				= I3DL2LISTENER_DEFAULTREVERB;
		m_I3DL2Listener.flReverbDelay		= I3DL2LISTENER_DEFAULTREVERBDELAY;
		m_I3DL2Listener.flDiffusion			= I3DL2LISTENER_DEFAULTDIFFUSION;
		m_I3DL2Listener.flDensity			= I3DL2LISTENER_DEFAULTDENSITY;
		m_I3DL2Listener.flHFReference		= I3DL2LISTENER_DEFAULTHFREFERENCE;
	}
	m_I3DL2ListenerDefault = m_I3DL2Listener;
}

//------------------------------------------------------------------------------
//	CModule::Initialize
//------------------------------------------------------------------------------
void 
CModule::Initialize(void)
/*++

Routine Description:

	Initializes the basic state of the module. This is meant to be called from
	a constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_state					= CModule::OK;
	m_activeConfig			= -1;
	m_mixbin				= -1;
	m_bBadData				= FALSE;
	m_fIIR2Frequency		= 4500.0;
	m_fIIR2Q				= 1.0;
	m_fIIR2GainDB			= 0.0;
	m_fIIR2FrequencyDefault	= 4500.0;
	m_fIIR2QDefault			= 1.0;
	m_fIIR2GainDBDefault	= 0.0;
	m_bIIR2					= FALSE;
	m_bI3DL2				= FALSE;
	m_pGraph				= NULL;
	m_pParameterDialog		= NULL;
	m_bRealtime				= FALSE;
	m_bHighlight			= FALSE;

	// Setup the state font
	if(!m_stateFont)
	{
		m_stateFont = new CFont;
		m_stateFont->CreatePointFont(160, "Arial");
	}
	++m_stateFontRef;
}

//------------------------------------------------------------------------------
//	CModule::SetDisplayName
//------------------------------------------------------------------------------
void 
CModule::SetDisplayName(void)
/*++

Routine Description:

	Sets the name that is displayed

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_mixbin >= 0)
		m_displayName = m_name;
	else if(m_name != m_effectName)
		m_displayName = m_name;
	else
		m_displayName.Format(_T("%s (%X)"), (LPCTSTR)m_name, GetId()); 

	m_movingName = m_name;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Parameter.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Parameter.h

Abstract:

	Effect Parameter

Author:

	Robert Heitkamp (robheit) 29-Nov-2001

Revision History:

	29-Nov-2001 robheit
		Initial Version

--*/
#if !defined(AFX_PARAMETER_H__A010D544_B8C8_4FE9_B1AC_1B9A2C2CBB3C__INCLUDED_)
#define AFX_PARAMETER_H__A010D544_B8C8_4FE9_B1AC_1B9A2C2CBB3C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"

//------------------------------------------------------------------------------
//	CParameter 
//------------------------------------------------------------------------------
class CParameter  
{
public:

	CParameter(void);
//	CParameter(const CParameter& param);
//	CParameter(const FX_PARAM_DESCRIPTION& param);
	virtual ~CParameter(void);

	inline LPCTSTR GetName(void) const { return m_name; };
//	inline LPCTSTR GetDescription(void) const { return m_description; };
	inline LPCTSTR GetUnits(void) const { return m_units; };
	inline DWORD GetOffset(void) const { return m_dwOffset; };
	inline DWORD GetDefault(void) const { return m_dwDefault; };
	inline DWORD GetType(void) const { return m_dwType; };
	inline DWORD GetMin(void) const { return m_dwMin; };
	inline DWORD GetMax(void) const { return m_dwMax; };
	inline BOOL GetAtomic(void) const { return m_bAtomic; };
	inline DWORD GetValue(void) const { return m_dwValue; };
	
	inline void SetValue(DWORD value) { m_dwValue = value; };
	inline void SetName(LPCTSTR pName) { m_name = pName; };
//	inline void SetDescription(LPCTSTR pDesc) { m_description = pDesc; };
//	inline void SetUnits(LPCTSTR pUnits) { m_units = pUnits; };
	inline void SetOffset(DWORD dwOffset) { m_dwOffset = dwOffset; };
//	inline void SetDefault(DWORD dwDefault) { m_dwDefault = dwDefault; };
//	inline void SetType(DWORD dwType) { m_dwType = dwType; };
//	inline void SetMin(DWORD dwMin) { m_dwMin = dwMin; };
//	inline void SetMax(DWORD dwMax) { m_dwMax = dwMax; };
//	inline void SetAtmonic(BOOL bAtomic) { m_bAtomic = bAtomic; };

	CParameter& operator = (const CParameter& param);
	CParameter& operator = (const FX_PARAM_DESCRIPTION& param);

private:

	CString	m_name;
	CString	m_description;
	CString	m_units;
	DWORD	m_dwOffset;
	DWORD	m_dwDefault;
	DWORD	m_dwType;
	DWORD	m_dwMin;
	DWORD	m_dwMax;
	BOOL	m_bAtomic;
	DWORD	m_dwValue;
};

#endif // !defined(AFX_PARAMETER_H__A010D544_B8C8_4FE9_B1AC_1B9A2C2CBB3C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Module.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Module.h

Abstract:

	Effects module

Author:

	Robert Heitkamp (robheit) 03-May-2001

Revision History:

	03-May-2001 robheit
		Initial Version
	23-Nob-2001	robheit
		Changed to no longer use cells

--*/
#if !defined(AFX_MODULE_H__C19F8972_4C8D_4389_8E1C_D8A84B1C418A__INCLUDED_)
#define AFX_MODULE_H__C19F8972_4C8D_4389_8E1C_D8A84B1C418A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <afxtempl.h>
#include "Unique.h"
//#include "WinDspImageBuilder.h"
#include "Parameter.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CGraph;
class CPatchCord;
class CJack;
class CParameterDialog;
class CKnob;
class CWinDspImageBuilder;

//------------------------------------------------------------------------------
//	CModule
//------------------------------------------------------------------------------
class CModule : public CUnique
{
public:

	enum State
	{
		OK,
		INVALID,
		MOVING
	};

	enum Type 
	{
		INPUT_MIXBIN,
		OUTPUT_MIXBIN,
		EFFECT
	};

	enum ColorFlag
	{
		COLOR_SPEAKER,
		COLOR_XTALK,
		COLOR_I3DL2,
		COLOR_FXSEND,
		COLOR_EFFECT
	};

	struct Config 
	{
		CString	name;
		CString	stateFilename;

		Config& operator = (const Config& c) 
		{
			name			= c.name;
			stateFilename	= c.stateFilename;
			return *this;
		}
	};

	struct I3DL2Listener
	{
		LONG	lRoom;
		LONG	lRoomHF;
		FLOAT	flRoomRolloffFactor;
		FLOAT	flDecayTime;
		FLOAT	flDecayHFRatio;
		LONG	lReflections;
		FLOAT	flReflectionsDelay;
		LONG	lReverb;
		FLOAT	flReverbDelay;
		FLOAT	flDiffusion;
		FLOAT	flDensity;
		FLOAT	flHFReference;

		I3DL2Listener& operator = (const I3DL2Listener& l) 
		{
			lRoom				= l.lRoom;
			lRoomHF				= l.lRoomHF;
			flRoomRolloffFactor	= l.flRoomRolloffFactor;
			flDecayTime			= l.flDecayTime;
			flDecayHFRatio		= l.flDecayHFRatio;
			lReflections		= l.lReflections;
			flReflectionsDelay	= l.flReflectionsDelay;
			lReverb				= l.lReverb;
			flReverbDelay		= l.flReverbDelay;
			flDiffusion			= l.flDiffusion;
			flDensity			= l.flDensity;
			flHFReference		= l.flHFReference;
			return *this;
		}
	};

public:

	CModule(CGraph* pGraph, Type type, ColorFlag colorFlag, LPCTSTR pName,
			int dspCycles, int yMemSize, int scratchLength, LPCTSTR dspCode, 
			LPCTSTR stateFilename, const CStringArray* pInputs, 
			const CStringArray* pOutputs);
	CModule(const CModule& module);
	CModule(void);
	virtual ~CModule(void);

	void Draw(CDC*);
	void SetRect(const CRect& rect);
	BOOL AreInputsPatched(void) const;
	BOOL AreOutputsPatched(void) const;
	BOOL IsPatched(void) const;
	void Disconnect(void);
	void DisconnectInputs(void);
	void DisconnectOutputs(void);
	BOOL IsConnected(void) const;
	LPCTSTR GetStateFilename(void) const;
	void AddConfiguration(LPCTSTR, LPCTSTR);
	void Move(const CPoint& point);
	CJack* GetJack(const CPoint& point, BOOL bSmallJacks) const;
//	CJack* GetJack(const CPatchCord* pPatchCord) const;
	void SetState(State state);
	void Write(CFile& file); // throw(CFileException);
	void FixPointers(const CGraph* pGraph);
	virtual BOOL Read(CFile& file, BYTE version);
	BOOL SetParameters(CWinDspImageBuilder* imageBuilder, const char* pFilename);
	void ShowProperties(void);
	void SetEffectName(void);
	void ChangeParameter(const CKnob* pKnob, BOOL bTransmit);
	BOOL WriteStateFile(LPCTSTR pFilePath);
	void SetActiveConfig(int config);
	BOOL AreParametersModified(void) const;
	void ParameterDialogDestroyed(void);

	// Inlined methods
	inline const CRect& GetRect(void) const { return m_rect; };
//	inline void SetType(Type type) { m_type = type; };
	inline Type GetType(void) const { return m_type; };
	inline State GetState(void) const { return m_state; };
	inline const CArray<CJack*, CJack*&>& GetInputs(void) const { return m_inputs; };
	inline const CArray<CJack*, CJack*&>& GetOutputs(void) const { return m_outputs; };
	inline LPCTSTR GetName(void) const { return (LPCTSTR)m_name; };
	inline LPCTSTR GetEffectName(void) const { return (LPCTSTR)m_effectName; };
	inline LPCTSTR GetDSPCode(void) const { return (LPCTSTR)m_dspCode; };
	inline CArray<Config, Config&>& GetConfigs(void) { return m_configs; };
	inline int GetNumConfigs(void) const { return m_configs.GetSize(); };
	inline int GetActiveConfig(void) const { return m_activeConfig; };
	inline int GetDSPCycles(void) const { return m_dspCycles; };
	inline int GetYMemSize(void) const { return m_yMemSize; };
	inline int GetScratchLength(void) const { return m_scratchLength; };
	inline void SetMixbin(int mixbin) { m_mixbin = mixbin; };
	inline int GetMixbin(void) const { return m_mixbin; };
	inline CGraph* GetGraph(void) const { return m_pGraph; };
	inline const CArray<CParameter, CParameter&>& GetParameters(void) const { return m_parameters; };

	// Note: I3DL2 cannot display properties right now (although support is there)
	inline BOOL HasProperties(void) const { return (m_bIIR2 || (m_parameters.GetSize() != 0)); };
//	inline BOOL IsIIR2(void) const { return m_bIIR2; };
	inline BOOL IsI3DL2(void) const { return m_bI3DL2; };
	inline const I3DL2Listener& GetI3DL2Listener(void) const { return m_I3DL2Listener; };
	inline LPCTSTR GetIniName(void) const { return m_iniName; };
	inline void SetIniName(LPCTSTR pName) { m_iniName = pName; };
	inline void SetIndex(DWORD index) { m_index = index; };
	inline DWORD GetIndex(void) const { return m_index; };
	inline void SetRealtime(BOOL bFlag) { m_bRealtime = bFlag; };
	inline void Highlight(BOOL bFlag) { m_bHighlight = bFlag; };

private:

	void CreatePenAndBrush(void);
	void ConvertToIIR2(void);
//	void ConvertFromIIR2(double& freq, double& q, double& gain, double a1, double a2, double b0, double b1, double b2);
	void ReorderIIR2Params(void);
	double ToDouble(DWORD dwVal);
	DWORD ToDWORD(double fVal);
	void SetI3DL2Parameters(void);
	void Initialize(void);
	void SetDisplayName(void);

private:

	// Written to file
	Type							m_type;
	State							m_state;
	CRect							m_rect;
	CString							m_name;
	CRect							m_nameRect;
	CRect							m_configRect;
	CArray<CJack*, CJack*&>			m_inputs;
	CArray<CJack*, CJack*&>			m_outputs;
	CString							m_stats;
	CRect							m_statsRect;
	CString							m_dspCode;
	CString							m_stateFilename;
	int								m_dspCycles;
	int								m_yMemSize;
	int								m_scratchLength;
	CArray<Config, Config&>			m_configs;
	int								m_activeConfig;
	ColorFlag						m_colorFlag;
	int								m_mixbin;
	CArray<CParameter, CParameter&>	m_parameters;
	CString							m_iniName;
	DWORD							m_index;
	double							m_fIIR2Frequency;
	double							m_fIIR2Q;
	double							m_fIIR2GainDB;
	double							m_fIIR2FrequencyDefault;
	double							m_fIIR2QDefault;
	double							m_fIIR2GainDBDefault;
	CString							m_effectName;

	// Not written to file
	BOOL							m_bBadData;
	CPen							m_pen;
	CBrush							m_brush;
	CBrush							m_movingBrush;
	CGraph*							m_pGraph;
	static CFont*					m_stateFont;
	static int						m_stateFontRef;
	BOOL							m_bIIR2;
	BOOL							m_bI3DL2;
	I3DL2Listener					m_I3DL2Listener;
	I3DL2Listener					m_I3DL2ListenerDefault;
	CParameterDialog*				m_pParameterDialog;
	CString							m_displayName;
	CString							m_movingName;
	BOOL							m_bRealtime;
	BOOL							m_bHighlight;
};

#endif // !defined(AFX_MODULE_H__C19F8972_4C8D_4389_8E1C_D8A84B1C418A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\parser.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	parser.h

Abstract:

	Additional parser setup

Author:

	Robert Heitkamp (robheit) 04-Jun-2001

Revision History:

	04-Jun-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "..\xgpimage\parser.h"

//------------------------------------------------------------------------------
//	Keywords
//------------------------------------------------------------------------------
#define FX_CONFIG_NAME	"FX_CONFIG_NAME"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\ParameterDialog.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ParameterDialog.cpp

Abstract:

	Dialog to handle effect parameters

Author:

	Robert Heitkamp (robheit) 30-Nov-2001

Revision History:

	30-Nov-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <math.h>
#include "resource.h"
#include "ParameterDialog.h"
#include "Knob.h"
#include "Module.h"

//------------------------------------------------------------------------------
//	Message Map
//------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CParameterDialog,CDialog)
	//{{AFX_MSG_MAP(CParameterDialog)
	ON_COMMAND(IDRESET, OnReset)
	ON_COMMAND(IDAPPLY, OnApply)
	ON_COMMAND(IDDEFAULT, OnDefault)
	ON_BN_CLICKED(IDC_REALTIME, OnRealtime)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------------
//	CParameterDialog::CParameterDialog
//------------------------------------------------------------------------------
CParameterDialog::CParameterDialog(
								   IN CModule*	pModule,
								   IN LPCTSTR	pName,
								   IN int		width
								   ) : CDialog(IDD_PARAMETER_DIALOG)
/*++

Routine Description:

	Constructor

Arguments:

	IN pModule -	Module associated with this
	IN pName -		Name of dialog
	IN width -		Number of parameter knobs per row (max)

Return Value:

	None

--*/
{
	m_pModule			= pModule;
	m_name				= pName;
	m_width				= width;
	m_bRealtimeEnabled	= FALSE;
	m_bRealtime			= FALSE;
}

//------------------------------------------------------------------------------
//	CParameterDialog::~CParameterDialog
//------------------------------------------------------------------------------
CParameterDialog::~CParameterDialog(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;
	for(i=0; i<m_knobs.GetSize(); ++i)
		delete m_knobs[i];
}

//------------------------------------------------------------------------------
//	CParameterDialog::AddKnob
//------------------------------------------------------------------------------
void 
CParameterDialog::AddKnob(
						  IN CKnob*	pKnob
						  )
/*++

Routine Description:

	Adds a knob. The memory for this object is managed internally and will
	be destroyed with the dialog exits. This method cannot be called after
	the dialog has been displayed.

Arguments:

	IN pKnob -	Knob to add

Return Value:

	None

--*/
{
	m_knobs.Add(pKnob);
}

//------------------------------------------------------------------------------
//	CParameterDialog::UpdateKnobs
//------------------------------------------------------------------------------
void
CParameterDialog::UpdateKnobs(void)
/*++

Routine Description:

	Updates the dialog for the new knobs

Arguments:

	None

Return Value:

	None

--*/
{
	int		i;
	CWnd*	pWnd;
	CRect	rect;
	CRect	winRect;
	int		x;
	int		y;
	int		rows;
	int		smallWidth;
	int		height		= 0;
	int		width		= 0;

	GetClientRect(winRect);
	
	// Create all the knobs and calculate the width and height
	for(m_bRealtimeEnabled=TRUE, i=0; i<m_knobs.GetSize(); ++i)
	{
		m_knobs[i]->Create(NULL, WS_CHILD | WS_VISIBLE, CRect(0,0,1,1), this);
		m_knobs[i]->GetClientRect(rect);
		if(rect.Width() > width)
			width = rect.Width();
		if(rect.Height() > height)
			height = rect.Height();
		if(!m_knobs[i]->GetAtomic())
			m_bRealtimeEnabled = FALSE;
	}
	
	// Adjust for spacing
	width	+= 10;
	height	+= 20;

	rows = (m_knobs.GetSize() / m_width) + ((m_knobs.GetSize() % m_width) ? 1 : 0);

	// Place the knobs
	for(i=0, y=0; y<rows; ++y)
	{
		for(x=0; x<m_width && i<m_knobs.GetSize(); ++x, ++i)
		{
			m_knobs[i]->GetClientRect(rect);
			m_knobs[i]->MoveWindow(x*width+10 + (((width-10) - rect.Width()) / 2), y*height+10, 
								   rect.Width(), rect.Height());
		}
	}
	if(m_width <= m_knobs.GetSize())
		x = m_width;
	else
		x = m_knobs.GetSize();

	// Adjust the location of the ok/apply/cancel/reset buttons
	pWnd = (CWnd*)GetDlgItem(IDRESET);
	pWnd->GetClientRect(rect);
	smallWidth = rect.Width();
	pWnd->MoveWindow(x*width+20, 20, smallWidth, rect.Height());

	pWnd = (CWnd*)GetDlgItem(IDDEFAULT);
	pWnd->MoveWindow(x*width+20, rect.Height()+25, smallWidth, rect.Height());

	pWnd = (CWnd*)GetDlgItem(IDC_REALTIME);
	pWnd->MoveWindow(x*width+20, 2*rect.Height()+30, smallWidth, rect.Height());
	pWnd->EnableWindow(m_bRealtimeEnabled);
	m_bRealtime = m_bRealtime && m_bRealtimeEnabled;
	
	pWnd = (CWnd*)GetDlgItem(IDOK);
	pWnd->MoveWindow(x*width+smallWidth+35, 20, rect.Width(), rect.Height());

	pWnd = (CWnd*)GetDlgItem(IDAPPLY);
	pWnd->MoveWindow(x*width+smallWidth+35, rect.Height()+25, rect.Width(), rect.Height());

	pWnd = (CWnd*)GetDlgItem(IDCANCEL);
	pWnd->MoveWindow(x*width+smallWidth+35, 2*rect.Height()+30, rect.Width(), rect.Height());

	pWnd->GetClientRect(rect);
	pWnd = (CWnd*)GetDlgItem(IDC_GROUP);
	pWnd->MoveWindow(x*width+smallWidth+27, 5, rect.Width()+17, 3*rect.Height()+35);

	width = (x*width) + 20 + smallWidth + (rect.Width()) + 30;
	if((4*rect.Height()+35) > (rows*height+20))
		height = 4*rect.Height()+35;
	else
		height = rows*height+20;

	// Adjust the window dimensions of this
	GetWindowRect(&winRect);
	ScreenToClient(&winRect);
	GetClientRect(rect);
	width	+= winRect.Width() - rect.Width();
	height	+= winRect.Height() - rect.Height();
	SetWindowPos(NULL, 0, 0, width, height, SWP_NOMOVE | SWP_NOZORDER);
}

//------------------------------------------------------------------------------
//	CParameterDialog::SetRealtime
//------------------------------------------------------------------------------
void 
CParameterDialog::SetRealtime(
							  IN BOOL bFlag
							  ) 
/*++

Routine Description:

	Sets realtime control

Arguments:

	IN bFlag -	Realtime flag

Return Value:

	None

--*/
{ 
	int	i;

	m_bRealtime = bFlag && m_bRealtimeEnabled; 
	CheckDlgButton(IDC_REALTIME, m_bRealtime);
	for(i=0; i<m_knobs.GetSize(); ++i)
		m_knobs[i]->EnableRealtime(m_bRealtime);
}

//------------------------------------------------------------------------------
//	CParameterDialog::OnInitDialog
//------------------------------------------------------------------------------
BOOL
CParameterDialog::OnInitDialog(void)
/*++

Routine Description:

	Initializes the dialog

Arguments:

	None

Return Value:

	None

--*/
{
	if(CDialog::OnInitDialog())
	{
		SetWindowText(m_name);
		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CParameterDialog::OnOK
//------------------------------------------------------------------------------
void
CParameterDialog::OnOK(void)
/*++

Routine Description:

	Handles the Ok button

Arguments:

	None

Return Value:

	None

--*/
{
	OnApply();
	OnCancel();
}

//------------------------------------------------------------------------------
//	CParameterDialog::OnReset
//------------------------------------------------------------------------------
void
CParameterDialog::OnReset(void)
/*++

Routine Description:

	Resets the knobs to their original (last applied) settings

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;
	for(i=0; i<m_knobs.GetSize(); ++i)
		m_knobs[i]->Reset();
}

//------------------------------------------------------------------------------
//	CParameterDialog::OnApply
//------------------------------------------------------------------------------
void
CParameterDialog::OnApply(void)
/*++

Routine Description:

	Applys any changes made

Arguments:

	None

Return Value:

	None

--*/
{
	int		i;

	// Any changes?
	for(i=m_knobs.GetSize()-1; i>=0; --i)
	{
		m_pModule->ChangeParameter(m_knobs[i], FALSE);
		m_knobs[i]->SetLastPos(m_knobs[i]->GetPos());
	}
	m_pModule->ChangeParameter(NULL, TRUE);
}

//------------------------------------------------------------------------------
//	CParameterDialog::OnDefault
//------------------------------------------------------------------------------
void
CParameterDialog::OnDefault(void)
/*++

Routine Description:

	Resets the knobs to their default settings

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;
	for(i=0; i<m_knobs.GetSize(); ++i)
		m_knobs[i]->Default();
}

//------------------------------------------------------------------------------
//	CParameterDialog::OnCancel
//------------------------------------------------------------------------------
void
CParameterDialog::OnCancel(void)
/*++

Routine Description:

	Destroys the window when the cancel button is pressed

Arguments:

	None

Return Value:

	None

--*/
{
	DestroyWindow();
}

//------------------------------------------------------------------------------
//	CParameterDialog::PostNcDestroy
//------------------------------------------------------------------------------
void
CParameterDialog::PostNcDestroy(void)
/*++

Routine Description:

	Handles the destruction of the window

Arguments:

	None

Return Value:

	None

--*/
{
	CDialog::PostNcDestroy();
	m_pModule->ParameterDialogDestroyed();
	delete this;
}

//------------------------------------------------------------------------------
//	CParameterDialog::OnRealtime
//------------------------------------------------------------------------------
void 
CParameterDialog::OnRealtime(void) 
/*++

Routine Description:

	Toggles the realtime feature

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	m_bRealtime = !m_bRealtime;
	for(i=0; i<m_knobs.GetSize(); ++i)
		m_knobs[i]->EnableRealtime(m_bRealtime);
	m_pModule->SetRealtime(m_bRealtime);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\ParameterDialog.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	ParameterDialog.h

Abstract:

	Dialog to handle Effect parameters

Author:

	Robert Heitkamp (robheit) 30-Nov-2001

Revision History:

	30-Nov-2001 robheit
		Initial Version

--*/
#ifndef PARAMETER_DIALOG_H
#define PARAMETER_DIALOG_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <afxtempl.h>
#include "dspbuilder.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CKnob;
class CModule;

//------------------------------------------------------------------------------
//	CParameterDialog
//------------------------------------------------------------------------------
class CParameterDialog : public CDialog  
{
public:

	CParameterDialog(CModule* pModule=NULL, LPCTSTR pName=NULL, int width=5);
	virtual ~CParameterDialog(void);

	void AddKnob(CKnob* pKnob);	// Knobs will be freed with the dialog exits
//	inline void SetModule(CModule* pModule) { m_pModule = pModule; };
//	inline void SetName(LPCTSTR pName) { m_name = pName; };
	void UpdateKnobs(void);
	void SetRealtime(BOOL bFlag);

	inline BOOL GetRealtime(void) const { return m_bRealtime; };
		
protected:

	virtual BOOL OnInitDialog(void);
	virtual void OnOK(void);
	virtual void OnCancel(void);
	virtual void PostNcDestroy(void);

protected:
	//{{AFX_MSG(CParameterDialog)
	afx_msg void OnReset();
	afx_msg void OnApply();
	afx_msg void OnDefault();
	afx_msg void OnRealtime();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	
	CString					m_name;
	int						m_width;
	CArray<CKnob*, CKnob*&>	m_knobs;
	CModule*				m_pModule;
	BOOL					m_bRealtimeEnabled;
	BOOL					m_bRealtime;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dspbuilder.rc
//
#define IDAPPLY                         3
#define IDRESET                         4
#define IDDEFAULT                       5
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_DSPBUITYPE                  129
#define IDD_DSP_ERROR                   134
#define IDD_XBOX_CONNECT                135
#define IDD_EXPORT_DIALOG               136
#define IDD_DIRS_DIALOG                 137
#define IDD_DIRECTORY_DIALOG            138
#define IDB_DRIVEIMAGES                 140
#define IDB_KNOB                        153
#define IDB_KNOB_BUMP                   154
#define IDD_PARAMETER_DIALOG            155
#define IDD_EFFECT_NAME_DIALOG          156
#define IDC_DSP_ERROR_EDIT              1000
#define IDC_XBOX_NAME                   1002
#define IDC_EXPORT_OPTIONS_XTALK        1004
#define IDC_I3DL2_COMBO                 1005
#define IDC_I3DL2_REVERB                1006
#define IDC_PATCH_XTALK_TO_LFE          1009
#define IDC_INI_FILE_PATH_EDIT          1010
#define IDC_DSP_CODE_PATH_EDIT          1011
#define IDC_DSP_CODE_PATH_TEXT          1012
#define IDC_INI_FILE_PATH_TEXT          1013
#define IDC_DSP_CODE_PATH_BROWSE        1014
#define IDC_DIRECTORY_TREE              1015
#define ac                              1015
#define IDC_INI_FILE_PATH_BROWSE        1015
#define IDC_ABOUT_VERSION               1023
#define IDC_ABOUT_COPYRIGHT             1024
#define IDC_EFFECT_NAME_EDIT            1025
#define IDC_REALTIME                    1026
#define IDC_GROUP                       1027
#define ID_XBOX_CONNECT                 32771
#define ID_XBOX_EXPORT_IMAGE            32772
#define ID_XBOX_TEST                    32773
#define ID_TOOLS_OPTIONS                32774
#define ID_TOO                          32775
#define IDM_FILE_SAVE_AS_IMAGE          32776
#define ID_FILE_SAVE_AS_IMAGE           32777
#define ID_XBOX_TRANSMIT_IMAGE          32778
#define ID_FILE_GENERATE_AND_SAVE_IMAGE 32779
#define ID_FILE_GENERATE_AND_SAVE_IMAGE_AS 32780
#define IDC_TOOLS_DIRECTORIES           32781
#define IDC_TOOLS_BUILD_OPTIONS         32782
#define IDC_TOOLS_TRANSMIT_OPTIONS      32783
#define IDC_TOOLS_SNAP_TO_GRID          32785
#define ID_GRID_INSERT_EFFECT           57346
#define ID_GRID_DISCONNECT_ALL          57347
#define ID_GRID_DELETE_ALL              57348
#define ID_GRID_SHOW_GRID               57349
#define ID_PATCH_DISCONNECT             59142
#define ID_MIXBIN_DISCONNECT            59143
#define ID_GRID_WINDOW                  59144
#define ID_EFFECTS_PROPERTIES           61191
#define ID_EFFECTS_DELETE               61192
#define ID_EFFECTS_DISCONNECT_ALL       61193
#define ID_EFFECTS_DISCONNECT_INPUTS    61194
#define ID_EFFECTS_DISCONNECT_OUTPUTS   61195
#define ID_MIXBIN_MOVE_UP               61204
#define ID_MIXBIN_MOVE_DOWN             61205
#define ID_EFFECTS_CONFIGS              61206
#define IDS_STATUS_BAR_TEXT             61207
#define ID_EFFECTS_NAME                 61208
#define ID_PATCH_OVERWRITE              61209

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        157
#define _APS_NEXT_COMMAND_VALUE         32786
#define _APS_NEXT_CONTROL_VALUE         1028
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\PatchCord.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	PatchCord.cpp

Abstract:

	Patch Cord. This object connects modules

Author:

	Robert Heitkamp (robheit) 05-Oct-2001

Revision History:

	05-Oct-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "PatchCord.h"
#include "Graph.h"
#include "Module.h"
#include "Jack.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//------------------------------------------------------------------------------
//	CPatchCord::CPatchCord
//------------------------------------------------------------------------------
CPatchCord::CPatchCord(
					   IN CJack*	pJack
					   ) : CUnique()
/*++

Routine Description:

	Constructor

Arguments:

	IN pJack -	Jack

Return Value:

	None

--*/
{
	m_pPatchNode		= NULL;
	m_pJack				= pJack;
	m_bInvalid			= FALSE;
	m_lastPointOn		= CPatchCord::POINTON_NONE;
	m_bBadData			= FALSE;
	m_bMark				= FALSE;
	m_bHighlight		= FALSE;
	m_bOverwrite		= FALSE;
	m_bOverwriteEnable	= FALSE;
}

//------------------------------------------------------------------------------
//	CPatchCord::~CPatchCord
//------------------------------------------------------------------------------
CPatchCord::~CPatchCord(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode;

	if(!m_bBadData)
		ClearPatch();
	else
	{
		while(m_pPatchNode)
		{
			// Clear the node
			pNode = m_pPatchNode->pNext;
			delete m_pPatchNode;
			m_pPatchNode = pNode;
		}
	}
}

//------------------------------------------------------------------------------
//	CPatchCord::Draw
//------------------------------------------------------------------------------
void
CPatchCord::Draw(
				 IN CDC*	pDC
				 )
/*++

Routine Description:

	Draws the patch cord

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode;
	CPen*					oldPen = NULL;
	CPen					pen;

	// Setup
	if(m_bInvalid)
		pen.CreatePen(PS_SOLID, 1, RGB(255, 0, 0));
	else if(m_bHighlight)
		pen.CreatePen(PS_SOLID, 1, RGB(100, 200, 100));
	else if(m_bOverwrite)
		pen.CreatePen(PS_SOLID, 3, RGB(0, 0, 255));
	else
		pen.CreatePen(PS_SOLID, 1, RGB(0, 0, 0));

	oldPen = (CPen*)pDC->SelectObject(&pen);
	pDC->Polyline(m_points.GetData(), m_points.GetSize());

	// If either end is patched to a non-jack patchcord, draw a block
	for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
	{
		if(pNode->bEnd && (pNode->pPatchCord->GetJack() == NULL))
		{
			pDC->FillSolidRect(m_points[m_points.GetSize()-1].x-2, 
							   m_points[m_points.GetSize()-1].y-2, 5, 5, 
							   RGB(0, 0, 0));
			break;
		}
	}
	for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
	{
		if(!pNode->bEnd && (pNode->pPatchCord->GetJack() == NULL))
		{
			pDC->FillSolidRect(m_points[0].x-2, m_points[0].y-2, 5, 5, 
							   RGB(0, 0, 0));
			break;
		}
	}

	if(m_bInvalid)
		pDC->SelectObject(oldPen);
}

//------------------------------------------------------------------------------
//	CPatchCord::DrawXOR
//------------------------------------------------------------------------------
void
CPatchCord::DrawXOR(
					IN CDC*	pDC
					)
/*++

Routine Description:

	Draws the patch cord in XOR mode

Arguments:

	IN pDC -	Device context

Return Value:

	None

--*/
{
	CPen*		oldPen;
	int			oldROP;

	// Setup
	oldPen	= (CPen*)pDC->SelectStockObject(WHITE_PEN);
	oldROP	= pDC->SetROP2(R2_XORPEN);

	Draw(pDC);

	// Restore
	pDC->SetROP2(oldROP);
	pDC->SelectObject(oldPen);
}

//------------------------------------------------------------------------------
//	CPatchCord::Split
//------------------------------------------------------------------------------
CPatchCord*
CPatchCord::Split(
				  IN const CPoint&	point
				  )
/*++

Routine Description:

	Splits the patch cord in two and returns the end split.
	A patch cord that is part of a jack cannot be split.

Arguments:

	IN point -	Point to use as split point

Return Value:

	New patch cord or NULL if this patch cord is part of a module

--*/
{
	int						i;
	CPatchCord*				pNewCord;
	CArray<CPoint, CPoint&>	points;
	CPatchCord::PatchNode*	pNode;
	CPatchCord::PatchNode*	pNext;

	// If this patch cord belongs to a Jack, it cannot be split
	ASSERT(m_pJack == NULL);

	// Build the new cord
	pNewCord = new CPatchCord;
	pNewCord->SetInvalid(m_bInvalid);

	// Is the point the last point on the cord?
	if(point == m_points[m_points.GetSize()-1])
		pNewCord->GetPoints().Add((CPoint&)point);

	// Or somewhere else
	else
	{
		points.Copy(m_points);

		// Find the place to insert the point
		for(i=1; i<m_points.GetSize(); ++i)
		{
			// Horizontal segment?
			if(m_points[i-1].y == m_points[i].y)
			{
				// Is the split point on the segment?
				if(m_points[i].y == point.y)
				{
					// Duplicate point?
					if(point.x == m_points[i-1].x)
					{
						m_points.RemoveAt(i, m_points.GetSize()-i);
						points.RemoveAt(0, i-1);
						pNewCord->SetPoints(points);
						break;
					}

					// Between the two points?
					else if(((point.x > m_points[i-1].x) && (point.x < m_points[i].x)) ||
							((point.x < m_points[i-1].x) && (point.x > m_points[i].x)))
					{
						m_points.RemoveAt(i, m_points.GetSize()-i);
						m_points.Add((CPoint&)point);
						points.RemoveAt(0, i);
						points.InsertAt(0, (CPoint&)point);
						pNewCord->SetPoints(points);
						break;
					}
				}
			}

			// Vertical segment
			else
			{
				// Is the split point on the segment?
				if(m_points[i].x == point.x)
				{
					// Duplicate point?
					if(point.y == m_points[i-1].y)
					{
						m_points.RemoveAt(i, m_points.GetSize()-i);
						points.RemoveAt(0, i-1);
						pNewCord->SetPoints(points);
						break;
					}

					// Between the two points?
					else if(((point.y > m_points[i-1].y) && (point.y < m_points[i].y)) ||
							((point.y < m_points[i-1].y) && (point.y > m_points[i].y)))
					{
						m_points.RemoveAt(i, m_points.GetSize()-i);
						m_points.Add((CPoint&)point);
						points.RemoveAt(0, i);
						points.InsertAt(0, (CPoint&)point);
						pNewCord->SetPoints(points);
						break;
					}
				}
			}
		}
	}

	pNewCord->AddPatchCord(this, FALSE);

	// Remove all end patches and add them to the new cord
	for(pNode=m_pPatchNode, pNext=(pNode ? pNode->pNext : NULL); pNode; pNode=pNext)
	{
		pNext = pNode->pNext;
		if(pNode->bEnd)
		{
			pNode->pPatchCord->SwapPatchCord(this, pNewCord);
			pNewCord->AddPatchCord(pNode->pPatchCord, TRUE);

			if(pNode->pPrev)
				pNode->pPrev->pNext = pNext;
			else
				m_pPatchNode = pNext;

			if(pNode->pNext)
				pNode->pNext->pPrev = pNode->pPrev;

			delete pNode;
		}
	}

	// Add the new cord as the end patch
	AddPatchCord(pNewCord, TRUE);

	// Update overwrite info
#if 0
	pNewCord->SetOverwriteEnable();
	pNewCord->SetOverwrite(pNewCord->GetOverwriteEnable() && m_bOverwrite);
	SetOverwriteEnable();
	SetOverwrite(m_bOverwriteEnable && m_bOverwrite);
#else
//	pNewCord->SetOverwriteEnable(m_bOverwriteEnable);
//	pNewCord->SetOverwrite(m_bOverwrite);
#endif

	CalcRect();
	pNewCord->CalcRect();

	return pNewCord;
}

//------------------------------------------------------------------------------
//	CPatchCord::Join
//------------------------------------------------------------------------------
void
CPatchCord::Join(
				 IN OUT CPatchCord*&	pPatchCord
				 )
/*++

Routine Description:

	Joins another patchcord to this and deletes the other cord. The last point
	of this must be the same as the first point of pPatch. There can also not be

Arguments:

	IN OUT pPatch -	Other cord to join that is deleted upon return.

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode;
	int						numStart	= 0;
	int						numEnd		= 0;
	int						i;

	// Strict error checking
	ASSERT((m_pJack == NULL) && (pPatchCord->GetJack() == NULL));
	ASSERT(IsPatched(pPatchCord));

	// How are they connected? End - Beginning?
	if(m_points[m_points.GetSize()-1] == pPatchCord->GetPoints()[0])
	{
		// More strict error checking
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		{
			if(pNode->bEnd)
				++numEnd;
		}
		for(pNode=pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(!pNode->bEnd)
				++numStart;
		}
		ASSERT((numEnd == 1) && (numStart == 1));

		// Remove and add points
		m_points.RemoveAt(m_points.GetSize()-1);
		m_points.Append(pPatchCord->GetPoints());

		// Add the patches
		for(pNode=pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(pNode->bEnd)
			{
				AddPatchCord(pNode->pPatchCord, TRUE);
				pNode->pPatchCord->SwapPatchCord(pPatchCord, this);
			}
		}
	}

	// How are they connected? End - End?
	else if(m_points[m_points.GetSize()-1] == pPatchCord->GetPoints()[pPatchCord->GetPoints().GetSize()-1])
	{
		// More strict error checking
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		{
			if(pNode->bEnd)
				++numEnd;
		}
		for(pNode=pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(pNode->bEnd)
				++numStart;
		}
		ASSERT((numEnd == 1) && (numStart == 1));

		// Remove and add points
		m_points.RemoveAt(m_points.GetSize()-1);

		// Add the points in reverse order
		for(i=pPatchCord->GetPoints().GetSize()-1; i>=0; --i)
			m_points.Add(pPatchCord->GetPoints()[i]);

		// Add the patches
		for(pNode=pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(!pNode->bEnd)
			{
				AddPatchCord(pNode->pPatchCord, TRUE);
				pNode->pPatchCord->SwapPatchCord(pPatchCord, this);
			}
		}
	}

	// How are they connected? Beginning - End?
	else if(m_points[0] == pPatchCord->GetPoints()[pPatchCord->GetPoints().GetSize()-1])
	{
		// More strict error checking
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		{
			if(!pNode->bEnd)
				++numEnd;
		}
		for(pNode=pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(pNode->bEnd)
				++numStart;
		}
		ASSERT((numEnd == 1) && (numStart == 1));

		// Remove and add points
		m_points.RemoveAt(0);

		// Add the points in reverse order
		for(i=pPatchCord->GetPoints().GetSize()-1; i>=0; --i)
			m_points.InsertAt(0, pPatchCord->GetPoints()[i]);

		// Add the patches
		for(pNode=pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(!pNode->bEnd)
			{
				AddPatchCord(pNode->pPatchCord, FALSE);
				pNode->pPatchCord->SwapPatchCord(pPatchCord, this);
			}
		}
	}

	// How are they connected? Beginning - Beginning?
	else if(m_points[0] == pPatchCord->GetPoints()[0])
	{
		// More strict error checking
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		{
			if(!pNode->bEnd)
				++numEnd;
		}
		for(pNode=pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(!pNode->bEnd)
				++numStart;
		}
		ASSERT((numEnd == 1) && (numStart == 1));

		// Remove and add points
		m_points.RemoveAt(0);

		// Add the points
		for(i=0; i<pPatchCord->GetPoints().GetSize(); ++i)
			m_points.InsertAt(0, pPatchCord->GetPoints()[i]);

		// Add the patches
		for(pNode=pPatchCord->GetPatchNode(); pNode; pNode=pNode->pNext)
		{
			if(pNode->bEnd)
			{
				AddPatchCord(pNode->pPatchCord, FALSE);
				pNode->pPatchCord->SwapPatchCord(pPatchCord, this);
			}
		}
	}

	else
		ASSERT(0);

	// Remove duplicate points
	for(i=1; i<m_points.GetSize(); )
	{
		if(m_points[i] == m_points[i-1])
			m_points.RemoveAt(i);
		else
			++i;
	}

	// Remove redundent points
	if(m_points.GetSize() >= 3)
	{
		for(i=2; i<m_points.GetSize(); )
		{
			if(((m_points[i].x == m_points[i-1].x) && (m_points[i].x == m_points[i-2].x)) ||
			   ((m_points[i].y == m_points[i-1].y) && (m_points[i].y == m_points[i-2].y)))
			   m_points.RemoveAt(i-1);
			else
				++i;
		}
	}

	// Remove the references to each other
	RemovePatchCord(pPatchCord);
	pPatchCord->ClearPatch();

	// Update the overwrite enable flag
//	SetOverwriteEnable();

	// Update the overwrite flag
//	SetOverwrite(m_bOverwriteEnable && (m_bOverwrite || pPatchCord->GetOverwrite()));

	delete pPatchCord;
	pPatchCord = NULL;
	
	CalcRect();
}

//------------------------------------------------------------------------------
//	CPatchCord::Connect
//------------------------------------------------------------------------------
CPatchCord* 
CPatchCord::Connect(
					IN OUT CPatchCord*&	pPatchCord,
					IN const CPoint&	point,
					IN BOOL				bEnd
					)
/*++

Routine Description:

	Connects another patch cord to this, splitting this if necessary and 
	performing a join

Arguments:

	IN OUT pPatchCord -	Patch cord to join
	IN point -			Point to connect
	IN bEnd -			TRUE if the connection is at the end of pPatchCord
						FALSE if the connection is at the beginning of pPatchCord

Return Value:

	The new split patch cord if one is created

--*/
{
	CPatchCord*				pSplit;
	CPatchCord::PatchNode*	pNode;

	// Is the point at the beginning?
	if(point == m_points[0])
	{
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		{
			if(!pNode->bEnd)
			{
				pNode->pPatchCord->AddPatchCord(pPatchCord, point);
				pPatchCord->AddPatchCord(pNode->pPatchCord, bEnd);
			}
		}
		AddPatchCord(pPatchCord, FALSE);
		pPatchCord->AddPatchCord(this, bEnd);
		return NULL;
	}

	// Or at the end?
	else if(point == m_points[m_points.GetSize()-1])
	{
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		{
			if(pNode->bEnd)
			{
				pNode->pPatchCord->AddPatchCord(pPatchCord, point);
				pPatchCord->AddPatchCord(pNode->pPatchCord, bEnd);
			}
		}
		AddPatchCord(pPatchCord, TRUE);
		pPatchCord->AddPatchCord(this, bEnd);
		return NULL;
	}

	// Or in the middle?
	// Split this at the point
	pSplit = Split(point);

	// Add the new patch cord at the point
	AddPatchCord(pPatchCord, point);

	// Add the point to the new (split) patch cord
	pSplit->AddPatchCord(pPatchCord, point);

	// Add this to the splitting patch cord
	pPatchCord->AddPatchCord(this, bEnd);

	// Add the new (split) to the splitting patch cord
	pPatchCord->AddPatchCord(pSplit, bEnd);

	return pSplit;
}

//------------------------------------------------------------------------------
//	CPatchCord::SetPoints
//------------------------------------------------------------------------------
void
CPatchCord::SetPoints(
					  IN const CArray<CPoint, CPoint&>&	points
					  )
/*++

Routine Description:

	Sets the points for the patch cord line

Arguments:

	IN points -	Points

Return Value:

	None

--*/
{	
	int	i;

	m_points.RemoveAll();
	m_points.Copy(points);

	// Remove duplicate points
	for(i=1; i<m_points.GetSize(); )
	{
		if(m_points[i] == m_points[i-1])
			m_points.RemoveAt(i);
		else
			++i;
	}

	// Remove useless points
	if(m_points.GetSize() >= 3)
	{
		for(i=0; i<m_points.GetSize()-2; ++i)
		{
			// Horizontal or vertical 3 point segment?
			if(((m_points[i].y == m_points[i+1].y) &&
			    (m_points[i].y == m_points[i+2].y)) ||
			   ((m_points[i].x == m_points[i+1].x) &&
				(m_points[i].x == m_points[i+2].x)))
			{
				m_points.RemoveAt(i+1);
			}
			else
				++i;
		}
	}

	CalcRect();
}

//------------------------------------------------------------------------------
//	CPatchCord::AddPatchCord
//------------------------------------------------------------------------------
void
CPatchCord::AddPatchCord(
						 IN CPatchCord*		pPatchCord,
						 IN const CPoint&	point
						 )
/*++

Routine Description:

	Adds a patch cord to a patch node list. The patch cord can only be added
	to an endpoint

Arguments:

	IN pPatch -	Patch cord to add to list
	IN point -	Point where patch is being added

Return Value:

	None

--*/
{
	// Strict error checking
	ASSERT(m_points.GetSize() >= 2);
	ASSERT((point == m_points[0]) || (point == m_points[m_points.GetSize()-1]));

	AddPatchCord(pPatchCord, (point == m_points[0]) ? FALSE : TRUE);
}

//------------------------------------------------------------------------------
//	CPatchCord::AddPatchCord
//------------------------------------------------------------------------------
void
CPatchCord::AddPatchCord(
						 IN CPatchCord*	pPatchCord,
						 IN BOOL		bEnd
						 )
/*++

Routine Description:

	Adds a patch cord to a patch node list. The patch cord can only be added
	to an endpoint

Arguments:

	IN pPatch -	Patch cord to add to list
	IN bEnd -	TRUE to add to end, FALSE to add to beginning

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode	= new CPatchCord::PatchNode;
	pNode->pPatchCord				= pPatchCord;
	pNode->pNext					= m_pPatchNode;
	pNode->pPrev					= NULL;
	pNode->bEnd						= bEnd;
	if(m_pPatchNode)
		m_pPatchNode->pPrev = pNode;
	m_pPatchNode = pNode;
}

//------------------------------------------------------------------------------
//	CPatchCord::RemovePatchCord
//------------------------------------------------------------------------------
void 
CPatchCord::RemovePatchCord(
							IN CPatchCord*	pPatchCord
							)
/*++

Routine Description:

	Removes a patch cord from the patch node list

Arguments:

	IN pPatch -	Patch cord to remove

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode = m_pPatchNode;

	while(pNode && pNode->pPatchCord != pPatchCord)
		pNode = pNode->pNext;

	if(pNode)
	{
		if(pNode->pPrev)
			pNode->pPrev->pNext = pNode->pNext;
		else
			m_pPatchNode = pNode->pNext;

		if(pNode->pNext)
			pNode->pNext->pPrev = pNode->pPrev;

		delete pNode;
	}
}

//------------------------------------------------------------------------------
//	CPatchCord::SwapPatchCord
//------------------------------------------------------------------------------
void 
CPatchCord::SwapPatchCord(
						  IN CPatchCord*	pOld,
						  IN CPatchCord*	pNew
						  )
/*++

Routine Description:

	Swaps two patches

Arguments:

	IN pOld -	Patch to remove
	IN pNew -	Patch to add

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode = m_pPatchNode;

	while(pNode && pNode->pPatchCord != pOld)
		pNode = pNode->pNext;

	if(pNode)
		pNode->pPatchCord = pNew;
}

//------------------------------------------------------------------------------
//	CPatchCord::ClearPatch
//------------------------------------------------------------------------------
void 
CPatchCord::ClearPatch(void)
/*++

Routine Description:

	Removes all connections

Arguments:

	None

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode = m_pPatchNode;

	while(pNode)
	{
		// Disconnect
		pNode->pPatchCord->RemovePatchCord(this);

		// Clear the node
		m_pPatchNode = pNode->pNext;
		delete pNode;
		pNode = m_pPatchNode;
	}
}

//------------------------------------------------------------------------------
//	CPatchCord::Write
//------------------------------------------------------------------------------
void 
CPatchCord::Write(
				  IN CFile&	file
				  )
/*++

Routine Description:

	Writes the patch cord to a save file

Arguments:

	IN file -	File to write to

Return Value:

	None

--*/
{
	WORD					word;
	int						i;
	CPatchCord::PatchNode*	pNode;
	DWORD					id;

	try
	{
		// Write the unique id
		CUnique::Write(file);

		// Write the invalid state
		file.Write(&m_bInvalid, sizeof(m_bInvalid));

		// Write the rect
		CalcRect();
		file.Write((LPRECT)m_rect, sizeof(RECT));

		// Write the jack (id)
		id = m_pJack ? m_pJack->GetId() : 0;
		file.Write(&id, sizeof(id));

		// Overwrite enable
		file.Write(&m_bOverwriteEnable, sizeof(m_bOverwriteEnable));

		// Overwrite
		file.Write(&m_bOverwrite, sizeof(m_bOverwrite));

		// Write the points
		word = (WORD)m_points.GetSize();
		file.Write(&word, sizeof(word));
		for(i=0; i<m_points.GetSize(); ++i)
		{
			file.Write(&m_points[i].x, sizeof(m_points[i].x));
			file.Write(&m_points[i].y, sizeof(m_points[i].y));
		}

		// Count the patches
		for(word=0, pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
			++word;

		// Write the patches
		file.Write(&word, sizeof(word));
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		{	
			file.Write(&pNode->bEnd, sizeof(pNode->bEnd));
			id = pNode->pPatchCord->GetId();
			file.Write(&id, sizeof(id));
		}
	}
	catch(...)
	{
		throw;	}
}

//------------------------------------------------------------------------------
//	CPatchCord::IsPatched
//------------------------------------------------------------------------------
BOOL 
CPatchCord::IsPatched(
					  IN const CPatchCord*	pPatchCord
					  ) const
/*++

Routine Description:

	Returns TRUE if this is patched to pPatch

Arguments:

	IN pPatch -		Patch cord to check connectivity
					if NULL, will return TRUE if patched to anything

Return Value:

	TRUE if this is patched to pPatch, FALSE if not connected

--*/
{
	CPatchCord::PatchNode*	pNode;

	if(pPatchCord == NULL)
		return (m_pPatchNode != NULL);

	// Check this connected to pPatch
	for(pNode=m_pPatchNode; pNode && pNode->pPatchCord != pPatchCord; pNode = pNode->pNext);

	// Check pPatch connected to this
	if(pNode)
	{
		for(pNode=pPatchCord->GetPatchNode(); pNode && pNode->pPatchCord != this; pNode = pNode->pNext);
		ASSERT(pNode != NULL);
		return TRUE;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CPatchCord::IsPatchedAtEnds
//------------------------------------------------------------------------------
BOOL 
CPatchCord::IsPatchedAtEnds(void) const
/*++

Routine Description:

	Returns TRUE if this is patched at both ends to anything

Arguments:

	None

Return Value:

	TRUE if this is patched at both ends, FALSE if not connected

--*/
{
	BOOL					start	= FALSE;
	BOOL					end		= FALSE;
	CPatchCord::PatchNode*	pNode;

	for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
	{
		if(pNode->bEnd)
			end = TRUE;
		else
			start = TRUE;
	}

	return (start && end);
}

//------------------------------------------------------------------------------
//	CPatchCord::IsPatchedToModule
//------------------------------------------------------------------------------
BOOL 
CPatchCord::IsPatchedToModule(
							  IN const CModule*	pModule
							  ) const
/*++

Routine Description:

	Determines if this is directly connected to the module pModule

Arguments:

	IN pModule -	Module to check

Return Value:

	TRUE if connected, FALSE otherwise

--*/
{
	CPatchCord::PatchNode*	pNode;

	// Check this connected to pPatch
	for(pNode=m_pPatchNode; pNode; pNode = pNode->pNext)
	{
		if(pNode->pPatchCord->GetJack() &&
		   (pNode->pPatchCord->GetJack()->GetModule() == pModule))
		{
			return TRUE;
		}
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CPatchCord::IsPatchedToEffect
//------------------------------------------------------------------------------
BOOL 
CPatchCord::IsPatchedToEffect(
							  IN const CModule* pEffect
							  ) const
/*++

Routine Description:

	Returns TRUE if the patch cord is patched to a particular effect.
	If pEffect is NULL, this returns TRUE is the patch cord is patched to any
	effect (not a mixbin)

Arguments:

	IN pEffect -	Effect to check (can be NULL)

Return Value:

	TRUE if patched, FALSE otherwise

--*/
{
	CPatchCord::PatchNode*	pNode;

	if(pEffect)
		return IsPatchedToModule(pEffect);

	// Check this connected to pPatch
	for(pNode=m_pPatchNode; pNode; pNode = pNode->pNext)
	{
		if(pNode->pPatchCord->GetJack() &&
		   pNode->pPatchCord->GetJack()->GetModule() &&
		   pNode->pPatchCord->GetJack()->GetModule()->GetMixbin() < 0)
		{
			return TRUE;
		}
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CPatchCord::IntersectRect
//------------------------------------------------------------------------------
BOOL 
CPatchCord::IntersectRect(
						  IN const CRect& rect
						  ) const
/*++

Routine Description:

	Returns TRUE if this intersects a rect by checking each line segment.

Arguments:

	IN rect -	Rect to check for intersection with

Return Value:

	TRUE if this intersects the rect, FALSE otherwise

--*/
{
	int	i;
	int	xy0;
	int	xy1;

	// Quick error check
	if(m_points.GetSize() < 2)
		return FALSE;

	for(i=1; i<m_points.GetSize(); ++i)
	{
		// Is the segment horizontal?
		if(m_points[i].y == m_points[i-1].y)
		{
			if(m_points[i].x < m_points[i-1].x)
			{
				xy0 = m_points[i].x;
				xy1 = m_points[i-1].x;
			}
			else
			{
				xy0 = m_points[i-1].x;
				xy1 = m_points[i].x;
			}

			if((m_points[i].y >= rect.top) && (m_points[i].y <= rect.bottom) &&
			   (xy0 <= rect.right) && (xy1 >= rect.left))
			   return TRUE;
		}

		// Otherwise, vertical
		else
		{
			if(m_points[i].y < m_points[i-1].y)
			{
				xy0 = m_points[i].y;
				xy1 = m_points[i-1].y;
			}
			else
			{
				xy0 = m_points[i-1].y;
				xy1 = m_points[i].y;
			}

			if((m_points[i].x >= rect.left) && (m_points[i].x <= rect.right) &&
			   (xy0 <= rect.bottom) && (xy1 >= rect.top))
			   return TRUE;
		}
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//	CPatchCord::IsPointOnLine
//------------------------------------------------------------------------------
BOOL 
CPatchCord::IsPointOnLine(
						  IN const CPoint&	point,
						  IN int			epsilon
						  )
/*++

Routine Description:

	Returns TRUE if the point is on the segment within a given epsilon.

Arguments:

	IN point -		Point to check
	IN epsilon -	Number of pixels within the line

Return Value:

	TRUE if the point is on the line segment, FALSE otherwise

--*/
{
	CRect	rect;
	int		i;

	// Check for the point on a point
	for(i=0; i<m_points.GetSize(); ++i)
	{
		if((abs(point.x - m_points[i].x) <= epsilon) &&
		   (abs(point.y - m_points[i].y) <= epsilon))
		{
			m_lastPointOn	= CPatchCord::POINTON_POINT;
			m_lastPoint		= m_points[i];
			return TRUE;
		}
	}

	// Then check the line segments
	for(i=1; i<m_points.GetSize(); ++i)
	{
		rect.left	= MIN(m_points[i].x, m_points[i-1].x) - epsilon;
		rect.right	= MAX(m_points[i].x, m_points[i-1].x) + epsilon;
		rect.top	= MIN(m_points[i].y, m_points[i-1].y) - epsilon;
		rect.bottom	= MAX(m_points[i].y, m_points[i-1].y) + epsilon;
		if(::IsPointInRect(point.x, point.y, rect))
		{
			if(m_points[i].x == m_points[i-1].x)
			{
				m_lastPointOn	= CPatchCord::POINTON_VERTICAL;
				m_lastPoint.x	= m_points[i].x;
				m_lastPoint.y	= point.y;
			}
			else
			{
				m_lastPointOn = CPatchCord::POINTON_HORIZONTAL;
				m_lastPoint.x	= point.x;
				m_lastPoint.y	= m_points[i].y;
			}
			return TRUE;
		}
	}

	m_lastPointOn = CPatchCord::POINTON_NONE;
	return FALSE;
}

//------------------------------------------------------------------------------
//	CPatchCord::FixPointers
//------------------------------------------------------------------------------
void
CPatchCord::FixPointers(
						IN const CGraph*	pGraph
						)
/*++

Routine Description:

	Fixes the pointers loaded from a file read

Arguments:

	IN pGraph -	Graph to correct pointers with

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode;

	if(m_pJack)
		m_pJack = pGraph->GetJackFromId((DWORD)m_pJack);

	for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		pNode->pPatchCord = pGraph->GetPatchCordFromId((DWORD)pNode->pPatchCord);

	m_bBadData = FALSE;
}

//------------------------------------------------------------------------------
//	CPatchCord::Read
//------------------------------------------------------------------------------
BOOL
CPatchCord::Read(
 			     IN CFile&	file,
				 IN BYTE	version
			     )
/*++

Routine Description:

	Constructor. Reads from a file

Arguments:

	IN file -		File to read from
	IN version -	File version

Return Value:

	None

--*/
{
	BOOL					ret = TRUE;
	WORD					word;
	CPoint					point;
	CPatchCord::PatchNode*	pNode;
	int						i;

	m_bBadData = TRUE;

	// Read the unique id
	if(!CUnique::Read(file, version))
		return FALSE;

	// Read the invalid state
	if(file.Read(&m_bInvalid, sizeof(m_bInvalid)) != sizeof(m_bInvalid))
		return FALSE;

	// Read the rect
	if(file.Read((LPRECT)m_rect, sizeof(RECT)) != sizeof(RECT))
		return FALSE;

	// Read the jack (id)
	if(file.Read(&m_pJack, sizeof(DWORD)) != sizeof(DWORD))
		return FALSE;

	if(version >= 4)
	{
		// Overwrite enable
		if(file.Read(&m_bOverwriteEnable, sizeof(m_bOverwriteEnable)) != sizeof(m_bOverwriteEnable))
			return FALSE;

		// Overwrite
		if(file.Read(&m_bOverwrite, sizeof(m_bOverwrite)) != sizeof(m_bOverwrite))
			return FALSE;
	}

	// Read the points
	if(file.Read(&word, sizeof(word)) != sizeof(word))
		return FALSE;
	for(i=0; ret && i<word; ++i)
	{
		ret = (file.Read(&point.x, sizeof(point.x)) == sizeof(point.x));
		if(ret)
		{
			ret = (file.Read(&point.y, sizeof(point.y)) == sizeof(point.y));
			if(ret)
				m_points.Add(point);
		}
	}

	// Sanity check
	CalcRect();

	// Read the patches
	if(ret)
		ret = (file.Read(&word, sizeof(word)) == sizeof(word));
	for(i=0; ret && i<word; ++i)
	{
		pNode = new CPatchCord::PatchNode;
		ret = (file.Read(&pNode->bEnd, sizeof(pNode->bEnd)) == sizeof(pNode->bEnd));
		if(ret)
		{
			ret = (file.Read(&pNode->pPatchCord, sizeof(DWORD)) == sizeof(DWORD));
			if(ret)
			{
				pNode->pNext	= m_pPatchNode;
				pNode->pPrev	= NULL;
				if(m_pPatchNode)
					m_pPatchNode->pPrev = pNode;
				m_pPatchNode = pNode;
			}
		}
	}

	if(ret)
		return TRUE;

	// Error cleanup
	m_points.RemoveAll();
	while(m_pPatchNode)
	{
		pNode = m_pPatchNode->pNext;
		delete m_pPatchNode;
		m_pPatchNode = pNode;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CPatchCord::GetConnections
//------------------------------------------------------------------------------
void 
CPatchCord::GetConnections(
						   IN OUT CArray<CJack*, CJack*>& list
						   )
/*++

Routine Description:

	Builds a list of all jacks connected to this. The list is not cleared
	before adding.

Arguments:

	IN OUT list -	List of jacks connected to this

Return Value:

	None

--*/
{
	int						i;
	CPatchCord::PatchNode*	pNode;

	// If this patch cord is marked, just return
	if(m_bMark)
		return;
	
	// Otherwise, if this is a jack, add to the list if not already there
	if(m_pJack)
	{
		for(i=0; i<list.GetSize(); ++i)
		{
			if(list[i] == m_pJack)
				return;
		}
		list.Add(m_pJack);
	}

	// Otherwise, traverse all other connected patch cords
	else
	{
		// Mark this (never mark a jack's patch cord)
		m_bMark = TRUE;

		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
			pNode->pPatchCord->GetConnections(list);
	}
}

//------------------------------------------------------------------------------
//	CPatchCord::GetPatchCords
//------------------------------------------------------------------------------
void 
CPatchCord::GetPatchCords(
						  IN OUT CArray<CPatchCord*, CPatchCord*>& list
						  )
/*++

Routine Description:

	Builds a list of all patch cords connected to this, including those 
	indirectly connected and jacks.
	The list is not cleared before adding.

Arguments:

	IN OUT list -	List of patch cords connected to this

Return Value:

	None

--*/
{
	int						i;
	CPatchCord::PatchNode*	pNode;

	// If this patch cord is marked, just return
	if(m_bMark)
		return;

	// Add to the list if not already there
	for(i=0; i<list.GetSize(); ++i)
	{
		if(list[i] == this)
			return;
	}
	list.Add(this);

	// Mark this (never mark a jack's patch cord)
	m_bMark = TRUE;

	// Traverse all other connected patch cords
	for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		pNode->pPatchCord->GetPatchCords(list);
}

//------------------------------------------------------------------------------
//	CPatchCord::Invalidate
//------------------------------------------------------------------------------
void
CPatchCord::Invalidate(void)
/*++

Routine Description:

	Recursive method to invalidate all patch cords connected to this. This
	will not invalidate patch cords belonging to jacks.

Arguments:

	None

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode;

	if(m_bInvalid || m_bMark || m_pJack)
		return;

	else
	{
		m_bMark		= TRUE;
		m_bInvalid	= TRUE;

		// Invalidate all connections
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
			pNode->pPatchCord->Invalidate();
	
	}
}

//------------------------------------------------------------------------------
//	CPatchCord::SetOverwriteEnabled
//------------------------------------------------------------------------------
void 
CPatchCord::SetOverwriteEnable(void)
/*++

Routine Description:

	Determines if overwrite enable should be set. For it to be set, the patch
	cord must be connected to an output mixbin or another patch cord connected
	to an output mixbin

Arguments:

	None

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*	pNode;

	m_bOverwriteEnable = FALSE;
	for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
	{
		if(pNode->pPatchCord &&
		   (pNode->pPatchCord->GetOverwriteEnable() ||
		    (pNode->pPatchCord->GetJack() &&
 			 pNode->pPatchCord->GetJack()->GetInput() &&
			 pNode->pPatchCord->GetJack()->GetModule() &&
			 pNode->pPatchCord->GetJack()->GetModule()->GetMixbin() >= 0)))
		{
			m_bOverwriteEnable = TRUE;
			break;
		}
	}
}

//------------------------------------------------------------------------------
//	CPatchCord::SetOverwrite
//------------------------------------------------------------------------------
RECT
CPatchCord::SetOverwrite(
						 IN BOOL bFlag
						 )
/*++

Routine Description:

	Enables or disables overwritting

Arguments:

	IN bFlag -	TRUE to enable overwrite, FALSE to disable

Return Value:

	None

--*/
{
	CPatchCord::PatchNode*				pNode;
	CArray<CPatchCord*, CPatchCord*>	patchCordList;
	int									i;
	CRect								rect(0,0,0,0);
	CPatchCord*							pMixbin	= NULL;

	if(bFlag == m_bOverwrite)
		return rect;

	// Get the list of all connections
	GetPatchCords(patchCordList);
	for(i=patchCordList.GetSize()-1; i>=0; --i)
		patchCordList[i]->Mark(FALSE);

	// The list cannot include an input mixbin or any effect inputs,
	// and must contain at least one output mixbin
	for(i=patchCordList.GetSize()-1; i>=0; --i)
	{
		if(patchCordList[i]->GetJack())
		{
			if(patchCordList[i]->GetJack()->GetModule())
			{
				// Is this a mixbin
				if(patchCordList[i]->GetJack()->GetModule()->GetMixbin() >= 0)
				{
					// Output mixbin?
					if(patchCordList[i]->GetJack()->GetInput())
					{
						// There cannot be more than one output
						if(pMixbin)
							return rect;
						pMixbin = patchCordList[i];
					}

					// Or input
					else
						return rect;
				}

				// Cannot be an effect input
				else if(patchCordList[i]->GetJack()->GetInput())
				   return rect;
			}
		}
	}

	// No output?
	if(!pMixbin)
		return rect;

	// Is this patch cord connected to an effect?
	if(IsPatchedToEffect(NULL))
	{
		// Find the effect
		for(pNode=m_pPatchNode; pNode; pNode=pNode->pNext)
		{
			if(pNode->pPatchCord && pNode->pPatchCord->GetJack() &&
			   pNode->pPatchCord->GetJack()->GetModule() &&
			   pNode->pPatchCord->GetJack()->GetModule()->GetMixbin() < 0)
			{
				// Clear the list
				patchCordList.RemoveAll();				
				CGraph::ShortestPath(pNode->pPatchCord->GetJack(), 
									 pMixbin->GetJack(), patchCordList);
				break;
			}
		}

	}

	// Set the flags for all the patch cords and unmark them
	for(i=patchCordList.GetSize()-1; i>=0; --i)
	{
		if(patchCordList[i]->GetJack())
		{
			patchCordList[i]->GetJack()->SetOverwrite(bFlag);
			rect.UnionRect(rect, 
						   patchCordList[i]->GetJack()->GetModule()->GetRect());
		}
		else
		{
			patchCordList[i]->m_bOverwrite = bFlag;
			rect.UnionRect(rect, patchCordList[i]->GetRect());
		}
	}

	return rect;
}

//------------------------------------------------------------------------------
//	CPatchCord::CalcRect
//------------------------------------------------------------------------------
void 
CPatchCord::CalcRect(void)
/*++

Routine Description:

	Calculates the rect for the patch cord

Arguments:

	None

Return Value:

	None

--*/
{
	int	i;

	if(m_points.GetSize())
	{
		m_rect.left		= m_points[0].x;
		m_rect.right	= m_points[0].x;
		m_rect.top		= m_points[0].y;
		m_rect.bottom	= m_points[0].y;
		for(i=1; i<m_points.GetSize(); ++i)
		{
			if(m_points[i].x < m_rect.left)
				m_rect.left = m_points[i].x;
			if(m_points[i].x > m_rect.right)
				m_rect.right = m_points[i].x;
			if(m_points[i].y < m_rect.top)
				m_rect.top = m_points[i].y;
			if(m_points[i].y > m_rect.bottom)
				m_rect.bottom = m_points[i].y;
		}

		// Adjust
		++m_rect.right;
		++m_rect.bottom;
	}
	else
	{
		m_rect.left		= 0;
		m_rect.right	= 0;
		m_rect.top		= 0;
		m_rect.bottom	= 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Unique.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Unique.cpp

Abstract:

	Base class for all unique objects

Author:

	Robert Heitkamp (robheit) 27-Nov-2001

Revision History:

	27-Nov-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Unique.h"

//------------------------------------------------------------------------------
//	Static Member Variables
//------------------------------------------------------------------------------
DWORD CUnique::m_globalId = 0;

//------------------------------------------------------------------------------
//	CUnique::CUnique
//------------------------------------------------------------------------------
CUnique::CUnique(void)
/*++

Routine Description:

	Constructor. Generates a unique id.

Arguments:

	None

Return Value:

	None

--*/
{
	m_id = ++m_globalId;
}

//------------------------------------------------------------------------------
//	CUnique::~CUnique
//------------------------------------------------------------------------------
CUnique::~CUnique(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CUnique::Write
//------------------------------------------------------------------------------
void 
CUnique::Write(
			   IN CFile& file
			   )
/*++

Routine Description:

	Writes the ID to a file

Arguments:

	IN file -	File to write to

Return Value:

	None

--*/
{
	try
	{
		file.Write(&m_id, sizeof(m_id));
	}
	catch(...)
	{
		throw;
	}
}

//------------------------------------------------------------------------------
//	CUnique::Read
//------------------------------------------------------------------------------
BOOL
CUnique::Read(
			  IN CFile& file,
			  IN BYTE//	version
			  )
/*++

Routine Description:

	Reads the ID from a file

Arguments:

	IN file -		File to read from
	IN version -	File version

Return Value:

	TRUE on success, FALSE on failure

--*/
{	
	BOOL	ret = (file.Read(&m_id, sizeof(m_id)) == sizeof(m_id));

	if(ret)
	{
		if(m_id > m_globalId)
			m_globalId = m_id;
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\PatchCord.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	PatchCord.h

Abstract:

	Patch Cord class. This object connects modules

Author:

	Robert Heitkamp (robheit) 05-Oct-2001


Revision History:

	05-Oct-2001 robheit
		Initial Version

--*/
#if !defined(AFX_PATCHCORD_H__94E63C94_9F86_4138_B073_A64F83BA8AE5__INCLUDED_)
#define AFX_PATCHCORD_H__94E63C94_9F86_4138_B073_A64F83BA8AE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <afxtempl.h>
#include "Unique.h"

//------------------------------------------------------------------------------
//	Forward Declarations:
//------------------------------------------------------------------------------
class CModule;
class CGraph;
class CJack;

//------------------------------------------------------------------------------
//	CPatchCord
//------------------------------------------------------------------------------
class CPatchCord : public CUnique
{
public:

	struct PatchNode
	{
		CPatchCord*	pPatchCord;
		BOOL		bEnd;
		PatchNode*	pNext;
		PatchNode*	pPrev;
	};

	enum PointOn
	{
		POINTON_NONE,
		POINTON_HORIZONTAL,
		POINTON_VERTICAL,
		POINTON_POINT
	};

public:

	CPatchCord(CJack* pJack=NULL);
	virtual ~CPatchCord(void);

	void Draw(CDC* pDC);
	void DrawXOR(CDC* pDC);
	CPatchCord* Split(const CPoint& point);
	void Join(CPatchCord*& pPatchCord);
	CPatchCord* Connect(CPatchCord*& pPatchCord, const CPoint& point, BOOL bEnd);
	void SetPoints(const CArray<CPoint, CPoint&>& points);
	void AddPatchCord(CPatchCord* pPatchCord, const CPoint& point);
	void AddPatchCord(CPatchCord* pPatchCord, BOOL bEnd);
	void RemovePatchCord(CPatchCord* pPatchCord);
	void SwapPatchCord(CPatchCord* pOld, CPatchCord* pNew);
	BOOL IsPatched(const CPatchCord* pPatchCord= NULL) const;
	BOOL IsPatchedAtEnds(void) const;
	BOOL IsPatchedToModule(const CModule*) const;
	BOOL IsPatchedToEffect(const CModule*) const;
	BOOL IntersectRect(const CRect& rect) const;
	BOOL IsPointOnLine(const CPoint& point, int epsilon=0);
	void ClearPatch(void);
	void Write(CFile& file); // throw(CFileException);
	void FixPointers(const CGraph* pGraph);
	virtual BOOL Read(CFile& file, BYTE version);
	void GetConnections(CArray<CJack*, CJack*>& list);
	void GetPatchCords(CArray<CPatchCord*, CPatchCord*>& list);
	void Invalidate(void);
	void SetOverwriteEnable(void);
	RECT SetOverwrite(BOOL bFlag);
	void CalcRect(void);

	inline void Mark(BOOL bMark) { m_bMark = bMark; };
//	inline BOOL GetMark(void) const { return m_bMark; };
	inline CJack* GetJack(void) const { return m_pJack; };
//	inline void SetJack(CJack* pJack) { m_pJack = pJack; };
	inline void SetInvalid(BOOL bFlag) { m_bInvalid = bFlag; };
	inline BOOL IsInvalid(void) const { return m_bInvalid; };
	inline CRect GetRect(void) const { return m_rect; };
	inline CArray<CPoint, CPoint&>& GetPoints(void) { return m_points; };
	inline PatchNode* GetPatchNode(void) const { return m_pPatchNode; };
	inline PointOn GetLastPointOn(void) const { return m_lastPointOn; };
	inline const CPoint& GetLastPoint(void) const { return m_lastPoint; };
	inline void Highlight(BOOL bFlag) { m_bHighlight = bFlag; };
	inline BOOL GetOverwrite(void) const { return m_bOverwrite; };
	inline BOOL GetOverwriteEnable(void) const { return m_bOverwriteEnable; };
	inline void SetOverwriteEnable(BOOL bFlag) { m_bOverwriteEnable = bFlag; };

private:

	// Saved to file
	BOOL						m_bInvalid;		// TRUE if invalid
	CRect						m_rect;			// Bounding rect
	CJack*						m_pJack;		// Only the id is saved
	BOOL						m_bOverwrite;
	BOOL						m_bOverwriteEnable;
	CArray<CPoint, CPoint&>		m_points;		// Points in line
	PatchNode*					m_pPatchNode;	// Connection(s)

	// Not saved to file
	PointOn						m_lastPointOn;	// Last point location
	CPoint						m_lastPoint;	// Last point
	BOOL						m_bBadData;		// TRUE if the pointers are bad
	BOOL						m_bMark;
	BOOL						m_bHighlight;
};

#endif // !defined(AFX_PATCHCORD_H__94E63C94_9F86_4138_B073_A64F83BA8AE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\Unique.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Unique.h

Abstract:

	Base class for all unique objects

Author:

	Robert Heitkamp (robheit) 27-Nov-2001

Revision History:

	27-Nov-2001 robheit
		Initial Version

--*/
#if !defined(AFX_UNIQUE_H__0287EF65_4786_4D05_898F_04C36A2C4926__INCLUDED_)
#define AFX_UNIQUE_H__0287EF65_4786_4D05_898F_04C36A2C4926__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <afxwin.h>

//------------------------------------------------------------------------------
//	CUnique
//------------------------------------------------------------------------------
class CUnique  
{
public:

	CUnique(void);
	virtual ~CUnique(void);

	virtual void Write(CFile& file); // throw(CFileException);
	virtual BOOL Read(CFile& file, BYTE version);

	DWORD GetId(void) const { return m_id; };
//	void SetId(DWORD id) { m_id = id; };

private:

	static DWORD	m_globalId;
	DWORD			m_id;
};

#endif // !defined(AFX_UNIQUE_H__0287EF65_4786_4D05_898F_04C36A2C4926__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\WinDspImageBuilder.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WinDspImageBuilder.h

Abstract:

	Windowed version of CDspImageBuilder

Author:

	Robert Heitkamp (robheit) 08-Jun-2001

Revision History:

	08-Jun-2001 robheit
		Initial Version

--*/
#ifndef _WINDSPIMAGEBUILDER_H_
#define _WINDSPIMAGEBUILDER_H_

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "..\XGPIMAGE\fxdspimg.h"

//------------------------------------------------------------------------------
//	CWinDspImageBuilder
//------------------------------------------------------------------------------
class CWinDspImageBuilder : public CDspImageBuilder  
{
public:

	CWinDspImageBuilder(void);
	virtual ~CWinDspImageBuilder(void);

	void ShowDialog(void);
	void ClearText(void);

	virtual void Print(PCHAR pFormat, ...);

private:

	CString	m_text;
	BOOL	m_showDialog;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dspbuilder\WinDspImageBuilder.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WinDspImageBuilder.cpp

Abstract:

	Windowed version of CDspImageBuilder

Author:

	Robert Heitkamp (robheit) 08-Jun-2001

Revision History:

	08-Jun-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "dspbuilder.h"
#include "WinDspImageBuilder.h"
#include "resource.h"

class CDSPDialog : public CDialog 
{
public:

	CDSPDialog(LPCSTR pString=NULL) : CDialog(IDD_DSP_ERROR) 
	{
		unsigned i;
		unsigned length	= strlen(pString);
		unsigned count	= 0;

		// Count the number of carriage returns
		for(i=0; i<length; ++i)
		{
			if(pString[i] == '\n')
				++count;
		}

		m_pString = new char [length + count + 1];

		for(count=0, i=0; i<length; ++i)
		{
			if(pString[i] == '\n')
				m_pString[count++] = 13;
			m_pString[count++] = pString[i];
		}
		m_pString[count] = '\0';
	};

	virtual ~CDSPDialog(void)
	{
		delete [] m_pString;
	}

protected:

	virtual BOOL OnInitDialog(void)
	{
		CDialog::OnInitDialog();
		SetDlgItemText(IDC_DSP_ERROR_EDIT, m_pString);
		return TRUE;
	}

private:

	LPTSTR	m_pString;
};

//------------------------------------------------------------------------------
//	CWinDspImageBuilder::CWinDspImageBuilder
//------------------------------------------------------------------------------
CWinDspImageBuilder::CWinDspImageBuilder(void) : CDspImageBuilder("dspbuilder")
/*++

Routine Description:

	Constructor

Arguments:

	IN pAppName -	Application name

Return Value:

	None

--*/
{
	m_showDialog = FALSE;
}

//------------------------------------------------------------------------------
//	CWinDspImageBuilder::~CWinDspImageBuilder
//------------------------------------------------------------------------------
CWinDspImageBuilder::~CWinDspImageBuilder(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CWinDspImageBuilder::ShowDialog
//------------------------------------------------------------------------------
void
CWinDspImageBuilder::ShowDialog(void)
/*++

Routine Description:

	Shows the dialog if any text exists

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_showDialog)
	{
		m_showDialog = FALSE;
		CDSPDialog	dialog(m_text);
		dialog.DoModal();
	}
}

//------------------------------------------------------------------------------
//	CWinDspImageBuilder::ClearText
//------------------------------------------------------------------------------
void
CWinDspImageBuilder::ClearText(void)
/*++

Routine Description:

	Clears any text

Arguments:

	None

Return Value:

	None

--*/
{
	m_text.Empty();
	m_showDialog = TRUE;
}

//------------------------------------------------------------------------------
//	CWinDspImageBuilder::Print
//------------------------------------------------------------------------------
void
CWinDspImageBuilder::Print(
						   IN PCHAR	pFormat,
						   IN ...
						   )
/*++

Routine Description:

	Virtual print method.

Arguments:

	IN pFormat -	Format string
	IN ... -		Additional arguments

Return Value:

	None

--*/
{
    CHAR    szString[0x400];
    va_list	va;

	va_start(va, pFormat);
	vsprintf(szString, pFormat, va);
	va_end(va);

	m_text			+= szString;
	m_showDialog	= TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\dscommon.cpp ===
#include "..\..\common\dscommon.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\ifileio.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1/18/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ifileio.cpp
 *  Content:    IRemoteFileIo implementation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/18/2002   dereks  Created.
 *
 ****************************************************************************/

#include "dsremi.h"

using namespace DSREMOTE;


/****************************************************************************
 *
 *  CreateRemoteFileIo
 *
 *  Description:
 *      Creates a remote file I/O object.
 *
 *  Arguments:
 *      LPREMOTECONNECTION [in]: connection object.
 *      LPREMOTEFILEIO * [out]: remote file I/O object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateRemoteFileIo"

HRESULT
CreateRemoteFileIo
(
    LPREMOTECONNECTION      pConnection, 
    LPREMOTEFILEIO *        ppFileIo
)
{
    CRemoteFileIo *         pFileIo;
    HRESULT                 hr;

    hr = HRFROMP(pFileIo = NEW(CRemoteFileIo(pConnection)));

    if(SUCCEEDED(hr))
    {
        *ppFileIo = pFileIo;
    }

    return hr;
}


/****************************************************************************
 *
 *  CRemoteFileIo
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      LPREMOTECONNECTION [in]: connection object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::CRemoteFileIo"

CRemoteFileIo::CRemoteFileIo
(
    LPREMOTECONNECTION      pConnection
)
{
    m_pConnection = ADDREF(pConnection);
}


/****************************************************************************
 *
 *  ~CRemoteFileIo
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::~CRemoteFileIo"

CRemoteFileIo::~CRemoteFileIo
(
    void
)
{
    RELEASE(m_pConnection);
}


/****************************************************************************
 *
 *  CreateFile
 *
 *  Description:
 *      Creates or opens a file on the remote machine.
 *
 *  Arguments:
 *      LPCSTR [in]: remote file path.
 *      DWORD [in]: access flags.
 *      DWORD [in]: share mode.
 *      DWORD [in]: creation flags.
 *      DWORD [in]: general flags and file attributes.
 *      LPHANDLE [out]: remote file handle.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::CreateFile"

HRESULT
CRemoteFileIo::CreateFile
(
    LPCSTR                          pszRemoteFile, 
    DWORD                           dwDesiredAccess, 
    DWORD                           dwShareMode, 
    DWORD                           dwCreationDistribution, 
    DWORD                           dwFlagsAndAttributes, 
    LPHANDLE                        phFile
)
{
    DSRPACKET                       Packet;
    DSRBUFFER                       Buffers[1];
    DSRBUFFER                       Response;
    DSRFILEIO_CREATEFILE_MSGDATA    PacketData;
    DSRFILEIO_CREATEFILE_RESPONSE   ResponseData;
    HRESULT                         hr;

    Packet.dwMajorType = DSRTYPE_FILEIO;
    Packet.dwMinorType = DSRTYPE_FILEIO_CREATEFILE;
    Packet.dwFlags = 0;

    Buffers[0].dwSize = sizeof(PacketData);
    Buffers[0].pvData = &PacketData;

    strcpy(PacketData.szFileName, pszRemoteFile);

    PacketData.dwDesiredAccess = dwDesiredAccess;
    PacketData.dwShareMode = dwShareMode;
    PacketData.dwCreationDistribution = dwCreationDistribution;
    PacketData.dwFlagsAndAttributes = dwFlagsAndAttributes;

    Response.dwSize = sizeof(ResponseData);
    Response.pvData = &ResponseData;

    hr = m_pConnection->Send(&Packet, NUMELMS(Buffers), Buffers, &Response);

    if(SUCCEEDED(hr))
    {
        ASSERT(sizeof(ResponseData) == Response.dwSize);
        
        if(ERROR_SUCCESS == ResponseData.dwError)
        {
            ASSERT(IS_VALID_HANDLE_VALUE(ResponseData.hFile));

            *phFile = ResponseData.hFile;
        }
        else
        {
            ASSERT(!IS_VALID_HANDLE_VALUE(ResponseData.hFile));

            hr = HRESULT_FROM_WIN32(ResponseData.dwError);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  ReadFile
 *
 *  Description:
 *      Reads data from a file opened on the remote machine.
 *
 *  Arguments:
 *      HANDLE [in]: remote file handle.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size, in bytes.
 *      LPDWORD [out]: amount read, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::ReadFile"

HRESULT
CRemoteFileIo::ReadFile
(
    HANDLE                          hFile, 
    LPVOID                          pvBuffer, 
    DWORD                           dwBufferSize, 
    LPDWORD                         pdwBytesRead
)                                   
{                                   
    DSRPACKET                       Packet;
    DSRBUFFER                       Buffers[1];
    DSRBUFFER                       Response;
    DSRFILEIO_READFILE_MSGDATA      PacketData;
    LPDSRFILEIO_READFILE_RESPONSE   pResponseData;
    DWORD                           dwResponseSize;
    HRESULT                         hr;

    //
    // Read requests are sent as a simple message containing just the file
    // handle.  The response packet dictates the amount of data to read and
    // the amount actually read.
    //

    dwResponseSize = sizeof(*pResponseData) + dwBufferSize;

    hr = HRFROMP(pResponseData = (LPDSRFILEIO_READFILE_RESPONSE)MEMALLOC_NOINIT(BYTE, dwResponseSize));

    if(SUCCEEDED(hr))
    {
        Packet.dwMajorType = DSRTYPE_FILEIO;
        Packet.dwMinorType = DSRTYPE_FILEIO_READFILE;
        Packet.dwFlags = 0;
        
        Buffers[0].dwSize = sizeof(PacketData);
        Buffers[0].pvData = &PacketData;
    
        PacketData.hFile = hFile;

        Response.dwSize = dwResponseSize;
        Response.pvData = pResponseData;

        hr = m_pConnection->Send(&Packet, NUMELMS(Buffers), Buffers, &Response);
    }

    if(SUCCEEDED(hr))
    {
        if(ERROR_SUCCESS == pResponseData->dwError)
        {
            CopyMemory(pvBuffer, pResponseData + 1, Response.dwSize - sizeof(*pResponseData));

            if(pdwBytesRead)
            {
                *pdwBytesRead = Response.dwSize - sizeof(*pResponseData);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(pResponseData->dwError);
        }
    }

    MEMFREE(pResponseData);

    return hr;
}


/****************************************************************************
 *
 *  WriteFile
 *
 *  Description:
 *      Writes data to a file opened on the remote machine.
 *
 *  Arguments:
 *      HANDLE [in]: remote file handle.
 *      LPCVOID [in]: data buffer.
 *      DWORD [in]: data buffer size, in bytes.
 *      LPDWORD [out]: amount written, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::WriteFile"

HRESULT
CRemoteFileIo::WriteFile
(
    HANDLE                          hFile, 
    LPCVOID                         pvBuffer, 
    DWORD                           dwBufferSize, 
    LPDWORD                         pdwBytesWritten
)                                   
{                                   
    DSRPACKET                       Packet;
    DSRBUFFER                       Buffers[2];
    DSRBUFFER                       Response;
    DSRFILEIO_WRITEFILE_MSGDATA     PacketData;
    DSRFILEIO_WRITEFILE_RESPONSE    ResponseData;
    DWORD                           dwPacketSize;
    HRESULT                         hr;

    //
    // Write requests are sent with the buffer data appended to the outgoing
    // packet.
    //

    Packet.dwMajorType = DSRTYPE_FILEIO;
    Packet.dwMinorType = DSRTYPE_FILEIO_WRITEFILE;
    Packet.dwFlags = 0;

    Buffers[0].dwSize = sizeof(PacketData);
    Buffers[0].pvData = &PacketData;

    PacketData.hFile = hFile;

    Buffers[1].dwSize = dwBufferSize;
    Buffers[1].pvData = (LPVOID)pvBuffer;
    
    Response.dwSize = sizeof(ResponseData);
    Response.pvData = &ResponseData;

    hr = m_pConnection->Send(&Packet, NUMELMS(Buffers), Buffers, &Response);

    if(SUCCEEDED(hr))
    {
        if(ERROR_SUCCESS == ResponseData.dwError)
        {
            if(pdwBytesWritten)
            {
                *pdwBytesWritten = ResponseData.dwBytesWritten;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ResponseData.dwError);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  SetFilePointer
 *
 *  Description:
 *      Sets the current file pointer on a file opened on the remote machine.
 *
 *  Arguments:
 *      HANDLE [in]: remote file handle.
 *      LONG [in]: distance to move.
 *      DWORD [in]: move method.
 *      LPDWORD [out]: absolute file position after the move.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::SetFilePointer"

HRESULT
CRemoteFileIo::SetFilePointer
(
    HANDLE                              hFile, 
    LONG                                lDistanceToMove, 
    DWORD                               dwMoveMethod, 
    LPDWORD                             pdwAbsPosition
)                                   
{                                   
    DSRPACKET                           Packet;
    DSRBUFFER                           Buffers[1];
    DSRBUFFER                           Response;
    DSRFILEIO_SETFILEPOINTER_MSGDATA    PacketData;
    DSRFILEIO_SETFILEPOINTER_RESPONSE   ResponseData;
    HRESULT                             hr;

    Packet.dwMajorType = DSRTYPE_FILEIO;
    Packet.dwMinorType = DSRTYPE_FILEIO_SETFILEPOINTER;
    Packet.dwFlags = 0;
    
    Buffers[0].dwSize = sizeof(PacketData);
    Buffers[0].pvData = &PacketData;

    PacketData.hFile = hFile;
    PacketData.lDistanceToMove = lDistanceToMove;
    PacketData.dwMoveMethod = dwMoveMethod;

    Response.dwSize = sizeof(ResponseData);
    Response.pvData = &ResponseData;

    hr = m_pConnection->Send(&Packet, NUMELMS(Buffers), Buffers, &Response);

    if(SUCCEEDED(hr))
    {
        if(ERROR_SUCCESS == ResponseData.dwError)
        {
            if(pdwAbsPosition)
            {
                *pdwAbsPosition = ResponseData.dwAbsPosition;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ResponseData.dwError);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  SetEndOfFile
 *
 *  Description:
 *      Sets the current file position as the end of the file.
 *
 *  Arguments:
 *      HANDLE [in]: remote file handle.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::SetEndOfFile"

HRESULT
CRemoteFileIo::SetEndOfFile
(
    HANDLE                          hFile
)                                   
{                                   
    DSRPACKET                       Packet;
    DSRBUFFER                       Buffers[1];
    DSRBUFFER                       Response;
    DSRFILEIO_SETENDOFFILE_MSGDATA  PacketData;
    DSRFILEIO_SETENDOFFILE_RESPONSE ResponseData;
    HRESULT                         hr;

    Packet.dwMajorType = DSRTYPE_FILEIO;
    Packet.dwMinorType = DSRTYPE_FILEIO_SETENDOFFILE;
    Packet.dwFlags = 0;
    
    Buffers[0].dwSize = sizeof(PacketData);
    Buffers[0].pvData = &PacketData;

    PacketData.hFile = hFile;

    Response.dwSize = sizeof(ResponseData);
    Response.pvData = &ResponseData;

    hr = m_pConnection->Send(&Packet, NUMELMS(Buffers), Buffers, &Response);

    if(SUCCEEDED(hr))
    {
        if(ERROR_SUCCESS != ResponseData.dwError)
        {
            hr = HRESULT_FROM_WIN32(ResponseData.dwError);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  CloseHandle
 *
 *  Description:
 *      Closes a remotely open file.
 *
 *  Arguments:
 *      HANDLE [in]: remote file handle.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::CloseHandle"

HRESULT
CRemoteFileIo::CloseHandle
(
    HANDLE                          hFile
)                                   
{                                   
    DSRPACKET                       Packet;
    DSRBUFFER                       Buffers[1];
    DSRBUFFER                       Response;
    DSRFILEIO_CLOSEHANDLE_MSGDATA   PacketData;
    DSRFILEIO_CLOSEHANDLE_RESPONSE  ResponseData;
    HRESULT                         hr;

    Packet.dwMajorType = DSRTYPE_FILEIO;
    Packet.dwMinorType = DSRTYPE_FILEIO_CLOSEHANDLE;
    Packet.dwFlags = 0;

    Buffers[0].dwSize = sizeof(PacketData);
    Buffers[0].pvData = &PacketData;

    PacketData.hFile = hFile;

    Response.dwSize = sizeof(ResponseData);
    Response.pvData = &ResponseData;

    hr = m_pConnection->Send(&Packet, NUMELMS(Buffers), Buffers, &Response);

    if(SUCCEEDED(hr))
    {
        if(ERROR_SUCCESS != ResponseData.dwError)
        {
            hr = HRESULT_FROM_WIN32(ResponseData.dwError);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  DeleteFile
 *
 *  Description:
 *      Deletes a file from the remote machine.
 *
 *  Arguments:
 *      LPCSTR [in]: remote file name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::DeleteFile"

HRESULT
CRemoteFileIo::DeleteFile
(
    LPCSTR                          pszRemoteFile
)                                   
{                                   
    DSRPACKET                       Packet;
    DSRBUFFER                       Buffers[1];
    DSRBUFFER                       Response;
    DSRFILEIO_DELETEFILE_MSGDATA    PacketData;
    DSRFILEIO_DELETEFILE_RESPONSE   ResponseData;
    HRESULT                         hr;

    Packet.dwMajorType = DSRTYPE_FILEIO;
    Packet.dwMinorType = DSRTYPE_FILEIO_DELETEFILE;
    Packet.dwFlags = 0;
    
    Buffers[0].dwSize = sizeof(PacketData);
    Buffers[0].pvData = &PacketData;

    strcpy(PacketData.szFileName, pszRemoteFile);

    Response.dwSize = sizeof(ResponseData);
    Response.pvData = &ResponseData;

    hr = m_pConnection->Send(&Packet, NUMELMS(Buffers), Buffers, &Response);

    if(SUCCEEDED(hr))
    {
        if(ERROR_SUCCESS != ResponseData.dwError)
        {
            hr = HRESULT_FROM_WIN32(ResponseData.dwError);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  CopyFile
 *
 *  Description:
 *      Copies a file from this machine to the remote one.
 *
 *  Arguments:
 *      LPCSTR [in]: source file name.
 *      LPCSTR [in]: remote file name.
 *      BOOL [in]: FALSE to allow overwriting the file.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIo::CopyFile"

HRESULT
CRemoteFileIo::CopyFile
(
    LPCSTR                  pszSourceFile,
    LPCSTR                  pszRemoteFile,
    BOOL                    fFailIfFileExists
)                                   
{                                   
    static const DWORD      dwBufferSize    = DSREMOTE_OPTIMAL_PACKET_SIZE - sizeof(DSRFILEIO_WRITEFILE_MSGDATA);
    HANDLE                  hSourceFile     = INVALID_HANDLE_VALUE;
    HANDLE                  hRemoteFile     = INVALID_HANDLE_VALUE;
    LPVOID                  pvBuffer;
    DWORD                   dwRead;
    HRESULT                 hr;

    hr = HRFROMP(pvBuffer = MEMALLOC_NOINIT(BYTE, dwBufferSize));

    if(SUCCEEDED(hr))
    {
        if(!IS_VALID_HANDLE_VALUE(hSourceFile = ::CreateFile(pszSourceFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = this->CreateFile(pszRemoteFile, GENERIC_READ | GENERIC_WRITE, 0, fFailIfFileExists ? CREATE_NEW : CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, &hRemoteFile);
    }

    while(SUCCEEDED(hr))
    {
        if(!::ReadFile(hSourceFile, pvBuffer, dwBufferSize, &dwRead, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        if(SUCCEEDED(hr) && !dwRead)
        {
            break;
        }

        if(SUCCEEDED(hr))
        {
            hr = this->WriteFile(hRemoteFile, pvBuffer, dwRead, NULL);
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = this->SetEndOfFile(hRemoteFile);
    }

    if(IS_VALID_HANDLE_VALUE(hSourceFile))
    {
        ::CloseHandle(hSourceFile);
    }
    
    if(IS_VALID_HANDLE_VALUE(hRemoteFile))
    {
        this->CloseHandle(hRemoteFile);
    }
    
    MEMFREE(pvBuffer);

    return hr;
}


/****************************************************************************
 *
 *  Receive
 *
 *  Description:
 *      Called when data is received.
 *
 *  Arguments:
 *      LPCDSRPACKET [in]: packet data.
 *      LPDSRBUFFER   [in/out]: response data.
 *      LPVOID [in]: callback context.
 *
 *  Returns:  
 *      BOOL: TRUE if the message was handled.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIoHandler;:Receive"

BOOL
CRemoteFileIoHandler::Receive
(
    LPCDSRPACKET            pPacketHeader, 
    LPCDSRBUFFER            pPacketBuffer, 
    LPDSRBUFFER             pResponseBuffer, 
    LPVOID                  pvContext
)
{
    CRemoteFileIoHandler *  pHandler    = (CRemoteFileIoHandler *)pvContext;
    BOOL                    fHandled    = TRUE;
    
    ASSERT(pPacketHeader);
    ASSERT(pPacketBuffer);
    ASSERT(pResponseBuffer);

    ASSERT(DSRTYPE == pPacketHeader->dwMajorType);
    
    switch(pPacketHeader->dwMinorType)
    {
        case DSRTYPE_FILEIO_CREATEFILE:
            pHandler->CreateFile(pPacketBuffer, pResponseBuffer);
            break;

        case DSRTYPE_FILEIO_READFILE:
            pHandler->ReadFile(pPacketBuffer, pResponseBuffer);
            break;

        case DSRTYPE_FILEIO_WRITEFILE:
            pHandler->WriteFile(pPacketBuffer, pResponseBuffer);
            break;

        case DSRTYPE_FILEIO_SETFILEPOINTER:
            pHandler->SetFilePointer(pPacketBuffer, pResponseBuffer);
            break;

        case DSRTYPE_FILEIO_SETENDOFFILE:
            pHandler->SetEndOfFile(pPacketBuffer, pResponseBuffer);
            break;

        case DSRTYPE_FILEIO_CLOSEHANDLE:
            pHandler->CloseHandle(pPacketBuffer, pResponseBuffer);
            break;

        case DSRTYPE_FILEIO_DELETEFILE:
            pHandler->DeleteFile(pPacketBuffer, pResponseBuffer);
            break;

        default:
            fHandled = FALSE;
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  CreateFile
 *
 *  Description:
 *      Creates or opens a file on the remote machine.
 *
 *  Arguments:
 *      LPCDSRBUFFER [in]: packet data.
 *      LPDSRBUFFER   [in/out]: response data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIoHandler::CreateFile"

void
CRemoteFileIoHandler::CreateFile
(
    LPCDSRBUFFER                    pPacket, 
    LPDSRBUFFER                     pResponse
)
{
    LPCDSRFILEIO_CREATEFILE_MSGDATA pPacketData     = (LPCDSRFILEIO_CREATEFILE_MSGDATA)pPacket->pvData;
    LPDSRFILEIO_CREATEFILE_RESPONSE pResponseData   = (LPDSRFILEIO_CREATEFILE_RESPONSE)pResponse->pvData;

    ASSERT(pPacket->dwSize >= sizeof(*pPacketData));
    ASSERT(pResponse->dwSize >= sizeof(*pResponseData));

    pResponseData->hFile = ::CreateFile(pPacketData->szFileName, pPacketData->dwDesiredAccess, pPacketData->dwShareMode, NULL, pPacketData->dwCreationDistribution, pPacketData->dwFlagsAndAttributes, NULL);

    if(IS_VALID_HANDLE_VALUE(pResponseData->hFile))
    {
        pResponseData->dwError = ERROR_SUCCESS;
    }
    else
    {
        pResponseData->dwError = GetLastError();

        DPF_ERROR("CreateFile failed with error %lu", pResponseData->dwError);
    }

    pResponse->dwSize = sizeof(*pResponseData);
}


/****************************************************************************
 *
 *  ReadFile
 *
 *  Description:
 *      Reads data from a file opened on the remote machine.
 *
 *  Arguments:
 *      LPCDSRBUFFER [in]: packet data.
 *      LPDSRBUFFER   [in/out]: response data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIoHandler::ReadFile"

void
CRemoteFileIoHandler::ReadFile
(
    LPCDSRBUFFER                    pPacket, 
    LPDSRBUFFER                     pResponse
)
{
    LPCDSRFILEIO_READFILE_MSGDATA   pPacketData     = (LPCDSRFILEIO_READFILE_MSGDATA)pPacket->pvData;
    LPDSRFILEIO_READFILE_RESPONSE   pResponseData   = (LPDSRFILEIO_READFILE_RESPONSE)pResponse->pvData;
    DWORD                           dwBytesRead;

    ASSERT(pPacket->dwSize >= sizeof(*pPacketData));
    ASSERT(pResponse->dwSize >= sizeof(*pResponseData));

    if(::ReadFile(pPacketData->hFile, pResponseData + 1, pResponse->dwSize - sizeof(*pResponseData), &dwBytesRead, NULL))
    {
        pResponseData->dwError = ERROR_SUCCESS;
        pResponse->dwSize = dwBytesRead + sizeof(*pResponseData);
    }
    else
    {
        pResponseData->dwError = GetLastError();
        pResponse->dwSize = sizeof(*pResponseData);

        DPF_ERROR("ReadFile failed with error %lu", pResponseData->dwError);
    }
}


/****************************************************************************
 *
 *  WriteFile
 *
 *  Description:
 *      Writes data to a file opened on the remote machine.
 *
 *  Arguments:
 *      LPCDSRBUFFER [in]: packet data.
 *      LPDSRBUFFER   [in/out]: response data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIoHandler::WriteFile"

void
CRemoteFileIoHandler::WriteFile
(
    LPCDSRBUFFER                    pPacket, 
    LPDSRBUFFER                     pResponse
)
{
    LPCDSRFILEIO_WRITEFILE_MSGDATA  pPacketData     = (LPCDSRFILEIO_WRITEFILE_MSGDATA)pPacket->pvData;
    LPDSRFILEIO_WRITEFILE_RESPONSE  pResponseData   = (LPDSRFILEIO_WRITEFILE_RESPONSE)pResponse->pvData;

    ASSERT(pPacket->dwSize >= sizeof(*pPacketData));
    ASSERT(pResponse->dwSize >= sizeof(*pResponseData));

    if(::WriteFile(pPacketData->hFile, pPacketData + 1, pPacket->dwSize - sizeof(*pPacketData), &pResponseData->dwBytesWritten, NULL))
    {
        pResponseData->dwError = ERROR_SUCCESS;
    }
    else
    {
        pResponseData->dwError = GetLastError();

        DPF_ERROR("WriteFile failed with error %lu", pResponseData->dwError);
    }

    pResponse->dwSize = sizeof(*pResponseData);
}


/****************************************************************************
 *
 *  SetFilePointer
 *
 *  Description:
 *      Writes data to a file opened on the remote machine.
 *
 *  Arguments:
 *      LPCDSRBUFFER [in]: packet data.
 *      LPDSRBUFFER   [in/out]: response data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIoHandler::SetFilePointer"

void
CRemoteFileIoHandler::SetFilePointer
(
    LPCDSRBUFFER                        pPacket, 
    LPDSRBUFFER                         pResponse
)
{
    LPCDSRFILEIO_SETFILEPOINTER_MSGDATA pPacketData     = (LPCDSRFILEIO_SETFILEPOINTER_MSGDATA)pPacket->pvData;
    LPDSRFILEIO_SETFILEPOINTER_RESPONSE pResponseData   = (LPDSRFILEIO_SETFILEPOINTER_RESPONSE)pResponse->pvData;

    ASSERT(pPacket->dwSize >= sizeof(*pPacketData));
    ASSERT(pResponse->dwSize >= sizeof(*pResponseData));

    pResponseData->dwAbsPosition = ::SetFilePointer(pPacketData->hFile, pPacketData->lDistanceToMove, NULL, pPacketData->dwMoveMethod);
    
    if(INVALID_SET_FILE_POINTER != pResponseData->dwAbsPosition)
    {
        pResponseData->dwError = ERROR_SUCCESS;
    }
    else
    {
        pResponseData->dwError = GetLastError();

        DPF_ERROR("SetFilePointer failed with error %lu", pResponseData->dwError);
    }

    pResponse->dwSize = sizeof(*pResponseData);
}


/****************************************************************************
 *
 *  SetEndOfFile
 *
 *  Description:
 *      Writes data to a file opened on the remote machine.
 *
 *  Arguments:
 *      LPCDSRBUFFER [in]: packet data.
 *      LPDSRBUFFER   [in/out]: response data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIoHandler::SetEndOfFile"

void
CRemoteFileIoHandler::SetEndOfFile
(
    LPCDSRBUFFER                        pPacket, 
    LPDSRBUFFER                         pResponse
)
{
    LPCDSRFILEIO_SETENDOFFILE_MSGDATA   pPacketData     = (LPCDSRFILEIO_SETENDOFFILE_MSGDATA)pPacket->pvData;
    LPDSRFILEIO_SETENDOFFILE_RESPONSE   pResponseData   = (LPDSRFILEIO_SETENDOFFILE_RESPONSE)pResponse->pvData;

    ASSERT(pPacket->dwSize >= sizeof(*pPacketData));
    ASSERT(pResponse->dwSize >= sizeof(*pResponseData));

    if(::SetEndOfFile(pPacketData->hFile))
    {
        pResponseData->dwError = ERROR_SUCCESS;
    }
    else
    {
        pResponseData->dwError = GetLastError();

        DPF_ERROR("SetEndOfFile failed with error %lu", pResponseData->dwError);
    }

    pResponse->dwSize = sizeof(*pResponseData);
}


/****************************************************************************
 *
 *  CloseHandle
 *
 *  Description:
 *      Writes data to a file opened on the remote machine.
 *
 *  Arguments:
 *      LPCDSRBUFFER [in]: packet data.
 *      LPDSRBUFFER   [in/out]: response data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIoHandler::CloseHandle"

void
CRemoteFileIoHandler::CloseHandle
(
    LPCDSRBUFFER                        pPacket, 
    LPDSRBUFFER                         pResponse
)
{
    LPCDSRFILEIO_CLOSEHANDLE_MSGDATA    pPacketData     = (LPCDSRFILEIO_CLOSEHANDLE_MSGDATA)pPacket->pvData;
    LPDSRFILEIO_CLOSEHANDLE_RESPONSE    pResponseData   = (LPDSRFILEIO_CLOSEHANDLE_RESPONSE)pResponse->pvData;

    ASSERT(pPacket->dwSize >= sizeof(*pPacketData));
    ASSERT(pResponse->dwSize >= sizeof(*pResponseData));

    if(::CloseHandle(pPacketData->hFile))
    {
        pResponseData->dwError = ERROR_SUCCESS;
    }
    else
    {
        pResponseData->dwError = GetLastError();

        DPF_ERROR("CloseHandle failed with error %lu", pResponseData->dwError);
    }

    pResponse->dwSize = sizeof(*pResponseData);
}


/****************************************************************************
 *
 *  DeleteFile
 *
 *  Description:
 *      Writes data to a file opened on the remote machine.
 *
 *  Arguments:
 *      LPCDSRBUFFER [in]: packet data.
 *      LPDSRBUFFER   [in/out]: response data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteFileIoHandler::DeleteFile"

void
CRemoteFileIoHandler::DeleteFile
(
    LPCDSRBUFFER                    pPacket, 
    LPDSRBUFFER                     pResponse
)
{
    LPCDSRFILEIO_DELETEFILE_MSGDATA pPacketData     = (LPCDSRFILEIO_DELETEFILE_MSGDATA)pPacket->pvData;
    LPDSRFILEIO_DELETEFILE_RESPONSE pResponseData   = (LPDSRFILEIO_DELETEFILE_RESPONSE)pResponse->pvData;

    ASSERT(pPacket->dwSize >= sizeof(*pPacketData));
    ASSERT(pResponse->dwSize >= sizeof(*pResponseData));

    if(::DeleteFile(pPacketData->szFileName))
    {
        pResponseData->dwError = ERROR_SUCCESS;
    }
    else
    {
        pResponseData->dwError = GetLastError();

        DPF_ERROR("DeleteFile failed with error %lu", pResponseData->dwError);
    }

    pResponse->dwSize = sizeof(*pResponseData);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\sources.inc ===
#
# Common sources file for all dsremote apps and libs
#

C_DEFINES=$(C_DEFINES) -DDPF_LIBRARY=\"DSREMOTE\" -DNAMESPACE=DSREMOTE -DDPFLVL_DEFAULT=4

INCLUDES=$(INCLUDES);\
    $(DSBASEDIR)\tools\dsremote

SOURCES=$(SOURCES) \
    ..\iremote.cpp \
    ..\ifileio.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\iremote.h ===
/***************************************************************************
 *
 *  Copyright (C) 1/8/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iremote.h
 *  Content:    IRemoteConnection interface impelementation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/8/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __IREMOTE_H__
#define __IREMOTE_H__

//
// Packet signature
//

#define DSREMOTE_PACKET_SIGNATURE   'srsd'

//
// Reserved packet flags (outgoing)
//

#define DSRPACKETF_ACKREQ           0x00010000

//
// Reserved packet flags (incoming)
//

#define DSRPACKETF_ACK              0x80000000

//
// Packet header
//

BEGIN_DEFINE_STRUCT()
    DWORD           dwSignature;        // Packet signature
    DWORD           dwSequence;         // Packet sequence number
    DWORD           dwMajorType;        // Packet major type
    DWORD           dwMinorType;        // Packet minor type
    DWORD           dwFlags;            // Packet flags
    DWORD           dwSize;             // Packet data buffer size
    DWORD           dwResponseSize;     // Response data size
    DWORD           dwStitchOffset;     // Stitched message data offset
    DWORD           dwStitchSize;       // Stitched message size
    DWORD           dwChecksum;         // Packet checksum
END_DEFINE_STRUCT(DSRPACKETHEADER);

#ifdef __cplusplus

//
// DSREMOTECALLBACK wrapper
//

namespace DSREMOTE
{
    class CRemoteCallback
    {
    private:
        DSREMOTECALLBACK        m_Callback;         // Callback object
        LPVOID                  m_pvContext;        // Context

    public:
        void Initialize(LPCDSREMOTECALLBACK pCallback, LPVOID pvContext);
        void Connect(LPCSTR pszRemoteAddress);
        void Disconnect(void);
    };

    __inline void CRemoteCallback::Initialize(LPCDSREMOTECALLBACK pCallback, LPVOID pvContext)
    {
        if(pCallback)
        {
            m_Callback = *pCallback;
        }
        else
        {
            ZeroMemory(&m_Callback, sizeof(m_Callback));
        }

        m_pvContext = pvContext;
    }

    __inline void CRemoteCallback::Connect(LPCSTR pszRemoteAddress)
    {
        if(m_Callback.Connect)
        {
            m_Callback.Connect(pszRemoteAddress, m_pvContext);
        }
    }

    __inline void CRemoteCallback::Disconnect(void)
    {
        if(m_Callback.Disconnect)
        {
            m_Callback.Disconnect(m_pvContext);
        }
    }
}

//
// IDSREMOTEMSGHANDLER wrapper
//

namespace DSREMOTE
{
    class CRemoteMsgHandler
    {
    public:
        LIST_ENTRY              m_leHandlers;       // List entry
        DWORD                   m_dwMajorType;      // Msg major type

    private:
        DSREMOTEMSGHANDLER      m_Callback;         // Callback object
        LPVOID                  m_pvContext;        // Context

    public:
        CRemoteMsgHandler(void);
        virtual ~CRemoteMsgHandler(void);

    public:
        void Initialize(DWORD dwMajorType, LPCDSREMOTEMSGHANDLER pCallback, LPVOID pvContext);
        BOOL Receive(LPCDSRPACKET pPacketHeader, LPCDSRBUFFER pPacketBuffer, LPDSRBUFFER pResponseBuffer);
    };

    __inline CRemoteMsgHandler::CRemoteMsgHandler(void)
    {
        InitializeListHead(&m_leHandlers);
    }

    __inline CRemoteMsgHandler::~CRemoteMsgHandler(void)
    {
        AssertValidEntryList(&m_leHandlers, ASSERT_NOT_IN_LIST);
    }

    __inline void CRemoteMsgHandler::Initialize(DWORD dwMajorType, LPCDSREMOTEMSGHANDLER pCallback, LPVOID pvContext)
    {
        m_dwMajorType = dwMajorType;
    
        if(pCallback)
        {
            m_Callback = *pCallback;
        }
        else
        {
            ZeroMemory(&m_Callback, sizeof(m_Callback));
        }

        m_pvContext = pvContext;
    }

    __inline BOOL CRemoteMsgHandler::Receive(LPCDSRPACKET pPacketHeader, LPCDSRBUFFER pPacketBuffer, LPDSRBUFFER pResponseBuffer)
    {
        BOOL                    fResponse;
    
        ASSERT(pPacketHeader);
        ASSERT(pPacketBuffer);
        ASSERT(pResponseBuffer);

        ASSERT(pPacketHeader->dwMajorType == m_dwMajorType);
    
        if(m_Callback.Receive)
        {
            fResponse = m_Callback.Receive(pPacketHeader, pPacketBuffer, pResponseBuffer, m_pvContext);
        }
        else
        {
            fResponse = FALSE;
        }
    
        return fResponse;
    }
}

//
// Stiched packet wrapper
//

namespace DSREMOTE
{
    class CStitchedPacket
    {
    public:
        LIST_ENTRY              m_leStitched;       // List entry
        DSRPACKETHEADER         m_PacketHeader;     // Packet data
        LPVOID                  m_pvPacketData;     // Data buffer
        DWORD                   m_dwReceived;       // Amount of data stitched so far

    public:
        CStitchedPacket(void);
        virtual ~CStitchedPacket(void);

    public:
        HRESULT Initialize(LPCDSRPACKETHEADER pPacketHeader, PLIST_ENTRY plstStitched);
    };
}

//
// IRemoteConnection implementation
//

namespace DSREMOTE
{
    class CRemoteConnection
        : public IRemoteConnection, public CRefCount
    {
    protected:
        DWORD                   m_dwPort;           // Port assignment
        CRemoteCallback         m_StatusCallback;   // Status callback object
        LIST_ENTRY              m_lstHandlers;      // Msg handlers
        LIST_ENTRY              m_lstStitched;      // Incomplete stiched messages
        SOCKET                  m_socket;           // Transmission socket
        DWORD                   m_dwState;          // Connection state
        DWORD                   m_dwSequence;       // Current outbound message sequence number

    private:
        CRemoteFileIoHandler    m_FileIoHandler;    // Standard file i/o handler

    public:
        CRemoteConnection(void);
        virtual ~CRemoteConnection(void);

    public:
        // Initialization
        HRESULT Initialize(DWORD dwPort, LPCDSREMOTECALLBACK pCallback, LPVOID pvContext);
    
        // IUnknown methods
        ULONG STDMETHODCALLTYPE AddRef(void);
        ULONG STDMETHODCALLTYPE Release(void);

        // IRemoteConnection methods
        HRESULT STDMETHODCALLTYPE Connect(LPCSTR pszHost, DWORD dwFlags);
        HRESULT STDMETHODCALLTYPE Disconnect(DWORD dwFlags);
        DWORD STDMETHODCALLTYPE GetState(void);
        HRESULT STDMETHODCALLTYPE Send(LPCDSRPACKET pPacketHeader, DWORD dwPacketBufferCount, LPCDSRBUFFER paPacketBuffers, LPDSRBUFFER pResponseBuffer);
        HRESULT STDMETHODCALLTYPE RegisterMsgHandler(DWORD dwMajorType, LPCDSREMOTEMSGHANDLER pHandler, LPVOID pvContext);
        HRESULT STDMETHODCALLTYPE UnregisterMsgHandler(DWORD dwMajorType);
        void STDMETHODCALLTYPE DoWork(void);

    protected:
        // Socket connection
        HRESULT Listen(void);

        // Data transmission
        HRESULT SendMessage(LPCDSRPACKETHEADER pPacketHeader, DWORD dwPacketBufferCount, LPCDSRBUFFER paPacketBuffers);
        HRESULT ReceiveMessage(LPDSRPACKETHEADER pPacketHeader, LPVOID *ppvPacketData);
        HRESULT DispatchMessage(LPCDSRPACKETHEADER pPacketHeader, LPVOID *ppvPacketData);

        // WinSock wrappers
        HRESULT send(LPCVOID pvData, DWORD dwSize);
        HRESULT recv(LPVOID pvData, DWORD dwSize, LPDWORD pdwReceived = NULL);

        // Stitched packets
        HRESULT CreateStitchedPacket(LPCDSRPACKETHEADER pPacketHeader, CStitchedPacket **ppPacket);

        // Handlers
        void OnConnect(const SOCKADDR_IN &sa);

    protected:
        // Socket creation
        static HRESULT CreateSocket(SOCKET *psock);
        static void CreateAddress(LPCSTR pszAddress, DWORD dwPort, SOCKADDR_IN *pAddr);
        static void CloseSocket(SOCKET *psock);

        // Socket connection
        static HRESULT CreateConnection(SOCKET *psock, LPCSTR pszHost, DWORD dwPort, SOCKADDR_IN *pAddr);
        static HRESULT AcceptConnection(SOCKET *psock, SOCKADDR_IN *pAddr);
        static BOOL GetSocketStatus(SOCKET sock, DWORD dwAccess, DWORD dwTimeout);

        // Xbox pseudo-DNS
        static HRESULT GetHostAddress(LPCSTR pszHost, LPSTR pszAddress);

        // Checksums
        static DWORD __fastcall CreateChecksum(LPCVOID pvBuffer, DWORD dwBufferSize);
    };

    __inline ULONG CRemoteConnection::AddRef(void)
    {
        return CRefCount::AddRef();
    }

    __inline ULONG CRemoteConnection::Release(void)
    {
        return CRefCount::Release();
    }

    __inline DWORD CRemoteConnection::GetState(void)
    {
        return m_dwState;
    }
}

#endif // __cplusplus

#endif // __IREMOTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\dsremi.h ===
/***************************************************************************
 *
 *  Copyright (C) 01/08/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsremi.h
 *  Content:    DirectSound remote API internal header.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/08/2002  dereks  Created.
 *
 ****************************************************************************/

#ifndef __DSREMI_H__
#define __DSREMI_H__

#ifndef _XBOX
#define USEDPF
#endif // _XBOX

#include "dscommon.h"
#ifndef _XBOX
#include <winsock2.h>
#endif // _XBOX
#include "xboxdbg.h"
#include "xboxverp.h"
#include "dsremote.h"
#include "ifileio.h"
#include "iremote.h"

#ifdef __cplusplus

static void GetLibraryVersion(LPSTR pszString)
{
    static const DWORD      dwMajor = (VER_PRODUCTVERSION_DW >> 24) & 0xFF;
    static const DWORD      dwMinor = (VER_PRODUCTVERSION_DW >> 16) & 0xFF;
    static const DWORD      dwBuild = VER_PRODUCTVERSION_DW & 0xFFFF;
    
    sprintf(pszString, "%lu.%lu.%lu", dwMajor, dwMinor, dwBuild);
}

#endif // __cplusplus

#endif // __DSREMI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\dsremote.h ===
/***************************************************************************
 *
 *  Copyright (C) 1/8/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsremote.h
 *  Content:    Remote DirectSound API main header.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/8/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __DSREMOTE_H__
#define __DSREMOTE_H__

#ifdef _XBOX
#include <xtl.h>
#else // _XBOX
#include <windows.h>
#include <objbase.h>
#endif // _XBOX

//
// Forward declarations
//

typedef struct IRemoteConnection IRemoteConnection;
typedef IRemoteConnection *LPREMOTECONNECTION;

typedef struct IRemoteFileIo IRemoteFileIo;
typedef IRemoteFileIo *LPREMOTEFILEIO;

//
// Packet data buffer
//

typedef struct _DSRBUFFER
{
    DWORD       dwSize;             // Buffer size, in bytes
    LPVOID      pvData;             // Buffer data
} DSRBUFFER, *LPDSRBUFFER;

typedef const DSRBUFFER *LPCDSRBUFFER;

//
// Packet header
//

typedef struct _DSRPACKET
{
    DWORD       dwMajorType;        // Packet major type
    DWORD       dwMinorType;        // Packet minor type
    DWORD       dwFlags;            // Packet flags
} DSRPACKET, *LPDSRPACKET;

typedef const DSRPACKET *LPCDSRPACKET;

//
// Reserved major/minor type identifiers
//

#define DSRTYPE_SYSTEM              'sysr'
#define DSRTYPE_FILEIO              'elif'

//
// Default port assignments
//

#define DSREMOTE_DEFAULT_PORT       1818

//
// IRemoteConnection::Connect flags
//

#define DSREMOTE_CONNECT_DNSLOOKUP  0x00000001      // The supplied address is an Xbox name, not an IP address

//
// IRemoteConnection::Disconnect flags
//

#define DSREMOTE_DISCONNECT_LISTEN  0x00000001      // The connection object will listen for a new connection

//
// Optimal packet size
//

#define DSREMOTE_OPTIMAL_PACKET_SIZE 1024

//
// IRemoteConnection::GetState connection states
//

#define DSREMOTE_STATE_IDLE         0
#define DSREMOTE_STATE_LISTENING    1
#define DSREMOTE_STATE_CONNECTED    2

//
// DSREMOTECALLBACK (pseudo-interface vector table)
//

typedef struct _DSREMOTECALLBACK
{
    void (STDMETHODCALLTYPE *Connect)(LPCSTR pszRemoteAddress, LPVOID pvContext);
    void (STDMETHODCALLTYPE *Disconnect)(LPVOID pvContext);
} DSREMOTECALLBACK, *LPDSREMOTECALLBACK;

typedef const DSREMOTECALLBACK *LPCDSREMOTECALLBACK;

//
// DSREMOTEMSGHANDLER (pseudo-interface vector table)
//

typedef struct _DSREMOTEMSGHANDLER
{
    BOOL (STDMETHODCALLTYPE *Receive)(LPCDSRPACKET pPacketHeader, LPCDSRBUFFER pPacketBuffer, LPDSRBUFFER pResponseBuffer, LPVOID pvContext);
} DSREMOTEMSGHANDLER, *LPDSREMOTEMSGHANDLER;

typedef const DSREMOTEMSGHANDLER *LPCDSREMOTEMSGHANDLER;

//
// IRemoteConnection
//

#undef INTERFACE
#define INTERFACE IRemoteConnection

DECLARE_INTERFACE(IRemoteConnection)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IRemoteConnection methods
    STDMETHOD(Connect)(THIS_ LPCSTR pszHost, DWORD dwFlags) PURE;
    STDMETHOD(Disconnect)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetState)(THIS) PURE;
    STDMETHOD(Send)(THIS_ LPCDSRPACKET pPacketHeader, DWORD dwPacketBufferCount, LPCDSRBUFFER paPacketBuffers, LPDSRBUFFER pResponseBuffer) PURE;
    STDMETHOD(RegisterMsgHandler)(THIS_ DWORD dwMajorType, LPCDSREMOTEMSGHANDLER pHandler, LPVOID pvContext) PURE;
    STDMETHOD(UnregisterMsgHandler)(THIS_ DWORD dwMajorType) PURE;
    STDMETHOD_(VOID, DoWork)(THIS) PURE;
};

//
// IRemoteFileIo
//

#undef INTERFACE
#define INTERFACE IRemoteFileIo

DECLARE_INTERFACE(IRemoteFileIo)
{
    // IUnknown methods
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IRemoteFileIo methods
    STDMETHOD(CreateFile)(THIS_ LPCSTR pszRemoteFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, LPHANDLE phRemoteFile) PURE;
    STDMETHOD(ReadFile)(THIS_ HANDLE hRemoteFile, LPVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwBytesRead) PURE;
    STDMETHOD(WriteFile)(THIS_ HANDLE hRemoteFile, LPCVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwBytesWritten) PURE;
    STDMETHOD(SetFilePointer)(THIS_ HANDLE hRemoteFile, LONG lDistanceToMove, DWORD dwMoveMethod, LPDWORD pdwAbsPosition) PURE;
    STDMETHOD(SetEndOfFile)(THIS_ HANDLE hRemoteFile) PURE;
    STDMETHOD(CloseHandle)(THIS_ HANDLE hRemoteFile) PURE;
    STDMETHOD(CopyFile)(THIS_ LPCSTR pszLocalFile, LPCSTR pszRemoteFile, BOOL fFailIfFileExists) PURE;
    STDMETHOD(DeleteFile)(THIS_ LPCSTR pszRemoteFile) PURE;
};

//
// API
//

STDAPI CreateRemoteConnection(DWORD dwPort, LPCDSREMOTECALLBACK pCallback, LPVOID pvContext, LPREMOTECONNECTION *ppConnection);
STDAPI CreateRemoteFileIo(LPREMOTECONNECTION pConnection, LPREMOTEFILEIO *ppFileIo);

#endif // __DSREMOTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\ifileio.h ===
/***************************************************************************
 *
 *  Copyright (C) 1/18/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ifileio.h
 *  Content:    IRemoteFileIo implementation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/18/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __IFILEIO_H__
#define __IFILEIO_H__

//
// Remote file I/O message types
//

enum
{
    DSRTYPE_FILEIO_CREATEFILE = 0,
    DSRTYPE_FILEIO_READFILE,
    DSRTYPE_FILEIO_WRITEFILE,
    DSRTYPE_FILEIO_SETFILEPOINTER,
    DSRTYPE_FILEIO_SETENDOFFILE,
    DSRTYPE_FILEIO_CLOSEHANDLE,
    DSRTYPE_FILEIO_DELETEFILE,
};

BEGIN_DEFINE_STRUCT()
    CHAR        szFileName[MAX_PATH];
    DWORD       dwDesiredAccess;
    DWORD       dwShareMode;
    DWORD       dwCreationDistribution;
    DWORD       dwFlagsAndAttributes;
END_DEFINE_STRUCT(DSRFILEIO_CREATEFILE_MSGDATA);

BEGIN_DEFINE_STRUCT()
    DWORD       dwError;
    HANDLE      hFile;
END_DEFINE_STRUCT(DSRFILEIO_CREATEFILE_RESPONSE);

BEGIN_DEFINE_STRUCT()
    HANDLE      hFile;
END_DEFINE_STRUCT(DSRFILEIO_READFILE_MSGDATA);

BEGIN_DEFINE_STRUCT()
    DWORD       dwError;
END_DEFINE_STRUCT(DSRFILEIO_READFILE_RESPONSE);

BEGIN_DEFINE_STRUCT()
    HANDLE      hFile;
END_DEFINE_STRUCT(DSRFILEIO_WRITEFILE_MSGDATA);

BEGIN_DEFINE_STRUCT()
    DWORD       dwError;
    DWORD       dwBytesWritten;
END_DEFINE_STRUCT(DSRFILEIO_WRITEFILE_RESPONSE);

BEGIN_DEFINE_STRUCT()
    HANDLE      hFile;
    LONG        lDistanceToMove;
    DWORD       dwMoveMethod;
END_DEFINE_STRUCT(DSRFILEIO_SETFILEPOINTER_MSGDATA);

BEGIN_DEFINE_STRUCT()
    DWORD       dwError;
    DWORD       dwAbsPosition;
END_DEFINE_STRUCT(DSRFILEIO_SETFILEPOINTER_RESPONSE);

BEGIN_DEFINE_STRUCT()
    HANDLE      hFile;
END_DEFINE_STRUCT(DSRFILEIO_SETENDOFFILE_MSGDATA);

BEGIN_DEFINE_STRUCT()
    DWORD       dwError;
END_DEFINE_STRUCT(DSRFILEIO_SETENDOFFILE_RESPONSE);

BEGIN_DEFINE_STRUCT()
    HANDLE      hFile;
END_DEFINE_STRUCT(DSRFILEIO_CLOSEHANDLE_MSGDATA);

BEGIN_DEFINE_STRUCT()
    DWORD       dwError;
END_DEFINE_STRUCT(DSRFILEIO_CLOSEHANDLE_RESPONSE);

BEGIN_DEFINE_STRUCT()
    CHAR        szFileName[MAX_PATH];
END_DEFINE_STRUCT(DSRFILEIO_DELETEFILE_MSGDATA);

BEGIN_DEFINE_STRUCT()
    DWORD       dwError;
END_DEFINE_STRUCT(DSRFILEIO_DELETEFILE_RESPONSE);

#ifdef __cplusplus

//
// IRemoteFileIo implementation
//

namespace DSREMOTE
{
    class CRemoteFileIo
        : public IRemoteFileIo, public CRefCount
    {
    protected:
        LPREMOTECONNECTION      m_pConnection;      // Remote connection object

    public:
        CRemoteFileIo(LPREMOTECONNECTION pConnection);
        virtual ~CRemoteFileIo(void);

    public:
        // IUnknown methods
        virtual ULONG STDMETHODCALLTYPE AddRef(void);
        virtual ULONG STDMETHODCALLTYPE Release(void);

        // IRemoteFileIo methods
        virtual HRESULT STDMETHODCALLTYPE CreateFile(LPCSTR pszRemoteFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, LPHANDLE phFile);
        virtual HRESULT STDMETHODCALLTYPE ReadFile(HANDLE hFile, LPVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwBytesRead);
        virtual HRESULT STDMETHODCALLTYPE WriteFile(HANDLE hFile, LPCVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwBytesWritten);
        virtual HRESULT STDMETHODCALLTYPE SetFilePointer(HANDLE hFile, LONG lDistanceToMove, DWORD dwMoveMethod, LPDWORD pdwAbsPosition);
        virtual HRESULT STDMETHODCALLTYPE SetEndOfFile(HANDLE hFile);
        virtual HRESULT STDMETHODCALLTYPE CloseHandle(HANDLE hFile);
        virtual HRESULT STDMETHODCALLTYPE CopyFile(LPCSTR pszLocalFile, LPCSTR pszRemoteFile, BOOL fFailIfFileExists);
        virtual HRESULT STDMETHODCALLTYPE DeleteFile(LPCSTR pszRemoteFile);
    };

    __inline ULONG CRemoteFileIo::AddRef(void)
    {
        return CRefCount::AddRef();
    }

    __inline ULONG CRemoteFileIo::Release(void)
    {
        return CRefCount::Release();
    }
}

//
// Remote file I/O message handler
//

namespace DSREMOTE
{
    class CRemoteFileIoHandler
    {
    public:
        enum
        {
            DSRTYPE = DSRTYPE_FILEIO
        };

    public:
        // Handler registration
        HRESULT Register(LPREMOTECONNECTION pConnection);

    protected:
        // Specific handler functions
        void CreateFile(LPCDSRBUFFER pPacket, LPDSRBUFFER pResponse);
        void ReadFile(LPCDSRBUFFER pPacket, LPDSRBUFFER pResponse);
        void WriteFile(LPCDSRBUFFER pPacket, LPDSRBUFFER pResponse);
        void SetFilePointer(LPCDSRBUFFER pPacket, LPDSRBUFFER pResponse);
        void SetEndOfFile(LPCDSRBUFFER pPacket, LPDSRBUFFER pResponse);
        void CloseHandle(LPCDSRBUFFER pPacket, LPDSRBUFFER pResponse);
        void DeleteFile(LPCDSRBUFFER pPacket, LPDSRBUFFER pResponse);

    protected:
        // Generic handler function
        static BOOL STDMETHODCALLTYPE Receive(LPCDSRPACKET pPacketHeader, LPCDSRBUFFER pPacketBuffer, LPDSRBUFFER pResponseBuffer, LPVOID pvContext);
    };    

    __inline HRESULT CRemoteFileIoHandler::Register(LPREMOTECONNECTION pConnection)
    {
        DSREMOTEMSGHANDLER      VTable;

        ZeroMemory(&VTable, sizeof(VTable));

        VTable.Receive = Receive;

        return pConnection->RegisterMsgHandler(DSRTYPE, &VTable, this);
    }
}

#endif // __cplusplus

#endif // __IFILEIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\iremote.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1/8/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iremote.cpp
 *  Content:    IRemote interface impelementation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/8/2002   dereks  Created.
 *
 ****************************************************************************/

#include "dsremi.h"

using namespace DSREMOTE;

#ifdef DEBUG

static HRESULT __WSATranslateError(DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszCalled)
{
    DWORD                   dwResult    = WSAGetLastError();
    HRESULT                 hr;

    CDebug::SetContext(DPF_FLAGS_DEFAULT, dwLevel, pszFile, nLine, pszFunction, DPF_LIBRARY);

    if(dwResult)
    {
        CDebug::Print("%s failed with error %lu", pszCalled, dwResult);
        hr = HRESULT_FROM_WIN32(dwResult);
    }
    else
    {
        CDebug::Print("%s failed with an unknown error", pszCalled);
        hr = E_FAIL;
    }

    return hr;
}

#define WSATranslateError(dwLevel, func) \
    __WSATranslateError(dwLevel, __FILE__, __LINE__, DPF_FNAME, #func)


static HRESULT __XBDMTranslateError(DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, HRESULT hr, LPCSTR pszCalled)
{
    if(XBDM_NOERR == hr)
    {
        hr = S_OK;
    }
    else
    {
        CDebug::SetContext(DPF_FLAGS_DEFAULT, dwLevel, pszFile, nLine, pszFunction, DPF_LIBRARY);

        if(FAILED(hr))
        {
            CDebug::Print("%s failed with error %lx", pszCalled, hr);
        }
        else
        {
            CDebug::Print("%s failed with an unknown error", hr);
            hr = E_FAIL;
        }
    }

    return hr;
}

#define XBDMTranslateError(dwLevel, result, func) \
    __XBDMTranslateError(dwLevel, __FILE__, __LINE__, DPF_FNAME, result, #func)

#else // DEBUG

static HRESULT __WSATranslateError(void)
{
    DWORD                   dwResult    = WSAGetLastError();
    HRESULT                 hr;

    if(dwResult)
    {
        hr = HRESULT_FROM_WIN32(dwResult);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

#define WSATranslateError(dwLevel, func) \
    __WSATranslateError()


static HRESULT __XBDMTranslateError(HRESULT hr)
{
    if(XBDM_NOERR == hr)
    {
        hr = S_OK;
    }
    else if(SUCCEEDED(hr))
    {
        hr = E_FAIL;
    }

    return hr;
}

#define XBDMTranslateError(dwLevel, result, func) \
    __XBDMTranslateError(result)

#endif // DEBUG


/****************************************************************************
 *
 *  CreateRemoteConnection
 *
 *  Description:
 *      Creates a remote transmission object.
 *
 *  Arguments:
 *      DWORD [in]: port assignment.
 *      LPCDSREMOTECALLBACK [in]: callback object.
 *      LPVOID [in]: callback context.
 *      LPREMOTECONNECTION * [out]: remote object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateRemoteConnection"

HRESULT
CreateRemoteConnection
(
    DWORD                   dwPort,
    LPCDSREMOTECALLBACK     pCallback,
    LPVOID                  pvContext,
    LPREMOTECONNECTION *    ppRemote
)
{
    CRemoteConnection *     pRemote;
    HRESULT                 hr;

    hr = HRFROMP(pRemote = NEW(CRemoteConnection));

    if(SUCCEEDED(hr))
    {
        hr = pRemote->Initialize(dwPort, pCallback, pvContext);
    }

    if(SUCCEEDED(hr))
    {
        *ppRemote = pRemote;
    }
    else
    {
        RELEASE(pRemote);
    }

    return hr;
}


/****************************************************************************
 *
 *  CRemoteConnection
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::CRemoteConnection"

CRemoteConnection::CRemoteConnection
(
    void
)
{
    m_socket = INVALID_SOCKET;
    m_dwState = DSREMOTE_STATE_IDLE;

    InitializeListHead(&m_lstHandlers);
    InitializeListHead(&m_lstStitched);
}


/****************************************************************************
 *
 *  ~CRemoteConnection
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::~CRemoteConnection"

CRemoteConnection::~CRemoteConnection
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    CStitchedPacket *       pStitchedPacket;

    Disconnect(0);

    WSACleanup();

#ifdef _XBOX

    XNetCleanup();

#endif // _XBOX

    while((pleEntry = m_lstStitched.Flink) != &m_lstStitched)
    {
        pStitchedPacket = CONTAINING_RECORD(pleEntry, CStitchedPacket, m_leStitched);

        MEMFREE(pStitchedPacket->m_pvPacketData);
        DELETE(pStitchedPacket);
    }
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: port assignment.
 *      LPCDSREMOTECALLBACK [in]: callback object.
 *      LPVOID [in]: callback context.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::Initialize"

HRESULT
CRemoteConnection::Initialize
(
    DWORD                   dwPort,
    LPCDSREMOTECALLBACK     pCallback,
    LPVOID                  pvContext
)
{
    HRESULT                 hr          = S_OK;
    DWORD                   dwResult;
    WSADATA                 wsadata;
    SOCKADDR_IN             sa;
    
    //
    // Save data members
    //

    m_dwPort = dwPort;
    
    m_StatusCallback.Initialize(pCallback, pvContext);

    //
    // Initialize the network
    //

#ifdef _XBOX

    XNetStartupParams xnsp;

    ZeroMemory(&xnsp, sizeof(xnsp));

    xnsp.cfgSizeOfStruct = sizeof(xnsp);
    xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY | XNET_STARTUP_BYPASS_ENCRYPTION;
    
    if(dwResult = XNetStartup(&xnsp))
    {
        DPF_ERROR("XNetStartup failed with %lu", dwResult);
        hr = HRESULT_FROM_WIN32(dwResult);
    }

#endif // _XBOX

    if(SUCCEEDED(hr))
    {
        if(dwResult = WSAStartup(MAKEWORD(2, 2), &wsadata))
        {
            DPF_ERROR("WSAStartup failed with %lu", dwResult);
            hr = HRESULT_FROM_WIN32(dwResult);
        }
    }

    //
    // Register default handlers
    //

    if(SUCCEEDED(hr))
    {
        hr = m_FileIoHandler.Register(this);
    }

    //
    // Listen for a connection
    //

    if(SUCCEEDED(hr))
    {
        hr = Listen();
    }

    return hr;
}


/****************************************************************************
 *
 *  Listen
 *
 *  Description:
 *      Listens for a connection.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::Listen"

HRESULT
CRemoteConnection::Listen
(
    void
)
{
    SOCKADDR_IN             sa;
    HRESULT                 hr;

    if(DSREMOTE_STATE_LISTENING != m_dwState)
    {
        //
        // If we're connected, disconnect
        //
        
        if(DSREMOTE_STATE_CONNECTED == m_dwState)
        {
            DPF_WARNING("Already connected");
            Disconnect(0);
        }

        //
        // Create the socket
        //

        hr = CreateSocket(&m_socket);

        //
        // Bind the socket to the local address
        //

        if(SUCCEEDED(hr))
        {
            CreateAddress(NULL, m_dwPort, &sa);

            if(bind(m_socket, (const sockaddr *)&sa, sizeof(sa)))
            {
                hr = WSATranslateError(DPFLVL_ERROR, bind);
            }
        }

        //
        // Listen for a connection
        //

        if(SUCCEEDED(hr))
        {
            if(listen(m_socket, SOMAXCONN))
            {
                hr = WSATranslateError(DPFLVL_ERROR, listen);
            }
        }        

        if(SUCCEEDED(hr))
        {
            DPF_INFO("Listening for connection on port %lu", m_dwPort);

            m_dwState = DSREMOTE_STATE_LISTENING;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateAddress
 *
 *  Description:
 *      Creates an IP address.
 *
 *  Arguments:
 *      LPCSTR [in]: host address.
 *      DWORD [in]: port number.
 *      SOCKADDR_IN * [out]: address.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::CreateAddress"

void 
CRemoteConnection::CreateAddress
(
    LPCSTR                  pszAddress, 
    DWORD                   dwPort, 
    SOCKADDR_IN *           pAddr
)
{
    pAddr->sin_family = AF_INET;
    pAddr->sin_addr.s_addr = pszAddress ? inet_addr(pszAddress) : INADDR_ANY;
    pAddr->sin_port = htons((USHORT)dwPort);
}


/****************************************************************************
 *
 *  CreateSocket
 *
 *  Description:
 *      Creates a local socket.
 *
 *  Arguments:
 *      SOCKET * [out]: socket.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::CreateSocket"

HRESULT
CRemoteConnection::CreateSocket
(
    SOCKET *                psock
)
{
    HRESULT                 hr          = S_OK;
    SOCKET                  sock;
    
    if(INVALID_SOCKET == (sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)))
    {
        hr = WSATranslateError(DPFLVL_ERROR, socket);
    }

    if(SUCCEEDED(hr))
    {
        *psock = sock;
    }

    return hr;
}


/****************************************************************************
 *
 *  Connect
 *
 *  Description:
 *      Connects to a remote session or listens for one.
 *
 *  Arguments:
 *      LPCSTR [in]: host address or NULL to listen for a connection.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::Connect"

HRESULT
CRemoteConnection::Connect
(
    LPCSTR                  pszHost,
    DWORD                   dwFlags
)
{
    HRESULT                 hr              = S_OK;
    CHAR                    szHost[0x100];
    SOCKADDR_IN             sa;

    //
    // If we're already connected, disconnect
    //

    if(DSREMOTE_STATE_CONNECTED == m_dwState)
    {
        DPF_WARNING("Already connected");
        Disconnect(0);
    }

    //
    // If the DNSLOOKUP flag was specified, the host name is an Xbox name,
    // not an address.  We'll do the conversion for them.
    //
    // If the DNSLOOKUP flag was specified, but no host was, the caller wants
    // to connect to the default Xbox.
    //
    // If the host name is NULL *and* DNSLOOKUP wasn't specified, the caller
    // wants to block until someone else connects to this session.
    //

    if(dwFlags & DSREMOTE_CONNECT_DNSLOOKUP)
    {
        hr = GetHostAddress(pszHost, szHost);

        if(SUCCEEDED(hr))
        {
            pszHost = szHost;
        }
    }

    //
    // Connect to the remote host
    //

    if(pszHost)
    {
        hr = CreateConnection(&m_socket, pszHost, m_dwPort, &sa);
    }
    else
    {
        hr = AcceptConnection(&m_socket, &sa);
    }

    //
    // Call the callback
    //

    if(SUCCEEDED(hr))
    {
        OnConnect(sa);
    }

    return hr;
}


/****************************************************************************
 *
 *  GetHostAddress
 *
 *  Description:
 *      Looks up an Xbox's address.
 *
 *  Arguments:
 *      LPCSTR [in]: host name.
 *      LPSTR [out]: host address.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::GetHostAddress"

HRESULT
CRemoteConnection::GetHostAddress
(
    LPCSTR                  pszHost,
    LPSTR                   pszAddress
)
{

#ifdef _XBOX

    DPF_ERROR("DNSLOOKUP is not supported by the Xbox version of this library");
    
    return E_INVALIDARG;

#else // _XBOX

    HRESULT                 hr              = S_OK;
    CHAR                    szHost[0x100];
    DWORD                   dwSize;
    DWORD                   dwAddress;

    if(!pszHost)
    {
        dwSize = NUMELMS(szHost);
        
        hr = XBDMTranslateError(DPFLVL_ERROR, DmGetXboxName(szHost, &dwSize), DmGetXboxName);

        if(SUCCEEDED(hr))
        {
            pszHost = szHost;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = XBDMTranslateError(DPFLVL_ERROR, DmSetXboxNameNoRegister(pszHost), XBDMTranslateError);
    }

    if(SUCCEEDED(hr))
    {
        hr = XBDMTranslateError(DPFLVL_ERROR, DmGetAltAddress(&dwAddress), DmGetAltAddress);
    }

    if(SUCCEEDED(hr))
    {
        sprintf(pszAddress, "%lu.%lu.%lu.%lu", ((LPBYTE)&dwAddress)[3], ((LPBYTE)&dwAddress)[2], ((LPBYTE)&dwAddress)[1], ((LPBYTE)&dwAddress)[0]);
    }

    return hr;

#endif // _XBOX

}


/****************************************************************************
 *
 *  CreateConnection
 *
 *  Description:
 *      Connects to a remote session or listens for one.
 *
 *  Arguments:
 *      SOCKET * [in/out]: socket.
 *      LPCSTR [in]: host address.
 *      DWORD [in]: host port.
 *      SOCKADDR_IN * [out]: host address.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::CreateConnection"

HRESULT
CRemoteConnection::CreateConnection
(
    SOCKET *                pSocket,
    LPCSTR                  pszHost,
    DWORD                   dwPort,
    SOCKADDR_IN *           pAddr
)
{
    SOCKET                  sock;
    SOCKADDR_IN             sa;
    HRESULT                 hr;

    CreateAddress(pszHost, dwPort, &sa);

    //
    // Create the new socket
    //

    hr = CreateSocket(&sock);

    //
    // Make the remote connection
    //

    if(SUCCEEDED(hr))
    {
        DPF_INFO("Attempting connection to %lu.%lu.%lu.%lu:%lu on socket %x", sa.sin_addr.S_un.S_un_b.s_b1, sa.sin_addr.S_un.S_un_b.s_b2, sa.sin_addr.S_un.S_un_b.s_b3, sa.sin_addr.S_un.S_un_b.s_b4, dwPort, sock);

        if(connect(sock, (const sockaddr *)&sa, sizeof(sa)))
        {
            hr = WSATranslateError(DPFLVL_WARNING, connect);
        }
    }

    //
    // Close supplied socket and return the new one
    //

    if(SUCCEEDED(hr))
    {
        CloseSocket(pSocket);

        *pSocket = sock;
    }

    //
    // Return the address
    //

    if(SUCCEEDED(hr) && pAddr)
    {
        *pAddr = sa;
    }

    return hr;
}


/****************************************************************************
 *
 *  AcceptConnection
 *
 *  Description:
 *      Accepts an incoming connection.
 *
 *  Arguments:
 *      SOCKET * [in/out]: socket.  The socket is assumed to be in a listen
 *                         state on entry.  If a connection is made, the
 *                         orginal socket will be closed and a new one 
 *                         returned.
 *      SOCKADDR_IN [out]: address of the connected entity.
 *      
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::AcceptConnection"

HRESULT
CRemoteConnection::AcceptConnection
(
    SOCKET *                pSocket,
    SOCKADDR_IN *           pAddr
)
{
    int                     nSize   = sizeof(*pAddr);
    HRESULT                 hr      = S_OK;
    SOCKET                  sock;

    //
    // Wait for the connection
    //

    if(INVALID_SOCKET == (sock = accept(*pSocket, (sockaddr *)pAddr, pAddr ? &nSize : NULL)))
    {
        hr = WSATranslateError(DPFLVL_WARNING, accept);
    }

    //
    // Close the listen socket and return the new one
    //

    if(SUCCEEDED(hr))
    {
        CloseSocket(pSocket);

        *pSocket = sock;
    }

    return hr;
}


/****************************************************************************
 *
 *  GetSocketStatus
 *
 *  Description:
 *      Checks a socket for pending read or write data.
 *
 *  Arguments:
 *      SOCKET  [in]: socket.
 *      DWORD [in]: access flags (GENERIC_READ | GENERIC_WRITE).
 *      DWORD [in]: timeout, in ms.
 *
 *  Returns:  
 *      BOOL: TRUE if the socket is ready.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::GetSocketStatus"

BOOL
CRemoteConnection::GetSocketStatus
(
    SOCKET                  sock,
    DWORD                   dwAccess,
    DWORD                   dwTimeout
)
{
    TIMEVAL                 timeval;
    fd_set                  fdsRead;
    fd_set                  fdsWrite;
    DWORD                   dwResult;
    BOOL                    fReady;

    ASSERT(dwAccess & (GENERIC_READ | GENERIC_WRITE));

    timeval.tv_sec = 0;
    timeval.tv_usec = dwTimeout;

    FD_ZERO(&fdsRead);
    FD_ZERO(&fdsWrite);

    if(dwAccess & GENERIC_READ)
    {
        FD_SET(sock, &fdsRead);
    }

    if(dwAccess & GENERIC_WRITE)
    {
        FD_SET(sock, &fdsWrite);
    }

    dwResult = select(0, &fdsRead, &fdsWrite, NULL, (INFINITE == dwTimeout) ? NULL : &timeval);

    switch(dwResult)
    {
        case 1:
        case 2:
            fReady = TRUE;
            break;

        case SOCKET_ERROR:
        case 0:
            fReady = FALSE;
            break;

        default:
            ASSERTMSG("Unexpected result from select");
            fReady = FALSE;
            break;
    }

    return fReady;
}


/****************************************************************************
 *
 *  DoWork
 *
 *  Description:
 *      Worker function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::DoWork"

void
CRemoteConnection::DoWork
(
    void
)
{
    LPVOID                  pvPacketData;
    DSRPACKETHEADER         PacketHeader;
    SOCKADDR_IN             sa;
    HRESULT                 hr;

    if(INVALID_SOCKET != m_socket)
    {
        //
        // Check for pending read data
        //

        if(GetSocketStatus(m_socket, GENERIC_READ, 0))
        {
            if(DSREMOTE_STATE_LISTENING == m_dwState)
            {
                //
                // Accept an incoming connection
                //

                hr = AcceptConnection(&m_socket, &sa);
                
                if(SUCCEEDED(hr))
                {
                    OnConnect(sa);
                }
            }
            else if(DSREMOTE_STATE_CONNECTED == m_dwState)
            {
                //
                // Receive and dispatch the next message
                //

                hr = ReceiveMessage(&PacketHeader, &pvPacketData);

                if(SUCCEEDED(hr) && pvPacketData)
                {
                    DispatchMessage(&PacketHeader, &pvPacketData);
                }
            }
        }
    }
}
        

/****************************************************************************
 *
 *  OnConnect
 *
 *  Description:
 *      Called when a connection is made.
 *
 *  Arguments:
 *      const SOCKADDR_IN & [in]: connection address.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::OnConnect"

void
CRemoteConnection::OnConnect
(
    const SOCKADDR_IN &     sa
)
{
    CHAR                    szAddress[0x100];

    //
    // Flag the object as connected
    //

    m_dwState = DSREMOTE_STATE_CONNECTED;

    //
    // Call the callback
    //

    sprintf(szAddress, "%lu.%lu.%lu.%lu", sa.sin_addr.S_un.S_un_b.s_b1, sa.sin_addr.S_un.S_un_b.s_b2, sa.sin_addr.S_un.S_un_b.s_b3, sa.sin_addr.S_un.S_un_b.s_b4);

    DPF_INFO("Connected to %s", szAddress);

    m_StatusCallback.Connect(szAddress);
}


/****************************************************************************
 *
 *  Disconnect
 *
 *  Description:
 *      Disconnects a connected socket.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::Disconnect"

HRESULT
CRemoteConnection::Disconnect
(
    DWORD                   dwFlags
)
{
    HRESULT                 hr  = S_OK;
    
    if(DSREMOTE_STATE_IDLE != m_dwState)
    {
        CloseSocket(&m_socket);

        m_dwState = DSREMOTE_STATE_IDLE;

        DPF_INFO("Disconnected");

        m_StatusCallback.Disconnect();
    }

    if(dwFlags & DSREMOTE_DISCONNECT_LISTEN)
    {
        hr = Listen();
    }

    return hr;
}


/****************************************************************************
 *
 *  CloseSocket
 *
 *  Description:
 *      Closes an open socket.
 *
 *  Arguments:
 *      SOCKET * [in/out]: socket.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::CloseSocket"

void 
CRemoteConnection::CloseSocket
(
    SOCKET *                psock
)
{
    ASSERT(psock);

    if(INVALID_SOCKET != *psock)
    {
        shutdown(*psock, SD_BOTH);
        closesocket(*psock);

        *psock = INVALID_SOCKET;
    }
}


/****************************************************************************
 *
 *  RegisterMsgHandler
 *
 *  Description:
 *      Registers a message handler.
 *
 *  Arguments:
 *      DWORD [in]: message major type.
 *      LPCDSREMOTEMSGHANDLER [in]: handler object.
 *      LPVOID [in]: handler context.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::RegisterMsgHandler"

HRESULT
CRemoteConnection::RegisterMsgHandler
(
    DWORD                   dwMajorType,
    LPCDSREMOTEMSGHANDLER   pCallback,
    LPVOID                  pvContext
)
{
    HRESULT                 hr          = S_OK;
    CRemoteMsgHandler *     pHandler;
    LIST_ENTRY *            pleEntry;

    for(pleEntry = m_lstHandlers.Flink; (pleEntry != &m_lstHandlers) && SUCCEEDED(hr); pleEntry = pleEntry->Flink)
    {
        pHandler = CONTAINING_RECORD(pleEntry, CRemoteMsgHandler, m_leHandlers);

        if(dwMajorType == pHandler->m_dwMajorType)
        {
            DPF_ERROR("Type %lu already registered", dwMajorType);
            hr = E_INVALIDARG;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(pHandler = NEW(CRemoteMsgHandler));
    }

    if(SUCCEEDED(hr))
    {
        pHandler->Initialize(dwMajorType, pCallback, pvContext);
    }

    if(SUCCEEDED(hr))
    {
        InsertTailList(&m_lstHandlers, &pHandler->m_leHandlers);
    }

    return hr;
}


/****************************************************************************
 *
 *  UnregisterMsgHandler
 *
 *  Description:
 *      Unregisters a message handler.
 *
 *  Arguments:
 *      DWORD [in]: message major type.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::UnregisterMsgHandler"

HRESULT
CRemoteConnection::UnregisterMsgHandler
(
    DWORD                   dwMajorType
)
{
    HRESULT                 hr          = E_INVALIDARG;
    CRemoteMsgHandler *     pHandler;
    LIST_ENTRY *            pleEntry;

    for(pleEntry = m_lstHandlers.Flink; pleEntry != &m_lstHandlers; pleEntry = pleEntry->Flink)
    {
        pHandler = CONTAINING_RECORD(pleEntry, CRemoteMsgHandler, m_leHandlers);

        if(dwMajorType == pHandler->m_dwMajorType)
        {
            RemoveEntryList(pleEntry);

            DELETE(pHandler);

            hr = S_OK;
            
            break;
        }
    }

    if(FAILED(hr))
    {
        DPF_ERROR("Handler not registered");
    }

    return hr;
}


/****************************************************************************
 *
 *  Send
 *
 *  Description:
 *      Transmits data across the connection.
 *
 *  Arguments:
 *      LPCDSRPACKET [in]: packet header.
 *      DWORD [in]: packet data buffer count.
 *      LPCDSRBUFFER [in]: packet data buffers.
 *      LPDSRBUFFER [in/out]: response data buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::Send"

HRESULT
CRemoteConnection::Send
(
    LPCDSRPACKET            pPacketHeader, 
    DWORD                   dwPacketBufferCount, 
    LPCDSRBUFFER            paPacketBuffers, 
    LPDSRBUFFER             pResponseBuffer
)
{
    HRESULT                 hr              = S_OK;
    DSRPACKETHEADER         PacketHeader;
    DSRPACKETHEADER         ResponseHeader;
    LPVOID                  pvResponseData;
    DWORD                   dwSent;
    BOOL                    fDispatch;

    if(!pPacketHeader)
    {
        DPF_ERROR("No packet descriptor supplied");
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr) && HIWORD(pPacketHeader->dwFlags))
    {
        DPF_ERROR("The high word of the packet flags is reserved for internal use");
        hr = E_INVALIDARG;
    }
    
    if(SUCCEEDED(hr))
    {
        if(dwPacketBufferCount && !paPacketBuffers)
        {
            DPF_ERROR("Buffer count is non-zero, but paPacketBuffers is NULL");
            hr = E_INVALIDARG;
        }
        else if(!dwPacketBufferCount && paPacketBuffers)
        {
            DPF_ERROR("Buffer count is zero, but paPacketBuffers is non-NULL");
            hr = E_INVALIDARG;
        }
    }

    if(SUCCEEDED(hr) && pResponseBuffer)
    {
        if(pResponseBuffer->pvData && !pResponseBuffer->dwSize)
        {
            DPF_ERROR("Valid response buffer supplied, but dwSize is 0");
            hr = E_INVALIDARG;
        }
        else if(!pResponseBuffer->pvData && pResponseBuffer->dwSize)
        {
            DPF_ERROR("No response buffer supplied, but dwSize is non-zero");
            hr = E_INVALIDARG;
        }
    }

    if(SUCCEEDED(hr) && (DSREMOTE_STATE_CONNECTED != m_dwState))
    {
        DPF_ERROR("Not connected");
        hr = E_FAIL;
    }

    //
    // Send the data.  If an empty response structure was supplied, the caller
    // just wants to make sure the message was handled, but doesn't care what
    // data the handler wants to send back.
    //
    // Note that dwSize, dwChecksum, dwStitchSize and dwStitchOffset are filled
    // in by SendMessage.
    //

    if(SUCCEEDED(hr))
    {
        PacketHeader.dwSignature = DSREMOTE_PACKET_SIGNATURE;
        PacketHeader.dwSequence = m_dwSequence++;
        PacketHeader.dwMajorType = pPacketHeader->dwMajorType;
        PacketHeader.dwMinorType = pPacketHeader->dwMinorType;
        PacketHeader.dwFlags = pPacketHeader->dwFlags;

        if(pResponseBuffer)
        {
            PacketHeader.dwFlags |= DSRPACKETF_ACKREQ;
            PacketHeader.dwResponseSize = pResponseBuffer->dwSize;
        }
        else
        {
            PacketHeader.dwResponseSize = 0;
        }

        hr = SendMessage(&PacketHeader, dwPacketBufferCount, paPacketBuffers);
    }

    //
    // Wait for the response packet
    //

    if(SUCCEEDED(hr) && pResponseBuffer)
    {
        while(SUCCEEDED(hr))
        {
            hr = ReceiveMessage(&ResponseHeader, &pvResponseData);

            if(SUCCEEDED(hr))
            {
                if((ResponseHeader.dwSequence == PacketHeader.dwSequence) && (ResponseHeader.dwFlags & DSRPACKETF_ACK))
                {
                    ASSERT(ResponseHeader.dwMajorType == PacketHeader.dwMajorType);
                    ASSERT(ResponseHeader.dwMinorType == PacketHeader.dwMinorType);
                    ASSERT(ResponseHeader.dwSize <= PacketHeader.dwResponseSize);
                    ASSERT(!ResponseHeader.dwResponseSize);

                    if(pResponseBuffer->dwSize = min(PacketHeader.dwResponseSize, ResponseHeader.dwSize))
                    {
                        ASSERT(pvResponseData);

                        CopyMemory(pResponseBuffer->pvData, pvResponseData, pResponseBuffer->dwSize);
                    }

                    MEMFREE(pvResponseData);

                    break;
                }
                else if(pvResponseData)
                {
                    hr = DispatchMessage(&ResponseHeader, &pvResponseData);
                }
            }
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  SendMessage
 *
 *  Description:
 *      Transmits data across the connection.
 *
 *  Arguments:
 *      LPCDSRPACKETHEADER [in]: packet header.
 *      DWORD [in]: packet data buffer count.
 *      LPCDSRBUFFER [in]: packet data buffers.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::SendMessage"

HRESULT
CRemoteConnection::SendMessage
(
    LPCDSRPACKETHEADER      pPacketHeader,
    DWORD                   dwBufferCount,
    LPCDSRBUFFER            paBuffers
)
{
    LPDSRPACKETHEADER       pBuffer;
    DWORD                   dwTotalPacketSize;
    DWORD                   dwBufferSize;
    DWORD                   dwPacketDataSize;
    DWORD                   dwPacketCount;
    DWORD                   dwBufferIndex;
    DWORD                   dwSrcOffset;
    DWORD                   dwDstOffset;
    DWORD                   dwCopy;
    DWORD                   dwSent;
    HRESULT                 hr;
    DWORD                   i;

    ASSERT(DSREMOTE_STATE_CONNECTED == m_dwState);

    //
    // Determine the total outgoing message size
    //

    for(i = 0, dwTotalPacketSize = 0; i < dwBufferCount; i++)
    {
        dwTotalPacketSize += paBuffers[i].dwSize;
    }

    //
    // Coalesce the data into a single buffer.  If the message size exceeds
    // the maximum, send the message as multiple packets.
    //

    if(dwTotalPacketSize > DSREMOTE_OPTIMAL_PACKET_SIZE)
    {
        dwPacketDataSize = DSREMOTE_OPTIMAL_PACKET_SIZE;
    }
    else
    {
        dwPacketDataSize = dwTotalPacketSize;
    }

    dwPacketCount = (dwTotalPacketSize + dwPacketDataSize - 1) / dwPacketDataSize;
    dwBufferSize = dwPacketDataSize + sizeof(*pPacketHeader);
    
    hr = HRFROMP(pBuffer = (LPDSRPACKETHEADER)MEMALLOC_NOINIT(BYTE, dwBufferSize));

    if(SUCCEEDED(hr))
    {
        *pBuffer = *pPacketHeader;

        pBuffer->dwSize = dwTotalPacketSize;
        pBuffer->dwStitchOffset = 0;
        pBuffer->dwStitchSize = dwPacketDataSize;
    }
        
    //
    // Send the data out over the wire
    //

    for(i = 0, dwBufferIndex = 0, dwSrcOffset = 0; (i < dwPacketCount) && SUCCEEDED(hr); i++)
    {
        //
        // If this is the last packet, fix the size
        //
        
        if(i + 1 == dwPacketCount)
        {
            pBuffer->dwStitchSize = dwTotalPacketSize - (dwPacketDataSize * (dwPacketCount - 1));
        }
        
        //
        // Copy the packet data into the outgoing buffer
        //
        
        dwDstOffset = 0;
        
        while(dwDstOffset < pBuffer->dwStitchSize)
        {
            if(dwSrcOffset >= paBuffers[dwBufferIndex].dwSize)
            {
                dwBufferIndex++;
                dwSrcOffset = 0;
            }

            dwCopy = min(pBuffer->dwStitchSize - dwDstOffset, paBuffers[dwBufferIndex].dwSize - dwSrcOffset);
            
            CopyMemory((LPBYTE)(pBuffer + 1) + dwDstOffset, (LPBYTE)paBuffers[dwBufferIndex].pvData + dwSrcOffset, dwCopy);

            dwSrcOffset += dwCopy;
            dwDstOffset += dwCopy;
        }

        //
        // Create a checksum
        //

        pBuffer->dwChecksum = CreateChecksum(pBuffer + 1, pBuffer->dwStitchSize);

        //
        // Transmit the data
        //

        DPF_INFO("Sending %lu bytes (stitch offset %lu)", pBuffer->dwStitchSize, pBuffer->dwStitchOffset);

        hr = send(pBuffer, sizeof(*pBuffer) + pBuffer->dwStitchSize);

        //
        // Increment the stitch offset
        //

        pBuffer->dwStitchOffset += pBuffer->dwStitchSize;
    }

    //
    // Clean up
    //

    MEMFREE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  ReceiveMessage
 *
 *  Description:
 *      Receives data across a connection.
 *
 *  Arguments:
 *      LPDSRPACKETHEADER [out]: packet header.
 *      LPVOID * [out]: packet data.  The caller is responsible for freeing
 *                      this buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::ReceiveMessage"

HRESULT
CRemoteConnection::ReceiveMessage
(
    LPDSRPACKETHEADER       pPacketHeader,
    LPVOID *                ppvPacketData
)
{
    LPVOID                  pvPacketData    = NULL;
    LPVOID                  pvResponseData  = NULL;
    CStitchedPacket *       pStitchedPacket = NULL;
    HRESULT                 hr              = S_OK;
    PLIST_ENTRY             pleEntry;
    CRemoteMsgHandler *     pHandler;
    BOOL                    fResponse;
    BOOL                    fComplete;
    DWORD                   dwChecksum;

    ASSERT(DSREMOTE_STATE_CONNECTED == m_dwState);

    //
    // Receive just the packet header.
    //
    // We actually expect to get an error here.  Most of the time, there
    // should be more data following the packet, so we should get WSAEMSGSIZE
    //

    hr = recv(&pPacketHeader->dwSignature, sizeof(pPacketHeader->dwSignature));

    if(SUCCEEDED(hr) && (DSREMOTE_PACKET_SIGNATURE != pPacketHeader->dwSignature))
    {
        DPF_WARNING("Invalid packet signature");
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        hr = recv((LPBYTE)pPacketHeader + sizeof(pPacketHeader->dwSignature), sizeof(*pPacketHeader) - sizeof(pPacketHeader->dwSignature));
    }
        
    //
    // If any data follows the packet header, receive it now
    //

    if(SUCCEEDED(hr) && pPacketHeader->dwSize)
    {
        //
        // Get the receive buffer, either from the stitched packet object or
        // by allocating one.
        //
        
        if(pPacketHeader->dwStitchSize < pPacketHeader->dwSize)
        {
            hr = CreateStitchedPacket(pPacketHeader, &pStitchedPacket);

            if(SUCCEEDED(hr))
            {
                pvPacketData = pStitchedPacket->m_pvPacketData;
            }
        }
        else
        {
            ASSERT(pPacketHeader->dwStitchSize == pPacketHeader->dwSize);

            hr = HRFROMP(pvPacketData = MEMALLOC_NOINIT(BYTE, pPacketHeader->dwSize));
        }

        //
        // Receive the packet data
        //

        if(SUCCEEDED(hr))
        {
            ASSERT(pPacketHeader->dwStitchOffset + pPacketHeader->dwStitchSize <= pPacketHeader->dwSize);
            ASSERT(pPacketHeader->dwStitchSize);

            hr = recv((LPBYTE)pvPacketData + pPacketHeader->dwStitchOffset, pPacketHeader->dwStitchSize);
        }

        //
        // Check the checksum
        //

        if(SUCCEEDED(hr))
        {
            dwChecksum = CreateChecksum((LPBYTE)pvPacketData + pPacketHeader->dwStitchOffset, pPacketHeader->dwStitchSize);

            if(dwChecksum != pPacketHeader->dwChecksum)
            {
                DPF_ERROR("Checksum error");
                hr = E_FAIL;
            }
        }

        //
        // Increment the amount of data we've received.  If we've received
        // all of it, we can return the data to the caller and free the
        // stitched packet object.  If not, return NULL to the calling 
        // function.
        //

        if(SUCCEEDED(hr))
        {
            DPF_INFO("Received %lu bytes (stitch offset %lu)", pPacketHeader->dwStitchSize, pPacketHeader->dwStitchOffset);

            if(pStitchedPacket)
            {
                ASSERT(pStitchedPacket->m_dwReceived + pPacketHeader->dwStitchSize <= pPacketHeader->dwSize);
            
                pStitchedPacket->m_dwReceived += pPacketHeader->dwStitchSize;

                if(fComplete = (pStitchedPacket->m_dwReceived >= pPacketHeader->dwSize))
                {
                    DELETE(pStitchedPacket);
                }
                else
                {
                    pvPacketData = NULL;
                }
            }
            else
            {
                fComplete = TRUE;
            }
        }
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppvPacketData = pvPacketData;
    }
    else
    {
        MEMFREE(pvPacketData);
    }

    return hr;
}


/****************************************************************************
 *
 *  DispatchMessage
 *
 *  Description:
 *      Dispatches a message to the appropriate handler.
 *
 *  Arguments:
 *      LPCDSRPACKETHEADER [in]: packet header.
 *      LPVOID * [in/out]: packet data.  This buffer will be freed during
 *                         this call.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::DispatchMessage"

HRESULT
CRemoteConnection::DispatchMessage
(
    LPCDSRPACKETHEADER      pPacketHeader, 
    LPVOID *                ppvPacketData
)
{
    HRESULT                 hr              = S_OK;
    PLIST_ENTRY             pleEntry;
    CRemoteMsgHandler *     pHandler;
    DSRPACKET               Packet;
    DSRBUFFER               PacketBuffer;
    DSRBUFFER               Response;
    DSRPACKETHEADER         ResponseHeader;

    ASSERT(!(pPacketHeader->dwFlags & DSRPACKETF_ACK));
    ASSERT(ppvPacketData && *ppvPacketData);

    //
    // Set up the external version of the packet header
    //

    Packet.dwMajorType = pPacketHeader->dwMajorType;
    Packet.dwMinorType = pPacketHeader->dwMinorType;
    Packet.dwFlags = LOWORD(pPacketHeader->dwFlags);

    PacketBuffer.dwSize = pPacketHeader->dwSize;
    PacketBuffer.pvData = *ppvPacketData;

    //
    // Set up and allocate the response data
    //

    if((pPacketHeader->dwFlags & DSRPACKETF_ACKREQ) && pPacketHeader->dwResponseSize)
    {
        Response.dwSize = pPacketHeader->dwResponseSize;

        hr = HRFROMP(Response.pvData = MEMALLOC_NOINIT(BYTE, Response.dwSize));
    }
    else
    {
        Response.dwSize = 0;
        Response.pvData = NULL;
    }

    //
    // Find the correct handler function
    //

    if(SUCCEEDED(hr))
    {
        for(pleEntry = m_lstHandlers.Flink; pleEntry != &m_lstHandlers; pleEntry = pleEntry->Flink)
        {
            pHandler = CONTAINING_RECORD(pleEntry, CRemoteMsgHandler, m_leHandlers);

            if(pPacketHeader->dwMajorType == pHandler->m_dwMajorType)
            {
                break;
            }
        }

        if(pleEntry == &m_lstHandlers)
        {
            DPF_ERROR("No handler found for major type %lu", pPacketHeader->dwMajorType);
            hr = E_FAIL;
        }
    }

    //
    // Call the handler
    //

    if(SUCCEEDED(hr))
    {
        if(!pHandler->Receive(&Packet, &PacketBuffer, &Response))
        {
            Response.dwSize = 0;
        }
    }

    //
    // Regardless of whether the message was handled or not, we'll send an ack
    // back to the caller.  If the message was handled and response data was
    // supplied, we'll include that with the ack packet.
    //

    if(SUCCEEDED(hr) && (pPacketHeader->dwFlags & DSRPACKETF_ACKREQ))
    {
        ResponseHeader = *pPacketHeader;

        ResponseHeader.dwFlags |= DSRPACKETF_ACK;
        ResponseHeader.dwSize = Response.dwSize;
        ResponseHeader.dwResponseSize = 0;
        
        hr = SendMessage(&ResponseHeader, 1, &Response);
    }

    //
    // Clean up
    //

    MEMFREE(Response.pvData);
    MEMFREE(*ppvPacketData);

    return hr;
}


/****************************************************************************
 *
 *  send
 *
 *  Description:
 *      Wrapper around WinSock's send function.
 *
 *  Arguments:
 *      LPCVOID [in]: data.
 *      DWORD [in]: size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::send"

HRESULT
CRemoteConnection::send
(
    LPCVOID                 pvBuffer,
    DWORD                   dwBufferSize
)
{
    HRESULT                 hr      = S_OK;
    DWORD                   dwSent;

    ASSERT(DSREMOTE_STATE_CONNECTED == m_dwState);

    if((dwSent = ::send(m_socket, (const char *)pvBuffer, dwBufferSize, 0)) != dwBufferSize)
    {
        if(SOCKET_ERROR == dwSent)
        {
            hr = WSATranslateError(DPFLVL_WARNING, send);
        }
        else
        {
            DPF_WARNING("send returned no error, but not all the data was sent (%lu != %lu)", dwSent, dwBufferSize);
            hr = E_FAIL;
        }
    }

    if(FAILED(hr))
    {
        Disconnect(DSREMOTE_DISCONNECT_LISTEN);
    }

    return hr;
}


/****************************************************************************
 *
 *  recv
 *
 *  Description:
 *      Wrapper around WinSock's recv function.
 *
 *  Arguments:
 *      LPVOID [in]: data.
 *      DWORD [in]: size, in bytes.
 *      LPDWORD [out]: amount of data received, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::recv"

HRESULT
CRemoteConnection::recv
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwReceived
)
{
    DWORD                   dwTotalReceived = 0;
    HRESULT                 hr              = S_OK;
    DWORD                   dwReceived;

    ASSERT(DSREMOTE_STATE_CONNECTED == m_dwState);

    while(SUCCEEDED(hr) && (dwTotalReceived < dwBufferSize))
    {
        if((dwReceived = ::recv(m_socket, (char *)pvBuffer + dwTotalReceived, dwBufferSize - dwTotalReceived, 0)) != dwBufferSize - dwTotalReceived)
        {
            if(SOCKET_ERROR == dwReceived)
            {
                if(!pdwReceived || (WSAEMSGSIZE != WSAGetLastError()))
                {
                    hr = WSATranslateError(DPFLVL_WARNING, recv);
                }
            }
            else if(!dwReceived)
            {
                DPF_WARNING("recv returned no error, but not all the data was received (%lu != %lu)", dwReceived, dwBufferSize);
                hr = E_FAIL;
            }
        }

        if(SUCCEEDED(hr))
        {
            dwTotalReceived += dwReceived;
        }
    }

    if(SUCCEEDED(hr) && pdwReceived)
    {
        *pdwReceived = dwTotalReceived;
    }
    
    if(FAILED(hr))
    {
        Disconnect(DSREMOTE_DISCONNECT_LISTEN);
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateStitchedPacket
 *
 *  Description:
 *      Creates a stitched packet object.
 *
 *  Arguments:
 *      LPCDSRPACKET [in]: packet header.
 *      CStitchedPacket ** [out]: stitched packet object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::CreateStitchedPacket"

HRESULT
CRemoteConnection::CreateStitchedPacket
(
    LPCDSRPACKETHEADER      pPacketHeader,
    CStitchedPacket **      ppStitchedPacket
)
{
    HRESULT                 hr              = S_OK;
    CStitchedPacket *       pStitchedPacket;
    PLIST_ENTRY             pleEntry;
    
    //
    // See if a packet is already in the list
    //

    for(pleEntry = m_lstStitched.Flink; pleEntry != &m_lstStitched; pleEntry = pleEntry->Flink)
    {
        pStitchedPacket = CONTAINING_RECORD(pleEntry, CStitchedPacket, m_leStitched);

        if(pStitchedPacket->m_PacketHeader.dwSequence == pPacketHeader->dwSequence)
        {
            ASSERT(pPacketHeader->dwMajorType == pStitchedPacket->m_PacketHeader.dwMajorType);
            ASSERT(pPacketHeader->dwMinorType == pStitchedPacket->m_PacketHeader.dwMinorType);
            ASSERT(pPacketHeader->dwFlags == pStitchedPacket->m_PacketHeader.dwFlags);
            ASSERT(pPacketHeader->dwSize == pStitchedPacket->m_PacketHeader.dwSize);
            ASSERT(pPacketHeader->dwResponseSize == pStitchedPacket->m_PacketHeader.dwResponseSize);
            
            break;
        }
    }

    if(pleEntry == &m_lstStitched)
    {
        hr = HRFROMP(pStitchedPacket = NEW(CStitchedPacket));

        if(SUCCEEDED(hr))
        {
            hr = pStitchedPacket->Initialize(pPacketHeader, &m_lstStitched);
        }
    }

    if(SUCCEEDED(hr))
    {
        *ppStitchedPacket = pStitchedPacket;
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateChecksum
 *
 *  Description:
 *      Creates a 32-bit data checksum.
 *
 *  Arguments:
 *      LPCVOID [in]: data buffer.
 *      DWORD [in]: buffer size, in bytes.
 *
 *  Returns:  
 *      DWORD: checksum.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CRemoteConnection::CreateChecksum"

#pragma warning(disable:4035)

DWORD __fastcall
CRemoteConnection::CreateChecksum
(
    LPCVOID                 pvBuffer,
    DWORD                   dwBufferSize
)
{
    __asm 
    {
	    xor		eax, eax
        xor     ebx, ebx
        shr     edx, 2
        test    edx, edx
        jz      L2
L1:     add     eax, [ecx]
        adc     ebx, 0
        add     ecx, 4
        dec     edx
        jnz     L1
L2:     add     eax, ebx
        adc     eax, 0
    }
}

#pragma warning(default:4035)


/****************************************************************************
 *
 *  CStitchedPacket
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CStitchedPacket::CStitchedPacket"

CStitchedPacket::CStitchedPacket
(
    void
)
{
    InitializeListHead(&m_leStitched);
}


/****************************************************************************
 *
 *  ~CStitchedPacket
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CStitchedPacket::~CStitchedPacket"

CStitchedPacket::~CStitchedPacket
(
    void
)
{
    RemoveEntryList(&m_leStitched);
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCDSRPACKETHEADER [in]: packet data.
 *      PLIST_ENTRY [in/out]: stitched message list.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CStitchedPacket::Initialize"

HRESULT
CStitchedPacket::Initialize
(
    LPCDSRPACKETHEADER      pPacketHeader,
    PLIST_ENTRY             plstStitched
)
{
    HRESULT                 hr;

    hr = HRFROMP(m_pvPacketData = MEMALLOC_NOINIT(BYTE, pPacketHeader->dwSize));

    if(SUCCEEDED(hr))
    {
        m_PacketHeader = *pPacketHeader;

        InsertTailList(plstStitched, &m_leStitched);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\dsremote\test\dsrtest.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1/8/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       win32.cpp
 *  Content:    insert content description here.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/8/2002   dereks  Created.
 *
 ****************************************************************************/

#include "dsremote.h"
#include <xboxdbg.h>
#include <stdio.h>

EXTERN_C DWORD g_dwDirectSoundDebugLevel;

#define ASSERT(exp) \
    { \
        if(!(exp)) \
        { \
            __asm int 3 \
        } \
    }

//
// Major packet types
//

enum
{
    DSRTYPE_TEST = 'tset',
};

//
// Minor packet types
//

enum
{
    DSRTYPE_TEST_STRING = 0,
    DSRTYPE_TEST_COUNT
};

//
// Message handler callback
//

class CTestMsgHandler
{
public:
    enum
    {
        DSRTYPE = DSRTYPE_TEST
    };

public:
    // Handler registration
    HRESULT Register(LPREMOTECONNECTION pConnection);
   
protected:
    // Specific handler functions
    void ReceiveString(LPCSTR pszString, LPSTR pszResponseString, LPDWORD pdwResponseSize);

private:
    // Handler function
    static BOOL STDMETHODCALLTYPE Receive(LPCDSRPACKET pPacket, LPCDSRBUFFER pPacketBuffer, LPDSRBUFFER pResponseBuffer, LPVOID pvContext);
};


/****************************************************************************
 *
 *  Register
 *
 *  Description:
 *      Registers the handler with a connection object.
 *
 *  Arguments:
 *      LPREMOTECONNECTION [in]: connection object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTestMsgHandler;:Register"

HRESULT
CTestMsgHandler::Register
(
    LPREMOTECONNECTION      pConnection
)
{
    DSREMOTEMSGHANDLER      VTable;

    ZeroMemory(&VTable, sizeof(VTable));

    VTable.Receive = Receive;

    return pConnection->RegisterMsgHandler(DSRTYPE, &VTable, this);
}


/****************************************************************************
 *
 *  Receive
 *
 *  Description:
 *      Called when data is received.
 *
 *  Arguments:
 *      LPCDSRPACKET [in]: packet data.
 *      LPDSRBUFFER [in/out]: response data.
 *      LPVOID [in]: callback context.
 *
 *  Returns:  
 *      BOOL: TRUE if the message was handled.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTestMsgHandler;:Receive"

BOOL
CTestMsgHandler::Receive
(
    LPCDSRPACKET            pPacket, 
    LPCDSRBUFFER            pPacketBuffer,
    LPDSRBUFFER             pResponseBuffer,
    LPVOID                  pvContext
)
{
    CTestMsgHandler *       pHandler    = (CTestMsgHandler *)pvContext;
    BOOL                    fHandled    = TRUE;
    
    switch(pPacket->dwMinorType)
    {
        case DSRTYPE_TEST_STRING:
            pHandler->ReceiveString((LPCSTR)pPacketBuffer->pvData, (LPSTR)pResponseBuffer->pvData, &pResponseBuffer->dwSize);
            break;

        default:
            fHandled = FALSE;
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  ReceiveString
 *
 *  Description:
 *      Called when data is received.
 *
 *  Arguments:
 *      LPCSTR [in]: input string.
 *      LPSTR [out]: response string.
 *      LPDWORD [out]: response string length, in bytes.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CTestMsgHandler;:ReceiveString"

void
CTestMsgHandler::ReceiveString
(
    LPCSTR                  pszString, 
    LPSTR                   pszResponseString, 
    LPDWORD                 pdwResponseSize
)
{
    static DWORD            dwResponseIndex     = 0;
    CHAR                    szResponse[0x100];
    DWORD                   dwLength;

    ASSERT(pszString);
    
    OutputDebugStringA("Received string:  ");
    OutputDebugStringA(pszString);
    OutputDebugStringA("\n");

    if(pszResponseString && pdwResponseSize)
    {
        dwLength = sprintf(szResponse, "Response %lu", dwResponseIndex++) + 1;

        if(dwLength <= *pdwResponseSize)
        {
            strcpy(pszResponseString, szResponse);
            *pdwResponseSize = dwLength;
        }
        else
        {
            *pdwResponseSize = 0;
        }
    }
}


/****************************************************************************
 *
 *  TestSend
 *
 *  Description:
 *      Tests basic transfer of data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestSend"

void
TestSend
(
    void
)
{

#ifdef _XBOX

    static const DWORD      dwFlags             = 0;

#else // _XBOX

    static const DWORD      dwFlags             = DSREMOTE_CONNECT_DNSLOOKUP;

#endif // _XBOX

    static const DWORD      dwSendCount         = 10;
    static const DWORD      dwStringRepeat      = 0x100;
    static const LPCSTR     pszStringTemplate   = "%8.8lX\t";
    static const DWORD      dwStringSize        = 9;
    static const DWORD      dwSendSize          = (dwStringSize * dwStringRepeat) + 1;
    IRemoteConnection *     pConnection         = NULL;
    LPVOID                  pvBuffer            = NULL;
    CTestMsgHandler         MsgHandler;
    DSRPACKET               Packet;
    DSRBUFFER               PacketBuffer;
    DSRBUFFER               ResponseBuffer;
    HRESULT                 hr;
    DWORD                   a, b;

    hr = CreateRemoteConnection(DSREMOTE_DEFAULT_PORT, NULL, NULL, &pConnection);

    if(SUCCEEDED(hr))
    {
        hr = pConnection->Connect(NULL, dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        hr = MsgHandler.Register(pConnection);
    }

    if(SUCCEEDED(hr))
    {
        if(!(pvBuffer = LocalAlloc(LPTR, dwSendSize)))
        {
            hr = E_OUTOFMEMORY;
        }
    }

// #ifndef _XBOX

    if(SUCCEEDED(hr))
    {
        for(a = 0; (a < dwSendCount) && SUCCEEDED(hr); a++)
        {
            for(b = 0; b < dwStringRepeat; b++)
            {
                sprintf((LPSTR)pvBuffer + (dwStringSize * b), pszStringTemplate, (dwStringRepeat * a) + b);
            }
        
            Packet.dwMajorType = DSRTYPE_TEST;
            Packet.dwMinorType = DSRTYPE_TEST_STRING;
            Packet.dwFlags = 0;

            PacketBuffer.dwSize = dwSendSize;
            PacketBuffer.pvData = pvBuffer;

            ResponseBuffer.dwSize = dwSendSize;
            ResponseBuffer.pvData = pvBuffer;

            hr = pConnection->Send(&Packet, 1, &PacketBuffer, &ResponseBuffer);

            if(SUCCEEDED(hr))
            {
                OutputDebugStringA("Received response:  ");
                
                if(ResponseBuffer.dwSize)
                {
                    OutputDebugStringA((LPCSTR)pvBuffer);
                }
                else
                {
                    OutputDebugStringA("(null)");
                }

                OutputDebugStringA("\n");
            }        
        }
    }

// #endif // _XBOX

    while(SUCCEEDED(hr))
    {
        pConnection->DoWork();
    }

    if(pConnection)
    {
        pConnection->Release();
    }

    if(pvBuffer)
    {
        LocalFree(pvBuffer);
    }
}


/****************************************************************************
 *
 *  TestFileIo
 *
 *  Description:
 *      Tests remote file i/o.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestFileIo"

void
TestFileIo
(
    void
)
{

#ifdef _XBOX

    static const DWORD      dwFlags         = 0;

#else // _XBOX

    static const DWORD      dwFlags         = DSREMOTE_CONNECT_DNSLOOKUP;
    static const LPCSTR     pszSourceFile   = "c:\\winnt\\regedit.exe";
    static const LPCSTR     pszRemoteFile   = "t:\\regedit.exe";

#endif // _XBOX

    IRemoteConnection *     pConnection     = NULL;
    IRemoteFileIo *         pFileIo         = NULL;
    HRESULT                 hr;

    hr = CreateRemoteConnection(DSREMOTE_DEFAULT_PORT, NULL, NULL, &pConnection);

    if(SUCCEEDED(hr))
    {
        hr = pConnection->Connect(NULL, dwFlags);
    }

#ifndef _XBOX

    if(SUCCEEDED(hr))
    {
        hr = CreateRemoteFileIo(pConnection, &pFileIo);
    }

    if(SUCCEEDED(hr))
    {
        hr = pFileIo->CopyFile(pszSourceFile, pszRemoteFile, FALSE);
    }

    if(pFileIo)
    {
        pFileIo->Release();
    }

#endif // _XBOX

    while(SUCCEEDED(hr))
    {
        pConnection->DoWork();
    }

    if(pConnection)
    {
        pConnection->Release();
    }
}


/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "main"

void __cdecl
main
(
    void
)
{
    g_dwDirectSoundDebugLevel = 4;

    // TestSend();
    TestFileIo();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\inc\dsp.h ===
#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

#define MAX_FX_INPUTS 50
#define MAX_FX_OUTPUTS 50

#define Int24 long


//
// max processing cycles in the GP, per 32 sample frame
//

#define DSP_MAXCYCLES_AVAILABLE 100000
#define DSP_BUFFER_FRAME_LENGTH	32

//
// each FX we download to the DSP will be pointed to a space in Xram
// That space will contain a fixed data structure followed by FX specific variables
// the data structure below has to match what is defined in the DSP asm includes

typedef struct DSP_STATE_FIXED {

	DWORD   dwScratchBase;
	DWORD   dwScratchLength;
	DWORD   dwYMemBase;
	DWORD   dwYMemLength;
	DWORD   dwFlags;
	DWORD	dwIoPtrs[2]; 

} DSP_STATE_FIXED, *PDSP_STATE_FIXED;

//
// state flags
//
#define BIT_FX_STATE_FLAG_INITIALIZED		0
#define VALUE_FX_STATE_FLAG_INITIALIZED     1

#define BIT_FX_STATE_FLAG_GLOBAL_FX         1
#define VALUE_FX_STATE_FLAG_GLOBAL_FX       2

//
// GP memory offsets for the mixbins specifed as sources/outputs
// BUGBUG part of XRAM inside the dsp is mapped to VP mixbins. Its ok to write to that for now..
//

#define DSP_VPMIXBIN_MEMOFFSET_BASE		0x001400	
#define DSP_GPMIXBIN_MEMOFFSET_BASE		0x000c00	

//
// defines that describe the scratch image file layout
//

typedef struct _SCRATCH_IMAGE_FX_DESCRIPTION {

	DWORD dwCodeOffset;
	DWORD dwCodeSize;
	DWORD dwStateOffset;
	DWORD dwStateSize;
	DWORD dwYMemOffset;
    DWORD dwYMemSize;
	DWORD dwScratchOffset;
	DWORD dwScratchSize;

} SCRATCH_IMAGE_FX_DESCRIPTION;

//
// immediately following the descriptor is an array of
// SCRATCH_IMAGE_FX_DESCRIPTION data structs.
// Each struct describes an effect parsed. The elements are ordered
// in the order they were parsed from the fx description INI file
// 

typedef struct _SCRATCH_IMAGE_DESCRIPTOR {

	DWORD dwNumFX;
    DWORD dwTotalScratchSize;

} SCRATCH_IMAGE_DESCRIPTOR;


typedef struct HOST_TO_DSP_COMMANDBLOCK {

    DWORD dwOffset;
	DWORD dwCodeLength;
	DWORD dwStateOffset;
	DWORD dwStateLength;
	DWORD dwCommandFlags;
	DWORD dwDspStatus;


} HOST_TO_DSP_COMMANDBLOCK, *PHOST_TO_DSP_COMMANDBLOCK;

//
// command block field defines
//

#define BIT_H2DCB_COMMAND_PRESENT			0x00
#define BIT_H2DCB_COMMAND_LOAD_CODE         0x01
#define BIT_H2DCB_COMMAND_LOAD_XRAM_STATE   0x02
#define BIT_H2DCB_COMMAND_UPDATE_XRAM_STATE 0x04


#define DSP_PMEMORY_SIZE	4096*sizeof(DWORD)
#define DSP_XMEMORY_SIZE	3072*sizeof(DWORD)
#define DSP_YMEMORY_SIZE	2048*sizeof(DWORD)

//
// the definition below is an estimate of the currnet size of the engine.
// 

#define DSP_EXECUTION_ENGINE_SIZE  0x600  // in bytes

//
// the following offsets can be moved around since we set up the command node
// with relative pointers
// The definitions blow must match dsound\dsp\fx\include\gputil.h
//

#define DSP_COMMANDBLOCK_SCRATCHOFFSET  	 2048

//
// base offset in scratch were we put the GP audio output + multipass
//

#define DSP_AUDIO_DATA_SCRATCHOFFSET	(((DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK)+\
                                           DSP_PMEMORY_SIZE+DSP_XMEMORY_SIZE - DSP_EXECUTION_ENGINE_SIZE + PAGE_SIZE-1)/PAGE_SIZE)* PAGE_SIZE)
	
//
// NOTE: keep in sync with dsound. 3 pages for ac3, 1 page for multipass

#define DSP_AUDIO_DATA_SIZE		(PAGE_SIZE*4)

#define DSP_FX_DELAY_DATA_SCRATCHOFFSET (DSP_AUDIO_DATA_SCRATCHOFFSET+DSP_AUDIO_DATA_SIZE)

// #############################################################
// NOTE: The definitions for Xmemory offsets and data structures
// MUST BE KEPT IN SYNC WITH THE DSP CODE!!!!
// The equivalent definitions for the dsp execution engine
// are at dsound\dsp\include\io.h
// #############################################################

//
// any variable in X-mem must be at this bas eoffset or higher
// This must be in synch with with dsp\fx\source\defaultengine.asm
// and the definition of dspStateBlockXRAM
//

#define DSP_FX_STATE_YMEMORY_BASE_OFFSET 0
#define DSP_FX_STATE_XMEMORY_BASE_OFFSET (128*sizeof(DWORD))

//
// XMEM offset of AC3 buffer variable. Set by the mcpx to tell the GP dma where to put the
// audio output for the EP to read..
//

#define DSP_AC3BUFFER_XMEMORY_OFFSET            (DSP_FX_STATE_XMEMORY_BASE_OFFSET-sizeof(DWORD))   
#define DSP_MULTIPASS_BUFFER_XMEMORY_OFFSET     (DSP_FX_STATE_XMEMORY_BASE_OFFSET-(sizeof(DWORD)*2))   

//
// both xram and scratch contain mcxp overheaed so they are not 
// completely available for FX 
//

#define DSP_FX_STATE_MAX_SIZE ((2048+1024-512)*sizeof(DWORD))

#define DSP_GPTEMPBIN_MEMOFFSET_BASE (DSP_FX_STATE_XMEMORY_BASE_OFFSET + DSP_FX_STATE_MAX_SIZE)	
#define DSP_MIN_FX_CODE_SIZE (sizeof(DWORD)*2)

//
// various opcodes we look for in the image builder
//

#define DSP_563000_OPCODE_RTS		    	0x0000000C
#define DSP_563000_OPCODE_MOVE_X_TO_R5_IMM	0x0065F400
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\inc\cipher.h ===
#define KEY_SIZE 8
#define PRIVATE_KEY_SEED ((ULONGLONG) 0x7fa49bca49de12ba)

int XAudiopUtility_Encode(
						  PUCHAR pKey,
						  PUCHAR pSrc, 
						  DWORD dwSize, 
						  PUCHAR pDst,
						  BOOL fEmbeddedKey);

int XAudiopUtility_Decode(PUCHAR pKey,
						  PUCHAR pSrc, 
						  DWORD dwSize, 
						  PUCHAR pDst,
						  BOOL fEmbeddedKey);

void XAudiopUtility_GenerateKey(PUCHAR pKey);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\cldtobin\CldToBin.c ===
// **************************************************************************
//
// CldToBin:		convert Motorola .cld output file to a binary file  
//       
//		Gints Klimanis, 2000
//
// **************************************************************************        

#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <varargs.h>
#include <sys/types.h>

/* Headers for working with COFF files */
#ifndef BIG_ENDIAN
#define BIG_ENDIAN 0
#endif
#include "coreaddr.h"
#include "maout.h"
#include "dspext.h"

union dbl {     /* double-precision floating point/integer union */
        double dval;
        struct {
#if !BIG_ENDIAN
                unsigned long lval, hval;
#else
                unsigned long hval, lval;
#endif
        } l;
};

#define False	0
#define True	1

struct comment {	/* comment structure */
	long c_scno;
	long c_text;
	struct comment *c_next;
};

static long ReadHeaders (FILHDR *header, AOUTHDR *optionalHeader, OPTHDR *linkHeader);
static void ReadSections(FILHDR *fileHeader, int numSections, long sectionSeek, char *sectionComment);
static long DumpData(XCNHDR *sh, FILHDR *fileHeader, char *sectionComment);
static int freads (char *ptr, int size, long nitems,FILE *stream);

static void swapw (char *ptr, int size, long nitems);
static void ByteSwap32(void *ptr);
char *FileNamePtr   (char *filePath);
char *FileNameExtPtr(char *filePath);

long symentsize = SYMESZ;
/*  Global variables  */
FILHDR	fileHeader;		/* File header structure */
AOUTHDR	optionalHeader;	/* Optional header structure */
OPTHDR	linkHeader;		/* Linker header structure */
int	absolute;			/* Absolute file flag */

long numSections;		/* Number of sections */
//long sectionSeek;		/* Used to seek to first section */

long symPtr;			/* File pointer to symbol table entries */
long numSymbols;		/* Number of symbols */

int  dataWidth;        /* width of data for printing */
int  addressWidth;     /* width of address for printing */

char *strTab;			/* Pointer to start of string char. array */
long strLength;			/* Length in bytes of string array */

FILE *inFile  = NULL;	
FILE *outFile = stdout;	

char *headerString = NULL;
char *footerString = NULL;
char *nestedIncludeString = NULL;
int useCTitleHeaderFooter = False;

int verbose = False;
int write24to32 = True;
#define kMemoryMapFlag_MemoryX	0x1
#define kMemoryMapFlag_MemoryY	0x2
#define kMemoryMapFlag_MemoryP	0x4
int memoryMapFlags = kMemoryMapFlag_MemoryP | kMemoryMapFlag_MemoryY | kMemoryMapFlag_MemoryX;
int xSegments = 0;
int ySegments = 0;
int pSegments = 0;
int binary          = True;
int comma           = False;
int oneValuePerLine = False;
int byteSwap        = True;
int onlySection     = -1;
int addSectionComments = False;

#define kMaxSections	300
char sectionIncluded[kMaxSections];
int  sectionLengths [kMaxSections];
int sectionCounter = -1;

char str[2000];

/* init is to non valid memory space */
int  space = 777; /* 0=p, 1=x, 2=y, 3=l, 4=N */

struct comment *commentHead    = NULL;	/* head of comment chain */
struct comment *currentComment = NULL;	/* current comment in chain */

// **********************************************************************************
// OnInterrupt:			clean up from signal
// ********************************************************************************** 
	static void
OnInterrupt (int signum)			
{
exit(1);
}	// ---- end OnInterrupt() ---- 

// **********************************************************************************
// PrintUsage:		
// ********************************************************************************** 
	void   
PrintUsage()
{
printf("cldtobin: convert Motorola .cld file to binary or HEX test data file\n" );
printf("Usage: [Options] <infile.cld><outfile.txt>\n");
printf("Options:\n");
printf("                                    \n");
printf("WARNING:  cldtobin processes P-memory sections,\n");
printf("          but has trouble including X and Y memory sections\n");
printf("                                    \n");
printf("    -h    help     print usage statement\n");
printf("    -v    verbose  print debug info\n");
printf("                                    \n");
printf("    -noX  exclude X   Memory sections\n");
printf("    -noY  exclude Y   Memory sections\n");
printf("    -noXY exclude X&Y Memory sections\n");
printf("    -noP  exclude P   Memory sections\n");
printf("    -excludeN <n> exclude section n of N sections Range:[0..N-1]\n");
printf("              (counted in output sections, not input)\n");
printf("Options for binary output only:\n");
printf("    -no24to32  write 32-bit word in 32-bit container\n");
printf("    -nobyteSwap  no endian byte swap, after 24->32 pad\n");
printf("                                    \n");
printf("Options for text output only:\n");
printf("    -astext  output as text instead of binary\n");
printf("    -asinc   separate each word with a comma text\n");
printf("    -nestedinclude  stringused to avoid including DSP code twice\n");
printf("    -single  one text value per line\n");
printf("    -header  prepend this string to output text\n");
printf("    -footer  append  this string to output text\n");
printf("    -titleCheadfoot  C array header & footer using file name\n");
printf("    -addSectionComments  section #, word count/section, 1st word\n");
printf("\n");
printf("Written by Gints Klimanis, nVidia, Inc. 2000\n");
}	// ---- end PrintUsage() ---- 

// ************************************************************
// main:		
// ************************************************************ 
	void
main(int argc, char **argv)
{
int i;
char *s;
int argIndex = 1;
int fileIndex = 0;
char *fileNames[2];

fileNames[0] = NULL;
fileNames[1] = NULL;
for (i = 0; i < kMaxSections; i++)
	{
	sectionIncluded[i] = True;
	sectionLengths [i] = 0;
	}

if ( argc < 3 )
    {
	PrintUsage();
	exit (-1 );
    }

for (i = 1; i < argc; i++)
	{
	s = argv[i]; //printf("arg[%d]='%s'\n", i, s);

	if (s[0] == '-')
		{
		if (!stricmp(s, "-v"))
			verbose = True;
		else if (!stricmp(s, "-noX"))
			memoryMapFlags &= ~kMemoryMapFlag_MemoryX;
		else if (!stricmp(s, "-noY"))
			memoryMapFlags &= ~kMemoryMapFlag_MemoryY;
		else if (!stricmp(s, "-noXY"))
			{
			memoryMapFlags &= ~kMemoryMapFlag_MemoryX;
			memoryMapFlags &= ~kMemoryMapFlag_MemoryY;
			}
		else if (!stricmp(s, "-noP"))
			memoryMapFlags &= ~kMemoryMapFlag_MemoryP;
		else if (!stricmp(s, "-24to32"))
			write24to32 = True;
		else if (!stricmp(s, "-no24to32"))
			write24to32 = False;

		else if (!stricmp(s, "-header"))
			{
			if (++i >= argc)
				{
				fprintf(stderr, "Well, supply %s \n", argv[i-1]);
				exit(-1);
				}
			headerString = argv[i];
			}
		else if (!stricmp(s, "-nestedinclude"))
			{
			if (++i >= argc)
				{
				fprintf(stderr, "Well, supply %s \n", argv[i-1]);
				exit(-1);
				}
			nestedIncludeString = argv[i];
			}
		else if (!stricmp(s, "-footer"))
			{
			if (++i >= argc)
				{
				fprintf(stderr, "Well, supply %s \n", argv[i-1]);
				exit(-1);
				}
			footerString = argv[i];
			}
		else if (!stricmp(s, "-titleCheadfoot"))
			useCTitleHeaderFooter = True;
		else if (!stricmp(s, "-addSectionComments"))
			addSectionComments = True;
		
		else if (!stricmp(s, "-byteSwap"))
			byteSwap = True;
		else if (!stricmp(s, "-nobyteSwap"))
			byteSwap = False;
		else if (!stricmp(s, "-asText"))
			binary = False;
        else if (!stricmp(s, "-asInc"))
        { binary = False; comma = True; }
		else if (!stricmp(s, "-single"))
			oneValuePerLine = True;
		else if (!stricmp(s, "-excludeN"))
			{
			int x;
			if (++i >= argc)
				{
				fprintf(stderr, "Well, supply %s \n", argv[i-1]);
				exit(-1);
				}
			x = atoi(argv[i]);
			if (x < 0 || x > 1000)
				{
				fprintf(stderr, "Well, arg[%d]=%s out of range [0..%d]\n", i, argv[i], 0, kMaxSections-1);
				exit(-1);
				}
			sectionIncluded[x] = False;
			}
		else if (!stricmp(s, "-onlySection"))
			{
			int x;
			if (++i >= argc)
				{
				fprintf(stderr, "Well, supply %s \n", argv[i-1]);
				exit(-1);
				}
			x = atoi(argv[i]);
			if (x < 0 || x > 1000)
				{
				fprintf(stderr, "Well, arg[%d]=%s out of range [0..%d]\n", i, argv[i], 0, kMaxSections-1);
				exit(-1);
				}
			onlySection = x;
			}
		else
			{
			printf("Bogus option '%s'\n", s);
			PrintUsage();
			exit (-1 );
			}
		}
	else
		fileNames[fileIndex++] = argv[i];
	}

if (!fileNames[0])
	{
	printf("Provide input file name\n");
	PrintUsage();
	exit (-1 );
	}
if (!fileNames[1])
	{
	printf("Provide output file name\n");
	PrintUsage();
	exit (-1 );
	}
if (verbose)
	{
//	printf("memoryMapFlags=%X\n", memoryMapFlags);
	printf("Input  file: '%s'\n", fileNames[0]);
	printf("Output file: '%s'\n", fileNames[1]);
	}

  /* set up for signals, save program name, check for command line options */
    signal (SIGINT, OnInterrupt);

if ( ( inFile = fopen( fileNames[0], "rb" ) ) == NULL )
	{
	printf( "cannot open input file %s", fileNames[0] );
	exit(0);
	}
if (fileNames[1])
	{
	if (binary)
		outFile = fopen( fileNames[1], "wb" );
	else
		outFile = fopen( fileNames[1], "w" );
	 if ( outFile == NULL )
		{
		printf( "cannot open output file %s", fileNames[1] );
		fclose( inFile );
		exit(0);
		}
	}

{
char *p;
long sectionSeek;

if (!binary)
	{
// Pinpoint file name in the full file path string
	strcpy(s, FileNamePtr(fileNames[1]));
// Exclude file extension
	p = FileNameExtPtr(s);
	p[0] = '\0';
	}

// Insert some text before the DSP code data
if (!binary)
	{
	if (useCTitleHeaderFooter)
		{
	// Insert "include once" stuff
		fprintf(outFile, "#ifndef __%s_H__\n", s);
		fprintf(outFile, "#define __%s_H__\n", s);

		}
	else if (headerString)
		fprintf(outFile, "%s", headerString);
	}
sectionSeek = ReadHeaders(&fileHeader, &optionalHeader, &linkHeader);
if (-1 == sectionSeek)
	{
	printf("ReadHeaders: Bad header, Exiting ...\n");
	exit(-1);
	}

ReadSections(&fileHeader, numSections, sectionSeek, s);

if (!binary)
	{
	if (useCTitleHeaderFooter)
		fprintf(outFile, "%s", "};");
	else if (footerString)
		fprintf(outFile, "%s", footerString);

	if (nestedIncludeString)	
		fprintf(outFile, "\n#endif /* %s */\n", nestedIncludeString);

// End of "include once" stuff
	if (useCTitleHeaderFooter)
		fprintf(outFile, "\n#endif // __%s_H__\n", s);
	}
}

fclose( inFile );
if (outFile)
	{
	if (binary)
		{
		int i;
#define ZERO_PADDING	2
		for (i = 0; i < ZERO_PADDING; i++) 
			str[i] = 0;
		fwrite((void *) str, sizeof(unsigned char), ZERO_PADDING, outFile);
		}
	fclose( outFile );
	}
exit (0);
}	// ---- end main() ---- 

// ************************************************************
// ReadHeaders:		return sectionSeek, -1 on error
// ************************************************************ 
	static long
ReadHeaders(FILHDR *header, AOUTHDR *optionalHeader, OPTHDR *linkHeader)
{
if ( freads( (char *) header, sizeof(FILHDR), 1, inFile ) != 1 )
	printf ("ReadHeaders(): Cannot read file header");

/* Save global values */
    numSections = header->f_nscns;
    numSymbols  = header->f_nsyms;
    symPtr      = header->f_symptr;
    absolute    = !!(header->f_flags & F_RELFLG);

/* Check MAGIC number */
    if ( header->f_magic == M56KMAGIC )
		{
		dataWidth    = 6;
		addressWidth = 4;
		}
    else if ( header->f_magic == M96KMAGIC )
		dataWidth = addressWidth = 8;
    else if ( header->f_magic == M16KMAGIC )
		dataWidth = addressWidth = 4;
    else if ( header->f_magic == M563MAGIC )
		dataWidth = addressWidth = 6;
    else if ( header->f_magic == M566MAGIC )
		{
		dataWidth    = 6;
        addressWidth = 4;
		}
    else if ( header->f_magic == M568MAGIC )
 		dataWidth = addressWidth = 4;
    else if ( header->f_magic == SC1MAGIC )
		{
		dataWidth    = 4;
		addressWidth = 8;
		}
    else if ( header->f_magic == M567MAGIC )
		{
		dataWidth    = 4;
		addressWidth = 8;
		}
    else
		{
		printf("Header has a bad magic number\n" );
		return (-1);
		}
    /* optional header present */
    if ( header->f_opthdr )
		{
		if ( absolute )
			{
			if ( freads( (char *) optionalHeader,
				(int)header->f_opthdr, 1, inFile ) != 1 )
			printf( "cannot read optional file header" );
			}
		else
			{
			if ( freads( (char *) linkHeader,
				(int)header->f_opthdr, 1, inFile ) != 1 )
			printf( "cannot read linker file header" );
			}
		}

/* sectionSeek: File offset for first section headers */
return (sizeof(FILHDR) + header->f_opthdr);
}	// ---- end ReadHeaders() ---- 

// ************************************************************
// ReadSections:		
// ************************************************************ 
	static void
ReadSections(FILHDR *fileHeader, int numSections, long sectionSeek, char *sectionComment)
{
int i;
XCNHDR sh;		/* Section header structure */

for (i = 0; i < numSections; i++)
    {
	if (fseek (inFile, sectionSeek, 0) != 0)
	    printf ("cannot seek to section headers");
	if (freads ((char *)&sh, sizeof(XCNHDR), 1, inFile) != 1)
	    printf ("cannot read section headers");
#if !BIG_ENDIAN
	if (sh._n._s_n._s_zeroes)
	    swapw (sh._n._s_name, sizeof(long), 2);
#endif
	sectionSeek += sizeof(XCNHDR);

	DumpData (&sh, fileHeader, sectionComment);
    }


if (verbose)
	{
	// Add up section lengths
	long totalLength   = 0;
	long totalSections = 0;
printf("\n");
	for (i = 0; i <= sectionCounter; i++)
		{
if (verbose)
	printf("Section %2d: included=%d length=%d\n", i, sectionIncluded[i], sectionLengths[i]);
		if (sectionIncluded[i])
			{
			totalSections++;
			totalLength += sectionLengths[i];
			}
		}
	printf("\nTotals in output: %d words (%d bytes) in %d Sections\n", totalLength, totalLength/3, totalSections);
	}
}	// ---- end ReadSections() ----

// ************************************************************
// GetSectionName:		
// ************************************************************ 
	char *
GetSectionName (XCNHDR *sh)
{
char *secname;

if ( sh->_n._s_n._s_zeroes )
	secname = sh->_n._s_name;
else
    {
	if (sh->_n._s_n._s_offset < sizeof(strLength) ||
	    sh->_n._s_n._s_offset > strLength)
	    printf ("invalid string table offset for section header name");
	secname = &strTab[sh->_n._s_n._s_offset - sizeof(strLength)];
    }

return (secname);
}	// ---- end GetSectionName() ----

// ************************************************************
// DumpData:			Return # words in this section
// ************************************************************ 
	static long
DumpData (XCNHDR *sh, FILHDR *fileHeader, char *sectionComment)
{
    char *secname, *GetSectionName ();
    long *raw_data;
    int  j;
    char emi_name_buf[8];
	int memtype, address ;
	char *mem_field;
int isXmemory = False;
int isYmemory = False;
int isPmemory = False;

sectionCounter++;
sectionLengths [sectionCounter] = sh->_s.s_size;

if (verbose)
	printf("Section %2d:  valid=%d s_scnptr=%5d s_size=%5d s_paddr=%5d\n", 
		   sectionCounter, ( sh->_s.s_scnptr && sh->_s.s_size ), 
		   sh->_s.s_scnptr, sh->_s.s_size, 
			sh->_s.s_paddr);

if (!( sh->_s.s_scnptr && sh->_s.s_size ))
	{
	sectionIncluded[sectionCounter] = False;
	return (0);
	}

memtype = CORE_ADDR_MAP(  sh->_s.s_paddr );
address = CORE_ADDR_ADDR( sh->_s.s_paddr );
secname = GetSectionName( sh );

/* Determine memory field (optional counter ok) */
switch ( memtype )
	{
	case memory_map_p:
	    mem_field = "P";
	    break;
	    
	case memory_map_pa:
	    mem_field = "PA";
	    break;
	    
	case memory_map_pb:
	    mem_field = "PB";
	    break;
	    
	case memory_map_pe:
	    mem_field = "PE";
	    break;
	    
	case memory_map_pi:
	    mem_field = "PI";
	    break;
	    
	case memory_map_pr:
	    mem_field = "PR";
	    break;
	    
	case memory_map_y:
	    mem_field = "Y";
	    break;
	    
	case memory_map_ya:
	    mem_field = "YA";
	    break;
	    
	case memory_map_yb:
	    mem_field = "YB";
	    break;
	    
	case memory_map_ye:
	    mem_field = "YE";
	    break;
	    
	case memory_map_yi:
	    mem_field = "YI";
	    break;
	    
	case memory_map_yr:
	    mem_field = "YR";
	    break;
	    
	case memory_map_x:
	    mem_field = "X";
	    break;
	    
	case memory_map_xa:
	    mem_field = "XA";
	    break;
	    
	case memory_map_xb:
	    mem_field = "XB";
	    break;
	    
	case memory_map_xe:
	    mem_field = "XE";
	    break;
	    
	case memory_map_xi:
	    mem_field = "XI";
	    break;
	    
	case memory_map_xr:
	    mem_field = "XR";
	    break;
	    
	case memory_map_l:
	    mem_field = "L";
	    break;
	    
	case memory_map_laa:
	    mem_field = "LAA";
	    break;
	    
	case memory_map_lab:
	    mem_field = "LAB";
	    break;
	    
	case memory_map_lba:
	    mem_field = "LBA";
	    break;
	    
	case memory_map_lbb:
	    mem_field = "LBB";
	    break;
	    
	case memory_map_le:
	    mem_field = "LE";
	    break;
	    
	case memory_map_li:
	    mem_field = "LI";
	    break;
	    
	case memory_map_emi:
	    mem_field = "EM";
	    break;
	    
	case memory_map_dm:
	    mem_field = "DM";
	    break;
	    
	default:

	    if ((fileHeader->f_magic == M566MAGIC) &&
		  	  (memtype == memory_map_e1      ) && 
			  (sh->_s.s_flags & STYP_OVERLAY ) &&
			(!(sh->_s.s_flags & STYP_OVERLAYP))  )
	    {
		/* substitute when x or y overlay memory destination */
		memtype = memory_map_e0;
	    }
	    
	    if (memtype >= memory_map_e0 && memtype <= memory_map_e255)
			{
			sprintf(emi_name_buf,"E%d",memtype-memory_map_e0);
			mem_field = emi_name_buf;
			}
	    else
			mem_field = "<error>";
	break;
	}
	
sectionLengths[sectionCounter] = sh->_s.s_size;

if (!binary && useCTitleHeaderFooter)
	{
	fprintf(outFile, "\n#define k%s_Length %d\n", sectionComment, sectionLengths[sectionCounter]);

	if (nestedIncludeString)	
		fprintf(outFile, "\n#ifdef %s\n", nestedIncludeString);

	fprintf(outFile, "Int24 %sLength = k%s_Length;\n", sectionComment, sectionComment);
// Insert array preample :   Int24 fileName[] = {
	fprintf(outFile, "Int24 %s[k%s_Length] = {\n", sectionComment, sectionComment);
	}

//	if (verbose)
//		printf("Section %2d IsX=%d IsY=%d IsP=%d included=%d length=%d\n", 
//		sectionCounter, 
//		IsMemoryX(memtype), IsMemoryY(memtype), IsMemoryP(memtype), 
//		sectionIncluded[sectionCounter], sectionLengths[sectionCounter]);

if		(IsMemoryX(memtype) && !(memoryMapFlags & kMemoryMapFlag_MemoryX))
	sectionIncluded[sectionCounter] = False;
else if (IsMemoryY(memtype) && !(memoryMapFlags & kMemoryMapFlag_MemoryY))
	sectionIncluded[sectionCounter] = False;
else if (IsMemoryP(memtype) && !(memoryMapFlags & kMemoryMapFlag_MemoryP))
	sectionIncluded[sectionCounter] = False;

if (!sectionIncluded[sectionCounter])
	{
	if (verbose)
		printf("Section %2d Memory %s not included\n", sectionCounter, mem_field);

//	printf("sectionIncluded=%d IsMemoryX=%d IsMemoryY=%d IsMemoryP=%d\n",
//			sectionIncluded[sectionCounter-1], IsMemoryX(memtype), IsMemoryY(memtype), IsMemoryP(memtype));

//		if (!binary)
//			fprintf (outFile, "_DATA %s %01.*X\n", mem_field, addressWidth, address );
//	printf("_DATA %s %01.*X\n", mem_field, addressWidth, address );
	return (0);
	}

raw_data = (long *)malloc((size_t)(sh->_s.s_size * sizeof(long)));
if (!raw_data)
	{
	printf ("cannot allocate raw data for section %s", secname);
	return (0);
	}

if (fseek (inFile, sh->_s.s_scnptr, 0) != 0)
	{
	printf ("cannot seek to raw data in section %s", secname);
	return (0);
	}

if (freads ((char *)raw_data, (int)sh->_s.s_size,sizeof(long), inFile) != sizeof(long))
	{
	printf ("cannot read raw data in section %s",  secname);
	return (0);
	}


/* check for block data */
if ( sh->_s.s_flags & STYP_BLOCK )
	{
	if (!binary)
		{
	    if ( mem_field[0] == 'L' )
			{
			fprintf( outFile, "_BLOCKDATA Y %01.*X %01.*X %01.*X\n",
				addressWidth, address,
				addressWidth, CORE_ADDR_ADDR( sh->_s.s_vaddr ),
				dataWidth, *raw_data++ );

			fprintf( outFile, "_BLOCKDATA X %01.*X %01.*X %01.*X\n",
				addressWidth, address,
				addressWidth, CORE_ADDR_ADDR( sh->_s.s_vaddr ),
				dataWidth, *raw_data++ );
			}
	    else
			{
			fprintf( outFile, "_BLOCKDATA %s %01.*X %01.*X %01.*X\n",
				mem_field,
				addressWidth, address,
				addressWidth, CORE_ADDR_ADDR( sh->_s.s_vaddr ),
				dataWidth, *raw_data++ );
			}
		}
	}
	
	else
	{

	if (addSectionComments || verbose)
		{
		sprintf(str, "/* Section %2d Including Memory %s $%06X (1st word= $%06X ) length= %5d */\n", 
			sectionCounter, mem_field,  address, *raw_data,  sh->_s.s_size);

		if (!binary && addSectionComments) // && !comma)
			fprintf(outFile, "%s", str );

		if (verbose)
			printf("%s", str);
		}

		j = 0;
	    while (j < sh->_s.s_size)
	    {
		if ( mem_field[0] == 'L' )
			{
            int last = (j == sh->_s.s_size-1); 

			if (binary)
				{
				static unsigned char vv[4];
				long *p;
				vv[0] = 0;

				p     = raw_data+1;
				vv[1] = ((*p) & 0x00FF0000)>>16;
				vv[2] = ((*p) & 0x0000FF00)>>8 ;
				vv[3] = ((*p) & 0x000000FF)    ;
				if (write24to32)
					{
					if (byteSwap)
						ByteSwap32(vv);
					fwrite((void *)     vv, sizeof(unsigned char), 4, outFile);
					}
				else
					fwrite((void *) (vv+1), sizeof(unsigned char), 3, outFile);

				p     = raw_data;
				vv[1] = ((*p) & 0x00FF0000)>>16;
				vv[2] = ((*p) & 0x0000FF00)>>8 ;
				vv[3] = ((*p) & 0x000000FF)    ;
				if (write24to32)
					{
					if (byteSwap)
						ByteSwap32(vv);
					fwrite((void *)     vv, sizeof(unsigned char), 4, outFile);
					}
				else
					fwrite((void *) (vv+1), sizeof(unsigned char), 3, outFile);
				}
			else
				fprintf (outFile, "%s%01.*lX%s %s%01.*lX%s ", (comma?"0x":""), dataWidth, *(raw_data+1), (comma?",":""), comma?"0x":"", dataWidth, *raw_data, ((comma&&(!last))?",":""));
			raw_data += 2;
		    j        += 2;
			}
		else
			{
            int last = (j == sh->_s.s_size);

			if (binary)
				{
				static unsigned char vv[4];
				long *p;
				vv[0] = 0;

				p     = raw_data;
				vv[1] = ((*p) & 0x00FF0000)>>16;
				vv[2] = ((*p) & 0x0000FF00)>>8 ;
				vv[3] = ((*p) & 0x000000FF)    ;
				if (write24to32)
					{
					if (byteSwap)
						ByteSwap32(vv);
					fwrite((void *)     vv, sizeof(unsigned char), 4, outFile);
					}
				else
					fwrite((void *) (vv+1), sizeof(unsigned char), 3, outFile);
				}
			else
                fprintf (outFile, "%s%01.*lX%s ", (comma?"0x":""), dataWidth, *raw_data, ((comma&&(!last))?",":""));
			raw_data++;
		    j++;
			}
		
		if (!binary)
			{
			if (oneValuePerLine)
				fprintf (outFile, "\n");
			else if ( j % 4 == 0 && j < sh->_s.s_size )
				fprintf (outFile, "\n");
			}

	    }
		if (!binary)
			fprintf (outFile, "\n");
	}

return (sectionLengths[sectionCounter]);
}	// ---- end DumpData() ---- 


static char *map_chars[]={
"P",
"X","Y","L","N",
"LAA","LAB","LBA","LBB","LE",
"LI","PA","PB","PE","PI",
"PR","XA","XB","XE","XI",
"XR","YA","YB","YE","YI",
"YR","PT","PF","EM",
"E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9 ",
"E10", "E11", "E12", "E13", "E14", "E15", "E16", "E17", "E18", "E19", 
"E20", "E21", "E22", "E23", "E24", "E25", "E26", "E27", "E28", "E29", 
"E30", "E31", "E32", "E33", "E34", "E35", "E36", "E37", "E38", "E39", 
"E40", "E41", "E42", "E43", "E44", "E45", "E46", "E47", "E48", "E49", 
"E50", "E51", "E52", "E53", "E54", "E55", "E56", "E57", "E58", "E59", 
"E60", "E61", "E62", "E63", "E64", "E65", "E66", "E67", 
"E68", "E69", "E70", "E71", "E72", "E73", "E74", "E75", 
"E76", "E77", "E78", "E79", "E80", "E81", "E82", "E83", 
"E84", "E85", "E86", "E87", "E88", "E89", "E90", "E91", 
"E92", "E93", "E94", "E95", "E96", "E97", "E98", "E99", 
"E100", "E101", "E102", "E103", "E104", "E105", "E106", "E107", 
"E108", "E109", "E110", "E111", "E112", "E113", "E114", "E115", 
"E116", "E117", "E118", "E119", "E120", "E121", "E122", "E123", 
"E124", "E125", "E126", "E127", "E128", "E129", "E130", "E131", 
"E132", "E133", "E134", "E135", "E136", "E137", "E138", "E139", 
"E140", "E141", "E142", "E143", "E144", "E145", "E146", "E147", 
"E148", "E149", "E150", "E151", "E152", "E153", "E154", "E155", 
"E156", "E157", "E158", "E159", "E160", "E161", "E162", "E163", 
"E164", "E165", "E166", "E167", "E168", "E169", "E170", "E171", 
"E172", "E173", "E174", "E175", "E176", "E177", "E178", "E179", 
"E180", "E181", "E182", "E183", "E184", "E185", "E186", "E187", 
"E188", "E189", "E190", "E191", "E192", "E193", "E194", "E195", 
"E196", "E197", "E198", "E199", "E200", "E201", "E202", "E203", 
"E204", "E205", "E206", "E207", "E208", "E209", "E210", "E211", 
"E212", "E213", "E214", "E215", "E216", "E217", "E218", "E219", 
"E220", "E221", "E222", "E223", "E224", "E225", "E226", "E227", 
"E228", "E229", "E230", "E231", "E232", "E233", "E234", "E235", 
"E236", "E237", "E238", "E239", "E240", "E241", "E242", "E243", 
"E244", "E245", "E246", "E247", "E248", "E249", "E250", "E251", 
"E252", "E253", "E254", "E255"
    };

// **********************************************************************************
// freads:  swap bytes and read
// 
//	Treats ptr as reference to union array; if necessary,
//		swaps bytes to maintain base format byte ordering
//		(big endian).  Calls fread to do I/O..
// ********************************************************************************** 
static int
freads (char *ptr, int size, long nitems, FILE *stream)
//		char *ptr;		pointer to buffer
//		int size;		size of buffer
//		int nitems;		number of items to read
//		FILE *stream;		file pointer
{
int rc = fread (ptr, size, nitems, stream);
#if !BIG_ENDIAN
    swapw (ptr, size, nitems);
#endif
    return (rc);
}	// ---- end freads() ---- 


union wrd
{   /* word union for byte swapping */
    unsigned long l;
    unsigned char b[4];
};

// **********************************************************************************
// swapw:		swap bytes in words
// 
//	Treats ptr as reference to union array; if necessary,
//		swaps bytes to maintain base format byte ordering (big endian).
// ********************************************************************************** 
	static void
swapw (char *ptr, int size, long nitems)
//		ptr;		pointer to buffer
//		size;		size of buffer
//		nitems;		number of items to write
{
    union wrd *w;
    union wrd *end = (union wrd *)ptr +	((size * nitems) / sizeof(union wrd));
    unsigned i;

    for (w = (union wrd *)ptr; w < end; w++)
    {
	i       = w->b[0];
	w->b[0] = w->b[3];
	w->b[3] = i;
	i       = w->b[1];
	w->b[1] = w->b[2];
	w->b[2] = i;
    }
}	// ---- end swapw() ---- 

// **********************************************************************************
// ByteSwap32:		swap bytes in 32-bit word
// 
// ********************************************************************************** 
	static void
ByteSwap32(void *ptr)
{
unsigned char *b = (unsigned char *) ptr;
unsigned char x;

x    = b[0];
b[0] = b[3];
b[3] = x;
x    = b[1];
b[1] = b[2];
b[2] = x;
}	// ---- end ByteSwap32() ---- 

// **********************************************************************************
// FileNamePtr:		Return ptr to filename in file path string
// 
// ********************************************************************************** 
	char *
FileNamePtr(char *filePath)
{

char *fileName = filePath;
char *s = filePath;

while (*s != '\0')
	{
	if (*s == '\\' || *s == '/')
		{
		s++;
		if (*s != '\0')
			fileName = s;
		}
	s++;
	}

//printf("FileNamePtr: path='%s' -> fileName='%s'\n", filePath, fileName);
return (fileName);
}	// ---- end FileNamePtr() ---- 

// **********************************************************************************
// FileNameExtPtr:		Return ptr to file name extension in file path string
//						(this points to the '.' )
// ********************************************************************************** 
	char *
FileNameExtPtr(char *filePath)
{
char *fileName = filePath;
long length = strlen(filePath);
char *s;

s = filePath + length;

while (s != filePath)
	{
	if (*s == '.')
		break;
	s--;
	}

//printf("FileNameExtPtr: path='%s' -> fileExt='%s'\n", filePath, s);
return (s);
}	// ---- end FileNameExtPtr() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\coreaddr.h ===
#ifndef CORE_ADDR_ADDR
enum memory_map{memory_map_p=0,
memory_map_x,memory_map_y,memory_map_l,memory_map_none,

memory_map_laa,memory_map_lab,memory_map_lba,memory_map_lbb,memory_map_le,
memory_map_li,

memory_map_pa,memory_map_pb,memory_map_pe,memory_map_pi,
memory_map_pr,

memory_map_xa,memory_map_xb,memory_map_xe,memory_map_xi,
memory_map_xr,

memory_map_ya,memory_map_yb,memory_map_ye,memory_map_yi,
memory_map_yr,

memory_map_pt,memory_map_pf,

memory_map_emi,
memory_map_e0,memory_map_e1,memory_map_e2,memory_map_e3,
memory_map_e4,memory_map_e5,memory_map_e6,memory_map_e7,
memory_map_e8,memory_map_e9,memory_map_e10,memory_map_e11,
memory_map_e12,memory_map_e13,memory_map_e14,memory_map_e15,
memory_map_e16,memory_map_e17,memory_map_e18,memory_map_e19,
memory_map_e20,memory_map_e21,memory_map_e22,memory_map_e23,
memory_map_e24,memory_map_e25,memory_map_e26,memory_map_e27,
memory_map_e28,memory_map_e29,memory_map_e30,memory_map_e31,
memory_map_e32,memory_map_e33,memory_map_e34,memory_map_e35,
memory_map_e36,memory_map_e37,memory_map_e38,memory_map_e39,
memory_map_e40,memory_map_e41,memory_map_e42,memory_map_e43,
memory_map_e44,memory_map_e45,memory_map_e46,memory_map_e47,
memory_map_e48,memory_map_e49,memory_map_e50,memory_map_e51,
memory_map_e52,memory_map_e53,memory_map_e54,memory_map_e55,
memory_map_e56,memory_map_e57,memory_map_e58,memory_map_e59,
memory_map_e60,memory_map_e61,memory_map_e62,memory_map_e63,

memory_map_e64,memory_map_e65,memory_map_e66,memory_map_e67,
memory_map_e68,memory_map_e69,memory_map_e70,memory_map_e71,
memory_map_e72,memory_map_e73,memory_map_e74,memory_map_e75,
memory_map_e76,memory_map_e77,memory_map_e78,memory_map_e79,
memory_map_e80,memory_map_e81,memory_map_e82,memory_map_e83,
memory_map_e84,memory_map_e85,memory_map_e86,memory_map_e87,
memory_map_e88,memory_map_e89,memory_map_e90,memory_map_e91,
memory_map_e92,memory_map_e93,memory_map_e94,memory_map_e95,
memory_map_e96,memory_map_e97,memory_map_e98,memory_map_e99,

memory_map_e100,memory_map_e101,memory_map_e102,memory_map_e103,
memory_map_e104,memory_map_e105,memory_map_e106,memory_map_e107,
memory_map_e108,memory_map_e109,memory_map_e110,memory_map_e111,
memory_map_e112,memory_map_e113,memory_map_e114,memory_map_e115,
memory_map_e116,memory_map_e117,memory_map_e118,memory_map_e119,
memory_map_e120,memory_map_e121,memory_map_e122,memory_map_e123,
memory_map_e124,memory_map_e125,memory_map_e126,memory_map_e127,
memory_map_e128,memory_map_e129,memory_map_e130,memory_map_e131,
memory_map_e132,memory_map_e133,memory_map_e134,memory_map_e135,
memory_map_e136,memory_map_e137,memory_map_e138,memory_map_e139,
memory_map_e140,memory_map_e141,memory_map_e142,memory_map_e143,
memory_map_e144,memory_map_e145,memory_map_e146,memory_map_e147,
memory_map_e148,memory_map_e149,memory_map_e150,memory_map_e151,
memory_map_e152,memory_map_e153,memory_map_e154,memory_map_e155,
memory_map_e156,memory_map_e157,memory_map_e158,memory_map_e159,
memory_map_e160,memory_map_e161,memory_map_e162,memory_map_e163,
memory_map_e164,memory_map_e165,memory_map_e166,memory_map_e167,
memory_map_e168,memory_map_e169,memory_map_e170,memory_map_e171,
memory_map_e172,memory_map_e173,memory_map_e174,memory_map_e175,
memory_map_e176,memory_map_e177,memory_map_e178,memory_map_e179,
memory_map_e180,memory_map_e181,memory_map_e182,memory_map_e183,
memory_map_e184,memory_map_e185,memory_map_e186,memory_map_e187,
memory_map_e188,memory_map_e189,memory_map_e190,memory_map_e191,
memory_map_e192,memory_map_e193,memory_map_e194,memory_map_e195,
memory_map_e196,memory_map_e197,memory_map_e198,memory_map_e199,

memory_map_e200,memory_map_e201,memory_map_e202,memory_map_e203,
memory_map_e204,memory_map_e205,memory_map_e206,memory_map_e207,
memory_map_e208,memory_map_e209,memory_map_e210,memory_map_e211,
memory_map_e212,memory_map_e213,memory_map_e214,memory_map_e215,
memory_map_e216,memory_map_e217,memory_map_e218,memory_map_e219,
memory_map_e220,memory_map_e221,memory_map_e222,memory_map_e223,
memory_map_e224,memory_map_e225,memory_map_e226,memory_map_e227,
memory_map_e228,memory_map_e229,memory_map_e230,memory_map_e231,
memory_map_e232,memory_map_e233,memory_map_e234,memory_map_e235,
memory_map_e236,memory_map_e237,memory_map_e238,memory_map_e239,
memory_map_e240,memory_map_e241,memory_map_e242,memory_map_e243,
memory_map_e244,memory_map_e245,memory_map_e246,memory_map_e247,
memory_map_e248,memory_map_e249,memory_map_e250,memory_map_e251,
memory_map_e252,memory_map_e253,memory_map_e254,memory_map_e255,
memory_map_dm,
memory_map_p8,memory_map_u,memory_map_u8,memory_map_u16,
memory_map_xs,
memory_map_ys,
memory_map_maxp1, /* should stay at last valid memory map plus 1 */
memory_map_error=666666,
memory_map_ic = memory_map_pt
};

union addr_map{
  enum memory_map mape;long l; unsigned long u;
  };
struct core_addr_struct {
   union addr_map w0;
   union addr_map w1;
};

typedef struct core_addr_struct CORE_ADDR;
#define CORE_ADDR_ADDR(ca) ((ca).w0.l)
#define CORE_ADDR_ADDRU(ca) ((ca).w0.u)
#define CORE_ADDR_MAP(ca) ((ca).w1.mape)

char *TranslateMemoryMapID(int id);
int IsMemoryX(int id);
int IsMemoryY(int id);
int IsMemoryP(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\aouthdr.h ===
/* Values for the magic field in aouthdr
 */
#define	OMAGIC	0407L
#define	NMAGIC	0410L
#define	ZMAGIC	0413L
#define	LIBMAGIC	0443L
#define	N_BADMAG(x) (((x).magic)!=OMAGIC && ((x).magic)!=NMAGIC && ((x).magic)!=ZMAGIC && ((x).magic)!=LIBMAGIC)

typedef	struct aouthdr {
	long	magic;		/* see above				*/
	long	vstamp;		/* version stamp			*/
	long	tsize;		/* text size in words */
	long	dsize;		/* initialized data "  "		*/
	long	bsize;		/* uninitialized data "   "		*/

	CORE_ADDR entry;		/* entry pt.				*/
	CORE_ADDR text_start;	/* base of text used for this file	*/
	CORE_ADDR data_start;	/* base of data used for this file	*/
	CORE_ADDR text_end;	/* end address of text used for this file	*/
	CORE_ADDR data_end;	/* end address of data used for this file	*/

} AOUTHDR;
#define AOUTHSZ sizeof(AOUTHDR)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\dspext.h ===
/**
*	DSPEXT - DSP COFF definition extensions
**/

struct opthdr {	/* original (old) linker optional header */
	long modsize;	/* module size */
	long datasize;	/* raw data size */
	long endstr;	/* end expression string */
	long secnt;	/* logical section count */
	long ctrcnt;	/* counter count */
	long relocnt;	/* relocation entry count */
	long lnocnt;	/* line number entry count */
	long bufcnt;	/* buffer count */
	long ovlcnt;	/* overlay count */
	long dumstk;	/* debugger dummy stack size */
};
#define OPTHDR struct opthdr
#define OPTHSZ (sizeof(OPTHDR))

/*
  NOTE:	Currently the linker depends on the fields modsize through
  	ovlcnt to be in the same relative position in both opthdr
	and opthdr2.
*/

struct opthdr2 {	/* linker optional header */
	long modsize;	/* module size */
	long datasize;	/* raw data size */
	long endstr;	/* end expression string */
	long secnt;	/* logical section count */
	long ctrcnt;	/* counter count */
	long relocnt;	/* relocation entry count */
	long lnocnt;	/* line number entry count */
	long bufcnt;	/* buffer count */
	long ovlcnt;	/* overlay count */
	long majver;	/* major version number */
	long minver;	/* minor version number */
	long revno;	/* revision number */
	long optflags;	/* optional header flags */
	long sditot;	/* count of SDIs in module */
};
#define OPTHDR2 struct opthdr2
#define OPTH2SZ (sizeof(OPTHDR2))

union xcnhdr {	/* extended COFF section header */
	union {
		char _s_name[SYMNMLEN];
		struct {
			long	_s_zeroes;
			long	_s_offset;
		} _s_n;
	} _n;
	SCNHDR	_s;
};
#define XCNHDR	union xcnhdr
#define XCNHSZ	sizeof (XCNHDR)

#define scn_name	xcn->_n._s_name
#define scn_zeroes	xcn->_n._s_n._s_zeroes
#define scn_offset	xcn->_n._s_n._s_offset
#define scn_paddr	xcn->_s.s_paddr.w0.u
#define scn_pmap	xcn->_s.s_paddr.w1.mape
#define scn_vaddr	xcn->_s.s_vaddr.w0.u
#define scn_vmap	xcn->_s.s_vaddr.w1.mape
#define scn_size	xcn->_s.s_size
#define scn_scnptr	xcn->_s.s_scnptr
#define scn_relptr	xcn->_s.s_relptr
#define scn_lnnoptr	xcn->_s.s_lnnoptr
#define scn_nreloc	xcn->_s.s_nreloc
#define scn_nlnno	xcn->_s.s_nlnno
#define scn_flags	xcn->_s.s_flags

struct mematt {		/* memory attribute structure */
	enum memory_map mspace; /* memory space */
	enum memory_map mmap;   /* memory mapping */
	long mcntr;             /* counter */
	long mclass;		/* memory class */
};

union auxlnk {	/* original (old) linker auxiliary symbol structure */
	struct {
		long secno;
		long rsecno;
		long mem;
		long flags;
		union {
			struct {
				long bufcnt;
				long buftyp;
				long buflim;
			} buf;
			struct {
				long ovlcnt;
				long ovlmem;
				long ovlstr;
			} ovl;
		} bufovl;
	} aux;
	SYMENT filler;	/* to fill out to size of SYMENT */
};
#define AUXLNK union auxlnk
#define AUXLSZ (sizeof(AUXLNK))

/*
  NOTE:	Currently the linker depends on the fields secno and
  	rsecno to be in the same relative position in both auxlnk
	and auxlnk1.
*/

union auxlnk1 {	/* linker first auxiliary symbol structure */
	struct {
		long secno;
		long rsecno;
		long flags;
		struct mematt mem;
	} aux;
	SYMENT filler;	/* to fill out to size of SYMENT */
};
#define AUXLNK1 union auxlnk1
#define AUXL1SZ (sizeof(AUXLNK1))

union auxlnk2 {	/* linker second auxiliary symbol structure */
	union {
		struct {
			long bufcnt;
			long buftyp;
			long buflim;
		} buf;
		struct {
			struct mematt ovlmem;
			long ovlcnt;
			long ovlstr;
			unsigned long ovloff;
		} ovl;
	} bufovl;
	SYMENT filler;	/* to fill out to size of SYMENT */
};
#define AUXLNK2 union auxlnk2
#define AUXL2SZ (sizeof(AUXLNK2))

#define F_CC	0x00010000L	/* object file produced via C compiler */
#define F_SDI   0x00020000L	/* object file contains span-dep. instr. */

#define C_SECT  128L		/* special class for nested section symbols */
#define C_SDI	129L		/* special class for SDI symbol record */

#define T_MOD	1L		/* special module file type (maps to T_ARG) */

#define _TXT	".txt"		/* .txt section name */
#define _DAT	".dat"		/* .dat section name */
#define _CMT	".cmt"		/* .cmt comment symbol name */
#define _SDI	".sdi"		/* .sdi span-dependent instruction name */
#define _BS	".bs"		/* .bs begin section symbol name */
#define _ES	".es"		/* .es end section symbol name */
#define _TX	".tx"		/* .tx section debug name */
#define _DA	".da"		/* .da section debug name */
#define _XR	".xr"		/* .xr xref symbol name */
#define _BM	".bm"		/* .bm begin macro symbol name */
#define _EM	".em"		/* .em end macro symbol name */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\common\coreaddr.c ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#ifndef BIG_ENDIAN
#define BIG_ENDIAN 0
#endif
#include "coreaddr.h" 
#include "maout.h"

#define False	0
#define True	1

// ************************************************************
// IsMemoryP		
// ************************************************************ 
	int
IsMemoryP(int id)
{
return 
   (memory_map_p  == id ||
    memory_map_pa == id ||
    memory_map_pb == id ||
    memory_map_pe == id ||
    memory_map_pi == id ||
    memory_map_pr == id);
}	// ---- end IsMemoryP() ----

// ************************************************************
// IsMemoryX		
// ************************************************************ 
	int
IsMemoryX(int id)
{
return 
   (memory_map_x  == id ||
    memory_map_xa == id ||
    memory_map_xb == id ||
    memory_map_xe == id ||
    memory_map_xi == id ||
    memory_map_xr == id);
}	// ---- end IsMemoryX() ----

// ************************************************************
// IsMemoryY		
// ************************************************************ 
	int
IsMemoryY(int id)
{
return 
   (memory_map_y  == id ||
    memory_map_ya == id ||
    memory_map_yb == id ||
    memory_map_ye == id ||
    memory_map_yi == id ||
    memory_map_yr == id);
}	// ---- end IsMemoryY() ----

// ************************************************************
// TranslateMemoryMapID		
// ************************************************************ 
	char *
TranslateMemoryMapID(int id)
{
switch (id)
	{
	case memory_map_p:
	return ("memory_map_p");
	case memory_map_x:
	return ("memory_map_x");
	case memory_map_y:
	return ("memory_map_y");
	case memory_map_l:
	return ("memory_map_l");
	case memory_map_none:
	return ("memory_map_none");

	case memory_map_laa:
	return ("memory_map_laa");
	case memory_map_lab:
	return ("memory_map_lab");
	case memory_map_lba:
	return ("memory_map_lba");
	case memory_map_lbb:
	return ("memory_map_lbb");
	case memory_map_le:
	return ("memory_map_le");
	case memory_map_li:
	return ("memory_map_li");

	case memory_map_pa:
	return ("memory_map_pa");
	case memory_map_pb:
	return ("memory_map_pb");
	case memory_map_pe:
	return ("memory_map_pe");
	case memory_map_pi:
	return ("memory_map_pi");
	case memory_map_pr:
	return ("memory_map_pr");
		
	case memory_map_xa:
	return ("memory_map_xa");
	case memory_map_xb:
	return ("memory_map_xb");
	case memory_map_xe:
	return ("memory_map_xe");
	case memory_map_xi:
	return ("memory_map_xi");
	case memory_map_xr:
	return ("memory_map_xr");
	
	case memory_map_ya:
	return ("memory_map_ya");
	case memory_map_yb:
	return ("memory_map_yb");
	case memory_map_ye:
	return ("memory_map_ye");
	case memory_map_yi:
	return ("memory_map_yi");
	case memory_map_yr:
	return ("memory_map_yr");

	case memory_map_pt:
	return ("memory_map_pt");
	case memory_map_pf:
	return ("memory_map_pf");

	case memory_map_emi:
	return ("memory_map_emi");
	case memory_map_dm:
	return ("memory_map_dm");

	case memory_map_p8:
	return ("memory_map_p8");
	case memory_map_u:
	return ("memory_map_u");
	case memory_map_u8:
	return ("memory_map_u8");
	case memory_map_u16:
	return ("memory_map_u16");

	case memory_map_xs:
	return ("memory_map_xs");
	case memory_map_ys:
	return ("memory_map_ys");
	case memory_map_maxp1:
	return ("memory_map_maxp1");

	case memory_map_error:
	return ("memory_map_error");
	}

if (id >= memory_map_e0 && id <= memory_map_e255)
	{
// Hey static memory is bad !!
	static char s[20];
	sprintf(s, "memory_map_e%d\n", id - memory_map_e0);
	return (s);
	}
return ("Dunno");
}	// ---- end TranslateMemoryMapID() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\linenum.h ===
/*  There is one line number entry for every 
    "breakpointable" source line in a section.
    Line numbers are grouped on a per function
    basis; the first entry in a function grouping
    will have l_lnno = 0 and in place of physical
    address will be the symbol table index of
    the function name.
*/
struct lineno
{
	union
	{
		long	l_symndx ;	/* sym. table index of function name
						iff l_lnno == 0      */
		CORE_ADDR l_paddr ;	/* (physical) address of line number */
	}		l_addr ;
	unsigned long	l_lnno ;	/* line number */
} ;

#define	LINENO	struct lineno
#define	LINESZ	(sizeof(LINENO))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\maout.h ===
/*		COMMON OBJECT FILE FORMAT

    $Id: maout.h,v 1.3 1995/07/26 20:19:24 surekha Exp $

 	File Organization:

 	_______________________________________________    INCLUDE FILE
 	|_______________HEADER_DATA___________________|
 	|					      |
 	|	File Header			      |    "filehdr.h"
 	|.............................................|
 	|					      |
 	|	Auxilliary Header Information	      |	   "aouthdr.h"
 	|					      |
 	|_____________________________________________|
 	|					      |
 	|	".text" section header		      |	   "scnhdr.h"
 	|					      |
 	|.............................................|
 	|					      |
 	|	".data" section header		      |	      ''
 	|					      |
 	|.............................................|
 	|					      |
 	|	".bss" section header		      |	      ''
 	|					      |
 	|_____________________________________________|
 	|______________RAW_DATA_______________________|
 	|					      |
 	|	".text" section data (rounded to 4    |
 	|				bytes)	      |
 	|.............................................|
 	|					      |
 	|	".data" section data (rounded to 4    |
 	|				bytes)	      |
 	|_____________________________________________|
 	|____________RELOCATION_DATA__________________|
 	|					      |
 	|	".text" section relocation data	      |    "reloc.h"
 	|					      |
 	|.............................................|
 	|					      |
 	|	".data" section relocation data	      |       ''
 	|					      |
 	|_____________________________________________|
 	|__________LINE_NUMBER_DATA_(SDB)_____________|
 	|					      |
 	|	".text" section line numbers	      |    "linenum.h"
 	|					      |
 	|.............................................|
 	|					      |
 	|	".data" section line numbers	      |	      ''
 	|					      |
 	|_____________________________________________|
 	|________________SYMBOL_TABLE_________________|
 	|					      |
 	|	".text", ".data" and ".bss" section   |    "syms.h"
 	|	symbols				      |	   "storclas.h"
 	|					      |
 	|_____________________________________________|
	|________________STRING_TABLE_________________|
	|					      |
	|	    long symbol names		      |
	|_____________________________________________|



 		OBJECT FILE COMPONENTS

 	HEADER FILES:
 			/usr/include/filehdr.h
			/usr/include/aouthdr.h
			/usr/include/scnhdr.h
			/usr/include/reloc.h
			/usr/include/linenum.h
			/usr/include/syms.h
			/usr/include/storclas.h

	STANDARD FILE:
			/usr/include/maout.h    "object file" 
   */
#include "filehdr.h"
#include "aouthdr.h"
#include "scnhdr.h"
#include "reloc.h"
#include "linenum.h"
#include "syms.h"
#include "storclas.h"
/*
 * Format of an maout header
 */
 

struct	exec {	/* maout header */
	long		a_magic;	/* magic number */
	unsigned	long a_text;		/* size of text segment */
					/* in bytes		*/
					/* padded out to next	*/
					/* page boundary with	*/
					/* binary zeros.	*/
	unsigned	long a_data;		/* size of initialized data */
					/* segment in bytes	*/
					/* padded out to next	*/
					/* page boundary with	*/
					/* binary zeros.	*/
	unsigned	long a_bss;		/* Actual size of	*/
					/* uninitialized data	*/
					/* segment in bytes.	*/
	unsigned	long a_syms;		/* size of symbol table */
	CORE_ADDR a_entry;	/* entry point */
};

#define	A_MAGIC1	0407L		/* normal */
#define	A_MAGIC0	0401L		/* lpd (UNIX/RT) */
#define	A_MAGIC2	0410L		/* read-only text */
#define	A_MAGIC3	0411L		/* separated I&D */
#define	A_MAGIC4	0405L		/* overlay */
#define	A_MAGIC5	0437L		/* system overlay, separated I&D */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\reloc.h ===
struct reloc {
	long r_vaddr;	/* (virtual) address of reference */
	long	r_symndx;	/* index into symbol table */
	unsigned long	r_type;	/* relocation type */
	};

/*
 *   relocation types for all products and generics
 */

/*
 * All generics
 *	reloc. already performed to symbol in the same section
 */
#define  R_ABS		0L
#define RELOC  struct reloc
#define RELSZ sizeof(RELOC)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\filehdr.h ===
struct filehdr {
	unsigned long	f_magic;	/* magic number */
	unsigned long	f_nscns;	/* number of sections */
	long		f_timdat;	/* time & date stamp */
	long		f_symptr;	/* file pointer to symbolic header */
	long		f_nsyms;	/* sizeof(symbolic hdr) */
	unsigned long	f_opthdr;	/* sizeof(optional hdr) */
	unsigned long	f_flags;	/* flags */
	};

/*
 *   Bits for f_flags:
 *
 *	F_RELFLG	relocation info stripped from file
 *	F_EXEC		file is executable  (i.e. no unresolved
 *				externel references)
 *	F_LNNO		line nunbers stripped from file
 *	F_LSYMS		local symbols stripped from file
 *	F_MINMAL	this is a minimal object file (".m") output of fextract
 *	F_UPDATE	this is a fully bound update file, output of ogen
 *	F_SWABD		this file has had its bytes swabbed (in names)
 *	F_AR16WR	this file has the byte ordering of an AR16WR (e.g. 11/70) machine
 *				(it was created there, or was produced by conv)
 *	F_AR32WR	this file has the byte ordering of an AR32WR machine(e.g. vax)
 *	F_AR32W		this file has the byte ordering of an AR32W machine (e.g. 3b,maxi,MC68000)
 *	F_PATCH		file contains "patch" list in optional header
 *	F_NODF		(minimal file only) no decision functions for
 *				replaced functions
 */

#define  F_RELFLG	0000001L
#define  F_EXEC		0000002L
#define  F_LNNO		0000004L
#define  F_LSYMS	0000010L
#define  F_MINMAL	0000020L
#define  F_UPDATE	0000040L
#define  F_SWABD	0000100L
#define  F_AR16WR	0000200L
#define  F_AR32WR	0000400L
#define  F_AR32W	0001000L
#define  F_PATCH	0002000L
#define  F_NODF		0002000L


/* Motorola 56000/96000/56100/56300/56800/56600/SC400 */
#define   M56KMAGIC 709L
#define   M96KMAGIC 710L
#define   M16KMAGIC 711L
#define   M563MAGIC 712L
#define   M568MAGIC 713L
#define   M566MAGIC 714L
#define   SC1MAGIC 715L
#define   M567MAGIC 716L

#define	FILHDR	struct filehdr
#define	FILHSZ	sizeof(FILHDR)

/*
Don't use line continuation (e.g. backslash at end of line)
in the following macro.  It causes problems with the PC compilers
when newline characters are converted.
*/
#define ISCOFF(x) (((x)==M56KMAGIC) || ((x)==M96KMAGIC) || ((x)==M16KMAGIC) || ((x)==M563MAGIC) || ((x)==M568MAGIC) || ((x)==M566MAGIC) || ((x)==SC1MAGIC) || ((x)==M567MAGIC))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\storclas.h ===
/*
 *   STORAGE CLASSES
 */

#define  C_EFCN          -1L    /* physical end of function */
#define  C_NULL          0L
#define  C_AUTO          1L     /* automatic variable */
#define  C_EXT           2L     /* external symbol */
#define  C_STAT          3L     /* static */
#define  C_REG           4L     /* register variable */
#define  C_EXTDEF        5L     /* external definition */
#define  C_LABEL         6L     /* label */
#define  C_ULABEL        7L     /* undefined label */
#define  C_MOS           8L     /* member of structure */
#define  C_ARG           9L     /* function argument */
#define  C_STRTAG        10L    /* structure tag */
#define  C_MOU           11L    /* member of union */
#define  C_UNTAG         12L    /* union tag */
#define  C_TPDEF         13L    /* type definition */
#define C_USTATIC	 14L    /* undefined static */
#define  C_ENTAG         15L    /* enumeration tag */
#define  C_MOE           16L    /* member of enumeration */
#define  C_REGPARM	 17L    /* register parameter */
#define  C_FIELD         18L    /* bit field */
#define C_MEMREG         19L    /* memory locations used as registers */
#define C_OPTIMIZED      20L    /* objects optimized away */

#define  C_BLOCK         100L   /* ".bb" or ".eb" */
#define  C_FCN           101L   /* ".bf" or ".ef" */
#define  C_EOS           102L   /* end of structure */
#define  C_FILE          103L   /* file name */

	/*
	 * The following storage class is a "dummy" used only by STS
	 * for line number entries reformatted as symbol table entries
	 */

#define  C_LINE		 104L
#define  C_ALIAS	 105L   /* duplicate tag */
#define  C_HIDDEN	 106L   /* special storage class for external */

	/*
	 * The following storage classes support Motorola DSP assembly
	 * language symbolic debugging.
	 */

#define  A_FILE		 200L	/* assembly language source file name */
#define	 A_SECT		 201L	/* logical section start/end symbol */
#define	 A_BLOCK	 202L	/* COFF section debug symbol */
#define	 A_MACRO	 203L	/* macro debug symbol */
#define  A_GLOBAL	 210L	/* global assembly language symbol */
#define  A_XDEF		 211L	/* XDEFed assembly language symbol */
#define  A_XREF		 212L	/* XREFed assembly language symbol */
#define  A_SLOCAL	 213L	/* section local label */
#define  A_ULOCAL	 214L	/* underscore local label */
#define  A_MLOCAL	 215L	/* macro local label */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\scnhdr.h ===
struct scnhdr {
	char		s_name[8];	/* section name */
	CORE_ADDR		s_paddr;	/* physical address, aliased s_nlib */
	CORE_ADDR	s_vaddr;	/* virtual address */
	long		s_size;		/* section size */
	long		s_scnptr;	/* file ptr to raw data for section */
	long		s_relptr;	/* file ptr to relocation */
	long		s_lnnoptr;	/* file ptr to gp histogram */
	unsigned long	s_nreloc;	/* number of relocation entries */
	unsigned long	s_nlnno;	/* number of gp histogram entries */
	long		s_flags;	/* flags */
	};

/* the number of shared libraries in a .lib section in an absolute output file
 * is put in the s_paddr field of the .lib section header, the following define
 * allows it to be referenced as s_nlib
 */

#define s_nlib	s_paddr
#define	SCNHDR	struct scnhdr
#define	SCNHSZ	sizeof(SCNHDR)


/*
 * Define constants for names of "special" sections
 */

#define	_TEXT	".text"
#define	_DATA	".data"
#define	_BSS	".bss"
#define	_TV	".tv"
#define _INIT ".init"
#define _FINI ".fini"
#define _LIB ".lib"

/*
 * The low 4 bits of s_flags is used as a section "type"
 */

#define STYP_REG	0x00L		/* "regular" section:
						allocated, relocated, loaded */
#define STYP_DSECT	0x01L		/* "dummy" section:
						not allocated, relocated,
						not loaded */
#define STYP_NOLOAD	0x02L		/* "noload" section:
						allocated, relocated,
						 not loaded */
#define STYP_GROUP	0x04L		/* "grouped" section:
						formed of input sections */
#define STYP_PAD	0x08L		/* "padding" section:
						not allocated, not relocated,
						 loaded */
#define STYP_COPY	0x10L		/* "copy" section:
						for decision function used
						by field update;  not
						allocated, not relocated,
						loaded;  reloc & lineno
						entries processed normally */
#define	STYP_TEXT	0x20L		/* section contains text only */
#define STYP_DATA	0x40L		/* section contains data only */
#define STYP_BSS	0x80L		/* section contains bss only */
#define STYP_DEBUG 0x0100L /* DWARF debug section */

/*
 *  In a minimal file or an update file, a new function
 *  (as compared with a replaced function) is indicated by S_NEWFCN
 */

#define S_NEWFCN  0x100L

/*
 * In 3b Update Files (output of ogen), sections which appear in SHARED
 * segments of the Pfile will have the S_SHRSEG flag set by ogen, to inform
 * dufr that updating 1 copy of the proc. will update all process invocations.
 */
#define S_SHRSEG	0x20L

/*
 * Motorola DSP section header flags
 */
#define STYP_BLOCK	0x400L
#define STYP_OVERLAY	0x800L
#define STYP_MACRO	0x1000L
#define STYP_BW		0x2000L
#define STYP_OVERLAYP   0x4000L

/*
 * Flags added for block define pseudo instructions to identify run-time space.
 */
#define STYP_P_RUNSPACE		0x10000L
#define STYP_X_RUNSPACE		0x20000L
#define STYP_Y_RUNSPACE		0x40000L
#define STYP_EMI_RUNSPACE	0x80000L
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\rvbparam\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	rvbparam.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\include\syms.h ===
#ifndef MCOFF_SYMS_H
#define MCOFF_SYMS_H

/*	Defines for "special" symbols   */

#define _ETEXT	"etext"
#define _EDATA	"edata"
#define _END	"end"

#define _START	"__start"

/*		Storage Classes are defined in storclas.h  */
#include "storclas.h"

/*		Number of characters in a symbol name */
#define  SYMNMLEN	8
/*		Number of characters in a file name */
#define  FILNMLEN	16
/*		Number of array dimensions in auxiliary entry */
#define  DIMNUM		4


struct syment
{
	union
	{
		char		_n_name[SYMNMLEN];	/* old COFF version */
		struct
		{
			long	_n_zeroes;	/* new == 0 */
			long	_n_offset;	/* offset into string table */
		} _n_n;
		char		*_n_nptr[2];	/* allows for overlaying */
	} _n;
	union {
		CORE_ADDR _n_address; /* when an address */
		unsigned long _n_val[2]; /* _n_val[0] is least significant */
		}_n_value;	/* value of symbol */
	long			n_scnum;	/* section number */
	unsigned long		n_type;		/* type and derived type */
	long			n_sclass;	/* storage class */
	long			n_numaux;	/* number of aux. entries */
};

#define n_name		_n._n_name
#define n_nptr		_n._n_nptr[1]
#define n_zeroes	_n._n_n._n_zeroes
#define n_offset	_n._n_n._n_offset
#define n_value _n_value._n_address
/*
   Relocatable symbols have a section number of the
   section in which they are defined.  Otherwise, section
   numbers have the following meanings:
*/
        /* undefined symbol */
#define  N_UNDEF	0L
        /* value of symbol is absolute */
#define  N_ABS		-1L
        /* special debugging symbol -- value of symbol is meaningless */
#define  N_DEBUG	-2L

/*
   The fundamental type of a symbol packed into the low 
   4 bits of the word.
*/

#define  _EF	".ef"

#define  T_NULL     0L
#define  T_ARG      1L          /* function argument (only used by compiler) */
#define  T_VOID     1L          /* void */
#define  T_CHAR     2L          /* character */
#define  T_SHORT    3L          /* short integer */
#define  T_INT      4L          /* integer */
#define  T_LONG     5L          /* long integer */
#define  T_FLOAT    6L          /* floating point */
#define  T_DOUBLE   7L          /* double word */
#define  T_STRUCT   8L          /* structure  */
#define  T_UNION    9L          /* union  */
#define  T_ENUM     10L         /* enumeration  */
#define  T_MOE      11L         /* member of enumeration */
#define  T_UCHAR    12L         /* unsigned character */
#define  T_USHORT   13L         /* unsigned short */
#define  T_UINT     14L         /* unsigned integer */
#define  T_ULONG    15L         /* unsigned long */

#define  T_FRAC     0x10000L         /* fractional */
#define  T_UFRAC    0x10001L         /* unsigned fractional */
#define  T_LFRAC    0x10002L         /* long fractional */
#define  T_ULFRAC   0x10003L         /* unsigned long fractional */
#define  T_ACCUM    0x10004L         /* accumulator ext:msb*/
#define  T_LACCUM   0x10005L         /* long accumulator ext:msb:lsb */

/*
 * derived types are:
 */

#define  DT_NON      0L          /* no derived type */
#define  DT_PTR      1L          /* pointer */
#define  DT_FCN      2L          /* function */
#define  DT_ARY      3L          /* array */

/*
 *   type packing constants
 */

#define  N_BTMASK     0x1000fL
#define  N_TMASK      0x30L
#define  N_BTSHFT     4L
#define  N_TSHIFT     2L
#define  N_BTMASK_LOW 0xfL
#define  N_BTMASK_HI  0x10000L
#define  N_BTSHFT_HI  16L

/*
 *   MACROS
 */

	/*   Basic Type of  x   */

#define  BTYPE(x)  ((x) & N_BTMASK)

       /* index for extended basic types - used for table lookup */
#define  BTYPE_INDEX(x)  (((x) & N_BTMASK_LOW) | (((x) & N_BTMASK_HI) >> (N_BTSHFT_HI-N_BTSHFT)))

	/*   Is  x  a  pointer ?   */

#define  ISPTR(x)  (((x) & N_TMASK) == (DT_PTR << N_BTSHFT))

	/*   Is  x  a  function ?  */

#define  ISFCN(x)  (((x) & N_TMASK) == (DT_FCN << N_BTSHFT))

	/*   Is  x  an  array ?   */

#define  ISARY(x)  (((x) & N_TMASK) == (DT_ARY << N_BTSHFT))

	/* Is x a structure, union, or enumeration TAG? */

#define ISTAG(x)  ((x)==C_STRTAG || (x)==C_UNTAG || (x)==C_ENTAG)

#define  INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(DT_PTR<<N_BTSHFT)|(x&N_BTMASK))

#define  DECREF(x) (((((x)&~N_BTMASK)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))

/*
 *	AUXILIARY ENTRY FORMAT
 */

union auxent
{
	struct
	{
		long		x_tagndx;	/* str, un, or enum tag indx */
		union
		{
			struct
			{
				unsigned long	x_lnno;	/* declaration line number */
				unsigned long	x_size;	/* str, union, array size */
			} x_lnsz;
			long	x_fsize;	/* size of function */
		} x_misc;
		union
		{
			struct			/* if ISFCN, tag, or .bb */
			{
				long	x_lnnoptr;	/* ptr to fcn line # */
				long	x_endndx;	/* entry ndx past block end */
          unsigned long x_type; /* function prologue/epilogue type index */
			} 	x_fcn;
			struct			/* if ISARY, up to 4 dimen. */
			{
				unsigned long	x_dimen[DIMNUM];
			} 	x_ary;
		}		x_fcnary;
		unsigned long  x_tvndx;		/* tv index */
	} 	x_sym;
	struct
	{
		char	x_fname[FILNMLEN]; /* filename here if x_foff==0 */
		unsigned long x_foff; /* if !0 then x_fname in string table */
    unsigned long x_ftype; /* index indicating memory space used by file for stack */
	} 	x_file;
        struct
        {
                long    x_scnlen;          /* section length */
                unsigned long  x_nreloc;  /* number of relocation entries */
                unsigned long  x_nlinno;  /* number of line numbers */
               unsigned long x_soff; /* section name offset in string table (for named sections) */
        }       x_scn;

	struct
	{
		long		x_tvfill;	/* tv fill value */
		unsigned long	x_tvlen;	/* length of .tv */
		unsigned long	x_tvran[2];	/* tv range */
	}	x_tv;	/* info about .tv section (in auxent of symbol .tv)) */
struct syment filler; /* to fill out to size of syment */
};

#define	SYMENT	struct syment
#define	SYMESZ	(sizeof(SYMENT))

#define	AUXENT	union auxent
#define	AUXESZ	(sizeof(AUXENT)) 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\rvbparam\rvbparam.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	rvbparam.cpp

Abstract:

	Defines the entry point for the console application

Author:

	George Chrysanthakopolous

Revision History:

	21-Jun-2001 robheit
		Added support for long filenames and fixed a few bugs

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"

#define MODE_24K 24
#define MODE_48K 48


#define REVERB_EFFECT_BUFFERREVERBIONSIZE_OFFSET	17

char REVERB_EFFECT_PARAMS_FILTER[94] = {

	0,//DWORD dwMainDelayLineBase;
	1,//DWORD dwMainDelayLineSize;

	0,//DWORD dwMainDelayLine1Base;
	1,//DWORD dwMainDelayLine1Size;

	0,//DWORD dwMainDelayLine2Base;
	1,//DWORD dwMainDelayLine2Size;

	0,//DWORD dwMainDelayLine3Base;
	1,//DWORD dwMainDelayLine3Size;

	0,//DWORD dwBufferReflection0Base;
    1,//DWORD dwBufferReflection0Size;

	0,//DWORD dwBufferReflection1Base;
    1,//DWORD dwBufferReflection1Size;

	0,//DWORD dwBufferReflection2Base;
    1,//DWORD dwBufferReflection2Size;

	0,//DWORD dwBufferReflection3Base;
    1,//DWORD dwBufferReflection3Size;

	0,//DWORD dwBufferShortReverb0Base;
    1,//DWORD dwBufferShortReverb0Size;

	0,//DWORD dwBufferShortReverb1Base;
    1,//DWORD dwBufferShortReverb1Size;

	0,//DWORD dwBufferShortReverb2Base;
    1,//DWORD dwBufferShortReverb2Size;

	0,//DWORD dwBufferShortReverb3Base;
    1,//DWORD dwBufferShortReverb3Size;

	0,//DWORD dwBufferLongReverb0Base;
    1,//DWORD dwBufferLongReverb0Size;

	0,//DWORD dwBufferLongReverb1Base;
    1,//DWORD dwBufferLongReverb1Size;

	2,//DWORD dwReflectionsInputDelay0;
	2,//DWORD dwReflectionsInputDelay1;
	2,//DWORD dwReflectionsInputDelay2;
	2,//DWORD dwReflectionsInputDelay3;
	2,//DWORD dwReflectionsInputDelay4;

	2,//DWORD dwShortReverbInputDelay;

	2,//DWORD dwLongReverbInputDelay0a;
	2,//DWORD dwLongReverbInputDelay0b;

	2,//DWORD dwLongReverbInputDelay1a;
	2,//DWORD dwLongReverbInputDelay1b;

	2,//DWORD dwLongReverbInputDelay2a;
	2,//DWORD dwLongReverbInputDelay2b;

	2,//DWORD dwLongReverbInputDelay3a;
	2,//DWORD dwLongReverbInputDelay3b;

	2,//DWORD dwReflectionDelay0;
	2,//DWORD dwReflectionDelay1;
	2,//DWORD dwReflectionDelay2;
	2,//DWORD dwReflectionDelay3;

	2,//DWORD dwLongReverbDelay;

	0,//DWORD dwShortReverbInputGain_Channel0a;
	0,//DWORD dwShortReverbInputGain_Channel0b;

	0,//DWORD dwShortReverbInputGain_Channel1a;
	0,//DWORD dwShortReverbInputGain_Channel1b;

	0,//DWORD dwShortReverbInputGain_Channel2a;
	0,//DWORD dwShortReverbInputGain_Channel2b;

	0,//DWORD dwShortReverbInputGain_Channel3a;
	0,//DWORD dwShortReverbInputGain_Channel3b;

	0,//DWORD dwLongReverbInputGain;

	0,//DWORD dwLongReverbCrossfeedGain;

	0,//DWORD dwNewReflectionOutputGain_Channel0;
	0,//DWORD dwNewReflectionOutputGain_Channel1;
	0,//DWORD dwNewReflectionOutputGain_Channel2;
	0,//DWORD dwNewReflectionOutputGain_Channel3;

	0,//DWORD dwNewShortReverbOutputGain_Channel;
	0,//DWORD dwNewLongReverbOutputGain_Channel;

    0,//DWORD dwNumOutputChannels;
	0,//DWORD IIR_Input_Delay;
	0,//DWORD IIR_InputCoefficientA;
	0,//DWORD IIR_InputCoefficientB;

	0,//DWORD IIR_LongReverb_MainDelay0_Delay;
	0,//DWORD IIR_LongReverb_MainDelay0_CoefficientA;
	0,//DWORD IIR_LongReverb_MainDelay0_CoefficientB;

	0,//DWORD IIR_LongReverb_MainDelay1_Delay;
	0,//DWORD IIR_LongReverb_MainDelay1_CoefficientA;
	0,//DWORD IIR_LongReverb_MainDelay1_CoefficientB;

	0,//DWORD IIR_LongReverb_MainDelay2_Delay;
	0,//DWORD IIR_LongReverb_MainDelay2_CoefficientA;
	0,//DWORD IIR_LongReverb_MainDelay2_CoefficientB;

	0,//DWORD IIR_ShortReverb_Channel0_Delay;
	0,//DWORD IIR_ShortReverb_Channel0_CoefficientA;
	0,//DWORD IIR_ShortReverb_Channel0_CoefficientB;

	0,//DWORD IIR_ShortReverb_Channel1_Delay;
	0,//DWORD IIR_ShortReverb_Channel1_CoefficientA;
	0,//DWORD IIR_ShortReverb_Channel1_CoefficientB;

	0,//DWORD IIR_ShortReverb_Channel2_Delay;
	0,//DWORD IIR_ShortReverb_Channel2_CoefficientA;
	0,//DWORD IIR_ShortReverb_Channel2_CoefficientB;

	0,//DWORD IIR_ShortReverb_Channel3_Delay;
	0,//DWORD IIR_ShortReverb_Channel3_CoefficientA;
	0,//DWORD IIR_ShortReverb_Channel3_CoefficientB;

	0,//DWORD IIR_LongReverb_Channel0_Delay;
	0,//DWORD IIR_LongReverb_Channel0_CoefficientA;
	0,//DWORD IIR_LongReverb_Channel0_CoefficientB;

	0,//DWORD IIR_LongReverb_Channel1_Delay;
	0,//DWORD IIR_LongReverb_Channel1_CoefficientA;
	0,//DWORD IIR_LongReverb_Channel1_CoefficientB;

};



#define NUM_HEADER_STRINGS 8

CHAR *iniHeader[NUM_HEADER_STRINGS]= {

	    "[FXSTATE]",
		"FX_SCRATCHLENGTH=580000",
		"FX_NUMINPUTS=2",
		"FX_NUMOUTPUTS=35",
		"FX_YMEMSIZE=0",
		"FX_DSPCYCLES=31000",
		"FX_NUMPARAMS=512",
		" "
};

CHAR *iniHeader24k[NUM_HEADER_STRINGS]= {

	    "[FXSTATE]",
		"FX_SCRATCHLENGTH=380000",
		"FX_NUMINPUTS=2",
		"FX_NUMOUTPUTS=35",
		"FX_YMEMSIZE=0",
		"FX_DSPCYCLES=31000",
		"FX_NUMPARAMS=512",
		" "
};

#define NUM_TRAILER_STRINGS 44

CHAR *iniTrailer[NUM_TRAILER_STRINGS]= {
        ";Constants",
	    "FX_PARAM94=12582912",
		"FX_PARAM95=12582912",
		"FX_PARAM96=12582912",
		"FX_PARAM97=4194304",
		"FX_PARAM98=12582912",
		"FX_PARAM99=12582912",
		"FX_PARAM100=12582912",
		" ",
		";ReflectionsFeedbackGain",
		" ",
		"FX_PARAM101=13421773",
		"FX_PARAM102=3355443",
		"FX_PARAM103=13421773",
		"FX_PARAM104=13421773",
		" ",
		";ShortReverbInputDelayList",
		" ",
		"FX_PARAM105=0",
		"FX_PARAM106=464",
		"FX_PARAM107=1072",
		"FX_PARAM108=1856",
		"FX_PARAM109=0",
		"FX_PARAM110=464",
		"FX_PARAM111=1072",
		"FX_PARAM112=1856",
		" ",
		";ShortReverbDelayList",
		" ",
		"FX_PARAM113=11136",				// This values is equal to a buffer length and should be read from the IO file
		"FX_PARAM114=13488",				// This values is equal to a buffer length and should be read from the IO file
		"FX_PARAM115=16352",				// This values is equal to a buffer length and should be read from the IO file
		"FX_PARAM116=19824",				// This values is equal to a buffer length and should be read from the IO file
		" ",
		"; DSPBuilder settings",
		"FX_NAME=I3DL2 BATHROOM Reverb",
        "FX_CONFIG_NAME=Arena",
		"FX_DSPCODE=reverb.scr",
		"FX_INPUT0_NAME=Left",
		"FX_INPUT1_NAME=Right",
		"FX_OUTPUT0_NAME=Front Left",
		"FX_OUTPUT1_NAME=Front Right",
		"FX_OUTPUT2_NAME=Back Left",
		"FX_OUTPUT3_NAME=Back Right"
};

CHAR *iniTrailer24k[NUM_TRAILER_STRINGS]= {
        ";Constants",
	    "FX_PARAM94=12582912",
		"FX_PARAM95=12582912",
		"FX_PARAM96=12582912",
		"FX_PARAM97=4194304",
		"FX_PARAM98=12582912",
		"FX_PARAM99=12582912",
		"FX_PARAM100=12582912",
		" ",
		";ReflectionsFeedbackGain",
		" ",
		"FX_PARAM101=13421773",
		"FX_PARAM102=3355443",
		"FX_PARAM103=13421773",
		"FX_PARAM104=13421773",
		" ",
		";ShortReverbInputDelayList",
		" ",
		"FX_PARAM105=0",
		"FX_PARAM106=232",
		"FX_PARAM107=536",
		"FX_PARAM108=928",
		"FX_PARAM109=0",
		"FX_PARAM110=232",
		"FX_PARAM111=536",
		"FX_PARAM112=928",
		" ",
		";ShortReverbDelayList",
		" ",
		"FX_PARAM113=5568",				// This values is equal to a buffer length and should be read from the IO file
		"FX_PARAM114=6736",				// This values is equal to a buffer length and should be read from the IO file
		"FX_PARAM115=8176",				// This values is equal to a buffer length and should be read from the IO file
		"FX_PARAM116=9904",				// This values is equal to a buffer length and should be read from the IO file
		" ",
		"; DSPBuilder settings",
		"FX_NAME=Bathroom Reverb",
        "FX_CONFIG_NAME=Arena",
		"FX_DSPCODE=reverb.scr",
		"FX_INPUT0_NAME=Left",
		"FX_INPUT1_NAME=Right",
		"FX_OUTPUT0_NAME=Front Left",
		"FX_OUTPUT1_NAME=Front Right",
		"FX_OUTPUT2_NAME=Back Left",
		"FX_OUTPUT3_NAME=Back Right"
};

#define FXNAME_OFFSET 35

#define FX_SHORTREVERBINPUTDELAYLIST_ID 105
#define FX_SHORTREVERBINPUTDELAYLIST_COUNT 8

#define FX_SHORTREVERBDELAYLIST_ID 113
#define FX_SHORTREVERBDELAYLIST_COUNT 4

DWORD ioParams[94];


int _cdecl main(int argc, char* argv[])
{
	DWORD dwValue;
	DWORD i=0,j=0;
	CHAR szTemp[256],szParam[256];
	CHAR szInFile[MAX_PATH], szOutFile[MAX_PATH];
    FILE *inFile  = NULL;	
    FILE *outFile = NULL;	
	CHAR szFriendlyName[256];
	DWORD dwConversionFactor = 4;
    BOOL bHalfSampleRate=FALSE;					// RDA : bHalfSampleRate indicates if the system is to generate 
												//       a state file for a half sample rate system.


	REVERB_EFFECT_PARAMS rvbParams;
	PDWORD pBuffer;

	memset(&rvbParams,0,sizeof(rvbParams));

	pBuffer = (PDWORD) &rvbParams;

	//
	// convert the input file
	//

	if (argc < 4) {
        printf("\n Usage: rvbparam <friendly name> <input *.IO file> <output state INI file> [HALFSAMPLERATE]\n");
		return -1;
	}

	strcpy(szFriendlyName, argv[1]);
	strcpy(szInFile, argv[2]);
    strcpy(szOutFile, argv[3]);

	//memcpy(szFriendlyName,argv[1],sizeof(szInFile));
	//memcpy(szInFile,argv[2],sizeof(szInFile));
    //memcpy(szOutFile2,argv[3],sizeof(szOutFile2));

	// Replace all ' ' in the filenames with '_'
	for(i=0; i<strlen(szOutFile); ++i)
	{
		if(szOutFile[i] == ' ')
			szOutFile[i] = '_';
	}

	if(argc==5 && strcmp(argv[4],"HALFSAMPLERATE")==0)
		bHalfSampleRate=TRUE;


	//
	// read the parameters words, one at a time
	//

	CHAR t=0;
	DWORD dwOffset = 0;

	if (( outFile = fopen( szOutFile, "w" ) ) == NULL )
	{
		printf( "cannot open output file %s", szOutFile );
		return -1;
	}

	if (( inFile = fopen( szInFile, "r" ) ) == NULL )
	{
		printf( "cannot open input file %s", szInFile );
		return -1;
	}

    //
    // write the state file
    //

	j = 0;
	t = 0;
	dwOffset = 0;
	i = 0;

	memset(&rvbParams,0,sizeof(rvbParams));
	pBuffer = (PDWORD) &rvbParams;

	DWORD count = 0;

	//
	// write out the header
	//

    if (bHalfSampleRate == TRUE) {

        for (i=0;i<NUM_HEADER_STRINGS;i++) {
    
            sprintf(szParam,"%s\n",iniHeader24k[i]);
            fwrite((void*)szParam,strlen(szParam),1,outFile);
    
        }

    } else {

        for (i=0;i<NUM_HEADER_STRINGS;i++) {
    
            sprintf(szParam,"%s\n",iniHeader[i]);
            fwrite((void*)szParam,strlen(szParam),1,outFile);
    
        }

    }


	while (j<(sizeof(rvbParams)/sizeof(DWORD))) {

		if (fread((void*)&t,sizeof(CHAR),1,inFile) == 0) {
			if (fread((void*)&t,sizeof(CHAR),1,inFile) == 0)
				break;
		}

		

		if ((t == 0x20) || (t == 0xa)) {

			szTemp[i]=0;

			if (i>0) {

				i=0;
				dwValue = atoi(szTemp);

				//
				// filter some values. the need to be conveted
				//

				if (REVERB_EFFECT_PARAMS_FILTER[count] == 1){

					//
					// convert this value to bytes(its in dwords)
					//

					if (count <=27) {
						dwValue ++;
						dwValue *= dwConversionFactor;
						dwValue --;
					}

				} else if (count <27) {
					dwValue = 0;
				}

				if (REVERB_EFFECT_PARAMS_FILTER[count] == 2){

					//
					// convert this value to bytes(its in samples)
					//

					dwValue *= dwConversionFactor;

				}


				// Store the converted parameter
				ioParams[j]=dwValue;


                //
                // set number of outputs to 4. IO files have it to 2
                //

                if (count==63) {
					dwValue = 4;
				}



				//
				// when we reach the IIR coefficients portion of the *.IO
				// input file, we need to start writing a zero every 3 DWORD
				// since the actual DSP param layout has a delay element word
				// infront of each coeffient pair (a,b) but the sensuar data file dont
				// account for that. Their reverb used to have translation code to get around that
				// (baaaa)
				//

				if (pBuffer == &rvbParams.IIR_Input_Delay){

					dwOffset = j;			

				}


				if (dwOffset && ((j-dwOffset)%2 == 0)){
					DWORD dwTemp = 0;				
					sprintf(szParam,"FX_PARAM%d=%d\n",count,dwTemp);
					fwrite((void*)szParam,strlen(szParam),1,outFile);
					*pBuffer = dwTemp;
					pBuffer++;					
					count++;


				}

				if (dwValue < -1) {
					dwValue &=0x00FFFFFF;
				}

				*pBuffer = dwValue;
				pBuffer++;				


				sprintf(szParam,"FX_PARAM%d=%d\n",count,dwValue);
				fwrite((void*)szParam,strlen(szParam),1,outFile);

				count++;
				j++;


			}

			continue;
		}

		szTemp[i++] = t;
		
	}

	//
	// write out the trailer
	//
	int iParamValue=(sizeof(rvbParams)/sizeof(DWORD));
	BOOL bIsParam;
	for (i=0;i<NUM_TRAILER_STRINGS;i++) {

		// Check to see if this string defines a DSP parameter
		if(strncmp(iniTrailer[i],"FX_PARAM",8)==0)
			bIsParam=TRUE;
		else
			bIsParam=FALSE;

		// Write the default string from the array
		// This string is overwritten if we are writing a 'special case'
		if(!bHalfSampleRate)
			sprintf(szParam,"%s\n",iniTrailer[i]);			// Running at full sample rate.....
		else
			sprintf(szParam,"%s\n",iniTrailer24k[i]);		// Running at half sample rate.....

		// Put the proper name in the DSP builder settings
		if(i == FXNAME_OFFSET) 
		{
            if(bHalfSampleRate)
                sprintf(szParam,"FX_NAME=I3DL2 24K Reverb\n");
            else
                sprintf(szParam,"FX_NAME=I3DL2 Reverb\n");
		}

		// Put the proper name in the DSP builder settings
		else if(i == FXNAME_OFFSET+1) 
            sprintf(szParam,"FX_CONFIG_NAME=%s\n",szFriendlyName);

		// Write the correct reverb '.scr' file 
		else if(i == FXNAME_OFFSET+2)
		{
            if(bHalfSampleRate)
                sprintf(szParam,"FX_DSPCODE=reverb24k.scr\n");
            else
                sprintf(szParam,"FX_DSPCODE=reverb.scr\n");
		}

		// If processing a DSP parameter & it is a short reverb delay .......
		if(bIsParam && iParamValue>=FX_SHORTREVERBDELAYLIST_ID && iParamValue<FX_SHORTREVERBDELAYLIST_ID+FX_SHORTREVERBDELAYLIST_COUNT)
		{
			// Get the number of the short reverb (0-3)
			int iReverbID=iParamValue-FX_SHORTREVERBDELAYLIST_ID;
			// Get the length of the Short reverb buffer from the IO file
			int iBufferSize=1+ioParams[REVERB_EFFECT_BUFFERREVERBIONSIZE_OFFSET+2*iReverbID];
			// Output the modified parameter value
			sprintf(szParam,"FX_PARAM%i=%i\n",iParamValue,iBufferSize );
		}


		// Write the string to the IO file
		fwrite((void*)szParam,strlen(szParam),1,outFile);

		// If we have just processed a parameter then increment the parameter count
		if(bIsParam) iParamValue++;
	}


	fclose( inFile );
	fclose( outFile );

	return 0;
	

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\rvbparam\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__9F93952D_9A3F_4FC6_AE10_0620FDC8AA77__INCLUDED_)
#define AFX_STDAFX_H__9F93952D_9A3F_4FC6_AE10_0620FDC8AA77__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>


// TODO: reference additional headers your program requires here

#include "rvbformat.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9F93952D_9A3F_4FC6_AE10_0620FDC8AA77__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\sources.inc ===
#
# Common sources file for all Wave Bundler apps and libs
#

C_DEFINES=$(C_DEFINES) -DDPF_LIBRARY=\"WAVBNDLR\"

INCLUDES=$(INCLUDES);\
    $(DSBASEDIR)\tools\wavbndlr\common
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\internal\DSP\rvbparam\rvbformat.h ===
/*
This folder contains data files that contain sets of parameters for the reverb engine.

The format of the files is as follows:

Offset	Description
0	Host address of the base of the main delay line
1	Size-1 of host delay line measures in samples
2	Host address of the first 'long reverb' extension to the main delay line
3	Size-1 of first extension delay line measures in samples
4	Host address of the second 'long reverb' extension to the main delay line
5	Size-1 of second extension delay line measures in samples
6	Host address of the third 'long reverb' extension to the main delay line
7	Size-1 of third extension delay line measures in samples

8	Host address of the reflection delay buffer 0
9	Size-1 of reflection delay buffer 0
10	Host address of the reflection delay buffer 1
11	Size-1 of reflection delay buffer 1
12	Host address of the reflection delay buffer 2
13	Size-1 of reflection delay buffer 2
14	Host address of the reflection delay buffer 3
15	Size-1 of reflection delay buffer 3

16	Host address of the short reverb delay buffer 0
17	Size-1 of short reverb delay buffer 0
18	Host address of the short reverb delay buffer 1
19	Size-1 of short reverb delay buffer 1
20	Host address of the short reverb delay buffer 2
21	Size-1 of short reverb delay buffer 2
22	Host address of the short reverb delay buffer 3
23	Size-1 of short reverb delay buffer 3

24	Host address of the long reverb delay buffer 2
25	Size-1 of long reverb delay buffer 2
26	Host address of the long reverb delay buffer 3
27	Size-1 of long reverb delay buffer 3


28	Reflections input delay 0 measured in samples
29	Reflections input delay 1 measured in samples
30	Reflections input delay 2 measured in samples
31	Reflections input delay 3 measured in samples
32	Reflections input delay 4 measured in samples

33	Short reverb input delay measured in samples

34	Long reverb input 0a delay measured in samples
35	Long reverb input 0b delay measured in samples
36	Long reverb input 1a delay measured in samples
37	Long reverb input 1b delay measured in samples
38	Long reverb input 2a delay measured in samples
39	Long reverb input 2b delay measured in samples
40	Long reverb input 3a delay measured in samples
41	Long reverb input 3b delay measured in samples

42	Reflections delay 0 measured in samples
43	Reflections delay 1 measured in samples
44	Reflections delay 2 measured in samples
45	Reflections delay 3 measured in samples

46	Long reverb delay measured in samples

47	Short reverb channel 0a input gain * 2^23
48	Short reverb channel 0b input gain * 2^23
49	Short reverb channel 1a input gain * 2^23
50	Short reverb channel 1b input gain * 2^23
51	Short reverb channel 2a input gain * 2^23
52	Short reverb channel 2b input gain * 2^23
53	Short reverb channel 3a input gain * 2^23
54	Short reverb channel 3b input gain * 2^23

55	Long reverb input gain * 2^23

56	Long reverb crossfeed gain * 2^23

57	Reflections channel 0 output gain *2^16
58	Reflections channel 1 output gain *2^16
59	Reflections channel 2 output gain *2^16
60	Reflections channel 3 output gain *2^16

61	Short reverb output gain *2^16

62	Long reverb output gain *2^16

63	Number of channels (2 for 2 channel; 4 for 4 channels)

64	Input IIR A coefficient * 2^23
65	Input IIR B coefficient * 2^23
66	IIR Long reverb main delay extension 1 A coefficient * 2^23
67	IIR Long reverb main delay extension 1 B coefficient * 2^23
68	IIR Long reverb main delay extension 2 A coefficient * 2^23
69	IIR Long reverb main delay extension 2 B coefficient * 2^23
70	IIR Long reverb main delay extension 3 A coefficient * 2^23
71	IIR Long reverb main delay extension 3 B coefficient * 2^23

72	IIR short reverb channel 0 A coefficient * 2^23
73	IIR Short reverb channel 0 B coefficient * 2^23
74	IIR Short reverb channel 1 A coefficient * 2^23
75	IIR Short reverb channel 1 B coefficient * 2^23
76	IIR Short reverb channel 2 A coefficient * 2^23
77	IIR Short reverb channel 2 B coefficient * 2^23
78	IIR Short reverb channel 3 A coefficient * 2^23
79	IIR Short reverb channel 3 B coefficient * 2^23

80	IIR Long reverb channel 0a A coefficient * 2^23
81	IIR Long reverb channel 0b B coefficient * 2^23
82	IIR Long reverb channel 1a A coefficient * 2^23
83	IIR Long reverb channel 1b B coefficient * 2^23



All numbers are decimal integers represented in ASCII format
All delays are measured in samples, divisible by 4 and greater than 32 samples.
The maximum value for the reverb gain is 20dB (x100) so the corresponding output gain values are scaled up by 2^(23-7)=2^16 to fill the entire 24 bit data range.
Although the maximum value for the reflections gain is 10dB (x10) it is easiest to scale the gain values by 2^16 to match the reverb gain.

Other floating point values are scaled from -1 to 1 so are scaled 
by 2^23 to fill the 24 bit data range.
*/

typedef struct _REVERB_EFFECT_PARAMS {

	DWORD dwMainDelayLineBase;
	DWORD dwMainDelayLineSize;

	DWORD dwMainDelayLine1Base;
	DWORD dwMainDelayLine1Size;

	DWORD dwMainDelayLine2Base;
	DWORD dwMainDelayLine2Size;

	DWORD dwMainDelayLine3Base;
	DWORD dwMainDelayLine3Size;

	DWORD dwBufferReflection0Base;
    DWORD dwBufferReflection0Size;

	DWORD dwBufferReflection1Base;
    DWORD dwBufferReflection1Size;

	DWORD dwBufferReflection2Base;
    DWORD dwBufferReflection2Size;

	DWORD dwBufferReflection3Base;
    DWORD dwBufferReflection3Size;

	DWORD dwBufferShortReverb0Base;
    DWORD dwBufferShortReverb0Size;
	
	DWORD dwBufferShortReverb1Base;
    DWORD dwBufferShortReverb1Size;

	DWORD dwBufferShortReverb2Base;
    DWORD dwBufferShortReverb2Size;

	DWORD dwBufferShortReverb3Base;
    DWORD dwBufferShortReverb3Size;

	DWORD dwBufferLongReverb0Base;
    DWORD dwBufferLongReverb0Size;

	DWORD dwBufferLongReverb1Base;
    DWORD dwBufferLongReverb1Size;

	DWORD dwReflectionsInputDelay0;
	DWORD dwReflectionsInputDelay1;
	DWORD dwReflectionsInputDelay2;
	DWORD dwReflectionsInputDelay3;
	DWORD dwReflectionsInputDelay4;

	DWORD dwShortReverbInputDelay;

	DWORD dwLongReverbInputDelay0a;
	DWORD dwLongReverbInputDelay0b;

	DWORD dwLongReverbInputDelay1a;
	DWORD dwLongReverbInputDelay1b;

	DWORD dwLongReverbInputDelay2a;
	DWORD dwLongReverbInputDelay2b;

	DWORD dwLongReverbInputDelay3a;
	DWORD dwLongReverbInputDelay3b;

	DWORD dwReflectionDelay0;
	DWORD dwReflectionDelay1;
	DWORD dwReflectionDelay2;
	DWORD dwReflectionDelay3;

	DWORD dwLongReverbDelay;

	DWORD dwShortReverbInputGain_Channel0a;
	DWORD dwShortReverbInputGain_Channel0b;

	DWORD dwShortReverbInputGain_Channel1a;
	DWORD dwShortReverbInputGain_Channel1b;

	DWORD dwShortReverbInputGain_Channel2a;
	DWORD dwShortReverbInputGain_Channel2b;

	DWORD dwShortReverbInputGain_Channel3a;
	DWORD dwShortReverbInputGain_Channel3b;

	DWORD dwLongReverbInputGain;

	DWORD dwLongReverbCrossfeedGain;

	DWORD dwNewReflectionOutputGain_Channel0;
	DWORD dwNewReflectionOutputGain_Channel1;
	DWORD dwNewReflectionOutputGain_Channel2;
	DWORD dwNewReflectionOutputGain_Channel3;

	DWORD dwNewShortReverbOutputGain_Channel;
	DWORD dwNewLongReverbOutputGain_Channel;

    DWORD dwNumOutputChannels;
	DWORD IIR_Input_Delay;
	DWORD IIR_InputCoefficientA;
	DWORD IIR_InputCoefficientB;

	DWORD IIR_LongReverb_MainDelay0_Delay;
	DWORD IIR_LongReverb_MainDelay0_CoefficientA;
	DWORD IIR_LongReverb_MainDelay0_CoefficientB;

	DWORD IIR_LongReverb_MainDelay1_Delay;
	DWORD IIR_LongReverb_MainDelay1_CoefficientA;
	DWORD IIR_LongReverb_MainDelay1_CoefficientB;

	DWORD IIR_LongReverb_MainDelay2_Delay;
	DWORD IIR_LongReverb_MainDelay2_CoefficientA;
	DWORD IIR_LongReverb_MainDelay2_CoefficientB;

	DWORD IIR_ShortReverb_Channel0_Delay;
	DWORD IIR_ShortReverb_Channel0_CoefficientA;
	DWORD IIR_ShortReverb_Channel0_CoefficientB;

	DWORD IIR_ShortReverb_Channel1_Delay;
	DWORD IIR_ShortReverb_Channel1_CoefficientA;
	DWORD IIR_ShortReverb_Channel1_CoefficientB;

	DWORD IIR_ShortReverb_Channel2_Delay;
	DWORD IIR_ShortReverb_Channel2_CoefficientA;
	DWORD IIR_ShortReverb_Channel2_CoefficientB;

	DWORD IIR_ShortReverb_Channel3_Delay;
	DWORD IIR_ShortReverb_Channel3_CoefficientA;
	DWORD IIR_ShortReverb_Channel3_CoefficientB;

	DWORD IIR_LongReverb_Channel0_Delay;
	DWORD IIR_LongReverb_Channel0_CoefficientA;
	DWORD IIR_LongReverb_Channel0_CoefficientB;

	DWORD IIR_LongReverb_Channel1_Delay;
	DWORD IIR_LongReverb_Channel1_CoefficientA;
	DWORD IIR_LongReverb_Channel1_CoefficientB;

} REVERB_EFFECT_PARAMS, *PREVERB_EFFECT_PARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\dscommon.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscommon.cpp
 *  Content:    DirectSound common source file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/10/01    dereks  Created.
 *
 ***************************************************************************/

#include "..\..\..\common\dscommon.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\VOXSUX\voxsux.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voxsux.cpp
 *  Content:    Sets the Voxware ACM CODEC to the lowest possible priority.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/29/01    dereks  Created.
 *
 ****************************************************************************/

#include <windows.h>

//
// Basic linked-list template class
//

template <class type> class CList
{
protected:
    type *                  m_pHead;        // Pointer to the head of the list
    type *                  m_pTail;        // Pointer to the tail of the list

public:
    CList(void);

public:
    // Node creation, removal
    void AddNode(type *pNode);
    void InsertNode(type *pPrev, type *pNode);
    void RemoveNode(type *pNode);
    void Reset(void);
    
    // Basic list information
    type *GetListHead(void);
    type *GetListTail(void);
};


template <class type>
CList<type>::CList
(
    void
)
{
    m_pHead = NULL;
    m_pTail = NULL;
}


template <class type>
void
CList<type>::AddNode
(
    type *                  pNode
)
{
    InsertNode(m_pTail, pNode);
}


template <class type>
void
CList<type>::InsertNode
(
    type *                  pPrev, 
    type *                  pNode
)                           
{                           
    type *                  pNext   = pPrev ? pPrev->pNext : m_pHead;

    // ASSERT(!pNode->pPrev);
    // ASSERT(!pNode->pNext);

    if(pPrev)
    {
        pPrev->pNext = pNode;
    }

    if(pNext)
    {
        pNext->pPrev = pNode;
    }

    pNode->pPrev = pPrev;
    pNode->pNext = pNext;

    if(m_pHead && m_pTail)
    {
        if(m_pHead == pNext)
        {
            m_pHead = pNode;
        }

        if(m_pTail == pPrev)
        {
            m_pTail = pNode;
        }
    }
    else
    {
        // ASSERT(!m_pHead);
        // ASSERT(!m_pTail);
        
        m_pHead = m_pTail = pNode;
    }
}


template <class type>
void 
CList<type>::RemoveNode
(
    type *                  pNode
)
{
    // ASSERT(pNode);
    
    if(pNode->pPrev)
    {
        pNode->pPrev->pNext = pNode->pNext;
    }

    if(pNode->pNext)
    {
        pNode->pNext->pPrev = pNode->pPrev;
    }

    if(pNode == m_pHead)
    {
        m_pHead = pNode->pNext;
    }

    if(pNode == m_pTail)
    {
        m_pTail = pNode->pPrev;
    }

    pNode->pPrev = NULL;
    pNode->pNext = NULL;
}


template <class type>
void 
CList<type>::Reset
(
    void
)
{
    type *                  pNode   = m_pHead;
    type *                  pNext;

    while(pNode)
    {
        pNext = pNode->pNext;

        pNode->pPrev = NULL;
        pNode->pNext = NULL;

        pNode = pNext;
    }

    m_pHead = NULL;
    m_pTail = NULL;
}


template <class type>
type *
CList<type>::GetListHead
(
    void
)
{ 
    return m_pHead;
}


template <class type>
type *
CList<type>::GetListTail
(
    void
)
{ 
    return m_pTail;
}


//
// String node class
//

class CStringNode
{
public:
    CStringNode *           pPrev;
    CStringNode *           pNext;
    LPSTR                   psz;

public:
    CStringNode(void);
    ~CStringNode(void);

public:
    BOOL Init(LPCSTR psz);
};


CStringNode::CStringNode
(
    void
)
{
    pPrev = NULL;
    pNext = NULL;
    psz = NULL;
}


CStringNode::~CStringNode
(
    void
)
{
    if(psz)
    {
        LocalFree(psz);
    }
}


BOOL
CStringNode::Init
(
    LPCSTR                  pszNew
)
{
    UINT                    nStrLen;

    nStrLen = strlen(pszNew) + 1;

    if(psz = (LPSTR)LocalAlloc(LPTR, nStrLen))
    {
        memcpy(psz, pszNew, nStrLen);
    }
    
    return !!psz;
}


/****************************************************************************
 *
 *  GetPriorityString
 *
 *  Description:
 *      Gets the name for a codec priority value.
 *
 *  Arguments:
 *      DWORD [in]: priority.
 *      LPSTR [out]: priority value string.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

__inline void
GetPriorityString
(
    DWORD                   dwPriority,
    LPSTR                   pszValueName
)
{
    wsprintf(pszValueName, "Priority%lu", dwPriority + 1);
}


/****************************************************************************
 *
 *  CreateCodecNode
 *
 *  Description:
 *      Creates and initializes a codec node.
 *
 *  Arguments:
 *      LPCSTR [in]: codec priority data.
 *      CList & [in]: codec list.
 *
 *  Returns:  
 *      LONG: Win32 error code.
 *
 ****************************************************************************/

LONG
CreateCodecNode
(
    LPCSTR                  pszCodec,
    CList<CStringNode> &    lstCodecs,
    CStringNode **          ppCodecNode = NULL
)
{
    CStringNode *           pCodecNode;

    if(!(pCodecNode = new CStringNode))
    {
        return ERROR_OUTOFMEMORY;
    }

    if(!pCodecNode->Init(pszCodec))
    {
        delete pCodecNode;
        return ERROR_OUTOFMEMORY;
    }

    lstCodecs.AddNode(pCodecNode);

    if(ppCodecNode)
    {
        *ppCodecNode = pCodecNode;
    }

    return 0;
}


/****************************************************************************
 *
 *  FreeCodecNode
 *
 *  Description:
 *      Releases a codec node.
 *
 *  Arguments:
 *      CStringNode * [in]: codec node.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
FreeCodecNode
(
    CList<CStringNode> &    lstCodecs,
    CStringNode *           pCodecNode
)
{
    lstCodecs.RemoveNode(pCodecNode);

    delete pCodecNode;
}


/****************************************************************************
 *
 *  GetPriorityCodec
 *
 *  Description:
 *      Gets the name of a codec from the priority list and adds it to our
 *      own.
 *
 *  Arguments:
 *      HKEY [in]: registry key.
 *      DWORD [in]: priority value.
 *      CList & [in]: codec list.
 *      LPLONG [out]: status code.
 *
 *  Returns:  
 *      BOOL: TRUE if enumeration should continue.
 *
 ****************************************************************************/

BOOL
GetPriorityCodec
(
    HKEY                    hkey,
    DWORD                   dwPriority,
    CList<CStringNode> &    lstCodecs,
    LPLONG                  plStatus
)
{
    CHAR                    szValueName[0x100];
    CHAR                    szValueData[0x100];
    DWORD                   dwType;
    DWORD                   dwSize;
    LONG                    lStatus;

    GetPriorityString(dwPriority, szValueName);

    dwSize = sizeof(szValueData);
    
    if(lStatus = RegQueryValueEx(hkey, szValueName, NULL, &dwType, (LPBYTE)szValueData, &dwSize))
    {
        if(ERROR_FILE_NOT_FOUND == lStatus)
        {
            lStatus = 0;
        }
        
        *plStatus = lStatus;
        return FALSE;
    }

    if(REG_SZ != dwType)
    {
        *plStatus = ERROR_INVALID_DATA;
        return FALSE;
    }

    if(lStatus = CreateCodecNode(szValueData, lstCodecs))
    {
        *plStatus = lStatus;
        return FALSE;
    }

    *plStatus = 0;
    
    return TRUE;
}


/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      INT: Win32 error code (0 on success).
 *
 ****************************************************************************/
 
INT
main
(
    void
)
{
    static const LPCSTR     pszRegKey           = "Software\\Microsoft\\Multimedia\\Audio Compression Manager\\Priority v4.00";
    static const LPCSTR     pszVoxName          = "msacm.voxacm160";
    static const LPCSTR     pszXBName           = "msacm.xbadpcm";
    static const LPCSTR     pszXBFull           = "1, msacm.xbadpcm";
    HKEY                    hkey                = 0;
    LONG                    lStatus;
    DWORD                   dwPriority;
    CList<CStringNode>      lstCodecs;
    CStringNode *           pCodecNode;
    CHAR                    szValueName[0x100];

    //
    // Open the ACM priority registry key
    //

    lStatus = RegOpenKey(HKEY_CURRENT_USER, pszRegKey, &hkey);

    //
    // Enumerate all existing priority values and add them to the codec
    // list.
    //

    for(dwPriority = 0; !lStatus; dwPriority++)
    {
        if(!GetPriorityCodec(hkey, dwPriority, lstCodecs, &lStatus))
        {
            break;
        }
    }

    //
    // Make sure the Xbox ADPCM codec is in the list
    //

    if(!lStatus)
    {
        for(pCodecNode = lstCodecs.GetListHead(); pCodecNode; pCodecNode = pCodecNode->pNext)
        {
            if(strstr(pCodecNode->psz, pszXBName))
            {
                break;
            }
        }

        if(pCodecNode)
        {
            FreeCodecNode(lstCodecs, pCodecNode);
        }

        lStatus = CreateCodecNode(pszXBFull, lstCodecs);
    }

    //
    // Look for the Voxware codec.  If we find it, move it to the end
    // of the list and rewrite the registry list.
    //

    if(!lStatus)
    {
        for(pCodecNode = lstCodecs.GetListHead(); pCodecNode; pCodecNode = pCodecNode->pNext)
        {
            if(strstr(pCodecNode->psz, pszVoxName))
            {
                break;
            }
        }

        if(pCodecNode)
        {
            lstCodecs.RemoveNode(pCodecNode);
            lstCodecs.AddNode(pCodecNode);

            for(pCodecNode = lstCodecs.GetListHead(), dwPriority = 0; pCodecNode && !lStatus; pCodecNode = pCodecNode->pNext, dwPriority++)
            {
                GetPriorityString(dwPriority, szValueName);
    
                lStatus = RegSetValueEx(hkey, szValueName, 0, REG_SZ, (LPBYTE)pCodecNode->psz, strlen(pCodecNode->psz) + 1);
            }
        }
    }

    //
    // Clean up
    //

    while(pCodecNode = lstCodecs.GetListHead())
    {
        FreeCodecNode(lstCodecs, pCodecNode);
    }

    if(hkey)
    {
        RegCloseKey(hkey);
    }

    return lStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\wbcommon.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 12/11/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wbcommon.cpp
 *  Content:    Wave Bundler common source files.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/11/2001   dereks  Created.
 *
 ****************************************************************************/
 
#include "wavbndli.h"
#include "format2.cpp"

#ifndef _XBOX

#include "filter.cpp"
#include "writer.cpp"

#include "..\..\..\common\dscommon.cpp"

#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\filter.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/27/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       filter.h
 *  Content:    Filter classes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/27/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __FILTER_H__
#define __FILTER_H__

//
// Public filter types
//

#define WBFILTER_ADPCM  0x00000001
#define WBFILTER_8BIT   0x00000002
#define WBFILTER_MASK   0x00000003

#ifdef __cplusplus

//
// Xbox ADPCM filter
//

class CXboxAdpcmFilter
    : protected CImaAdpcmCodec
{
public:
    CXboxAdpcmFilter(void);
    virtual ~CXboxAdpcmFilter(void);

public:
    // Filter name
    static LPCSTR GetName(void);
    
    // Initialization
    virtual BOOL Initialize(LPCWAVEBANKMINIWAVEFORMAT pwfxSource);

    // Format
    static BOOL IsValidFormat(LPCWAVEBANKMINIWAVEFORMAT pwfxFormat);
    static BOOL ConvertFormat(LPWAVEBANKMINIWAVEFORMAT pwfxFormat);

    // Sizes
    static DWORD GetSourceAlignment(DWORD nChannels);
    virtual DWORD GetSourceAlignment(void);
    static DWORD GetDestinationAlignment(DWORD nChannels);
    virtual DWORD GetDestinationAlignment(void);
    static DWORD GetSize(DWORD cbSource, DWORD nChannels, BOOL fRoundUp = FALSE);
    virtual DWORD GetSize(DWORD cbSource, BOOL fRoundUp = FALSE);

    // Data conversion
    virtual BOOL Convert(LPCVOID pvSource, LPDWORD pcbRead, LPVOID pvDest, LPDWORD pcbWritten);
};

__inline LPCSTR CXboxAdpcmFilter::GetName(void)
{
    return "ADPCM";
}

__inline DWORD CXboxAdpcmFilter::GetSourceAlignment(DWORD nChannels)
{
    return nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;
}

__inline DWORD CXboxAdpcmFilter::GetSourceAlignment(void)
{
    return m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;
}

__inline DWORD CXboxAdpcmFilter::GetDestinationAlignment(DWORD nChannels)
{
    return nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
}

__inline DWORD CXboxAdpcmFilter::GetDestinationAlignment(void)
{
    return m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
}

__inline DWORD CXboxAdpcmFilter::GetSize(DWORD cbSource, DWORD nChannels, BOOL fRoundUp)
{
    const DWORD             cbSrcAlign  = GetSourceAlignment(nChannels);
    const DWORD             cbDstAlign  = GetDestinationAlignment(nChannels);
    
    if(fRoundUp)
    {
        cbSource += cbSrcAlign - 1;
    }

    cbSource /= cbSrcAlign;
    cbSource *= cbDstAlign;
    
    return cbSource;
}

__inline DWORD CXboxAdpcmFilter::GetSize(DWORD cbSource, BOOL fRoundUp)
{
    return GetSize(cbSource, m_wfxEncode.wfx.nChannels, fRoundUp);
}

//
// 16- to 8-bit filter
//

class C8BitFilter
{
protected:
    DWORD                   m_nChannels;    // Channel count

public:
    C8BitFilter(void);
    virtual ~C8BitFilter(void);

public:
    // Filter name
    static LPCSTR GetName(void);
    
    // Initialization
    virtual BOOL Initialize(LPCWAVEBANKMINIWAVEFORMAT pwfxSource);

    // Format
    static BOOL IsValidFormat(LPCWAVEBANKMINIWAVEFORMAT pwfxFormat);
    static BOOL ConvertFormat(LPWAVEBANKMINIWAVEFORMAT pwfxFormat);

    // Sizes
    static DWORD GetSourceAlignment(DWORD nChannels);
    virtual DWORD GetSourceAlignment(void);
    static DWORD GetDestinationAlignment(DWORD nChannels);
    virtual DWORD GetDestinationAlignment(void);
    static DWORD GetSize(DWORD cbSource, DWORD nChannels);
    virtual DWORD GetSize(DWORD cbSource);

    // Data conversion
    virtual BOOL Convert(LPCVOID pvSource, LPDWORD pcbRead, LPVOID pvDest, LPDWORD pcbWritten);
};
    
__inline LPCSTR C8BitFilter::GetName(void)
{
    return "8-bit";
}

__inline DWORD C8BitFilter::GetSourceAlignment(DWORD nChannels)
{
    return nChannels * 2;
}

__inline DWORD C8BitFilter::GetSourceAlignment(void)
{
    return m_nChannels * 2;
}

__inline DWORD C8BitFilter::GetDestinationAlignment(DWORD nChannels)
{
    return nChannels;
}

__inline DWORD C8BitFilter::GetDestinationAlignment(void)
{
    return m_nChannels;
}

__inline DWORD C8BitFilter::GetSize(DWORD cbSource, DWORD nChannels)
{
    return cbSource / (nChannels * 2) * nChannels;
}

__inline DWORD C8BitFilter::GetSize(DWORD cbSource)
{
    return cbSource / (m_nChannels * 2) * m_nChannels;
}

#endif // __cplusplus

#endif // __FILTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\wavbndli.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/2/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wavbndli.h
 *  Content:    Wave Bundler common library definitions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/2/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WAVBNDLI_H__
#define __WAVBNDLI_H__

#ifndef _XBOX
#define USEDPF
#define DPFLVL_DEFAULT DPFLVL_INFO
#endif // _XBOX

#include "..\..\..\common\dscommon.h"
#include "xboxverp.h"
#include "wavbndlr.h"

#ifndef _XBOX

#ifndef _CONSOLE

EXTERN_C HWND g_hwndMain;
EXTERN_C LPCSTR g_pszAppTitle;

#endif // _CONSOLE

#include "imaadpcm.h"
#include "filter.h"
#include "writer.h"

#endif // _XBOX

static void GetWaveBundlerVersion(LPSTR pszString)
{
    static const DWORD      dwMajor = (VER_PRODUCTVERSION_DW >> 24) & 0xFF;
    static const DWORD      dwMinor = (VER_PRODUCTVERSION_DW >> 16) & 0xFF;
    static const DWORD      dwBuild = VER_PRODUCTVERSION_DW & 0xFFFF;
    
    sprintf(pszString, "%lu.%lu.%lu", dwMajor, dwMinor, dwBuild);
}

#endif // __WAVBNDLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\wberror.h ===
/***************************************************************************
 *
 *  Copyright (C) 1/29/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wberror.h
 *  Content:    Wave Bundler error codes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/29/2002   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WBERROR_H__
#define __WBERROR_H__

#define FACILITY_WBND       50

#define MAKE_WBND_HRESULT(code) \
    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WBND, code)
    
enum
{
    WBND_ERROR_BADFORMAT = 0,
    WBND_ERROR_SIGNATURE,
    WBND_ERROR_VERSION,
    WBND_ERROR_ENTRYEXISTS,
    WBND_ERROR_FILTERINIT,
    WBND_ERROR_COMPRESS,
    WBND_ERROR_BANKEXISTS,
    WBND_ERROR_BANKFILEEXISTS,
    WBND_ERROR_HEADERFILEEXISTS,
    WBND_ERROR_NOENTRIES,
};

#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_BADFORMAT)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_SIGNATURE)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_VERSION)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_ENTRYEXISTS)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_FILTERINIT)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_COMPRESS)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_BANKEXISTS)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_BANKFILEEXISTS)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_HEADERFILEEXISTS)
#define WBND_BADFORMAT      MAKE_WBND_HRESULT(WBND_ERROR_NOENTRIES)

#include "namespc.h"

EXTERN_C LPCSTR WbndTranslateError(HRESULT hr);

#include "namespc.h"

#endif // __WBERROR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\wbnderr.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1/29/2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wberror.cpp
 *  Content:    Wave Bundler error codes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/29/2002   dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\format2.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/27/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       format2.cpp
 *  Content:    Format conversion helpers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/27/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"

using namespace DirectSound::WaveFormat;


/****************************************************************************
 *
 *  WaveBankExpandFormat
 *
 *  Description:
 *      Expands a compressed wave format to a standard format structure.
 *
 *  Arguments:
 *      LPCWAVEBANKMINIWAVEFORMAT [in]: compressed format.
 *      LPWAVEBANKUNIWAVEFORMAT [out]: standard format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveBankExpandFormat"

BOOL 
WaveBankExpandFormat
(
    LPCWAVEBANKMINIWAVEFORMAT  pwfxCompressed, 
    LPWAVEBANKUNIWAVEFORMAT    pwfxExpanded
)
{
    DPF_ENTER();

    if(WAVEBANKMINIFORMAT_TAG_ADPCM == pwfxCompressed->wFormatTag)
    {
        XAudioCreateAdpcmFormat((WORD)pwfxCompressed->nChannels, pwfxCompressed->nSamplesPerSec, &pwfxExpanded->AdpcmWaveFormat);
    }
    else
    {
        XAudioCreatePcmFormat((WORD)pwfxCompressed->nChannels, pwfxCompressed->nSamplesPerSec, (WAVEBANKMINIFORMAT_BITDEPTH_16 == pwfxCompressed->wBitsPerSample) ? 16 : 8, &pwfxExpanded->WaveFormatEx);
    }

    DPF_LEAVE(TRUE);

    return TRUE;
}


/****************************************************************************
 *
 *  WaveBankCompressFormat
 *
 *  Description:
 *      Converts a standard format structure to a compressed wave format.
 *
 *  Arguments:
 *      LPCWAVEBANKUNIWAVEFORMAT [in]: standard format.
 *      LPWAVEBANKMINIWAVEFORMAT [out]: compressed format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaveBankCompressFormat"

BOOL 
WaveBankCompressFormat
(
    LPCWAVEBANKUNIWAVEFORMAT   pwfxExpanded,
    LPWAVEBANKMINIWAVEFORMAT   pwfxCompressed
)
{
    BOOL                        fValid;

    DPF_ENTER();

    if(WAVE_FORMAT_PCM == pwfxExpanded->WaveFormatEx.wFormatTag)
    {
        if(fValid = IsValidPcmFormat(&pwfxExpanded->WaveFormatEx))
        {
            pwfxCompressed->wFormatTag = WAVEBANKMINIFORMAT_TAG_PCM;
            pwfxCompressed->nChannels = pwfxExpanded->WaveFormatEx.nChannels;
            pwfxCompressed->nSamplesPerSec = pwfxExpanded->WaveFormatEx.nSamplesPerSec;
            pwfxCompressed->wBitsPerSample = (16 == pwfxExpanded->WaveFormatEx.wBitsPerSample) ? WAVEBANKMINIFORMAT_BITDEPTH_16 : WAVEBANKMINIFORMAT_BITDEPTH_8;
        }
    }
    else if(WAVE_FORMAT_XBOX_ADPCM == pwfxExpanded->WaveFormatEx.wFormatTag)
    {
        if(fValid = IsValidAdpcmFormat(&pwfxExpanded->AdpcmWaveFormat))
        {
            pwfxCompressed->wFormatTag = WAVEBANKMINIFORMAT_TAG_ADPCM;
            pwfxCompressed->nChannels = pwfxExpanded->WaveFormatEx.nChannels;
            pwfxCompressed->nSamplesPerSec = pwfxExpanded->WaveFormatEx.nSamplesPerSec;
            pwfxCompressed->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_4;
        }
    }
    else
    {
        DPF_ERROR("Unsupported format tag");
        fValid = FALSE;
    }   

    DPF_LEAVE(fValid);

    return fValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\filter.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/27/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       filter.cpp
 *  Content:    Filter classes.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/27/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"


/****************************************************************************
 *
 *  CXboxAdpcmFilter
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::CXboxAdpcmFilter"

CXboxAdpcmFilter::CXboxAdpcmFilter
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CXboxAdpcmFilter
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::~CXboxAdpcmFilter"

CXboxAdpcmFilter::~CXboxAdpcmFilter
(
    void
)
{
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCWAVEBANKMINIWAVEFORMAT [in]: source format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::Initialize"

BOOL
CXboxAdpcmFilter::Initialize
(
    LPCWAVEBANKMINIWAVEFORMAT   pwfxSource
)
{
    WAVEBANKMINIWAVEFORMAT      wfxDest     = *pwfxSource;
    WAVEBANKUNIWAVEFORMAT       wfxExpanded;

    if(!ConvertFormat(&wfxDest))
    {
        return FALSE;
    }

    if(!WaveBankExpandFormat(&wfxDest, &wfxExpanded))
    {
        return FALSE;
    }

    return CImaAdpcmCodec::Initialize(&wfxExpanded.AdpcmWaveFormat, TRUE);
}


/****************************************************************************
 *
 *  IsValidFormat
 *
 *  Description:
 *      Checks a source format for validity.
 *
 *  Arguments:
 *      LPWAVEBANKMINIWAVEFORMAT [in/out]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::IsValidFormat"

BOOL 
CXboxAdpcmFilter::IsValidFormat
(
    LPCWAVEBANKMINIWAVEFORMAT  pwfxFormat
)
{
    if(WAVEBANKMINIFORMAT_TAG_PCM != pwfxFormat->wFormatTag)
    {
        return FALSE;
    }

    if((pwfxFormat->nChannels < 1) || (pwfxFormat->nChannels > 2))
    {
        return FALSE;
    }

    if(WAVEBANKMINIFORMAT_BITDEPTH_16 != pwfxFormat->wBitsPerSample)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  ConvertFormat
 *
 *  Description:
 *      Converts a source format to a destination.
 *
 *  Arguments:
 *      LPWAVEBANKMINIWAVEFORMAT [in/out]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::ConvertFormat"

BOOL 
CXboxAdpcmFilter::ConvertFormat
(
    LPWAVEBANKMINIWAVEFORMAT   pwfxFormat
)
{
    if(!IsValidFormat(pwfxFormat))
    {
        return FALSE;
    }

    pwfxFormat->wFormatTag = WAVEBANKMINIFORMAT_TAG_ADPCM;
    pwfxFormat->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_4;

    return TRUE;
}


/****************************************************************************
 *
 *  Convert
 *
 *  Description:
 *      Converts data.
 *
 *  Arguments:
 *      LPCVOID [in]: source buffer.
 *      DWORD [in/out]: source buffer size, in bytes.
 *      LPVOID [out]: destination buffer.
 *      DWORD [in/out]: destination buffer size, in bytes.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CXboxAdpcmFilter::Convert"

BOOL
CXboxAdpcmFilter::Convert
(
    LPCVOID                 pvSource,
    LPDWORD                 pcbSource,
    LPVOID                  pvDest,
    LPDWORD                 pcbDest
)
{
    DWORD                   cBlocks;

    //
    // Convert byte sizes to blocks
    //

    *pcbSource /= m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;
    *pcbDest /= m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;
    
    cBlocks = min(*pcbSource, *pcbDest);

    *pcbSource = cBlocks * m_wfxEncode.wfx.nChannels * 2 * XBOX_ADPCM_SAMPLES_PER_BLOCK;
    *pcbDest = cBlocks * m_wfxEncode.wfx.nChannels * XBOX_ADPCM_ENCODED_BLOCK_SIZE;

    //
    // Convert data
    //

    return CImaAdpcmCodec::Convert(pvSource, pvDest, cBlocks);
}


/****************************************************************************
 *
 *  C8BitFilter
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::C8BitFilter"

C8BitFilter::C8BitFilter
(
    void
)
{
}


/****************************************************************************
 *
 *  ~C8BitFilter
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::~C8BitFilter"

C8BitFilter::~C8BitFilter
(
    void
)
{
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCWAVEBANKMINIWAVEFORMAT [in]: source format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::Initialize"

BOOL
C8BitFilter::Initialize
(
    LPCWAVEBANKMINIWAVEFORMAT  pwfxSource
)
{
    if(!IsValidFormat(pwfxSource))
    {
        return FALSE;
    }
    
    m_nChannels = pwfxSource->nChannels;
    
    return TRUE;
}


/****************************************************************************
 *
 *  IsValidFormat
 *
 *  Description:
 *      Checks a source format for validity.
 *
 *  Arguments:
 *      LPWAVEBANKMINIWAVEFORMAT [in/out]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::IsValidFormat"

BOOL 
C8BitFilter::IsValidFormat
(
    LPCWAVEBANKMINIWAVEFORMAT  pwfxFormat
)
{
    if(WAVEBANKMINIFORMAT_TAG_PCM != pwfxFormat->wFormatTag)
    {
        return FALSE;
    }

    if(WAVEBANKMINIFORMAT_BITDEPTH_16 != pwfxFormat->wBitsPerSample)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  ConvertFormat
 *
 *  Description:
 *      Converts a source format to a destination.
 *
 *  Arguments:
 *      LPWAVEBANKMINIWAVEFORMAT [in/out]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::ConvertFormat"

BOOL 
C8BitFilter::ConvertFormat
(
    LPWAVEBANKMINIWAVEFORMAT   pwfxFormat
)
{
    if(!IsValidFormat(pwfxFormat))
    {
        return FALSE;
    }

    pwfxFormat->wBitsPerSample = WAVEBANKMINIFORMAT_BITDEPTH_8;

    return TRUE;
}


/****************************************************************************
 *
 *  Convert
 *
 *  Description:
 *      Converts data.
 *
 *  Arguments:
 *      LPCVOID [in]: source buffer.
 *      DWORD [in/out]: source buffer size, in bytes.
 *      LPVOID [out]: destination buffer.
 *      DWORD [in/out]: destination buffer size, in bytes.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "C8BitFilter::Convert"

BOOL
C8BitFilter::Convert
(
    LPCVOID                 pvSource,
    LPDWORD                 pcbSource,
    LPVOID                  pvDest,
    LPDWORD                 pcbDest
)
{
    const short *           psSource    = (const short *)pvSource;
    unsigned char *         pbDest      = (unsigned char *)pvDest;
    DWORD                   cSamples;
    DWORD                   dwSample;

    //
    // Convert byte sizes to samples
    //

    *pcbSource /= m_nChannels * 2;
    *pcbDest /= m_nChannels;
    
    cSamples = min(*pcbSource, *pcbDest);

    *pcbSource = cSamples * m_nChannels * 2;
    *pcbDest = cSamples * m_nChannels;

    //
    // Convert data
    //

    cSamples *= m_nChannels;
    
    while(cSamples--)
    {
        dwSample = *psSource + 32768;
        *pbDest = (BYTE)(dwSample >> 8);

        pbDest++;
        psSource++;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\writer.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/2/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       writer.cpp
 *  Content:    Wave bank writer.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/2/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wavbndli.h"


/****************************************************************************
 *
 *  MakeHeaderString
 *
 *  Description:
 *      Removes all spaces from a string and replaces them with underscores.
 *
 *  Arguments:
 *      LPSTR [in/out]: string.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MakeHeaderString"

void
MakeHeaderString
(
    LPSTR                   pszString
)
{
    while(*pszString)
    {
        if((*pszString >= 'a') && (*pszString <= 'z'))
        {
            *pszString = 'A' + *pszString - 'a';
        }
        else if((*pszString >= 'A') && (*pszString <= 'Z'))
        {
        }
        else if((*pszString >= '0') && (*pszString <= '9'))
        {
        }
        else
        {
            *pszString = '_';
        }

        pszString++;
    }
}


/****************************************************************************
 *
 *  ExtractDirectory
 *
 *  Description:
 *      Extracts the first directory from a path.
 *
 *  Arguments:
 *      LPSTR [in]: path.
 *      LPSTR [out]: directory name.
 *
 *  Returns:  
 *      LPSTR: path.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ExtractDirectory"

LPSTR
ExtractDirectory
(
    LPSTR                   pszSrc,
    LPSTR                   pszDst
)
{
    if('\\' == *pszSrc)
    {
        pszSrc++;
    }

    while(TRUE)
    {
        if('\\' == *pszSrc)
        {
            *pszDst = 0;
            pszSrc++;
            break;
        }
        
        *pszDst = *pszSrc;

        if(!*pszDst)
        {
            break;
        }

        pszDst++;
        pszSrc++;
    }

    return pszSrc;
}


/****************************************************************************
 *
 *  GetRelativePath
 *
 *  Description:
 *      Converts an absolute path to a relative one.
 *
 *  Arguments:
 *      LPCSTR [in]: parent path.
 *      LPCSTR [in]: child path.
 *      LPSTR [out]: relative path.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetRelativePath"

void
GetRelativePath
(
    LPCSTR                  pszInputParentPath,
    LPCSTR                  pszInputChildPath,
    LPSTR                   pszRelativePath
)
{
    BOOL                    fSuccess                = TRUE;
    CHAR                    szParentPath[MAX_PATH];
    CHAR                    szChildPath[MAX_PATH];
    CHAR                    szParentPart[MAX_PATH];
    CHAR                    szChildPart[MAX_PATH];
    LPSTR                   pszParentPath;
    LPSTR                   pszChildPath;
    LPSTR                   pszParentTemp;
    LPSTR                   pszChildTemp;

    *pszRelativePath = 0;

    GetFullPathName(pszInputParentPath, NUMELMS(szParentPath), szParentPath, NULL);
    GetFullPathName(pszInputChildPath, NUMELMS(szChildPath), szChildPath, NULL);

    if((szParentPath[0] >= 'a') && (szParentPath[0] <= 'z'))
    {
        szParentPath[0] = 'A' + (szParentPath[0] - 'a');
    }

    if((szChildPath[0] >= 'a') && (szChildPath[0] <= 'z'))
    {
        szChildPath[0] = 'A' + (szChildPath[0] - 'a');
    }

    pszParentPath = szParentPath;
    pszChildPath = szChildPath;

    //
    // If the paths aren't on the same drive, bail
    //

    if((szParentPath[0] >= 'A') && (szParentPath[0] <= 'Z') && (':' == szParentPath[1]))
    {
        fSuccess = ((szParentPath[0] == szChildPath[0]) && (szParentPath[1] == szChildPath[1]));

        if(fSuccess)
        {
            pszParentPath = &szParentPath[2];
            pszChildPath = &szChildPath[2];
        }
    }

    //
    // Skip over any matching directories
    //

    if(fSuccess)
    {
        while(TRUE)
        {
            pszParentTemp = ExtractDirectory(pszParentPath, szParentPart);

            if(!*pszParentTemp)
            {
                break;
            }

            pszChildTemp = ExtractDirectory(pszChildPath, szChildPart);

            if(!*pszChildTemp)
            {
                break;
            }

            if(_stricmp(szParentPart, szChildPart))
            {
                break;
            }

            pszParentPath = pszParentTemp;
            pszChildPath = pszChildTemp;
        }
    }

    //
    // For every directory that appears in the parent but not the child, add
    // a "..\"
    //

    if(fSuccess)
    {
        while(TRUE)
        {
            pszParentTemp = ExtractDirectory(pszParentPath, szParentPart);

            if(!*pszParentTemp)
            {
                break;
            }

            pszChildTemp = ExtractDirectory(pszChildPath, szChildPart);

            if(*pszChildTemp)
            {
                if(!_stricmp(szParentPart, szChildPart))
                {
                    break;
                }
            }

            strcat(pszRelativePath, "..\\");

            pszParentPath = pszParentTemp;
        }
    }

    //
    // If anything went wrong, just copy the full child path.  If all is good,
    // build the relative path.
    //
    
    if(fSuccess)
    {
        strcat(pszRelativePath, pszChildPath);
    }
    else
    {
        strcpy(pszRelativePath, szChildPath);
    }
}


/****************************************************************************
 *
 *  CWaveBankEntry
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CWaveBank * [in]: parent object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::CWaveBankEntry"

CWaveBankEntry::CWaveBankEntry
(
    CWaveBank *            pParent
)
{
    DPF_ENTER();

    m_pParent = pParent;

    InsertTailListUninit(&m_pParent->m_lstEntries, &m_leEntry);

    m_pParent->m_dwEntryCount++;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CWaveBankEntry
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::~CWaveBankEntry"

CWaveBankEntry::~CWaveBankEntry
(
    void
)
{
    DPF_ENTER();

    RemoveEntryList(&m_leEntry);

    ASSERT(m_pParent->m_dwEntryCount);
    m_pParent->m_dwEntryCount--;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object from a source file.
 *
 *  Arguments:
 *      LPCSTR [in]: entry name.
 *      LPCSTR [in]: wave file name.
 *      DWORD [in]: processing flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::Initialize"

HRESULT
CWaveBankEntry::Initialize
(
    LPCSTR                  pszEntryName,
    LPCSTR                  pszFileName,
    DWORD                   dwFlags
)
{
    HRESULT                 hr          = S_OK;
    UINT                    nNameCount;
    UINT                    nFileCount;
    
    DPF_ENTER();

    ASSERT(pszFileName);

    //
    // Save the file path
    //

    GetFullPathName(pszFileName, NUMELMS(m_szFileName), m_szFileName, NULL);

    //
    // Save the flags
    //

    m_dwFlags = dwFlags;

    //
    // If no entry name was specified, generate one from the file name
    //

    if(pszEntryName)
    {
        strncpy(m_szEntryName, pszEntryName, NUMELMS(m_szEntryName));
    }
    else
    {
        _splitpath(m_szFileName, NULL, NULL, m_szEntryName, NULL);
    }

    strncpy(m_szHeaderName, m_szEntryName, NUMELMS(m_szHeaderName));
    MakeHeaderString(m_szHeaderName);

    FindDuplicateEntry(m_szHeaderName, &nNameCount, m_szFileName, &nFileCount);

    if(nNameCount)
    {
        DPF_ERROR("An entry with that name already exists in the bank, or that name has been reserved");
        hr = E_FAIL;
    }
    else if(nFileCount)
    {
        DPF_WARNING("An entry using that filename already exists in the bank");
    }

    //
    // Open the file
    //

    if(SUCCEEDED(hr))
    {
        hr = LoadWaveFile();
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  FindDuplicateEntry
 *
 *  Description:
 *      Checks the wave bank for a duplicate entry.
 *
 *  Arguments:
 *      LPCSTR [in]: entry name.
 *      UINT * [out]: count of duplicate named entries found.
 *      LPCSTR [in]: entry file path.
 *      UINT * [out]: count of duplicate pathed entries found.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::FindDuplicateEntry"

HRESULT
CWaveBankEntry::FindDuplicateEntry
(
    LPCSTR                  pszName,
    UINT *                  pnNameCount,
    LPCSTR                  pszPath,
    UINT *                  pnPathCount
)
{
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    
    DPF_ENTER();

    ASSERT(pszName || pszPath);

    if(pnNameCount)
    {
        *pnNameCount = 0;
    }

    if(pnPathCount)
    {
        *pnPathCount = 0;
    }

    if(pszName)
    {
        if(!_strcmpi(pszName, WBCHEADER_ENTRYCOUNTSHORTNAME))
        {
            hr = E_FAIL;
            
            if(pnNameCount)
            {
                *pnNameCount += 1;
            }
        }
    }

    for(pleEntry = m_pParent->m_lstEntries.Flink; pleEntry != &m_pParent->m_lstEntries; pleEntry = pleEntry->Flink)
    {
        if(FAILED(hr) && !pnNameCount && !pnPathCount)
        {
            break;
        }
        
        if(this == (pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry)))
        {
            continue;
        }

        if(pszName)
        {
            if(!_strcmpi(pszName, pEntry->m_szHeaderName))
            {
                hr = E_FAIL;
                
                if(pnNameCount)
                {
                    *pnNameCount += 1;
                }
            }
        }

        if(pszPath)
        {
            if(!_strcmpi(pszPath, pEntry->m_szFileName))
            {
                hr = E_FAIL;
                
                if(pnPathCount)
                {
                    *pnPathCount += 1;
                }
            }
        }
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetName
 *
 *  Description:
 *      Renames the entry.
 *
 *  Arguments:
 *      LPCSTR [in]: entry name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "SetName"

HRESULT 
CWaveBankEntry::SetName
(
    LPCSTR                  pszName
)
{
    HRESULT                 hr                                      = S_OK;
    CHAR                    szHeaderName[NUMELMS(m_szHeaderName)];

    if(strlen(pszName) >= NUMELMS(m_szEntryName))
    {
        DPF_ERROR("That name is too long");
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        strncpy(szHeaderName, pszName, NUMELMS(szHeaderName));
        MakeHeaderString(szHeaderName);

        hr = FindDuplicateEntry(szHeaderName, NULL, NULL, NULL);

        if(SUCCEEDED(hr))
        {
            strncpy(m_szEntryName, pszName, NUMELMS(m_szEntryName));
            strncpy(m_szHeaderName, szHeaderName, NUMELMS(m_szHeaderName));
        }
        else
        {
            DPF_ERROR("An entry with that name already exists in the bank, or that name has been reserved");
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  LoadWaveFile
 *
 *  Description:
 *      Initializes the object from a wave file.
 *
 *  Arguments:
 *      LPCSTR [in]: wave file name.
 *      DWORD [in]: processing flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::LoadWaveFile"

HRESULT
CWaveBankEntry::LoadWaveFile
(
    void
)
{
    CWaveFile               WaveFile;
    WAVEBANKUNIWAVEFORMAT   Format;
    HRESULT                 hr;
    
    DPF_ENTER();
    
    //
    // Open the file
    //

    if(FAILED(hr = WaveFile.Open(m_szFileName)))
    {
        DPF_ERROR("An error occurred while attempting to open %s", m_szFileName);
    }

    //
    // Load the file format
    //

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = WaveFile.GetFileType(&m_dwFileType)))
        {
            DPF_ERROR("An error occurred while attempting to retrieve the file type");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = WaveFile.GetFormat(&Format.WaveFormatEx, sizeof(Format))))
        {
            DPF_ERROR("An error occurred while attempting to retrieve the file format");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(!WaveBankCompressFormat(&Format, &m_Format))
        {
            hr = E_NOTIMPL;
        }
    }

    //
    // Save the data chunk offset and length
    //

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = WaveFile.GetDataOffset(&m_PlayRegion.dwStart)))
        {
            DPF_ERROR("An error occurred while attempting to retrieve the wave data offset");
        }
    }
    
    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = WaveFile.GetDuration(&m_PlayRegion.dwLength)))
        {
            DPF_ERROR("An error occurred while attempting to retrieve the wave data length");
        }
    }

    //
    // Save the loop region
    //

    if(SUCCEEDED(hr))
    {
        hr = WaveFile.GetLoopRegion(&m_LoopRegion.dwStart, &m_LoopRegion.dwLength);

        if(FAILED(hr))
        {
            m_LoopRegion.dwStart = 0;
            m_LoopRegion.dwLength = 0;
            
            hr = S_OK;
        }
    }
    
    //
    // Update the flags to account for having valid data
    //
    
    if(SUCCEEDED(hr))
    {
        SetFlags(~0UL, m_dwFlags);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetValidFlags
 *
 *  Description:
 *      Gets the mask of flags available for the entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: valid flags mask.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::GetValidFlags"

DWORD
CWaveBankEntry::GetValidFlags
(
    void
)
{
    DWORD                   dwFlags = 0;
    
    DPF_ENTER();
    
    if(CXboxAdpcmFilter::IsValidFormat(&m_Format))
    {
        dwFlags |= WBFILTER_ADPCM;
    }

    if(C8BitFilter::IsValidFormat(&m_Format))
    {
        dwFlags |= WBFILTER_8BIT;
    }

    DPF_LEAVE(dwFlags);

    return dwFlags;
}


/****************************************************************************
 *
 *  SetFlags
 *
 *  Description:
 *      Sets entry flags.  Because of error-checking, the flags actually set
 *      by this method may not match those passed in.
 *
 *  Arguments:
 *      DWORD [in]: mask of flags to change.
 *      DWORD [in]: new flags.
 *
 *  Returns:  
 *      DWORD: new flags.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::SetFlags"

DWORD
CWaveBankEntry::SetFlags
(
    DWORD                   dwMask,
    DWORD                   dwFlags
)
{
    DPF_ENTER();

    //
    // Check the mask against what the filters can actually deal with
    //

    dwMask &= GetValidFlags();

    //
    // Mask off any unused bits
    //
    
    dwFlags &= dwMask;
    
    //
    // ADPCM and 8BIT are mutually exclusive
    //

    if((dwFlags & WBFILTER_ADPCM) && (dwFlags & WBFILTER_8BIT))
    {
        DPF_WARNING("ADPCM and 8BIT filtering are mutually exclusive");
        dwFlags &= ~WBFILTER_8BIT;
    }

    //
    // Set the flags
    //

    m_dwFlags &= ~dwMask;
    m_dwFlags |= dwFlags;

    DPF_LEAVE(dwFlags);

    return dwFlags;
}


/****************************************************************************
 *
 *  GetMetaData
 *
 *  Description:
 *      Generates entry meta-data.
 *
 *  Arguments:
 *      LPWAVEBANKENTRY [out]: entry meta-data.
 *      LPDWORD [in/out]: current offset into the data segment.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::GetMetaData"

HRESULT
CWaveBankEntry::GetMetaData
(
    LPWAVEBANKENTRY         pMetaData,
    LPDWORD                 pdwOffset
)
{
    static const DWORD      dwAlignment = 4;
    
    DPF_ENTER();

    ASSERT(!((m_dwFlags & WBFILTER_ADPCM) && (m_dwFlags & WBFILTER_8BIT)));

    //
    // If we're compressing, write the compressed format, not the source
    //

    pMetaData->Format = m_Format;
    
    if(m_dwFlags & WBFILTER_ADPCM)
    {
        if(!CXboxAdpcmFilter::ConvertFormat(&pMetaData->Format))
        {
            m_dwFlags &= ~WBFILTER_ADPCM;
        }
    }
    
    if(m_dwFlags & WBFILTER_8BIT)
    {
        if(!C8BitFilter::ConvertFormat(&pMetaData->Format))
        {
            m_dwFlags &= ~WBFILTER_8BIT;
        }
    }

    //
    // Block-align the file offset
    //
        
    pMetaData->PlayRegion.dwStart = BLOCKALIGNPAD(*pdwOffset, dwAlignment);

    //
    // If we're compressing, calculate the compressed data size as well
    //

    pMetaData->PlayRegion.dwLength = m_PlayRegion.dwLength;

    if(m_dwFlags & WBFILTER_ADPCM)
    {
        pMetaData->PlayRegion.dwLength = CXboxAdpcmFilter::GetSize(pMetaData->PlayRegion.dwLength, m_Format.nChannels, TRUE);
    }
    
    if(m_dwFlags & WBFILTER_8BIT)
    {
        pMetaData->PlayRegion.dwLength = C8BitFilter::GetSize(pMetaData->PlayRegion.dwLength, m_Format.nChannels);
    }

    //
    // ... and the loop offsets
    //

    pMetaData->LoopRegion = m_LoopRegion;

    if(m_dwFlags & WBFILTER_ADPCM)
    {
        pMetaData->LoopRegion.dwStart = CXboxAdpcmFilter::GetSize(pMetaData->LoopRegion.dwStart, m_Format.nChannels);
        pMetaData->LoopRegion.dwLength = CXboxAdpcmFilter::GetSize(pMetaData->LoopRegion.dwLength, m_Format.nChannels);
    }
    
    if(m_dwFlags & WBFILTER_8BIT)
    {
        pMetaData->LoopRegion.dwStart = C8BitFilter::GetSize(pMetaData->LoopRegion.dwStart, m_Format.nChannels);
        pMetaData->LoopRegion.dwLength = C8BitFilter::GetSize(pMetaData->LoopRegion.dwLength, m_Format.nChannels);
    }

    //
    // Update the file offset
    //

    *pdwOffset = pMetaData->PlayRegion.dwStart + pMetaData->PlayRegion.dwLength;

    DPF_LEAVE_HRESULT(S_OK);

    return S_OK;
}


/****************************************************************************
 *
 *  CommitWaveData
 *
 *  Description:
 *      Writes entry wave data to the bank file.
 *
 *  Arguments:
 *      CStdFileStream * [in]: bank file stream.
 *      DWORD [in]: base file offset of the data segment.
 *      LPCWAVEBANKENTRY [in]: entry meta-data generated by GetMetaData.
 *      LPVOID [in]: scratch memory.
 *      DWORD [in]: size of scratch buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::CommitWaveData"

HRESULT
CWaveBankEntry::CommitWaveData
(
    CStdFileStream *        pBankFile,
    DWORD                   dwBaseOffset,
    LPCWAVEBANKENTRY        pMetaData,
    LPVOID                  pvCopyBuffer,
    DWORD                   dwCopyBufferSize
)
{
    DWORD                   dwTotalRead     = 0;
    DWORD                   dwTotalWritten  = 0;
    CXboxAdpcmFilter        AdpcmFilter;
    C8BitFilter             BitFilter;
    CStdFileStream          WaveFile;
    DWORD                   dwAlignment;
    DWORD                   dwRead;
    DWORD                   dwWritten;
    DWORD                   dwAlignedRead;
    DWORD                   dwFilterRead;
    DWORD                   dwFileType;
    HRESULT                 hr;
    
    DPF_ENTER();

    ASSERT(!((m_dwFlags & WBFILTER_ADPCM) && (m_dwFlags & WBFILTER_8BIT)));

    if(!pBankFile)
    {
        ASSERT(dwCopyBufferSize >= pMetaData->PlayRegion.dwLength);
    }

    //
    // Open the source file and seek to the start of the data chunk
    //

    if(FAILED(hr = WaveFile.Open(m_szFileName, GENERIC_READ, FILE_SHARE_READ, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN)))
    {
        DPF_ERROR("An error occurred while attempting to open %s", m_szFileName);
    }

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = WaveFile.Seek(m_PlayRegion.dwStart, FILE_BEGIN)))
        {
            DPF_ERROR("An error occurred while attempting to read from the wave file");
        }
    }

    //
    // Seek to the proper location in the destination file
    //

    if(SUCCEEDED(hr))
    {
        if(FAILED(hr = pBankFile->Seek(dwBaseOffset + pMetaData->PlayRegion.dwStart, FILE_BEGIN)))
        {
            DPF_ERROR("An error occurred while attempting to read from the bank file");
        }
    }

    //
    // Initialize the ADPCM filter
    //

    if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_ADPCM))
    {
        if(!AdpcmFilter.Initialize(&m_Format))
        {
            DPF_ERROR("Failed to initialize the ADPCM filter");
            hr = E_FAIL;
        }
    }

    //
    // Initialize the 8BIT filter
    //

    if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_8BIT))
    {
        if(!BitFilter.Initialize(&m_Format))
        {
            DPF_ERROR("Failed to initialize the 8BIT filter");
            hr = E_FAIL;
        }
    }

    //
    // Get the filter alignment so we never have to seek backwards in the
    // file due to converting less data than we read.
    //

    if(SUCCEEDED(hr))
    {
        if(m_dwFlags & WBFILTER_ADPCM)
        {
            dwAlignment = AdpcmFilter.GetSourceAlignment();
        }
        else if(m_dwFlags & WBFILTER_8BIT)
        {
            dwAlignment = BitFilter.GetSourceAlignment();
        }
        else
        {
            dwAlignment = m_Format.nChannels;
            
            if(WAVEBANKMINIFORMAT_BITDEPTH_16 == m_Format.wBitsPerSample)
            {
                dwAlignment *= 2;
            }
        }

        ASSERT(dwCopyBufferSize >= dwAlignment);
    }

    //
    // Start copying data
    //

    while(SUCCEEDED(hr) && (dwTotalRead < m_PlayRegion.dwLength))
    {
        //
        // Don't read past the end of the file
        //

        dwRead = min(dwCopyBufferSize, m_PlayRegion.dwLength - dwTotalRead);

        //
        // Align the read amount so we never have to seek backwards in the
        // file due to converting less data than we read.  If there isn't
        // enough data left in the file to satisfy the alignment, pad with
        // silence.
        //

        if(dwRead >= dwAlignment)
        {
            dwRead = dwAlignedRead = BLOCKALIGN(dwRead, dwAlignment);
        }
        else
        {
            dwAlignedRead = BLOCKALIGNPAD(dwRead, dwAlignment);
        }

        dwWritten = dwAlignedRead;

        //
        // Read source data
        //
        
        hr = WaveFile.Read(pvCopyBuffer, dwRead);

        //
        // Convert if AIFF PCM
        //

        if(SUCCEEDED(hr) && (WAVELDR_FILETYPE_AIFF == m_dwFileType))
        {
            CWaveFile::ConvertAiffPcm(pvCopyBuffer, dwRead, (WAVEBANKMINIFORMAT_BITDEPTH_16 == m_Format.wBitsPerSample) ? 16 : 8);
        }

        //
        // Pad with silence if necessary
        //

        if(SUCCEEDED(hr) && (dwAlignedRead > dwRead))
        {
            ZeroMemory((LPBYTE)pvCopyBuffer + dwRead, dwAlignedRead - dwRead);
        }
        
        //
        // Convert (or not)
        //

        if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_ADPCM))
        {
            dwFilterRead = dwAlignedRead;
            
            if(AdpcmFilter.Convert(pvCopyBuffer, &dwFilterRead, pvCopyBuffer, &dwWritten))
            {
                ASSERT(dwFilterRead == dwAlignedRead);
            }
            else
            {
                DPF_ERROR("An error occurred while compressing PCM data");
                hr = E_FAIL;
            }
        }
            
        if(SUCCEEDED(hr) && (m_dwFlags & WBFILTER_8BIT))
        {
            dwFilterRead = dwAlignedRead;
            
            if(BitFilter.Convert(pvCopyBuffer, &dwFilterRead, pvCopyBuffer, &dwWritten))
            {
                ASSERT(dwFilterRead == dwAlignedRead);
            }
            else
            {
                DPF_ERROR("An error occurred while compressing PCM data");
                hr = E_FAIL;
            }
        }

        //
        // Write to the bank file
        //
        
        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = pBankFile->Write(pvCopyBuffer, dwWritten)))
            {
                DPF_ERROR("An error occurred while attempting to write to the bank file");
            }
        }

        //
        // Increment counters
        //

        if(SUCCEEDED(hr))
        {
            dwTotalRead += dwRead;
            dwTotalWritten += dwWritten;
        }

        //
        // If no file was specified, bail out now
        //

        if(!pBankFile)
        {
            break;
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(dwTotalRead == m_PlayRegion.dwLength);
        ASSERT(dwTotalWritten == pMetaData->PlayRegion.dwLength);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ReadProjectData
 *
 *  Description:
 *      Initializes the entry based on saved project data.
 *
 *  Arguments:
 *      LPCSTR [in]: project file name.
 *      LPCSTR [in]: section name.
 *      DWORD [in]: entry index.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::ReadProjectData"

HRESULT
CWaveBankEntry::ReadProjectData
(
    LPCSTR                  pszProjectFile, 
    LPCSTR                  pszSectionName,
    DWORD                   dwEntryIndex
)
{
    CHAR                    szKeyName[0x100];
    CHAR                    szEntryData[MAX_PATH + 0x200];
    CHAR                    szEntryName[0x100];
    CHAR                    szFileName[MAX_PATH];
    DWORD                   dwFlags;
    LPCSTR                  pszSrc;
    LPSTR                   pszDst;
    HRESULT                 hr;
    
    DPF_ENTER();

    //
    // Load the whole entry string
    //

    sprintf(szKeyName, WBPROJECT_ENTRY_KEY, dwEntryIndex);

    GetPrivateProfileString(pszSectionName, szKeyName, "", szEntryData, NUMELMS(szEntryData), pszProjectFile);

    pszSrc = szEntryData;
    
    //
    // Extract the entry name
    //
    
    pszDst = szEntryName;

    while(TRUE)
    {
        switch(tolower(*pszSrc))
        {
            case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
                pszSrc++;
                *pszDst = 0;
                break;

            default:
                *pszDst = *pszSrc;
                break;
        }

        if(!*pszDst)
        {
            break;
        }

        pszDst++;
        pszSrc++;
    }

    //
    // Extract the file name
    //
    
    pszDst = szFileName;

    while(TRUE)
    {
        switch(tolower(*pszSrc))
        {
            case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
                pszSrc++;
                *pszDst = 0;
                break;

            default:
                *pszDst = *pszSrc;
                break;
        }

        if(!*pszDst)
        {
            break;
        }

        pszDst++;
        pszSrc++;
    }

    //
    // Extract the flags
    //

    dwFlags = 0;

    while(*pszSrc)
    {
        switch(tolower(*pszSrc))
        {
            case WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR:
                break;

            case WBPROJECT_ENTRYEXT_ADPCMFILTER_LCHAR:
                dwFlags |= WBFILTER_ADPCM;
                break;

            case WBPROJECT_ENTRYEXT_8BITFILTER_LCHAR:
                dwFlags |= WBFILTER_8BIT;
                break;

            default:
                DPF_WARNING("Unrecognized flag character in project file");
                break;
        }

        pszSrc++;
    }

    //
    // Initialize the entry
    //

    hr = Initialize(szEntryName, szFileName, dwFlags);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  WriteProjectData
 *
 *  Description:
 *      Stores project data for the entry.
 *
 *  Arguments:
 *      LPCSTR [in]: project file name.
 *      LPCSTR [in]: section name.
 *      DWORD [in]: entry index.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankEntry::WriteProjectData"

HRESULT
CWaveBankEntry::WriteProjectData
(
    LPCSTR                  pszProjectFile, 
    LPCSTR                  pszSectionName,
    DWORD                   dwEntryIndex
)
{
    HRESULT                 hr                              = S_OK;
    CHAR                    szKeyName[0x100];
    CHAR                    szEntryData[MAX_PATH + 0x200];
    
    DPF_ENTER();

    sprintf(szKeyName, WBPROJECT_ENTRY_KEY, dwEntryIndex);

    strcpy(szEntryData, m_szEntryName);
    strcat(szEntryData, WBPROJECT_ENTRYEXT_SEPARATOR_STR);

    GetRelativePath(pszProjectFile, m_szFileName, &szEntryData[strlen(szEntryData)]);

    if(m_dwFlags & WBFILTER_MASK)
    {
        strcat(szEntryData, WBPROJECT_ENTRYEXT_SEPARATOR_STR);

        if(m_dwFlags & WBFILTER_ADPCM)
        {
            strcat(szEntryData, WBPROJECT_ENTRYEXT_ADPCMFILTER_STR);
        }

        if(m_dwFlags & WBFILTER_8BIT)
        {
            strcat(szEntryData, WBPROJECT_ENTRYEXT_8BITFILTER_STR);
        }
    }

    if(!WritePrivateProfileString(pszSectionName, szKeyName, szEntryData, pszProjectFile))
    {
        DPF_ERROR("Error %lu occurred writing to the project file", GetLastError());
        hr = E_FAIL;
    }        

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CWaveBank
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::CWaveBank"

CWaveBank::CWaveBank
(
    CWaveBankProject *     pParent
)
{
    DPF_ENTER();

    m_pParent = pParent;
    m_dwEntryCount = 0;

    InitializeListHead(&m_lstEntries);

    if(m_pParent)
    {
        InsertTailListUninit(&m_pParent->m_lstBanks, &m_leBank);

        m_pParent->m_dwBankCount++;
    }
    else
    {
        InitializeListHead(&m_leBank);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CWaveBank
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::~CWaveBank"

CWaveBank::~CWaveBank
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *       pEntry;
    
    DPF_ENTER();

    //
    // Free all the entries
    //
    
    while((pleEntry = m_lstEntries.Flink) != &m_lstEntries)
    {
        pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);
        
        DELETE(pEntry);
    }

    //
    // Free ourselves from the parent list
    //

    RemoveEntryList(&m_leBank);

    if(m_pParent)
    {
        ASSERT(m_pParent->m_dwBankCount);
        m_pParent->m_dwBankCount--;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCSTR [in]: wave bank name.
 *      LPCSTR [in]: bank file path.
 *      LPCSTR [in]: header file path.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::Initialize"

HRESULT
CWaveBank::Initialize
(
    LPCSTR                  pszBankName,
    LPCSTR                  pszBankFile,
    LPCSTR                  pszHeaderFile
)
{
    HRESULT                 hr                  = S_OK;
    UINT                    nNameCount;
    UINT                    nBankFileCount;
    UINT                    nHeaderFileCount;

    DPF_ENTER();

    strncpy(m_szBankName, pszBankName, NUMELMS(m_szBankName));
    strncpy(m_szHeaderName, pszBankName, NUMELMS(m_szHeaderName));
    MakeHeaderString(m_szHeaderName);

    GetFullPathName(pszBankFile, NUMELMS(m_szBankFile), m_szBankFile, NULL);
    GetFullPathName(pszHeaderFile, NUMELMS(m_szHeaderFile), m_szHeaderFile, NULL);

    FindDuplicateBank(m_szHeaderName, &nNameCount, m_szBankFile, &nBankFileCount, m_szHeaderFile, &nHeaderFileCount);

    if(nNameCount)
    {
        DPF_ERROR("A bank with that name (or a similar one) already exists in the project");
        hr = E_FAIL;
    }
    else if(nBankFileCount)
    {
        DPF_ERROR("A bank using that filename already exists in the project");
        hr = E_FAIL;
    }
    else if(nHeaderFileCount)
    {
        DPF_ERROR("A bank using that header filename already exists in the project");
        hr = E_FAIL;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  FindDuplicateBank
 *
 *  Description:
 *      Checks the wave bank for a duplicate Bank.
 *
 *  Arguments:
 *      LPCSTR [in]: Bank name.
 *      UINT * [out]: count of duplicate named entries found.
 *      LPCSTR [in]: Bank file path.
 *      UINT * [out]: count of duplicate pathed entries found.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::FindDuplicateBank"

HRESULT
CWaveBank::FindDuplicateBank
(
    LPCSTR                  pszName,
    UINT *                  pnNameCount,
    LPCSTR                  pszBankFile,
    UINT *                  pnBankFileCount,
    LPCSTR                  pszHeaderFile,
    UINT *                  pnHeaderFileCount
)
{
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleBank;
    CWaveBank *            pBank;
    
    DPF_ENTER();

    ASSERT(pszName || pszBankFile);

    if(pnNameCount)
    {
        *pnNameCount = 0;
    }

    if(pnBankFileCount)
    {
        *pnBankFileCount = 0;
    }

    if(pnHeaderFileCount)
    {
        *pnHeaderFileCount = 0;
    }

    for(pleBank = m_pParent->m_lstBanks.Flink; pleBank != &m_pParent->m_lstBanks; pleBank = pleBank->Flink)
    {
        if(this == (pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank)))
        {
            continue;
        }

        if(pszName)
        {
            if(!_strcmpi(pszName, pBank->m_szHeaderName))
            {
                hr = E_FAIL;
                
                if(pnNameCount)
                {
                    *pnNameCount = *pnNameCount + 1;
                }
                else if(!pnBankFileCount)
                {
                    break;
                }
            }
        }

        if(pszBankFile)
        {
            if(!_strcmpi(pszBankFile, pBank->m_szBankFile))
            {
                hr = E_FAIL;
                
                if(pnBankFileCount)
                {
                    *pnBankFileCount = *pnBankFileCount + 1;
                }
                else if(!pnNameCount)
                {
                    break;
                }
            }
        }

        if(pszHeaderFile)
        {
            if(!_strcmpi(pszHeaderFile, pBank->m_szHeaderFile))
            {
                hr = E_FAIL;
                
                if(pnHeaderFileCount)
                {
                    *pnHeaderFileCount = *pnHeaderFileCount + 1;
                }
                else if(!pnNameCount)
                {
                    break;
                }
            }
        }
    }
    
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetName
 *
 *  Description:
 *      Renames the Bank.
 *
 *  Arguments:
 *      LPCSTR [in]: Bank name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "SetName"

HRESULT 
CWaveBank::SetName
(
    LPCSTR                  pszName
)
{
    HRESULT                 hr                                      = S_OK;
    CHAR                    szHeaderName[NUMELMS(m_szHeaderName)];

    if(strlen(pszName) >= NUMELMS(m_szBankName))
    {
        DPF_ERROR("That name is too long");
        hr = E_FAIL;
    }

    if(SUCCEEDED(hr))
    {
        strncpy(szHeaderName, pszName, NUMELMS(szHeaderName));
        MakeHeaderString(szHeaderName);

        hr = FindDuplicateBank(szHeaderName, NULL, NULL, NULL, NULL, NULL);

        if(SUCCEEDED(hr))
        {
            strncpy(m_szBankName, pszName, NUMELMS(m_szBankName));
            strncpy(m_szHeaderName, szHeaderName, NUMELMS(m_szHeaderName));
        }
        else
        {
            DPF_ERROR("A bank with that name (or a similar one) already exists in the project");
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  AddEntry
 *
 *  Description:
 *      Adds an entry to the wave bank.
 *
 *  Arguments:
 *      LPCSTR [in]: entry name.
 *      LPCSTR [in]: wave file name.
 *      DWORD [in]: entry flags.
 *      CWaveBankEntry ** [out]: entry object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::AddEntry"

HRESULT
CWaveBank::AddEntry
(
    LPCSTR                  pszEntryName,
    LPCSTR                  pszFileName,
    DWORD                   dwFlags,
    CWaveBankEntry **      ppEntry
)
{
    CWaveBankEntry *       pEntry;
    HRESULT                 hr;
    
    DPF_ENTER();

    hr = HRFROMP(pEntry = CreateEntry());

    if(SUCCEEDED(hr))
    {
        hr = pEntry->Initialize(pszEntryName, pszFileName, dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        if(ppEntry)
        {
            *ppEntry = pEntry;
        }
    }
    else
    {
        DELETE(pEntry);
    }

    return hr;
}


/****************************************************************************
 *
 *  GenerateBank
 *
 *  Description:
 *      Saves files to the wave bank.
 *
 *  Arguments:
 *      CWaveBankCallback * [in]: callback object.
 *      BOOL [in]: TRUE to allow overwriting the wave bank file.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::GenerateBank"

HRESULT
CWaveBank::GenerateBank
(
    CWaveBankCallback *     pCallback,
    BOOL                    fAllowOverwrite
)                                   
{                                   
    static const DWORD      dwCopyBufferSize    = 256 * 1024;
    LPVOID                  pvCopyBuffer        = NULL;
    LPWAVEBANKENTRY         paMetaData          = NULL;
    HRESULT                 hr                  = S_OK;
    CStdFileStream          BankFile;
    WAVEBANKHEADER          Header;
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    DWORD                   dwEntryIndex;
    DWORD                   dwOffset;
    
    DPF_ENTER();

    if(m_dwEntryCount)
    {
        //
        // Call the callback
        //

        if(pCallback)
        {
            if(!pCallback->OpenBank(m_szBankFile))
            {
                hr = E_ABORT;
            }
        }

        //
        // Open the bank file
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = BankFile.Open(m_szBankFile, GENERIC_READ | GENERIC_WRITE, 0, fAllowOverwrite ? CREATE_ALWAYS : CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN)))
            {
                DPF_ERROR("An error occurred while attempting to open %s", m_szBankFile);
            }
        }
        
        //
        // Allocate temporary storage
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HRFROMP(pvCopyBuffer = MEMALLOC_NOINIT(BYTE, dwCopyBufferSize))))
            {
                DPF_ERROR("Out of memory");
            }
        }

        //
        // Allocate data for the entire metadata section
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HRFROMP(paMetaData = MEMALLOC(WAVEBANKENTRY, m_dwEntryCount))))
            {
                DPF_ERROR("Out of memory");
            }
        }

        //
        // Write the file header
        //

        if(SUCCEEDED(hr))
        {
            Header.dwSignature = WAVEBANKHEADER_SIGNATURE;
            Header.dwVersion = WAVEBANKHEADER_VERSION;
            Header.dwFlags = m_dwFlags;
            Header.dwEntryCount = m_dwEntryCount;
            Header.dwAlignment = 4;
            
            strncpy(Header.szBankName, m_szBankName, NUMELMS(Header.szBankName));

            if(FAILED(hr = BankFile.Write(&Header, sizeof(Header))))
            {
                DPF_ERROR("An error occurred while attempting to write to the bank file");
            }
        }

        //
        // Generate and write metadata
        //

        if(SUCCEEDED(hr))
        {
            for(pleEntry = m_lstEntries.Flink, dwEntryIndex = 0, dwOffset = 0; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink, dwEntryIndex++)
            {
                ASSERT(dwEntryIndex < m_dwEntryCount);
                
                pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

                hr = pEntry->GetMetaData(&paMetaData[dwEntryIndex], &dwOffset);
            }
        }
        
        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = BankFile.Write(paMetaData, sizeof(paMetaData[0]) * m_dwEntryCount)))
            {
                DPF_ERROR("An error occurred while attempting to write to the bank file");
            }
        }

        //
        // Write the data section
        //

        if(SUCCEEDED(hr))
        {
            for(pleEntry = m_lstEntries.Flink, dwEntryIndex = 0; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink, dwEntryIndex++)
            {
                ASSERT(dwEntryIndex < m_dwEntryCount);
                
                pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

                if(pCallback)
                {
                    if(!pCallback->BeginEntry(pEntry->m_szFileName, pEntry->m_dwFlags))
                    {
                        hr = E_ABORT;
                    }
                }
        
                if(SUCCEEDED(hr))
                {
                    dwOffset = sizeof(Header) + (sizeof(paMetaData[0]) * Header.dwEntryCount);
                    
                    hr = pEntry->CommitWaveData(&BankFile, dwOffset, &paMetaData[dwEntryIndex], pvCopyBuffer, dwCopyBufferSize);
                }

                if(SUCCEEDED(hr) && pCallback)
                {
                    pCallback->EndEntry(pEntry->m_szFileName, pEntry->m_dwFlags);
                }
            }
        }

        //
        // Call the callback
        //

        if(pCallback)
        {
            pCallback->CloseBank(m_szBankFile);
        }
    }
    else
    {
        DPF_ERROR("No entries added yet");
        hr = E_FAIL;
    }

    //
    // Clean up
    //

    MEMFREE(pvCopyBuffer);
    MEMFREE(paMetaData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GenerateHeader
 *
 *  Description:
 *      Generates the C header to use with the wave bank.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::GenerateHeader"

HRESULT
CWaveBank::GenerateHeader
(
    CWaveBankCallback *     pCallback,
    BOOL                    fAllowOverwrite
)                                   
{                                   
    static const LPCSTR     pszFileBegin            = "#pragma once\r\n\r\n";
    static const LPCSTR     pszEnumBegin            = "typedef enum\r\n{\r\n";
    static const LPCSTR     pszEnumEnd              = "} " WBCHEADER_ENUMNAME ";\r\n\r\n";
    static const LPCSTR     pszEnumEntry            = "    " WBCHEADER_ENUMENTRYNAME " = %lu,\r\n";
    static const LPCSTR     pszEnumCount            = "#define " WBCHEADER_ENTRYCOUNTNAME " %lu\r\n";
    HRESULT                 hr                      = S_OK;
    CStdFileStream          HeaderFile;
    CHAR                    szText[MAX_PATH];
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    DWORD                   dwEntry;
    
    DPF_ENTER();

    if(m_dwEntryCount)
    {
        //
        // Call the callback
        //

        if(pCallback)
        {
            if(!pCallback->OpenHeader(m_szHeaderFile))
            {
                hr = E_ABORT;
            }
        }

        //
        // Open the bank file
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HeaderFile.Open(m_szHeaderFile, GENERIC_READ | GENERIC_WRITE, 0, fAllowOverwrite ? CREATE_ALWAYS : CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN)))
            {
                DPF_ERROR("An error occurred while attempting to open %s", m_szHeaderFile);
            }
        }

        //
        // Write the file header
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HeaderFile.Write(pszFileBegin, strlen(pszFileBegin))))
            {
                DPF_ERROR("An error occurred while attempting to write to the header file");
            }
        }

        //
        // Write the enumeration header
        //

        if(SUCCEEDED(hr))
        {
            if(FAILED(hr = HeaderFile.Write(pszEnumBegin, strlen(pszEnumBegin))))
            {
                DPF_ERROR("An error occurred while attempting to write to the header file");
            }
        }

        //
        // Begin the entry loop
        //

        if(SUCCEEDED(hr))
        {
            for(pleEntry = m_lstEntries.Flink, dwEntry = 0; (pleEntry != &m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, dwEntry++)
            {
                pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

                //
                // Add the entry to the enumeration
                //

                sprintf(szText, pszEnumEntry, m_szHeaderName, pEntry->m_szHeaderName, dwEntry);

                if(FAILED(hr = HeaderFile.Write(szText, strlen(szText))))
                {
                    DPF_ERROR("An error occurred while attempting to write to the header file");
                }
            }
        }

        //
        // End the enumeration
        //

        if(SUCCEEDED(hr))
        {
            sprintf(szText, pszEnumEnd, m_szHeaderName);

            if(FAILED(hr = HeaderFile.Write(szText, strlen(szText))))
            {
                DPF_ERROR("An error occurred while attempting to write to the header file");
            }
        }

        //
        // Add a count
        //

        if(SUCCEEDED(hr))
        {
            ASSERT(dwEntry == m_dwEntryCount);
            
            sprintf(szText, pszEnumCount, m_szHeaderName, dwEntry);

            if(FAILED(hr = HeaderFile.Write(szText, strlen(szText))))
            {
                DPF_ERROR("An error occurred while attempting to write to the header file");
            }
        }

        //
        // Call the callback
        //

        if(pCallback)
        {
            pCallback->CloseHeader(m_szHeaderFile);
        }
    }
    else
    {
        DPF_ERROR("No entries added yet");
        hr = E_FAIL;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ReadProjectData
 *
 *  Description:
 *      Initializes the entry based on saved project data.
 *
 *  Arguments:
 *      LPCSTR [in]: project file name.
 *      DWORD [in]: bank index.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::ReadProjectData"

HRESULT
CWaveBank::ReadProjectData
(
    LPCSTR                  pszProjectFile, 
    DWORD                   dwBankIndex
)
{
    HRESULT                 hr                      = S_OK;
    CHAR                    szSectionName[MAX_PATH];
    CHAR                    szBankName[MAX_PATH];
    CHAR                    szBankFile[MAX_PATH];
    CHAR                    szHeaderFile[MAX_PATH];
    DWORD                   dwEntryCount;
    CWaveBankEntry *        pEntry;
    HRESULT                 hrEntry;
    DWORD                   i;
    
    DPF_ENTER();

    sprintf(szSectionName, WBPROJECT_BANK_KEY, dwBankIndex);

    GetPrivateProfileString(szSectionName, WBPROJECT_BANK_NAME_KEY, "", szBankName, NUMELMS(szBankName), pszProjectFile);
    GetPrivateProfileString(szSectionName, WBPROJECT_BANK_FILE_KEY, "", szBankFile, NUMELMS(szBankFile), pszProjectFile);
    GetPrivateProfileString(szSectionName, WBPROJECT_BANK_HEADER_KEY, "", szHeaderFile, NUMELMS(szHeaderFile), pszProjectFile);

    hr = Initialize(szBankName, szBankFile, szHeaderFile);

    if(SUCCEEDED(hr))
    {
        dwEntryCount = GetPrivateProfileInt(szSectionName, WBPROJECT_BANK_ENTRYCOUNT_KEY, 0, pszProjectFile);

        for(i = 0; (i < dwEntryCount) && SUCCEEDED(hr); i++)
        {
            hrEntry = HRFROMP(pEntry = CreateEntry());

            if(SUCCEEDED(hrEntry))
            {
                hrEntry = pEntry->ReadProjectData(pszProjectFile, szSectionName, i);
            }

            if(FAILED(hrEntry))
            {
                DELETE(pEntry);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  WriteProjectData
 *
 *  Description:
 *      Saves project data for the bank.
 *
 *  Arguments:
 *      LPCSTR [in]: project file name.
 *      DWORD [in]: bank index.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::WriteProjectData"

HRESULT
CWaveBank::WriteProjectData
(
    LPCSTR                  pszProjectFile, 
    DWORD                   dwBankIndex
)
{
    HRESULT                 hr                      = S_OK;
    CHAR                    szSectionName[MAX_PATH];
    CHAR                    szText[MAX_PATH];
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    DWORD                   i;
    
    DPF_ENTER();

    sprintf(szSectionName, WBPROJECT_BANK_KEY, dwBankIndex);
    
    if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_NAME_KEY, m_szBankName, pszProjectFile))
    {
        DPF_ERROR("An error occurred while attempting to write to the project file");
        hr = E_FAIL;
    }        

    if(SUCCEEDED(hr))
    {
        GetRelativePath(pszProjectFile, m_szBankFile, szText);
        
        if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_FILE_KEY, szText, pszProjectFile))
        {
            DPF_ERROR("An error occurred while attempting to write to the project file");
            hr = E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {
        GetRelativePath(pszProjectFile, m_szHeaderFile, szText);
        
        if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_HEADER_KEY, szText, pszProjectFile))
        {
            DPF_ERROR("An error occurred while attempting to write to the project file");
            hr = E_FAIL;
        }        
    }

    if(SUCCEEDED(hr))
    {
        sprintf(szText, "%lu", m_dwEntryCount);

        if(!WritePrivateProfileString(szSectionName, WBPROJECT_BANK_ENTRYCOUNT_KEY, szText, pszProjectFile))
        {
            DPF_ERROR("An error occurred while attempting to write to the project file");
            hr = E_FAIL;
        }        
    }

    if(SUCCEEDED(hr))
    {
        for(pleEntry = m_lstEntries.Flink, i = 0; (pleEntry != &m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, i++)
        {
            ASSERT(i < m_dwEntryCount);
        
            pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

            hr = pEntry->WriteProjectData(pszProjectFile, szSectionName, i);
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(i == m_dwEntryCount);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetBankDataSize
 *
 *  Description:
 *      Calculates the size of the wave bank's data segment, in bytes.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: bank data size.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBank::GetBankDataSize"

DWORD
CWaveBank::GetBankDataSize
(
    void
)                                   
{                                   
    DWORD                   dwSize      = 0;
    HRESULT                 hr          = S_OK;
    WAVEBANKENTRY           MetaData;
    PLIST_ENTRY             pleEntry;
    CWaveBankEntry *        pEntry;
    
    DPF_ENTER();

    //
    // Get entry meta-data and calculate the size based on the final file 
    // offset returned.
    //

    for(pleEntry = m_lstEntries.Flink; SUCCEEDED(hr) && (pleEntry != &m_lstEntries); pleEntry = pleEntry->Flink)
    {
        pEntry = CONTAINING_RECORD(pleEntry, CWaveBankEntry, m_leEntry);

        hr = pEntry->GetMetaData(&MetaData, &dwSize);
    }

    if(FAILED(hr))
    {
        dwSize = 0;
    }

    DPF_LEAVE(dwSize);

    return dwSize;
}


/****************************************************************************
 *
 *  CWaveBankProject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::CWaveBankProject"

CWaveBankProject::CWaveBankProject
(
    void
)
{
    DPF_ENTER();

    m_dwBankCount = 0;

    InitializeListHead(&m_lstBanks);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CWaveBankProject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::~CWaveBankProject"

CWaveBankProject::~CWaveBankProject
(
    void
)
{
    PLIST_ENTRY             pleBank;
    CWaveBank *             pBank;
    
    DPF_ENTER();

    //
    // Free all the entries
    //
    
    while((pleBank = m_lstBanks.Flink) != &m_lstBanks)
    {
        pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank);
        
        DELETE(pBank);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AddBank
 *
 *  Description:
 *      Adds a wave bank to the project.
 *
 *  Arguments:
 *      LPCSTR [in]: wave bank name.
 *      LPCSTR [in]: bank file path.
 *      LPCSTR [in]: header file path.
 *      CWaveBank ** [out]: bank object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::AddBank"

HRESULT
CWaveBankProject::AddBank
(
    LPCSTR                  pszBankName, 
    LPCSTR                  pszBankFile, 
    LPCSTR                  pszHeaderFile,
    CWaveBank **            ppBank
)
{
    CWaveBank *             pBank;
    HRESULT                 hr;
    
    DPF_ENTER();

    hr = HRFROMP(pBank = CreateBank());

    if(SUCCEEDED(hr))
    {
        hr = pBank->Initialize(pszBankName, pszBankFile, pszHeaderFile);
    }

    if(SUCCEEDED(hr))
    {
        if(ppBank)
        {
            *ppBank = pBank;
        }
    }
    else
    {
        DELETE(pBank);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Generate
 *
 *  Description:
 *      Generates wave bank files.
 *
 *  Arguments:
 *      CWaveBankCallback * [in]: callback object.
 *      BOOL [in]: TRUE to allow overwriting of files.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::Generate"

HRESULT
CWaveBankProject::Generate
(
    CWaveBankCallback *     pCallback,
    BOOL                    fAllowOverwrite
)
{
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleBank;
    PLIST_ENTRY             pleEntry;
    CWaveBank *             pBank;
    UINT                    nBankCount;
    UINT                    nEntryCount;

    DPF_ENTER();

    nBankCount = 0;
    nEntryCount = 0;
    
    for(pleBank = m_lstBanks.Flink; (pleBank != &m_lstBanks) && SUCCEEDED(hr); pleBank = pleBank->Flink)
    {
        pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank);

        for(pleEntry = pBank->m_lstEntries.Flink; (pleEntry != &pBank->m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink)
        {
            nEntryCount++;
        }

        nBankCount++;
    }

    if(pCallback)
    {
        if(!pCallback->BeginProject(nBankCount, nEntryCount))
        {
            hr = E_ABORT;
        }
    }

    if(!nBankCount)
    {
        DPF_ERROR("No banks in the project");
        hr = E_FAIL;
    }
    else if(!nEntryCount)
    {
        DPF_ERROR("No entries in the project");
        hr = E_FAIL;
    }

    for(pleBank = m_lstBanks.Flink; (pleBank != &m_lstBanks) && SUCCEEDED(hr); pleBank = pleBank->Flink)
    {
        pBank = CONTAINING_RECORD(pleBank, CWaveBank, m_leBank);

        hr = pBank->GenerateBank(pCallback, fAllowOverwrite);

        if(SUCCEEDED(hr))
        {
            hr = pBank->GenerateHeader(pCallback, fAllowOverwrite);
        }
    }

    if(pCallback)
    {
        pCallback->EndProject(hr);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ReadProjectData
 *
 *  Description:
 *      Initializes the project based on saved project data.
 *
 *  Arguments:
 *      LPCSTR [in]: project file name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::ReadProjectData"

HRESULT
CWaveBankProject::ReadProjectData
(
    LPCSTR                  pszProjectFile
)
{
    HRESULT                 hr                          = S_OK;
    CHAR                    szProjectFile[MAX_PATH];
    LPSTR                   pszFilePart;
    DWORD                   dwBankCount;
    CWaveBank *             pBank;
    char                    c;
    DWORD                   i;
    
    DPF_ENTER();

    //
    // Convert the project file name to a full path.  The INI APIs prefer it
    //

    GetFullPathName(pszProjectFile, NUMELMS(szProjectFile), szProjectFile, &pszFilePart);

    //
    // Set the current directory to the project file's to make sure any 
    // relative paths are expanded properly
    //

    c = *pszFilePart;
    *pszFilePart = 0;
    
    if(!SetCurrentDirectory(szProjectFile))
    {
        DPF_ERROR("Unable to change to project file directory");
        hr = E_FAIL;
    }

    *pszFilePart = c;

    //
    // Start loading banks
    //

    if(SUCCEEDED(hr))
    {
        dwBankCount = GetPrivateProfileInt(WBPROJECT_PROJECT_MAIN_SECTION, WBPROJECT_PROJECT_BANKCOUNT_KEY, 0, szProjectFile);

        for(i = 0; (i < dwBankCount) && SUCCEEDED(hr); i++)
        {
            hr = HRFROMP(pBank = CreateBank());

            if(SUCCEEDED(hr))
            {
                hr = pBank->ReadProjectData(szProjectFile, i);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  WriteProjectData
 *
 *  Description:
 *      Stores project data.
 *
 *  Arguments:
 *      LPCSTR [in]: project file name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWaveBankProject::WriteProjectData"

HRESULT
CWaveBankProject::WriteProjectData
(
    LPCSTR                  pszProjectFile
)
{
    HRESULT                 hr                      = S_OK;
    CStdFileStream          ProjectFile;
    CHAR                    szBankCount[MAX_PATH];
    PLIST_ENTRY             pleEntry;
    CWaveBank *             pBank;
    DWORD                   i;
    
    DPF_ENTER();

    //
    // Truncate the existing file
    //

    DeleteFile(pszProjectFile);

    //
    // Write project data
    //

    if(SUCCEEDED(hr))
    {
        sprintf(szBankCount, "%lu", m_dwBankCount);
        
        if(!WritePrivateProfileString(WBPROJECT_PROJECT_MAIN_SECTION, WBPROJECT_PROJECT_BANKCOUNT_KEY, szBankCount, pszProjectFile))
        {
            DPF_ERROR("An error occurred while attempting to write to the project file");
            hr = E_FAIL;
        }
    }

    //
    // Write all bank data
    //

    for(pleEntry = m_lstBanks.Flink, i = 0; (pleEntry != &m_lstBanks) && SUCCEEDED(hr); pleEntry = pleEntry->Flink, i++)
    {
        ASSERT(i < m_dwBankCount);
        
        pBank = CONTAINING_RECORD(pleEntry, CWaveBank, m_leBank);

        hr = pBank->WriteProjectData(pszProjectFile, i);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(i == m_dwBankCount);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Console\wbcommon.cpp ===
#include "..\common\wbcommon.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Common\writer.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/2/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       writer.h
 *  Content:    Wave bank writer.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/2/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WRITER_H__
#define __WRITER_H__

//
// File extensions
//

#define WBWRITER_FILEEXTENSION_PROJECT          "xwp"
#define WBWRITER_FILEEXTENSION_BANK             "xwb"
#define WBWRITER_FILEEXTENSION_HEADER           "h"
                                                
//                                              
// Project file format                          
//                                              
                                                
#define WBPROJECT_PROJECT_MAIN_SECTION          "PROJECT"
#define WBPROJECT_PROJECT_BANKCOUNT_KEY         "BANKCOUNT"
                                                
#define WBPROJECT_BANK_KEY                      "BANK%lu"
#define WBPROJECT_BANK_NAME_KEY                 "BANKNAME"
#define WBPROJECT_BANK_FILE_KEY                 "BANKFILE"
#define WBPROJECT_BANK_HEADER_KEY               "HEADERFILE"
#define WBPROJECT_BANK_ENTRYCOUNT_KEY           "ENTRYCOUNT"
                                                
#define WBPROJECT_ENTRY_KEY                     "ENTRY%lu"
                                                
#define WBPROJECT_ENTRYEXT_SEPARATOR_STR        ","
#define WBPROJECT_ENTRYEXT_SEPARATOR_LCHAR      ','

#define WBPROJECT_ENTRYEXT_ADPCMFILTER_STR      "c"
#define WBPROJECT_ENTRYEXT_ADPCMFILTER_LCHAR    'c'
                                                
#define WBPROJECT_ENTRYEXT_8BITFILTER_STR       "8"
#define WBPROJECT_ENTRYEXT_8BITFILTER_LCHAR     '8'

//
// C header file format
//

#define WBCHEADER_ENUMNAME                      "WAVEBANK_%s"
#define WBCHEADER_ENUMENTRYNAME                 WBCHEADER_ENUMNAME "_%s"
#define WBCHEADER_ENTRYCOUNTSHORTNAME           "ENTRY_COUNT"
#define WBCHEADER_ENTRYCOUNTNAME                WBCHEADER_ENUMNAME "_" WBCHEADER_ENTRYCOUNTSHORTNAME

#ifdef __cplusplus

//
// Forward declarations
//

class CWaveBank;
class CWaveBankProject;
class CWaveBankCallback;

//
// Wave bank entry
//

class CWaveBankEntry
{
public:
    static const DWORD      m_dwDataAlignment;      // Entry data file alignment

public:
    CWaveBank *             m_pParent;              // Parent object
    LIST_ENTRY              m_leEntry;              // Parent list entry
    CHAR                    m_szEntryName[0x100];   // Entry name
    CHAR                    m_szHeaderName[0x100];  // Entry name (header version)
    CHAR                    m_szFileName[MAX_PATH]; // Source file path
    WAVEBANKMINIWAVEFORMAT  m_Format;               // Format
    WAVEBANKENTRYREGION     m_PlayRegion;           // Wave data file offset/length
    WAVEBANKENTRYREGION     m_LoopRegion;           // Loop region
    DWORD                   m_dwFlags;              // Flags
    DWORD                   m_dwFileType;           // File type

public:
    CWaveBankEntry(CWaveBank *pParent);
    virtual ~CWaveBankEntry(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCSTR pszEntryName, LPCSTR pszFileName, DWORD dwFlags);

    // Entry properties
    virtual HRESULT SetName(LPCSTR pszName);
    virtual DWORD GetValidFlags(void);
    virtual DWORD SetFlags(DWORD dwMask, DWORD dwFlags);

    // Entry data
    virtual HRESULT GetMetaData(LPWAVEBANKENTRY pMetaData, LPDWORD pdwOffset);
    virtual HRESULT CommitWaveData(CStdFileStream *pBankFile, DWORD dwBaseOffset, LPCWAVEBANKENTRY pMetaData, LPVOID pvCopyBuffer, DWORD dwCopyBufferSize);

    // Project data
    virtual HRESULT ReadProjectData(LPCSTR pszProjectFile, LPCSTR pszSectionName, DWORD dwEntryIndex);
    virtual HRESULT WriteProjectData(LPCSTR pszProjectFile, LPCSTR pszSectionName, DWORD dwEntryIndex);

protected:
    // Initialization
    virtual HRESULT LoadWaveFile(void);

    // Validation
    virtual HRESULT FindDuplicateEntry(LPCSTR pszName, UINT *pnNameCount, LPCSTR pszPath, UINT *pnPathCount);
};

//
// Wave bank
//

class CWaveBank
{
public:
    CWaveBankProject *      m_pParent;                                  // Parent object
    LIST_ENTRY              m_leBank;                                   // Wave bank list entry
    CHAR                    m_szBankName[16];                           // Wave bank name
    CHAR                    m_szHeaderName[16];                         // Wave bank name (header version)
    CHAR                    m_szBankFile[MAX_PATH];                     // Wave bank file name
    CHAR                    m_szHeaderFile[MAX_PATH];                   // Wave bank header file name
    LIST_ENTRY              m_lstEntries;                               // Bank entry list
    DWORD                   m_dwEntryCount;                             // Wave bank entry count
    DWORD                   m_dwFlags;                                  // Wave bank flags

public:
    CWaveBank(CWaveBankProject *pParent = NULL);
    virtual ~CWaveBank(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCSTR pszBankName, LPCSTR pszBankFile, LPCSTR pszHeaderFile);

    // Bank properties
    virtual HRESULT SetName(LPCSTR pszName);
    virtual DWORD GetBankDataSize(void);

    // Entries
    virtual HRESULT AddEntry(LPCSTR pszEntryName, LPCSTR pszFileName, DWORD dwFlags, CWaveBankEntry **ppEntry = NULL);
    virtual void RemoveEntry(CWaveBankEntry *pEntry);

    // File creation
    virtual HRESULT GenerateBank(CWaveBankCallback *pCallback, BOOL fAllowOverwrite);
    virtual HRESULT GenerateHeader(CWaveBankCallback *pCallback, BOOL fAllowOverwrite);

    // Project data
    virtual HRESULT ReadProjectData(LPCSTR pszProjectFile, DWORD dwEntryIndex);
    virtual HRESULT WriteProjectData(LPCSTR pszProjectFile, DWORD dwEntryIndex);

protected:
    // Entry creation
    virtual CWaveBankEntry *CreateEntry(void);

    // Validation
    virtual HRESULT FindDuplicateBank(LPCSTR pszName, UINT *pnNameCount, LPCSTR pszBankFile, UINT *pnBankFile, LPCSTR pszHeaderFile, UINT *pnHeaderFile);
};

__inline void CWaveBank::RemoveEntry(CWaveBankEntry *pEntry)
{
    DELETE(pEntry);
}

__inline CWaveBankEntry *CWaveBank::CreateEntry(void)
{
    return NEW(CWaveBankEntry(this));
}

//
// Wave bank project
//

class CWaveBankProject
{
public:
    LIST_ENTRY              m_lstBanks;                 // Wave bank list
    DWORD                   m_dwBankCount;              // Bank count

public:
    CWaveBankProject(void);
    virtual ~CWaveBankProject(void);

public:
    // Banks
    virtual HRESULT AddBank(LPCSTR pszBankName, LPCSTR pszBankFile, LPCSTR pszHeaderFile, CWaveBank **ppBank);
    virtual void RemoveBank(CWaveBank *pBank);
    
    // File creation
    virtual HRESULT Generate(CWaveBankCallback *pCallback, BOOL fAllowOverwrite);

    // Project data
    virtual HRESULT ReadProjectData(LPCSTR pszProjectFile);
    virtual HRESULT WriteProjectData(LPCSTR pszProjectFile);

protected:    
    // Bank creation
    virtual CWaveBank *CreateBank(void);
};

__inline void CWaveBankProject::RemoveBank(CWaveBank *pBank)
{
    DELETE(pBank);
}

__inline CWaveBank *CWaveBankProject::CreateBank(void)
{
    return NEW(CWaveBank(this));
}

//
// Wave bank status callback
//

class CWaveBankCallback
{
public:
    virtual BOOL BeginProject(UINT nBankCount, UINT nEntryCount);
    virtual void EndProject(HRESULT hr);
    virtual BOOL OpenBank(LPCSTR pszFile);
    virtual void CloseBank(LPCSTR pszFile);
    virtual BOOL OpenHeader(LPCSTR pszFile);
    virtual void CloseHeader(LPCSTR pszFile);
    virtual BOOL BeginEntry(LPCSTR pszFile, DWORD dwFlags);
    virtual void EndEntry(LPCSTR pszFile, DWORD dwFlags);
};

__inline BOOL CWaveBankCallback::BeginProject(UINT nBankCount, UINT nEntryCount)
{
    return TRUE;
}

__inline void CWaveBankCallback::EndProject(HRESULT hr)
{
}

__inline BOOL CWaveBankCallback::OpenBank(LPCSTR pszFile)
{
    return TRUE;
}

__inline void CWaveBankCallback::CloseBank(LPCSTR pszFile)
{
}

__inline BOOL CWaveBankCallback::OpenHeader(LPCSTR pszFile)
{
    return TRUE;
}

__inline void CWaveBankCallback::CloseHeader(LPCSTR pszFile)
{
}

__inline BOOL CWaveBankCallback::BeginEntry(LPCSTR pszFile, DWORD dwFlags)
{
    return TRUE;
}

__inline void CWaveBankCallback::EndEntry(LPCSTR pszFile, DWORD dwFlags)
{
}

#endif // __cplusplus

#endif // __WRITER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\listview.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/12/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       listview.h
 *  Content:    Misc. list-view helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/12/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __LISTVIEW_H__
#define __LISTVIEW_H__

#undef ListView_SetItemText
#undef ListView_SortItems

//
// ListView_SortItems callback
//

typedef void (CALLBACK *LPFNLVSORTITEMS)(HWND hwnd, UINT nItem1, UINT nItem2, LPVOID pvContext);

//
// ListView helper functions
//

EXTERN_C LPARAM ListView_GetItemParam(HWND hwnd, UINT nItem);
EXTERN_C void ListView_SelectItem(HWND hwnd, UINT nItem, BOOL fSelected, BOOL fSingleSelect);
EXTERN_C void ListView_ResizeColumns(HWND hwndLV, int cx);
EXTERN_C void ListView_AutoSizeColumn(HWND hwnd, UINT nColumn);
EXTERN_C void ListView_AutoSizeColumns(HWND hwnd);
EXTERN_C BOOL ListView_SetItemText(HWND hwnd, UINT nItem, UINT nSubItem, LPCSTR pszFormat, ...);
EXTERN_C BOOL ListView_SortItems(HWND hwnd, UINT nSubItem, BOOL fString, BOOL fAscending, LPFNLVSORTITEMS pfnCallback, LPVOID pvContext);

#endif // __LISTVIEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\mru.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/26/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mru.h
 *  Content:    Most-recently-used list.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/26/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __MRU_H__
#define __MRU_H__

#define MRU_MAX_COUNT   4
#define MRU_KEY         "MRU"

#ifdef __cplusplus

//
// MRU list
//

class CMRU
{
public:
    LPCSTR                  m_pszParentKey;                         // Parent registry key
    CHAR                    m_aszPaths[MRU_MAX_COUNT][MAX_PATH];    // MRU file array
    HMENU                   m_hmenu;                                // MRU menu handle
    UINT                    m_nCommandId;                           // Base MRU item command identifier

public:
    CMRU(void);
    virtual ~CMRU(void);

public:
    // Initialization
    virtual void Initialize(LPCSTR pszParentKey, HMENU hMenu, UINT nCommandId);

    // MRU data
    virtual void Load(LPCSTR pszParentKey = NULL);
    virtual void Save(LPCSTR pszParentKey = NULL);
    virtual void AddItem(LPCSTR pszPath);
    
    // UI helpers
    virtual void Apply(void);
};

#endif // __cplusplus

#endif // __MRU_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\Console\console.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/6/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       console.cpp
 *  Content:    Wave Bundler Win32 console front-end.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/6/2001   dereks  Created.
 *
 ****************************************************************************/

#define EXENAME "WAVBNDLR"

#include "wavbndli.h"
#include <conio.h>

//
// Switch values
//

#define SWITCH_NOOVERWRITE  0x00000001
#define SWITCH_NOLOGO       0x00000002

//
// Class to implement overwrite printing to the console
//

class CPrintBoy
{
protected:
    UINT                    m_nLength;      // Length of the last print operation

public:
    CPrintBoy(void);

public:
    void Print(LPCSTR pszString);
    void Clear(void);
};

//
// Status callback
//

class CConsoleCallback
    : public CWaveBankCallback
{
public:
    CPrintBoy &             m_PrintBoy;     // Console print tool

public:
    CConsoleCallback(CPrintBoy &PrintBoy);

public:
    virtual BOOL OpenBank(LPCSTR pszFile);
    virtual BOOL OpenHeader(LPCSTR pszFile);
    virtual BOOL BeginEntry(LPCSTR pszFile, DWORD dwFlags);
};


/****************************************************************************
 *
 *  CPrintBoy
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPrintBoy::CPrintBoy"

CPrintBoy::CPrintBoy
(
    void
)
:   m_nLength(0)
{
}


/****************************************************************************
 *
 *  Print
 *
 *  Description:
 *      Clears the existing console text line and prints over the top of it.
 *
 *  Arguments:
 *      LPCSTR [in]: string.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPrintBoy::Print"

void
CPrintBoy::Print
(
    LPCSTR                  pszString
)
{
    static const int        nCharLimit  = 79;
    int                     nLength;
    int                     nDiff;
    int                     i;

    //
    // Truncate the string to 79 characters
    //

    for(i = 0; i < (int)m_nLength; i++)
    {
        _putch('\b');
    }

    for(nLength = 0; *pszString && (nLength < nCharLimit); nLength++, pszString++)
    {
        _putch(*pszString);
    }

    if((nDiff = m_nLength - nLength) > 0)
    {
        for(i = 0; i < nDiff; i++)
        {
            _putch(' ');
        }

        for(i = 0; i < nDiff; i++)
        {
            _putch('\b');
        }
    }
    
    m_nLength = nLength;
}


/****************************************************************************
 *
 *  Clear
 *
 *  Description:
 *      Clears the existing console text line and prints over the top of it.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CPrintBoy::Clear"

void
CPrintBoy::Clear
(
    void
)
{
    Print("");

    while(m_nLength)
    {
        _putch('\b');

        m_nLength--;
    }
}


/****************************************************************************
 *
 *  CConsoleCallback
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CPrintBoy & [in]: console print tool.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CConsoleCallback::CConsoleCallback"

CConsoleCallback::CConsoleCallback
(
    CPrintBoy &             PrintBoy
)
:   m_PrintBoy(PrintBoy)
{
}


/****************************************************************************
 *
 *  OpenBank
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      LPCSTR [in]: bank file name. 
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CConsoleCallback::OpenBank"

BOOL
CConsoleCallback::OpenBank
(
    LPCSTR                  pszFile
)
{
    m_PrintBoy.Clear();
    printf("Generating wave bank file %s\r\n", pszFile);

    return TRUE;
}


/****************************************************************************
 *
 *  OpenHeader
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      LPCSTR [in]: header file name. 
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CConsoleCallback::OpenHeader"

BOOL
CConsoleCallback::OpenHeader
(
    LPCSTR                  pszFile
)
{
    m_PrintBoy.Clear();
    printf("Generating header file %s\r\n", pszFile);

    return TRUE;
}


/****************************************************************************
 *
 *  BeginEntry
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      CWaveBankEntry * [in]: entry.
 *      DWORD [in]: entry flags.
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CConsoleCallback::BeginEntry"

BOOL
CConsoleCallback::BeginEntry
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags
)
{
    CHAR                    szText[MAX_PATH + 0x100];

    strcpy(szText, "Processing ");
    _splitpath(pszFile, NULL, NULL, &szText[strlen(szText)], NULL);

    m_PrintBoy.Print(szText);

    return TRUE;
}


/****************************************************************************
 *
 *  Banner
 *
 *  Description:
 *      Prints the "hey, look at me!" banner.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Banner"

void
Banner
(
    void
)
{
    CHAR                    szVersion[0x100];

    GetWaveBundlerVersion(szVersion);
    
    printf("\r\n");
    printf(EXENAME " version %s\r\n", szVersion);
    printf("Copyright (c) 2001 Microsoft Corporation.  All rights reserved.\r\n");
    printf("Creates wave banks for use on the Xbox.\r\n");
    printf("\r\n");
}


/****************************************************************************
 *
 *  Usage
 *
 *  Description:
 *      Prints usage information.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      int: -1.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Usage"

int
Usage
(
    void
)
{
    Banner();
    
    printf(EXENAME " [/N] [/L] <project>\r\n");
    printf("\r\n");
    printf("Usage:\r\n");
    printf("\r\n");
    printf("  project       Specifies the project file to build.\r\n");
    printf("  /N            Prevents destination files from being overwritten if they\r\n");
    printf("                already exist.\r\n");
    printf("  /L            Does not print the banner.\r\n");
    printf("\r\n");

    return -1;
}


/****************************************************************************
 *
 *  DebugCallback
 *
 *  Description:
 *      Callback function for debug messages.
 *
 *  Arguments:
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: debug string.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "DebugCallback"

void CALLBACK
DebugCallback
(
    DWORD                   dwLevel,
    LPCSTR                  pszString
)
{
    if(dwLevel <= DPFLVL_WARNING)
    {
        printf("\r\n");

        if(dwLevel < DPFLVL_WARNING)
        {
            printf("Error: %s", pszString);
        }
        else
        {
            printf("Warning: %s", pszString);
        }
        
        printf("\r\n");
    }
}


/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      int [in]: argument count.
 *      char ** [in]: arguments.
 *
 *  Returns:  
 *      int: 0 on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "main"

int __cdecl
main
(
    int                     argc,
    char **                 argv
)
{
    DWORD                   dwSwitches          = 0;
    LPSTR                   pszPrjFile          = NULL;
    HRESULT                 hr                  = S_OK;
    CWaveBankProject        Project;
    CPrintBoy               PrintBoy;
    CConsoleCallback        Callback(PrintBoy);
    LPCSTR                  psz;
    int                     i;

    //
    // Initialize globals
    //
    
    CDebug::m_pfnDpfCallback = DebugCallback;

    //
    // Parse the command-line
    //

    for(i = 1; (i < argc) && SUCCEEDED(hr); i++)
    {
        if(('/' == argv[i][0]) || ('-' == argv[i][0]))
        {
            for(psz = &argv[i][1]; *psz && SUCCEEDED(hr); psz++)
            {
                switch(*psz)
                {
                    case 'N':
                    case 'n':
                        dwSwitches |= SWITCH_NOOVERWRITE;
                        break;

                    case 'L':
                    case 'l':
                        dwSwitches |= SWITCH_NOLOGO;
                        break;

                    default:
                        hr = Usage();
                        break;
                }
            }
        }
        else if(!pszPrjFile)
        {
            pszPrjFile = argv[i];
        }
        else
        {
            hr = Usage();
        }
    }

    if(SUCCEEDED(hr) && !pszPrjFile)
    {
        hr = Usage();
    }

    if(SUCCEEDED(hr) && !(dwSwitches & SWITCH_NOLOGO))
    {
        Banner();
    }

    //
    // Initialize the wave bank project
    //

    if(SUCCEEDED(hr))
    {
        hr = Project.ReadProjectData(pszPrjFile);
    }

    //
    // Generate files
    //

    if(SUCCEEDED(hr))
    {
        hr = Project.Generate(&Callback, !(dwSwitches & SWITCH_NOOVERWRITE));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr) && !(dwSwitches & SWITCH_NOLOGO))
    {
        printf("\r\nSuccess!\r\n\r\n");
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\mru.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/26/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mru.cpp
 *  Content:    Most-recently-used list.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/26/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wbndgui.h"


/****************************************************************************
 *
 *  CMRU
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::CMRU"

CMRU::CMRU
(
    void
)
{
    UINT                    i;
    
    m_hmenu = NULL;

    for(i = 0; i < NUMELMS(m_aszPaths); i++)
    {
        m_aszPaths[i][0] = 0;
    }
}


/****************************************************************************
 *
 *  ~CMRU
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::~CMRU"

CMRU::~CMRU
(
    void
)
{
    Save();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializees the object to a menu.
 *
 *  Arguments:
 *      LPCSTR [in]: parent registry key.
 *      HMENU [in]: menu handle.
 *      UINT [in]: first MRU item command identifier.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::Initialize"

void
CMRU::Initialize
(
    LPCSTR                  pszParentKey,
    HMENU                   hmenu,
    UINT                    nCommandId
)
{
    m_hmenu = hmenu;
    m_nCommandId = nCommandId;

    Load(pszParentKey);
}


/****************************************************************************
 *
 *  Load
 *
 *  Description:
 *      Loads MRU data from the registry.
 *
 *  Arguments:
 *      LPCSTR [in]: parent registry key.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::Load"

void
CMRU::Load
(
    LPCSTR                  pszParentKey
)
{
    CHAR                    szValue[]   = "a";
    HKEY                    hkeyParent  = NULL;
    HKEY                    hkey        = NULL;
    DWORD                   dwSize;
    LONG                    lResult;
    UINT                    i;

    if(pszParentKey)
    {
        m_pszParentKey = pszParentKey;
    }
    else
    {
        pszParentKey = m_pszParentKey;
    }

    for(i = 0; i < NUMELMS(m_aszPaths); i++)
    {
        m_aszPaths[i][0] = 0;
    }
    
    if(pszParentKey)
    {
        lResult = RegCreateKey(HKEY_CURRENT_USER, pszParentKey, &hkeyParent);

        if(ERROR_SUCCESS == lResult)
        {
            lResult = RegCreateKey(hkeyParent, MRU_KEY, &hkey);
        }

        for(i = 0; (ERROR_SUCCESS == lResult) && (i < NUMELMS(m_aszPaths)); i++)
        {
            dwSize = sizeof(m_aszPaths[i]);
            lResult = RegQueryValueEx(hkey, szValue, NULL, NULL, (LPBYTE)m_aszPaths[i], &dwSize);

            szValue[0]++;
        }
    }

    Apply();

    if(hkey)
    {
        RegCloseKey(hkey);
    }

    if(hkeyParent)
    {
        RegCloseKey(hkeyParent);
    }
}


/****************************************************************************
 *
 *  Save
 *
 *  Description:
 *      Saves MRU data to the registry.
 *
 *  Arguments:
 *      LPCSTR [in]: parent registry key.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::Save"

void
CMRU::Save
(
    LPCSTR                  pszParentKey
)
{
    CHAR                    szValue[]   = "a";
    HKEY                    hkeyParent  = NULL;
    HKEY                    hkey        = NULL;
    DWORD                   dwSize;
    LONG                    lResult;
    UINT                    i;

    if(!pszParentKey)
    {
        pszParentKey = m_pszParentKey;
    }

    if(pszParentKey)
    {
        lResult = RegCreateKey(HKEY_CURRENT_USER, pszParentKey, &hkeyParent);

        if(ERROR_SUCCESS == lResult)
        {
            lResult = RegCreateKey(hkeyParent, MRU_KEY, &hkey);
        }

        for(i = 0; (ERROR_SUCCESS == lResult) && (i < NUMELMS(m_aszPaths)); i++)
        {
            if(!m_aszPaths[i][0])
            {
                break;
            }

            lResult = RegSetValueEx(hkey, szValue, 0, REG_SZ, (LPBYTE)m_aszPaths[i], strlen(m_aszPaths[i]) + 1);

            szValue[0]++;
        }
    }

    if(hkey)
    {
        RegCloseKey(hkey);
    }

    if(hkeyParent)
    {
        RegCloseKey(hkeyParent);
    }
}


/****************************************************************************
 *
 *  Apply
 *
 *  Description:
 *      Applies MRU data to the menu.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::Apply"

void
CMRU::Apply
(
    void
)
{
    CHAR                    szString[MAX_PATH + 0x100];
    UINT                    i;
    
    if(!m_hmenu)
    {
        return;
    }

    //
    // Remove existing menu items
    //
    
    while(DeleteMenu(m_hmenu, 0, MF_BYPOSITION));

    //
    // Add MRU data
    //

    if(m_aszPaths[0][0])
    {
        for(i = 0; i < NUMELMS(m_aszPaths); i++)
        {
            if(!m_aszPaths[i][0])
            {
                break;
            }

            sprintf(szString, "&%lu\t%s", i + 1, m_aszPaths[i]);

            AppendMenu(m_hmenu, MF_STRING, m_nCommandId + i, szString);
        }
    }
    else
    {
        AppendMenu(m_hmenu, MF_STRING | MF_GRAYED, m_nCommandId, "Recent File");
    }
}


/****************************************************************************
 *
 *  AddItem
 *
 *  Description:
 *      Adds an item to the MRU list.
 *
 *  Arguments:
 *      LPCSTR [in]: item path.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMRU::AddItem"

void
CMRU::AddItem
(
    LPCSTR                  pszPath
)
{
    UINT                    nItemIndex          = -1;
    CHAR                    szTemp[MAX_PATH];
    UINT                    i;
    
    //
    // See if the item already appears in the list
    //

    for(i = 0; i < NUMELMS(m_aszPaths); i++)
    {
        if(!m_aszPaths[i][0])
        {
            break;
        }

        if(!_strcmpi(pszPath, m_aszPaths[i]))
        {
            nItemIndex = i;
            break;
        }
    }

    //
    // If the item's already in the list, just reorder so it's at the top.  If
    // not, add the item to the top of the list.
    //

    if(nItemIndex >= NUMELMS(m_aszPaths))
    {
        nItemIndex = NUMELMS(m_aszPaths) - 1;
    }

    for(i = nItemIndex; i > 0; i--)
    {
        strcpy(m_aszPaths[i], m_aszPaths[i - 1]);
    }

    strcpy(m_aszPaths[0], pszPath);

    //
    // Update UI
    //

    Apply();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\listview.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/12/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       listview.cpp
 *  Content:    Misc. list-view helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/12/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wbndgui.h"

BEGIN_DEFINE_STRUCT()
    HWND            hwnd;
    UINT            nSubItem;
    BOOL            fString;
    BOOL            fAscending;
    LPFNLVSORTITEMS pfnCallback;
    LPVOID          pvContext;
END_DEFINE_STRUCT(LVSORTITEMDATA);


/****************************************************************************
 *
 *  ListView_SelectItem
 *
 *  Description:
 *      Sets the selection state of a list view item.
 *
 *  Arguments:
 *      HWND [in]: list view window handle.
 *      UINT [in]: item index.
 *      BOOL [in]: TRUE to select the item; FALSE to unselect it.
 *      BOOL [in]: TRUE to unselect all other items.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ListView_SelectItem"

void
ListView_SelectItem
(
    HWND                    hwnd,
    UINT                    nItem,
    BOOL                    fSelected,
    BOOL                    fSingleSelect
)
{
    static const DWORD      dwStateMask = LVIS_SELECTED | LVIS_FOCUSED;
    int                     nItemCount;
    int                     i;
    
    if(fSingleSelect)
    {
        nItemCount = ListView_GetItemCount(hwnd);

        for(i = 0; i < (int)nItemCount; i++)
        {
            if(i != (int)nItem)
            {
                ListView_SetItemState(hwnd, i, 0, dwStateMask);
            }
        }
    }

    ListView_SetItemState(hwnd, nItem, fSelected ? dwStateMask : 0, dwStateMask);
}


/****************************************************************************
 *
 *  ListView_ResizeColumns
 *
 *  Description:
 *      Resizes all columns in a list view.
 *
 *  Arguments:
 *      HWND [in]: list view window handle.
 *      int [in]: column width.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ListView_ResizeColumns"

void
ListView_ResizeColumns
(
    HWND                    hwnd,
    int                     cx
)
{
    HWND                    hwndHeader;
    int                     nColumns;
    int                     i;

    hwndHeader = ListView_GetHeader(hwnd);
    nColumns = Header_GetItemCount(hwndHeader);

    for(i = 0; i < nColumns; i++)
    {
        ListView_SetColumnWidth(hwnd, i, cx);
    }
}


/****************************************************************************
 *
 *  ListView_AutoSizeColumn
 *
 *  Description:
 *      Resizes a columns in a list view.
 *
 *  Arguments:
 *      HWND [in]: list view window handle.
 *      UINT [in]: column index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ListView_AutoSizeColumn"

void
ListView_AutoSizeColumn
(
    HWND                    hwnd,
    UINT                    nColumn
)
{
    static const int        nMarginWidth    = 7;
    CHAR                    szText[0x400];
    int                     nLargestWidth;
    int                     nWidth;
    int                     nCount;
    LVCOLUMN                lvc;
    int                     i;
    
    //
    // Get the width of the column header text
    //

    lvc.mask = LVCF_TEXT;
    lvc.pszText = szText;
    lvc.cchTextMax = NUMELMS(szText);
    
    ListView_GetColumn(hwnd, nColumn, &lvc);

    nLargestWidth = ListView_GetStringWidth(hwnd, szText);

    //
    // Get the width of each item in the column
    //

    nCount = ListView_GetItemCount(hwnd);
    
    for(i = 0; i < nCount; i++)
    {
        ListView_GetItemText(hwnd, i, nColumn, szText, NUMELMS(szText));

        if((nWidth = ListView_GetStringWidth(hwnd, szText)) > nLargestWidth)
        {
            nLargestWidth = nWidth;
        }
    }

    //
    // Factor in the margins and set the column width
    //

    ListView_SetColumnWidth(hwnd, nColumn, nLargestWidth + (nMarginWidth * 2));
}


/****************************************************************************
 *
 *  ListView_AutoSizeColumns
 *
 *  Description:
 *      Resizes all columns in a list view.
 *
 *  Arguments:
 *      HWND [in]: list view window handle.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ListView_AutoSizeColumns"

void
ListView_AutoSizeColumns
(
    HWND                    hwnd
)
{
    HWND                    hwndHeader;
    int                     nCount;
    int                     i;
    
    hwndHeader = ListView_GetHeader(hwnd);
    nCount = Header_GetItemCount(hwndHeader);

    for(i = 0; i < nCount; i++)
    {
        ListView_AutoSizeColumn(hwnd, i);
    }
}


/****************************************************************************
 *
 *  ListView_SetItemText
 *
 *  Description:
 *      Sets the text for a list-view item.
 *
 *  Arguments:
 *      HWND [in]: list view window handle.
 *      UINT [in]: item index.
 *      UINT [in]: sub-item index.
 *      LPCSTR [in]: item format text.
 *      ...
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ListView_SetItemText"

BOOL
ListView_SetItemText
(
    HWND                    hwnd,
    UINT                    nItem,
    UINT                    nSubItem,
    LPCSTR                  pszFormat,
    ...
)
{
    CHAR                    szText[0x100];
    LVITEM                  lvi;
    va_list                 va;

    va_start(va, pszFormat);
    vsprintf(szText, pszFormat, va);
    va_end(va);

    lvi.mask = LVIF_TEXT;
    lvi.iItem = nItem;
    lvi.iSubItem = nSubItem;
    lvi.pszText = szText;
    
    return ListView_SetItem(hwnd, &lvi);
}


/****************************************************************************
 *
 *  ListView_SortCallback
 *
 *  Description:
 *      ListView_SortItemsEx callback.
 *
 *  Arguments:
 *      LPARAM [in]: item index.
 *      LPARAM [in]: item index.
 *      LPARAM [in]: sort parameter.
 *
 *  Returns:  
 *      int: negative value if the first item should precede the second, a 
 *           positive value if the first item should follow the second, or 
 *           zero if the two items are equivalent. 
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ListView_SortCallback"

int CALLBACK
ListView_SortCallback
(
    LPARAM                  nItem0,
    LPARAM                  nItem1,
    LPARAM                  lContext
)
{
    LPCLVSORTITEMDATA       pContext            = (LPCLVSORTITEMDATA)lContext;
    CHAR                    szText[2][0x400];
    INT                     nValue[2];
    int                     nResult;
    
    ListView_GetItemText(pContext->hwnd, nItem0, pContext->nSubItem, szText[0], NUMELMS(szText[0]));
    ListView_GetItemText(pContext->hwnd, nItem1, pContext->nSubItem, szText[1], NUMELMS(szText[1]));

    if(pContext->fString)
    {
        nResult = strcmp(szText[0], szText[1]);
    }
    else
    {
        nValue[0] = atoi(szText[0]);
        nValue[1] = atoi(szText[1]);

        nResult = nValue[0] - nValue[1];
    }        

    if(!pContext->fAscending)
    {
        nResult = -nResult;
    }

    if((nResult > 0) && pContext->pfnCallback)
    {
        pContext->pfnCallback(pContext->hwnd, nItem0, nItem1, pContext->pvContext);
    }

    return nResult;
}


/****************************************************************************
 *
 *  ListView_SortItems
 *
 *  Description:
 *      Sorts a list of string items.
 *
 *  Arguments:
 *      HWND [in]: list-view window handle.
 *      UINT [in]: sub-item to sort by.
 *      BOOL [in]: TRUE to sort as a string; FALSE to sort as a number.
 *      BOOL [in]: TRUE to sort items in ascending order; FALSE for 
 *                 descending.
 *      LPFNLVSORTITEMS [in]: callback function called when two items are
 *                            swapped.
 *      LPVOID [in]: callback context.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ListView_SortItems"

BOOL
ListView_SortItems
(
    HWND                    hwnd,
    UINT                    nSubItem,
    BOOL                    fString,
    BOOL                    fAscending,
    LPFNLVSORTITEMS         pfnCallback,
    LPVOID                  pvContext
)
{
    LVSORTITEMDATA          data;

    data.hwnd = hwnd;
    data.nSubItem = nSubItem;
    data.fString = fString;
    data.fAscending = fAscending;
    data.pfnCallback = pfnCallback;
    data.pvContext = pvContext;
    
    return ListView_SortItemsEx(hwnd, ListView_SortCallback, (LPARAM)&data);
}


/****************************************************************************
 *
 *  ListView_GetItemParam
 *
 *  Description:
 *      Gets the 32-bit data associated with a list-view item.
 *
 *  Arguments:
 *      HWND [in]: list-view window handle.
 *      UINT [in]: item index.
 *
 *  Returns:  
 *      LPARAM: item data or 0 on error.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ListView_GetItemParam"

LPARAM
ListView_GetItemParam
(
    HWND                    hwnd, 
    UINT                    nItem
)
{
    LVITEM                  lvi;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = nItem;
    lvi.iSubItem = 0;

    if(!ListView_GetItem(hwnd, &lvi))
    {
        return 0;
    }

    return lvi.lParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\wbcommon.cpp ===
#include "..\common\wbcommon.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GUI.rc
//
#define IDM_MAIN                        101
#define IDA_MAIN                        102
#define IDD_GENERATE                    108
#define IDI_PROJECT                     109
#define IDI_BANK                        110
#define IDI_ENTRY                       112
#define IDB_TOOLBAR                     120
#define IDM_BANK_POPUP                  126
#define IDM_ENTRY_POPUP                 127
#define IDD_AUDITION                    128
#define IDD_ABOUT                       129
#define IDC_ENTRY                       1014
#define IDC_PROGRESS                    1015
#define IDC_BANK                        1016
#define IDC_ADDRESS                     1017
#define IDC_SEPARATOR                   1018
#define IDC_APPNAME                     1019
#define IDC_VERSION                     1020
#define IDC_COPYRIGHT                   1021
#define ID_FILE_EXIT                    40001
#define ID_HELP_ABOUT                   40006
#define ID_BANK_ADD                     40007
#define ID_BANK_REMOVE                  40008
#define ID_ENTRY_ADD                    40009
#define ID_ENTRY_REMOVE                 40010
#define ID_PROJECT_GENERATE             40014
#define ID_DELETE                       40015
#define ID_BANK_RENAME                  40016
#define ID_ENTRY_RENAME                 40019
#define ID_RENAME                       40021
#define ID_SELECT_ALL                   40023
#define ID_CONVERT_8BIT                 40026
#define ID_CONVERT_ADPCM                40027
#define ID_REMOVE                       40029
#define ID_ENTRY_AUDITION               40030
#define ID_REFRESH                      40031
#define ID_ENTRY_CANCEL_AUDITION        40032
#define IDS_APPTITLE                    57615

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         40034
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\wbndgui.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wbndgui.h
 *  Content:    Main header for the Wave Bundler GUI.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WBNDGUI_H__
#define __WBNDGUI_H__

#define USE_XBOX_COLORS

#define XBOX_BLACK  RGB(0, 0, 0)
#define XBOX_GREEN  RGB(0, 255, 0)

#define WBND_REG_KEY        "Software\\Microsoft\\Microsoft Xbox SDK\\Wave Bundler"
#define WBND_REG_VAL_WNDPOS "Window Placement"

#include "wavbndli.h"
#include <commctrl.h>
#include <shellapi.h>
#include <commdlg.h>
#include <afxres.h>
#include <xboxdbg.h>
#include "resource.h"
#include "wndwrap.h"
#include "mru.h"
#include "listview.h"
#include "sbgui.h"
#include "winmain.h"

#endif // __WBNDGUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\sbgui.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/11/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sbgui.h
 *  Content:    GUI versions of wave bank objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/11/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __SBGUI_H__
#define __SBGUI_H__

//
// ListView column data
//

BEGIN_DEFINE_STRUCT()
    LPCSTR  pszText;            // Column header text
    BOOL    fString;            // String or numeric value
    BOOL    fAscending;         // Ascending or descending sort order
END_DEFINE_STRUCT(LVCOLUMNDATA);

#ifdef __cplusplus

//
// Forward declarations
//

class CGuiWaveBank;
class CGuiWaveBankProject;
class CGenerateDialog;

//
// Wave bank entry
//

class CGuiWaveBankEntry
    : public CWaveBankEntry
{
public:
    static LVCOLUMNDATA     m_aColumnData[8];   // Column data

public:
    CGuiWaveBank *          m_pParent;          // Parent object
    HICON                   m_hIcon;            // Icon handle

public:
    CGuiWaveBankEntry(CGuiWaveBank *pParent);
    virtual ~CGuiWaveBankEntry(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCSTR pszEntryName, LPCSTR pszWaveFile, DWORD dwFlags);
    virtual HRESULT Refresh(void);

    // Properties
    virtual HRESULT SetName(LPCSTR pszName);
    virtual DWORD SetFlags(DWORD dwMask, DWORD dwFlags);

    // UI helpers
    virtual void UpdateListView(UINT nItem = -1);

    // Indexing
    static CGuiWaveBankEntry *GetEntry(HWND hwnd, UINT nItem);
    virtual UINT GetItemIndex(void);

    // Auditioning
    virtual HRESULT Audition(PDM_CONNECTION pxbdm);
};

__inline HRESULT CGuiWaveBankEntry::Refresh(void)
{
    return LoadWaveFile();
}

__inline CGuiWaveBankEntry *CGuiWaveBankEntry::GetEntry(HWND hwnd, UINT nItem)
{
    return (CGuiWaveBankEntry *)ListView_GetItemParam(hwnd, nItem);
}

//
// Wave bank
//

class CGuiWaveBank
    : public CWaveBank
{
public:
    static LVCOLUMNDATA     m_aColumnData[5];   // Column data

public:
    CGuiWaveBankProject *   m_pParent;          // Parent object

public:
    CGuiWaveBank(CGuiWaveBankProject *pParent);
    virtual ~CGuiWaveBank(void);

public:
    // Initialization
    virtual HRESULT Initialize(LPCSTR pszBankName, LPCSTR pszBankFile, LPCSTR pszHeaderFile);
    virtual HRESULT Refresh(void);
    
    // Properties
    virtual HRESULT SetName(LPCSTR pszName);
    
    // Entries
    virtual HRESULT AddEntry(void);
    virtual void SortEntryList(UINT nColumnIndex);
    
    // UI helpers
    virtual UINT GetItemIndex(void);
    virtual void UpdateListView(UINT nItem = -1);

    // Indexing
    static CGuiWaveBank *GetBank(HWND hwnd, UINT nItem);

protected:
    // Entry creation
    virtual CWaveBankEntry *CreateEntry(void);
};

__inline CWaveBankEntry *CGuiWaveBank::CreateEntry(void)
{
    return NEW(CGuiWaveBankEntry(this));
}

__inline CGuiWaveBank *CGuiWaveBank::GetBank(HWND hwnd, UINT nItem)
{
    return (CGuiWaveBank *)ListView_GetItemParam(hwnd, nItem);
}

//
// Wave bank generation callback dialog
//

class CGenerateDialog
    : public CModelessDialog, public CWaveBankCallback
{
public:
    enum
    {
        IDD = IDD_GENERATE,
    };

public:
    CHAR                    m_szBankText[0x100];    // Bank status formatting string
    CHAR                    m_szEntryText[0x100];   // Entry status formatting string
    BOOL                    m_fContinue;            // TRUE to continue processing
    BOOL                    m_fAllowClose;          // TRUE to allow the dialog to close
    UINT                    m_nEntryIndex;          // Current entry index
    HANDLE                  m_hTerminateEvent;      // Thread termination event

public:
    CGenerateDialog(void);
    virtual ~CGenerateDialog(void);

public:
    // Creation
    virtual HWND Create(CGuiWaveBankProject *pProject);

    // Message handlers
    virtual BOOL OnInitDialog(LPVOID pvContext, LRESULT *plResult);

    // Command handlers
    virtual void OnCancel(void);

    // Notification handlers
    virtual BOOL BeginProject(UINT nBankCount, UINT nEntryCount);
    virtual void EndProject(HRESULT hr);
    virtual BOOL OpenBank(LPCSTR pszFile);
    virtual BOOL BeginEntry(LPCSTR pszFile, DWORD dwFlags);
    virtual void EndEntry(LPCSTR pszFile, DWORD dwFlags);
};    

//
// Wave bank project
//

class CGuiWaveBankProject
    : public CWaveBankProject
{
public:
    CWindow *               m_pParent;                      // Parent object
    HWND                    m_hwndBankList;                 // Bank list-view window handle
    HIMAGELIST              m_himlBankList;                 // Bank list-view image list
    HWND                    m_hwndEntryList;                // Entry list-view window handle
    HIMAGELIST              m_himlEntryList;                // Entry list-view image list
    CGuiWaveBank *          m_pActiveBank;                  // The currently active bank
    CHAR                    m_szProjectFile[MAX_PATH];      // Project file path
    HICON                   m_hBankIcon;                    // Bank icon handle
    INT                     m_nBankIcon;                    // Bank icon index into the bank image-list
    CGenerateDialog         m_GenerateDialog;               // Generation dialog

public:
    CGuiWaveBankProject(CWindow *pParent);
    virtual ~CGuiWaveBankProject(void);

public:
    // Project file
    virtual HRESULT Open(LPCSTR pszProjectFile = NULL);
    virtual HRESULT Save(BOOL fPrompt = FALSE);
    
    // Project managment
    virtual HRESULT AddBank(void);
    virtual void RemoveBank(UINT nBankIndex);
    virtual HRESULT AddEntry(void);
    virtual void RemoveEntry(UINT nEntryIndex);
    virtual void SortBankList(UINT nColumnIndex);
    virtual void SortEntryList(UINT nColumnIndex);

    // File creation
    virtual HRESULT Generate(void);

    // UI helpers
    virtual void Attach(HWND hwndBankList, HWND hwndEntryList);
    virtual void Detach(BOOL fClearList = TRUE);
    virtual void SelectBank(UINT nBankIndex);
    virtual void ClearEntryList(void);
    virtual void FillEntryList(void);
    virtual HRESULT Refresh(void);

protected:
    // Bank creation
    virtual CWaveBank *CreateBank(void);

    // Generate thread
    virtual HRESULT GenerateThread(void);

private:
    static DWORD WINAPI GenerateThreadProc(LPVOID pvContext);
};

__inline CWaveBank *CGuiWaveBankProject::CreateBank(void)
{
    return NEW(CGuiWaveBank(this));
}

__inline void CGuiWaveBankProject::SortEntryList(UINT nColumnIndex)
{
    if(m_pActiveBank)
    {
        m_pActiveBank->SortEntryList(nColumnIndex);
    }
}

#endif // __cplusplus

#endif // __SBGUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\winmain.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winmain.h
 *  Content:    Application entry point and main window object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WINMAIN_H__
#define __WINMAIN_H__

//
// Toolbar button indices
//

BEGIN_DEFINE_ENUM()
    BTN_LEAF = 0,
    BTN_OPEN,
    BTN_SAVE,
    BTN_BANK,
    BTN_ENTRY,
    BTN_GENERATE,
    BTN_ADPCM,
    BTN_8BIT,
    BTN_AUDITION,
    BTN_STOP,
    BTN_COUNT,
END_DEFINE_ENUM_();

//
// List-view column data
//

BEGIN_DEFINE_STRUCT()
    LPLVCOLUMNDATA  paColumnData;
    UINT            nColumnCount;
END_DEFINE_STRUCT(LVCOLUMNDATAPTR);

#ifdef __cplusplus

//
// Main window class
//

class CMainWindow
    : public CWindow, public CWaveBankCallback
{
public:
    enum                                                                // Control identifiers
    {
        IDC_MAIN_BANKLIST = 0,
        IDC_MAIN_ENTRYLIST,
        IDC_MAIN_TOOLBAR,
        IDC_MAIN_STATUSBAR,
        IDC_MAIN_COUNT
    };

    LVCOLUMNDATAPTR             m_aColumnData[IDC_MAIN_ENTRYLIST + 1];  // Column data
    HWND                        m_ahwndControls[IDC_MAIN_COUNT];        // Control window handles
    HMENU                       m_ahmenuPopup[IDC_MAIN_ENTRYLIST + 1];  // Popup menus
    CGuiWaveBankProject *       m_pProject;                             // Project object
    CMRU                        m_MRU;                                  // MRU list
    BOOL                        m_fDirty;                               // Does the project need to be saved?
    PDM_CONNECTION              m_pxbdm;                                // Xbox debugger connection

public:
    CMainWindow(void);
    virtual ~CMainWindow(void);

public:
    // Creation
    virtual BOOL Create(void);

    // Message handlers
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnClose(LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);
    virtual BOOL OnSize(DWORD dwResize, int nWidth, int nHeight, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hwndControl, LRESULT *plResult);
    virtual BOOL OnNotify(LPNMHDR pHdr, LRESULT *plResult);
    virtual BOOL OnContextMenu(HWND hwnd, int x, int y, LRESULT *plResult);
    virtual BOOL OnMenuSelect(UINT nMenuItem, UINT nFlags, HMENU hMenu, LRESULT *plResult);

    // Command handlers
    virtual void OnNewProject(BOOL fAddBank = TRUE);
    virtual void OnOpenProject(LPCSTR pszProjectFile = NULL);
    virtual void OnSaveProject(BOOL fPrompt);
    virtual void OnNewBank(BOOL fAddEntries = TRUE);
    virtual void OnRemoveBank(void);
    virtual void OnNewEntry(void);
    virtual void OnRemoveEntry(void);
    virtual void OnConvert(DWORD dwMask);
    virtual void OnGenerate(void);
    virtual void OnDelete(HWND hwnd = NULL);
    virtual void OnRename(HWND hwnd = NULL);
    virtual void OnSelectAll(HWND hwnd = NULL);
    virtual void OnExit(void);
    virtual void OnAbout(void);
    virtual void OnRefresh(void);
    virtual void OnAudition(void);
    virtual void OnCancelAudition(void);

    // Notification handlers
    virtual void OnToolTipDisplayInfo(LPNMTTDISPINFO pInfo);
    virtual void OnListViewItemChanged(LPNMLISTVIEW pInfo);
    virtual void OnBankListItemStateChange(void);
    virtual void OnEntryListItemStateChange(void);
    virtual void OnListViewColumnClick(LPNMLISTVIEW pInfo);
    virtual void OnListViewBeginLabelEdit(NMLVDISPINFO *pInfo);
    virtual void OnListViewEndLabelEdit(NMLVDISPINFO *pInfo);
    virtual BOOL BeginEntry(LPCSTR pszFile, DWORD dwFlags);

protected:
    // UI helpers
    virtual HWND CreateListView(UINT nCommandId);
    virtual HWND CreateToolBar(void);
    virtual HWND CreateStatusBar(void);
    virtual void MakeDirty(BOOL fDirty = TRUE, BOOL fForce = FALSE);
    virtual BOOL CheckDirty(void);
    virtual void UpdateAppTitle(void);
    
    virtual void SetCommandState(UINT nCommandId, BOOL fEnable, BOOL fCheck);
    virtual void SetBankCommandStates(void);
    virtual void SetEntryCommandStates(void);
    virtual void SetCommandStates(void);

    // Remote helpers
    virtual BOOL ConnectRemote(void);
};

//
// About box
//

class CAboutDialog
    : public CModalDialog
{
public:
    enum
    {
        IDD = IDD_ABOUT,
    };

public:
    CAboutDialog(void);
    virtual ~CAboutDialog(void);

public:
    // Creation
    virtual BOOL Create(CWindow *pParent = NULL);

    // Message handlers
    virtual BOOL OnInitDialog(LPVOID pvContext, LRESULT *plResult);
};    

#endif // __cplusplus

#endif // __WINMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\winmain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winmain.cpp
 *  Content:    Application entry point and main window object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wbndgui.h"

CHAR g_szAppTitle[0x100];
HWND g_hwndMain = NULL;
LPCSTR g_pszAppTitle = g_szAppTitle;
HINSTANCE g_hInstance = NULL;


/****************************************************************************
 *
 *  WinMain
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      HINSTANCE [in]: application instance handle.
 *      HINSTANCE [in]: unused.
 *      LPSTR [in]: application command-line.
 *      INT [in]: show command.
 *
 *  Returns:  
 *      INT: application return code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WinMain"

INT WINAPI
WinMain
(
    HINSTANCE               hInstance,
    HINSTANCE               hUnused,
    LPSTR                   pszCmdLine,
    INT                     nShowCmd
)
{
    INITCOMMONCONTROLSEX    icc;
    CMainWindow             Window;
    BOOL                    fSuccess;
    CHAR                    szPath[MAX_PATH];
    UINT                    a, b;

    //
    // Initialize globals
    //
    
    g_hInstance = hInstance;
    CDebug::m_pfnDpfCallback = CWindow::DebugCallback;

    //
    // Initialize the common controls library
    //
    
    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_WIN95_CLASSES;
    
    fSuccess = InitCommonControlsEx(&icc);

    //
    // Load the application title
    //

    LoadString(hInstance, IDS_APPTITLE, g_szAppTitle, NUMELMS(g_szAppTitle));

#ifdef _DEBUG

    strcat(g_szAppTitle, " (debug)");

#endif // _DEBUG
    
    //
    // Create the main window
    //

    if(fSuccess)
    {
        fSuccess = Window.Create();
    }

    //
    // If a project file was specified in the command line, open it
    //

    if(fSuccess && pszCmdLine)
    {
        Window.OnOpenProject(pszCmdLine);
    }

    //
    // Enter the message pump
    //

    if(fSuccess)
    {
        Window.PumpMessages();
    }

    return !fSuccess;
}


/****************************************************************************
 *
 *  CMainWindow
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::CMainWindow"

CMainWindow::CMainWindow
(
    void
)
{
    ZeroMemory(&m_ahwndControls, sizeof(m_ahwndControls));
    ZeroMemory(&m_ahmenuPopup, sizeof(m_ahmenuPopup));

    m_pProject = NULL;
    m_fDirty = FALSE;
    m_pxbdm = NULL;

    m_aColumnData[IDC_MAIN_BANKLIST].paColumnData = CGuiWaveBank::m_aColumnData;
    m_aColumnData[IDC_MAIN_BANKLIST].nColumnCount = NUMELMS(CGuiWaveBank::m_aColumnData);

    m_aColumnData[IDC_MAIN_ENTRYLIST].paColumnData = CGuiWaveBankEntry::m_aColumnData;
    m_aColumnData[IDC_MAIN_ENTRYLIST].nColumnCount = NUMELMS(CGuiWaveBankEntry::m_aColumnData);
}


/****************************************************************************
 *
 *  ~CMainWindow
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::~CMainWindow"

CMainWindow::~CMainWindow
(
    void
)
{
    CHAR                    szCommand[0x100];
    UINT                    i;

    for(i = 0; i < NUMELMS(m_ahmenuPopup); i++)
    {
        if(m_ahmenuPopup[i])
        {
            DestroyMenu(m_ahmenuPopup[i]);
        }
    }

    if(m_pxbdm)
    {
        sprintf(szCommand, "XAUD!disconnect %s", g_pszAppTitle);

        DmSendCommand(m_pxbdm, szCommand, NULL, NULL);
        DmCloseConnection(m_pxbdm);
    }
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::Create"

BOOL
CMainWindow::Create
(
    void
)
{
    WNDCREATE               Create;
    LRESULT                 lrWndPos;
    HKEY                    hkey;
    WINDOWPLACEMENT         wp;
    DWORD                   cbSize;

    ZeroMemory(&Create, sizeof(Create));

    Create.dwClassStyle = CS_OWNDC;
    Create.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_PROJECT));
    Create.hCursor = LoadCursor(NULL, IDC_ARROW);
    Create.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
    Create.pszClassName = "Wave Bundler GUI";
    Create.pszWindowName = NULL;
    Create.dwStyle = WS_OVERLAPPEDWINDOW;
    Create.x = CW_USEDEFAULT;
    Create.y = CW_USEDEFAULT;
    Create.nWidth = CW_USEDEFAULT;
    Create.nHeight = CW_USEDEFAULT;
    Create.pszMenu = MAKEINTRESOURCE(IDM_MAIN);
    Create.pszAccelerator = MAKEINTRESOURCE(IDA_MAIN);

    if(!CWindow::Create(&Create))
    {
        return FALSE;
    }

    //
    // Load window position and state.  If none exist, center the window
    // over the default monitor
    //

    if(ERROR_SUCCESS == (lrWndPos = RegOpenKey(HKEY_CURRENT_USER, WBND_REG_KEY, &hkey)))
    {
        cbSize = sizeof(wp);
        
        lrWndPos = RegQueryValueEx(hkey, WBND_REG_VAL_WNDPOS, NULL, NULL, (LPBYTE)&wp, &cbSize);

        RegCloseKey(hkey);
    }

    if(ERROR_SUCCESS == lrWndPos)
    {
        if(SW_SHOWMAXIMIZED != wp.showCmd)
        {
            wp.showCmd = SW_SHOWNORMAL;
        }
        
        MoveWindow(wp.rcNormalPosition);
        ShowWindow(m_hwnd, wp.showCmd);
    }
    else
    {            
        CenterWindow(m_hwnd, NULL);
        ShowWindow(m_hwnd, SW_SHOWNORMAL);
    }

    //
    // Connect to the remote audio console
    //

    ConnectRemote();

    //
    // Initialize the project
    //

    OnNewProject(FALSE);

    return TRUE;
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles creation of the window.
 *
 *  Arguments:
 *      LPVOID [in]: window creation context.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnCreate"

BOOL
CMainWindow::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    BOOL                    fHandled;
    HMENU                   hSubMenu;
    
    //
    // Save the main window handle
    //

    g_hwndMain = m_hwnd;

    //
    // Hand off to the base class
    //
    
    fHandled = CWindow::OnCreate(pvContext, plResult);

    //
    // Set the window title
    //

    UpdateAppTitle();

    //
    // Create the toolbar
    //

    if(!(m_ahwndControls[IDC_MAIN_TOOLBAR] = CreateToolBar()))
    {
        *plResult = -1;
        return TRUE;
    }

    //
    // Create the status bar
    //

    if(!(m_ahwndControls[IDC_MAIN_STATUSBAR] = CreateStatusBar()))
    {
        *plResult = -1;
        return TRUE;
    }

    //
    // Create the list views
    //

    if(!(m_ahwndControls[IDC_MAIN_BANKLIST] = CreateListView(IDC_MAIN_BANKLIST)))
    {
        *plResult = -1;
        return TRUE;
    }

    if(!(m_ahwndControls[IDC_MAIN_ENTRYLIST] = CreateListView(IDC_MAIN_ENTRYLIST)))
    {
        *plResult = -1;
        return TRUE;
    }

    //
    // Initialize the MRU list
    //

    hSubMenu = GetSubMenu(m_hmenu, 0);
    hSubMenu = GetSubMenu(hSubMenu, 6);
    
    m_MRU.Initialize(WBND_REG_KEY, hSubMenu, ID_FILE_MRU_FILE1);

    //
    // Load popup menus
    //

    m_ahmenuPopup[IDC_MAIN_BANKLIST] = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_BANK_POPUP));
    m_ahmenuPopup[IDC_MAIN_ENTRYLIST] = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_ENTRY_POPUP));

    return fHandled;
}


/****************************************************************************
 *
 *  CreateListView
 *
 *  Description:
 *      Creates a list view.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *
 *  Returns:  
 *      HWND: child window handle.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::CreateListView"

HWND
CMainWindow::CreateListView
(
    UINT                    nCommandId
)
{
    static const DWORD      dwStyle         = WS_CHILD | WS_VISIBLE | LVS_AUTOARRANGE | LVS_EDITLABELS | LVS_REPORT | LVS_SHOWSELALWAYS;
    static const DWORD      dwStyleEx       = WS_EX_CLIENTEDGE;
    static const DWORD      dwLvStyleEx     = LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP;
    LPCLVCOLUMNDATAPTR      pColumnData     = &m_aColumnData[nCommandId];
    HWND                    hwnd;
    LVCOLUMN                lvc;

    ASSERT(nCommandId < NUMELMS(m_aColumnData));
    
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.iSubItem = 0;

    if(hwnd = CreateWindowEx(dwStyleEx, WC_LISTVIEW, NULL, dwStyle, 0, 0, 0, 0, m_hwnd, NULL, g_hInstance, NULL))
    {
        SetWindowLong(hwnd, GWL_ID, nCommandId);
        
        ListView_SetExtendedListViewStyleEx(hwnd, dwLvStyleEx, dwLvStyleEx);

#ifdef USE_XBOX_COLORS

        ListView_SetBkColor(hwnd, XBOX_BLACK);
        ListView_SetTextBkColor(hwnd, XBOX_BLACK);
        ListView_SetTextColor(hwnd, XBOX_GREEN);

#endif // USE_XBOX_COLORS
        
        for(; lvc.iSubItem < (int)pColumnData->nColumnCount; lvc.iSubItem++)
        {
            lvc.pszText = (LPSTR)pColumnData->paColumnData[lvc.iSubItem].pszText;
    
            ListView_InsertColumn(hwnd, lvc.iSubItem, &lvc);
            ListView_AutoSizeColumn(hwnd, lvc.iSubItem);
        }
    }

    return hwnd;
}


/****************************************************************************
 *
 *  CreateToolBar
 *
 *  Description:
 *      Creates the main window's toolbar.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HWND: child window handle.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::CreateToolBar"

HWND
CMainWindow::CreateToolBar
(
    void
)
{
    #define MAKE_TOOLBAR_BUTTON(command, image) \
        { image, command, TBSTATE_ENABLED, BTNS_BUTTON, { 0, 0 }, 0, 0 }

    #define MAKE_TOOLBAR_CHECKBUTTON(command, image) \
        { image, command, TBSTATE_ENABLED, BTNS_CHECK, { 0, 0 }, 0, 0 }

    #define MAKE_TOOLBAR_SEPARATOR() \
        { 0, IDC_STATIC, TBSTATE_ENABLED, BTNS_SEP, { 0, 0 }, 0, 0 }
    
    static const TBBUTTON   aButtons[] =
    {
        MAKE_TOOLBAR_BUTTON(ID_FILE_NEW, BTN_LEAF),
        MAKE_TOOLBAR_SEPARATOR(),
        MAKE_TOOLBAR_BUTTON(ID_FILE_OPEN, BTN_OPEN),
        MAKE_TOOLBAR_BUTTON(ID_FILE_SAVE, BTN_SAVE),
        MAKE_TOOLBAR_SEPARATOR(),
        MAKE_TOOLBAR_BUTTON(ID_BANK_ADD, BTN_BANK),
        MAKE_TOOLBAR_BUTTON(ID_ENTRY_ADD, BTN_ENTRY),
        MAKE_TOOLBAR_SEPARATOR(),
        MAKE_TOOLBAR_CHECKBUTTON(ID_CONVERT_ADPCM, BTN_ADPCM),
        MAKE_TOOLBAR_CHECKBUTTON(ID_CONVERT_8BIT, BTN_8BIT),
        MAKE_TOOLBAR_SEPARATOR(),
        MAKE_TOOLBAR_BUTTON(ID_ENTRY_AUDITION, BTN_AUDITION),
        MAKE_TOOLBAR_BUTTON(ID_ENTRY_CANCEL_AUDITION, BTN_STOP),
        MAKE_TOOLBAR_SEPARATOR(),
        MAKE_TOOLBAR_BUTTON(ID_PROJECT_GENERATE, BTN_GENERATE),
    };
    
    static const DWORD      dwStyle     = WS_CHILD | WS_VISIBLE | CCS_TOP | TBSTYLE_FLAT | TBSTYLE_TRANSPARENT | TBSTYLE_TOOLTIPS;
    UINT                    nBitmaps;
    HWND                    hwnd;
    UINT                    i;

    for(i = 0, nBitmaps = 0; i < NUMELMS(aButtons); i++)
    {
        if(BTNS_SEP != aButtons[i].fsStyle)
        {
            nBitmaps++;
        }
    }

    return CreateToolbarEx(m_hwnd, dwStyle, IDC_MAIN_TOOLBAR, nBitmaps, g_hInstance, IDB_TOOLBAR, aButtons, NUMELMS(aButtons), 16, 16, 16, 16, sizeof(aButtons[0]));
}


/****************************************************************************
 *
 *  CreateStatusBar
 *
 *  Description:
 *      Creates the main window's status bar.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HWND: child window handle.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::CreateStatusBar"

HWND
CMainWindow::CreateStatusBar
(
    void
)
{
    static const DWORD      dwStyle = WS_CHILD | WS_VISIBLE | CCS_BOTTOM | SBARS_SIZEGRIP;
    HWND                    hwnd;
    
    if(hwnd = CreateWindowEx(0, STATUSCLASSNAME, NULL, dwStyle, 0, 0, 0, 0, m_hwnd, NULL, g_hInstance, NULL))
    {
        SetWindowLong(hwnd, GWL_ID, IDC_MAIN_STATUSBAR);
    }

    return hwnd;
}


/****************************************************************************
 *
 *  OnDestroy
 *
 *  Description:
 *      Handles destruction of the window.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnDestroy"

BOOL
CMainWindow::OnDestroy
(
    LRESULT *               plResult
)
{
    HKEY                    hkey;
    WINDOWPLACEMENT         wp;
    BOOL                    fHandled;
    
    fHandled = CWindow::OnDestroy(plResult);

    //
    // Save window placement
    //
    
    if(ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER, WBND_REG_KEY, &hkey))
    {
        wp.length = sizeof(wp);
        
        if(GetWindowPlacement(m_hwnd, &wp))
        {
            RegSetValueEx(hkey, WBND_REG_VAL_WNDPOS, 0, REG_BINARY, (const BYTE *)&wp, sizeof(wp));
        }

        RegCloseKey(hkey);
    }

    //
    // Bail
    //

    PostQuitMessage(0);

    return fHandled;
}


/****************************************************************************
 *
 *  OnSize
 *
 *  Description:
 *      Handles resizing of the window.
 *
 *  Arguments:
 *      DWORD [in]: resize flags.
 *      int [in]: window width.
 *      int [in]: window height.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnSize"

BOOL
CMainWindow::OnSize
(
    DWORD                   dwResize, 
    int                     nWidth, 
    int                     nHeight,
    LRESULT *               plResult
)
{
    static const int        nMargin             = 7;
    static const int        nBankListPercent    = 35;
    BOOL                    fHandled;
    RECT                    rcClient;
    RECT                    rcToolBar;
    RECT                    rcStatusBar;
    RECT                    rcBankList;
    RECT                    rcEntryList;
    
    fHandled = CWindow::OnSize(dwResize, nWidth, nHeight, plResult);

    rcClient.left = 0;
    rcClient.top = 0;
    rcClient.right = nWidth;
    rcClient.bottom = nHeight;

    //
    // Resize toolbar and status bar
    //
    
    SendMessage(m_ahwndControls[IDC_MAIN_TOOLBAR], WM_SIZE, dwResize, MAKELPARAM(nWidth, nHeight));
    SendMessage(m_ahwndControls[IDC_MAIN_STATUSBAR], WM_SIZE, dwResize, MAKELPARAM(nWidth, nHeight));

    GetWindowRect(m_ahwndControls[IDC_MAIN_TOOLBAR], &rcToolBar);
    GetWindowRect(m_ahwndControls[IDC_MAIN_STATUSBAR], &rcStatusBar);

    rcClient.top += rcToolBar.bottom - rcToolBar.top;
    rcClient.bottom -= rcStatusBar.bottom - rcStatusBar.top;

    //
    // Resize list views
    //

    rcClient.left += nMargin;
    rcClient.top += nMargin;
    rcClient.right -= nMargin;
    rcClient.bottom -= nMargin;

    rcBankList.left = rcClient.left;
    rcBankList.top = rcClient.top;
    rcBankList.right = rcBankList.left + ((rcClient.right - rcClient.left) * nBankListPercent / 100);
    rcBankList.bottom = rcClient.bottom;

    rcEntryList.left = rcBankList.right + nMargin;
    rcEntryList.top = rcClient.top;
    rcEntryList.right = rcClient.right;
    rcEntryList.bottom = rcClient.bottom;
    
    MoveWindow(m_ahwndControls[IDC_MAIN_BANKLIST], rcBankList);
    MoveWindow(m_ahwndControls[IDC_MAIN_ENTRYLIST], rcEntryList);

    return fHandled;
}


/****************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Command message dispatcher.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnCommand"

BOOL
CMainWindow::OnCommand
(
    UINT                    nCommandId,
    UINT                    nControlId,
    HWND                    hwndControl,
    LRESULT *               plResult
)
{
    BOOL                    fHandled;

    fHandled = CWindow::OnCommand(nCommandId, nControlId, hwndControl, plResult);

    if((nControlId >= ID_FILE_MRU_FILE1) && (nControlId < ID_FILE_MRU_FILE1 + MRU_MAX_COUNT))
    {
        OnOpenProject(m_MRU.m_aszPaths[nControlId - ID_FILE_MRU_FILE1]);
    }
    else
    {
        switch(nControlId)
        {
            case ID_FILE_NEW:
                OnNewProject();
                break;

            case ID_FILE_OPEN:
                OnOpenProject();
                break;

            case ID_FILE_SAVE:
                OnSaveProject(FALSE);
                break;

            case ID_FILE_SAVE_AS:
                OnSaveProject(TRUE);
                break;

            case ID_BANK_ADD:
                OnNewBank();
                break;
        
            case ID_BANK_RENAME:
                OnRename(m_ahwndControls[IDC_MAIN_BANKLIST]);
                break;
        
            case ID_BANK_REMOVE:
                OnRemoveBank();
                break;
        
            case ID_ENTRY_ADD:
                OnNewEntry();
                break;
        
            case ID_ENTRY_RENAME:
                OnRename(m_ahwndControls[IDC_MAIN_ENTRYLIST]);
                break;
        
            case ID_ENTRY_REMOVE:
                OnRemoveEntry();
                break;

            case ID_CONVERT_ADPCM:
                OnConvert(WBFILTER_ADPCM);
                break;

            case ID_CONVERT_8BIT:
                OnConvert(WBFILTER_8BIT);
                break;

            case ID_PROJECT_GENERATE:
                OnGenerate();
                break;
        
            case ID_RENAME:
                OnRename();
                break;
        
            case ID_DELETE:
                OnDelete();
                break;

            case ID_SELECT_ALL:
                OnSelectAll();
                break;
        
            case ID_FILE_EXIT:
                OnExit();
                break;

            case ID_HELP_ABOUT:
                OnAbout();
                break;

            case ID_REFRESH:
                OnRefresh();
                break;

            case ID_ENTRY_AUDITION:
                OnAudition();
                break;

            case ID_ENTRY_CANCEL_AUDITION:
                OnCancelAudition();
                break;
        }
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnExit
 *
 *  Description:
 *      Exits the application.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnExit"

void
CMainWindow::OnExit
(
    void
)
{
    if(!CheckDirty())
    {
        return;
    }

    DestroyWindow(m_hwnd);
}


/****************************************************************************
 *
 *  OnAbout
 *
 *  Description:
 *      Displays information about the application.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnAbout"

void
CMainWindow::OnAbout
(
    void
)
{   

#if 1

    HICON                   hicon;
    CHAR                    szText[0x100];
    CHAR                    szVersion[0x100];

    hicon = (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_PROJECT), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);

    GetWaveBundlerVersion(szVersion);

    sprintf(szText, "XDK version %s", szVersion);

    ShellAbout(m_hwnd, g_pszAppTitle, szText, hicon);

    DestroyIcon(hicon);

#else

    CAboutDialog            AboutDialog;

    AboutDialog.Create(this);

#endif

}


/****************************************************************************
 *
 *  OnNotify
 *
 *  Description:
 *      Dispatches notification messages.
 *
 *  Arguments:
 *      LPNMHDR [in]: notification header.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnNotify"

BOOL
CMainWindow::OnNotify
(
    LPNMHDR                 pHdr,
    LRESULT *               plResult
)
{
    BOOL                    fHandled;

    fHandled = CWindow::OnNotify(pHdr, plResult);

    switch(pHdr->code)
    {
        case TTN_GETDISPINFO:
            OnToolTipDisplayInfo((LPNMTTDISPINFO)pHdr);
            break;

        case LVN_ITEMCHANGED:
            OnListViewItemChanged((LPNMLISTVIEW)pHdr);
            break;

        case LVN_COLUMNCLICK:
            OnListViewColumnClick((LPNMLISTVIEW)pHdr);
            break;

        case LVN_BEGINLABELEDIT:
            OnListViewBeginLabelEdit((NMLVDISPINFO *)pHdr);
            break;

        case LVN_ENDLABELEDIT:
            OnListViewEndLabelEdit((NMLVDISPINFO *)pHdr);
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnToolTipDisplayInfo
 *
 *  Description:
 *      Gets display information for a tool-tip.
 *
 *  Arguments:
 *      LPTOOLTIPTEXT [in/out]: tool tip data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnToolTipDisplayInfo"

void
CMainWindow::OnToolTipDisplayInfo
(
    LPNMTTDISPINFO          pInfo
)
{
    pInfo->hinst = g_hInstance;
    pInfo->lpszText = MAKEINTRESOURCE(pInfo->hdr.idFrom);
}


/****************************************************************************
 *
 *  OnListViewItemChanged
 *
 *  Description:
 *      Notifies that a list view item has changed in some way.
 *
 *  Arguments:
 *      LPNMLISTVIEW [in]: notification data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnListViewItemChanged"

void
CMainWindow::OnListViewItemChanged
(
    LPNMLISTVIEW            pInfo
)
{
    if(pInfo->uChanged & LVIF_STATE)
    {
        if((pInfo->uOldState & LVIS_SELECTED) || (pInfo->uNewState & LVIS_SELECTED))
        {
            switch(pInfo->hdr.idFrom)
            {
                case IDC_MAIN_BANKLIST:
                    OnBankListItemStateChange();
                    break;

                case IDC_MAIN_ENTRYLIST:
                    OnEntryListItemStateChange();
                    break;
            }
        }
    }
}


/****************************************************************************
 *
 *  OnBankListItemStateChange
 *
 *  Description:
 *      Notifies that a list view item has changed in some way.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnBankListItemStateChange"

void
CMainWindow::OnBankListItemStateChange
(
    void
)
{
    HWND                    hwnd        = m_ahwndControls[IDC_MAIN_BANKLIST];
    int                     nSelCount;
    int                     nSelItem;
    
    //
    // If only one bank is selected, activate it
    //

    if(m_pProject)
    {
        if(1 == (nSelCount = ListView_GetSelectedCount(hwnd)))
        {
            nSelItem = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED);
        }
        else
        {
            nSelItem = -1;
        }

        m_pProject->SelectBank(nSelItem);
    }

    //
    // Update command states
    //

    SetCommandStates();
}


/****************************************************************************
 *
 *  OnEntryListItemStateChange
 *
 *  Description:
 *      Notifies that a list view item has changed in some way.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnEntryListItemStateChange"

void
CMainWindow::OnEntryListItemStateChange
(
    void
)
{
    //
    // Update command states
    //
    
    SetCommandStates();
}


/****************************************************************************
 *
 *  OnListViewColumnClick
 *
 *  Description:
 *      Notifies that a list view column has been clicked.
 *
 *  Arguments:
 *      LPNMLISTVIEW [in]: notification data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnListViewColumnClick"

void
CMainWindow::OnListViewColumnClick
(
    LPNMLISTVIEW            pInfo
)
{
    if(!m_pProject)
    {
        return;
    }
    
    switch(pInfo->hdr.idFrom)
    {
        case IDC_MAIN_BANKLIST:
            m_pProject->SortBankList(pInfo->iSubItem);

            MakeDirty();

            break;

        case IDC_MAIN_ENTRYLIST:
            m_pProject->SortEntryList(pInfo->iSubItem);

            MakeDirty();

            break;
    }
}


/****************************************************************************
 *
 *  OnListViewBeginLabelEdit
 *
 *  Description:
 *      Handles the start of a list-view item edit operation.
 *
 *  Arguments:
 *      NMLVDISPINFO * [in]: notification data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnListViewBeginLabelEdit"

void
CMainWindow::OnListViewBeginLabelEdit
(
    NMLVDISPINFO *          pInfo
)
{
    EnableAccelerators(FALSE);
}


/****************************************************************************
 *
 *  OnListViewEndLabelEdit
 *
 *  Description:
 *      Handles the completion of a list-view item edit operation.
 *
 *  Arguments:
 *      NMLVDISPINFO * [in]: notification data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnListViewEndLabelEdit"

void
CMainWindow::OnListViewEndLabelEdit
(
    NMLVDISPINFO *          pInfo
)
{
    CGuiWaveBank *         pBank;
    CGuiWaveBankEntry *    pEntry;
    
    EnableAccelerators(TRUE);

    if(!m_pProject)
    {
        return;
    }

    if(!pInfo->item.pszText)
    {
        return;
    }

    if(!*pInfo->item.pszText)
    {
        return;
    }

    if(IDC_MAIN_BANKLIST == pInfo->hdr.idFrom)
    {
        if(pBank = (CGuiWaveBank *)ListView_GetItemParam(m_ahwndControls[IDC_MAIN_BANKLIST], pInfo->item.iItem))
        {
            pBank->SetName(pInfo->item.pszText);

            MakeDirty();
        }
        else
        {
            ASSERTMSG("Bad item data");
        }
    }
    else if(IDC_MAIN_ENTRYLIST == pInfo->hdr.idFrom)
    {
        if(pEntry = (CGuiWaveBankEntry *)ListView_GetItemParam(m_ahwndControls[IDC_MAIN_ENTRYLIST], pInfo->item.iItem))
        {
            if(SUCCEEDED(pEntry->SetName(pInfo->item.pszText)))
            {
                MakeDirty();
            }
        }
        else
        {
            ASSERTMSG("Bad item data");
        }
    }
}


/****************************************************************************
 *
 *  OnContextMenu
 *
 *  Description:
 *      Handles right-click notifications for all windows.
 *
 *  Arguments:
 *      HWND [in]: window that received the message.
 *      int [in]: x-coordinate.
 *      int [in]: y-coordinate.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnContextMenu"

BOOL
CMainWindow::OnContextMenu
(
    HWND                    hwnd, 
    int                     x, 
    int                     y, 
    LRESULT *               plResult
)
{
    HMENU                   hmenu;
    BOOL                    fHandled;

    fHandled = CWindow::OnContextMenu(hwnd, x, y, plResult);
    
    if(hwnd == m_ahwndControls[IDC_MAIN_BANKLIST])
    {
        hmenu = GetSubMenu(m_ahmenuPopup[IDC_MAIN_BANKLIST], 0);
    }
    else if(hwnd == m_ahwndControls[IDC_MAIN_ENTRYLIST])
    {
        hmenu = GetSubMenu(m_ahmenuPopup[IDC_MAIN_ENTRYLIST], 0);
    }
    else
    {
        hmenu = NULL;
    }
    
    if(hmenu)
    {
        TrackPopupMenu(hmenu, TPM_RIGHTBUTTON, x, y, 0, m_hwnd, NULL);
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnMenuSelect
 *
 *  Description:
 *      Handles selection of a menu item.
 *
 *  Arguments:
 *      UINT [in]: menu item identifier.
 *      UINT [in]: flags.
 *      HMENU [in]: menu handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnMenuSelect"

BOOL
CMainWindow::OnMenuSelect
(
    UINT                    nMenuItem, 
    UINT                    nFlags, 
    HMENU                   hMenu, 
    LRESULT *               plResult
)
{
    CHAR                    szText[0x100];
    BOOL                    fHandled;

    fHandled = CWindow::OnMenuSelect(nMenuItem, nFlags, hMenu, plResult);

    szText[0] = 0;

    if(!(nFlags & (MF_SYSMENU | MF_POPUP)))
    {
        LoadString(g_hInstance, nMenuItem, szText, NUMELMS(szText));
    }

    SetWindowText(m_ahwndControls[IDC_MAIN_STATUSBAR], szText);

    return fHandled;
}


/****************************************************************************
 *
 *  OnNewProject
 *
 *  Description:
 *      Creates a new project.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to prompt for a bank to be added to the project.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnNewProject"

void
CMainWindow::OnNewProject
(
    BOOL                    fAddBank
)
{
    HRESULT                 hr;
    
    if(!CheckDirty())
    {
        return;
    }

    //
    // Delete the old project
    //
    
    DELETE(m_pProject);
    
    //
    // Update UI
    //

    UpdateAppTitle();
    SetCommandStates();

    //
    // Create a new project
    //
    
    hr = HRFROMP(m_pProject = NEW(CGuiWaveBankProject(this)));

    if(SUCCEEDED(hr))
    {
        m_pProject->Attach(m_ahwndControls[IDC_MAIN_BANKLIST], m_ahwndControls[IDC_MAIN_ENTRYLIST]);
    }

    if(SUCCEEDED(hr))
    {
        UpdateAppTitle();
    }

    //
    // Add a bank to the new project
    //

    if(SUCCEEDED(hr) && fAddBank)
    {
        OnNewBank();
    }
}


/****************************************************************************
 *
 *  OnNewBank
 *
 *  Description:
 *      Creates a new bank.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to prompt for entries to be added to the bank.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnNewBank"

void
CMainWindow::OnNewBank
(
    BOOL                    fAddEntries
)
{
    HRESULT                 hr;
    
    if(!m_pProject)
    {
        return;
    }

    hr = m_pProject->AddBank();

    if(SUCCEEDED(hr))
    {
        MakeDirty();
    }

    if(SUCCEEDED(hr) && fAddEntries)
    {
        OnNewEntry();
    }
}


/****************************************************************************
 *
 *  OnRemoveBank
 *
 *  Description:
 *      Removes the selected bank(s).
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnRemoveBank"

void
CMainWindow::OnRemoveBank
(
    void
)
{
    static const LPCSTR     pszSingle   = "Are you sure you want to remove the bank from the project?";
    static const LPCSTR     pszMultiple = "Are you sure you want to remove the selected banks from the project?";
    HWND                    hwnd        = m_ahwndControls[IDC_MAIN_BANKLIST];
    int                     nItemCount;
    int                     i;
    
    if(!m_pProject)
    {
        return;
    }

    if((nItemCount = ListView_GetSelectedCount(hwnd)) > 0)
    {
        if(IDYES == MessageBox(nItemCount > 1 ? pszMultiple : pszSingle, MB_ICONQUESTION | MB_YESNO))
        {
            while(TRUE)
            {
                if(-1 == (i = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED)))
                {
                    break;
                }

                m_pProject->RemoveBank(i);
            }

            MakeDirty();
        }
    }
}


/****************************************************************************
 *
 *  OnNewEntry
 *
 *  Description:
 *      Creates a new entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnNewEntry"

void
CMainWindow::OnNewEntry
(
    void
)
{
    if(!m_pProject)
    {
        return;
    }

    if(SUCCEEDED(m_pProject->AddEntry()))
    {
        MakeDirty();
    }
}


/****************************************************************************
 *
 *  OnRemoveEntry
 *
 *  Description:
 *      Removes the selected entry or entries.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnRemoveEntry"

void
CMainWindow::OnRemoveEntry
(
    void
)
{
    static const LPCSTR     pszSingle   = "Are you sure you want to remove the entry from the bank?";
    static const LPCSTR     pszMultiple = "Are you sure you want to remove the selected entries from the bank?";
    HWND                    hwnd        = m_ahwndControls[IDC_MAIN_ENTRYLIST];
    int                     nItemCount;
    int                     i;
    
    if(!m_pProject)
    {
        return;
    }

    if((nItemCount = ListView_GetSelectedCount(hwnd)) > 0)
    {
        if(IDYES == MessageBox(nItemCount > 1 ? pszMultiple : pszSingle, MB_ICONQUESTION | MB_YESNO))
        {
            while(TRUE)
            {
                if(-1 == (i = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED)))
                {
                    break;
                }

                m_pProject->RemoveEntry(i);
            }

            MakeDirty();
        }
    }
}


/****************************************************************************
 *
 *  OnConvert
 *
 *  Description:
 *      Toggles the conversion flags for each selected entry.
 *
 *  Arguments:
 *      DWORD [in]: flags mask.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnConvert"

void
CMainWindow::OnConvert
(
    DWORD                   dwMask
)
{
    static const LPCSTR     pszConfusion    = "Not all of the selected entries are able to be converted";
    HWND                    hwnd            = m_ahwndControls[IDC_MAIN_ENTRYLIST];
    DWORD                   dwFlags         = 0;
    int                     nChanged        = 0;
    int                     nItemCount;
    CGuiWaveBankEntry *     pEntry;
    int                     i;
    
    if(!m_pProject)
    {
        return;
    }

    //
    // If any selected items are compressed, we'll uncompress and vice-versa
    //

    if((nItemCount = ListView_GetSelectedCount(hwnd)) > 0)
    {
        i = -1;
        
        while(TRUE)
        {
            if(-1 == (i = ListView_GetNextItem(hwnd, i, LVNI_SELECTED)))
            {
                break;
            }

            pEntry = (CGuiWaveBankEntry *)ListView_GetItemParam(hwnd, i);
            ASSERT(pEntry);

            dwFlags |= pEntry->m_dwFlags;
        }

        dwFlags = ~dwFlags & dwMask;

        i = -1;
        
        while(TRUE)
        {
            if(-1 == (i = ListView_GetNextItem(hwnd, i, LVNI_SELECTED)))
            {
                break;
            }

            pEntry = (CGuiWaveBankEntry *)ListView_GetItemParam(hwnd, i);
            ASSERT(pEntry);

            if(dwFlags == pEntry->SetFlags(WBFILTER_MASK, dwFlags))
            {
                nChanged++;
            }

            pEntry->UpdateListView();
        }

        MakeDirty();

        OnEntryListItemStateChange();

        if(nChanged < nItemCount)
        {
            MessageBox(pszConfusion, MB_OK | MB_ICONINFORMATION);
        }
    }
}


/****************************************************************************
 *
 *  OnGenerate
 *
 *  Description:
 *      Generates wave bank files.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnGenerate"

void
CMainWindow::OnGenerate
(
    void
)
{

#if 0

    static const LPCSTR     pszMessage  = "All entries were successfully written";
    HRESULT                 hr;
    
    if(!m_pProject)
    {
        return;
    }

    SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    hr = m_pProject->Generate(this);

    SendMessage(m_ahwndControls[IDC_MAIN_STATUSBAR], SB_SETTEXT, 0, NULL);

    SetCursor(LoadCursor(NULL, IDC_ARROW));
    
    if(SUCCEEDED(hr))
    {
        MessageBox(pszMessage, MB_OK | MB_ICONINFORMATION);
    }

#else

    m_pProject->Generate();

#endif
    
}


/****************************************************************************
 *
 *  BeginEntry
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      LPCSTR [in]: entry file name.
 *      DWORD [in]: entry flags.
 *      UINT [in]: entry index.
 *      UINT [in]: entry count.
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::BeginEntry"

BOOL
CMainWindow::BeginEntry
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags
)
{
    CHAR                    szText[MAX_PATH + 0x100];

    strcpy(szText, "Processing ");

    strcat(szText, pszFile);
    // _splitpath(pszFile, NULL, NULL, &szText[strlen(szText)], NULL);

    SendMessage(m_ahwndControls[IDC_MAIN_STATUSBAR], SB_SETTEXT, 0, (LPARAM)szText);

    return TRUE;
}


/****************************************************************************
 *
 *  OnSaveProject
 *
 *  Description:
 *      Saves the current project.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to prompt for a file name.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnSaveProject"

void
CMainWindow::OnSaveProject
(
    BOOL                    fPrompt
)
{
    if(!m_pProject)
    {
        return;
    }

    if(SUCCEEDED(m_pProject->Save(fPrompt)))
    {
        m_MRU.AddItem(m_pProject->m_szProjectFile);

        MakeDirty(FALSE, TRUE);
    }
}


/****************************************************************************
 *
 *  OnOpenProject
 *
 *  Description:
 *      Opens a project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnOpenProject"

void
CMainWindow::OnOpenProject
(
    LPCSTR                  pszProjectFile
)
{
    CHAR                    szPath[MAX_PATH];
    LPSTR                   psz;
    HRESULT                 hr;

    //
    // Strip any quotes from the path
    //

    if(pszProjectFile)
    {
        psz = szPath;
        
        while(TRUE)
        {
            if('\"' == *pszProjectFile)
            {
                pszProjectFile++;
                continue;
            }

            if(!(*psz++ = *pszProjectFile++))
            {
                break;
            }
        }

        pszProjectFile = szPath;
    }

    //
    // Open the project
    //

    if(pszProjectFile && m_pProject)
    {
        if(!_strcmpi(pszProjectFile, m_pProject->m_szProjectFile))
        {
            return;
        }
    }

    if(!CheckDirty())
    {
        return;
    }

    MakeDirty(FALSE);

    DELETE(m_pProject);

    hr = HRFROMP(m_pProject = NEW(CGuiWaveBankProject(this)));

    if(SUCCEEDED(hr))
    {
        m_pProject->Attach(m_ahwndControls[IDC_MAIN_BANKLIST], m_ahwndControls[IDC_MAIN_ENTRYLIST]);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pProject->Open(pszProjectFile);
    }

    if(SUCCEEDED(hr))
    {
        m_MRU.AddItem(m_pProject->m_szProjectFile);
    }

    if(SUCCEEDED(hr))
    {
        UpdateAppTitle();
    }

    //
    // If we failed to open the project, create an empty one
    //

    if(FAILED(hr))
    {
        OnNewProject(FALSE);
    }
}


/****************************************************************************
 *
 *  OnDelete
 *
 *  Description:
 *      Handles the generic delete command.
 *
 *  Arguments:
 *      HWND [in]: window handle that received the message.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnDelete"

void
CMainWindow::OnDelete
(
    HWND                    hwnd
)
{
    if(!hwnd)
    {
        hwnd = GetFocus();
    }

    if(hwnd == m_ahwndControls[IDC_MAIN_BANKLIST])
    {
        OnRemoveBank();
    }
    else if(hwnd == m_ahwndControls[IDC_MAIN_ENTRYLIST])
    {
        OnRemoveEntry();
    }
}


/****************************************************************************
 *
 *  OnRename
 *
 *  Description:
 *      Handles the generic rename command.
 *
 *  Arguments:
 *      HWND [in]: window handle that received the message.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnRename"

void
CMainWindow::OnRename
(
    HWND                    hwnd
)
{
    int                     i;

    if(!hwnd)
    {
        hwnd = GetFocus();
    }

    if((hwnd == m_ahwndControls[IDC_MAIN_BANKLIST]) || (hwnd == m_ahwndControls[IDC_MAIN_ENTRYLIST]))
    {
        if(1 == ListView_GetSelectedCount(hwnd))
        {
            if(-1 != (i = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED)))
            {
                ListView_EditLabel(hwnd, i);
            }
        }
    }
}


/****************************************************************************
 *
 *  OnSelectAll
 *
 *  Description:
 *      Selects all entries in a list.
 *
 *  Arguments:
 *      HWND [in]: window handle that received the message.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnSelectAll"

void
CMainWindow::OnSelectAll
(
    HWND                    hwnd
)
{
    int                     nItemCount;
    int                     i;

    if(!hwnd)
    {
        hwnd = GetFocus();
    }
    
    if((hwnd == m_ahwndControls[IDC_MAIN_BANKLIST]) || (hwnd == m_ahwndControls[IDC_MAIN_ENTRYLIST]))
    {
        nItemCount = ListView_GetItemCount(hwnd);

        for(i = 0; i < nItemCount; i++)
        {
            ListView_SetItemState(hwnd, i, LVIS_SELECTED, LVIS_SELECTED);
        }
    }
}


/****************************************************************************
 *
 *  OnClose
 *
 *  Description:
 *      Handles closing the window.
 *
 *  Arguments:
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnClose"

BOOL
CMainWindow::OnClose
(
    LRESULT *               plResult
)
{
    OnExit();
    return FALSE;
}


/****************************************************************************
 *
 *  CheckDirty
 *
 *  Description:
 *      Prompts the user to save if the project has changed.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing; FALSE to cancel.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::CheckDirty"

BOOL
CMainWindow::CheckDirty
(
    void
)
{
    static const LPCSTR     pszMessage                  = "Save changes to %s?";
    static const LPCSTR     pszNoName                   = "New Project";
    CHAR                    szMessage[MAX_PATH + 0x100];
    UINT                    nResult;
    
    if(!m_pProject || !m_fDirty)
    {
        return TRUE;
    }

    sprintf(szMessage, pszMessage, m_pProject->m_szProjectFile[0] ? m_pProject->m_szProjectFile : pszNoName);

    nResult = MessageBox(szMessage, MB_ICONQUESTION | MB_YESNOCANCEL);

    if(IDYES == nResult)
    {
        OnSaveProject(FALSE);

        return !m_fDirty;
    }
    else if(IDNO == nResult)
    {
        return TRUE;
    }

    return FALSE;
}


/****************************************************************************
 *
 *  MakeDirty
 *
 *  Description:
 *      Updates the dirty flag.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to flag the project as dirty.
 *      BOOL [in]: TRUE to force an update.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::MakeDirty"

void
CMainWindow::MakeDirty
(
    BOOL                    fDirty,
    BOOL                    fForce
)
{
    if((fDirty != m_fDirty) || fForce)
    {
        m_fDirty = fDirty;

        UpdateAppTitle();
    }
}


/****************************************************************************
 *
 *  UpdateAppTitle
 *
 *  Description:
 *      Updates the application title.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::UpdateAppTitle"

void
CMainWindow::UpdateAppTitle
(
    void
)
{
    CHAR                    szText[MAX_PATH + 0x100];

    if(m_pProject)
    {
        if(m_pProject->m_szProjectFile[0])
        {
            _splitpath(m_pProject->m_szProjectFile, NULL, NULL, szText, NULL);
        }
        else
        {
            strcpy(szText, "New Project");
        }
        
        if(m_fDirty)
        {
            strcat(szText, " *");
        }
        
        strcat(szText, " - ");
        strcat(szText, g_pszAppTitle);

        SetWindowText(m_hwnd, szText);
    }
    else
    {
        SetWindowText(m_hwnd, g_pszAppTitle);
    }
}


/****************************************************************************
 *
 *  SetCommandState
 *
 *  Description:
 *      En/disables menu, toolbar and accelerator commands based on current
 *      application state.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      BOOL [in]: TRUE to enable; FALSE to disable; -1 to skip.
 *      BOOL [in]: TRUE to check; FALSE to uncheck; -1 to skip.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::SetCommandState"

void
CMainWindow::SetCommandState
(
    UINT                    nCommandId,
    BOOL                    fEnable,
    BOOL                    fCheck
)
{
    static const DWORD      adwMenuSelected[] = 
    { 
        MF_BYCOMMAND | MF_GRAYED,
        MF_BYCOMMAND | MF_ENABLED 
    };

    static const DWORD      adwCheckState[] =
    {
        MF_BYCOMMAND | MF_UNCHECKED,
        MF_BYCOMMAND | MF_CHECKED
    };

    UINT                    i;

    if((TRUE == fEnable) || (FALSE == fEnable))
    {
        EnableMenuItem(m_hmenu, nCommandId, adwMenuSelected[fEnable]);

        for(i = 0; i < NUMELMS(m_ahmenuPopup); i++)
        {
            EnableMenuItem(m_ahmenuPopup[i], nCommandId, adwMenuSelected[fEnable]);
        }

        SendMessage(m_ahwndControls[IDC_MAIN_TOOLBAR], TB_ENABLEBUTTON, nCommandId, MAKELONG(fEnable, 0));
    }

    if((TRUE == fCheck) || (FALSE == fCheck))
    {
        CheckMenuItem(m_hmenu, nCommandId, adwCheckState[fCheck]);

        for(i = 0; i < NUMELMS(m_ahmenuPopup); i++)
        {
            CheckMenuItem(m_ahmenuPopup[i], nCommandId, adwCheckState[fCheck]);
        }

        SendMessage(m_ahwndControls[IDC_MAIN_TOOLBAR], TB_CHECKBUTTON, nCommandId, MAKELONG(fCheck, 0));
    }
}


/****************************************************************************
 *
 *  SetBankCommandStates
 *
 *  Description:
 *      En/disables menu, toolbar and accelerator commands based on current
 *      application state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::SetBankCommandStates"

void
CMainWindow::SetBankCommandStates
(
    void
)
{
    HWND                    hwnd        = m_ahwndControls[IDC_MAIN_BANKLIST];
    int                     nSelCount;

    //
    // Update command state based on the number of items currently selected
    // in the bank list
    //
    
    nSelCount = ListView_GetSelectedCount(hwnd);

    SetCommandState(ID_BANK_RENAME, (1 == nSelCount), -1);
    SetCommandState(ID_BANK_REMOVE, (nSelCount > 0), -1);
    SetCommandState(ID_ENTRY_ADD, (1 == nSelCount), -1);
}


/****************************************************************************
 *
 *  SetEntryCommandStates
 *
 *  Description:
 *      En/disables menu, toolbar and accelerator commands based on current
 *      application state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::SetEntryCommandStates"

void
CMainWindow::SetEntryCommandStates
(
    void
)
{
    HWND                    hwnd        = m_ahwndControls[IDC_MAIN_ENTRYLIST];
    int                     nAdpcmValid = 0;
    int                     nAdpcm      = 0;
    int                     n8BitValid  = 0;
    int                     n8Bit       = 0;
    int                     nSelCount   = 0;
    int                     i           = -1;
    DWORD                   dwValid;
    CGuiWaveBankEntry *    pEntry;

    //
    // Determine the number of selected items and the availability of 
    // conversion for each item.
    //

    while(TRUE)
    {
        if(-1 == (i = ListView_GetNextItem(hwnd, i, LVNI_SELECTED)))
        {
            break;
        }

        nSelCount++;    

        pEntry = (CGuiWaveBankEntry *)ListView_GetItemParam(hwnd, i);
        ASSERT(pEntry);

        dwValid = pEntry->GetValidFlags();

        if(dwValid & WBFILTER_ADPCM)
        {
            nAdpcmValid++;
            
            if(pEntry->m_dwFlags & WBFILTER_ADPCM)
            {
                nAdpcm++;
            }
        }
        else
        {
            ASSERT(!(pEntry->m_dwFlags & WBFILTER_ADPCM));
        }
        
        if(dwValid & WBFILTER_8BIT)
        {
            n8BitValid++;
            
            if(pEntry->m_dwFlags & WBFILTER_8BIT)
            {
                n8Bit++;
            }
        }
        else
        {
            ASSERT(!(pEntry->m_dwFlags & WBFILTER_8BIT));
        }
    }

    //
    // Update command state based on the number of items currently selected
    // in the entry list
    //
    
    SetCommandState(ID_ENTRY_RENAME, (1 == nSelCount), -1);
    SetCommandState(ID_ENTRY_REMOVE, (nSelCount > 0), -1);
    SetCommandState(ID_CONVERT_ADPCM, (nAdpcmValid > 0), (nAdpcm > 0));
    SetCommandState(ID_CONVERT_8BIT, (n8BitValid > 0), (n8Bit > 0));
    SetCommandState(ID_ENTRY_AUDITION, (nSelCount > 0), -1);
}


/****************************************************************************
 *
 *  SetCommandStates
 *
 *  Description:
 *      En/disables menu, toolbar and accelerator commands based on current
 *      application state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::SetCommandStates"

void
CMainWindow::SetCommandStates
(
    void
)
{
    SetBankCommandStates();
    SetEntryCommandStates();
}


/****************************************************************************
 *
 *  OnRefresh
 *
 *  Description:
 *      Refreshes project data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnRefresh"

void
CMainWindow::OnRefresh
(
    void
)
{
    if(!m_pProject)
    {
        return;
    }

    SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    m_pProject->Refresh();

    SetCursor(LoadCursor(NULL, IDC_ARROW));
}


/****************************************************************************
 *
 *  OnAudition
 *
 *  Description:
 *      Auditions an entry.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnAudition"

void
CMainWindow::OnAudition
(
    void
)
{
    HWND                    hwnd        = m_ahwndControls[IDC_MAIN_ENTRYLIST];
    int                     i           = -1;
    CGuiWaveBankEntry *    pEntry;
    int                     nItemCount;
    
    if(!m_pProject)
    {
        return;
    }

    if(!ConnectRemote())
    {
        DPF_ERROR("Can't connect to audio console");
        return;
    }

    if((nItemCount = ListView_GetSelectedCount(hwnd)) > 0)
    {
        SetCursor(LoadCursor(NULL, IDC_WAIT));
    
        while(TRUE)
        {
            if(-1 == (i = ListView_GetNextItem(hwnd, i, LVNI_SELECTED)))
            {
                break;
            }

            pEntry = CGuiWaveBankEntry::GetEntry(hwnd, i);
            ASSERT(pEntry);

            pEntry->Audition(m_pxbdm);
        }

        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
}


/****************************************************************************
 *
 *  OnCancelAudition
 *
 *  Description:
 *      Cancels any autitioning entries.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::OnCancelAudition"

void
CMainWindow::OnCancelAudition
(
    void
)
{
    HWND                    hwnd;
    
    if(!ConnectRemote())
    {
        DPF_ERROR("Can't connect to audio console");
        return;
    }

    DmSendCommand(m_pxbdm, "XAUD!WaveBank.StopAll", NULL, NULL);
}


/****************************************************************************
 *
 *  ConnectRemote
 *
 *  Description:
 *      Connects to a remote instance of Audio Console.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMainWindow::ConnectRemote"

BOOL
CMainWindow::ConnectRemote
(
    void
)
{
    HRESULT                 hr                  = S_OK;
    CHAR                    szCommand[0x100];
    
    if(!m_pxbdm)
    {
        if(XBDM_NOERR == (hr = DmOpenConnection(&m_pxbdm)))
        {
            hr = S_OK;
        }

        if(SUCCEEDED(hr))
        {
            sprintf(szCommand, "XAUD!connect %s", g_pszAppTitle);

            if(XBDM_NOERR == (hr = DmSendCommand(m_pxbdm, szCommand, NULL, NULL)))
            {
                hr = S_OK;
            }
        }

        if(FAILED(hr) && m_pxbdm)
        {
            DmCloseConnection(m_pxbdm);
            m_pxbdm = NULL;
        }
    }

    return SUCCEEDED(hr);
}


/****************************************************************************
 *
 *  CAboutDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAboutDialog::CAboutDialog"

CAboutDialog::CAboutDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CAboutDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAboutDialog::~CAboutDialog"

CAboutDialog::~CAboutDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the dialog.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAboutDialog::Create"

BOOL
CAboutDialog::Create
(
    CWindow *               pParent
)
{
    return CModalDialog::Create(IDD, NULL, pParent);
}


/****************************************************************************
 *
 *  OnInitDialog
 *
 *  Description:
 *      Handles dialog initialization.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAboutDialog::OnInitDialog"

BOOL
CAboutDialog::OnInitDialog
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    CHAR                    szTemplate[0x100];
    CHAR                    szVersion[0x100];
    CHAR                    szText[0x100];
    SYSTEMTIME              time;
    BOOL                    fHandled;
    
    fHandled = CModalDialog::OnInitDialog(pvContext, plResult);
    
    //
    // Set text items and window title
    //

    GetWindowText(m_hwnd, szTemplate, NUMELMS(szTemplate));
    sprintf(szText, szTemplate, g_pszAppTitle);
    SetWindowText(m_hwnd, szText);

    GetDlgItemText(m_hwnd, IDC_APPNAME, szTemplate, NUMELMS(szTemplate));
    sprintf(szText, szTemplate, g_pszAppTitle);
    SetDlgItemText(m_hwnd, IDC_APPNAME, szText);

    GetDlgItemText(m_hwnd, IDC_VERSION, szTemplate, NUMELMS(szTemplate));
    GetWaveBundlerVersion(szVersion);
    sprintf(szText, szTemplate, szVersion);
    SetDlgItemText(m_hwnd, IDC_VERSION, szText);

    GetDlgItemText(m_hwnd, IDC_COPYRIGHT, szTemplate, NUMELMS(szTemplate));
    GetLocalTime(&time);
    sprintf(szText, szTemplate, time.wYear);
    SetDlgItemText(m_hwnd, IDC_COPYRIGHT, szText);

    //
    // Center the window
    //

    CenterWindow(m_hwnd, m_pParent ? m_pParent->m_hwnd : NULL);

    return fHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\wndwrap.h ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wndwrap.h
 *  Content:    Windows wrapper classes (aka My Mini MFC)
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __WNDWRAP_H__
#define __WNDWRAP_H__

#define WINDOW_SIGNATURE 'wdnw'

// 
// Globals
//

EXTERN_C LPCSTR g_pszAppTitle;
EXTERN_C HINSTANCE g_hInstance;

//
// Debugging
//

#define WM_DPF WM_APP
#define WM_DPF_SIGNATURE 0xDF

//
// Window creation properties
//

BEGIN_DEFINE_STRUCT()
    DWORD       dwClassStyle;       // Window class style
    DWORD       dwClassExtra;       // Extra amount of memory allocated for the class
    DWORD       dwWndExtra;         // Extra amount of memory allocated for the window
    HICON       hIcon;              // Icon
    HICON       hIconSm;            // 16x16 icon
    HCURSOR     hCursor;            // Class cursor
    HBRUSH      hbrBackground;      // Class background color
    LPCTSTR     pszClassName;       // Class name
    LPCTSTR     pszWindowName;      // window name
    DWORD       dwStyle;            // window style
    DWORD       dwExStyle;          // extended window style
    int         x;                  // horizontal position of window
    int         y;                  // vertical position of window
    int         nWidth;             // window width
    int         nHeight;            // window height
    LPCSTR      pszMenu;            // menu resource identifier
    LPCSTR      pszAccelerator;     // accelerator table resource identifier
END_DEFINE_STRUCT(WNDCREATE);

//
// Generic helper functions
//

EXTERN_C BOOL FormatStringResource(LPTSTR pszText, HINSTANCE hInstance, UINT nResourceId, ...);
EXTERN_C void CenterWindow(HWND hwnd, HWND hwndParent);

#ifdef __cplusplus

//
// Forward declarations
//

class CWindow;

//
// Window base class
//

class CWindow
{
    friend class CDialog;

public:
    const DWORD             m_dwSignature;  // Validity signature
    CWindow *               m_pParent;      // Parent window handle
    LIST_ENTRY              m_lstChildren;  // Child window list
    LIST_ENTRY              m_leChild;      // Child window list entry
    HWND                    m_hwnd;         // Window handle
    HMENU                   m_hmenu;        // Menu handle
    HACCEL                  m_haccel;       // Accelerator table handle
    BOOL                    m_fEnableAccel; // Enable accelerators?

public:
    CWindow(void);
    virtual ~CWindow(void);

public:
    // Creation
    virtual BOOL Create(LPCWNDCREATE pCreate, LPVOID pvContext = NULL, CWindow *pParent = NULL);

    // Window heirarchy
    virtual void SetParent(CWindow *pParent);

    // Window size
    virtual void MoveWindow(const RECT &rc);
    virtual void MoveWindow(HWND hwnd, const RECT &rc);

    // User prompt
    virtual int MessageBox(LPCTSTR pszText, UINT uType);
    virtual int MessageBox(UINT nResourceId, UINT uType);

    // Message pump
    virtual void PumpMessages(void);

    // Message handlers
    virtual BOOL OnCreate(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnClose(LRESULT *plResult);
    virtual BOOL OnDestroy(LRESULT *plResult);
    virtual BOOL OnSize(DWORD dwResize, int nWidth, int nHeight, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hwndControl, LRESULT *plResult);
    virtual BOOL OnNotify(LPNMHDR pHdr, LRESULT *plResult);
    virtual BOOL OnDebug(UINT nSignature, UINT nLevel, LPCSTR pszMessage, LRESULT *plResult);
    virtual BOOL OnContextMenu(HWND hwnd, int x, int y, LRESULT *plResult);
    virtual BOOL OnMenuSelect(UINT nMenuItem, UINT nFlags, HMENU hMenu, LRESULT *plResult);

    // Accelerator state
    virtual void EnableAccelerators(BOOL fEnable);

    // Debug helpers
    static void CALLBACK DebugCallback(DWORD dwLevel, LPCSTR pszString);

public:
    virtual operator HWND(void);

protected:
    // Message dispatcher
    virtual BOOL DispatchMessage(LPMSG pmsg);

    // Message handlers
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT DefaultMessageHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

__inline CWindow::operator HWND(void)
{
    return m_hwnd;
}

__inline LRESULT CWindow::DefaultMessageHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

__inline BOOL CWindow::OnClose(LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnDestroy(LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnSize(DWORD dwResize, int nWidth, int nHeight, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnCommand(UINT nCommandId, UINT nControlId, HWND hwndControl, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnNotify(LPNMHDR pHdr, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnContextMenu(HWND hwnd, int x, int y, LRESULT *plResult)
{
    return FALSE;
}

__inline BOOL CWindow::OnMenuSelect(UINT nMenuItem, UINT nFlags, HMENU hMenu, LRESULT *plResult)
{
    return FALSE;
}

__inline void CWindow::MoveWindow(const RECT &rc)
{
    MoveWindow(m_hwnd, rc);
}

__inline void CWindow::MoveWindow(HWND hwnd, const RECT &rc)
{
    ::MoveWindow(hwnd, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);
}

__inline int CWindow::MessageBox(LPCTSTR pszText, UINT uType)
{
    return ::MessageBox(m_hwnd, pszText, g_pszAppTitle, uType);
}

__inline int CWindow::MessageBox(UINT nResourceId, UINT uType)
{
    TCHAR                   szText[0x100];

    LoadString(g_hInstance, nResourceId, szText, NUMELMS(szText));
    
    return MessageBox(szText, uType);
}

__inline void CWindow::EnableAccelerators(BOOL fEnable)
{
    m_fEnableAccel = fEnable;
}

__inline void CWindow::DebugCallback(DWORD dwLevel, LPCSTR pszString)
{
    SendMessage(g_hwndMain, WM_DPF, MAKELONG(dwLevel, WM_DPF_SIGNATURE), (LPARAM)pszString);
}

//
// Dialog base class
//

class CDialog
    : public CWindow
{
public:
    CDialog(void);
    virtual ~CDialog(void);

public:
    // Message handlers
    virtual BOOL OnInitDialog(LPVOID pvContext, LRESULT *plResult);
    virtual BOOL OnCommand(UINT nCommandId, UINT nControlId, HWND hwndControl, LRESULT *plResult);
    virtual BOOL OnClose(LRESULT *plResult);

    // Command handlers
    virtual void OnOk(void);
    virtual void OnCancel(void);

protected:
    // Message dispatcher
    virtual BOOL DispatchMessage(LPMSG pmsg);

    // Message handlers
    virtual BOOL HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    static BOOL CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT DefaultMessageHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

__inline LRESULT CDialog::DefaultMessageHandler(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return FALSE;
}

__inline BOOL CDialog::OnInitDialog(LPVOID pvContext, LRESULT *plResult)
{
    return TRUE;
}

__inline BOOL CDialog::OnClose(LRESULT *plResult)
{
    OnCancel();
    return FALSE;
}

__inline void CDialog::OnOk(void)
{
    EndDialog(m_hwnd, TRUE);
}

__inline void CDialog::OnCancel(void)
{
    EndDialog(m_hwnd, FALSE);
}

//
// Modal dialog base class
//

class CModalDialog
    : public CDialog
{
public:
    CModalDialog(void);
    virtual ~CModalDialog(void);

public:
    // Creation
    virtual BOOL Create(UINT nResourceId, LPVOID pvContext = NULL, CWindow *pParent = NULL);
};

//
// Modeless dialog base class
//

class CModelessDialog
    : public CDialog
{
public:
    CModelessDialog(void);
    virtual ~CModelessDialog(void);

public:
    // Creation
    virtual HWND Create(UINT nResourceId, LPVOID pvContext = NULL, CWindow *pParent = NULL);
};

#endif // __cplusplus

#endif // __WNDWRAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\wndwrap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/8/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       wndwrap.cpp
 *  Content:    Windows wrapper classes (aka My Mini MFC)
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/8/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wbndgui.h"

BEGIN_DEFINE_STRUCT()
    CWindow *   pWindow;
    LPVOID      pvContext;
END_DEFINE_STRUCT(WINDOWCREATECTX);


/****************************************************************************
 *
 *  FormatStringResource
 *
 *  Description:
 *      Loads a string template and formats it with the additional 
 *      parameters.
 *
 *  Arguments:
 *      LPTSTR [out]: receives formatted text.
 *      HINSTANCE [in]: instance handle.
 *      UINT [in]: resource identifier.
 *      ...
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FormatStringResource"

BOOL
FormatStringResource
(
    LPTSTR                  pszText, 
    HINSTANCE               hInstance, 
    UINT                    nResourceId, 
    ...
)
{
    TCHAR                   szFormat[0x100];
    va_list                 va;

    if(!LoadString(hInstance, nResourceId, szFormat, NUMELMS(szFormat)))
    {
        return FALSE;
    }

    va_start(va, nResourceId);
    vsprintf(pszText, szFormat, va);
    va_end(va);

    return TRUE;
}


/****************************************************************************
 *
 *  CenterWindow
 *
 *  Description:
 *      Centers one window over another.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      HWND [in]: parent window handle, or NULL to center over the desktop.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CenterWindow"

void
CenterWindow
(
    HWND                    hwnd,
    HWND                    hwndParent
)
{
    RECT                    rc;
    RECT                    rcParent;
    HMONITOR                hmon;
    MONITORINFO             mi;
    
    mi.cbSize = sizeof(mi);
    
    GetWindowRect(hwnd, &rc);
    
    if(hwndParent)
    {
        GetWindowRect(hwndParent, &rcParent);
    }
    else
    {
        hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY);

        GetMonitorInfo(hmon, &mi);

        rcParent = mi.rcWork;
    }

    rc.right -= rc.left;
    rc.bottom -= rc.top;
    
    rc.left = rcParent.left + (((rcParent.right - rcParent.left) - rc.right) / 2);
    rc.top = rcParent.top + (((rcParent.bottom - rcParent.top) - rc.bottom) / 2);

    MoveWindow(hwnd, rc.left, rc.top, rc.right, rc.bottom, TRUE);
}


/****************************************************************************
 *
 *  CWindow
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CWindow::CWindow
(
    void
)
:   m_dwSignature(WINDOW_SIGNATURE)
{
    m_hwnd = NULL;
    m_hmenu = NULL;
    m_haccel = NULL;
    m_fEnableAccel = TRUE;
    
    InitializeListHead(&m_lstChildren);
    InitializeListHead(&m_leChild);
}


/****************************************************************************
 *
 *  ~CWindow
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CWindow::~CWindow
(
    void
)
{
    if(m_hwnd)
    {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    if(m_hmenu)
    {
        DestroyMenu(m_hmenu);
        m_hmenu = NULL;
    }

    if(m_haccel)
    {
        DestroyAcceleratorTable(m_haccel);
        m_haccel = NULL;
    }

    SetParent(NULL);
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a window.
 *
 *  Arguments:
 *      LPCWNDCREATE [in]: window creation data.
 *      LPVOID [in]: window creation context (passed to OnCreate).
 *      int [in]: window visibility.
 *      CWindow * [in]: parent window.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CWindow::Create
(
    LPCWNDCREATE            pCreate,
    LPVOID                  pvContext,
    CWindow *               pParent
)
{
    BOOL                    fSuccess    = TRUE;
    WNDCLASSEX              wc;
    WINDOWCREATECTX         ctx;

    ASSERT(pCreate);
    
    ZeroMemory(&wc, sizeof(wc));

    wc.cbSize = sizeof(wc);
    wc.style = pCreate->dwClassStyle;
    wc.lpfnWndProc = WindowProc;
    wc.cbClsExtra = pCreate->dwClassExtra;
    wc.cbWndExtra = pCreate->dwWndExtra;
    wc.hInstance = g_hInstance;
    wc.hIcon = pCreate->hIcon;
    wc.hCursor = pCreate->hCursor;
    wc.hbrBackground = pCreate->hbrBackground;
    wc.lpszClassName = pCreate->pszClassName;
    wc.hIconSm = pCreate->hIconSm;

    if(pCreate->pszMenu)
    {
        m_hmenu = LoadMenu(g_hInstance, pCreate->pszMenu);
    }

    if(pCreate->pszAccelerator)
    {
        m_haccel = LoadAccelerators(g_hInstance, pCreate->pszAccelerator);
    }

    if(pParent)
    {
        SetParent(pParent);
    }
    
    if(!::RegisterClassEx(&wc))
    {
        fSuccess = FALSE;
    }

    if(fSuccess)
    {
        ctx.pWindow = this;
        ctx.pvContext = pvContext;
        
        if(!(m_hwnd = CreateWindowEx(pCreate->dwExStyle, pCreate->pszClassName, pCreate->pszWindowName, pCreate->dwStyle, pCreate->x, pCreate->y, pCreate->nWidth, pCreate->nHeight, pParent ? pParent->m_hwnd : NULL, NULL, wc.hInstance, &ctx)))
        {
            fSuccess = FALSE;
        }
    }

    return fSuccess;
}


/****************************************************************************
 *
 *  WindowProc
 *
 *  Description:
 *      Main window message handler.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *
 *  Returns:  
 *      LRESULT: message result.
 *
 ****************************************************************************/

LPARAM CALLBACK
CWindow::WindowProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    LPCREATESTRUCT          pCreate;
    LPCWINDOWCREATECTX      pCtx;
    CWindow *               pWindow;
    LRESULT                 lResult;
    BOOL                    fHandled;
    
    //
    // Get the "this" pointer from the window
    //

    if(WM_CREATE == uMsg)
    {
        pCreate = (LPCREATESTRUCT)lParam;
        pCtx = (LPCWINDOWCREATECTX)pCreate->lpCreateParams;
        pWindow = pCtx->pWindow;

        SetWindowLong(hwnd, GWL_USERDATA, (LONG)pWindow);

        pWindow->m_hwnd = hwnd;
    }
    else
    {
        pWindow = (CWindow *)GetWindowLong(hwnd, GWL_USERDATA);
    }

    if(pWindow)
    {
        if(WINDOW_SIGNATURE != pWindow->m_dwSignature)
        {
            DPF_INFO("Bogus this pointer from message %4.4x", uMsg);
            pWindow = NULL;
        }
    }

    //
    // Hand off to the dispatcher
    //

    if(pWindow)
    {
        fHandled = pWindow->HandleMessage(uMsg, wParam, lParam, &lResult);
    }
    else
    {
        fHandled = FALSE;
    }

    //
    // Handle destruction
    //
    
    if((WM_DESTROY == uMsg) && pWindow)
    {
        SetWindowLong(hwnd, GWL_USERDATA, NULL);

        pWindow->m_hwnd = NULL;
    }

    //
    // Hand off to the default handler
    //

    if(!fHandled)
    {
        lResult = DefaultMessageHandler(hwnd, uMsg, wParam, lParam);
    }

    return lResult;
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

BOOL 
CWindow::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    LPCREATESTRUCT          pCreate;
    LPCWINDOWCREATECTX      pCtx;
    BOOL                    fHandled;
    
    switch(uMsg)
    {
        case WM_CREATE:
            pCreate = (LPCREATESTRUCT)lParam;
            pCtx = (LPCWINDOWCREATECTX)pCreate->lpCreateParams;
            fHandled = OnCreate(pCtx->pvContext, plResult);
            break;
        
        case WM_CLOSE:
            fHandled = OnClose(plResult);
            break;
        
        case WM_DESTROY:
            fHandled = OnDestroy(plResult);
            break;

        case WM_SIZE:
            fHandled = OnSize(wParam, LOWORD(lParam), HIWORD(lParam), plResult);
            break;

        case WM_COMMAND:
            fHandled = OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, plResult);
            break;
        
        case WM_NOTIFY:
            fHandled = OnNotify((LPNMHDR)lParam, plResult);
            break;

        case WM_DPF:
            fHandled = OnDebug(HIWORD(wParam), LOWORD(wParam), (LPCSTR)lParam, plResult);
            break;

        case WM_CONTEXTMENU:
            fHandled = OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam), plResult);
            break;

        case WM_MENUSELECT:
            fHandled = OnMenuSelect(LOWORD(wParam), HIWORD(wParam), (HMENU)lParam, plResult);
            break;
        
        default:
            fHandled = FALSE;
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  SetParent
 *
 *  Description:
 *      Creates a parent/child relationship.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CWindow::SetParent
(
    CWindow *               pParent
)
{
    RemoveEntryList(&m_leChild);

    if(m_pParent = pParent)
    {
        InsertTailList(&pParent->m_lstChildren, &m_leChild);
    }
}


/****************************************************************************
 *
 *  PumpMessages
 *
 *  Description:
 *      Pumps messages for the current thread.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CWindow::PumpMessages
(
    void
)
{
    MSG                     msg;

    while(::GetMessage(&msg, NULL, 0, 0))
    {
        if(!DispatchMessage(&msg))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
    }
}


/****************************************************************************
 *
 *  DispatchMessage
 *
 *  Description:
 *      Dispatches the next message in this window's queue.
 *
 *  Arguments:
 *      LPMSG [in]: message.
 *
 *  Returns:  
 *      BOOL: TRUE if the message has been dispatched.  FALSE if the caller
 *            should dispatch it.
 *
 ****************************************************************************/

BOOL
CWindow::DispatchMessage
(
    LPMSG                   pmsg
)
{
    PLIST_ENTRY             pleChild;

    if(m_haccel && m_fEnableAccel)
    {
        if(TranslateAccelerator(m_hwnd, m_haccel, pmsg))
        {
            return TRUE;
        }
    }

    for(pleChild = m_lstChildren.Flink; pleChild != &m_lstChildren; pleChild = pleChild->Flink)
    {
        if(CONTAINING_RECORD(pleChild, CWindow, m_leChild)->DispatchMessage(pmsg))
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


/****************************************************************************
 *
 *  OnCreate
 *
 *  Description:
 *      Handles creation of the window.
 *
 *  Arguments:
 *      LPVOID [in]: window creation context.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::OnCreate"

BOOL
CWindow::OnCreate
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    if(m_hmenu)
    {
        SetMenu(m_hwnd, m_hmenu);
    }

    return FALSE;
}


/****************************************************************************
 *
 *  OnDebug
 *
 *  Description:
 *      Handles debug messages sent to the window.
 *
 *  Arguments:
 *      UINT [in]: signature.
 *      UINT [in]: debug level.
 *      LPCSTR [in]: debug text.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CWindow::OnDebug"

BOOL
CWindow::OnDebug
(
    UINT                    nSignature,
    UINT                    nLevel,
    LPCSTR                  pszMessage,
    LRESULT *               plResult
)
{
    if((WM_DPF_SIGNATURE == nSignature) && (nLevel >= DPFLVL_FIRST) && (nLevel <= DPFLVL_LAST))
    {
        switch(nLevel)
        {
            case DPFLVL_ERROR:
            case DPFLVL_RESOURCE:
                MessageBox(pszMessage, MB_OK | MB_ICONERROR);
                break;

            case DPFLVL_WARNING:
                MessageBox(pszMessage, MB_OK | MB_ICONWARNING);
                break;

            default:
                // MessageBox(pszMessage, MB_OK | MB_ICONINFORMATION);
                break;
        }
    }

    *plResult = 0;

    return TRUE;
}


/****************************************************************************
 *
 *  CDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CDialog::CDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CDialog::~CDialog
(
    void
)
{
    if(m_hwnd)
    {
        EndDialog(m_hwnd, 0);
        m_hwnd = NULL;
    }
}


/****************************************************************************
 *
 *  DispatchMessage
 *
 *  Description:
 *      Dispatches the next message in this window's queue.
 *
 *  Arguments:
 *      LPMSG [in]: message.
 *
 *  Returns:  
 *      BOOL: TRUE if the message has been dispatched.  FALSE if the caller
 *            should dispatch it.
 *
 ****************************************************************************/

BOOL
CDialog::DispatchMessage
(
    LPMSG                   pmsg
)
{
    if(IsDialogMessage(m_hwnd, pmsg))
    {
        return TRUE;
    }
    
    return CWindow::DispatchMessage(pmsg);
}


/****************************************************************************
 *
 *  DialogProc
 *
 *  Description:
 *      Dialog mesage handler.
 *
 *  Arguments:
 *      HWND [in]: window handle.
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *
 *  Returns:  
 *      LRESULT: message result.
 *
 ****************************************************************************/

BOOL CALLBACK
CDialog::DialogProc
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
)
{
    LPCWINDOWCREATECTX      pCtx;
    CWindow *               pWindow;
    LRESULT                 lResult;
    BOOL                    fHandled;
    
    //
    // Get the "this" pointer from the window
    //

    if(WM_INITDIALOG == uMsg)
    {
        pCtx = (LPCWINDOWCREATECTX)lParam;
        pWindow = pCtx->pWindow;

        SetWindowLong(hwnd, DWL_USER, (LONG)pWindow);

        pWindow->m_hwnd = hwnd;
    }
    else
    {
        pWindow = (CWindow *)GetWindowLong(hwnd, DWL_USER);
    }

    if(pWindow)
    {
        if(WINDOW_SIGNATURE != pWindow->m_dwSignature)
        {
            DPF_INFO("Bogus this pointer from message %4.4x", uMsg);
            pWindow = NULL;
        }
    }

    //
    // Hand off to the dispatcher
    //

    if(pWindow)
    {
        fHandled = pWindow->HandleMessage(uMsg, wParam, lParam, &lResult);
    }
    else
    {
        fHandled = FALSE;
    }

    //
    // Handle destruction
    //
    
    if((WM_DESTROY == uMsg) && pWindow)
    {
        SetWindowLong(hwnd, DWL_USER, NULL);

        pWindow->m_hwnd = NULL;
    }

    //
    // Hand off to the default handler
    //

    if(!fHandled)
    {
        lResult = DefaultMessageHandler(hwnd, uMsg, wParam, lParam);
    }

    return lResult;
}


/****************************************************************************
 *
 *  HandleMessage
 *
 *  Description:
 *      Dispatches a window message to the appropriate handler.
 *
 *  Arguments:
 *      UINT [in]: message identifier.
 *      WPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *      LRESULT * [out]: message result.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

BOOL 
CDialog::HandleMessage
(
    UINT                    uMsg, 
    WPARAM                  wParam, 
    LPARAM                  lParam, 
    LRESULT *               plResult
)
{
    LPCWINDOWCREATECTX      pCtx;
    BOOL                    fHandled;
    
    switch(uMsg)
    {
        case WM_INITDIALOG:
            pCtx = (LPCWINDOWCREATECTX)lParam;
            fHandled = OnInitDialog(pCtx->pvContext, plResult);
            break;
        
        default:
            fHandled = CWindow::HandleMessage(uMsg, wParam, lParam, plResult);
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  OnCommand
 *
 *  Description:
 *      Command message dispatcher.
 *
 *  Arguments:
 *      UINT [in]: command identifier.
 *      UINT [in]: control identifier.
 *      HWND [in]: control window handle.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDialog::OnCommand"

BOOL
CDialog::OnCommand
(
    UINT                    nCommandId,
    UINT                    nControlId,
    HWND                    hwndControl,
    LRESULT *               plResult
)
{
    BOOL                    fHandled;

    fHandled = CWindow::OnCommand(nCommandId, nControlId, hwndControl, plResult);

    switch(nControlId)
    {
        case IDOK:
            OnOk();
            break;

        case IDCANCEL:
            OnCancel();
            break;
    }

    return fHandled;
}


/****************************************************************************
 *
 *  CModalDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CModalDialog::CModalDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CModalDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CModalDialog::~CModalDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a window.
 *
 *  Arguments:
 *      UINT [in]: dialog resource identifier.
 *      LPVOID [in]: window creation context (passed to OnInitDialog).
 *      CWindow * [in]: parent window handle.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CModalDialog::Create
(
    UINT                    nResourceId,
    LPVOID                  pvContext,
    CWindow *               pParent
)
{
    WINDOWCREATECTX         ctx;
    
    if(pParent)
    {
        SetParent(pParent);
    }

    ctx.pWindow = this;
    ctx.pvContext = pvContext;
    
    return DialogBoxParam(g_hInstance, MAKEINTRESOURCE(nResourceId), pParent ? pParent->m_hwnd : NULL, DialogProc, (LPARAM)&ctx);
}


/****************************************************************************
 *
 *  CModelessDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CModelessDialog::CModelessDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CModelessDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CModelessDialog::~CModelessDialog
(
    void
)
{
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates a window.
 *
 *  Arguments:
 *      UINT [in]: dialog resource identifier.
 *      LPVOID [in]: window creation context (passed to OnInitDialog).
 *      CWindow * [in]: parent window handle.
 *
 *  Returns:  
 *      HWND: dialog window handle.
 *
 ****************************************************************************/

HWND
CModelessDialog::Create
(
    UINT                    nResourceId,
    LPVOID                  pvContext,
    CWindow *               pParent
)
{
    WINDOWCREATECTX         ctx;
    
    if(pParent)
    {
        SetParent(pParent);
    }

    ctx.pWindow = this;
    ctx.pvContext = pvContext;
    
    return CreateDialogParam(g_hInstance, MAKEINTRESOURCE(nResourceId), pParent ? pParent->m_hwnd : NULL, DialogProc, (LPARAM)&ctx);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\WavBndlr\GUI\sbgui.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 11/11/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sbgui.cpp
 *  Content:    GUI versions of wave bank objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/11/2001   dereks  Created.
 *
 ****************************************************************************/

#include "wbndgui.h"

#define MAKE_COMMDLG_FILTER(desc, ext) \
    desc " Files (" ext ")\0" ext "\0"

#define LVCOLUMN_ORDER_DEFAULT  TRUE


/****************************************************************************
 *
 *  FormatNumber
 *
 *  Description:
 *      Converts a number to a string, adding comma-separators.
 *
 *  Arguments:
 *      int [in]: number.
 *      BOOL [in]: signed or unsigned.
 *      BOOL [in]: add commas.
 *      LPSTR [out]: string.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FormatNumber"

void
FormatNumber
(
    int                     nValue,
    BOOL                    fSigned,
    BOOL                    fThousands,
    LPSTR                   pszString
)
{
    LPSTR                   psz     = pszString;
    UINT                    nDigits = 0;
    UINT                    uValue;
    
    if(nValue)
    {
        if(!fSigned || (nValue > 0))
        {
            uValue = (UINT)nValue;
            
            while(uValue)
            {
                *psz++ = '0' + (uValue % 10);

                uValue /= 10;

                if(uValue && fThousands)
                {
                    if(2 == (nDigits % 3))
                    {
                        *psz++ = ',';
                    }
                }

                nDigits++;
            }
        }
        else
        {
            uValue = abs(nValue);
            
            while(uValue)
            {
                *psz++ = '0' + (uValue % 10);

                uValue /= 10;

                if(uValue && fThousands)
                {
                    if(2 == (nDigits % 3))
                    {
                        *psz++ = ',';
                    }
                }

                nDigits++;
            }

            *psz++ = '-';
        }
    }
    else
    {
        *psz++ = '0';
    }

    *psz = 0;

    _strrev(pszString);
}


/****************************************************************************
 *
 *  CGuiWaveBankEntry
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CGuiWaveBank * [in]: parent object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::CGuiWaveBankEntry"

LVCOLUMNDATA CGuiWaveBankEntry::m_aColumnData[] =
{
    { "Entry Name", TRUE, LVCOLUMN_ORDER_DEFAULT },
    { "Format", TRUE, LVCOLUMN_ORDER_DEFAULT },
    { "Rate", FALSE, LVCOLUMN_ORDER_DEFAULT },
    { "Bits", FALSE, LVCOLUMN_ORDER_DEFAULT },
    { "Channels", FALSE, LVCOLUMN_ORDER_DEFAULT },
    { "Size", FALSE, LVCOLUMN_ORDER_DEFAULT },
    { "Conversion", TRUE, LVCOLUMN_ORDER_DEFAULT },
    { "Source File", TRUE, LVCOLUMN_ORDER_DEFAULT }
};

CGuiWaveBankEntry::CGuiWaveBankEntry
(
    CGuiWaveBank *         pParent
)
:   CWaveBankEntry(pParent)
{
    m_pParent = pParent;
    m_hIcon = NULL;
}


/****************************************************************************
 *
 *  ~CGuiWaveBankEntry
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::~CGuiWaveBankEntry"

CGuiWaveBankEntry::~CGuiWaveBankEntry
(
    void
)
{
    if(m_hIcon)
    {
        DestroyIcon(m_hIcon);
    }
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object from a wave file.
 *
 *  Arguments:
 *      LPCSTR [in]: entry name.
 *      LPCSTR [in]: wave file name.
 *      DWORD [in]: processing flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::Initialize"

HRESULT
CGuiWaveBankEntry::Initialize
(
    LPCSTR                  pszEntryName,
    LPCSTR                  pszFileName,
    DWORD                   dwFlags
)
{
    SHFILEINFO              shfi;
    HRESULT                 hr;
    
    //
    // Initialize the base class
    //
    
    hr = CWaveBankEntry::Initialize(pszEntryName, pszFileName, dwFlags);

    //
    // Get the icon information for display
    //

    if(SUCCEEDED(hr))
    {
        ASSERT(!m_hIcon);

        if(SHGetFileInfo(pszFileName, 0, &shfi, sizeof(shfi), SHGFI_ICON))
        {
            m_hIcon = shfi.hIcon;
        }
    }

    //
    // Update display data
    //

    if(SUCCEEDED(hr))
    {
        UpdateListView();
    }
    
    //
    // Update the entry count in the bank list
    //

    if(SUCCEEDED(hr))
    {
        m_pParent->UpdateListView();
    }

    return hr;
}


/****************************************************************************
 *
 *  SetFlags
 *
 *  Description:
 *      Sets entry flags.  Because of error-checking, the flags actually set
 *      by this method may not match those passed in.
 *
 *  Arguments:
 *      DWORD [in]: mask of flags to change.
 *      DWORD [in]: new flags.
 *
 *  Returns:  
 *      DWORD: new flags.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::SetFlags"

DWORD
CGuiWaveBankEntry::SetFlags
(
    DWORD                   dwMask,
    DWORD                   dwFlags
)
{
    //
    // Hand off to the base class
    //

    dwFlags = CWaveBankEntry::SetFlags(dwMask, dwFlags);

    //
    // Update the parent bank's list-view data since our size may have
    // changed
    //

    m_pParent->UpdateListView();

    return dwFlags;
}


/****************************************************************************
 *
 *  GetItemIndex
 *
 *  Description:
 *      Gets the object's list view item index.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      UINT: item index or -1.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::GetItemIndex"

UINT
CGuiWaveBankEntry::GetItemIndex
(
    void
)
{
    HWND                    hwnd        = m_pParent->m_pParent->m_hwndEntryList;
    int                     nItemCount;
    int                     nItem;

    if(!hwnd)
    {
        return -1;
    }
    
    nItemCount = ListView_GetItemCount(hwnd);

    for(nItem = 0; nItem < nItemCount; nItem++)
    {
        if(this == GetEntry(hwnd, nItem))
        {
            break;
        }
    }

    return (nItem < nItemCount) ? nItem : -1;
}


/****************************************************************************
 *
 *  UpdateListView
 *
 *  Description:
 *      Updates the list-view item data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::UpdateListView"

void
CGuiWaveBankEntry::UpdateListView
(
    UINT                    nItem
)
{
    HWND                    hwnd            = m_pParent->m_pParent->m_hwndEntryList;
    HIMAGELIST              himl            = m_pParent->m_pParent->m_himlEntryList;
    UINT                    nSubItem        = 0;
    DWORD                   dwOffset        = 0;
    WAVEBANKENTRY           MetaData;
    CHAR                    szText[0x100];
    LVITEM                  lvi;
    HRESULT                 hr;

    if(!hwnd)
    {
        return;
    }

    if(m_pParent != m_pParent->m_pParent->m_pActiveBank)
    {
        return;
    }

    if(-1 == nItem)
    {
        nItem = GetItemIndex();
    }

    if(-1 == nItem)
    {
        lvi.mask = LVIF_IMAGE | LVIF_PARAM;
        lvi.iItem = ListView_GetItemCount(hwnd);
        lvi.iSubItem = 0;
        lvi.iImage = ImageList_AddIcon(himl, m_hIcon);
        lvi.lParam = (LPARAM)this;

        nItem = ListView_InsertItem(hwnd, &lvi);
    }
    else
    {
        ASSERT(this == GetEntry(hwnd, nItem));
    }

    hr = GetMetaData(&MetaData, &dwOffset);

    if(FAILED(hr))
    {
        return;
    }

    ListView_SetItemText(hwnd, nItem, nSubItem++, m_szEntryName);

    if(WAVEBANKMINIFORMAT_TAG_ADPCM == m_Format.wFormatTag)
    {
        ListView_SetItemText(hwnd, nItem, nSubItem++, "ADPCM");
    }
    else
    {
        ListView_SetItemText(hwnd, nItem, nSubItem++, "PCM");
    }

    ListView_SetItemText(hwnd, nItem, nSubItem++, "%lu", m_Format.nSamplesPerSec);

    if(WAVEBANKMINIFORMAT_TAG_ADPCM == m_Format.wFormatTag)
    {
        ListView_SetItemText(hwnd, nItem, nSubItem++, "4");
    }
    else
    {
        ListView_SetItemText(hwnd, nItem, nSubItem++, "%lu", (WAVEBANKMINIFORMAT_BITDEPTH_8 == m_Format.wBitsPerSample) ? 8 : 16);
    }

    ListView_SetItemText(hwnd, nItem, nSubItem++, "%lu", m_Format.nChannels);
    
    FormatNumber(MetaData.PlayRegion.dwLength, FALSE, TRUE, szText);
    ListView_SetItemText(hwnd, nItem, nSubItem++, szText);
    
    if(m_dwFlags & WBFILTER_ADPCM)
    {
        strcpy(szText, CXboxAdpcmFilter::GetName());
    }
    else if(m_dwFlags & WBFILTER_8BIT)
    {
        strcpy(szText, C8BitFilter::GetName());
    }
    else
    {
        strcpy(szText, "");
    }
    
    ListView_SetItemText(hwnd, nItem, nSubItem++, szText);
    ListView_SetItemText(hwnd, nItem, nSubItem++, m_szFileName);
}


/****************************************************************************
 *
 *  SetName
 *
 *  Description:
 *      Renames the entry.
 *
 *  Arguments:
 *      LPCSTR [in]: entry name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::SetName"

HRESULT 
CGuiWaveBankEntry::SetName
(
    LPCSTR                  pszName
)
{
    HRESULT                 hr;

    if(!pszName)
    {
        pszName = "";
    }
    
    hr = CWaveBankEntry::SetName(pszName);

    if(SUCCEEDED(hr))
    {
        UpdateListView();
    }

    return hr;
}


/****************************************************************************
 *
 *  Audition
 *
 *  Description:
 *      Auditions the entry on the target Xbox console.
 *
 *  Arguments:
 *      PDM_CONNECTION [in]: XBDM connection.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankEntry::Audition"

HRESULT 
CGuiWaveBankEntry::Audition
(
    PDM_CONNECTION          pxbdm
)
{
    static const LPCSTR     pszCommandTemplate      = "XAUD!WaveBank.PlayEntry \"%s\"";
    static const LPCSTR     pszDstPathTemplate      = "T:\\%s";
    static const DWORD      dwCopyBufferSize        = 256 * 1024;
    DWORD                   dwOffset                = 0;
    LPVOID                  pvCopyBuffer            = NULL;
    HRESULT                 hr                      = S_OK;
    CHAR                    szCurDir[MAX_PATH];
    CHAR                    szSrcFile[MAX_PATH];
    CHAR                    szDstFile[MAX_PATH];
    CHAR                    szFileTitle[MAX_PATH];
    CHAR                    szCommand[0x400];
    CStdFileStream          DataFile;
    WAVEBANKENTRY           Entry;

    //
    // Open a temporary file
    //

    GetCurrentDirectory(NUMELMS(szCurDir), szCurDir);
    GetTempFileName(szCurDir, "WBN", 0, szSrcFile);

    hr = DataFile.Open(szSrcFile, GENERIC_READ | GENERIC_WRITE, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_SEQUENTIAL_SCAN);

    //
    // Get entry meta-data and write it to the file
    //

    if(SUCCEEDED(hr))
    {
        hr = GetMetaData(&Entry, &dwOffset);
    }

    if(SUCCEEDED(hr))
    {
        hr = DataFile.Write(&Entry, sizeof(Entry));
    }
    
    //
    // Allocate the copy buffer
    //

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(pvCopyBuffer = MEMALLOC(BYTE, dwCopyBufferSize));
    }

    //
    // Get wave data
    //

    if(SUCCEEDED(hr))
    {
        hr = CommitWaveData(&DataFile, sizeof(Entry), &Entry, pvCopyBuffer, dwCopyBufferSize);
    }

    //
    // Close the file so XBDM can read it
    //

    if(SUCCEEDED(hr))
    {
        DataFile.Close();
    }

    //
    // Send the file to the Xbox
    //

    if(SUCCEEDED(hr))
    {
        sprintf(szDstFile, pszDstPathTemplate, m_pParent->m_szBankName);

        DmMkdir(szDstFile);
    }
    
    if(SUCCEEDED(hr))
    {
        _splitpath(m_szFileName, NULL, NULL, szFileTitle, NULL);
        
        strcat(szDstFile, "\\");
        strcat(szDstFile, szFileTitle);
        
        if(XBDM_NOERR == (hr = DmSendFile(szSrcFile, szDstFile)))
        {
            hr = S_OK;
        }
        else
        {
            DPF_INFO("DmSendFile failed with error %x", hr);
            DPF_ERROR("Unable to transfer data to the Xbox");
        }
    }

    //
    // Tell the Xbox to play the file
    //

    if(SUCCEEDED(hr))
    {
        sprintf(szCommand, pszCommandTemplate, szDstFile);
        
        if(XBDM_NOERR == (hr = DmSendCommand(pxbdm, szCommand, NULL, NULL)))
        {
            hr = S_OK;
        }
        else
        {
            DPF_INFO("DmSendCommand failed with error %x", hr);
            DPF_ERROR("Unable to send command to the Xbox");
        }
    }

    //
    // Clean up
    //

    DeleteFile(szSrcFile);
    
    MEMFREE(pvCopyBuffer);

    return hr;
}


/****************************************************************************
 *
 *  CGuiWaveBank
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CGuiProject * [in]: parent object.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::CGuiWaveBank"

LVCOLUMNDATA CGuiWaveBank::m_aColumnData[] =
{
    { "Bank Name", TRUE, LVCOLUMN_ORDER_DEFAULT },
    { "Entry Count", FALSE, LVCOLUMN_ORDER_DEFAULT },
    { "Bank Size", FALSE, LVCOLUMN_ORDER_DEFAULT },
    { "Bank File", TRUE, LVCOLUMN_ORDER_DEFAULT },
    { "Header File", TRUE, LVCOLUMN_ORDER_DEFAULT }
};

CGuiWaveBank::CGuiWaveBank
(
    CGuiWaveBankProject *  pParent
)
:   CWaveBank(pParent)
{
    m_pParent = pParent;
}


/****************************************************************************
 *
 *  ~CGuiWaveBank
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::~CGuiWaveBank"

CGuiWaveBank::~CGuiWaveBank
(
    void
)
{
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCSTR [in]: wave bank name.
 *      LPCSTR [in]: bank file path.
 *      LPCSTR [in]: header file path.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::Initialize"

HRESULT
CGuiWaveBank::Initialize
(
    LPCSTR                  pszBankName,
    LPCSTR                  pszBankFile,
    LPCSTR                  pszHeaderFile
)
{
    HRESULT                 hr;

    //
    // Initialize the base class
    //

    hr = CWaveBank::Initialize(pszBankName, pszBankFile, pszHeaderFile);

    //
    // Update display data
    //

    if(SUCCEEDED(hr))
    {
        UpdateListView();
    }

    return hr;
}


/****************************************************************************
 *
 *  Refresh
 *
 *  Description:
 *      Refreshes bank data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::Refresh"

HRESULT
CGuiWaveBank::Refresh
(
    void
)
{
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleEntry;
    CGuiWaveBankEntry *     pEntry;

    //
    // Refresh entries
    //

    for(pleEntry = m_lstEntries.Flink; (pleEntry != &m_lstEntries) && SUCCEEDED(hr); pleEntry = pleEntry->Flink)
    {
        pEntry = CONTAINING_RECORD(pleEntry, CGuiWaveBankEntry, m_leEntry);

        hr = pEntry->Refresh();
    }

    return hr;
}


/****************************************************************************
 *
 *  SetName
 *
 *  Description:
 *      Renames the entry.
 *
 *  Arguments:
 *      LPCSTR [in]: entry name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::SetName"

HRESULT 
CGuiWaveBank::SetName
(
    LPCSTR                  pszName
)
{
    HRESULT                 hr;

    if(!pszName)
    {
        pszName = "";
    }
    
    hr = CWaveBank::SetName(pszName);

    if(SUCCEEDED(hr))
    {
        UpdateListView();
    }

    return hr;
}


/****************************************************************************
 *
 *  GetItemIndex
 *
 *  Description:
 *      Gets the object's list view item index.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      UINT: item index or -1.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::GetItemIndex"

UINT
CGuiWaveBank::GetItemIndex
(
    void
)
{
    HWND                    hwnd        = m_pParent->m_hwndBankList;
    int                     nItemCount;
    int                     nItem;

    if(!hwnd)
    {
        return -1;
    }
    
    nItemCount = ListView_GetItemCount(hwnd);

    for(nItem = 0; nItem < nItemCount; nItem++)
    {
        if(this == GetBank(hwnd, nItem))
        {
            break;
        }
    }

    return (nItem < nItemCount) ? nItem : -1;
}


/****************************************************************************
 *
 *  AddEntry
 *
 *  Description:
 *      Adds an entry to the bank.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::AddEntry"

HRESULT
CGuiWaveBank::AddEntry
(
    void
)
{
    static const LPCSTR     pszFilter           = MAKE_COMMDLG_FILTER("Sound", "*.wav;*.aif;*.aiff") MAKE_COMMDLG_FILTER("All", "*.*");
    static const LPCSTR     pszTitle            = "Add Wave Bank Entries";
    static const DWORD      dwOfnFlags          = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_ALLOWMULTISELECT;
    static const UINT       nMaxFiles           = 2048;
    LPSTR                   pszPath;
    LPSTR                   pszFile;
    CHAR                    szFile[MAX_PATH];
    HRESULT                 hr;
    OPENFILENAME            ofn;

    //
    // Allocate enough space for more than one file
    //

    hr = HRFROMP(pszPath = MEMALLOC(CHAR, nMaxFiles * MAX_PATH));

    //
    // Get the file name(s)
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&ofn, sizeof(ofn));

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = m_pParent->m_pParent->m_hwnd;
        ofn.lpstrFilter = pszFilter;
        ofn.lpstrFile = pszPath;
        ofn.nMaxFile = nMaxFiles * MAX_PATH;
        ofn.lpstrTitle = pszTitle;
        ofn.Flags = dwOfnFlags;
        ofn.lpstrDefExt = WBWRITER_FILEEXTENSION_BANK;

        if(!GetOpenFileName(&ofn))
        {
            hr = E_ABORT;
        }
    }

    //
    // If more than one file was specified, the path will be first, followed
    // by each file name in a null-terminated list
    //

    if(SUCCEEDED(hr))
    {
        pszFile = pszPath + strlen(pszPath) + 1;

        if(*pszFile)
        {
            while(*pszFile)
            {
                _makepath(szFile, NULL, pszPath, pszFile, NULL);

                if(FAILED(CWaveBank::AddEntry(NULL, szFile, 0)))
                {
                    hr = S_FALSE;
                }

                pszFile += strlen(pszFile) + 1;
            }
        }
        else
        {
            hr = CWaveBank::AddEntry(NULL, pszPath, 0);
        }
    }

    //
    // Display a warning if not all of the entries were added
    //

    if(S_FALSE == hr)
    {
        DPF_WARNING("Not all entries were added to the wave bank");
    }

    //
    // Clean up
    //

    MEMFREE(pszPath);

    return hr;
}


/****************************************************************************
 *
 *  UpdateListView
 *
 *  Description:
 *      Updates the list-view item data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::UpdateListView"

void
CGuiWaveBank::UpdateListView
(
    UINT                    nItem
)
{
    HWND                    hwnd            = m_pParent->m_hwndBankList;
    UINT                    nSubItem        = 0;
    CHAR                    szText[0x100];
    DWORD                   dwSize;
    LVITEM                  lvi;

    if(!hwnd)
    {
        return;
    }

    if(-1 == nItem)
    {
        nItem = GetItemIndex();
    }

    if(-1 == nItem)
    {
        lvi.mask = LVIF_IMAGE | LVIF_PARAM;
        lvi.iItem = ListView_GetItemCount(hwnd);
        lvi.iSubItem = 0;
        lvi.iImage = m_pParent->m_nBankIcon;
        lvi.lParam = (LPARAM)this;

        nItem = ListView_InsertItem(hwnd, &lvi);
    }
    else
    {
        ASSERT(this == GetBank(hwnd, nItem));
    }

    dwSize = GetBankDataSize();

    ListView_SetItemText(hwnd, nItem, nSubItem++, m_szBankName);
    ListView_SetItemText(hwnd, nItem, nSubItem++, "%lu", m_dwEntryCount);

    FormatNumber(dwSize, FALSE, TRUE, szText);
    ListView_SetItemText(hwnd, nItem, nSubItem++, szText);

    ListView_SetItemText(hwnd, nItem, nSubItem++, m_szBankFile);
    ListView_SetItemText(hwnd, nItem, nSubItem++, m_szHeaderFile);
}


/****************************************************************************
 *
 *  SortEntryList
 *
 *  Description:
 *      Sorts the entry list.
 *
 *  Arguments:
 *      UINT [in]: column index to sort by.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::SortEntryList"

void
CGuiWaveBank::SortEntryList
(
    UINT                    nColumn
)
{
    const LPLVCOLUMNDATA    pColumn     = &CGuiWaveBankEntry::m_aColumnData[nColumn];
    PLIST_ENTRY             pleEntry;
    CGuiWaveBankEntry *     pEntry;
    int                     nItemCount;
    int                     nItem;

    ASSERT(nColumn < NUMELMS(CGuiWaveBankEntry::m_aColumnData));

    //
    // Let the list-view sort the list
    //

    ListView_SortItems(m_pParent->m_hwndEntryList, nColumn, pColumn->fString, pColumn->fAscending, NULL, NULL);

    //
    // Rebuild the list based on the list-view data
    //

    while(&m_lstEntries != RemoveHeadList(&m_lstEntries));

    nItemCount = ListView_GetItemCount(m_pParent->m_hwndEntryList);
    
    for(nItem = 0; nItem < nItemCount; nItem++)
    {
        pEntry = CGuiWaveBankEntry::GetEntry(m_pParent->m_hwndEntryList, nItem);
        ASSERT(pEntry);

        InsertTailList(&m_lstEntries, &pEntry->m_leEntry);
    }

    //
    // Swap the ascending flag
    //

    pColumn->fAscending = !pColumn->fAscending;
}


/****************************************************************************
 *
 *  CGuiWaveBankProject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CWindow * [in]: parent window.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::CGuiWaveBankProject"

CGuiWaveBankProject::CGuiWaveBankProject
(
    CWindow *               pParent
)
{
    m_pParent = pParent;
    m_hwndBankList = NULL;
    m_hwndEntryList = NULL;
    m_pActiveBank = NULL;
    m_hBankIcon = NULL;
    m_nBankIcon = -1;

    m_szProjectFile[0] = 0;
}


/****************************************************************************
 *
 *  ~CGuiWaveBankProject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::~CGuiWaveBankProject"

CGuiWaveBankProject::~CGuiWaveBankProject
(
    void
)
{
    //
    // Clear all items from the lists
    //

    Detach();

    //
    // Free resources
    //
    
    if(m_hBankIcon)
    {
        DestroyIcon(m_hBankIcon);
    }
}


/****************************************************************************
 *
 *  AddBank
 *
 *  Description:
 *      Adds a new bank to the project.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::AddBank"

HRESULT
CGuiWaveBankProject::AddBank
(
    void
)
{
    static const LPCSTR     pszSbkFilter        = MAKE_COMMDLG_FILTER("Wave Bank", "*." WBWRITER_FILEEXTENSION_BANK) MAKE_COMMDLG_FILTER("All", "*.*");
    static const LPCSTR     pszHdrFilter        = MAKE_COMMDLG_FILTER("Header", "*." WBWRITER_FILEEXTENSION_HEADER) MAKE_COMMDLG_FILTER("All", "*.*");
    static const LPCSTR     pszSbkTitle         = "Create Wave Bank File";
    static const LPCSTR     pszHdrTitle         = "Create Header File";
    static const DWORD      dwOfnFlags          = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
    CGuiWaveBank *          pBank               = NULL;
    HRESULT                 hr                  = S_OK;
    CHAR                    szSbkPath[MAX_PATH];
    CHAR                    szHdrPath[MAX_PATH];
    CHAR                    szDrive[MAX_PATH];
    CHAR                    szDir[MAX_PATH];
    CHAR                    szFile[MAX_PATH];
    CHAR                    szExt[MAX_PATH];
    PLIST_ENTRY             pleBank;
    OPENFILENAME            ofn;

    szSbkPath[0] = 0;
    szHdrPath[0] = 0;
    
    //
    // Get the wave bank file path
    //

    while(SUCCEEDED(hr))
    {
        ZeroMemory(&ofn, sizeof(ofn));

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = m_pParent->m_hwnd;
        ofn.lpstrFilter = pszSbkFilter;
        ofn.lpstrFile = szSbkPath;
        ofn.nMaxFile = NUMELMS(szSbkPath);
        ofn.lpstrTitle = pszSbkTitle;
        ofn.Flags = dwOfnFlags;
        ofn.lpstrDefExt = WBWRITER_FILEEXTENSION_BANK;

        if(!GetSaveFileName(&ofn))
        {
            hr = E_ABORT;
        }

        if(SUCCEEDED(hr))
        {
            for(pleBank = m_lstBanks.Flink; pleBank != &m_lstBanks; pleBank = pleBank->Flink)
            {
                pBank = CONTAINING_RECORD(pleBank, CGuiWaveBank, m_leBank);

                if(!_stricmp(szSbkPath, pBank->m_szBankFile))
                {
                    break;
                }
            }

            if(pleBank == &m_lstBanks)
            {
                pBank = NULL;
                break;
            }
            else
            {
                m_pParent->MessageBox("That wave bank file already exists in the project", MB_OK | MB_ICONSTOP);
            }
        }
    }
    
    //
    // Get the header file path
    //
    
    while(SUCCEEDED(hr))
    {
        _splitpath(szSbkPath, szDrive, szDir, szFile, szExt);
        _makepath(szHdrPath, szDrive, szDir, szFile, "." WBWRITER_FILEEXTENSION_HEADER);

        ZeroMemory(&ofn, sizeof(ofn));

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = m_pParent->m_hwnd;
        ofn.lpstrFilter = pszHdrFilter;
        ofn.lpstrFile = szHdrPath;
        ofn.nMaxFile = NUMELMS(szHdrPath);
        ofn.lpstrTitle = pszHdrTitle;
        ofn.Flags = dwOfnFlags;
        ofn.lpstrDefExt = WBWRITER_FILEEXTENSION_HEADER;

        if(!GetSaveFileName(&ofn))
        {
            hr = E_ABORT;
        }

        if(SUCCEEDED(hr))
        {
            for(pleBank = m_lstBanks.Flink; pleBank != &m_lstBanks; pleBank = pleBank->Flink)
            {
                pBank = CONTAINING_RECORD(pleBank, CGuiWaveBank, m_leBank);

                if(!_stricmp(szHdrPath, pBank->m_szHeaderFile))
                {
                    break;
                }
            }

            if(pleBank == &m_lstBanks)
            {
                pBank = NULL;
                break;
            }
            else
            {
                m_pParent->MessageBox("That header file already exists in the project", MB_OK | MB_ICONSTOP);
            }
        }
    }

    //
    // Create the wave bank object
    //

    if(SUCCEEDED(hr))
    {
        hr = CWaveBankProject::AddBank(szFile, szSbkPath, szHdrPath, (CWaveBank **)&pBank);
    }

    //
    // Resize the list-view columns
    //

    if(SUCCEEDED(hr))
    {
        ListView_AutoSizeColumns(m_hwndBankList);
    }

    //
    // Activate the new bank
    //
    
    if(SUCCEEDED(hr))
    {
        ListView_SelectItem(m_hwndBankList, ListView_GetItemCount(m_hwndBankList) - 1, TRUE, TRUE);
    }

    //
    // Set focus to the bank list
    //

    if(SUCCEEDED(hr))
    {
        SetFocus(m_hwndBankList);
    }

    //
    // Clean up
    //

    if(FAILED(hr))
    {
        DELETE(pBank);
    }

    return hr;
}


/****************************************************************************
 *
 *  RemoveBank
 *
 *  Description:
 *      Removes a bank from the project.
 *
 *  Arguments:
 *      UINT [in]: bank index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::RemoveBank"

void
CGuiWaveBankProject::RemoveBank
(
    UINT                    nBankIndex
)
{
    CGuiWaveBank *          pBank;

    //
    // Get the bank pointer
    //

    pBank = CGuiWaveBank::GetBank(m_hwndBankList, nBankIndex);
    
    //
    // Remove the item from the list view
    //

    ListView_DeleteItem(m_hwndBankList, nBankIndex);

    // 
    // Reset the current bank selection and remove it from the project
    //

    if(pBank)
    {
        if(pBank == m_pActiveBank)
        {
            SelectBank(-1);
        }

        CWaveBankProject::RemoveBank(pBank);
    }
}


/****************************************************************************
 *
 *  RemoveEntry
 *
 *  Description:
 *      Removes an entry from the project.
 *
 *  Arguments:
 *      UINT [in]: entry index.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::RemoveEntry"

void
CGuiWaveBankProject::RemoveEntry
(
    UINT                    nEntryIndex
)
{
    CGuiWaveBankEntry *     pEntry;

    //
    // Get the entry pointer
    //

    pEntry = CGuiWaveBankEntry::GetEntry(m_hwndEntryList, nEntryIndex);
    
    //
    // Remove the item from the list view
    //

    ListView_DeleteItem(m_hwndEntryList, nEntryIndex);

    //
    // Remove the entry from the project and update the UI
    //

    if(pEntry && m_pActiveBank)
    {
        m_pActiveBank->RemoveEntry(pEntry);
        m_pActiveBank->UpdateListView();
    }
}


/****************************************************************************
 *
 *  SelectBank
 *
 *  Description:
 *      Sets the currently active bank.
 *
 *  Arguments:
 *      CGuiWaveBank * [in]: bank.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::SelectBank"

void
CGuiWaveBankProject::SelectBank
(
    UINT                    nItem
)
{
    CGuiWaveBank *          pBank   = CGuiWaveBank::GetBank(m_hwndBankList, nItem);
    UINT                    i;
    
    if(pBank != m_pActiveBank)
    {
        //
        // Clear the entry list
        //
        
        ClearEntryList();

        //
        // Select the bank in the bank list
        //

        if(m_pActiveBank = pBank)
        {
            ListView_SelectItem(m_hwndBankList, nItem, TRUE, TRUE);
            SetFocus(m_hwndBankList);
        }

        //
        // Refill the entry list

        FillEntryList();

        //
        // Resize the entry list columns
        //

        ListView_AutoSizeColumns(m_hwndEntryList);

        //
        // Reset the entry-list sort data
        //

        for(i = 0; i < NUMELMS(CGuiWaveBankEntry::m_aColumnData); i++)
        {
            CGuiWaveBankEntry::m_aColumnData[i].fAscending = LVCOLUMN_ORDER_DEFAULT;
        }
    }
}


/****************************************************************************
 *
 *  ClearEntryList
 *
 *  Description:
 *      Removes all items from the entry list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::ClearEntryList"

void
CGuiWaveBankProject::ClearEntryList
(
    void
)
{
    ListView_DeleteAllItems(m_hwndEntryList);

    ImageList_RemoveAll(m_himlEntryList);
}


/****************************************************************************
 *
 *  FillEntryList
 *
 *  Description:
 *      Adds all entries in the current bank to the entry list-view.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::FillEntryList"

void
CGuiWaveBankProject::FillEntryList
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    CGuiWaveBankEntry *    pEntry;
    
    if(m_pActiveBank)
    {
        if(m_pActiveBank->m_dwEntryCount)
        {
            for(pleEntry = m_pActiveBank->m_lstEntries.Flink; pleEntry != &m_pActiveBank->m_lstEntries; pleEntry = pleEntry->Flink)
            {
                pEntry = CONTAINING_RECORD(pleEntry, CGuiWaveBankEntry, m_leEntry);

                pEntry->UpdateListView();
            }
        }
    }
}


/****************************************************************************
 *
 *  Open
 *
 *  Description:
 *      Opens an existing wave bank project.
 *
 *  Arguments:
 *      LPCSTR [in]: optional project file path.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::Open"

HRESULT
CGuiWaveBankProject::Open
(
    LPCSTR                  pszProjectFile
)
{
    static const LPCSTR     pszFilter   = MAKE_COMMDLG_FILTER("Project", "*." WBWRITER_FILEEXTENSION_PROJECT) MAKE_COMMDLG_FILTER("All", "*.*");
    static const LPCSTR     pszTitle    = "Open Project File";
    static const DWORD      dwOfnFlags  = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_ALLOWMULTISELECT;
    HRESULT                 hr          = S_OK;
    OPENFILENAME            ofn;

    //
    // Open the file
    //

    if(pszProjectFile)
    {
        strcpy(m_szProjectFile, pszProjectFile);
    }
    else
    {
        ZeroMemory(&ofn, sizeof(ofn));

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = m_pParent->m_hwnd;
        ofn.lpstrFilter = pszFilter;
        ofn.lpstrFile = m_szProjectFile;
        ofn.nMaxFile = NUMELMS(m_szProjectFile);
        ofn.lpstrTitle = pszTitle;
        ofn.Flags = dwOfnFlags;
        ofn.lpstrDefExt = WBWRITER_FILEEXTENSION_PROJECT;

        if(!GetOpenFileName(&ofn))
        {
            hr = E_ABORT;
        }
    }

    if(SUCCEEDED(hr))
    {
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        
        hr = ReadProjectData(m_szProjectFile);

        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }

    //
    // Resize the list-view columns
    //

    if(SUCCEEDED(hr))
    {
        ListView_AutoSizeColumns(m_hwndBankList);
    }

    //
    // Select the first bank in the list
    //

    if(SUCCEEDED(hr))
    {
        SelectBank(0);
    }

    return hr;
}


/****************************************************************************
 *
 *  Save
 *
 *  Description:
 *      Saves the wave bank project.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to prompt for the file name.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::Save"

HRESULT
CGuiWaveBankProject::Save
(
    BOOL                    fPrompt
)
{
    static const LPCSTR     pszFilter   = MAKE_COMMDLG_FILTER("Project", "*." WBWRITER_FILEEXTENSION_PROJECT) MAKE_COMMDLG_FILTER("All", "*.*");
    static const LPCSTR     pszTitle    = "Save Project File";
    static const DWORD      dwOfnFlags  = OFN_ENABLESIZING | OFN_EXPLORER | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    HRESULT                 hr          = S_OK;
    OPENFILENAME            ofn;

    if(!strlen(m_szProjectFile))
    {
        fPrompt = TRUE;
    }

    if(fPrompt)
    {
        ZeroMemory(&ofn, sizeof(ofn));

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = m_pParent->m_hwnd;
        ofn.lpstrFilter = pszFilter;
        ofn.lpstrFile = m_szProjectFile;
        ofn.nMaxFile = NUMELMS(m_szProjectFile);
        ofn.lpstrTitle = pszTitle;
        ofn.Flags = dwOfnFlags;
        ofn.lpstrDefExt = WBWRITER_FILEEXTENSION_PROJECT;

        if(!GetSaveFileName(&ofn))
        {
            hr = E_ABORT;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = WriteProjectData(m_szProjectFile);
    }

    return hr;
}


/****************************************************************************
 *
 *  Attach
 *
 *  Description:
 *      Attaches the object to the list-view windows.
 *
 *  Arguments:
 *      HWND [in]: bank list-view.
 *      HWND [in]: entry list-view.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::Attach"

void
CGuiWaveBankProject::Attach
(
    HWND                    hwndBankList,
    HWND                    hwndEntryList
)
{
    HIMAGELIST              himlOld;
    
    m_hwndBankList = hwndBankList;
    m_hwndEntryList = hwndEntryList;

    //
    // Create image lists
    //

    if(m_himlBankList = ImageList_Create(16, 16, ILC_COLOR8 | ILC_MASK, 1, 0))
    {
        if(m_hBankIcon = (HICON)LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_BANK), IMAGE_ICON, 16, 16, 0))
        {
            m_nBankIcon = ImageList_AddIcon(m_himlBankList, m_hBankIcon);
        }

        if(himlOld = ListView_SetImageList(m_hwndBankList, m_himlBankList, LVSIL_SMALL))
        {
            ImageList_Destroy(himlOld);
        }
    }

    if(m_himlEntryList = ImageList_Create(16, 16, ILC_COLOR8 | ILC_MASK, 1, -1))
    {
        if(himlOld = ListView_SetImageList(m_hwndEntryList, m_himlEntryList, LVSIL_SMALL))
        {
            ImageList_Destroy(himlOld);
        }
    }
}


/****************************************************************************
 *
 *  Detach
 *
 *  Description:
 *      Attaches the object from the list-view windows.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to clear the lists.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::Detach"

void
CGuiWaveBankProject::Detach
(
    BOOL                    fClearList
)
{
    if(fClearList)
    {
        ListView_DeleteAllItems(m_hwndBankList);
        ListView_DeleteAllItems(m_hwndEntryList);
    }

    m_hwndBankList = NULL;
    m_hwndEntryList = NULL;
}


/****************************************************************************
 *
 *  SortBankList
 *
 *  Description:
 *      Sorts the entry list.
 *
 *  Arguments:
 *      UINT [in]: column index to sort by.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBank::SortBankList"

void
CGuiWaveBankProject::SortBankList
(
    UINT                    nColumn
)
{
    const LPLVCOLUMNDATA    pColumn     = &CGuiWaveBank::m_aColumnData[nColumn];
    PLIST_ENTRY             pleBank;
    CGuiWaveBank *          pBank;
    int                     nItemCount;
    int                     nItem;

    ASSERT(nColumn < NUMELMS(CGuiWaveBank::m_aColumnData));

    //
    // Let the list-view sort the list
    //

    ListView_SortItems(m_hwndBankList, nColumn, pColumn->fString, pColumn->fAscending, NULL, NULL);

    //
    // Rebuild the list based on the list-view data
    //

    while(&m_lstBanks != RemoveHeadList(&m_lstBanks));

    nItemCount = ListView_GetItemCount(m_hwndBankList);
    
    for(nItem = 0; nItem < nItemCount; nItem++)
    {
        pBank = CGuiWaveBank::GetBank(m_hwndBankList, nItem);
        ASSERT(pBank);

        InsertTailList(&m_lstBanks, &pBank->m_leBank);
    }

    //
    // Swap the ascending flag
    //

    pColumn->fAscending = !pColumn->fAscending;
}


/****************************************************************************
 *
 *  AddEntry
 *
 *  Description:
 *      Adds an entry to the active bank.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::AddEntry"

HRESULT
CGuiWaveBankProject::AddEntry
(
    void
)
{
    HRESULT                 hr;

    if(!m_pActiveBank)
    {
        return E_FAIL;
    }

    //
    // Add the entry
    //

    hr = m_pActiveBank->AddEntry();

    //
    // Resize columns
    //

    if(SUCCEEDED(hr))
    {
        ListView_AutoSizeColumns(m_hwndEntryList);
    }

    return hr;
}


/****************************************************************************
 *
 *  Generate
 *
 *  Description:
 *      Generates project files.
 *
 *  Arguments:
 *      CWaveBankCallback * [in]: callback object.
 *      BOOL [in]: TRUE to allow file overwrites.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::Generate"

HRESULT
CGuiWaveBankProject::Generate
(
    void
)
{
    HANDLE                  hThread     = NULL;
    HRESULT                 hr          = S_OK;
    DWORD                   dwThreadId;
    HWND                    hwnd;
    
    //
    // Create the dialog
    //

    if(!(hwnd = m_GenerateDialog.Create(this)))
    {
        hr = E_FAIL;
    }

    //
    // Spawn the generation thread
    //

    hThread = CreateThread(NULL, 0, GenerateThreadProc, (LPVOID)this, 0, &dwThreadId);
    
    if(!IS_VALID_HANDLE_VALUE(hThread))
    {
        hr = E_OUTOFMEMORY;
    }
    
    //
    // Clean up
    //

    CLOSE_HANDLE(hThread);

    if(FAILED(hr))
    {
        EndDialog(hwnd, hr);
    }

    return hr;
}


/****************************************************************************
 *
 *  GenerateThreadProc
 *
 *  Description:
 *      Generation thread proc.
 *
 *  Arguments:
 *      LPVOID [in]: thread context.
 *
 *  Returns:  
 *      DWORD: thread return code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::GenerateThreadProc"

DWORD 
CGuiWaveBankProject::GenerateThreadProc
(
    LPVOID                  pvContext
)
{
    return ((CGuiWaveBankProject *)pvContext)->GenerateThread();
}


/****************************************************************************
 *
 *  GenerateThread
 *
 *  Description:
 *      Generation thread proc.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::GenerateThread"

HRESULT
CGuiWaveBankProject::GenerateThread
(
    void
)
{
    HRESULT                 hr;

    //
    // BUGBUG: we're not doing any thread synchronization because we're
    // relying on the fact that the parent window is disabled and so won't
    // be doing anything.  This probably isn't a good thing.
    //

    //
    // Start generation
    //

    hr = CWaveBankProject::Generate(&m_GenerateDialog, TRUE);

    //
    // Wait for the dialog to close
    //

    if(SUCCEEDED(hr))
    {
        WaitForSingleObject(m_GenerateDialog.m_hTerminateEvent, INFINITE);
    }

    return hr;
}


/****************************************************************************
 *
 *  Refresh
 *
 *  Description:
 *      Refreshes bank data.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGuiWaveBankProject::Refresh"

HRESULT
CGuiWaveBankProject::Refresh
(
    void
)
{
    HRESULT                 hr          = S_OK;
    PLIST_ENTRY             pleBank;
    CGuiWaveBank *          pBank;

    //
    // Refresh all banks
    //

    for(pleBank = m_lstBanks.Flink; (pleBank != &m_lstBanks) && SUCCEEDED(hr); pleBank = pleBank->Flink)
    {
        pBank = CONTAINING_RECORD(pleBank, CGuiWaveBank, m_leBank);

        hr = pBank->Refresh();
    }

    //
    // Update list-view data
    //

    if(m_pActiveBank)
    {
        ClearEntryList();
        FillEntryList();
        
        m_pActiveBank->UpdateListView();
    }

    return hr;
}


/****************************************************************************
 *
 *  CGenerateDialog
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::CGenerateDialog"

CGenerateDialog::CGenerateDialog
(
    void
)
{
    m_hTerminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}


/****************************************************************************
 *
 *  ~CGenerateDialog
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::~CGenerateDialog"

CGenerateDialog::~CGenerateDialog
(
    void
)
{
    CLOSE_HANDLE(m_hTerminateEvent);
}


/****************************************************************************
 *
 *  Create
 *
 *  Description:
 *      Creates the dialog.
 *
 *  Arguments:
 *      CGuiWaveBankProject * [in]: project.
 *      CWindow * [in]: parent window.
 *
 *  Returns:  
 *      HWND: window handle.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::Create"

HWND
CGenerateDialog::Create
(
    CGuiWaveBankProject *   pProject
)
{
    HWND                    hwnd;
    
    m_fContinue = TRUE;
    m_fAllowClose = FALSE;
    m_nEntryIndex = 0;

    //
    // Create the dialog
    //
    
    if(!(hwnd = CModelessDialog::Create(IDD, NULL, pProject->m_pParent)))
    {
        return NULL;
    }

    //
    // Disable the parent window
    //

    if(m_pParent)
    {
        EnableWindow(m_pParent->m_hwnd, FALSE);
    }

    return hwnd;
}


/****************************************************************************
 *
 *  OnInitDialog
 *
 *  Description:
 *      Handles dialog initialization.
 *
 *  Arguments:
 *      LPVOID [in]: creation context.
 *      LRESULT * [out]: message result code.
 *
 *  Returns:  
 *      BOOL: FALSE to allow the message to be passed to the default handler.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::OnInitDialog"

BOOL
CGenerateDialog::OnInitDialog
(
    LPVOID                  pvContext,
    LRESULT *               plResult
)
{
    CHAR                    szTemplate[0x100];
    CHAR                    szText[0x100];
    BOOL                    fHandled;
    
    fHandled = CModelessDialog::OnInitDialog(pvContext, plResult);
    
    //
    // Save the text format and clear the controls
    //

    GetDlgItemText(m_hwnd, IDC_BANK, m_szBankText, NUMELMS(m_szBankText));
    SetDlgItemText(m_hwnd, IDC_BANK, NULL);

    GetDlgItemText(m_hwnd, IDC_ENTRY, m_szEntryText, NUMELMS(m_szEntryText));
    SetDlgItemText(m_hwnd, IDC_ENTRY, NULL);

    //
    // Set the dialog title
    //

    GetWindowText(m_hwnd, szTemplate, NUMELMS(szTemplate));
    sprintf(szText, szTemplate, g_pszAppTitle);
    SetWindowText(m_hwnd, szText);

    //
    // Center the window
    //

    CenterWindow(m_hwnd, m_pParent ? m_pParent->m_hwnd : NULL);

    return fHandled;
}


/****************************************************************************
 *
 *  OnCancel
 *
 *  Description:
 *      Handles closing the window.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::OnCancel"

void 
CGenerateDialog::OnCancel
(
    void
)
{
    static const LPCSTR     pszCancelling   = "Cancelling...";

    //
    // Toggle the continue member to FALSE
    //
    
    m_fContinue = FALSE;

    //
    // If we're allowed to close, do it now.  If not, let the user know that
    // we're working on it.
    //

    if(m_fAllowClose)
    {
        SetEvent(m_hTerminateEvent);
        EnableWindow(m_pParent->m_hwnd, TRUE);
        EndDialog(m_hwnd, 0);
    }
    else
    {
        SetDlgItemText(m_hwnd, IDC_BANK, pszCancelling);

        ShowWindow(GetDlgItem(m_hwnd, IDC_ENTRY), SW_HIDE);
        ShowWindow(GetDlgItem(m_hwnd, IDC_PROGRESS), SW_HIDE);

        EnableWindow(GetDlgItem(m_hwnd, IDCANCEL), FALSE);
    }
}


/****************************************************************************
 *
 *  BeginProject
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      UINT [in]: total number of banks in the project.
 *      UINT [in]: total number of entries in the project.
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::BeginProject"

BOOL
CGenerateDialog::BeginProject
(
    UINT                    nBankCount, 
    UINT                    nEntryCount
)
{
    SendDlgItemMessage(m_hwnd, IDC_PROGRESS, PBM_SETRANGE32, 0, nEntryCount);

    return m_fContinue;
}


/****************************************************************************
 *
 *  EndProject
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      HRESULT [in]: return code.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::EndProject"

void
CGenerateDialog::EndProject
(
    HRESULT                 hr
)
{
    static const LPCSTR     pszSuccess  = "All entries were successfully written";
    static const LPCSTR     pszAbort    = "The operation was cancelled";
    static const LPCSTR     pszError    = "Errors occurred during processing";
    static const LPCSTR     pszClose    = "Close";
    
    if(SUCCEEDED(hr))
    {
        SetDlgItemText(m_hwnd, IDC_BANK, pszSuccess);
    }
    else if(E_ABORT == hr)
    {
        SetDlgItemText(m_hwnd, IDC_BANK, pszAbort);
    }        
    else
    {
        SetDlgItemText(m_hwnd, IDC_BANK, pszError);
    }

    ShowWindow(GetDlgItem(m_hwnd, IDC_ENTRY), SW_HIDE);
    ShowWindow(GetDlgItem(m_hwnd, IDC_PROGRESS), SW_HIDE);

    SetDlgItemText(m_hwnd, IDCANCEL, pszClose);
    EnableWindow(GetDlgItem(m_hwnd, IDCANCEL), TRUE);

    MessageBeep(-1);

    m_fAllowClose = TRUE;
}


/****************************************************************************
 *
 *  OpenBank
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      LPCSTR [in]: bank file name.
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::OpenBank"

BOOL
CGenerateDialog::OpenBank
(
    LPCSTR                  pszFile
)
{
    CHAR                    szText[MAX_PATH + 0x100];
    CHAR                    szFile[MAX_PATH];

    _splitpath(pszFile, NULL, NULL, szFile, NULL);
    sprintf(szText, m_szBankText, szFile);

    SetDlgItemText(m_hwnd, IDC_BANK, szText);

    return m_fContinue;
}


/****************************************************************************
 *
 *  BeginEntry
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      LPCSTR [in]: entry file name.
 *      DWORD [in]: entry flags.
 *
 *  Returns:  
 *      BOOL: TRUE to continue processing.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::BeginEntry"

BOOL
CGenerateDialog::BeginEntry
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags
)
{
    static CHAR             szText[MAX_PATH + 0x100];
    CHAR                    szFile[MAX_PATH];

    _splitpath(pszFile, NULL, NULL, szFile, NULL);
    sprintf(szText, m_szEntryText, szFile);

    SetDlgItemText(m_hwnd, IDC_ENTRY, szText);

    return m_fContinue;
}


/****************************************************************************
 *
 *  EndEntry
 *
 *  Description:
 *      Callback function.
 *
 *  Arguments:
 *      LPCSTR [in]: entry file name.
 *      DWORD [in]: entry flags.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CGenerateDialog::EndEntry"

void
CGenerateDialog::EndEntry
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags
)
{
    SendDlgItemMessage(m_hwnd, IDC_PROGRESS, PBM_SETPOS, ++m_nEntryIndex, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\cipher.cpp ===
#include "..\xcodescr\cipher.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xcodescr\scramble.h ===
#include "..\inc\cipher.h"

#define DBGLVL_INFO 2
#define DBGLVL_WARN 1
#define DBGLVL_ERROR 0

#define APP_NAME "xcodescr"

class CCodeScrambler {

protected:

	UCHAR m_szKey[KEY_SIZE+1];
    UCHAR m_szDspCodeFileName[MAX_PATH];
    UCHAR m_szOutputFileName[MAX_PATH];


    HANDLE m_hInputFile;
    HANDLE m_hOutputFile;

	DWORD m_dwDebugLevel;

public:

    CCodeScrambler::CCodeScrambler();
    CCodeScrambler::~CCodeScrambler();

	//
	// utility functions
	//
    void CCodeScrambler::UsageFailure(int err);
    int ParseCommandLine(int argc, char * argv[]);
	void DebugPrint(DWORD dwLevel, PCHAR pszFormat, ...);

	//
	// encode
	//

	int Encode();
	int Decode();

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xcodescr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	codescr.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xcodescr\cipher.cpp ===
#ifndef _XBOX
#include "stdafx.h"
#endif

#include "..\inc\cipher.h"


void lfsr(ULONGLONG seed, PVOID Contents, ULONG Length)
{
	static ULONGLONG ShiftReg;

	if (seed != 0 ) {
		ShiftReg = seed;
	}

	ShiftReg = ((((ShiftReg >> 63) 
		^ (ShiftReg >> 3)
		^ (ShiftReg >> 2)
		^ (ShiftReg)) & 0x1) << 63) | (ShiftReg >> 1);

	if (Contents) {

		memcpy(Contents, &ShiftReg,Length);
	}


}

void rotr(unsigned long *value,ULONG nRotBits,UCHAR valueSize)
{
	union {
		USHORT shortV;
		ULONG longV;
		UCHAR charV;
	} u;

	u.longV = *value;

	switch (valueSize) {
	case 1:
		u.charV = (u.charV << nRotBits) | (u.charV >> (8-nRotBits));
		break;
	case 2:
		u.shortV = (u.shortV << nRotBits) | (u.shortV >> (16-nRotBits));
		break;
	case 4:
		u.longV = (u.longV << nRotBits) | (u.longV >> (32-nRotBits));
		break;
	}


	*value = u.longV;

	
}

void rotl(unsigned long * value,ULONG nRotBits,UCHAR valueSize)
{
	union {
		USHORT shortV;
		ULONG longV;
		UCHAR charV;
	} u;

	u.longV = *value;

	switch (valueSize) {
	case 1:
		u.charV = (u.charV >> nRotBits) | (u.charV << (8-nRotBits));
		break;
	case 2:
		u.shortV = (u.shortV >> nRotBits) | (u.shortV << (16-nRotBits));
		break;
	case 4:
		u.longV = (u.longV >> nRotBits) | (u.longV << (32-nRotBits));
		break;
	
	}


	*value = u.longV;
	
}

void XAudiopUtility_GenerateKey(PUCHAR pKey)
{

	ULONGLONG seed = PRIVATE_KEY_SEED;

	//
	// seed LFSR
	//

	lfsr(seed,NULL,0);

	//
	// shift a few times
	//

	for (ULONG i=0;i<KEY_SIZE*10;i++) {
		lfsr(0,pKey,KEY_SIZE);
	}

}

int XAudiopUtility_Encode(PUCHAR pKey,
						  PUCHAR pSrc, 
						  DWORD dwSize, 
						  PUCHAR pDst,
						  BOOL fIncludeKey)
{
	ULONGLONG seed;
	UCHAR szPrivateKey[KEY_SIZE];
	ULONG i;
	int err = ERROR_SUCCESS;
	UCHAR temp,temp2;

	XAudiopUtility_GenerateKey(szPrivateKey);

	for (i=0;i<KEY_SIZE;i++) {

		//
      	// store our key with their key in the first N bytes of destination
	    //

		temp = szPrivateKey[i] ^ pKey[i];
		if (fIncludeKey) {

			*(pDst+i) = temp;

		}

	}

    //
	// seed the LFSR
	//

	memcpy(&seed,szPrivateKey,sizeof(seed));
	lfsr(seed,NULL,0);

	//
	// encode the data, byte at a time..
	// we do a XOR, rght shift, left shift
	//

	if (fIncludeKey) {
		pDst += KEY_SIZE;
	}

	temp = 0;

	for (i=0;i<dwSize;i++) {

		lfsr(0,&temp2,sizeof(UCHAR));
		temp = temp2 ^ *(pSrc+i) ^ szPrivateKey[i%KEY_SIZE];

		temp += szPrivateKey[i%KEY_SIZE]*pKey[i%KEY_SIZE];
		*(pDst+i) = temp;

	}


#if _DEBUG

	//
	// DEBUG ONLY: Verify encryption/decryption
	//

	PUCHAR pDst2 = new UCHAR[dwSize];
	memset(pDst2,0,dwSize);

	if (fIncludeKey) {
		XAudiopUtility_Decode(pKey, pDst-KEY_SIZE,dwSize+KEY_SIZE,pDst2,TRUE);
	} else {
		XAudiopUtility_Decode(pKey, pDst,dwSize,pDst2, FALSE);
	}

	if (pSrc != pDst) {
		err = memcmp(pDst2,pSrc,dwSize);
		if (err) {
			err = -1;
		}
	}


	delete [] pDst2;

#endif

	return err;

}


//
// NOTE: if fIsKeyEmbedded is TRUE, pSrc != pDst
//
	
int XAudiopUtility_Decode(PUCHAR pKey,
						  PUCHAR pSrc, 
						  DWORD  dwSize, 
						  PUCHAR pDst,
						  BOOL   fIsKeyEmbedded)
{
	ULONGLONG seed;

	UCHAR szPrivateKey[KEY_SIZE],szDevKey[KEY_SIZE];
	ULONG i;
	int err = ERROR_SUCCESS;
	UCHAR temp,temp2;

	//
	// regenerate our key
	//
	
	XAudiopUtility_GenerateKey(szPrivateKey);

	if (fIsKeyEmbedded) {

		//
		// recover user key from first N bytes of src
		//
		
		for (i=0;i<KEY_SIZE;i++) {
			
			szDevKey[i] = szPrivateKey[i] ^ *(pSrc+i);
			
		}

		if (pKey) {
			memcpy(pKey,szDevKey,KEY_SIZE);
		}

	} else {

		if (pKey == NULL) {
			return -1;
		}

		memcpy(szDevKey,pKey,KEY_SIZE);

	}

    //
	// seed the LFSR
	//

	memcpy(&seed,szPrivateKey,sizeof(seed));
	lfsr(seed,NULL,0);

	//
	// decode the data, byte at a time..
	// we do the inverse of the encode algorithm
	//

	if (fIsKeyEmbedded) {
		pSrc += KEY_SIZE;
		dwSize -= KEY_SIZE;
	}

	temp = 0;

	for (i=0;i<dwSize;i++) {

		temp = *(pSrc+i);
		temp -= szPrivateKey[i%KEY_SIZE]*szDevKey[i%KEY_SIZE];	
		lfsr(0,&temp2,sizeof(UCHAR));
		*(pDst+i) = temp2 ^ temp ^ szPrivateKey[i%KEY_SIZE];
	}


	return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xcodescr\codescr.cpp ===
// codescr.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "scramble.h"

int __cdecl main(int argc, char* argv[])
{
	int err;
	CCodeScrambler Scrambler;

	//
	// parse command line and open files
	//
	err = Scrambler.ParseCommandLine(argc,argv);

	//
	// encode the data
	//

	if (err == ERROR_SUCCESS) {

		err = Scrambler.Encode();

	}

	return err;
}

CCodeScrambler::CCodeScrambler()
{

	memset(m_szKey,0,sizeof(m_szKey));
    m_hInputFile = NULL;
    m_hOutputFile = NULL;
	m_dwDebugLevel = DBGLVL_WARN;


}

void CCodeScrambler::DebugPrint(DWORD dwLevel, PCHAR pszFormat, ...)
{
    CHAR                    szString[0x400];
    va_list                 va;

	va_start(va, pszFormat);
	vsprintf(szString, pszFormat, va);
	va_end(va);
	
	if (m_dwDebugLevel >= dwLevel) {
		
		fprintf(stderr,"*** %s ***\n",
			szString);
	}

}

void CCodeScrambler::UsageFailure(int err)
{
	if (err!=ERROR_SUCCESS){
		fprintf(stderr,"\n Error: 0x%x\n", err);
	}

    fprintf(stderr,"\n Usage: %s [key (8 chars)] [DSP binary code filename] [output filename]\n",
        APP_NAME);

}

int CCodeScrambler::ParseCommandLine(int argc, char **argv)
{

    int err = ERROR_SUCCESS;

	if (strstr("?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
		err = -1;
        return err;
	}

	if (strstr("/?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
		err = -1;
        return err;
	}

	if (strstr("-?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
		err = -1;
        return err;
	}

    if (argc < 3) {

        err = -1;
        UsageFailure(err);
        return err;
    }
	

    memcpy(m_szKey,argv[1],sizeof(m_szKey));
    printf("Key %s\n", m_szKey);

    memcpy(m_szDspCodeFileName,argv[2],sizeof(m_szDspCodeFileName));
    printf("Input File to scramble %s\n", m_szDspCodeFileName);

    memcpy(m_szOutputFileName,argv[3],sizeof(m_szOutputFileName));
    printf("Output File %s\n", m_szOutputFileName);
    
    //
    // open the file so we can generating the image
    //

    m_hOutputFile = CreateFile(
        (const char *)m_szOutputFileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL);

    if (m_hOutputFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        fprintf(stderr,"\n Failed to open the output file.Error 0x%x\n", err);
        return err;

    }

    m_hInputFile = CreateFile(
        (const char *)m_szDspCodeFileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_ALWAYS,
        0,
        NULL);

    if (m_hInputFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        fprintf(stderr,"\n Failed to open the dsp code file.Error 0x%x\n", err);
        return err;

    }

    return ERROR_SUCCESS;

}

CCodeScrambler::~CCodeScrambler()
{
    if (m_hInputFile != NULL) {
        CloseHandle(m_hInputFile);
    }

    if (m_hOutputFile != NULL) {
        CloseHandle(m_hOutputFile);
    }

}

int CCodeScrambler::Encode()
{

	DWORD dwSize,dwActualSize;
	PUCHAR pSrc,pDst;
	int err = ERROR_SUCCESS;
	BOOL bResult = FALSE;

	//
	// determine size of input file

	dwSize = SetFilePointer(m_hInputFile, 0, NULL, FILE_END);              
	SetFilePointer(m_hInputFile, 0, NULL, FILE_BEGIN);

	pSrc = new UCHAR[dwSize];
	if (pSrc == NULL) {
		err = ERROR_OUTOFMEMORY;
		goto errExit;
	}

	pDst = new UCHAR[dwSize+KEY_SIZE];
	if (pDst == NULL) {
		err = ERROR_OUTOFMEMORY;
		goto errExit;
	}

	memset(pDst,0,dwSize);

	//
	// read file data
	//

	bResult = ReadFile(m_hInputFile,
		pSrc,
		dwSize,
		&dwActualSize,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to read dsp code from file %s.Error 0x%x",
			m_szDspCodeFileName,
			err);

		goto errExit;
		
	}

	//
	// call library function
	//

	err = XAudiopUtility_Encode(m_szKey,pSrc,dwSize,pDst,TRUE);
	
	if (err == ERROR_SUCCESS) {
		
		//
		// write result to output file
		//
		bResult = WriteFile(m_hOutputFile,
			pDst,
			dwSize+KEY_SIZE,
			&dwActualSize,
			0);
		
		if (!bResult) {
			
			err = GetLastError();
			DebugPrint(DBGLVL_ERROR,"Failed to write dsp scrambled output to file %s.Error 0x%x",
				m_szOutputFileName,
				err);
			
			goto errExit;
			
		}

	}

	//
	// destructor will close the handles
	//

errExit:

	if (pDst) {
		delete [] pDst;
	}

	if (pSrc) {
		delete [] pSrc;
	}

	return err;
}

int CCodeScrambler::Decode()
{

	DWORD dwSize,dwActualSize;
	PUCHAR pSrc,pDst;
	int err = ERROR_SUCCESS;
	BOOL bResult = FALSE;

	//
	// determine size of input file

	dwSize = SetFilePointer(m_hInputFile, 0, NULL, FILE_END);              
	SetFilePointer(m_hInputFile, 0, NULL, FILE_BEGIN);

	pSrc = new UCHAR[dwSize];
	if (pSrc == NULL) {
		err = ERROR_OUTOFMEMORY;
		goto errExit;
	}

	pDst = new UCHAR[dwSize-KEY_SIZE];
	if (pDst == NULL) {
		err = ERROR_OUTOFMEMORY;
		goto errExit;
	}

	memset(pDst,0,dwSize);

	//
	// read file data
	//

	bResult = ReadFile(m_hInputFile,
		pSrc,
		dwSize,
		&dwActualSize,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to read dsp code from file %s.Error 0x%x",
			m_szDspCodeFileName,
			err);

		goto errExit;
		
	}

	//
	// call library function
	//

	err = XAudiopUtility_Decode(NULL,pSrc,dwSize,pDst,TRUE);
	
	if (err == ERROR_SUCCESS) {
		
		//
		// write result to output file
		//
		bResult = WriteFile(m_hOutputFile,
			pDst,
			dwSize,
			&dwActualSize,
			0);
		
		if (!bResult) {
			
			err = GetLastError();
			DebugPrint(DBGLVL_ERROR,"Failed to write dsp scrambled output to file %s.Error 0x%x",
				m_szOutputFileName,
				err);
			
			goto errExit;
			
		}

	}

	//
	// destructor will close the handles
	//

errExit:

	if (pDst) {
		delete [] pDst;
	}

	if (pSrc) {
		delete [] pSrc;
	}

	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xcodescr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__5F117C5D_1CF6_4BC7_A40C_4410AD70617D__INCLUDED_)
#define AFX_STDAFX_H__5F117C5D_1CF6_4BC7_A40C_4410AD70617D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

#include <windows.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5F117C5D_1CF6_4BC7_A40C_4410AD70617D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\dspfixup.cpp ===
#include "stdafx.h"
#include "fxdspimg.h"

//
// builds scratch image to be loaded into offset 0 of scratch memory...
//


int CDspImageBuilder::BuildDspImage()
{

    int err = ERROR_SUCCESS;

	BOOL bResult = FALSE;
	DWORD dwTotalSize = 0;
	CFxData *pCurrentFx = NULL, *pPreviousFx = NULL;
    DWORD dwBytesWritten;

	DWORD dwGraphIndex, dwFxIndex;
	DWORD j;

	DWORD dwCodeIndex = DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK);

	DWORD dwStateBaseIndex = dwCodeIndex + m_dwTotalDspCodeSize;

	DWORD dwStateIndex = DSP_FX_STATE_XMEMORY_BASE_OFFSET;

	//
	// the internal temp frame buffers are in XRAM, placed right after the concatenated
	// state blocks for all FX.
	//

	DWORD dwTempBinBaseIndex = dwStateIndex + m_dwTotalDspStateSize - 
		(m_dwNumTempBins*DSP_BUFFER_FRAME_LENGTH*sizeof(DWORD));

	DWORD dwYMemIndex = DSP_FX_STATE_YMEMORY_BASE_OFFSET;

	DWORD dwScratchIndex = DSP_FX_DELAY_DATA_SCRATCHOFFSET;

	//
	// the FX description data struct follows the delay line scratch space and is kept
	// by the driver/Game in system ram. The dsp does not parse this array..
	//

	HOST_TO_DSP_COMMANDBLOCK dspCommandBlock;

	SCRATCH_IMAGE_DESCRIPTOR *pDescriptor;
    SCRATCH_IMAGE_FX_DESCRIPTION *pFxDesc;

	PUCHAR pDevKeys;
	DWORD dwDevKeyBufferIndex = 0;

	//
	// initialize descriptor
	//

	DWORD dwDescriptorSize = sizeof(SCRATCH_IMAGE_DESCRIPTOR) + 
		sizeof(SCRATCH_IMAGE_FX_DESCRIPTION)*m_dwTotalFX;

	pDescriptor = (SCRATCH_IMAGE_DESCRIPTOR *) new BYTE[dwDescriptorSize];

	if (pDescriptor == NULL) {
		err = ERROR_OUTOFMEMORY;
		goto errExit;
	}

	pFxDesc = (SCRATCH_IMAGE_FX_DESCRIPTION *) ((PUCHAR)pDescriptor + sizeof(SCRATCH_IMAGE_DESCRIPTOR));

	memset(pDescriptor,0,dwDescriptorSize);
	pDescriptor->dwNumFX = m_dwTotalFX;

	//
	// set total scratch size in the header
	//

	pDescriptor->dwTotalScratchSize = m_dwTotalScratchSize;

	//
	// allocate buffer to store dev keys used to encrypt individual DSP code images
	// this buffer gets placed in the scratch file after the SCRATCH_IMAGE_DESCRIPTOR array
	//

	pDevKeys = new BYTE[KEY_SIZE*m_dwTotalFX];
    if (pDevKeys == NULL) {
		err = ERROR_OUTOFMEMORY;
		goto errExit;
	}

	    //
    // open the output file used to generate the image
    //

    m_hOutputFile = CreateFile(
        (const char *)m_szScratchImageFileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL);

    if (m_hOutputFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        Print("\n Failed to open the dsp image file.Error 0x%x\n", err);
        return err;

    }

	for (dwGraphIndex=0;dwGraphIndex<m_dwGraphCount;dwGraphIndex++){


		for (dwFxIndex=0;dwFxIndex<m_pGraphs[dwGraphIndex]->GetNumEffects();dwFxIndex++){

			pCurrentFx = m_pGraphs[dwGraphIndex]->GetFxData(dwFxIndex);

			//
			// change the first OPCODE of the FX dsp code so it points to the correct
			// offset in X:RAM. This way it will load into register rD(r5), the proper state
			// variables
			//

			PDWORD opcode = (PDWORD)pCurrentFx->m_pDspCode;

			//
			// verify its a 
			// move x:(CONSTANT),r5 
			// opcode
			//

			if (*opcode == DSP_563000_OPCODE_MOVE_X_TO_R5_IMM) {

				//
				// the next word specifies the source memory address
				// change that to the correct X memory offset

				*opcode++;
				*opcode = dwStateIndex/sizeof(DWORD);

			}

			//
			// write code for this FX in the correct offset in the scratch image
			//

			dwTotalSize = SetFilePointer(m_hOutputFile,
				dwCodeIndex,
				NULL,
				FILE_BEGIN);

			if (dwTotalSize == -1) {
				err = GetLastError();
				goto errExit;
			}

			//
			// right before we write this to file, encode the dsp code
			// using the authors ey and our private key
			//

			err = XAudiopUtility_Encode(pCurrentFx->m_szDevKey,
				(PUCHAR)pCurrentFx->m_pDspCode,
				pCurrentFx->m_dwDspCodeSize,
				(PUCHAR)pCurrentFx->m_pDspCode,
				FALSE);
			
			if (err !=ERROR_SUCCESS) {
				goto errExit;
			}

			bResult = WriteFile(m_hOutputFile,
				pCurrentFx->m_pDspCode,
				pCurrentFx->m_dwDspCodeSize,
				&dwBytesWritten,
				0);
			
			if (!bResult) {
				
				err = GetLastError();
				DebugPrint(DBGLVL_ERROR,"Failed to write scratch image to file %s",m_szScratchImageFileName);
				goto errExit;
				
			}
	
			//
			// setup this FX description
			//

			pFxDesc->dwCodeOffset = dwCodeIndex;
			pFxDesc->dwCodeSize = pCurrentFx->m_dwDspCodeSize;

			//
			// create an absolute scratch space offset
			//

			pFxDesc->dwStateOffset = dwStateBaseIndex+dwStateIndex-DSP_FX_STATE_XMEMORY_BASE_OFFSET;
			pFxDesc->dwStateSize = pCurrentFx->m_dwDspStateSize;

			//
			// set the scratch delay line info
			//

			pFxDesc->dwScratchOffset = dwScratchIndex;
			pFxDesc->dwScratchSize = pCurrentFx->GetScratchSize();

			//
			// set the Y memory info
			//

			((PDSP_STATE_FIXED)pCurrentFx->m_pDspState)->dwYMemBase = dwYMemIndex;
			pFxDesc->dwYMemOffset = ((PDSP_STATE_FIXED)pCurrentFx->m_pDspState)->dwYMemBase;
			pFxDesc->dwYMemSize = ((PDSP_STATE_FIXED)pCurrentFx->m_pDspState)->dwYMemLength;

			dwYMemIndex += ((PDSP_STATE_FIXED)pCurrentFx->m_pDspState)->dwYMemLength;

			//
			// increment to next fx description array element
			//

			pFxDesc++;

			//
			// store the dev encryption key for the current dsp image into a buffer
			// that gets written after the FX description array
			//

			memcpy(pDevKeys + dwDevKeyBufferIndex,pCurrentFx->m_szDevKey,KEY_SIZE);
			dwDevKeyBufferIndex += KEY_SIZE;

			//
			// update code scratch image offset
			//

			dwCodeIndex += pCurrentFx->m_dwDspCodeSize;

			//
			// fixup the pointer addresses for inputs/outputs
			// the first dwords in the small state block for each module
			// point to the input/output locations. First you specify all
			// input pointers in a contigious array of WORDs, followed by all output
			// IDs specified in a array of WORDS
			//

			for (j = 0; j < pCurrentFx->m_dwNumInputs; j++) {

				((PDSP_STATE_FIXED)pCurrentFx->m_pDspState)->dwIoPtrs[j] = 
					BufferIDToDSPAddress(dwTempBinBaseIndex,pCurrentFx->m_dwInputIDs[j]);

			}				
			
			//
			// output dwords start after the last inputID  WORD.
			//

			DWORD base = j;
			for ( j = 0 ; j < pCurrentFx->m_dwNumOutputs; j++) {

				((PDSP_STATE_FIXED)pCurrentFx->m_pDspState)->dwIoPtrs[base+j] = 
					BufferIDToDSPAddress(dwTempBinBaseIndex,pCurrentFx->m_dwOutputIDs[j]);

			}
				

			//
			// based on the current scratch space usage, fixup the scratch space offsets
			// in the FX state buffer, so the FX knows where its scratch lives..
			// the index is in BYTES since DSP dma expects SM_OFFSET dma word in bytes
			//

			((PDSP_STATE_FIXED)pCurrentFx->m_pDspState)->dwScratchBase = dwScratchIndex;
			((PDSP_STATE_FIXED)pCurrentFx->m_pDspState)->dwScratchLength = pCurrentFx->GetScratchSize();

			//
			// increment our pointer into the scratch space, by the amount reserved
			// in this effect
			//

			dwScratchIndex += pCurrentFx->GetScratchSize();

			//
			// copy state variable block for this FX into global state block buffer
			// The state block needs to be placed at the right offset in scratch memory
			// The dsp execution engine then DMAs it in a Xmemory internal buffer, allocated
			// at offset DSP_XMEMORY_BASE_OFFSET. When we fix up dsp code here,
			// we need to do it like we are insid the dsp pointing at absolute X-Mem
			// addresses
			//

			dwTotalSize = SetFilePointer(m_hOutputFile,
				dwStateBaseIndex+dwStateIndex-DSP_FX_STATE_XMEMORY_BASE_OFFSET,
				NULL,
				FILE_BEGIN);

			if (dwTotalSize == -1) {
				err = GetLastError();
				goto errExit;
			}
			
			bResult = WriteFile(m_hOutputFile,
				pCurrentFx->m_pDspState,
				pCurrentFx->m_dwDspStateSize,
				&dwBytesWritten,
				0);
			
			if (!bResult) {
				
				err = GetLastError();
				DebugPrint(DBGLVL_ERROR,"Failed to write scratch image to file %s",m_szScratchImageFileName);
				goto errExit;
				
			}
				
			dwStateIndex += pCurrentFx->m_dwDspStateSize;

		}

	}	

	//
	// the very last word of the concatenated DSP fx code must be an RTS
	//

	j = DSP_563000_OPCODE_RTS;
	dwTotalSize = SetFilePointer(m_hOutputFile,
		dwCodeIndex,
		NULL,
		FILE_BEGIN);

	if (dwTotalSize == -1) {
		err = GetLastError();
		goto errExit;
	}
	
	bResult = WriteFile(m_hOutputFile,
		&j,
		sizeof(DWORD),
		&dwBytesWritten,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to write scratch image to file %s",m_szScratchImageFileName);
		goto errExit;
		
	}

	// ************************************************************************
	//
	// write the FX description array right after the concatenated state blocks
	//
	// ************************************************************************

	dwTotalSize = SetFilePointer(m_hOutputFile,
		dwStateBaseIndex + m_dwTotalDspStateSize,
		NULL,
		FILE_BEGIN);
	
	if (dwTotalSize == -1) {
		err = GetLastError();
		goto errExit;
	}
	
	bResult = WriteFile(m_hOutputFile,
		pDescriptor,
		dwDescriptorSize,
		&dwBytesWritten,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to write scratch image to file %s",m_szScratchImageFileName);
		goto errExit;
		
	}

	// ************************************************************************
	//
	// write the concatenated dev encryptions keys after the FX description array
	// first we scramble them with our internal key
	//
	// ************************************************************************

	UCHAR szKey[8];
	XAudiopUtility_GenerateKey(szKey);

	err = XAudiopUtility_Encode(szKey,
		pDevKeys,
		KEY_SIZE*m_dwTotalFX,
		pDevKeys,
		FALSE);
	
	if (err !=ERROR_SUCCESS) {
		goto errExit;
	}

	dwTotalSize = SetFilePointer(m_hOutputFile,
		dwStateBaseIndex + m_dwTotalDspStateSize + dwBytesWritten,
		NULL,
		FILE_BEGIN);
	
	if (dwTotalSize == -1) {
		err = GetLastError();
		goto errExit;
	}
	
	bResult = WriteFile(m_hOutputFile,
		pDevKeys,
		KEY_SIZE*m_dwTotalFX,
		&dwBytesWritten,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to write scratch image to file %s",m_szScratchImageFileName);
		goto errExit;
		
	}

	// ************************************************************************
	// create a default command node and place it at the right offset
	// so the execution engine knows to upload all the FX and their state
	// ************************************************************************

	memset(&dspCommandBlock, 0 , sizeof(dspCommandBlock));

    dspCommandBlock.dwCommandFlags |= BIT_H2DCB_COMMAND_LOAD_CODE;
    dspCommandBlock.dwCommandFlags |= BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;
    dspCommandBlock.dwCodeLength = m_dwTotalDspCodeSize/sizeof(DWORD);	
	dspCommandBlock.dwStateOffset = dwStateBaseIndex;
    dspCommandBlock.dwStateLength = m_dwTotalDspStateSize/sizeof(DWORD);

	// ************************************************************************
	// now create an image of the scratch space and store it in the output file
	//


	//
	// move file pointer to command node offset
	//

	dwTotalSize = SetFilePointer(m_hOutputFile, DSP_COMMANDBLOCK_SCRATCHOFFSET, NULL, FILE_BEGIN);
	if (dwTotalSize == -1) {
		err = GetLastError();
		goto errExit;
	}

	//
	// write command node
	//

	bResult = WriteFile(m_hOutputFile,
		&dspCommandBlock,
		sizeof(dspCommandBlock),
		&dwBytesWritten,
		0);
    
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to write scratch image to file %s",m_szScratchImageFileName);
		goto errExit;
		
	}


errExit:

	//
	// generate the output scratch space image
	//

	if (err != ERROR_SUCCESS) {

		//
		// delete output file
		//

		DeleteFile((const char *)m_szScratchImageFileName);

	}

	if (m_hOutputFile) {
		CloseHandle(m_hOutputFile);
		m_hOutputFile = NULL;
	}


	if (pDescriptor) {
		delete [] pDescriptor;
	}

	if (pDevKeys) {
		delete [] pDevKeys;
	}


    return err;

}


DWORD CDspImageBuilder::BufferIDToDSPAddress(DWORD dwTempBinBaseIndex,DWORD dwId)
{
	DWORD dwResult = -1;
	switch (dwId & FX_BUFFERID_MASK) {
	case FXOUTPUT_GPMIXBIN_BASE:

		//
		// the mem offsets were ORed when we parsed these
		// remove the ID bit
		//

		dwResult = dwId & ~FXOUTPUT_GPMIXBIN_BASE;
		break;

	case FXINPUT_GPMIXBIN_BASE:

		//
		// the mem offsets were ORed when we parsed these
		// remove the ID bit
		//

		dwResult = dwId & ~FXINPUT_GPMIXBIN_BASE;
		break;

	case FXINPUT_VPMIXBIN_BASE:

		//
		// parsing function setup the address offset
		//

		dwResult = dwId & ~FXINPUT_VPMIXBIN_BASE;
		break;

	case FXINPUT_GPTEMPBIN_BASE:

		dwResult = dwId & ~FXINPUT_GPTEMPBIN_BASE;

		//
		// create the base XRAM address for this mixbin
		//

		dwResult = dwTempBinBaseIndex/sizeof(DWORD) + dwResult*DSP_BUFFER_FRAME_LENGTH;
		break;

	case FXOUTPUT_GPTEMPBIN_BASE:

		dwResult = dwId & ~FXOUTPUT_GPTEMPBIN_BASE;

		//
		// create the base XRAM address for this mixbin
		//

		dwResult = dwTempBinBaseIndex/sizeof(DWORD) + dwResult*DSP_BUFFER_FRAME_LENGTH;
		break;

	}

	return dwResult;

}

#define INCR_BUFFER {\
    dwSize  += strlen(pszStr);\
	pszStr  += strlen(pszStr);}


int CDspImageBuilder::CreateEnumHeader()
{

    int err = ERROR_SUCCESS;

	BOOL bResult = FALSE;
	CFxData *pCurrentFx = NULL;
    DWORD dwBytesWritten,dwSize;

	DWORD dwGraphIndex, dwFxIndex;
	DWORD j;
	
	PCHAR pszString,pBuffer,pszStr;

	DeleteFile((const char *)m_szCHeaderFileName);

    m_hOutputFile = CreateFile(
        (const char *)m_szCHeaderFileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL);

    if (m_hOutputFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        Print("\n Failed to open the generated header file.Error 0x%x\n", err);
        return err;

    }

	dwSize = SetFilePointer(m_hOutputFile,
		0,
		NULL,
		FILE_BEGIN);
	
	if (dwSize == -1) {
		err = GetLastError();
		goto errExit;
	}
	
	pszString = (PCHAR)new BYTE[MAX_FX_NAME];
	if (pszString == NULL) {
		err = ERROR_OUTOFMEMORY;
		goto errExit;
	}

	pBuffer = (PCHAR)new BYTE[MAX_FX_NAME*sizeof(DSP_STATE_FIXED)/sizeof(DWORD)];
	if (pBuffer == NULL) {
		err = ERROR_OUTOFMEMORY;
		goto errExit;
	}

	//
	// create the TYPEDEF ENUM string
	//

	sprintf(pszString,"\ntypedef enum _DSP_IMAGE_%s_FX_INDICES {\n",m_szImageFriendlyName);

	bResult = WriteFile(m_hOutputFile,
		pszString,
		strlen(pszString),
		&dwBytesWritten,
		0);
	
	if (!bResult) {
		
		err = GetLastError();
		DebugPrint(DBGLVL_ERROR,"Failed to write header file %s",m_szCHeaderFileName);
		goto errExit;
		
	}

	j = 0;

	for (dwGraphIndex=0;dwGraphIndex<m_dwGraphCount;dwGraphIndex++){
		for (dwFxIndex=0;dwFxIndex<m_pGraphs[dwGraphIndex]->GetNumEffects();dwFxIndex++){

			pCurrentFx = m_pGraphs[dwGraphIndex]->GetFxData(dwFxIndex);

			//
			// create an index for this effect
			//

			if (j == m_dwTotalFX-1) {

				CHAR string[256];

				sprintf(string,"DSP_IMAGE_%s_FX_INDICES",m_szImageFriendlyName);
				sprintf(pszString,"    %s_%s = %d\n} %s;\n",
					m_pGraphs[dwGraphIndex]->GetGraphName(),
					pCurrentFx->m_szFriendlyEffectName,
					j,
					string);

			} else {

				sprintf(pszString,"    %s_%s = %d,\n",
					m_pGraphs[dwGraphIndex]->GetGraphName(),
					pCurrentFx->m_szFriendlyEffectName,
					j);

			}

			bResult = WriteFile(m_hOutputFile,
				pszString,
				strlen(pszString),
				&dwBytesWritten,
				0);
			
			if (!bResult) {
				
				err = GetLastError();
				DebugPrint(DBGLVL_ERROR,"Failed to write header file %s",m_szCHeaderFileName);

				goto errExit;
				break;

			}
			
			j++;
		}
	}

	//
	// create a data structure for each FX state
	// it generate a data struct with the sam exact offset as DSP_STATE_FIXED
	// NOTE: YOU MUST KEEP THIS CODE IN SYNC WITH DSP_STATE_FIXED!!!!!
	//

	for (dwGraphIndex=0;dwGraphIndex<m_dwGraphCount;dwGraphIndex++){

		for (dwFxIndex=0;dwFxIndex<m_pGraphs[dwGraphIndex]->GetNumEffects();dwFxIndex++){

			pszStr = pBuffer;
			memset(pBuffer,0,MAX_FX_NAME*sizeof(DSP_STATE_FIXED)/sizeof(DWORD));
			
			dwSize = 0;

			pCurrentFx = m_pGraphs[dwGraphIndex]->GetFxData(dwFxIndex);

			sprintf(pszStr,"\ntypedef struct _%s_STATE {\n",pCurrentFx->m_szEffectName);
			INCR_BUFFER
			sprintf(pszStr,"    DWORD dwScratchOffset;        // Offset in bytes, of scratch area for this FX\n");
			INCR_BUFFER
			sprintf(pszStr,"    DWORD dwScratchLength;        // Length in DWORDS, of scratch area for this FX\n");
			INCR_BUFFER
			sprintf(pszStr,"    DWORD dwYMemoryOffset;        // Offset in DSP WORDS, of Y memory area for this FX\n");
			INCR_BUFFER
			sprintf(pszStr,"    DWORD dwYMemoryLength;        // Length in DSP WORDS, of Y memory area for this FX\n");
			INCR_BUFFER
			sprintf(pszStr,"    DWORD dwFlags;                // FX bitfield for various flags. See xgpimage documentation\n");
			INCR_BUFFER

				if (pCurrentFx->m_dwNumInputs > 0) {
					sprintf(pszStr,"    DWORD dwInMixbinPtrs[%d];      // XRAM offsets in DSP WORDS, of input mixbins\n",pCurrentFx->m_dwNumInputs);
					INCR_BUFFER
				}

				if (pCurrentFx->m_dwNumOutputs > 0) {
					sprintf(pszStr,"    DWORD dwOutMixbinPtrs[%d];     // XRAM offsets in DSP WORDS, of output mixbins\n",pCurrentFx->m_dwNumOutputs);
					INCR_BUFFER
				}

			sprintf(pszStr,"} %s_STATE, *LP%s_STATE;\n",pCurrentFx->m_szEffectName,pCurrentFx->m_szEffectName);
            INCR_BUFFER

			sprintf(pszStr,"\ntypedef const %s_STATE *LPC%s_STATE;\n",pCurrentFx->m_szEffectName,pCurrentFx->m_szEffectName);
            INCR_BUFFER

			bResult = WriteFile(m_hOutputFile,
				pBuffer,
				dwSize,
				&dwBytesWritten,
				0);
			
			if (!bResult) {
				
				err = GetLastError();
				DebugPrint(DBGLVL_ERROR,"Failed to write header file %s",m_szCHeaderFileName);

				goto errExit;
				break;

			}
			
		}
	}

errExit:
	if (pszString) {
		delete [] pszString;
	}

	if (pBuffer) {
		delete [] pBuffer;
	}

	CloseHandle(m_hOutputFile);
	m_hOutputFile = NULL;

	return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	fxparser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\parser.h ===
//
// keywords under the MAIN section
//

#define MAIN_SECTION_NAME       "MAIN"
#define GRAPH_KEY_NAME          "GRAPH"
#define FX_KEY_NAME             "FX"
#define IMAGE_FRIENDLY_NAME     "IMAGE_FRIENDLY_NAME"
#define NUM_TEMPBINS_NAME       "FX_NUMTEMPBINS"


#define MAX_TEMPBINS	256


//
// keywords in the state INI files under the FXSTATE section
//

#define FXSTATE_EFFECT_NAME         "FX_NAME"
#define FXSTATE_SECTION_NAME		"FXSTATE"

#define FXPARAM_DSPCODE_NAME	    "FX_DSPCODE"
#define FXPARAM_DSPSTATE_NAME	    "FX_DSPSTATE"
#define FXPARAM_NUMINPUTS_NAME		"FX_NUMINPUTS"
#define FXPARAM_NUMOUTPUTS_NAME     "FX_NUMOUTPUTS"

//
// definitions for Y memory. Found in *state.INI for each FX
//

#define FXPARAM_YMEMORY_SIZE        "FX_YMEMSIZE"

//
// definitions for X memory state. Found in *state.INI for each FX
//

#define FXPARAM_NUMINPUTS_NAME		        "FX_NUMINPUTS"
#define FXPARAM_NUMOUTPUTS_NAME		        "FX_NUMOUTPUTS"
#define FXPARAM_NUMPARAMS_NAME	        	"FX_NUMPARAMS"
#define FXPARAM_NUMPUBLICPARAMS_NAME	   	"FX_NUMPUBLICPARAMS"

#define FXPARAM_INPUT_NAME	     	"FX_INPUT"
#define FXPARAM_OUTPUT_NAME	     	"FX_OUTPUT"
#define FXPARAM_STATEPARAM_NAME   	"FX_PARAM"

#define FXPARAM_DSPCYCLES_NAME		"FX_DSPCYCLES"

#define FXPARAM_SCRATCH_LENGTH		"FX_SCRATCHLENGTH"

//
// entries that describe each parameter
//

#define FXPARAM_DESC_NAME          "FX_PARAM%d_NAME"
#define FXPARAM_DESC_DESCRIPTION   "FX_PARAM%d_DESCRIPTION"

#define FXPARAM_DESC_TYPE          "FX_PARAM%d_TYPE"
#define FXPARAM_DESC_UNITS         "FX_PARAM%d_UNITS"
#define FXPARAM_DESC_MIN           "FX_PARAM%d_MIN"
#define FXPARAM_DESC_MAX           "FX_PARAM%d_MAX"
#define FXPARAM_DESC_ATOMIC        "FX_PARAM%d_ATOMIC"

//
// the following params are defined in the dsp image INI file
//

#define FXFLAG_MIXOUTPUT           "FX_MIXOUTPUT"

// ****************************************************************************
// define the key words for the inputs of the first FX in a FX graph
// First define the VP mix bins
//

#define FX_BUFFERID_MASK			0xFFF00000			
#define FX_BUFFERID_BASE			0x00100000

#define NUM_VPMIXBINS 32
#define NUM_GPMIXBINS 32

#define NUM_FXSENDBINS 20

#define FXINPUT_VPMIXBIN_BASE		(FX_BUFFERID_BASE << 1)

//
// internal to the DSP final output GP mix bins
//

#define FXINPUT_GPMIXBIN_BASE		(FX_BUFFERID_BASE << 2)

//
// internal to the DSP fx routing temporary bins
//

#define FXINPUT_GPTEMPBIN_BASE		(FX_BUFFERID_BASE << 3)
#define FXINPUT_GPTEMPBIN_NAME      "GPTEMPBIN"


// ****************************************************************************
// definitions for output key words
// the namespace is the same with the FXINPUT_XXX definitions above, thus
// they need unique bit values
//


//
// GP internal mix bins as destination
//

#define FXOUTPUT_GPMIXBIN_BASE		(FX_BUFFERID_BASE << 4)

//
// GP temp bins
//

#define FXOUTPUT_GPTEMPBIN_BASE	    (FX_BUFFERID_BASE << 5)
#define FXOUTPUT_GPTEMPBIN_NAME		"GPTEMPBIN"

//
// friendly names for the VP and GPMIXBINS
//
/*
char* vpMixBinNames[32] ={

	"VPMIXBIN_FRONTLEFT",
	"VPMIXBIN_FRONTRIGHT",
	"VPMIXBIN_CENTER",
	"VPMIXBIN_LFE",
	"VPMIXBIN_BACKLEFT",
	"VPMIXBIN_BACKRIGHT",
	"VPMIXBIN_I3DL2SEND",
	"VPMIXBIN_XTLK_FL",
	"VPMIXBIN_XTLK_FR",
	"VPMIXBIN_XTLK_BL",
	"VPMIXBIN_XTLK_BR",
	"VPMIXBIN_FXSEND0",
	"VPMIXBIN_FXSEND1",
	"VPMIXBIN_FXSEND2",
	"VPMIXBIN_FXSEND3",
	"VPMIXBIN_FXSEND4",
	"VPMIXBIN_FXSEND5",
	"VPMIXBIN_FXSEND6",
	"VPMIXBIN_FXSEND7",
	"VPMIXBIN_FXSEND8",
	"VPMIXBIN_FXSEND9",
	"VPMIXBIN_FXSEND10",
	"VPMIXBIN_FXSEND11",
	"VPMIXBIN_FXSEND12",
	"VPMIXBIN_FXSEND13",
	"VPMIXBIN_FXSEND14",
	"VPMIXBIN_FXSEND15",
	"VPMIXBIN_FXSEND16",
	"VPMIXBIN_FXSEND17",
	"VPMIXBIN_FXSEND18",
	"VPMIXBIN_FXSEND19",
	"VPMIXBIN_RESERVED"
};


char* gpMixBinNames[32] ={

	"GPMIXBIN_FRONTLEFT",
	"GPMIXBIN_FRONTRIGHT",
	"GPMIXBIN_CENTER",
	"GPMIXBIN_LFE",
	"GPMIXBIN_BACKLEFT",
	"GPMIXBIN_BACKRIGHT",
	"GPMIXBIN_RESERVED",
	"GPMIXBIN_RESERVED",
	"GPMIXBIN_RESERVED",
	"GPMIXBIN_RESERVED",
	"GPMIXBIN_RESERVED",
	"GPMIXBIN_FXSEND0",
	"GPMIXBIN_FXSEND1",
	"GPMIXBIN_FXSEND2",
	"GPMIXBIN_FXSEND3",
	"GPMIXBIN_FXSEND4",
	"GPMIXBIN_FXSEND5",
	"GPMIXBIN_FXSEND6",
	"GPMIXBIN_FXSEND7",
	"GPMIXBIN_FXSEND8",
	"GPMIXBIN_FXSEND9",
	"GPMIXBIN_FXSEND10",
	"GPMIXBIN_FXSEND11",
	"GPMIXBIN_FXSEND12",
	"GPMIXBIN_FXSEND13",
	"GPMIXBIN_FXSEND14",
	"GPMIXBIN_FXSEND15",
	"GPMIXBIN_FXSEND16",
	"GPMIXBIN_FXSEND17",
	"GPMIXBIN_FXSEND18",
	"GPMIXBIN_FXSEND19",
	"GPMIXBIN_RESERVED"
};

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\main.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	main.cpp

Abstract:

	Entry point for xgpimage

Author:

	George Chrysanthakopoulos (georgic) 15-Mar-2001

Revision History:

	15-Mar-2001 georgic
		Initial Version
	04-Jun-2001	robheit
		Pulled code out of fxdspimg.cpp

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "fxdspimg.h"

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
int __cdecl main(int argc, char* argv[])
{
    int err;

    CDspImageBuilder Builder(APP_NAME);

    err = Builder.ParseCommandLine(argc,argv);
    if (err != ERROR_SUCCESS) {

        return err;

    }
    
    //
    // parse the actual file and assemble the dsp image
    //

    err = Builder.ParseInputFile();
    if (err != ERROR_SUCCESS) {
		Builder.DebugPrint(DBGLVL_ERROR,"Failed parsing input file");
        return err;
    }

    //
	// parsing complete.
	// at this point we should have Graphs created with an array of FX in each
	// the next step is to validate the FX chain and claculate the resource reqs
	//

	err = Builder.ValidateFxGraphs();
    if (err != ERROR_SUCCESS) {
		Builder.DebugPrint(DBGLVL_ERROR,"Validation of FX chains returned error");
        return err;
    }


    err = Builder.BuildDspImage();
    if (err != ERROR_SUCCESS) {
		Builder.DebugPrint(DBGLVL_ERROR,"Failed to created DSP image");
        return err;
    }

    err = Builder.CreateEnumHeader();
    if (err != ERROR_SUCCESS) {
		Builder.DebugPrint(DBGLVL_ERROR,"Failed to created C- Language enumeration header");
        return err;
    }

	if (!err) {
		Builder.DebugPrint(DBGLVL_ERROR, "%s run succesfully, scratch image generated.",APP_NAME);
	}

	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\fxdspimg.cpp ===
//
// fxdspimg.cpp 
// Parses and validates multiple DSP Audio FX chain specifications. It
// then creates a single DSP image, fixing jump points and pointers in DSP code,
// linking fx dsp routines for sequential processing.
// Does all resource allocation and fixup, providing offset maps of the final image
// to allow games to change FX parameters at runtime              
//
// Created      Author
// -------------------------------------------------------
// 3/15/2001    georgioc
//

#include "stdafx.h"
#include "..\xgpimage\fxdspimg.h"

//
// the order of the mixbins below is very important.
// it must stay in sync with the XBOX dsound mcpx driver and the mixbin
// definitions in dsound.h
//

char* vpMixBinNames[32] ={

    "VPMIXBIN_FRONTLEFT",
    "VPMIXBIN_FRONTRIGHT",
    "VPMIXBIN_CENTER",
    "VPMIXBIN_LFE",
    "VPMIXBIN_BACKLEFT",
    "VPMIXBIN_BACKRIGHT",
    "VPMIXBIN_XTLK_FL",
    "VPMIXBIN_XTLK_FR",
    "VPMIXBIN_XTLK_BL",
    "VPMIXBIN_XTLK_BR",
    "VPMIXBIN_I3DL2SEND",
    "VPMIXBIN_FXSEND0",
    "VPMIXBIN_FXSEND1",
    "VPMIXBIN_FXSEND2",
    "VPMIXBIN_FXSEND3",
    "VPMIXBIN_FXSEND4",
    "VPMIXBIN_FXSEND5",
    "VPMIXBIN_FXSEND6",
    "VPMIXBIN_FXSEND7",
    "VPMIXBIN_FXSEND8",
    "VPMIXBIN_FXSEND9",
    "VPMIXBIN_FXSEND10",
    "VPMIXBIN_FXSEND11",
    "VPMIXBIN_FXSEND12",
    "VPMIXBIN_FXSEND13",
    "VPMIXBIN_FXSEND14",
    "VPMIXBIN_FXSEND15",
    "VPMIXBIN_FXSEND16",
    "VPMIXBIN_FXSEND17",
    "VPMIXBIN_FXSEND18",
    "VPMIXBIN_FXSEND19",
    "VPMIXBIN_RESERVED"
};


char* gpMixBinNames[32] ={

    "GPMIXBIN_FRONTLEFT",
    "GPMIXBIN_FRONTRIGHT",
    "GPMIXBIN_CENTER",
    "GPMIXBIN_LFE",
    "GPMIXBIN_BACKLEFT",
    "GPMIXBIN_BACKRIGHT",
    "GPMIXBIN_XTLK_FL",
    "GPMIXBIN_XTLK_FR",
    "GPMIXBIN_XTLK_BL",
    "GPMIXBIN_XTLK_BR",
    "GPMIXBIN_I3DL2SEND",
    "GPMIXBIN_FXSEND0",
    "GPMIXBIN_FXSEND1",
    "GPMIXBIN_FXSEND2",
    "GPMIXBIN_FXSEND3",
    "GPMIXBIN_FXSEND4",
    "GPMIXBIN_FXSEND5",
    "GPMIXBIN_FXSEND6",
    "GPMIXBIN_FXSEND7",
    "GPMIXBIN_FXSEND8",
    "GPMIXBIN_FXSEND9",
    "GPMIXBIN_FXSEND10",
    "GPMIXBIN_FXSEND11",
    "GPMIXBIN_FXSEND12",
    "GPMIXBIN_FXSEND13",
    "GPMIXBIN_FXSEND14",
    "GPMIXBIN_FXSEND15",
    "GPMIXBIN_FXSEND16",
    "GPMIXBIN_FXSEND17",
    "GPMIXBIN_FXSEND18",
    "GPMIXBIN_FXSEND19",
    "GPMIXBIN_RESERVED"
};


CDspImageBuilder::CDspImageBuilder(char* AppName)
{
    memcpy(m_szAppName,AppName,sizeof(m_szAppName));

    memset(m_aTempBins,0,sizeof(m_aTempBins));
    m_hInputFile = NULL;
    m_hOutputFile = NULL;
    m_dwGraphCount = 0;
    m_dwDebugLevel = DBGLVL_WARN;

    m_dwTotalScratchSize = 0;
    m_dwTotalDspCodeSize = sizeof(DWORD); //add a word for the RTS we add;
    m_dwTotalDspStateSize = 0;
    m_dwTotalDspCyclesUsed = 0;
    m_dwTotalDspYMemSize = 0;

    m_dwTotalFX = 0;

    m_dwNumTempBins = 0;

    // Clear the path names
    SetIniPath(NULL);
    SetDspCodePath(NULL);
}

CDspImageBuilder::~CDspImageBuilder()
{
    if (m_hInputFile != NULL) {
        CloseHandle(m_hInputFile);
    }

    if (m_hOutputFile != NULL) {
        CloseHandle(m_hOutputFile);
    }

    for (ULONG i=0;i<m_dwGraphCount;i++){

        if (m_pGraphs[i]) {
            delete m_pGraphs[i];
        }

    }
}


int CDspImageBuilder::ParseCommandLine(int argc, char **argv)
{

    int err = ERROR_SUCCESS;
	TCHAR	buffer[1024];
	HKEY	hKey;
	DWORD	type;
	DWORD	size;

    if (argc < 3) {

        err = -1;
        UsageFailure(err);
        return err;
    }

    if (strstr("?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
        err = -1;
        return err;
    }

    if (strstr("/?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
        err = -1;
        return err;
    }

    if (strstr("-?",argv[1])) {
        UsageFailure(ERROR_SUCCESS);
        err = -1;
        return err;
    }


    //
    // create full path name for main INI
    //

    LPTSTR pBuffer;

    if (GetFullPathName(argv[1],
        sizeof(m_szDspDataFileName),
        m_szDspDataFileName,        
        &pBuffer)== 0){


        err = GetLastError();
        Print("\n Failed to find the dsp image INI file.Error 0x%x\n", err);
        return err;

    }

    printf("\nInput File to parse: %s\n", m_szDspDataFileName);

    PVOID lpvEnvBlock = GetEnvironmentStrings();

    // If the paths have not been specified through the api
    // retrieve any enviroment variables
    // they are optional and if they are not present the author of
    // INI file must provide fully qualified paths for the state ini
    // and the code files
    if (strlen(m_szIniPath) == 0)
        GetEnvironmentVariable(ENV_VAR_INI_PATH, m_szIniPath, sizeof(m_szIniPath));

    if (strlen(m_szDspCodePath) == 0)
        GetEnvironmentVariable(ENV_VAR_DSP_CODE_PATH, m_szDspCodePath, sizeof(m_szDspCodePath));

	// Then try XDK install path
    if (strlen(m_szIniPath) == 0)
	{
       if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\XboxSDK\\", 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
                        &hKey) == ERROR_SUCCESS)
		{
           size = sizeof(buffer);
           if(RegQueryValueEx(hKey,"InstallPath", NULL, 
               &type,(unsigned char*)buffer,
               &size) == ERROR_SUCCESS)
           {
               memcpy(m_szIniPath,buffer,sizeof(m_szIniPath));
               strcat(m_szIniPath,"\\source\\dsound\\dsp\\ini");
           }
           RegCloseKey(hKey);
		}
	}

    if (strlen(m_szDspCodePath) == 0)
	{
       if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\XboxSDK\\", 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
                        &hKey) == ERROR_SUCCESS)
		{
           size = sizeof(buffer);
           if(RegQueryValueEx(hKey,"InstallPath", NULL, 
               &type,(unsigned char*)buffer,
               &size) == ERROR_SUCCESS)
           {
               memcpy(m_szDspCodePath,buffer,sizeof(m_szDspCodePath));
               strcat(m_szDspCodePath,"\\source\\dsound\\dsp\\bin");
           }
			RegCloseKey(hKey);
		}
	}

    memcpy(m_szCHeaderFileName,argv[3],sizeof(m_szCHeaderFileName));
    printf("Header File to generate: %s\n", m_szCHeaderFileName);

    memcpy(m_szScratchImageFileName,argv[2],sizeof(m_szScratchImageFileName));
    printf("Output File: %s\n\n", m_szScratchImageFileName);
    
    m_hInputFile = CreateFile(
        (const char *)m_szDspDataFileName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_ALWAYS,
        0,
        NULL);

    if (m_hInputFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        Print("\n Failed to open the dsp image file.Error 0x%x\n", err);
        return err;

    }

    //
    // we dont need the input file anymore
    //

    CloseHandle(m_hInputFile);
    m_hInputFile = NULL;

    return ERROR_SUCCESS;

}


void CDspImageBuilder::UsageFailure(int err)
{
    if (err != ERROR_SUCCESS) {
        Print("\n Error: 0x%x\n", err);
    }

    Print("\n Usage: %s [FX description INI filename] [scratch image output filename] [generated C header]\n",
          m_szAppName);

}


int CDspImageBuilder::ErrorCheckOnParser(PCHAR pResult, PCHAR pDefault,DWORD dwBytesRead, DWORD dwSize)
{

    if (dwBytesRead == dwSize-1) {
        
        
        DebugPrint(DBGLVL_INFO,"Parsing error, GetProfile function thought our buffer is too small!!");
        return -1;
        
    }
    
    if (dwBytesRead == dwSize-2) {        
        
        DebugPrint(DBGLVL_INFO,"Parsing error, GetProfile function thought our buffer is too small!!");
        return -1;
        
    }

    if (dwBytesRead == 0) {

        DebugPrint(DBGLVL_INFO,"Parsing error, GetProfile function returned 0 bytes");

    }

    if (!strcmp(pResult,pDefault)) {


        return -1;

    }


    return ERROR_SUCCESS;

}

void CDspImageBuilder::DebugPrint(DWORD dwLevel, PCHAR pszFormat, ...)
{
    CHAR                    szString[0x400];
    va_list                 va;

    va_start(va, pszFormat);
    vsprintf(szString, pszFormat, va);
    va_end(va);
    
    if (m_dwDebugLevel >= dwLevel) {
        
        Print("*** %s ***\n", szString);
    }

}


void CDspImageBuilder::PrintParsingError(PCHAR pSection, PCHAR pKey, PCHAR pszFormat, ...)
{
    CHAR                    szString[0x400];
    va_list                 va;

    va_start(va, pszFormat);
    vsprintf(szString, pszFormat, va);
    va_end(va);
    
    Print("*** ParsingInputFile : SectionName %s, KeyName %s.\n"\
                   "    %s\n",
                   pSection,pKey,szString);

}

void CDspImageBuilder::PrintValidationError(DWORD dwDebugLevel, DWORD dwGraphIndex, DWORD dwFxIndex, PCHAR pszFormat, ...)
{
    CHAR                    szString[0x400];
    va_list                 va;

    va_start(va, pszFormat);
    vsprintf(szString, pszFormat, va);
    va_end(va);

    if (dwDebugLevel == DBGLVL_ERROR) {

        Print("*** Validating FX graphs : Error in GraphIndex %d, FxIndex %d.\n"\
            "    %s\n",
            dwGraphIndex,dwFxIndex,szString);

    } else {

        Print("*** Validating FX graphs : Warning in GraphIndex %d, FxIndex %d.\n"\
            "    %s\n",
            dwGraphIndex,dwFxIndex,szString);

    }


}

#define SECTION_MAX_SIZE 4096

int CDspImageBuilder::ParseInputFile()
{
    int err = ERROR_SUCCESS;
    DWORD dwBytesRead;
    DWORD dwValue = 0;
    DWORD i=0;

    LPCTSTR lpDefault = "DefaultString";
    LPSTR lpSectionName;
    LPSTR lpKeyName;
    PCHAR lpResult;

    CHAR szGraphName[256];

    CFxData *pFxData;
    CFxGraph *pGraph;

    lpResult = new CHAR[SECTION_MAX_SIZE];
    if (lpResult == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    lpSectionName = new CHAR[MAX_FX_NAME];
    if (lpSectionName == NULL) {
        
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    lpKeyName = new CHAR[MAX_FX_NAME];
    if (lpKeyName == NULL) {
        err = ERROR_OUTOFMEMORY;
        goto errorExit;
    }

    sprintf(lpSectionName,"%s",MAIN_SECTION_NAME);       

    //
    // see if the main section exists
    //
    
    dwBytesRead = GetPrivateProfileSection(lpSectionName,
        lpResult,
        SECTION_MAX_SIZE,
        (const char*)m_szDspDataFileName);
    
    if (!dwBytesRead) {
        
        PrintParsingError(lpSectionName,
            NULL,
            "FATAL: main section not found!");              
        
        return -1;
        
    }

    // **************************************************
    // read a friendlyname for this image
    // **************************************************

    sprintf(lpSectionName,"%s",MAIN_SECTION_NAME);       
    sprintf(lpKeyName,"%s",IMAGE_FRIENDLY_NAME);
    dwBytesRead = GetPrivateProfileString(lpSectionName,
        lpKeyName,
        lpDefault,
        (char *)m_szImageFriendlyName,
        MAX_FX_NAME,
        (const char*)m_szDspDataFileName);
    
    if (ErrorCheckOnParser((char *)m_szImageFriendlyName,(char*)lpDefault,dwBytesRead,MAX_FX_NAME)) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "WARNING: Key not found.");             

        sprintf(m_szImageFriendlyName,"DEFAULT");
        
    }

    // **************************************************
    // read max number of temporary bins used for routing
    // **************************************************

    sprintf(lpSectionName,"%s",MAIN_SECTION_NAME);       
    sprintf(lpKeyName,"%s",NUM_TEMPBINS_NAME);

    dwValue = GetPrivateProfileInt(lpSectionName,
        lpKeyName,
        -1,
        (const char*)m_szDspDataFileName);  
    
    if (dwValue == -1) {
        
        PrintParsingError(lpSectionName,
            lpKeyName,
            "WARNING: Key not found.");             

    } else {

        m_dwNumTempBins = dwValue;

    }
    
    //
    // graph enumeration loop
    //

    while (m_dwGraphCount < MAX_GRAPHS) {

        sprintf(lpSectionName,"%s",MAIN_SECTION_NAME);       
        sprintf(lpKeyName,"%s%d",GRAPH_KEY_NAME,m_dwGraphCount);
        dwBytesRead = GetPrivateProfileString(lpSectionName,
            lpKeyName,
            lpDefault,
            szGraphName,
            MAX_FX_NAME,
            (const char*)m_szDspDataFileName);
        
        if (ErrorCheckOnParser(szGraphName,(char*)lpDefault,dwBytesRead,MAX_FX_NAME)) {
            
            if (m_dwGraphCount == 0) {

                PrintParsingError(lpSectionName,
                lpKeyName,
                "ERROR: No Graph keys found!");             
                err = -1;
            
            }

            break;
            
        }

        //
        // Create a new Graph class that will contain a chain of FX
        // Then enter the FX enumeration loop that will find all the FX associated with
        // this graph section
        //

        pGraph= new CFxGraph();
        if (pGraph == NULL) {
            
            return ERROR_OUTOFMEMORY;
            
        }

        //
        // save the graph name
        //

        pGraph->SetGraphName(szGraphName);

        m_pGraphs[m_dwGraphCount++] = pGraph;

        //
        // check that no duplicate graph names have been specified
        //

        for (i=0;i<m_dwGraphCount-1;i++) {
            if (!strcmp(szGraphName,m_pGraphs[i]->GetGraphName())){

                //
                // duplicate name found
                //
                
                PrintParsingError(lpSectionName,
                    lpKeyName,
                    "FATAL: Duplicate Graph Names not allowed.");               
                return -1;

            }
        }

        while (pGraph->GetNumEffects() < MAX_FX_PER_GRAPH) {

            sprintf(lpSectionName,"%s",szGraphName);       
            sprintf(lpKeyName,"%s%d",FX_KEY_NAME,pGraph->GetNumEffects());
            dwBytesRead = GetPrivateProfileString(lpSectionName,
                lpKeyName,
                lpDefault,
                lpResult,
                MAX_FX_NAME,
                (const char*)m_szDspDataFileName);

            if (ErrorCheckOnParser(lpResult,(char*)lpDefault,dwBytesRead,MAX_FX_NAME)) {

                break;

            }

            //
            // we found a section for an effect in a graph.
            // now read the effect parameters from the FX section
            //

            pFxData = new CFxData();
            if (pFxData == NULL) {

                err = ERROR_OUTOFMEMORY;
                goto errorExit;

            }

            //
            // Add fx to graph. This will increment the total number of FX in
            // this graph instance
            //

            pGraph->SetFx(pFxData);

            // ****************************************************************
            // create FX subsection name
            // ****************************************************************

            sprintf(lpSectionName,"%s_FX%d_%s",
                szGraphName,
                pGraph->GetNumEffects()-1,
                lpResult);

            //
            // save the friendly FX name.
            //

            memcpy(pFxData->m_szFriendlyEffectName,lpResult,sizeof(pFxData->m_szFriendlyEffectName));

            dwBytesRead = GetPrivateProfileSection(lpSectionName,
                lpResult,
                SECTION_MAX_SIZE,
                (const char*)m_szDspDataFileName);
            
            if (!dwBytesRead) {
                
                PrintParsingError(lpSectionName,
                    lpKeyName,
                    "FATAL: FX section not found!");                
                
                return -1;
                
            }

            //
            // save the FX name.
            //

            memcpy(pFxData->m_szEffectName,lpSectionName,sizeof(pFxData->m_szEffectName));

            //
            // check real quick that no other FX in this graph has used the same name
            //

            for (i=0;i<pGraph->GetNumEffects()-1;i++) {

                CFxData *pFx = pGraph->GetFxData(i);
                if (!strcmp(pFx->m_szFriendlyEffectName,pFxData->m_szFriendlyEffectName)) {

                    //
                    // duplicate name found
                    //

                    PrintParsingError(lpSectionName,
                    lpKeyName,
                    "FATAL: Duplicate FX Names not allowed within a graph.");               
                    return -1;
                }
            }

            //
            // read the FX Dsp code filename
            //

            sprintf(lpKeyName,"%s", FXPARAM_DSPCODE_NAME);
            dwBytesRead = GetPrivateProfileString(lpSectionName,
                lpKeyName,
                lpDefault,
                lpResult,
                MAX_FX_NAME,
                (const char*)m_szDspDataFileName);
            
            if (ErrorCheckOnParser(lpResult,(char*)lpDefault,dwBytesRead,MAX_FX_NAME)) {
                
                PrintParsingError(lpSectionName,
                    lpKeyName,
                    "FATAL: FX dsp code filename not found");
                
                err = -1;
                goto errorExit;
                
            }
            
            //
            // if there is an environment variable for dsp code path
            // use it and assume a non qualified name was passed in the INI
            //

            if (m_szDspCodePath[0] !=0 ) {

                sprintf(pFxData->m_szDspCodeFileName,
                    "%s\\%s",
                    m_szDspCodePath,
                    lpResult);
            } else {

                memcpy(pFxData->m_szDspCodeFileName,
                    lpResult,
                    sizeof(pFxData->m_szDspCodeFileName));

            }

            //
            // read the FX Dsp STATE filename
            //

            sprintf(lpKeyName,"%s", FXPARAM_DSPSTATE_NAME);
            dwBytesRead = GetPrivateProfileString(lpSectionName,
                lpKeyName,
                lpDefault,
                lpResult,
                MAX_FX_NAME,
                (const char*)m_szDspDataFileName);
            
            if (ErrorCheckOnParser(lpResult,(char*)lpDefault,dwBytesRead,MAX_FX_NAME)) {
                
                PrintParsingError(lpSectionName,
                    lpKeyName,
                    "FATAL: FX dsp code filename not found");
                
                err = -1;
                goto errorExit;
                
            }

            //
            // if there was an environment variable specified, assume that the
            // the core INI file had an unqualified name. Make it into a full pathname here
            //
            
            if (m_szIniPath[0] != 0) {
                
                sprintf(pFxData->m_szDspStateFileName,
                    "%s\\%s",
                    m_szIniPath,
                    lpResult);
                
            } else {
                
                memcpy(pFxData->m_szDspStateFileName,lpResult,sizeof(pFxData->m_szDspStateFileName));
                
            }            

            // ****************************************************************
            // read number of inputs from the appropriate FX section under this graph
            // ****************************************************************

            err = ParseInputs(lpSectionName,pFxData);

            if (err != ERROR_SUCCESS) {
                return err;
            }

            // ****************************************************************
            // read number of outputs
            // ****************************************************************

            err = ParseOutputs(lpSectionName, pFxData);

            if (err != ERROR_SUCCESS) {
                return err;
            }

            // ****************************************************************
            // read number of state parameters
            // ****************************************************************
            // NOTE!!! parsing order is important since we must know the number of inputs
            // and number of outputs before trying to allocate a state parameter buffer         

            err = ParseStateParameters(lpSectionName, pFxData);

            if (err != ERROR_SUCCESS) {
                return err;
            }

            // ****************************************************************
            // create parameter descriptions
            // ****************************************************************

            err = ParseParameterDescriptions(pFxData->m_szDspStateFileName, &pFxData->m_pEffectStateParameters);

            if (err != ERROR_SUCCESS) {
                return err;
            }

            // ****************************************************************
            // determine if this FX overwrites its output. This must be done 
            // after parsing state
            // ****************************************************************
            
            sprintf(lpKeyName,"%s",FXFLAG_MIXOUTPUT);
            dwValue = GetPrivateProfileInt(lpSectionName,
                lpKeyName,
                -1,
                (const char*)m_szDspDataFileName);  
            
            if (dwValue == -1) {
                
                PrintParsingError(lpSectionName,
                    lpKeyName,
                    "WARNING: Key not found");              
                
            } else {
            
                //
                // Check : Make sure they pass a valid value for FXPARAM_MIXOUTPUT
                //
                
                if ((dwValue != 0) && (dwValue !=1) ) {
                    
                    PrintParsingError(lpSectionName,
                        lpKeyName,
                        "Invalid value specified for FXPARAM_MIXOUTPUT: Only 0 or 1 is valid");
                    
                    return -1;
                }
                
                ((PDSP_STATE_FIXED)pFxData->m_pDspState)->dwFlags |= (dwValue << BIT_FX_STATE_FLAG_GLOBAL_FX);
            
            }


            //
            // increment count of FX
            //

            m_dwTotalFX++;

        };//FX subloop

    }; //FX graph subloop

    DebugPrint(DBGLVL_ERROR,"Enumerated %d graph(s) and %d effect(s) total",
        m_dwGraphCount,
        m_dwTotalFX);


errorExit:

    if (lpResult) {
        delete [] lpResult;
    }

    if (lpKeyName) {
        delete [] lpKeyName;
    }

    if (lpSectionName) {
        delete [] lpSectionName;
    }

    return err;
}

int CDspImageBuilder::ParseParameterDescriptions(const char *pFileName, PFX_STATE_PARAMETERS *ppStateParams)
{
    int err = ERROR_SUCCESS;
    CHAR szKeyName[256];
    CHAR szSectionName[256];
    CHAR szDefault[256] = "DefaultString";
    CHAR szResult[256];

    DWORD dwValue, dwBytesRead;
    PFX_STATE_PARAMETERS pStateParams; 

    *ppStateParams = NULL;

    //
    // retrieve number of parameters
    //

    sprintf(szKeyName,"%s",FXPARAM_NUMPARAMS_NAME);
    sprintf(szSectionName,"%s",FXSTATE_SECTION_NAME);

    dwValue = GetPrivateProfileInt(szSectionName,
        szKeyName,
        -1,
        pFileName); 
    
    if (dwValue == -1) {
        
        PrintParsingError(szSectionName,
            szKeyName,
            "FATAL: Key not found or file %s not present",
            pFileName
            );              
        
        return -1;
    }
    
    DWORD dwNumParams = dwValue;

    sprintf(szKeyName,"%s",FXPARAM_NUMPUBLICPARAMS_NAME);
    sprintf(szSectionName,"%s",FXSTATE_SECTION_NAME);

    dwValue = GetPrivateProfileInt(szSectionName,
        szKeyName,
        -1,
        pFileName); 
    
    if (dwValue == -1) {
        
        PrintParsingError(szSectionName,
            szKeyName,
            "FATAL: Key not found or file %s not present",
            pFileName
            );              
        
        return -1;
    }
    
    //
    // allocate array that will hold parameter descriptions
    //

    PBYTE pBuffer;
    pBuffer = new BYTE[sizeof(FX_PARAM_DESCRIPTION)*(dwValue-1) + sizeof(FX_STATE_PARAMETERS)];
    if (pBuffer == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    pStateParams = (PFX_STATE_PARAMETERS)pBuffer;
    pStateParams->dwNumParams = dwValue;

    //
    // retrieve Effect name
    //

    sprintf(szKeyName,"%s",FXSTATE_EFFECT_NAME);
    sprintf(szSectionName,"%s",FXSTATE_SECTION_NAME);

    dwBytesRead = GetPrivateProfileString(szSectionName,
        szKeyName,
        szDefault,
        szResult,
        MAX_FX_NAME,
        pFileName);
    
    if (ErrorCheckOnParser(szResult,(char*)szDefault,dwBytesRead,MAX_FX_NAME)) {
        
        PrintParsingError(szSectionName,
            szKeyName,
            "FATAL: Parsing %s file. Key not specified correctly or not present", pFileName);
        
        return -1;
        
    }

    memcpy(pStateParams->EffectName,szResult,sizeof(pStateParams->EffectName));

    // ****************************************************************
    // read all parameter values
    // ****************************************************************
    
    DWORD count = 0, dwIndex = 0;
    while (count < dwNumParams) {
        
        //
        // now retrieve information for each parameter..
        //

        //
        // Parameter name
        // if this key does not exist this is not an exposed parameter, thus
        // we ignore it and move on
        //

        sprintf(szKeyName,FXPARAM_DESC_NAME,count);        
        dwBytesRead = GetPrivateProfileString(szSectionName,
            szKeyName,
            szDefault,
            szResult,
            MAX_FX_NAME,
            pFileName);
        
        if (ErrorCheckOnParser(szResult,(char*)szDefault,dwBytesRead,MAX_FX_NAME)) {
            
            count++;
            continue;
                        
        }

        memcpy(pStateParams->aParamDescriptions[dwIndex].ParameterName,
            szResult,
            sizeof(pStateParams->aParamDescriptions[dwIndex].ParameterName));

        // Min
        sprintf(szKeyName,FXPARAM_DESC_MIN,count);
        dwValue = GetPrivateProfileInt(szSectionName,
            szKeyName,
            -1,
            pFileName);         
        if (dwValue == -1) {
                        
            break;
        }
        pStateParams->aParamDescriptions[dwIndex].dwParameterMin = dwValue;

        // Max
        sprintf(szKeyName,FXPARAM_DESC_MAX,count);
        dwValue = GetPrivateProfileInt(szSectionName,
            szKeyName,
            -1,
            pFileName); 
        
        if (dwValue == -1) {
                        
            break;
        }
        pStateParams->aParamDescriptions[dwIndex].dwParameterMax = dwValue;

        // default value
        sprintf(szKeyName,"%s%d",FXPARAM_STATEPARAM_NAME,count);
        dwValue = GetPrivateProfileInt(szSectionName,
            szKeyName,
            -1,
            pFileName);    
        
        if (dwValue == -1) {
                        
            break;
        }
        pStateParams->aParamDescriptions[dwIndex].dwDefaultValue = dwValue;

        // parameter type
        sprintf(szKeyName,FXPARAM_DESC_TYPE,count);        
        dwBytesRead = GetPrivateProfileString(szSectionName,
            szKeyName,
            szDefault,
            szResult,
            MAX_FX_NAME,
            pFileName);
        
        if (ErrorCheckOnParser(szResult,(char*)szDefault,dwBytesRead,MAX_FX_NAME)) {
            
            PrintParsingError(szSectionName,
                szKeyName,
                "FATAL: Parsing %s file. Key not specified correctly or not present", pFileName);
            
            return -1;
            
        }
        
        if (strstr(szResult,"FLOAT")) {
            pStateParams->aParamDescriptions[dwIndex].dwParameterType = DSFX_PARAM_TYPE_FLOAT;
        } else if(strstr(szResult,"INTEGER")) {
            pStateParams->aParamDescriptions[dwIndex].dwParameterType = DSFX_PARAM_TYPE_INTEGER;
        } else {
            PrintParsingError(szSectionName,
                szKeyName,
                "FATAL: Parsing %s file. Key value not valid. FLOAT or INTEGER are valid only", pFileName);
            return -1;
        }

        // Units name
        sprintf(szKeyName,FXPARAM_DESC_UNITS,count);        
        dwBytesRead = GetPrivateProfileString(szSectionName,
            szKeyName,
            szDefault,
            szResult,
            MAX_FX_NAME,
            pFileName);
        
        if (ErrorCheckOnParser(szResult,(char*)szDefault,dwBytesRead,MAX_FX_NAME)) {
            
            PrintParsingError(szSectionName,
                szKeyName,
                "FATAL: Parsing %s file. Key not specified correctly or not present", pFileName);
            
            return -1;
            
        }

        memcpy(pStateParams->aParamDescriptions[dwIndex].UnitsName,
            szResult,
            sizeof(pStateParams->aParamDescriptions[dwIndex].UnitsName));

        // Description
        sprintf(szKeyName,FXPARAM_DESC_DESCRIPTION,count);        
        dwBytesRead = GetPrivateProfileString(szSectionName,
            szKeyName,
            szDefault,
            szResult,
            MAX_FX_NAME,
            pFileName);
        
        if (ErrorCheckOnParser(szResult,(char*)szDefault,dwBytesRead,MAX_FX_NAME)) {
            
            //
            // this parameter is optional
            //

            memset(pStateParams->aParamDescriptions[dwIndex].ParameterDesc,
                0,
                sizeof(pStateParams->aParamDescriptions[dwIndex].ParameterDesc));        
            
        } else {

            memcpy(pStateParams->aParamDescriptions[dwIndex].ParameterDesc,
                szResult,
                sizeof(pStateParams->aParamDescriptions[dwIndex].ParameterDesc));        

        }

        // atomic
        sprintf(szKeyName,FXPARAM_DESC_ATOMIC,count);
        dwValue = GetPrivateProfileInt(szSectionName,
            szKeyName,
            -1,
            pFileName);    
        
        if (dwValue == -1) {
                        
            break;
        }
        pStateParams->aParamDescriptions[dwIndex].bIsAtomic = dwValue;

        //
        // keep track of the offset into the state block of this parameter
        //

        pStateParams->aParamDescriptions[dwIndex].dwOffset = count;

        dwIndex++;
        count++;
        
    } // FX state parameter enumeration subloop
    
    //
    // update numner of public parameters we found
    //

    pStateParams->dwNumParams = dwIndex;

    *ppStateParams = pStateParams;
    return err;
}

int CDspImageBuilder::ParseStateParameters(PCHAR pFxName, CFxData *pFxData)
{
    int err = ERROR_SUCCESS;
    CHAR szKeyName[256];
    CHAR szSectionName[256];
    CHAR szDefault[256] = "DefaultString";

    DWORD dwValue;

    //
    // the state parameters are stored in a different file
    // each FX must specify a stateXXX.ini file that contains the
    // the state variable definitions
    //
    
    //
    // retrieve NUMINPUTS key
    //

    sprintf(szKeyName,"%s",FXPARAM_NUMINPUTS_NAME);
    sprintf(szSectionName,"%s",FXSTATE_SECTION_NAME);

    dwValue = GetPrivateProfileInt(szSectionName,
        szKeyName,
        -1,
        (const char*)pFxData->m_szDspStateFileName);    
    
    if (dwValue == -1) {
        
        PrintParsingError(pFxName,
            szKeyName,
            "FATAL: Parsing %s file.Key not found",             
            pFxData->m_szDspStateFileName);

        
        return -1;
    }

    //
    // make sure the numinputs we parsed earlier vs the num inputs
    // the DSP developer said this FX has, is the same
    //

    if (dwValue != pFxData->m_dwNumInputs) {

        PrintParsingError(pFxName,
            szKeyName,
            "FATAL: FX Description has a different number of inputs than FX %s requires",
            pFxData->m_szEffectName
            );              

        return -1;
    }

    //
    // retrieve NUMOUTPUTS key
    //

    sprintf(szKeyName,"%s",FXPARAM_NUMOUTPUTS_NAME);
    sprintf(szSectionName,"%s",FXSTATE_SECTION_NAME);

    dwValue = GetPrivateProfileInt(szSectionName,
        szKeyName,
        -1,
        (const char*)pFxData->m_szDspStateFileName);    
    
    if (dwValue == -1) {
        
        PrintParsingError(pFxName,
            szKeyName,
            "FATAL: Parsing %s file.Key not found",             
            pFxData->m_szDspStateFileName);
        
        return -1;
    }

    //
    // make sure the numinputs we parsed earlier vs the num inputs
    // the DSP developer said this FX has, is the same
    //

    if (dwValue != pFxData->m_dwNumOutputs) {

        PrintParsingError(pFxName,
            szKeyName,
            "FATAL: FX Description has a different number of outputs than FX %s requires",
            pFxData->m_szEffectName
            );              

        return -1;
    }

    //
    // the FX state memory is the size of the parameter words they specifed plus
    // one dsp word for each input/output ID plus extra dwords to describe scratch space usage.
    //

    //
    // retrieve NUMPARAMS key
    //

    sprintf(szKeyName,"%s",FXPARAM_NUMPARAMS_NAME);
    sprintf(szSectionName,"%s",FXSTATE_SECTION_NAME);

    dwValue = GetPrivateProfileInt(szSectionName,
        szKeyName,
        -1,
        (const char*)pFxData->m_szDspStateFileName);    
    
    if (dwValue == -1) {
        
        PrintParsingError(pFxName,
            szKeyName,
            "FATAL: Key not found or file %s not present",
            pFxData->m_szDspStateFileName
            );              
        
        return -1;
    }

    pFxData->m_dwNumParams = dwValue;
    pFxData->m_dwDspStateSize = pFxData->CalcStateSize();
    
    //
    // allocate Dsp state buffer
    //
    
    pFxData->m_pDspState = (DWORD*) new BYTE[pFxData->m_dwDspStateSize];
    if (pFxData->m_pDspState == NULL) {
        return ERROR_OUTOFMEMORY;
    }
    
    memset(pFxData->m_pDspState,0,pFxData->m_dwDspStateSize);

    // ****************************************************************
    // read DSP scratch offset length used by this FX
    // ****************************************************************
    
    sprintf(szKeyName,"%s",FXPARAM_SCRATCH_LENGTH);
    
    dwValue = GetPrivateProfileInt(szSectionName,
        szKeyName,
        -1,
        (const char*)pFxData->m_szDspStateFileName);    
    
    if (dwValue == -1) {
        
        PrintParsingError(szSectionName,
            szKeyName,
            "Key not found");               
        
        return -1;
    }
    
    ((PDSP_STATE_FIXED)pFxData->m_pDspState)->dwScratchLength = dwValue;            

    // ****************************************************************
    // read DSP Y memory size used by this FX
    // ****************************************************************

    sprintf(szKeyName,"%s",FXPARAM_YMEMORY_SIZE);
    
    dwValue = GetPrivateProfileInt(szSectionName,
        szKeyName,
        -1,
        (const char*)pFxData->m_szDspStateFileName);    
    
    if (dwValue == -1) {
        
        PrintParsingError(szSectionName,
            szKeyName,
            "Key not found");               
        
        return -1;
    }

    ((PDSP_STATE_FIXED)pFxData->m_pDspState)->dwYMemLength = dwValue;

    // ****************************************************************
    // read DSP cycles used by this FX
    // ****************************************************************
    
    sprintf(szKeyName,"%s",FXPARAM_DSPCYCLES_NAME);
    
    dwValue = GetPrivateProfileInt(szSectionName,
        szKeyName,
        -1,
        (const char*)pFxData->m_szDspStateFileName);    
    
    if (dwValue == -1) {
        
        PrintParsingError(szSectionName,
            szKeyName,
            "FATAL: Key not found");                
        
        return -1;
    }
    
    pFxData->m_dwDspCyclesUsed = dwValue;   

    // ****************************************************************
    // read all parameter values
    // ****************************************************************
    
    DWORD count = 0;
    while (count < pFxData->m_dwNumParams) {
        
        //
        // we expect keys for each input..
        //
        
        sprintf(szKeyName,"%s%d",FXPARAM_STATEPARAM_NAME,count);

        dwValue = GetPrivateProfileInt(szSectionName,
            szKeyName,
            -1,
            (const char*)pFxData->m_szDspStateFileName);    
        
        if (dwValue == -1) {
                        
            break;
        }
        
        DWORD offset = pFxData->GetParamOffset();
        pFxData->m_pDspState[count+offset] = dwValue;
        
        count++;
        
    } // FX state parameter enumeration subloop
    

    return err;
}

//*****************************************************************************

int CDspImageBuilder::ParseOutputs(PCHAR pFxName, CFxData *pFxData)
{

    CHAR szKeyName[64];
    CHAR szDefault [256] = "DefaultString";
    CHAR szResult[256];

    DWORD dwValue, dwBytesRead;

    //
    // retrieve number of outputs
    //

    sprintf(szKeyName,"%s",FXPARAM_NUMOUTPUTS_NAME);
    
    dwValue = GetPrivateProfileInt(pFxName,
        szKeyName,
        -1,
        (const char*)m_szDspDataFileName);
    
    
    if (dwValue == -1) {
        
        PrintParsingError(pFxName,
            szKeyName,
            "FATAL: Key (%s) not found",
            FXPARAM_NUMINPUTS_NAME);                
        
        return -1;
        
    }
    
    pFxData->m_dwNumOutputs = dwValue;
    
    // ****************************************************************
    // read input names...
    // ****************************************************************
    
    DWORD count = 0;
    while (count < pFxData->m_dwNumOutputs+1) {
        
        //
        // we expect keys for each input..
        //
        
        sprintf(szKeyName,"%s%d",FXPARAM_OUTPUT_NAME,count);
        dwBytesRead = GetPrivateProfileString(pFxName,
            szKeyName,
            szDefault,
            szResult,
            MAX_FX_NAME,
            (const char*)m_szDspDataFileName);
        
        if (ErrorCheckOnParser(szResult,(char*)szDefault,dwBytesRead,MAX_FX_NAME)) {
            
            if (count == pFxData->m_dwNumOutputs) {

                //
                // this is not an hour. We read one more input/output than we are
                // supposed to to catch any types by the author
                //

                break;
            } else {

                PrintParsingError(pFxName,
                    szKeyName,
                    "FATAL: Invalid output name found for output %d",
                    count);
                
                return -1;
            }
            
        } else {

            if (count == pFxData->m_dwNumOutputs) {

                PrintParsingError(pFxName,
                    szKeyName,
                    "WARNING: More outputs specified than FX_NUMOUTPUTS",
                    count);

                break;
            }
        } 
        
        pFxData->m_dwOutputIDs[count] = pFxData->OutputNameToOutputID(szResult);
        if (pFxData->m_dwOutputIDs[count] == -1) {
            
            PrintParsingError(pFxName,
                szKeyName,
                "FATAL: Invalid output name specified for output %d",
                count);
            
            return -1;
        }
        
        count++;
        if (count > MAX_FX_OUTPUTS) {

            PrintParsingError(pFxName,
                szKeyName,
                "FATAL: Too many outputs specified. Maximum is %d",
                MAX_FX_OUTPUTS);
            
            return -1;
        }


        
    } // FX output enumeration subloop
    
    return ERROR_SUCCESS;
}

//*****************************************************************************

int CDspImageBuilder::ParseInputs(PCHAR pFxName, CFxData *pFxData)
{

    CHAR szKeyName[64];
    CHAR szDefault[256] = "DefaultString";
    CHAR szResult[256];

    DWORD dwValue, dwBytesRead;

    //
    // retrieve number of inputs
    //

    sprintf(szKeyName,"%s",FXPARAM_NUMINPUTS_NAME);
    
    dwValue = GetPrivateProfileInt(pFxName,
        szKeyName,
        -1,
        (const char*)m_szDspDataFileName);
    
    
    if (dwValue == -1) {
        
        PrintParsingError(pFxName,
            pFxName,
            "FATAL: Key (%s) not found",
            FXPARAM_NUMINPUTS_NAME);                
        
        return -1;
        
    }
    
    pFxData->m_dwNumInputs = dwValue;
    
    // ****************************************************************
    // read input names...
    // ****************************************************************
    
    DWORD count = 0;
    while (count < pFxData->m_dwNumInputs) {
        
        //
        // we expect keys for each input..
        //
        
        sprintf(szKeyName,"%s%d",FXPARAM_INPUT_NAME,count);
        dwBytesRead = GetPrivateProfileString(pFxName,
            szKeyName,
            szDefault,
            szResult,
            MAX_FX_NAME,
            (const char*)m_szDspDataFileName);
        
        if (ErrorCheckOnParser(szResult,(char*)szDefault,dwBytesRead,MAX_FX_NAME)) {
            
            if (count == pFxData->m_dwNumInputs) {
                
                //
                // this is not an hour. We read one more input/output than we are
                // supposed to to catch any types by the author
                //
                
                break;
            } else {
                
                PrintParsingError(pFxName,
                    szKeyName,
                    "FATAL: Invalid input name found for input %d",
                    count);
                
                return -1;
            }
            
        } else {
            
            if (count == pFxData->m_dwNumInputs) {
                
                PrintParsingError(pFxName,
                    szKeyName,
                    "WARNING: More inputs specified than FX_NUMOUTPUTS",
                    count);
                
                break;
            }
        } 
        
        pFxData->m_dwInputIDs[count] = pFxData->InputNameToInputID(szResult);
        if (pFxData->m_dwInputIDs[count] == -1) {
            
            PrintParsingError(pFxName,
                szKeyName,
                "FATAL: Invalid input name specified for input %d",
                count);
            
            return -1;
        }
        
        count++;

        if (count > MAX_FX_INPUTS) {

            PrintParsingError(pFxName,
                szKeyName,
                "FATAL: Too many inputs specified. Maximum is %d",
                MAX_FX_INPUTS);
            
            return -1;
        }

        
    } // FX input enumeration subloop

    return ERROR_SUCCESS;
}

DWORD CFxData::OutputNameToOutputID(PCHAR pName)
{

    DWORD dwId = -1,i;
    CHAR szName[64];

    //
    // first check if the output specified is a mix bin
    //

    for (i=0;i<NUM_GPMIXBINS;i++) {

        if (!strcmp(gpMixBinNames[i],pName) && 
            !strstr(gpMixBinNames[i],"RESERVED")) {

            dwId = FXOUTPUT_GPMIXBIN_BASE;

            //
            // place the actuall GP mix bin memory offset here
            //

            dwId |= (i * DSP_BUFFER_FRAME_LENGTH) + DSP_GPMIXBIN_MEMOFFSET_BASE;
            return dwId;
        }

    }

    //
    // see if they specified internal temp bins
    //

    for (i=0;i<MAX_TEMPBINS;i++) {

        sprintf(szName,"%s%d",FXOUTPUT_GPTEMPBIN_NAME,i);
        if (!strcmp(szName,pName)) {

            dwId = FXOUTPUT_GPTEMPBIN_BASE;

            //
            // OR the bin number
            //

            dwId |= i;
            return dwId;
        }

    }

    return dwId;
}

DWORD CFxData::InputNameToInputID(PCHAR pName)
{

    DWORD dwId = -1,i;
    CHAR szName[64];

    //
    // first check if the input specified is a VP mix bin
    //

    for (i=0;i<NUM_VPMIXBINS;i++) {

        if (!strcmp(vpMixBinNames[i],pName) &&
            !strstr(vpMixBinNames[i],"RESERVED")) {

            dwId = FXINPUT_VPMIXBIN_BASE;
            dwId |= (i * DSP_BUFFER_FRAME_LENGTH) + DSP_VPMIXBIN_MEMOFFSET_BASE;

            return dwId;
        }

    }

    //
    // check if the input specified is a GP mix bin
    //

    for (i=0;i<NUM_GPMIXBINS;i++) {

        if (!strcmp(gpMixBinNames[i],pName)) {

            dwId = FXINPUT_GPMIXBIN_BASE;

            //
            // place the actuall GP mix bin memory offset here
            //

            dwId |= (i * DSP_BUFFER_FRAME_LENGTH) + DSP_GPMIXBIN_MEMOFFSET_BASE;

            return dwId;
        }

    }

    //
    // see if they specified internal temp bins
    //

    for (i=0;i<MAX_TEMPBINS;i++) {

        sprintf(szName,"%s%d",FXINPUT_GPTEMPBIN_NAME,i);
        if (!strcmp(szName,pName)) {

            dwId = FXINPUT_GPTEMPBIN_BASE;

            //
            // OR the bin number
            //

            dwId |= i;
            return dwId;
        }

    }


    return dwId;
}

DWORD CFxData::ParamNameToParamID(PCHAR pName)
{
#if 0
    DWORD dwId = -1,i;

    CHAR szName[64];
    PCHAR pszOffset;

    //
    // check if just a raw value is specified
    //
        
    sprintf(szName,"%s",FXPARAM_VALUE_NAME);
    pszOffset = strstr(pName,szName);
    
    if (pszOffset){
                
        //
        // extract the offset number from the definition
        //
        
        while (*pszOffset != '_') {
            pszOffset++;
            if (*pszOffset == 0) {
                
                return -1;
                
            }
        }
                
        i = atoi(pszOffset + 1);
        
        dwId = i | FXPARAM_VALUE_BASE;
        return dwId;
        
    }
#endif  
    return -1;
}



int CDspImageBuilder::ValidateFxGraphs()
{

    int err = ERROR_SUCCESS;
    DWORD dwFxIndex,dwGraphIndex, count;
    DWORD dwValue;
            
    //
    // for each graph, check each FX->FX connection for validity.
    //

    for (dwGraphIndex=0;dwGraphIndex<m_dwGraphCount;dwGraphIndex++){


        for (dwFxIndex=0;dwFxIndex<m_pGraphs[dwGraphIndex]->GetNumEffects();dwFxIndex++){

            CFxGraph *pGraph = m_pGraphs[dwGraphIndex];
            CFxData *pPreviousFx = NULL, *pCurrentFx = NULL, *pNextFx = NULL;

            pCurrentFx = pGraph->GetFxData(dwFxIndex);

            //
            // check : Presense of dsp code file
            //

            if (pCurrentFx->m_szDspCodeFileName[0] == 0) {

                PrintValidationError(DBGLVL_ERROR,dwGraphIndex,dwFxIndex,"Dsp code filename not specified");
                return -1;

            } else {

                //
                // read dsp code, convert to an array of dwords.
                //

                err = ReadDspCodeFile(pCurrentFx);
                if (err != ERROR_SUCCESS) {
                    return err;
                }
                
                PDWORD opcode = (PDWORD)pCurrentFx->m_pDspCode;
                
                //
                // verify its a 
                // move #>(CONSTANT),r5 
                // opcode
                //
                
                if (*opcode != DSP_563000_OPCODE_MOVE_X_TO_R5_IMM) {
                
                    PrintValidationError(DBGLVL_ERROR,dwGraphIndex,dwFxIndex,"First opcode of DSP FX must be *** move #>$40,r5 ***");
                    return -1;
                    
                }
                
                
            }

            //
            // check : Number of inputs
            //

            if (pCurrentFx->m_dwNumInputs > MAX_FX_INPUTS){

                PrintValidationError(DBGLVL_ERROR,dwGraphIndex,dwFxIndex,"Invalid number of Inputs");
                return -1;

            }

            //
            // check : Number of outputs
            //

            if (pCurrentFx->m_dwNumOutputs > MAX_FX_OUTPUTS){

                PrintValidationError(DBGLVL_ERROR,dwGraphIndex,dwFxIndex,"Invalid number of Outputs");
                return -1;

            }

            //
            // check : Validate Input IDs and connections
            //

            for (count=0;count<pCurrentFx->m_dwNumInputs;count++) {

                if (pCurrentFx->m_dwInputIDs[count] == 0) {

                    PrintValidationError(DBGLVL_ERROR,
                        dwGraphIndex,
                        dwFxIndex,
                        "No input source specified for input %d",
                        count);
                    
                    return -1;

                }

                //
                // if they specified a temp bin explicitly make sure its not allocated
                // or exceeds the number of bins they specified up front
                //

                if (pCurrentFx->m_dwInputIDs[count] & FXINPUT_GPTEMPBIN_BASE){

                    dwValue = pCurrentFx->m_dwInputIDs[count] & ~FXINPUT_GPTEMPBIN_BASE;
                    if (dwValue > m_dwNumTempBins-1) {

                        PrintValidationError(DBGLVL_ERROR,
                            dwGraphIndex,
                            dwFxIndex,
                            "Temp bin index is higher than specified in NUMTEMPBINS");

                        return -1;
                    }

                    if (!m_aTempBins[dwValue]) {

                        //
                        // allocate the bin in our mask
                        //
                        
                        m_aTempBins[dwValue] = TRUE;

                    }


                } //GPTEMPBIN  check
                                    
                            
            } // FX Input FOR loop

            //
            // Check : Output validation
            //

            for (count = 0;count < pCurrentFx->m_dwNumOutputs;count++){

                if (pCurrentFx->m_dwOutputIDs[count] == 0) {
                    
                    PrintValidationError(DBGLVL_ERROR,
                        dwGraphIndex,
                        dwFxIndex,
                        "No output destination specified for output %d",
                        count);
                    
                    return -1;
                    
                }

                //
                // if they specified a temp bin explicitly make sure its not allocated
                // or exceeds the number of bins they specified up front
                //

                if (pCurrentFx->m_dwOutputIDs[count] & FXOUTPUT_GPTEMPBIN_BASE){

                    dwValue = pCurrentFx->m_dwOutputIDs[count] & ~FXOUTPUT_GPTEMPBIN_BASE;
                    if (dwValue > m_dwNumTempBins-1) {

                        PrintValidationError(DBGLVL_ERROR,
                            dwGraphIndex,
                            dwFxIndex,
                            "Temp bin index is higher than specified in NUMTEMPBINS");

                        return -1;
                    }

                    if (!m_aTempBins[dwValue]) {

                        //
                        // allocate the bin in our mask
                        //
                        
                        m_aTempBins[dwValue] = TRUE;

                    }

                }
                                    
            }

            //****************************************************
            // DSP Resource checks
            //****************************************************

            //
            // keep track of the total size of all DSP code we have read so far
            //

            m_dwTotalDspCodeSize += pCurrentFx->m_dwDspCodeSize;
            if (m_dwTotalDspCodeSize > (DSP_PMEMORY_SIZE - DSP_EXECUTION_ENGINE_SIZE)) {

                PrintValidationError(DBGLVL_ERROR,
                    dwGraphIndex,
                    dwFxIndex,
                    " Dsp code space exceed with this FX");

                return -1;
            }

            //
            // keep track of the total size of X+Y memory used so far
            //

            m_dwTotalDspStateSize += pCurrentFx->m_dwDspStateSize;
            if (m_dwTotalDspStateSize > DSP_FX_STATE_MAX_SIZE) {

                PrintValidationError(DBGLVL_ERROR,
                    dwGraphIndex,
                    dwFxIndex,
                    "FATAL ERROR: DSP Local FX state memory space: %d. Total used so far: %d.",
                    DSP_FX_STATE_MAX_SIZE,
                    m_dwTotalDspStateSize);



                return -1;
            }

            //
            // keep track of scratch space usage
            //

            m_dwTotalScratchSize += pCurrentFx->GetScratchSize();

            //
            // keep track of Y memory usage
            //

            m_dwTotalDspYMemSize += pCurrentFx->GetYMemSize();
            if (m_dwTotalDspYMemSize > DSP_YMEMORY_SIZE) {

                PrintValidationError(DBGLVL_ERROR,
                    dwGraphIndex,
                    dwFxIndex,
                    "DSP Y memory space exceed with this FX");

                return -1;
            }

            //
            // track total cycles used
            //

            m_dwTotalDspCyclesUsed += pCurrentFx->m_dwDspCyclesUsed;

            if (m_dwTotalDspCyclesUsed > DSP_MAXCYCLES_AVAILABLE) {

                PrintValidationError(DBGLVL_ERROR,
                    dwGraphIndex,
                    dwFxIndex,
                    "FATAL ERROR: DSP Available processing cycles  = %d. Total including this FX %d",
                    DSP_MAXCYCLES_AVAILABLE,
                    m_dwTotalDspCyclesUsed);


                return -1;
            }

        }

    }


    //
    // count the total temporary bins we utilized. If its less than what the user
    // specified upfront, spew out a warning
    //

    dwValue = 0;
    for (ULONG i=0;i<MAX_TEMPBINS;i++) {

        if (m_aTempBins[i]){
            dwValue++;
        }

    }

    if (dwValue != m_dwNumTempBins) {

        PrintValidationError(DBGLVL_WARN,
            dwGraphIndex,
            dwFxIndex,
            "Number of temporary bins used = %d, Number of Bins specified in MAIN section %d.",
            dwValue,
            m_dwNumTempBins
            );

        //
        // will still use the value they gave us just in case they wanted to reserve space in xram
        //

    }

    //
    // add the right amount of words to XRAM utilization fo the TEMP bins
    //
    
    m_dwTotalDspStateSize += DSP_BUFFER_FRAME_LENGTH*sizeof(DWORD)*m_dwNumTempBins;
    
    //
    // align scratch space used to nearest page
    //

    m_dwTotalScratchSize = ((m_dwTotalScratchSize+PAGE_SIZE-1)/PAGE_SIZE)*PAGE_SIZE;

    return err;

}

int CDspImageBuilder::ReadDspCodeFile(CFxData *pCurrentFx)
{
    int err;
    PTCHAR pszFileName;
    PUCHAR pBuffer,pDst;
    PDWORD pdwSize;

    pszFileName = pCurrentFx->m_szDspCodeFileName;
    pBuffer = (PUCHAR)pCurrentFx->m_pDspCode;
    pdwSize = &pCurrentFx->m_dwDspCodeSize;
    
    //
    // attempt to open and read the dsp code
    //
    
    m_hInputFile = CreateFile(
        (const char *)pszFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    
    if (m_hInputFile == INVALID_HANDLE_VALUE) {
        
        err = GetLastError();
        DebugPrint(DBGLVL_ERROR,"Failed to open the dsp image file %s.Error 0x%x",
            pszFileName,
            err);
        return err;
        
    }
    
    //
    // read DSP code into FX data, determine size of file..
    //
    
    *pdwSize = SetFilePointer(m_hInputFile, 0, NULL, FILE_END);              
    SetFilePointer(m_hInputFile, 0, NULL, FILE_BEGIN);
    
    //
    // the cldtobin tool will append a few zero DWORDs at the end of the
    // of the dsp code. Make sure the dsp code length is dword aligned.
    // if not aligned it to the next lowest dword boundary
    //

    if (pCurrentFx->m_dwDspCodeSize & 0x00000003) {
        
        //
        // not dword aligned.. align it
        //

        pCurrentFx->m_dwDspCodeSize &= 0xFFFFFFFC;

    }

    //
    // allocate memory for the DSP code image
    //
    
    pBuffer = new BYTE[*pdwSize];
    if (pBuffer == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    pDst = new BYTE[*pdwSize];
    if (pDst == NULL) {
        delete [] pBuffer;
        return ERROR_OUTOFMEMORY;
    }

    DWORD dwBytesRead;
    BOOL bResult = ReadFile(m_hInputFile,
        pBuffer,
        *pdwSize,
        &dwBytesRead,
        0);
    
    if (!bResult) {
        
        err = GetLastError();
        DebugPrint(DBGLVL_ERROR,"Failed to read dsp code from file %s.Error 0x%x",
            pszFileName,
            err);

        delete [] pBuffer;
        delete [] pDst;
        return err;
        
    }

    //
    // the file is encrypted. decode
    //

    XAudiopUtility_Decode(pCurrentFx->m_szDevKey,pBuffer,*pdwSize,pDst,TRUE);

    pCurrentFx->m_pDspCode = (PDWORD)pDst;

    //
    // note that encoded file is KEY_SIZE bytes larger
    // then raw dsp opcode binary
    //

    pCurrentFx->m_dwDspCodeSize -= KEY_SIZE;

    CloseHandle(m_hInputFile);
    m_hInputFile = NULL;

    delete [] pBuffer;

    return ERROR_SUCCESS;
}

//------------------------------------------------------------------------------
//  CDspImageBuilder::Print
//------------------------------------------------------------------------------
void
CDspImageBuilder::Print(
                        IN PCHAR    pFormat,
                        IN ...
                        )
/*++

Routine Description:

    Virtual print method. Defaults to stderr

Arguments:

    IN pFormat -    Format string
    IN ... -        Additional arguments

Return Value:

    None

--*/
{
    CHAR    szString[0x400];
    va_list va;

    va_start(va, pFormat);
    vsprintf(szString, pFormat, va);
    va_end(va);

    fprintf(stderr, szString);
}

//------------------------------------------------------------------------------
//  CDspImageBuilder::SetIniPath
//------------------------------------------------------------------------------
void 
CDspImageBuilder::SetIniPath(
                             IN LPCTSTR pPath
                             )
/*++

Routine Description:

    Sets the path for .ini files

Arguments:

    IN pPath -  Path

Return Value:

    None

--*/
{
    if(pPath != NULL)
        strcpy(m_szIniPath, pPath);
    else
        memset(m_szIniPath, 0, sizeof(m_szIniPath));
}

//------------------------------------------------------------------------------
//  CDspImageBuilder::SetDspCodePath
//------------------------------------------------------------------------------
void 
CDspImageBuilder::SetDspCodePath(
                                 IN LPCTSTR pPath
                                 )
/*++

Routine Description:

    Sets the path for the dsp files

Arguments:

    IN pPath -  Path

Return Value:

    None

--*/
{
    if(pPath != NULL)
        strcpy(m_szDspCodePath, pPath);
    else
        memset(m_szDspCodePath, 0, sizeof(m_szDspCodePath));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\fxdspimg.h ===
//
// enviroment variables we read
//

#define ENV_VAR_INI_PATH "_XGPIMAGE_INI_PATH"
#define ENV_VAR_DSP_CODE_PATH  "_XGPIMAGE_DSP_CODE_PATH"

#define MAX_FX_NAME 256
#define APP_NAME "XGPIMAGE"

#define PAGE_SIZE 4096

class CFxData {
public:

	CFxData::CFxData()
	{

		DWORD i=0;
		memset(m_szEffectName,0,sizeof(m_szEffectName));
		memset(m_szFriendlyEffectName,0,sizeof(m_szFriendlyEffectName));
		memset(m_szDspCodeFileName,0,sizeof(m_szDspCodeFileName));
		memset(m_szDspStateFileName,0,sizeof(m_szDspStateFileName));

		m_dwEffectIndex = 0;
		m_dwNumInputs = 0;
		m_dwNumOutputs = 0;
		m_dwNumParams = 0;
		
		m_pDspCode = 0;
		m_dwDspCodeSize = 0;

		m_dwDspCyclesUsed = 0;
		
		m_pDspState = 0;
		m_dwDspStateSize = 0;

		for (i=0;i<MAX_FX_INPUTS;i++){

			m_dwInputIDs[i] = 0;

		}

		for (i=0;i<MAX_FX_OUTPUTS;i++){

			m_dwOutputIDs[i] = 0;

		}

        m_pEffectStateParameters = NULL;
	}

	CFxData::~CFxData()
	{

		if (m_pDspCode)
			delete [] m_pDspCode;

		if (m_pDspState)
			delete [] m_pDspState;

        if (m_pEffectStateParameters)
            delete [] m_pEffectStateParameters;
	}


	TCHAR m_szEffectName[MAX_FX_NAME];
	TCHAR m_szFriendlyEffectName[MAX_FX_NAME];
	TCHAR m_szDspCodeFileName[MAX_PATH];
	TCHAR m_szDspStateFileName[MAX_PATH];

	UCHAR m_szDevKey[KEY_SIZE];

    DWORD m_dwEffectIndex;
	DWORD m_dwNumInputs;
	DWORD m_dwNumOutputs;
	DWORD m_dwNumParams;

	PDWORD m_pDspCode;
	DWORD  m_dwDspCodeSize;
	
	PDWORD m_pDspState;
	DWORD  m_dwDspStateSize;

	DWORD  m_dwDspCyclesUsed;

	DWORD  m_dwInputIDs[MAX_FX_INPUTS];
	DWORD  m_dwOutputIDs[MAX_FX_OUTPUTS];

    PFX_STATE_PARAMETERS m_pEffectStateParameters;

	DWORD  CalcStateSize()
	{		
		return (sizeof(DSP_STATE_FIXED) + (m_dwNumParams + m_dwNumInputs + m_dwNumOutputs) * sizeof(DWORD) - sizeof(DWORD)*2 );
	}

	DWORD GetParamOffset()
	{

		return (sizeof(DSP_STATE_FIXED)/sizeof(DWORD) + (m_dwNumInputs + m_dwNumOutputs) - 2); 

	}

	DWORD GetScratchSize()
	{
		return ((PDSP_STATE_FIXED)m_pDspState)->dwScratchLength;
	}

	DWORD GetYMemSize()
	{
		return ((PDSP_STATE_FIXED)m_pDspState)->dwYMemLength;
	}

	DWORD ParamNameToParamID(PCHAR pName);
	DWORD InputNameToInputID(char * pName);
    DWORD OutputNameToOutputID(char * pName);


};

#define MAX_GRAPHS 20
#define MAX_FX_PER_GRAPH 32

class CFxGraph {

	DWORD m_dwNumEffects;
	TCHAR m_szGraphName[MAX_FX_NAME];
	CFxData *m_pFxArray[MAX_FX_PER_GRAPH];
public:

	CFxGraph::CFxGraph()
	{
		memset(m_szGraphName,0,sizeof(m_szGraphName));
		memset(m_pFxArray,0,sizeof(m_pFxArray));
		m_dwNumEffects = 0;
	}

	CFxGraph::~CFxGraph()
	{
		for (ULONG i=0;i<m_dwNumEffects;i++) {
			delete m_pFxArray[i];
		}
		m_dwNumEffects = 0;
	}

	DWORD GetNumEffects() { return m_dwNumEffects;}

	CFxData * GetFxData(DWORD dwIndex)
	{

		if (dwIndex < m_dwNumEffects){

			return m_pFxArray[dwIndex];

		} else {

			return NULL;

		}

	}

	void SetGraphName(TCHAR szName[])
	{
		memcpy(m_szGraphName,szName,sizeof(m_szGraphName));
	}

    TCHAR *GetGraphName()
	{
		return m_szGraphName;
	}

	void SetFx(CFxData *pFxData) 
	{
		pFxData->m_dwEffectIndex = m_dwNumEffects;
		m_pFxArray[m_dwNumEffects++] = pFxData;
	}

};

#define DBGLVL_INFO 2
#define DBGLVL_WARN 1
#define DBGLVL_ERROR 0

class CDspImageBuilder {

protected:

    TCHAR m_szAppName[64];

	TCHAR m_szDspCodePath[MAX_PATH];
	TCHAR m_szIniPath[MAX_PATH];

    TCHAR m_szDspDataFileName[MAX_PATH];
    TCHAR m_szScratchImageFileName[MAX_PATH];
    TCHAR m_szCHeaderFileName[MAX_PATH];

	TCHAR m_szImageFriendlyName[MAX_FX_NAME];

    HANDLE m_hInputFile;
    HANDLE m_hOutputFile;

	CFxGraph *m_pGraphs[MAX_GRAPHS];
	DWORD m_dwGraphCount;
	DWORD m_dwDebugLevel;

	DWORD m_dwTotalScratchSize;
	DWORD m_dwTotalDspCodeSize;
	DWORD m_dwTotalDspStateSize;
	DWORD m_dwTotalDspYMemSize;
	DWORD m_dwTotalDspCyclesUsed;

	DWORD m_dwTotalFX;

	UCHAR m_aTempBins[MAX_TEMPBINS];
	DWORD m_dwNumTempBins;

public:

    CDspImageBuilder::CDspImageBuilder(char* AppName);
    virtual CDspImageBuilder::~CDspImageBuilder();

	//
	// utility functions
	//
    
    int ParseCommandLine(int argc, char * argv[]);
    void UsageFailure(int err);
	int ErrorCheckOnParser(PCHAR pResult, PCHAR pDefault,DWORD dwBytesRead, DWORD dwSize);

	int ReadDspCodeFile(CFxData *pFx);

    void PrintParsingError(PCHAR pSection, PCHAR pKey,PCHAR szFormat, ...);
	void PrintValidationError(DWORD dwDebugLevel, DWORD dwGraphIndex, DWORD dwFxIndex, PCHAR pszFormat, ...);

	void DebugPrint(DWORD dwLevel, PCHAR pszFormat, ...);

	virtual void Print(PCHAR pFormat, ...);

	//
	// core functions
	//

    int ParseInputFile();
	int ValidateFxGraphs();
    int BuildDspImage();
    int CreateEnumHeader();
	//
	// parsing functions
	//
    int ParseParameterDescriptions(const char *pFileName, PFX_STATE_PARAMETERS *ppDesc);

	int ParseStateParameters( PCHAR pFxName, CFxData *pFxData);
    int ParseInputs( PCHAR pFxName, CFxData *pFxData);
    int ParseOutputs( PCHAR pFxName, CFxData *pFxData);

	//
	// DSP image generation functions
	//

	DWORD BufferIDToDSPAddress(DWORD dwBinBaseIndex,DWORD dwId);
	void DefaultCommandBlock(HOST_TO_DSP_COMMANDBLOCK *d);

	// Tools to programatically set the paths instead of relying on env vars
	void SetIniPath(LPCTSTR pPath);
	void SetDspCodePath(LPCTSTR pPath);

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F65E714B_EE06_4889_93E6_FCBC52303695__INCLUDED_)
#define AFX_STDAFX_H__F65E714B_EE06_4889_93E6_FCBC52303695__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <windows.h>
#include <xboxverp.h>
#include <stdio.h>
#include <stdlib.h>
#include <xboxdbg.h>
#include <dsfxparmp.h>

#include "parser.h"
#include "..\inc\dsp.h"
#include "..\inc\cipher.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F65E714B_EE06_4889_93E6_FCBC52303695__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\xgpimage\xgpimage.cpp ===
// xgpimage.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

int main(int argc, char* argv[])
{
	printf("Hello World!\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\waveldr\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\waveldr\waveldr.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 12/11/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       waveldr.cpp
 *  Content:    Wave Loader stand-along library.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/11/2001   dereks  Created.
 *
 ****************************************************************************/

#include "..\common\dscommon.h"
#include "..\common\waveldr.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\buffer.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       buffer.hpp
 *  Content:    Class header the buffer base class; this class
 *              contains all the logic that is shared between
 *              the Index/Vertex/Command buffer types.
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//----------------------------------------------------------------------------
// Helper to create an instance of a buffer.
//
HRESULT CreateVertexIndexOrPushBuffer(
    DWORD Type,
    DWORD Size, 
    void **ppBuffer);


} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\waveldr\waveldr.h ===
/***************************************************************************
 *
 *  Copyright (C) 12/11/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       waveldr.h
 *  Content:    Wave Loader stand-along library.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/11/2001   dereks  Created.
 *
 ****************************************************************************/

#include "..\common\waveldr.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\caps.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       caps.hpp
 *  Content:    Defintions for Kelvin device capabilities.
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#define KELVIN_CAPS_CAPS                D3DCAPS_READ_SCANLINE

// Define the device capabilities.
#define KELVIN_DEVCAPS_FLAGS           (D3DDEVCAPS_EXECUTESYSTEMMEMORY     | \
                                       D3DDEVCAPS_EXECUTEVIDEOMEMORY      | \
                                       D3DDEVCAPS_TLVERTEXSYSTEMMEMORY    | \
                                       D3DDEVCAPS_TLVERTEXVIDEOMEMORY     | \
                                       D3DDEVCAPS_TEXTUREVIDEOMEMORY      | \
                                       D3DDEVCAPS_DRAWPRIMTLVERTEX        | \
                                       D3DDEVCAPS_CANRENDERAFTERFLIP      | \
                                       D3DDEVCAPS_TEXTURENONLOCALVIDMEM   | \
                                       D3DDEVCAPS_DRAWPRIMITIVES2         | \
                                       D3DDEVCAPS_DRAWPRIMITIVES2EX       | \
                                       D3DDEVCAPS_HWTRANSFORMANDLIGHT     | \
                                       D3DDEVCAPS_CANBLTSYSTONONLOCAL     | \
                                       D3DDEVCAPS_PUREDEVICE              | \
                                       D3DDEVCAPS_HWRASTERIZATION         | \
                                       D3DDEVCAPS_QUINTICRTPATCHES        | \
                                       D3DDEVCAPS_RTPATCHES)


// Miscellaneous capabilities (dwMiscCaps)
#define KELVIN_TRICAPS_MISC            (D3DPMISCCAPS_MASKZ                | \
                                        D3DPMISCCAPS_CULLNONE             | \
                                        D3DPMISCCAPS_CULLCW               | \
                                        D3DPMISCCAPS_CULLCCW              | \
                                        D3DPMISCCAPS_BLENDOP              | \
                                        D3DPMISCCAPS_COLORWRITEENABLE     | \
                                        D3DPMISCCAPS_TSSARGTEMP)

// Raster capabilities (dwRasterCaps)
//
// Note that unlike the Nvidia driver, we don't say we support FOGVERTEX
// mode (since the hardware doesn't actually do it)
#define KELVIN_TRICAPS_RASTER          (D3DPRASTERCAPS_DITHER             | \
                                        D3DPRASTERCAPS_FOGTABLE           | \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS      | \
                                        D3DPRASTERCAPS_ZBIAS              | \
                                        D3DPRASTERCAPS_FOGRANGE           | \
                                        D3DPRASTERCAPS_ANISOTROPY         | \
                                        D3DPRASTERCAPS_WBUFFER            | \
                                        D3DPRASTERCAPS_WFOG               | \
                                        D3DPRASTERCAPS_ZFOG               | \
                                        D3DPRASTERCAPS_ANTIALIASEDGES)

// Z Compare capabilities (dwZCmpCaps)
#define KELVIN_TRICAPS_ZCMP            (D3DPCMPCAPS_NEVER                 | \
                                        D3DPCMPCAPS_LESS                  | \
                                        D3DPCMPCAPS_EQUAL                 | \
                                        D3DPCMPCAPS_LESSEQUAL             | \
                                        D3DPCMPCAPS_GREATER               | \
                                        D3DPCMPCAPS_NOTEQUAL              | \
                                        D3DPCMPCAPS_GREATEREQUAL          | \
                                        D3DPCMPCAPS_ALWAYS)

// Source blend capabilities (dwSrcBlendCaps)
#define KELVIN_TRICAPS_SRCBLEND        (D3DPBLENDCAPS_ZERO                | \
                                        D3DPBLENDCAPS_ONE                 | \
                                        D3DPBLENDCAPS_SRCCOLOR            | \
                                        D3DPBLENDCAPS_INVSRCCOLOR         | \
                                        D3DPBLENDCAPS_SRCALPHA            | \
                                        D3DPBLENDCAPS_INVSRCALPHA         | \
                                        D3DPBLENDCAPS_DESTALPHA           | \
                                        D3DPBLENDCAPS_INVDESTALPHA        | \
                                        D3DPBLENDCAPS_DESTCOLOR           | \
                                        D3DPBLENDCAPS_INVDESTCOLOR        | \
                                        D3DPBLENDCAPS_SRCALPHASAT         | \
                                        D3DPBLENDCAPS_BOTHSRCALPHA        | \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA)

// Destination blend capabilities (dwDestBlendCaps)
#define KELVIN_TRICAPS_DESTBLEND       (D3DPBLENDCAPS_ZERO                | \
                                        D3DPBLENDCAPS_ONE                 | \
                                        D3DPBLENDCAPS_SRCCOLOR            | \
                                        D3DPBLENDCAPS_INVSRCCOLOR         | \
                                        D3DPBLENDCAPS_SRCALPHA            | \
                                        D3DPBLENDCAPS_INVSRCALPHA         | \
                                        D3DPBLENDCAPS_DESTALPHA           | \
                                        D3DPBLENDCAPS_INVDESTALPHA        | \
                                        D3DPBLENDCAPS_DESTCOLOR           | \
                                        D3DPBLENDCAPS_INVDESTCOLOR        | \
                                        D3DPBLENDCAPS_SRCALPHASAT         | \
                                        D3DPBLENDCAPS_BOTHSRCALPHA        | \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA)

// Alpha compare capabilities (dwAlphaCmpCaps)
#define KELVIN_TRICAPS_ALPHACMP        (D3DPCMPCAPS_NEVER                 | \
                                        D3DPCMPCAPS_LESS                  | \
                                        D3DPCMPCAPS_EQUAL                 | \
                                        D3DPCMPCAPS_LESSEQUAL             | \
                                        D3DPCMPCAPS_GREATER               | \
                                        D3DPCMPCAPS_NOTEQUAL              | \
                                        D3DPCMPCAPS_GREATEREQUAL          | \
                                        D3DPCMPCAPS_ALWAYS)
// Shading capabilities (dwShadeCaps)
#define KELVIN_TRICAPS_SHADE           (D3DPSHADECAPS_COLORGOURAUDRGB     | \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB  | \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND   | \
                                        D3DPSHADECAPS_FOGGOURAUD)

// Texture capabilities (dwTextureCaps)
#define KELVIN_TRICAPS_TEXTURE         (D3DPTEXTURECAPS_PERSPECTIVE       | \
                                        D3DPTEXTURECAPS_POW2              | \
                                        D3DPTEXTURECAPS_ALPHA             | \
                                        D3DPTEXTURECAPS_CUBEMAP           | \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2      | \
                                        D3DPTEXTURECAPS_MIPMAP            | \
                                        D3DPTEXTURECAPS_MIPCUBEMAP        | \
                                        D3DPTEXTURECAPS_PROJECTED         | \
                                        D3DPTEXTURECAPS_ALPHAPALETTE      | \
                                        D3DPTEXTURECAPS_VOLUMEMAP         | \
                                        D3DPTEXTURECAPS_VOLUMEMAP_POW2    | \
                                        D3DPTEXTURECAPS_MIPVOLUMEMAP)

// Texture filtering capabilities (dwTextureFilterCaps)
#define KELVIN_TRICAPS_TEXTUREFILTER   (D3DPTFILTERCAPS_MINFPOINT         | \
                                        D3DPTFILTERCAPS_MINFLINEAR        | \
                                        D3DPTFILTERCAPS_MIPFPOINT         | \
                                        D3DPTFILTERCAPS_MIPFLINEAR        | \
                                        D3DPTFILTERCAPS_MAGFPOINT         | \
                                        D3DPTFILTERCAPS_MAGFLINEAR        | \
                                        D3DPTFILTERCAPS_MINFANISOTROPIC   | \
                                        D3DPTFILTERCAPS_MAGFANISOTROPIC   | \
                                        D3DPTFILTERCAPS_MAGFAFLATCUBIC    | \
                                        D3DPTFILTERCAPS_MAGFGAUSSIANCUBIC)

// Texture addressing capabilities (dwTextureAddressCaps)
#define KELVIN_TRICAPS_TEXTUREADDRESS  (D3DPTADDRESSCAPS_WRAP             | \
                                        D3DPTADDRESSCAPS_MIRROR           | \
                                        D3DPTADDRESSCAPS_CLAMP            | \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV)

#define KELVIN_CAPS_LINECAPS           (D3DLINECAPS_TEXTURE               | \
                                        D3DLINECAPS_ZTEST                 | \
                                        D3DLINECAPS_BLEND                 | \
                                        D3DLINECAPS_ALPHACMP              | \
                                        D3DLINECAPS_FOG)

#define KELVIN_CAPS_MAX_TEXTURE_REPEAT           8192

#define KELVIN_CAPS_MAX_TEXTURE_ASPECT_RATIO     0

// Means we support anisotropic filtering
#define KELVIN_CAPS_MAX_ANISOTROPY               2

const float KELVIN_CAPS_GUARD_BAND_LEFT = -1.0e8f;   // nv10/20 can use a guardband as large as 1e25, but 1e8 appears
const float KELVIN_CAPS_GUARD_BAND_TOP = -1.0e8f;    // to be the largest value that the game re-volt will handle.
const float KELVIN_CAPS_GUARD_BAND_RIGHT = 1.0e8f;   // anything larger aggravates an app bug that causes it to
const float KELVIN_CAPS_GUARD_BAND_BOTTOM = 1.0e8f;  // send us completely broken geometry.

#define KELVIN_CAPS_EXTENTS_ADJUST               0

#define KELVIN_CAPS_STENCILOPS         (D3DSTENCILCAPS_KEEP               | \
                                        D3DSTENCILCAPS_ZERO               | \
                                        D3DSTENCILCAPS_REPLACE            | \
                                        D3DSTENCILCAPS_INCRSAT            | \
                                        D3DSTENCILCAPS_DECRSAT            | \
                                        D3DSTENCILCAPS_INVERT             | \
                                        D3DSTENCILCAPS_INCR               | \
                                        D3DSTENCILCAPS_DECR)

#define KELVIN_CAPS_MAX_UV_PAIRS                  4    // Number of texture uv's supported

#define KELVIN_CAPS_FVF_CAPS           (KELVIN_CAPS_MAX_UV_PAIRS | \
                                        D3DFVFCAPS_DONOTSTRIPELEMENTS)

#define KELVIN_CAPS_TEXTUREOPS         (D3DTEXOPCAPS_DISABLE                   | \
                                        D3DTEXOPCAPS_SELECTARG1                | \
                                        D3DTEXOPCAPS_SELECTARG2                | \
                                        D3DTEXOPCAPS_MODULATE                  | \
                                        D3DTEXOPCAPS_MODULATE2X                | \
                                        D3DTEXOPCAPS_MODULATE4X                | \
                                        D3DTEXOPCAPS_ADD                       | \
                                        D3DTEXOPCAPS_ADDSIGNED                 | \
                                        D3DTEXOPCAPS_ADDSIGNED2X               | \
                                        D3DTEXOPCAPS_SUBTRACT                  | \
                                        D3DTEXOPCAPS_ADDSMOOTH                 | \
                                        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         | \
                                        D3DTEXOPCAPS_BLENDTEXTUREALPHA         | \
                                        D3DTEXOPCAPS_BLENDFACTORALPHA          | \
                                        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       | \
                                        D3DTEXOPCAPS_BLENDCURRENTALPHA         | \
                                        D3DTEXOPCAPS_PREMODULATE               | \
                                        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    | \
                                        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    | \
                                        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR | \
                                        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA | \
                                        D3DTEXOPCAPS_BUMPENVMAP                | \
                                        D3DTEXOPCAPS_BUMPENVMAPLUMINANCE       | \
                                        D3DTEXOPCAPS_DOTPRODUCT3)

#define KELVIN_CAPS_MAX_TEXTURE_BLEND_STAGES     4 // no remapping done on xbox, max is 4

#define KELVIN_CAPS_MAX_SIMULTANEOUS_TEXTURES    4

#define KELVIN_CAPS_VTXPCAPS           (D3DVTXPCAPS_TEXGEN                | \
                                        D3DVTXPCAPS_MATERIALSOURCE7       | \
                                        D3DVTXPCAPS_DIRECTIONALLIGHTS     | \
                                        D3DVTXPCAPS_POSITIONALLIGHTS      | \
                                        D3DVTXPCAPS_LOCALVIEWER           | \
                                        D3DVTXPCAPS_NO_VSDT_UBYTE4)

#define KELVIN_CAPS_MAX_ACTIVE_LIGHTS            8

#define KELVIN_CAPS_MAX_VERTEX_BLEND_MATRICES    4

#define KELVIN_CAPS_MAX_STREAMS                  16

#define KELVIN_CAPS_MAX_VSHADER_CONSTS           96

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\clear.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clear.cpp
 *  Content:    Handles wacking the hardware for the Clear command
 *
 ***************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//----------------------------------------------------------------------------
// D3DDevice_Clear
//
extern "C"
void WINAPI D3DDevice_Clear(
    DWORD Count,
    CONST D3DRECT *pRects,
    DWORD Flags,
    D3DCOLOR Color,
    float Z,
    DWORD Stencil) 
{ 
    CDevice *pDevice = g_pDevice;
    D3DRECT rect;

    PPUSH pPush;

    COUNT_API(API_D3DDEVICE_CLEAR);

#if DBG

    if (DBG_CHECK(TRUE))
    {
        if ((Flags == 0) ||
            (Flags & ~(D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL)))
        {
            D3D_ERR("Invalid flags passed to Clear");
        }
        if ((Flags & D3DCLEAR_STENCIL) && (Stencil > 0xff))
        {
            D3D_ERR("Invalid stencil fill value");
        }
        if ((Flags & D3DCLEAR_ZBUFFER) && (Z < 0.0f || Z > 1.0f))
        {
            D3D_ERR("Invalid Z fill value");
        }
        if ((Flags & D3DCLEAR_ZBUFFER) &&
            !(Flags & D3DCLEAR_STENCIL) &&
            (pDevice->m_pZBuffer) &&
            (PixelJar::GetBitsPerPixel(pDevice->m_pZBuffer) == 32) &&
            !(g_StencilEverEnabled) &&
            !(g_WarnedAboutStencil))
        {
            WARNING("D3DCLEAR_ZBUFFER for 32-bit depth buffers is faster when "
                    "D3DCLEAR_STENCIL set too,\neven when not using stencil");
            g_WarnedAboutStencil = TRUE;
        }
        if(pDevice->m_dwSnapshot)
        {
            HandleShaderSnapshot_Clear(Count, pRects, Flags, Color, Z, Stencil);
            return;
        }
    }

#endif

    // Get information about the render target.

    D3DSurface *pTarget = pDevice->m_pRenderTarget;
    D3DSurface *pZBuffer = pDevice->m_pZBuffer;

    DWORD FillDepth = 0;
    DWORD SavedFormat = 0;

    // Kelvin doesn't handle clearing rectangles in swizzled textures.
    // Munge it around to allow us to clear the entire texture as a linear
    // one.  This needs to be fixed.

    if (PixelJar::IsSwizzled(pTarget))
    {
        if (DBG_CHECK(TRUE))
        {
            DWORD Width = PixelJar::GetWidth(pTarget);
            DWORD Height = PixelJar::GetHeight(pTarget);

            if (DBG_CHECK(Count))
            {
                if (Count != 1
                    || pRects->x1 != 0
                    || pRects->y1 != 0
                    || pRects->x2 != (long)Width
                    || pRects->y2 != (long)Height)
                {
                    D3D_ERR("Swizzled render targets can only be cleared in their entirety.");
                }
            }

            if (pDevice->m_Viewport.X != 0
                || pDevice->m_Viewport.Y
                || (pDevice->m_Viewport.Width != Width)
                || (pDevice->m_Viewport.Height != Height))
            {
                D3D_ERR("Swizzled render targets can only be cleared in their entirety and cannot be restricted by a viewport.");
            }
        }

        SavedFormat = PixelJar::GetSurfaceFormat(pTarget, pZBuffer);

        DWORD NewFormat = SavedFormat & ~DRF_DEF(097, _SET_SURFACE_FORMAT, _TYPE, _SWIZZLE);
        NewFormat |= DRF_DEF(097, _SET_SURFACE_FORMAT, _TYPE, _PITCH);

        pPush = pDevice->StartPush();

        Push1(pPush, NV097_SET_SURFACE_FORMAT, NewFormat);

        pDevice->EndPush(pPush + 2);
    }

    // Get the color to set the target to.

    if (Flags & D3DCLEAR_TARGET)
    {
        D3DFORMAT Format = PixelJar::GetFormat(pTarget);

        switch(Format)
        {
        case D3DFMT_X8R8G8B8:
        case D3DFMT_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_A8R8G8B8:
            break;

        case D3DFMT_R5G6B5:
        case D3DFMT_LIN_R5G6B5:
            Color = ((Color & 0x00F80000) >> 8)
                  | ((Color & 0x0000FC00) >> 5)
                  | ((Color & 0x000000F8) >> 3);
            break;

        case D3DFMT_X1R5G5B5:
        case D3DFMT_LIN_X1R5G5B5:
            Color = ((Color & 0x00F80000) >> 9)
                  | ((Color & 0x0000F800) >> 6)
                  | ((Color & 0x000000F8) >> 3);
            break;

#if DBG

        case D3DFMT_LIN_L8:
        case D3DFMT_LIN_G8B8:
            D3D_ERR("D3DFMT_LIN_L8 and D3DFMT_LIN_G8B8 cannot be cleared via D3DDevice_Clear.");
            break;

#endif

        }
    }

    if (!pZBuffer)
    {
        Flags &= ~(D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL);

        // Nothing to do?  Then do nothing.  (Our init code hits this
        // case when it does the initial Clear and there's no Z-buffer.)

        if (!Flags)
        {
            return;
        }
    }

    if (Flags & D3DCLEAR_ZBUFFER)
    {
        // Adjust the zbuffer fill value.  

        D3DFORMAT Format = PixelJar::GetFormat(pZBuffer);

        // Adjust the z-buffer depth value.  We use doubles for the best
        // accuracy in the conversion to integer:

        switch(Format)
        {
        case D3DFMT_D16:
        case D3DFMT_LIN_D16:

            // Convert to a 16-bit number, with clamp.  Note that to match
            // the hardware, we never round.
            {
                long RawFillDepth;

                RawFillDepth = FloatToLong(Z * (float)D3DZ_MAX_D16);   
                RawFillDepth = (RawFillDepth > 0xffff) ? 0xffff : RawFillDepth;
                RawFillDepth = (RawFillDepth < 0)      ? 0      : RawFillDepth;

                FillDepth  = (DWORD)RawFillDepth;
            }
            break;

        case D3DFMT_D24S8:
        case D3DFMT_LIN_D24S8:

            // Convert to a 24-bit number, with clamp.  Note that to match
            // the hardware, we never round.
            {
                long RawFillDepth;

                RawFillDepth = FloatToLong(Z * (float)D3DZ_MAX_D24S8); 
                RawFillDepth = (RawFillDepth > 0xffffff) ? 0xffffff : RawFillDepth;
                RawFillDepth = (RawFillDepth < 0)        ? 0        : RawFillDepth;

                // The z-buffer occupies the upper 3 bytes:

                FillDepth  = (DWORD)RawFillDepth << 8;  
            }
            break;

        case D3DFMT_F16:
        case D3DFMT_LIN_F16:

            if (Z == 0.0F)
            {
                FillDepth = 0;
            }           
            else
            {
                double ZScaled = (double)Z * D3DZ_MAX_F16;

                DWORD ZBitsH = *((DWORD *)&ZScaled + 1);

                FillDepth = ((ZBitsH >> 8) - 0x3F8000) & 0xFFFF;
            }

            break;

        case D3DFMT_F24S8:
        case D3DFMT_LIN_F24S8:

            if (Z == 0.0F)
            {
                FillDepth = 0;
            }
            else
            {
                double ZScaled = (double)Z * D3DZ_MAX_F24S8;

                DWORD ZBitsH = *((DWORD *)&ZScaled + 1);

                FillDepth = ((ZBitsH - 0x38000000) << 4) & 0xFFFFFF00;
            }

            break;

        default:
            NODEFAULT("D3DDevice_Clear - Unknown depth buffer format\n");
        }
    }

    // We're going to clip to the viewport, so copy it to a more usable
    // form:

    INT x1Clip = pDevice->m_Viewport.X;
    INT y1Clip = pDevice->m_Viewport.Y;
    INT x2Clip = pDevice->m_Viewport.X + pDevice->m_Viewport.Width;
    INT y2Clip = pDevice->m_Viewport.Y + pDevice->m_Viewport.Height;

    // No supplied rectangles means we need to clear the whole surface.

    if (!Count)
    {
        rect.x1 = x1Clip;
        rect.y1 = y1Clip;
        rect.x2 = x2Clip;
        rect.y2 = y2Clip;

        pRects = &rect;
        Count = 1;
    }    

    // Iterate through the rectangles.  Note that we could do a little
    // less work in the case of multiple clear rectangles, but that
    // will be an infrequent case:

    do {
        // Clip the rectangle to the viewport:

        INT x1 = max(pRects->x1, x1Clip);
        INT y1 = max(pRects->y1, y1Clip);
        INT x2 = min(pRects->x2, x2Clip);
        INT y2 = min(pRects->y2, y2Clip);

        // Make sure the result is not empty:

        if ((x1 < x2) && (y1 < y2))
        {
            x1 = Round(x1 * pDevice->m_SuperSampleScaleX);
            x2 = Round(x2 * pDevice->m_SuperSampleScaleX);
            y1 = Round(y1 * pDevice->m_SuperSampleScaleY);
            y2 = Round(y2 * pDevice->m_SuperSampleScaleY);

            pPush = pDevice->StartPush();
    
            PushCount(pPush, NV097_SET_CLEAR_RECT_HORIZONTAL, 2);
    
            // NV097_SET_CLEAR_RECT_HORIZONTAL
    
            *(pPush + 1) 
                = DRF_NUMFAST(097, _SET_CLEAR_RECT_HORIZONTAL, _XMIN, x1) |
                  DRF_NUMFAST(097, _SET_CLEAR_RECT_HORIZONTAL, _XMAX, x2 - 1);
    
            // NV097_SET_CLEAR_RECT_VERTICAL
    
            *(pPush + 2) 
                = DRF_NUMFAST(097, _SET_CLEAR_RECT_VERTICAL, _YMIN, y1) |
                  DRF_NUMFAST(097, _SET_CLEAR_RECT_VERTICAL, _YMAX, y2 - 1);
    
            PushCount(pPush + 3, NV097_SET_ZSTENCIL_CLEAR_VALUE, 3);
    
            // NV097_SET_ZSTENCIL_CLEAR_VALUE
    
            *(pPush + 4) = FillDepth | Stencil;
    
            // NV097_SET_COLOR_CLEAR_VALUE
    
            *(pPush + 5) = Color;
    
            // NV097_CLEAR_SURFACE
            //
            // Writing to this register triggers the clear, so it has to come
            // last:
    
            *(pPush + 6) = Flags;

            // PERF: The Nvidia driver clears in 256-byte vertical bands!

            pDevice->EndPush(pPush + 7);
        }

    } while (++pRects, --Count != 0);

    // Put the original format back.

    if (SavedFormat)
    {
        pPush = pDevice->StartPush();

        Push1(pPush, NV097_SET_SURFACE_FORMAT, SavedFormat);

        pDevice->EndPush(pPush + 2);
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\block.cpp ===
/*============================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       block.cpp
 *  Content:    State block implementation.
 *
 * The whole goal of the Xbox state block implementation is to add as little
 * overhead to non-state-block functionality as is possible.  Specifically, 
 * we have gone out of our way to avoid adding any run-time checks for 
 * 'record' mode to any of our state-setting routines such as SetRenderState.
 *
 * DOC: Need note about how Registered objects are not referenced properly
 *      by state blocks
 *
 ****************************************************************************/

#include "precomp.hpp"
 
// Optimize this module for size:
 
#pragma optimize("s", on)

// !!! Fix state blocks to do render states in reverse order (for ZBIAS)
// !!! Remove random API RECORDSTATE restrictions
// !!! DOC: State programs can modify constant registers and we'll never know
// !!! Gotta fix for 'direct' APIs like SetVertexInputs 
// !!! Add SetScissors support (and to Present!)

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

// Don't use the d3d8.h versions of these macros because we don't compile 
// with D3DCOMPILE_BEGINSTATEBLOCK defined.

#define DIRTY_RENDERSTATE(state)                                     \
    { D3D__StateBlockDirty[D3DSBD_RENDERSTATES + (state)] = TRUE; }

#define DIRTY_TEXTURESTATE(stage, state)                             \
    { D3D__StateBlockDirty[D3DSBD_TEXTURESTATES +                    \
                      ((state) * D3DTSS_MAXSTAGES) + (stage)] = TRUE; } 

//------------------------------------------------------------------------------
// D3D__StateBlockDirty[]
//
// An array of bytes that correspond to changed state between BeginStateBlock 
// and EndStateBlock calls.
//
// NOTE: If the game calls no APIs in this module (as will be the case
//       most of the time), the linker will nicely remove this BIG
//       global allocation:
//
// PERF: Make sure things stay that way!

extern "C" 
{
    BYTE D3D__StateBlockDirty[(D3DSBD_MAX + 3) & ~3];
}

//------------------------------------------------------------------------------
// StateBlock
//
// Structure that we allocate to replay state-blocks when called by
// ApplyStateBlock.

struct StateBlock
{
#if DBG

    DWORD Signature;            // Always 'Sblk'
    DWORD* pDataEnd;            // Points one dword past the last Data[] value

#endif

    // NOTE: Each of the following fields represent the count of their
    //       corresponding entries in the variably-formatted 'Data'
    //       array.
    //
    // NOTE: The order of the variably-formatted 'Data' array also
    //       matches the order in which these fields are listed.
    //
    // NOTE: Pixel shaders REQUIRE that the restore order be:
    //          1. Pixel shader
    //          2. Pixel shader constants
    //          3. Pixel shader render states
    //
    // NOTE: Vertex shaders REQUIRE that the restore order be:
    //          1. Vertex shader
    //          2. Vertex shader constants

    DWORD D0_Textures;             
    BOOL D1_PixelShader;
    BOOL D2_VertexShader;
    BOOL D3_Index;
    DWORD D4_Streams;
    DWORD D6_PixelShaderConstants;
    DWORD D7_VertexShaderConstants;
    DWORD D8_RenderStates;         
    DWORD D9_TextureStates;   
    DWORD D10_Transforms;           
    BOOL D11_Viewport;             
    BOOL D12_Material;             
    BOOL D13_BackMaterial;             
    DWORD D14_Lights;               
    DWORD D15_LightEnables;         

    // Variable length, and Variably formatted data, based on the above:

    DWORD Data[1];
};

//------------------------------------------------------------------------------
// CreateStateBlock functionality groupings

D3DCONST BYTE g_PixelRenderStates[] =
{
    D3DRS_ZENABLE,
    D3DRS_FILLMODE,
    D3DRS_SHADEMODE,
    D3DRS_ZWRITEENABLE,
    D3DRS_ALPHATESTENABLE,
    D3DRS_SRCBLEND,
    D3DRS_DESTBLEND,
    D3DRS_ZFUNC,
    D3DRS_ALPHAREF,
    D3DRS_ALPHAFUNC,
    D3DRS_DITHERENABLE,
    D3DRS_FOGSTART,
    D3DRS_FOGEND,
    D3DRS_FOGDENSITY,
    D3DRS_EDGEANTIALIAS,
    D3DRS_ALPHABLENDENABLE,
    D3DRS_ZBIAS,
    D3DRS_STENCILENABLE,
    D3DRS_STENCILFAIL,
    D3DRS_STENCILZFAIL,
    D3DRS_STENCILPASS,
    D3DRS_STENCILFUNC,
    D3DRS_STENCILREF,
    D3DRS_STENCILMASK,
    D3DRS_STENCILWRITEMASK,
    D3DRS_TEXTUREFACTOR,
    D3DRS_WRAP0,
    D3DRS_WRAP1,
    D3DRS_WRAP2,
    D3DRS_WRAP3,
    D3DRS_COLORWRITEENABLE,
    D3DRS_BLENDOP,
};

CONST DWORD g_PixelRenderStatesCount = sizeof(g_PixelRenderStates) / 
                                       sizeof(g_PixelRenderStates[0]);

D3DCONST BYTE g_PixelTextureStates[] =
{
    D3DTSS_COLOROP,
    D3DTSS_COLORARG1,
    D3DTSS_COLORARG2,
    D3DTSS_ALPHAOP,
    D3DTSS_ALPHAARG1,
    D3DTSS_ALPHAARG2,
    D3DTSS_BUMPENVMAT00,
    D3DTSS_BUMPENVMAT01,
    D3DTSS_BUMPENVMAT10,
    D3DTSS_BUMPENVMAT11,
    D3DTSS_TEXCOORDINDEX,
    D3DTSS_ADDRESSU,
    D3DTSS_ADDRESSV,
    D3DTSS_BORDERCOLOR,
    D3DTSS_MAGFILTER,
    D3DTSS_MINFILTER,
    D3DTSS_MIPFILTER,
    D3DTSS_MIPMAPLODBIAS,
    D3DTSS_MAXMIPLEVEL,
    D3DTSS_MAXANISOTROPY,
    D3DTSS_BUMPENVLSCALE,
    D3DTSS_BUMPENVLOFFSET,
    D3DTSS_TEXTURETRANSFORMFLAGS,
    D3DTSS_ADDRESSW,
    D3DTSS_COLORARG0,
    D3DTSS_ALPHAARG0,
    D3DTSS_RESULTARG,
};

CONST DWORD g_PixelTextureStatesCount = sizeof(g_PixelTextureStates) / 
                                        sizeof(g_PixelTextureStates[0]);

D3DCONST BYTE g_VertexRenderStates[] =
{
    D3DRS_SHADEMODE,
    D3DRS_SPECULARENABLE,
    D3DRS_CULLMODE,
    D3DRS_FOGENABLE,
    D3DRS_FOGCOLOR,
    D3DRS_FOGTABLEMODE,
    D3DRS_FOGSTART,
    D3DRS_FOGEND,
    D3DRS_FOGDENSITY,
    D3DRS_RANGEFOGENABLE,
    D3DRS_AMBIENT,
    D3DRS_COLORVERTEX,
    D3DRS_LIGHTING,
    D3DRS_NORMALIZENORMALS,
    D3DRS_LOCALVIEWER,
    D3DRS_EMISSIVEMATERIALSOURCE,
    D3DRS_AMBIENTMATERIALSOURCE,
    D3DRS_DIFFUSEMATERIALSOURCE,
    D3DRS_SPECULARMATERIALSOURCE,
    D3DRS_VERTEXBLEND,
    D3DRS_POINTSIZE,
    D3DRS_POINTSIZE_MIN,
    D3DRS_POINTSPRITEENABLE,
    D3DRS_POINTSCALEENABLE,
    D3DRS_POINTSCALE_A,
    D3DRS_POINTSCALE_B,
    D3DRS_POINTSCALE_C,
    D3DRS_MULTISAMPLEANTIALIAS,
    D3DRS_MULTISAMPLEMASK,
    D3DRS_PATCHEDGESTYLE,
    D3DRS_PATCHSEGMENTS,
    D3DRS_POINTSIZE_MAX,
};

CONST DWORD g_VertexRenderStatesCount = sizeof(g_VertexRenderStates) / 
                                        sizeof(g_VertexRenderStates[0]);

D3DCONST BYTE g_VertexTextureStates[] =
{
    D3DTSS_TEXCOORDINDEX,
    D3DTSS_TEXTURETRANSFORMFLAGS
};

CONST DWORD g_VertexTextureStatesCount = sizeof(g_VertexTextureStates) / 
                                         sizeof(g_VertexTextureStates[0]);

//------------------------------------------------------------------------------
// ClearStateBlockFlags
//
// Clears all the 'dirty' flags we use to tell when a particular state
// gets modified.

VOID ClearStateBlockFlags()
{
    DWORD i;

    CDevice *pDevice = g_pDevice;

    ZeroMemory(&D3D__StateBlockDirty[0], sizeof(D3D__StateBlockDirty));

    // D14_Lights are special because there can be an arbitrary number of them,
    // so we keep their 'modified' status directly in their structure:

    Light* pLight = pDevice->m_pLights;
    for (i = 0; i < pDevice->m_LightCount; i++, pLight++)
    {
        pLight->Flags &= ~(LIGHT_STATEBLOCK_SET | LIGHT_STATEBLOCK_ENABLED);
    }
}

//------------------------------------------------------------------------------
// RecordStateBlock
//
// Here we run through our 'dirty' list and record any changed states into
// a variable-length, variably formatted allocation.

HRESULT RecordStateBlock(
    DWORD* pToken) 
{ 
    DWORD i;
    DWORD j;
    BYTE* pDirty;
    DWORD numStates; // Total number of states we check (used for an assert)
    StateBlock* pBlock = NULL;
    DWORD* pData = &pBlock->Data[0]; // We never actually dereference NULL

    CDevice* pDevice = g_pDevice;
    Light* pLights = pDevice->m_pLights;

    *pToken = NULL;

    // We always do two passes.  The first pass determines the size of
    // the state block allocation we'll need, and the second pass fills
    // in the state block:

    while (TRUE)
    {
        pDirty = &D3D__StateBlockDirty[0];

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_TEXTURES]);
        for (i = 0; i < D3DTSS_MAXSTAGES; i++)
        {
            if (*pDirty++)
            {
                if (pBlock != NULL)
                {
                    D3DBaseTexture* pTexture = pDevice->m_Textures[i];

                    pBlock->D0_Textures++;
                    pData[0] = i;
                    pData[1] = (DWORD) pTexture;

                    if (pTexture)
                    {
                        pTexture->AddRef();
                    }
                }
                pData += 2;
            }
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_PIXELSHADER]);
        if (*pDirty++)
        {
            if (pBlock != NULL)
            {
                PixelShader* pPixelShader = pDevice->m_pPixelShader;

                pBlock->D1_PixelShader = TRUE;
                pData[0] = (DWORD) pPixelShader;
                if (pPixelShader)
                {
                    pPixelShader->RefCount++;
                }
            }
            pData++;
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_VERTEXSHADER]);
        if (*pDirty++)
        {
            if (pBlock != NULL)
            {
                DWORD handle = pDevice->m_VertexShaderHandle;

                pBlock->D2_VertexShader = TRUE;
                pData[0] = handle;
                if (IsVertexProgram(handle))
                {
                    pDevice->m_pVertexShader->RefCount++;
                }
            }
            pData++;
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_INDICES]);
        if (*pDirty++)
        {
            if (pBlock != NULL)
            {
                D3DIndexBuffer* pIndexBuffer = pDevice->m_pIndexBuffer;

                pBlock->D3_Index = TRUE;
                pData[0] = pDevice->m_IndexBase;
                pData[1] = (DWORD) pIndexBuffer;
                if (pIndexBuffer)
                {
                    pIndexBuffer->AddRef();
                }
            }
            pData += 2;
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_STREAMS]);
        for (i = 0; i < D3DVS_STREAMS_MAX_V1_0; i++)
        {
            if (*pDirty++)
            {
                if (pBlock != NULL)
                {
                    D3DVertexBuffer* pVertexBuffer = g_Stream[i].pVertexBuffer;
    
                    pBlock->D4_Streams++;
                    pData[0] = i;
                    pData[1] = g_Stream[i].Stride;
                    pData[2] = (DWORD) pVertexBuffer;
                    if (pVertexBuffer)
                    {
                        pVertexBuffer->AddRef();
                    }
                }
                pData += 3;
            }
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_PIXELSHADERCONSTANTS]);
        for (i = 0; i < D3DPS_CONSTREG_MAX_DX8; i++)
        {
            if (*pDirty++)
            {
                // We can only call SetPixelShaderConstant if a pixel shader is
                // active, so a corollary is that there's no point in saving the
                // pixel shader constants if no pixel shader is active:

                if (pDevice->m_pPixelShader != NULL)
                {
                    if (pBlock != NULL)
                    {
                        pBlock->D6_PixelShaderConstants++;
                        pData[0] = i;
                        memcpy(pData + 1, &pDevice->m_PixelShaderConstants[i][0],
                               4*sizeof(FLOAT));
                    }
                    pData += 5;
                }
            }
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_VERTEXSHADERCONSTANTS]);
        for (i = 0; i < D3DVS_CONSTREG_COUNT_XBOX; i++)
        {
            if (*pDirty++)
            {
                // We never save the vertex shader constants that map
                // from -96 to -1, although we leave space for them
                // in the 'dirty' array for future expansion:

                if (i >= 96)
                {
                    if (pBlock != NULL)
                    {
                        pBlock->D7_VertexShaderConstants++;
                        pData[0] = i;
                        memcpy(pData + 1, &pDevice->m_VertexShaderConstants[i][0],
                               4*sizeof(FLOAT));
                    }
                    pData += 5;
                }
            }
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_RENDERSTATES]);
        for (i = 0; i < D3DRS_MAX; i++)
        {
            if (*pDirty++)
            {
                // If the fixed function pipeline is active, the shadowed
                // render states for the pixel shader registers are garbage,
                // so don't save those:

                if ((pDevice->m_pPixelShader != NULL) ||
                    (i < D3DRS_PSALPHAINPUTS0) ||
                    ((i > D3DRS_PSINPUTTEXTURE) && (i != D3DRS_PSTEXTUREMODES)))
                {
                    if (pBlock != NULL)
                    {
                        pBlock->D8_RenderStates++;
                        pData[0] = i;
                        pData[1] = D3D__RenderState[i];
                    }
                    pData += 2;
                }
            }
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_TEXTURESTATES]);
        for (j = 0; j < D3DTSS_MAX; j++) // j = 0 .. 29
        {
            for (i = 0; i < D3DTSS_MAXSTAGES; i++) // i = 0 .. 3
            {
                // Note that in the 'dirty' buffer, we always have all the
                // stages for a particular state be consecutive

                if (*pDirty++)
                {
                    if (pBlock != NULL)
                    {
                        pBlock->D9_TextureStates++;
                        pData[0] = i;   // Stage
                        pData[1] = j;   // State
                        pData[2] = D3D__TextureState[i][j];
                    }
                    pData += 3;
                }
            }
        }
        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_TRANSFORMS]);
        for (i = 0; i < D3DTS_MAX; i++)
        {
            if (*pDirty++)
            {
                if (pBlock != NULL)
                {
                    pBlock->D10_Transforms++;
                    pData[0] = i;
                    *((D3DMATRIX*) &pData[1]) = pDevice->m_Transform[i];
                }
                pData += 1 + sizeof(D3DMATRIX) / 4;
            }
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_VIEWPORT]);
        if (*pDirty++)
        {
            if (pBlock != NULL)
            {
                pBlock->D11_Viewport = TRUE;
                *((D3DVIEWPORT8*) &pData[0]) = pDevice->m_Viewport;
            }
            pData += sizeof(D3DVIEWPORT8) / 4;
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_MATERIAL]);
        if (*pDirty++)
        {
            if (pBlock != NULL)
            {
                pBlock->D12_Material = TRUE;
                *((D3DMATERIAL8*) &pData[0]) = pDevice->m_Material;
            }
            pData += sizeof(D3DMATERIAL8) / 4;
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_BACKMATERIAL]);
        if (*pDirty++)
        {
            if (pBlock != NULL)
            {
                pBlock->D13_BackMaterial = TRUE;
                *((D3DMATERIAL8*) &pData[0]) = pDevice->m_BackMaterial;
            }
            pData += sizeof(D3DMATERIAL8) / 4;
        }

        ASSERT(pDirty == &D3D__StateBlockDirty[D3DSBD_MAX]);
        for (i = 0; i < pDevice->m_LightCount; i++)
        {
            if (pLights[i].Flags & LIGHT_STATEBLOCK_SET)
            {
                if (pBlock != NULL)
                {
                    pBlock->D14_Lights++;
                    pData[0] = i;
                    *((D3DLIGHT8*) &pData[1]) = pLights->Light8;
                }
                pData += 1 + sizeof(D3DLIGHT8) / 4;
            }
        }
        for (i = 0; i < pDevice->m_LightCount; i++)
        {
            if (pLights[i].Flags & LIGHT_STATEBLOCK_ENABLED)
            {
                if (pBlock != NULL)
                {
                    pBlock->D15_LightEnables++;
                    pData[0] = i;
                    pDevice->GetLightEnable(i, (BOOL*) &pData[1]);
                }
                pData += 2;
            }
        }

        if (pBlock != NULL)
        {
            ASSERT(pData == pBlock->pDataEnd);

            // We're done!

            *pToken = (DWORD) pBlock;
            return S_OK;                    // =====>
        }

        // Okay, now we know the exact length of the allocation we'll need.
        // So allocate it now and do a second pass where we actually fill
        // in all the data:

        pBlock = (StateBlock*) MemAllocNoZero((DWORD) pData);
        if (pBlock == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // Zero just the header part of the block:

        ZeroMemory(pBlock, offsetof(StateBlock, Data));

        // Now initialize some stuff:

    #if DBG
        pBlock->Signature = 'Sblk';
        pBlock->pDataEnd = (DWORD*) ((BYTE*) pBlock + (DWORD) pData);
    #endif

        pData = &pBlock->Data[0];
    }
}

//------------------------------------------------------------------------------
// D3DDevice_ApplyStateBlock
//
// Plays back a state block.

extern "C"
void WINAPI D3DDevice_ApplyStateBlock(
    DWORD Token) 
{ 
    DWORD i;

    COUNT_API(API_D3DDEVICE_APPLYSTATEBLOCK);

    CDevice* pDevice = g_pDevice;

    StateBlock* pBlock = (StateBlock*) Token;

    if (DBG_CHECK(TRUE))
    {
        if (pBlock == NULL)
        {
            DPF_ERR("NULL parameter");
        }
    #if DBG
        if (pBlock->Signature != 'Sblk')
        {
            DPF_ERR("Invalid state block object (already deleted?)");
        }
    #endif
    }

    DWORD* pData = &pBlock->Data[0];

    for (i = 0; i < pBlock->D0_Textures; i++)
    {
        DWORD stage = pData[0];
        D3DBaseTexture* pTexture = (D3DBaseTexture*) pData[1];

        pDevice->SetTexture(stage, pTexture);

        pData += 2;
    }
    if (pBlock->D1_PixelShader)
    {
        DWORD handle = pData[0];

        pDevice->SetPixelShader(handle);

        pData++;
    }
    if (pBlock->D2_VertexShader)
    {
        DWORD handle = pData[0];

        pDevice->SetVertexShader(handle);

        pData++;
    }
    if (pBlock->D3_Index)
    {
        DWORD indexBase = pData[0];
        D3DIndexBuffer* pIndexBuffer = (D3DIndexBuffer*) pData[1];

        pDevice->SetIndices(pIndexBuffer, indexBase);

        pData += 2;
    }
    for (i = 0; i < pBlock->D4_Streams; i++)
    {
        DWORD index = pData[0];
        DWORD stride = pData[1];
        D3DVertexBuffer* pVertexBuffer = (D3DVertexBuffer*) pData[2];

        pDevice->SetStreamSource(index, pVertexBuffer, stride);

        pData += 3;
    }
    for (i = 0; i < pBlock->D6_PixelShaderConstants; i++)
    {
        DWORD index = pData[0];
        VOID* pConstantData = &pData[1];

        pDevice->SetPixelShaderConstant(index, pConstantData, 1);

        pData += 5;
    }
    for (i = 0; i < pBlock->D7_VertexShaderConstants; i++)
    {
        DWORD index = pData[0];
        VOID* pConstantData = &pData[1];

        // In our state block code here we refer to them as constants 0 to 191,
        // but SetVertexShaderConstant knows of them as -96 to 95:

        pDevice->SetVertexShaderConstant(index - 96, pConstantData, 1);

        pData += 5;
    }
    for (i = 0; i < pBlock->D8_RenderStates; i++)
    {
        DWORD state = pData[0];
        DWORD value = pData[1];

        // On free builds, we do a small optimization where we don't bother
        // to call SetRenderState if the state is already set to the proper
        // value.  We don't do this on checked builds as a small little
        // sanity check to ensure that all of our default values would 
        // actually get through the SetRenderState parameter checking.

    #if !DBG
        if (D3D__RenderState[state] != value)
    #endif
        {
            pDevice->SetRenderStateNotInline((D3DRENDERSTATETYPE) state, value);
        }

        pData += 2;
    }
    for (i = 0; i < pBlock->D9_TextureStates; i++)
    {
        DWORD stage = pData[0];
        DWORD state = pData[1];
        DWORD value = pData[2];

    #if !DBG
        if (D3D__TextureState[stage][state] != value)
    #endif
        {
            pDevice->SetTextureStageStateNotInline(stage, 
                (D3DTEXTURESTAGESTATETYPE) state, value);
        }

        pData += 3;
    }
    for (i = 0; i < pBlock->D10_Transforms; i++)
    {
        DWORD state = pData[0];
        D3DMATRIX* pMatrix = (D3DMATRIX*) &pData[1];

        pDevice->SetTransform((D3DTRANSFORMSTATETYPE) state, pMatrix);

        pData += 1 + sizeof(D3DMATRIX) / 4;
    }
    if (pBlock->D11_Viewport)
    {
        D3DVIEWPORT8* pViewport = (D3DVIEWPORT8*) &pData[0];

        pDevice->SetViewport(pViewport);

        pData += sizeof(D3DVIEWPORT8) / 4;
    }
    if (pBlock->D12_Material)
    {
        D3DMATERIAL8* pMaterial = (D3DMATERIAL8*) &pData[0];

        pDevice->SetMaterial(pMaterial);

        pData += sizeof(D3DMATERIAL8) / 4;
    }
    if (pBlock->D13_BackMaterial)
    {
        D3DMATERIAL8* pMaterial = (D3DMATERIAL8*) &pData[0];

        pDevice->SetBackMaterial(pMaterial);

        pData += sizeof(D3DMATERIAL8) / 4;
    }
    for (i = 0; i < pBlock->D14_Lights; i++)
    {
        DWORD index = pData[0];
        D3DLIGHT8* pLight = (D3DLIGHT8*) &pData[1];

        pDevice->SetLight(index, pLight);

        pData += 1 + sizeof(D3DLIGHT8) / 4;
    }
    for (i = 0; i < pBlock->D15_LightEnables; i++)
    {
        DWORD index = pData[0];
        BOOL enable = pData[1];

        pDevice->LightEnable(index, enable);

        pData += 2;
    }

    ASSERT(pData == pBlock->pDataEnd);
}

//------------------------------------------------------------------------------
// D3DDevice_CaptureStateBlock
//
// Update the values in the block (weird lights being the exception)

extern "C"
void WINAPI D3DDevice_CaptureStateBlock(
    DWORD Token) 
{ 
    DWORD i;

    COUNT_API(API_D3DDEVICE_CAPTURESTATEBLOCK);

    CDevice* pDevice = g_pDevice;

    StateBlock* pBlock = (StateBlock*) Token;

    if (DBG_CHECK(TRUE))
    {
        if (pBlock == NULL)
        {
            DPF_ERR("NULL parameter");
        }
    #if DBG
        if (pBlock->Signature != 'Sblk')
        {
            DPF_ERR("Invalid state block object (already deleted?)");
        }
    #endif
    }

    DWORD* pData = &pBlock->Data[0];

    for (i = 0; i < pBlock->D0_Textures; i++)
    {
        DWORD stage = pData[0];
        D3DBaseTexture* pTexture = (D3DBaseTexture*) pData[1];

        if (pTexture)
        {
            pTexture->Release();
        }
        pTexture = pDevice->m_Textures[stage];
        if (pTexture)
        {
            pTexture->AddRef();
        }
        pData[1] = (DWORD) pTexture;

        pData += 2;
    }
    if (pBlock->D1_PixelShader)
    {
        DWORD handle = pData[0];

        if (handle)
        {
            pDevice->DeletePixelShader(handle);
        }
        handle = (DWORD) pDevice->m_pPixelShader;
        if (handle)
        {
            pDevice->m_pPixelShader->RefCount++;
        }
        pData[0] = handle;

        pData++;
    }
    if (pBlock->D2_VertexShader)
    {
        DWORD handle = pData[0];

        if (IsVertexProgram(handle))
        {
            pDevice->DeleteVertexShader(handle);
        }
        handle = pDevice->m_VertexShaderHandle;
        if (IsVertexProgram(handle))
        {
            pDevice->m_pVertexShader->RefCount++;
        }
        pData[0] = handle;

        pData++;
    }
    if (pBlock->D3_Index)
    {
        D3DIndexBuffer* pIndexBuffer = (D3DIndexBuffer*) pData[1];

        if (pIndexBuffer)
        {
            pIndexBuffer->Release();
        }
        pIndexBuffer = pDevice->m_pIndexBuffer;
        if (pIndexBuffer)
        {
            pIndexBuffer->AddRef();
        }
        pData[0] = pDevice->m_IndexBase;
        pData[1] = (DWORD) pIndexBuffer;

        pData += 2;
    }
    for (i = 0; i < pBlock->D4_Streams; i++)
    {
        DWORD index = pData[0];
        D3DVertexBuffer* pVertexBuffer = (D3DVertexBuffer*) pData[2];

        if (pVertexBuffer)
        {
            pVertexBuffer->Release();
        }
        pVertexBuffer = g_Stream[index].pVertexBuffer;
        if (pVertexBuffer)
        {
            pVertexBuffer->AddRef();
        }
        pData[1] = g_Stream[index].Stride;
        pData[2] = (DWORD) pVertexBuffer;

        pData += 3;
    }
    for (i = 0; i < pBlock->D6_PixelShaderConstants; i++)
    {
        DWORD index = pData[0];
        VOID* pConstantData = &pData[1];

        memcpy(pConstantData, &pDevice->m_PixelShaderConstants[index][0],
               4*sizeof(FLOAT));

        pData += 5;
    }
    for (i = 0; i < pBlock->D7_VertexShaderConstants; i++)
    {
        DWORD index = pData[0];
        VOID* pConstantData = &pData[1];

        memcpy(pConstantData, &pDevice->m_VertexShaderConstants[index][0],
               4*sizeof(FLOAT));

        pData += 5;
    }
    for (i = 0; i < pBlock->D8_RenderStates; i++)
    {
        DWORD state = pData[0];

        pData[1] = D3D__RenderState[state];

        pData += 2;
    }
    for (i = 0; i < pBlock->D9_TextureStates; i++)
    {
        DWORD stage = pData[0];
        DWORD state = pData[1];

        pData[2] = D3D__TextureState[stage][state];

        pData += 3;
    }
    for (i = 0; i < pBlock->D10_Transforms; i++)
    {
        DWORD state = pData[0];

        *((D3DMATRIX*) &pData[1]) = pDevice->m_Transform[state];

        pData += 1 + sizeof(D3DMATRIX) / 4;
    }
    if (pBlock->D11_Viewport)
    {
        *((D3DVIEWPORT8*) &pData[0]) = pDevice->m_Viewport;

        pData += sizeof(D3DVIEWPORT8) / 4;
    }
    if (pBlock->D12_Material)
    {
        *((D3DMATERIAL8*) &pData[0]) = pDevice->m_Material;

        pData += sizeof(D3DMATERIAL8) / 4;
    }
    if (pBlock->D13_BackMaterial)
    {
        *((D3DMATERIAL8*) &pData[0]) = pDevice->m_BackMaterial;

        pData += sizeof(D3DMATERIAL8) / 4;
    }
    for (i = 0; i < pBlock->D14_Lights; i++)
    {
        DWORD index = pData[0];

        *((D3DLIGHT8*) &pData[1]) = pDevice->m_pLights[index].Light8;

        pData += 1 + sizeof(D3DLIGHT8) / 4;
    }
    for (i = 0; i < pBlock->D15_LightEnables; i++)
    {
        DWORD index = pData[0];

        pDevice->GetLightEnable(index, (BOOL*) &pData[1]);

        pData += 2;
    }

    ASSERT(pData == pBlock->pDataEnd);
}

//------------------------------------------------------------------------------
// D3DDevice_DeleteStateBlock

extern "C"
void WINAPI D3DDevice_DeleteStateBlock(
    DWORD Token) 
{ 
    DWORD i;
    DWORD stage;
    DWORD handle;
    D3DBaseTexture* pTexture;
    D3DIndexBuffer* pIndexBuffer;
    D3DVertexBuffer* pVertexBuffer;

    COUNT_API(API_D3DDEVICE_DELETESTATEBLOCK);

    CDevice* pDevice = g_pDevice;
    StateBlock* pBlock = (StateBlock*) Token;

    if (DBG_CHECK(TRUE))
    {
        if (pBlock == NULL)
        {
            DPF_ERR("NULL parameter");
        }

        #if DBG
        
            if (pBlock->Signature != 'Sblk')
            {
                DPF_ERR("Invalid state block object (already deleted?)");
            }
    
            pBlock->Signature = 'xxxx';
    
        #endif
    }

    // Release any referenced objects:

    DWORD* pData = &pBlock->Data[0];

    for (i = 0; i < pBlock->D0_Textures; i++)
    {
        stage = pData[0];
        pTexture = (D3DBaseTexture*) pData[1];
        pData += 2;

        if (pTexture)
        {
            pTexture->Release();
        }
    }
    if (pBlock->D1_PixelShader)
    {
        handle = pData[0];
        pData++;

        // Note this is a reference-counted delete:

        if (handle)
        {
            pDevice->DeletePixelShader(handle);
        }
    }
    if (pBlock->D2_VertexShader)
    {
        handle = pData[0];
        pData++;

        // Don't free the vertex shader if it's actually an FVF:

        if (IsVertexProgram(handle))
        {
            // Note this is a reference-counted delete:
    
            pDevice->DeleteVertexShader(handle);
        }
    }
    if (pBlock->D3_Index)
    {
        pIndexBuffer = (D3DIndexBuffer*) pData[1];
        pData += 2;

        if (pIndexBuffer)
        {
            pIndexBuffer->Release();
        }
    }
    for (i = 0; i < pBlock->D4_Streams; i++)
    {
        pVertexBuffer = (D3DVertexBuffer*) pData[2];
        pData += 3;

        if (pVertexBuffer)
        {
            pVertexBuffer->Release();
        }
    }

    // Free our state block memory:

    MemFree(pBlock);
}

//------------------------------------------------------------------------------
// D3DDevice_CreateStateBlock
//
// Looks at the current state and captures a bunch.
//
// Note that the PC version of DX8 doesn't record the contents of the palette, 
// so neither do we.

extern "C"
HRESULT WINAPI D3DDevice_CreateStateBlock(
    D3DSTATEBLOCKTYPE Type,
    DWORD* pToken) 
{ 
    DWORD i;
    DWORD j;

    COUNT_API(API_D3DDEVICE_CREATESTATEBLOCK);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (pDevice->m_StateFlags & STATE_PUREDEVICE)
        {
            DPF_ERR("Can't use state blocks with a pure device");
            return D3DERR_INVALIDCALL;
        }
        if (pDevice->m_StateFlags & STATE_RECORDBLOCK)
        {
            D3D_ERR("Cannot create state block when in the state record mode. "
                    "CreateStateBlock failed.");
            return D3DERR_INVALIDCALL;
        }
        if (pToken == NULL)
        {
            DPF_ERR("NULL parameter");
            return D3DERR_INVALIDCALL;
        }
        if ((Type < D3DSBT_ALL) || (Type > D3DSBT_VERTEXSTATE))
        {
            DPF_ERR("Invalid Type parameter");
            return D3DERR_INVALIDCALL;
        }
    }

    if (Type == D3DSBT_ALL)
    {
        // Dirty all the state-block dirty flags, so that everything
        // is recorded:

        FillMemory(&D3D__StateBlockDirty[0], 
                   sizeof(D3D__StateBlockDirty), 
                   0xffffffff);

        Light* pLights = pDevice->m_pLights;

        for (i = 0; i < pDevice->m_LightCount; i++)
        {
             if (pLights[i].Flags & LIGHT_SET)
             {
                 pLights[i].Flags |= (LIGHT_STATEBLOCK_SET | 
                                      LIGHT_STATEBLOCK_ENABLED);
             }
        }
    }
    else 
    {
        // First reset all flags, so that no extraneous stuff gets into
        // our state block:

        ClearStateBlockFlags();

        // Now dirty stuff appropriately:

        if (Type == D3DSBT_PIXELSTATE)
        {
            // We have to record the current pixel shader program, all
            // pixel shader constants, and pixel shader related render
            // states and texture stage states.

            D3D__StateBlockDirty[D3DSBD_PIXELSHADER] = TRUE;

            FillMemory(&D3D__StateBlockDirty[D3DSBD_PIXELSHADERCONSTANTS],
                       D3DPS_CONSTREG_MAX_DX8,
                       0xffffffff);

            for (i = 0; i < g_PixelRenderStatesCount; i++)
            {
                DIRTY_RENDERSTATE(g_PixelRenderStates[i]);
            }

            for (i = 0; i < D3DTSS_MAXSTAGES; i++)
            {
                for (j = 0; j < g_PixelTextureStatesCount; j++)
                {
                    DIRTY_TEXTURESTATE(i, g_PixelTextureStates[j]);
                }
            }
        }
        else
        {
            ASSERT(Type == D3DSBT_VERTEXSTATE);

            // We have to record the current vertex shader program, all
            // vertex shader constants, vertex shader related render
            // states and texture stage states, and lights:

            D3D__StateBlockDirty[D3DSBD_VERTEXSHADER] = TRUE;

            FillMemory(&D3D__StateBlockDirty[D3DSBD_VERTEXSHADERCONSTANTS],
                       D3DVS_CONSTREG_COUNT_XBOX,
                       0xffffffff);

            for (i = 0; i < g_VertexRenderStatesCount; i++)
            {
                DIRTY_RENDERSTATE(g_VertexRenderStates[i]);
            }

            for (i = 0; i < D3DTSS_MAXSTAGES; i++)
            {
                for (j = 0; j < g_VertexTextureStatesCount; j++)
                {
                    DIRTY_TEXTURESTATE(i, g_VertexTextureStates[j]);
                }
            }

            Light* pLights = pDevice->m_pLights;

            for (i = 0; i < pDevice->m_LightCount; i++)
            {
                 if (pLights[i].Flags & LIGHT_SET)
                 {
                     pLights[i].Flags |= (LIGHT_STATEBLOCK_SET | 
                                          LIGHT_STATEBLOCK_ENABLED);
                 }
            }
        }
    }

    // Finally, have RecordStateBlock do all the hard work of actually 
    // recording the state:

    return RecordStateBlock(pToken);
}

//------------------------------------------------------------------------------
// D3DDevice_BeginStateBlock
//
// Gets ready to start recording a state block.

extern "C"
void WINAPI D3DDevice_BeginStateBlock() 
{ 
    COUNT_API(API_D3DDEVICE_BEGINSTATEBLOCK);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (pDevice->m_StateFlags & STATE_PUREDEVICE)
        {
            DPF_ERR("Can't use state blocks with a pure device");
        }
        if (pDevice->m_StateFlags & STATE_RECORDBLOCK)
        {
            D3D_ERR("Already in the state record mode. BeginStateBlock failed.");
        }
    }

    pDevice->m_StateFlags |= STATE_RECORDBLOCK;

    ClearStateBlockFlags();
}

//------------------------------------------------------------------------------
// D3DDevice_EndStateBlock
//
// Here we run through our 'dirty' list and record any changed states into
// a variable-length, variably formatted allocation.

extern "C"
HRESULT WINAPI D3DDevice_EndStateBlock(
    DWORD* pToken) 
{
    COUNT_API(API_D3DDEVICE_ENDSTATEBLOCK);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (!(pDevice->m_StateFlags & STATE_RECORDBLOCK))
        {
            D3D_ERR("Not in state record mode. EndStateBlock failed.");
        }
    }

    pDevice->m_StateFlags &= ~STATE_RECORDBLOCK;

    return RecordStateBlock(pToken);
}

//------------------------------------------------------------------------------
// D3DDevice_Suspend

extern "C"
VOID WINAPI D3DDevice_Suspend()
{
    COUNT_API(API_D3DDEVICE_SUSPEND);

    CDevice* pDevice = g_pDevice;

    // Flush any pending lazy state before they take control:

    pDevice->SetStateVB(0);
}

//------------------------------------------------------------------------------
// D3DDevice_Resume

extern "C"
VOID WINAPI D3DDevice_Resume(
    BOOL Reset)
{
    COUNT_API(API_D3DDEVICE_RESUME);

    DWORD token;
    HRESULT result;

    if (DBG_CHECK(TRUE))
    {
        if (Reset > TRUE)
        {
            DPF_ERR("Only TRUE or FALSE are valid arguments");
        }
    }

    if (Reset)
    {
        // We could of course write a bunch of code to handle this more
        // efficiently.  But perf-wise, this is such a painful operation
        // anyways, because we have to hit *all* the hardware registers,
        // I don't think it's worth much development time.  The ugliest part, 
        // though, is that anyone linking to this routine pulls in the whole 
        // D3D__StateBlockDirty global (about 528 bytes).

        result = D3DDevice_CreateStateBlock(D3DSBT_ALL, &token);
        if (DBG_CHECK(result != S_OK))
        {
            DPF_ERR("Resume failed, not enough memory");
        }

        D3DDevice_ApplyStateBlock(token);
        D3DDevice_DeleteStateBlock(token);
    }
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\buffer.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       buffer.cpp
 *  Content:    Implementation of the CBuffer class.
 *
 ***************************************************************************/

#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

/*
 * Vertex buffer
 */

//------------------------------------------------------------------------------
// D3DDevice_CreateVertexBuffer
//
extern "C"
HRESULT WINAPI D3DDevice_CreateVertexBuffer(
    UINT Length,
    DWORD Usage,            // Ignored
    DWORD FVF,              // Ignored
    D3DPOOL Pool,           // Ignored
    D3DVertexBuffer **ppVertexBuffer
    )
{
    COUNT_API(API_D3DDEVICE_CREATEVERTEXBUFFER);

    D3DVertexBuffer *pBuffer;
    void *pData;

    // Allocate the memory for the header.   
    pBuffer = (D3DVertexBuffer *)MemAlloc(sizeof(D3DVertexBuffer));

    if (!pBuffer)
    {
        return E_OUTOFMEMORY;
    }

    // Allocate the memory for the buffer data.
    pData = AllocateContiguousMemory(Length, 0);

    if (!pData)
    {
        MemFree(pBuffer);
        return E_OUTOFMEMORY;
    }

    // Fill in its fields.
    //
    pBuffer->Common = /* initial refcount */ 1 
                      | D3DCOMMON_TYPE_VERTEXBUFFER 
                      | D3DCOMMON_D3DCREATED;

    pBuffer->Data = GetGPUAddress(pData);

    // Return the results.
    *ppVertexBuffer = pBuffer;

    return S_OK;
} 

//----------------------------------------------------------------------------
// Lock a vertex buffer and return a pointer to its data.
//
extern "C"
void WINAPI D3DVertexBuffer_Lock(
    D3DVertexBuffer *pBuffer, 
    UINT OffsetToLock, 
    UINT SizeToLock, 
    BYTE **ppbData, 
    DWORD Flags
    )
{
    COUNT_API(API_D3DVERTEXBUFFER_LOCK);
    CHECK(pBuffer, "D3DVertexBuffer_Lock");

    // Validate the parameters.
    if (DBG_CHECK(TRUE))
    {
        if (OffsetToLock != 0 && SizeToLock == 0)
        {
            DXGRIP("LockBuffer - Unable to lock zero bytes.");
        }
    }

    // Flush the vertex cache unless we're asked not to.
    if (!(Flags & D3DLOCK_NOFLUSH))
    {
        CDevice *pDevice = g_pDevice;

        // Invalidate the vertex cache.
        PPUSH pPush = pDevice->StartPush();

        Push1(pPush, NV097_INVALIDATE_VERTEX_CACHE_FILE, 0);

        pDevice->EndPush(pPush + 2);
    }

    // Make sure that we don't have multiple people partying on the buffer
    // at the same time.  Since the GPU will only ever read from this buffer
    // we only have to wait if we want to write to a part that is already
    // in use.
    //
    if (!(Flags & (D3DLOCK_NOOVERWRITE | D3DLOCK_READONLY)))
    {
        // Wait for the resource to be available.
        BlockOnNonSurfaceResource(pBuffer);
    }

    // Get the data.
    *ppbData = (BYTE *)GetDataFromResource(pBuffer) + OffsetToLock;
}

//----------------------------------------------------------------------------
// Get the description for the vertex buffer.
//
extern "C"
void WINAPI D3DVertexBuffer_GetDesc(
    D3DVertexBuffer *pBuffer, 
    D3DVERTEXBUFFER_DESC *pDesc
    )
{
    COUNT_API(API_D3DVERTEXBUFFER_GETDESC);
    CHECK(pBuffer, "D3DVertexBuffer_GetDesc");

    pDesc->Format = D3DFMT_VERTEXDATA;
    pDesc->Type   = pBuffer->GetType();
}

/*
 * Index buffer
 */

//------------------------------------------------------------------------------
// D3DDevice_CreateIndexBuffer
//
extern "C"
HRESULT WINAPI D3DDevice_CreateIndexBuffer(
    UINT Length,
    DWORD Usage,            // Ignored
    D3DFORMAT Format,
    D3DPOOL Pool,           // Ignored
    D3DIndexBuffer** ppIndexBuffer) 
{ 
    COUNT_API(API_D3DDEVICE_CREATEINDEXBUFFER);

    D3DIndexBuffer *pBuffer;
    void *pData;

    // Allocate the memory for the header and the buffer.
    //
    pBuffer = (D3DIndexBuffer *)MemAllocNoZero(sizeof(D3DIndexBuffer) + Length);

    if (!pBuffer)
    {
        return E_OUTOFMEMORY;
    }

    memset(pBuffer, 0, sizeof(D3DIndexBuffer));

    // Fill in its fields.
    //
    pBuffer->Common = /* initial refcount */ 1 
                      | D3DCOMMON_TYPE_INDEXBUFFER 
                      | D3DCOMMON_D3DCREATED;

    pBuffer->Data = (DWORD)(pBuffer + 1);

    // Return the results.
    *ppIndexBuffer = pBuffer;

    return S_OK;
}

//----------------------------------------------------------------------------
// Get the description for the index buffer.
//
extern "C"
void WINAPI D3DIndexBuffer_GetDesc(
    D3DIndexBuffer *pBuffer, 
    D3DINDEXBUFFER_DESC *pDesc
    )
{
    COUNT_API(API_D3DINDEXBUFFER_GETDESC);
    CHECK(pBuffer, "D3DIndexBuffer_GetDesc");

    pDesc->Format = D3DFMT_INDEX16;
    pDesc->Type   = D3DRTYPE_INDEXBUFFER;
}

/*
 * Palette
 */

//------------------------------------------------------------------------------
// Creates a palette resource, the 'Size' is the number of entries to put in the 
// palette and must be one of 32, 64, 128 or 256.
//
D3DCONST g_PaletteSize[] = { 256, 128, 64, 32 };

extern "C"
HRESULT WINAPI D3DDevice_CreatePalette(
    D3DPALETTESIZE Size, 
    D3DPalette **ppPalette
    )
{
    D3DPalette *pPalette;
    void *pData;

    COUNT_API(API_D3DDEVICE_CREATEPALETTE);

    if (DBG_CHECK(Size >= D3DPALETTE_MAX))
    {
        DPF_ERR("Size must be D3DPALETTESIZE_32, _64, _128, or _256");
    }

    // Allocate the memory for the header.
    pPalette = (D3DPalette *)MemAlloc(sizeof(D3DPalette));

    if (!pPalette)
    {
        return E_OUTOFMEMORY;
    }

    // Allocate the memory for the buffer data.
    pData = AllocateContiguousMemory(g_PaletteSize[Size], 0);

    if (!pData)
    {
        MemFree(pPalette);
        return E_OUTOFMEMORY;
    }

    // Fill in its fields. 

    pPalette->Common  = /* initial refcount */ 1 | D3DCOMMON_TYPE_PALETTE 
                                                 | D3DCOMMON_VIDEOMEMORY
                                                 | D3DCOMMON_D3DCREATED
                                                 | D3DPALETTE_COMMON_VIDEOMEMORY;

    pPalette->Common |= Size << D3DPALETTE_COMMON_PALETTESIZE_SHIFT;

    pPalette->Data = GetGPUAddress(pData);

    // Return the results.

    *ppPalette = pPalette;

    return S_OK;
}

//----------------------------------------------------------------------------
// Lock a palette and return a pointer to its data.
//
extern "C"
void WINAPI D3DPalette_Lock(
    D3DPalette *pPalette, 
    D3DCOLOR **ppColors, 
    DWORD Flags
    )
{
    COUNT_API(API_D3DPALETTE_LOCK);
    CHECK(pPalette, "D3DPalette_Lock");

    // Make sure that we don't have multiple people partying on the buffer
    // at the same time.  Since the GPU will only ever read from this buffer
    // we only have to wait if we want to write to it.
    //
    if (!(Flags & (D3DLOCK_NOOVERWRITE | D3DLOCK_READONLY)))
    {
        BlockOnNonSurfaceResource(pPalette);
    }

    // Get the data.
    *ppColors = (D3DCOLOR *)GetDataFromResource(pPalette);
}

//----------------------------------------------------------------------------
// Return the size of the palette.
//
extern "C"
D3DPALETTESIZE WINAPI D3DPalette_GetSize(
    D3DPalette *pPalette
    )
{
    COUNT_API(API_D3DPALETTE_GETSIZE);
    CHECK(pPalette, "D3DPalette_GetSize");

    return (D3DPALETTESIZE) ((pPalette->Common & D3DPALETTE_COMMON_PALETTESIZE_MASK) 
                                    >> D3DPALETTE_COMMON_PALETTESIZE_SHIFT);
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\d3ddev.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3ddev.cpp
 *  Content:    Direct3D device implementation
 *
 ***************************************************************************/
 
#include "precomp.hpp"
#include "xboxverp.h"

// Push buffer global object.  This will always have the same value as
// g_pDevice but we want to expose it as a different type and the
// compiler is not at all happy with that.
//
XMETAL_PushBuffer *g_pPushBuffer;

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//----------------------------------------------------------------------------
// Global device object.

CDevice* g_pDevice;

CDevice g_Device;

//----------------------------------------------------------------------------
// Direct3D_CreateDevice

extern "C"
HRESULT WINAPI Direct3D_CreateDevice(
    UINT Adapter, 
    D3DDEVTYPE DeviceType, 
    void *pUnused, 
    DWORD Flags, 
    D3DPRESENT_PARAMETERS *pPresentationParams, 
    D3DDevice **ppNewInterface)
{
    COUNT_API(API_DIRECT3D_CREATEDEVICE);

    HRESULT ret;

    // DOC: No multithreading support (D3DCREATE_MULTI_THREADED)
    // DOC: No FPU preserve support (D3DCREATE_FPU_PRESERVE)
    // DOC: D3DSWAPEFFECT_DISCARD does no enforcement on debug builds

    if (DBG_CHECK(TRUE))
    {
        if (NULL == pPresentationParams)
        {
            DPF_ERR("Invalid D3DPRESENT_PARAMETERS pointer, CreateDevice fails");
        }
    
        if (pPresentationParams->BackBufferFormat == D3DFMT_UNKNOWN)
        {
            DPF_ERR("D3DFORMAT_UNKNOWN not allowed on Xbox");
        }
    
        if (Adapter > 1)
        {
            DPF_ERR("Invalid Adapter parameter passed to CreateDevice");
        }

        if (Flags & ~(0x800000FFL))
        {
            DPF_ERR("Invalid BehaviorFlags passed to CreateDevice");
        }
    
        if (pPresentationParams->Windowed != FALSE)
        {
            DPF_ERR("Windowed must be FALSE");
        }
    
        if ((Flags & (D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_MIXED_VERTEXPROCESSING)) != 0)
        {
            D3D_ERR("Only hardware vertex processing supported");
        }
    
        if (DeviceType != D3DDEVTYPE_HAL)
        {
            D3D_ERR("Only HAL devices supported");
        }

        if (!IsValidRenderTargetD3DFORMAT(pPresentationParams->BackBufferFormat))
        {
            D3D_ERR("Only D3DFMT_A8R8G8B8, _X8R8G8B8, _R5G6B5, _X1R5G5B5 (and _LIN versions) supported");
        }

        if (g_pDevice != NULL)
        {
            D3D_ERR("Can't create more than one D3D device");
        }
    }    

    // If the push buffer size was not set by the title then use our defaults.

    if (!CDevice::m_PushBufferSize)
    {
        CDevice::m_PushBufferSize = DEFAULT_PUSH_BUFFER_SIZE;
    }
    
    if (!CDevice::m_PushSegmentSize)
    {
        CDevice::m_PushSegmentSize = DEFAULT_PUSH_BUFFER_SEGMENT_SIZE;
    }

    CDevice* pDevice = &g_Device;

    g_pDevice = pDevice;
    g_pPushBuffer = &g_pDevice->m_Pusher;

    // Do not do this inside of Init because that method is also called
    // from Reset.

    pDevice->m_cRefs = 1;

    ASSERT(STATE_PUREDEVICE == D3DCREATE_PUREDEVICE);

    pDevice->m_StateFlags |= (Flags & STATE_PUREDEVICE);

    // Handle stuff common to both CreateDevice() and Reset():

    ret = pDevice->Init(pPresentationParams);

    if (FAILED(ret))
    {
        WARNING("FATAL: Failed to initialize device object");

        pDevice->UnInit();

        if (ppNewInterface)
        {
            *ppNewInterface = NULL;
        }

        // Zero out the global device and push buffer pointers and the device object

        g_pPushBuffer = NULL;
        g_pDevice = NULL;
        ZeroMemory(pDevice, sizeof(*pDevice));

        return ret;
    }

    // Don't sully our call statistics with what we've set here:

    CLEAR_STATISTICS();

    if (ppNewInterface)
    {
        *ppNewInterface = pDevice;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
// Create the push buffer and set the push buffer segment count.  This must
// be called before calling CreateDevice.

extern "C"
void WINAPI Direct3D_SetPushBufferSize(
    DWORD PushBufferSize, 
    DWORD KickOffSize)
{
    COUNT_API(API_DIRECT3D_SETPUSHBUFFERSIZE);

    if (DBG_CHECK(TRUE))
    {
        if (g_pDevice)
        {
            DXGRIP("Direct3D_SetPushBufferSize - Called when there is an active device.");
        }

        if (KickOffSize & (KickOffSize - 1))
        {
            DXGRIP("Direct3D_SetPushBufferSize - The KickOffSize must be a power of 2.");
        }

        // This size restriction is somewhat arbitrary.  

        if (PushBufferSize < 64 * 1024)
        {
            DXGRIP("Direct3D_SetPushBufferSize - The PushBufferSize must not be less than 64 KB.");
        }

        // The KickOffSize must be more than PUSHER_THRESHOLD_SIZE_PLUS_OVERHEAD.
        // So we somewhat arbitrarily restrict it to being not less than 2048.

        if (KickOffSize < 2048)
        {
            DXGRIP("Direct3D_SetPushBufferSize - KickOffSize must be no less than 2048 bytes.");
        }

        if (PushBufferSize % KickOffSize)
        {
            DXGRIP("Direct3D_SetPushBufferSize - The PushBufferSize must be a multiple of the KickOffSize.");
        }

        if (PushBufferSize / KickOffSize < 4)
        {
            DXGRIP("Direct3D_SetPushBufferSize - A push buffer must have at least 4 segments.");
        }
    }

    CDevice::m_PushBufferSize = PushBufferSize;
    CDevice::m_PushSegmentSize = KickOffSize;
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\combiner.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       combiner.cpp
 *  Content:    Handles the setting of the combiner registers for the
 *              D3D fixed function pipeline
 *
 ***************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#if DBG

#define KELVIN_COMBINER_REG_TEX0               0x00000008      // the combiner's first texture register (data from texture unit 0)

#define TEXTUREPM                       0xCAFEBEEF   // arbitrary identifier
#define TSS_USES_NULL_TEXTURE           0x1

// combiner inputs
typedef enum _kelvinCombinerInput {
    kelvinCombinerInputA = 0,
    kelvinCombinerInputB = 1,
    kelvinCombinerInputC = 2,
    kelvinCombinerInputD = 3,
} kelvinCombinerInput;

// the positions of the inputs in the input control words
static DWORD kelvinCombinerInputShift[4] = {24, 16, 8, 0};

DWORD g_ColorICW[8];
DWORD g_ColorOCW[8];
DWORD g_AlphaICW[8];
DWORD g_AlphaOCW[8];

//---------------------------------------------------------------------------

// Set an alpha input to to 1 or -1

void nvKelvinACSetAlphaInputOne (CDevice* pDevice, kelvinCombinerInput eInput,
                                 DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_0);

    g_AlphaICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT nvKelvinACSelectAlphaInput (CDevice* pDevice, kelvinCombinerInput eInput,
                                    DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                                    BOOL bComplement, BOOL bExpandNormal)
{
    DWORD dwICW = 0;

    switch (D3D__TextureState[dwD3DStage][dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwCombinerStage != 0) { // XBOX: Changed from dwD3DStage
                // Output from previous stage
                dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pDevice->m_Textures[dwD3DStage])) {
                // if we don't actually have a texture, default to the 'current' alpha.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                dwICW |= DRF_NUM (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, KELVIN_COMBINER_REG_TEX0 + dwD3DStage);
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_D);
            break;
        case D3DTA_SPECULAR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
            pDevice->m_StateFlags |= STATE_COMBINERNEEDSSPECULAR;
            break;
        default:
            DXGRIP("unknown / illegal alpha argument '%d' in nvKelvinACSelectAlphaInput",
                 D3D__TextureState[dwD3DStage][dwD3DTSSArg] & D3DTA_SELECTMASK);
    }

    // handle the alpha replicate and complement flags

    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _TRUE);

    bComplement = ((D3D__TextureState[dwD3DStage][dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    g_AlphaICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
    return (0);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT nvKelvinACSelect1 (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Make A input
    hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT nvKelvinACSelect2 (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply D * 1
    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputC, dwHWStage, FALSE);
    hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // A & B default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACModulate (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * B
    hr  = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACAdd (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * 1
    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputC, dwHWStage, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACSub (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * -1
    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputC, dwHWStage, TRUE);
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + -D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACAddSmooth (CDevice* pDevice,DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACBlendAlpha (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage, DWORD dwType)
{
    HRESULT hr;
    DWORD dwTemp;

    // Multiply A * B(alpha)
    hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);

    if (dwType == TEXTUREPM) { // this type defined by us
        // Make B 1 since texture is already pre-multiplied
        nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
        // set type again for making C (1-alpha) below
        dwType = D3DTA_TEXTURE;
    }
    else {
        // Make B alpha, appropriate type
        dwTemp = D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG2];
        D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG2] = dwType;
        hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
        // copy arg2 back
        D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG2] = dwTemp;
    }

    // Make C: 1-alpha, make D: arg2
    dwTemp = D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG1];
    D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG1] = dwType;
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    // copy back to alphaarg1
    D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG1] = dwTemp;
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)
static HRESULT nvKelvinACPremodulate (CDevice* pDevice,DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwTemp;

    if (dwHWStage == 0) { // XBOX: Changed from dwD3DStage
        if(1) { // Xbox removed: D3D__TextureState[dwD3DStage+1][D3DTSS_ALPHAOP] != D3DTOP_DISABLE){
            // make A: alphaArg1(0), make B: texture(1)
             hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
             dwTemp = D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG2];
             D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG2] = D3DTA_TEXTURE;
             hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
             // copy back arg2
             D3D__TextureState[dwD3DStage][D3DTSS_ALPHAARG2] = dwTemp;
        }
        else{
            //asked to do premodulate on a single texture stage -- just pass down
            //the colorarg1
            hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
            nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
        }

    }
    else { // well, right now we only handle two stages (we could compress these)
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
        nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACMultiplyAdd (CDevice* pDevice, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    //set B to 1
    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set D to arg3
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACLerp (CDevice* pDevice, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set C to 1 - arg1
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG0, TRUE, FALSE);
    //set D to arg3
    hr |= nvKelvinACSelectAlphaInput (pDevice, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

void nvConstructKelvinOutputAlphaCombiners (CDevice* pDevice, BOOL bEnable,
                                            DWORD dwHWStage, DWORD dwD3DStage, BOOL bBias, DWORD dwShift, BOOL bOutTemp)
{
    if ((!bEnable) ||
        (D3D__TextureState[dwD3DStage][D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))
    {
        g_AlphaICW[dwHWStage] = 0; // Xbox added
        g_AlphaOCW[dwHWStage] |= (DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_0)  |
                                                        DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_AB_DST, _REG_0)   |
                                                        DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_CD_DST, _REG_0));
        return;
    }

    // select bias operation
    switch (dwShift) {
        case 0:
            g_AlphaOCW[dwHWStage] |= bBias ?
                                                           DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT_BIAS) :
                                                           DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT);
            break;
        case 1:
            g_AlphaOCW[dwHWStage] |= bBias ?
                                                           DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS) :
                                                           DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1);
            break;
        case 2:
            g_AlphaOCW[dwHWStage] |= bBias ?
                                                           // we can't shift by 2 and bias. do the best we can...
                                                           DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS) :
                                                           DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY2);
            break;
        default:
            DXGRIP("illegal shift in nvConstructKelvinOutputAlphaCombiners");
            break;
    }  // switch

    g_AlphaOCW[dwHWStage] |= (DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_MUX_ENABLE, _FALSE) |
                                                    DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_C)    |
                                                    DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_AB_DST, _REG_0)     |
                                                    DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_CD_DST, _REG_0));

    g_AlphaOCW[dwHWStage] |= bOutTemp ?
                                               DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_D) :
                                               DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_C);
}

//---------------------------------------------------------------------------

void ConstructAlphaCombiners (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage, BOOL bStageActive)
{
    DWORD   dwShift;
    BOOL    bBias, bEnable;
    HRESULT hr = 0;

    dwShift = 0;
    bBias   = FALSE;
    bEnable = TRUE;

    g_AlphaICW[dwHWStage] = 0;
    g_AlphaOCW[dwHWStage] = 0;

    if (!bStageActive) {
        // colorop was set to disable
        if (dwHWStage == 0) { // only construct default for stage 0
            // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
            g_AlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
            g_AlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
            nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
        }
        else {
            bEnable = FALSE;
        }
    }

    else {

        switch (D3D__TextureState[dwD3DStage][D3DTSS_ALPHAOP]) {
            default:
            case D3DTOP_DOTPRODUCT3:
                // We treat dot3 like disable because it doesn't really matter.
                // if the colorop is also dot3, then alpha will be overwritten momentarily anyhow.
                // BUGBUG if the colorop is NOT dot3, what the heck does this even mean???
            case D3DTOP_DISABLE:
                if (dwHWStage == 0) { // only construct default for stage 0
                    // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
                    g_AlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
                    g_AlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
                    nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
                }
                else {
                    bEnable = FALSE;
                }
                break;
            case D3DTOP_SELECTARG1:
                hr = nvKelvinACSelect1 (pDevice, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_SELECTARG2:
                hr = nvKelvinACSelect2 (pDevice, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_MODULATE4X:
                dwShift++;
            case D3DTOP_MODULATE2X:
                dwShift++;
            case D3DTOP_MODULATE:
                hr = nvKelvinACModulate (pDevice, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
                dwShift = 1;
            case D3DTOP_ADDSIGNED:   // same as add with following change
                bBias = TRUE;
            case D3DTOP_ADD:
                hr = nvKelvinACAdd (pDevice, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_SUBTRACT:
                hr = nvKelvinACSub (pDevice, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_ADDSMOOTH:
                hr = nvKelvinACAddSmooth (pDevice, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                hr = nvKelvinACBlendAlpha (pDevice, dwHWStage, dwD3DStage, D3DTA_DIFFUSE);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                hr = nvKelvinACBlendAlpha (pDevice, dwHWStage, dwD3DStage, D3DTA_TEXTURE);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                hr = nvKelvinACBlendAlpha (pDevice, dwHWStage, dwD3DStage, D3DTA_TFACTOR);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                hr = nvKelvinACBlendAlpha (pDevice,dwHWStage, dwD3DStage, TEXTUREPM);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                hr = nvKelvinACBlendAlpha (pDevice, dwHWStage, dwD3DStage, D3DTA_CURRENT);
                break;
            case D3DTOP_PREMODULATE:
                hr = nvKelvinACPremodulate (pDevice, dwHWStage, dwD3DStage);
                break;
// BUGBUG
#if 0
            case D3DTOP_ALPHAMODULATE:
                // This is the case where the old D3DRENDERSTATE_TEXTUREMAPBLEND was used with
                // the D3DTBLEND_MODULATE op because the dump translates this into TSS we define
                // a new op that properly handles D3DTBLEND_MODULATE
                // Alpha is obtained by the texture, if it has alpha otherwise it is obtained from
                // the vertex. The dump always sets arg1 to be texture and arg2 to be current
                if (statev.ptexture[0] && statev.ptexture[0]->sd.ddpfPixelFormat.dwRGBAlphaBitMask) {
                    nvKelvinACSelect1(dwHWStage);
                }
                else {
                    nvKelvinACSelect2(dwHWStage);
                }
                break;
#endif
            case D3DTOP_MULTIPLYADD:
                hr = nvKelvinACMultiplyAdd (pDevice, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_LERP:
                hr = nvKelvinACLerp (pDevice, dwHWStage, dwD3DStage);
                break;
        }  // switch

    }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (dwHWStage == 0) {
            // current = diffuse in stage 0
            g_AlphaICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4) |
                                                          DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        else {
            g_AlphaICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_C) |
                                                          DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        nvKelvinACSetAlphaInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    nvConstructKelvinOutputAlphaCombiners (pDevice, bEnable, dwHWStage, dwD3DStage, bBias, dwShift,
                                           D3D__TextureState[dwD3DStage][D3DTSS_RESULTARG] == D3DTA_TEMP);

}

////////////////////////////////////////////////////////////////////////////////

// Set a color input to to 1 or -1

void nvKelvinCCSetColorInputOne (CDevice* pDevice, kelvinCombinerInput eInput,
                                 DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_0);

    g_ColorICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT nvKelvinCCSelectColorInput (CDevice* pDevice, kelvinCombinerInput eInput,
                                    DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                                    BOOL bComplement, BOOL bExpandNormal, BOOL bAlphaReplicate)
{
    DWORD dwICW = 0;

    switch (D3D__TextureState[dwD3DStage][dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwCombinerStage != 0) { // XBOX: Changed from dwD3DStage
                // Output from previous stage
                dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pDevice->m_Textures[dwD3DStage])) {
                // if we don't actually have a texture, default to the 'current'.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                dwICW |= DRF_NUM (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, KELVIN_COMBINER_REG_TEX0 + dwD3DStage);
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_SPECULAR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
            pDevice->m_StateFlags |= STATE_COMBINERNEEDSSPECULAR;
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_D);
            break;
        default:
            DXGRIP("unknown / illegal color argument '%d' in nvKelvinCCSelectColorInput",
                 D3D__TextureState[dwD3DStage][dwD3DTSSArg] & D3DTA_SELECTMASK);
    }

    // Now handle the alpha replicate and complement flags

    bAlphaReplicate |= (D3D__TextureState[dwD3DStage][dwD3DTSSArg] & D3DTA_ALPHAREPLICATE);

    dwICW |= bAlphaReplicate ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _TRUE) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);

    bComplement = ((D3D__TextureState[dwD3DStage][dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    g_ColorICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT nvKelvinCCSelect1 (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // A * 1
    hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT nvKelvinCCSelect2 (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply D * 1
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputC, dwHWStage, FALSE);
    hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // A & B default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulate (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * B
    hr  = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCAdd (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1(B)
    hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // Make B 1
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply 1(C) * D
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputC, dwHWStage, FALSE);
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCSub (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * -1
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputC, dwHWStage, TRUE);
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + -D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCAddSmooth (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, TRUE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCBlendAlpha (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage, DWORD dwType)
{
    HRESULT hr;
    DWORD   dwTemp;

    // Multiply A * B(alpha)
    hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);

    if (dwType == TEXTUREPM) // this type defined by us
    {
        // Make B 1 since texture is already pre-multiplied
        nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
        // set type again for making C (1-alpha) below
        dwType = D3DTA_TEXTURE;
    }
    else
    {
        // Make B alpha, appropriate type
        dwTemp = D3D__TextureState[dwD3DStage][D3DTSS_COLORARG2];
        D3D__TextureState[dwD3DStage][D3DTSS_COLORARG2] = dwType;
        hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, TRUE);
        // copy arg2 back
        D3D__TextureState[dwD3DStage][D3DTSS_COLORARG2] = dwTemp;
    }

    // Make C: 1-alpha, make D: arg2
    dwTemp = D3D__TextureState[dwD3DStage][D3DTSS_COLORARG1];
    D3D__TextureState[dwD3DStage][D3DTSS_COLORARG1] = dwType;
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, TRUE, FALSE, TRUE);
    // copy back to colorarg1
    D3D__TextureState[dwD3DStage][D3DTSS_COLORARG1] = dwTemp;
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)

// Premodulate in stage (i-1) is effectively selectarg1
// Then, in stage i, modulate current color (the above) with texture in stage i
// Then, do the operation chosen for stage i

static HRESULT nvKelvinCCPremodulate (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwTemp;

    if (dwHWStage == 0) { // XBOX: Changed from dwD3DStage
        if (1) { // Xbox removed: D3D__TextureState[1][D3DTSS_COLOROP] != D3DTOP_DISABLE) {
            // This modulates selectarg1(stage0) with texture(stage1) now!
            // The right solution is really to wait and see if there is a stage 1
            // make A: colorArg1(0), make B: texture(nextstage)
            hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            // This is a bit of a hack here since we use colorarg from stage 0
            // but we get the texture from stage 1 (told to in SelectB)
            dwTemp = D3D__TextureState[dwD3DStage][D3DTSS_COLORARG2];
            D3D__TextureState[dwD3DStage][D3DTSS_COLORARG2] = D3DTA_TEXTURE;
            hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
            // reset back arg2
            D3D__TextureState[dwD3DStage][D3DTSS_COLORARG2] = dwTemp;
        }
        else {
            // asked to do premodulate on a single texture stage -- just pass down
            // the colorarg1
            hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
        }
    }
    else // well, right now we only handle two stages (we could compress these)
    {
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
        nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);

        //DCR check for premodulate on stage 0?
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulateAlpha (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage, BOOL bComplement)
{
    HRESULT hr;
    // A * 1
    hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    // Set C alpha(arg1), Set D: arg2
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, bComplement, FALSE, TRUE);
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulateColor (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage, BOOL bComplement)
{
    HRESULT hr;
    // A * B
    hr  = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, bComplement, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    // Set C alpha(arg1), Set D: 1
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, TRUE);
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputD, dwHWStage, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinBumpMap (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwArg1Cache;

    // this is terribly inefficient. we actually burn up a combiner stage doing nothing at all.
    // to make this better, we need a combiner analog to "nextAvailableTextureUnit" and to allow
    // for the possibility that this doesn't get incremented when we parse a D3D combiner stage.
    if (pDevice->m_Textures[dwD3DStage] == NULL) {
        DXGRIP("Setup failure");
        hr = TSS_USES_NULL_TEXTURE;
    }
    else {
        // just pass the result of the last stage on to the next
        dwArg1Cache = D3D__TextureState[dwD3DStage][D3DTSS_COLORARG1];
        D3D__TextureState[dwD3DStage][D3DTSS_COLORARG1] = D3DTA_CURRENT;
        hr = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
        D3D__TextureState[dwD3DStage][D3DTSS_COLORARG1] = dwArg1Cache;
        nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCDotProduct (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply expanded A * expanded B
    hr  = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, TRUE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, TRUE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCMultiplyAdd (CDevice* pDevice, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    // set B to 1
    nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // set D to arg3
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCLerp (CDevice* pDevice, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // set C to 1 - arg1
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG0, TRUE, FALSE, FALSE);
    // set D to arg3
    hr |= nvKelvinCCSelectColorInput (pDevice, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// Set up output combiners

void nvConstructKelvinOutputColorCombiners (CDevice* pDevice, BOOL bEnable, DWORD dwStage,
                                            BOOL bBias, DWORD dwShift, BOOL bDotAB, BOOL bDotCD, BOOL bOutTemp)
{
    if (!bEnable) {
        ASSERT (dwStage > 0);  // stage 0 should always be enabled
        g_ColorOCW[dwStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_0);
        return;
    }

    // select bias operation
    switch (dwShift) {
        case 0:
            g_ColorOCW[dwStage] |= bBias ?
                                                         DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _NOSHIFT_BIAS) :
                                                         DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _NOSHIFT);
            break;
        case 1:
            g_ColorOCW[dwStage] |= bBias ?
                                                         DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1_BIAS) :
                                                         DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1);
            break;
        case 2:
            g_ColorOCW[dwStage] |= bBias ?
                                                         // we can't shift by 2 and bias. do the best we can...
                                                         DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1_BIAS) :
                                                         DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY2);
            break;
        default:
            DXGRIP("illagal shift in nvConstructKelvinOutputColorCombiners");
    }  // switch

    // select mux enable
    g_ColorOCW[dwStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_MUX_ENABLE, _FALSE);

    // select dot enables
    if (bDotAB && bDotCD) {
        g_ColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _AB_DST_ENABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _CD_DST_ENABLE));
        g_ColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_C);
    }
    else if (bDotAB) {
        g_ColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _FALSE)          |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _AB_DST_ENABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _DISABLE));
        g_ColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DST, _REG_C);
    }
    else {
        // select the sum as final result
        g_ColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _FALSE)    |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _FALSE)    |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _DISABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _DISABLE));
        g_ColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_C);
    }

}

//---------------------------------------------------------------------------

BOOL ConstructColorCombiners (CDevice* pDevice, DWORD dwHWStage, DWORD dwD3DStage)
{
    DWORD   dwShift;
    BOOL    bDotProduct, bBias, bEnable, bStageActive;
    HRESULT hr = 0;

    bEnable      = TRUE;
    bStageActive = TRUE;
    bDotProduct  = FALSE;
    bBias        = FALSE;
    dwShift      = 0;

    g_ColorICW[dwHWStage] = 0;
    g_ColorOCW[dwHWStage] = 0;

    switch (D3D__TextureState[dwD3DStage][D3DTSS_COLOROP]) {
        default:
        case D3DTOP_DISABLE:
            if (dwHWStage == 0) { // only construct for stage 0 // XBOX: Changed from dwD3DStage
                // Default is diffuse color, make A=diffuse, B=1, C=D=0
                g_ColorICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
                nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
            }
            else {
                bEnable = FALSE; // don't enable output combiner
            }
            bStageActive = FALSE;
            break;
        case D3DTOP_SELECTARG1:
            hr = nvKelvinCCSelect1 (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_SELECTARG2: // same as 2 from above
            hr = nvKelvinCCSelect2 (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_MODULATE4X:
            dwShift++;
        case D3DTOP_MODULATE2X:
            dwShift++;
        case D3DTOP_MODULATE:
            hr = nvKelvinCCModulate (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
            dwShift = 1;
        case D3DTOP_ADDSIGNED:   // same as add with following change
            bBias = TRUE;
        case D3DTOP_ADD:
            hr = nvKelvinCCAdd (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_SUBTRACT:
            hr = nvKelvinCCSub (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_ADDSMOOTH:
            hr = nvKelvinCCAddSmooth (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            hr = nvKelvinCCBlendAlpha (pDevice, dwHWStage, dwD3DStage, D3DTA_DIFFUSE);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            hr = nvKelvinCCBlendAlpha (pDevice, dwHWStage , dwD3DStage, D3DTA_TEXTURE);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            hr = nvKelvinCCBlendAlpha (pDevice, dwHWStage, dwD3DStage, D3DTA_TFACTOR);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            hr = nvKelvinCCBlendAlpha (pDevice, dwHWStage, dwD3DStage, TEXTUREPM);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            hr = nvKelvinCCBlendAlpha (pDevice, dwHWStage, dwD3DStage, D3DTA_CURRENT);
            break;
        case D3DTOP_PREMODULATE:
            hr = nvKelvinCCPremodulate (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            hr = nvKelvinCCModulateAlpha (pDevice, dwHWStage, dwD3DStage, FALSE);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            hr = nvKelvinCCModulateColor (pDevice, dwHWStage, dwD3DStage, FALSE);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            hr = nvKelvinCCModulateAlpha (pDevice, dwHWStage, dwD3DStage, TRUE); // complement
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            hr = nvKelvinCCModulateColor (pDevice, dwHWStage, dwD3DStage, TRUE); // complement
            break;
        case D3DTOP_BUMPENVMAP:
        case D3DTOP_BUMPENVMAPLUMINANCE:
            hr = nvKelvinBumpMap (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_DOTPRODUCT3:
            hr = nvKelvinCCDotProduct (pDevice, dwHWStage, dwD3DStage);
            bDotProduct = TRUE;
            break;
        case D3DTOP_MULTIPLYADD:
            hr = nvKelvinCCMultiplyAdd (pDevice, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_LERP:
            hr = nvKelvinCCLerp (pDevice, dwHWStage, dwD3DStage);
            break;
    }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (dwHWStage == 0) {
            // current = diffuse in stage 0
            g_ColorICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
        }
        else {
            g_ColorICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_C);
        }
        nvKelvinCCSetColorInputOne (pDevice, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    nvConstructKelvinOutputColorCombiners (pDevice, bEnable, dwHWStage, bBias, dwShift, bDotProduct, FALSE,
                                           D3D__TextureState[dwD3DStage][D3DTSS_RESULTARG] == D3DTA_TEMP);

    return (bStageActive);
}


//------------------------------------------------------------------------------
// LazySetCombiners - corresponds to nvSetKelvinColorCombiners
//
// PERF: Lotsa material here for improvement

BOOL OldLazySetCombiners(
    CDevice* pDevice,
    DWORD* pBuffer)
{
    COUNT_PERF(PERF_SETSTATE_COMBINERS);

    // Only update combiners if there is no active pixel shader:

    if (pDevice->m_pPixelShader == NULL)
    {
        BOOL isStageActive;
        DWORD activeCombinerStagesCount;
        DWORD d3dStage;

        activeCombinerStagesCount = 0;

        do {
            d3dStage = activeCombinerStagesCount;
            if (D3D__RenderState[D3DRS_POINTSPRITEENABLE])
            {
                d3dStage = 3;

                if (pDevice->m_Textures[3] == NULL)
                {
                #if DBG
                    static WasWarned = FALSE;
                    if (!WasWarned)
                    {
                        WARNING("Point sprites are enabled but no texture is "
                                 "selected in stage 3.\n"
                                 "Xbox requires point sprites to use stage 3, "
                                 "not stage 0.");
                        WasWarned = TRUE;
                    }
                #endif
                }
            }

            isStageActive = ConstructColorCombiners(pDevice,
                                                    activeCombinerStagesCount,
                                                    d3dStage);

            ConstructAlphaCombiners(pDevice,
                                    activeCombinerStagesCount,
                                    d3dStage,
                                    isStageActive);

            if ((isStageActive) || (activeCombinerStagesCount == 0)) 
            {
                activeCombinerStagesCount++;
            }

        } while ((isStageActive) && (d3dStage < 3));

        // clear all the unused stages:

        for (DWORD i = activeCombinerStagesCount; i < NUM_COMBINERS; i++) 
        {
            g_ColorICW[i] = 0;
            g_ColorOCW[i] = 0;
            g_AlphaICW[i] = 0;
            g_AlphaOCW[i] = 0;
        }

        for (i = 0; i < 8; i++)
        {
            if (g_ColorICW[i] != pBuffer[1 + i])
            {
                _asm int 3;
                return FALSE;
            }
            if (g_ColorOCW[i] != pBuffer[10 + i])
            {
                _asm int 3;
                return FALSE;
            }
            if (g_AlphaICW[i] != pBuffer[19 + i])
            {
                _asm int 3;
                return FALSE;
            }
            if (g_AlphaOCW[i] != pBuffer[28 + i])
            {
                _asm int 3;
                return FALSE;
            }
        }
    }

    return TRUE;
}

#endif

























//------------------------------------------------------------------------------
// Combiner flags:

#define CFLAG_COMPLEMENT        0x010   // D3DTA_COMPLEMENT
#define CFLAG_ALPHAREPLICATE    0x020   // D3DTA_ALPHAREPLICATE
#define CFLAG_EXPANDNORMAL      0x040   // NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL

#define CFLAG_INPUT_SHIFT       16
#define CFLAG_INPUT_MASK        0xf0000
#define CFLAG_INPUT_A           0x30000
#define CFLAG_INPUT_B           0x20000
#define CFLAG_INPUT_C           0x10000
#define CFLAG_INPUT_D           0x00000

//------------------------------------------------------------------------------
// Combiner state:

#define CSTATE_ALPHAOFFSET      0x048   // 18*4 = 72 bytes
#define CSTATE_STAGE_MASK       0x003   // D3D stage
#define CSTATE_FIRSTSTAGE       0x010
#define CSTATE_ALPHAREPLICATE   0x020   // D3DTA_ALPHAREPLICATE
#define CSTATE_NEXTSTAGE        0x080

//------------------------------------------------------------------------------
// Set a color input to to 1 or -1

static DWORD CombinerOne(
    DWORD Flags)
{
    DWORD icw;

    if (Flags & CFLAG_COMPLEMENT)
    {
        icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else
    {
        icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT);
    }

    // Shift left by (8 * input):

    return icw << ((Flags & CFLAG_INPUT_MASK) >> (CFLAG_INPUT_SHIFT - 3));
}

//------------------------------------------------------------------------------
// Select the source for combiner input 

static DWORD CombinerInput(
    DWORD Flags,
    DWORD State,
    DWORD Arg)
{
    DWORD icw;
    DWORD stage;

    switch (Arg & D3DTA_SELECTMASK)
    {
    case D3DTA_TEXTURE:
        stage = State & CSTATE_STAGE_MASK;
        if (g_Device.m_Textures[stage] == NULL)
        {
            // If there's no texture, default to the current.  We'll catch
            // this invalid value later:

            icw = 0xffffffff; 
        }
        else
        {
            icw = DRF_NUMFAST(097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, 8 + stage);
        }
        break;
    case D3DTA_TFACTOR:
        icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_1);
        break;
    case D3DTA_SPECULAR:
        icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
        g_Device.m_StateFlags |= STATE_COMBINERNEEDSSPECULAR;
        break;
    case D3DTA_TEMP:
        icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_D);
        break;
    case D3DTA_CURRENT:
        if (!(State & CSTATE_FIRSTSTAGE))
        {
            // Output from previous stage:

            icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_C);
            break;
        }
        // Fall through...
    case D3DTA_DIFFUSE:
        icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_4);
        break;
    default:
        NODEFAULT("Unexpected color argument\n");
    }

    // Now handle the alpha replicate and complement flags:

    ASSERT(CFLAG_ALPHAREPLICATE == D3DTA_ALPHAREPLICATE);
    ASSERT(CFLAG_ALPHAREPLICATE == CSTATE_ALPHAREPLICATE);
    ASSERT((CFLAG_ALPHAREPLICATE >> 1) 
            == DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _TRUE));

    DWORD alphaReplication = (Flags | Arg | State) & CFLAG_ALPHAREPLICATE;
    icw |= (alphaReplication >> 1);

    ASSERT(CFLAG_COMPLEMENT == D3DTA_COMPLEMENT);
    ASSERT((CFLAG_COMPLEMENT << 1)
           == DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT));
    ASSERT(CFLAG_EXPANDNORMAL 
           == DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL));

    BOOL complement = (Flags ^ Arg) & CFLAG_COMPLEMENT;
    icw |= ((complement << 1) | (Flags & CFLAG_EXPANDNORMAL));

    // Shift left by (8 * input):

    return icw << ((Flags & CFLAG_INPUT_MASK) >> (CFLAG_INPUT_SHIFT - 3));
}

//------------------------------------------------------------------------------
// Select the input into A

static DWORD CombinerSelect1(
    DWORD State,
    DWORD Arg1)
{
    // A * 1

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg1);
    icw |= CombinerOne(CFLAG_INPUT_B);

    // C & D default to zero

    return icw;
}

//------------------------------------------------------------------------------
// Select the input into D

static DWORD CombinerSelect2(
    DWORD State,
    DWORD Arg2)
{
    // Multiply D * 1

    DWORD icw = CombinerOne(CFLAG_INPUT_C);
    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    // A & B default to zero

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerModulate(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2)
{
    // Multiply A * B

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg1);
    icw |= CombinerInput(CFLAG_INPUT_B, State, Arg2);

    // C & D default to zero

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerAdd(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2)
{
    // Multiply A * 1(B)

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg1);

    // Make B 1

    icw |= CombinerOne(CFLAG_INPUT_B);

    // Multiply 1(C) * D

    icw |= CombinerOne(CFLAG_INPUT_C);
    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    // Implicit A + D

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerSub(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2)
{
    // Multiply A * 1

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg1);
    icw |= CombinerOne(CFLAG_INPUT_B);

    // Multiply D * -1

    icw |= CombinerOne(CFLAG_INPUT_C | CFLAG_COMPLEMENT);
    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    // Implicit A + -D

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerAddSmooth(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2)
{
    // Multiply A * 1

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg1);
    icw |= CombinerOne(CFLAG_INPUT_B);

    // Make C: (1-arg1), make D: arg2

    icw |= CombinerInput(CFLAG_INPUT_C | CFLAG_COMPLEMENT, State, Arg1);
    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerBlendAlpha(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Type)
{
    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg1);
    icw |= CombinerInput(CFLAG_INPUT_B | CFLAG_ALPHAREPLICATE, State, Type);

    // Make C: 1-alpha, make D: arg2

    icw |= CombinerInput(
                CFLAG_INPUT_C | CFLAG_COMPLEMENT | CFLAG_ALPHAREPLICATE,
                State, Type);
    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerBlendAlphaPM(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2)
{
    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg1);

    // Make B 1 since texture is already pre-multiplied

    icw |= CombinerOne(CFLAG_INPUT_B);

    // Make C: 1-alpha, make D: arg2

    icw |= CombinerInput(
                CFLAG_INPUT_C | CFLAG_COMPLEMENT | CFLAG_ALPHAREPLICATE,
                State, D3DTA_TEXTURE);
    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    return icw;
}

//------------------------------------------------------------------------------
// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)
//
// Premodulate in stage (i-1) is effectively selectarg1
// Then, in stage i, modulate current color (the above) with texture in stage i
// Then, do the operation chosen for stage i

static DWORD CombinerPremodulate(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2)
{
    DWORD icw = 0;

    if (State & CSTATE_FIRSTSTAGE)
    {
        DWORD stage = State & CSTATE_STAGE_MASK;
        DWORD op = (State & CSTATE_ALPHAREPLICATE) ? D3DTSS_ALPHAOP : D3DTSS_COLOROP;

        ASSERT((stage < 3) && 
               (D3D__TextureState[stage + 1][op] != D3DTOP_DISABLE));

        // This modulates selectarg1(stage0) with texture(stage1) now!
        // The right solution is really to wait and see if there is a stage 1
        // make A: colorArg1(0), make B: texture(nextstage)

        icw |= CombinerInput(CFLAG_INPUT_A, State, Arg1);

        // This is a bit of a hack here since we use colorarg from stage 0
        // but we get the texture from stage 1 (told to in SelectB)

        icw |= CombinerInput(CFLAG_INPUT_B, State, D3DTA_TEXTURE);
    }
    else 
    {
        // Well, right now we only handle two stages (we could compress these)
        //
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1

        icw |= CombinerInput(CFLAG_INPUT_A, State, Arg1);

        icw |= CombinerOne(CFLAG_INPUT_B);

        // Check for premodulate on stage 0?
    }

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerModulateAlpha(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Flags)    // CFLAG_COMPLEMENT or 0
{
    // A * 1

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg1);
    icw |= CombinerOne(CFLAG_INPUT_B);

    // Set C alpha(arg1), Set D: arg2

    icw |= CombinerInput(CFLAG_INPUT_C | CFLAG_ALPHAREPLICATE | Flags, 
                          State, Arg1);
    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerModulateColor(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Flags)    // CFLAG_COMPLEMENT or 0
{
    // A * B

    DWORD icw = CombinerInput(CFLAG_INPUT_A | Flags, State, Arg1);
    icw |= CombinerInput(CFLAG_INPUT_B, State, Arg2);

    // Set C alpha(arg1), Set D: 1

    icw |= CombinerInput(CFLAG_INPUT_C | CFLAG_ALPHAREPLICATE, State, Arg1);
    icw |= CombinerOne(CFLAG_INPUT_D);

    return icw;
}

//------------------------------------------------------------------------------

static DWORD NewKelvinBumpMap(
    DWORD State,
    DWORD Arg1)
{
    // This is terribly inefficient. we actually burn up a combiner stage doing 
    // nothing at all.  

    DWORD stage = (State & CSTATE_STAGE_MASK);

    if (DBG_CHECK(g_pDevice->m_Textures[stage] == NULL))
    {
        DXGRIP("D3DTOP_BUMPENVMAP requires a texture to be set in the "
               "corresponding stage\n");
    }

    // Just pass the result of the last stage on to the next:

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, D3DTA_CURRENT);
    icw |= CombinerOne(CFLAG_INPUT_B);

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerDotProduct(
    DWORD State,
    DWORD Arg1,
    DWORD Arg2)
{
    // Multiply expanded A * expanded B

    DWORD icw = CombinerInput(CFLAG_INPUT_A | CFLAG_EXPANDNORMAL, State, Arg1);
    icw |= CombinerInput(CFLAG_INPUT_B | CFLAG_EXPANDNORMAL, State, Arg2);

    // C & D default to zero

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerMultiplyAdd(
    DWORD State,
    DWORD Arg0,
    DWORD Arg1,
    DWORD Arg2)
{
    // Set A to arg1

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg0);

    // Set B to 1

    icw |= CombinerOne(CFLAG_INPUT_B);

    // Set C to arg2

    icw |= CombinerInput(CFLAG_INPUT_C, State, Arg1);

    // Set D to arg3

    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    return icw;
}

//------------------------------------------------------------------------------

static DWORD CombinerLerp(
    DWORD State,
    DWORD Arg0,
    DWORD Arg1,
    DWORD Arg2)
{

    // Multiply A * B

    DWORD icw = CombinerInput(CFLAG_INPUT_A, State, Arg0);
    icw |= CombinerInput(CFLAG_INPUT_B, State, Arg1);

    // Set C to 1 - arg1

    icw |= CombinerInput(CFLAG_INPUT_C | CFLAG_COMPLEMENT, State, Arg0);

    // Set D to arg3

    icw |= CombinerInput(CFLAG_INPUT_D, State, Arg2);

    return icw;
}

//------------------------------------------------------------------------------
// LazySetCombiners

VOID LazySetCombiners(
    CDevice* pDevice)
{
    DWORD controlWords[4*9];

    COUNT_PERF(PERF_SETSTATE_COMBINERS);

    // Only update combiners if there is no active pixel shader:

    if (pDevice->m_pPixelShader != NULL)
        return;

    // Reset the combiner-needs-specular flag, because we're going to
    // recompute it:

    DWORD oldStateFlags = pDevice->m_StateFlags;
    pDevice->m_StateFlags &= ~STATE_COMBINERNEEDSSPECULAR;

    DWORD startStage = 0;
    if (D3D__RenderState[D3DRS_POINTSPRITEENABLE])
    {
        startStage = 3;
    #if DBG
        if (pDevice->m_Textures[3] == NULL)
        {
            static WasWarned = FALSE;
            if (!WasWarned)
            {
                WARNING("Point sprites are enabled but no texture is "
                         "selected in stage 3.\n"
                         "Xbox requires point sprites to use stage 3, "
                         "not stage 0.");
                WasWarned = TRUE;
            }
        }
    #endif
    }

    DWORD* pBuffer = &controlWords[1];
    DWORD stage = startStage;
    DWORD state = stage | CSTATE_FIRSTSTAGE;

    DWORD* pState = &D3D__TextureState[stage][0];
    DWORD op = pState[D3DTSS_COLOROP];

    do {
        DWORD arg0 = pState[D3DTSS_COLORARG0];
        DWORD arg1 = pState[D3DTSS_COLORARG1];
        DWORD arg2 = pState[D3DTSS_COLORARG2];
        DWORD ocwResult = (pState[D3DTSS_RESULTARG] == D3DTA_TEMP)
                        ? DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_D)
                        : DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_C);

        while (TRUE)
        {
            if (DBG_CHECK(state & CSTATE_ALPHAREPLICATE))
            {
                if ((op == D3DTOP_MODULATEALPHA_ADDCOLOR) ||
                    (op == D3DTOP_MODULATECOLOR_ADDALPHA) ||
                    (op == D3DTOP_MODULATEINVALPHA_ADDCOLOR) ||
                    (op == D3DTOP_MODULATEINVCOLOR_ADDALPHA) ||
                    (op == D3DTOP_DOTPRODUCT3) ||
                    (op == D3DTOP_BUMPENVMAP) ||
                    (op == D3DTOP_BUMPENVMAPLUMINANCE))
                {
                    DXGRIP("Illegal ALPHAOP: %li\n", op);
                }
            }

            DWORD icw;
            DWORD ocw = ocwResult;

            switch (op)
            {
            case D3DTOP_DISABLE:
                if (state & CSTATE_FIRSTSTAGE)
                {
                    // Default is diffuse color, make A=diffuse, B=1, C=0, D=0:

                    ASSERT((CSTATE_ALPHAREPLICATE << 23)
                        == DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_A_ALPHA, _TRUE));

                    icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4)
                        | DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_B_MAP, _UNSIGNED_INVERT)
                        | ((state & CSTATE_ALPHAREPLICATE) << 23);

                    // If COLOROP is DISABLE, set the defaults and finish:

                    if (!(state & CSTATE_ALPHAREPLICATE))
                    {
                        *(pBuffer + 0) = icw;
                        *(pBuffer + 9) = ocw;
                        *(pBuffer + 18) = icw 
                            | DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_A_ALPHA, _TRUE);
                        *(pBuffer + 27) = ocw;
                        pBuffer++;
                        stage++;

                        goto AllDone;
                    }
                }
                else
                {
                    // The COLOROP is enabled, but this is the ALPHAOP and it's
                    // disabled.  Don't enable the combiner:

                    ocw = 0;
                    icw = 0;
                }
                break;
            case D3DTOP_SELECTARG1:
                icw = CombinerSelect1(state, arg1);
                break;
            case D3DTOP_SELECTARG2:
                icw = CombinerSelect2(state, arg2);
                break;
            case D3DTOP_MODULATE4X:
                ocw |= DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY2);
                icw = CombinerModulate(state, arg1, arg2);
                break;
            case D3DTOP_MODULATE2X:
                ocw |= DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1);
                // Fall through...
            case D3DTOP_MODULATE:
                icw = CombinerModulate(state, arg1, arg2);
                break;
            case D3DTOP_ADDSIGNED2X:
                ocw |= DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1_BIAS);
                // Fall through...
            case D3DTOP_ADDSIGNED:
                ocw |= DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_OP, _NOSHIFT_BIAS);
                // Fall through...
            case D3DTOP_ADD:
                icw = CombinerAdd(state, arg1, arg2);
                break;
            case D3DTOP_SUBTRACT:
                icw = CombinerSub(state, arg1, arg2);
                break;
            case D3DTOP_ADDSMOOTH:
                icw = CombinerAddSmooth(state, arg1, arg2);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
            case D3DTOP_BLENDCURRENTALPHA:
            case D3DTOP_BLENDTEXTUREALPHA:
            case D3DTOP_BLENDFACTORALPHA:
                ASSERT(D3DTOP_BLENDCURRENTALPHA - D3DTOP_BLENDDIFFUSEALPHA
                        == D3DTA_CURRENT - D3DTA_DIFFUSE);
                ASSERT(D3DTOP_BLENDTEXTUREALPHA - D3DTOP_BLENDDIFFUSEALPHA
                        == D3DTA_TEXTURE - D3DTA_DIFFUSE);
                ASSERT(D3DTOP_BLENDFACTORALPHA - D3DTOP_BLENDDIFFUSEALPHA
                        == D3DTA_TFACTOR - D3DTA_DIFFUSE);

                icw = CombinerBlendAlpha(state, arg1, arg2, 
                            op - D3DTOP_BLENDDIFFUSEALPHA + D3DTA_DIFFUSE);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                icw = CombinerBlendAlphaPM(state, arg1, arg2);
                break;
            case D3DTOP_PREMODULATE:
                icw = CombinerPremodulate(state, arg1, arg2);
                break;
            case D3DTOP_MODULATEALPHA_ADDCOLOR:
                icw = CombinerModulateAlpha(state, arg1, arg2, 0);
                break;
            case D3DTOP_MODULATECOLOR_ADDALPHA:
                icw = CombinerModulateColor(state, arg1, arg2, 0);
                break;
            case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
                icw = CombinerModulateAlpha(state, arg1, arg2, CFLAG_COMPLEMENT);
                break;
            case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
                icw = CombinerModulateColor(state, arg1, arg2, CFLAG_COMPLEMENT);
                break;
            case D3DTOP_BUMPENVMAP:
            case D3DTOP_BUMPENVMAPLUMINANCE:
                icw = NewKelvinBumpMap(state, arg1);
                break;
            case D3DTOP_DOTPRODUCT3:
                icw = CombinerDotProduct(state, arg1, arg2);
                ASSERT(((DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_D)) >> 4)
                      == DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_AB_DST, _REG_D));
                ocw >>= 4;
                ocw |= (DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _TRUE)           |
                        DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _FALSE)          |
                        DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _AB_DST_ENABLE) |
                        DRF_DEF(097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _DISABLE));

                // Disable ICW and OCW for alpha:

                *(pBuffer + 18) = 0;    
                *(pBuffer + 27) = 0;
                state |= CSTATE_NEXTSTAGE;
                break;
            case D3DTOP_MULTIPLYADD:
                icw = CombinerMultiplyAdd(state, arg0, arg1, arg2);
                break;
            case D3DTOP_LERP:
                icw = CombinerLerp(state, arg0, arg1, arg2);
                break;
            default:
                NODEFAULT("Unexpected OP\n");
            }

            if ((icw & 0xff000000) == 0xff000000)
            {
                // This stage references a non-existent texture.  Just set it 
                // back to "select current":

                if (state & CSTATE_FIRSTSTAGE)
                {
                    // Current = diffuse in stage 0

                    icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4)
                        | DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_B_MAP, _UNSIGNED_INVERT);
                }
                else
                {
                    icw = DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_C)
                        | DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_B_MAP, _UNSIGNED_INVERT);
                }

                ASSERT((CSTATE_ALPHAREPLICATE << 23)
                    == DRF_DEF(097, _SET_COMBINER_COLOR, _ICW_A_ALPHA, _TRUE));

                icw |= ((state & CSTATE_ALPHAREPLICATE) << 23);
            }

            DWORD alphaOffset = (state & CSTATE_ALPHAOFFSET);

            *(DWORD*)((BYTE*) pBuffer + alphaOffset) = icw;
            *(DWORD*)((BYTE*) pBuffer + alphaOffset + 9*4) = ocw;

            if (state & CSTATE_NEXTSTAGE)
                goto NextStage;         //=====>

            // For alpha, always enable alpha replication:

            state |= (CSTATE_ALPHAREPLICATE | CSTATE_ALPHAOFFSET | CSTATE_NEXTSTAGE);

            arg0 = pState[D3DTSS_ALPHAARG0];
            arg1 = pState[D3DTSS_ALPHAARG1];
            arg2 = pState[D3DTSS_ALPHAARG2];
            op = pState[D3DTSS_ALPHAOP];
        }

NextStage:

        pBuffer++;
        stage++;
        if (stage == 4)
            goto AllDone;

        state = stage;
        pState = &D3D__TextureState[stage][0];
        op = pState[D3DTSS_COLOROP];

    } while (op != D3DTOP_DISABLE);

AllDone:

    // Clear any unused stages:

    DWORD usedStages = stage - startStage;
    DWORD unusedStages = 8 - usedStages;

    ASSERT((usedStages >= 1) && (usedStages <= 4));

    do {
        *(pBuffer) = 0;
        *(pBuffer + 9) = 0;
        *(pBuffer + 18) = 0;
        *(pBuffer + 27) = 0;
        pBuffer++;

    } while (--unusedStages != 0);

    controlWords[0] = PUSHER_METHOD(SUBCH_3D, NV097_SET_COMBINER_COLOR_ICW(0), 8);
    controlWords[9] = PUSHER_METHOD(SUBCH_3D, NV097_SET_COMBINER_COLOR_OCW(0), 8);
    controlWords[18] = PUSHER_METHOD(SUBCH_3D, NV097_SET_COMBINER_ALPHA_ICW(0), 8);
    controlWords[27] = PUSHER_METHOD(SUBCH_3D, NV097_SET_COMBINER_ALPHA_OCW(0), 8);

#if DBG
    if (!OldLazySetCombiners(pDevice, &controlWords[0]))
        LazySetCombiners(pDevice);
#endif

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, 
          NV097_SET_COMBINER_CONTROL, 
          (DRF_NUMFAST(097, _SET_COMBINER_CONTROL, _ITERATION_COUNT, usedStages) |
           DRF_DEF(097, _SET_COMBINER_CONTROL, _MUX_SELECT, _LSB) |
           DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR0, _SAME_FACTOR_ALL) |
           DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR1, _SAME_FACTOR_ALL)));

    memcpy((VOID*) (pPush + 2), &controlWords[0], sizeof(controlWords));

    pPush += 2 + sizeof(controlWords) / 4;

    PushedRaw(pPush);

    // Hit the specular-enable register if the specular-needed state changes,
    // and specular isn't already enabled via the render state:

    if ((pDevice->m_StateFlags ^ oldStateFlags) & STATE_COMBINERNEEDSSPECULAR)
    {
        if (!D3D__RenderState[D3DRS_SPECULARENABLE])
        {
            Push1(pPush, 
                  NV097_SET_SPECULAR_ENABLE, 
                  (pDevice->m_StateFlags & STATE_COMBINERNEEDSSPECULAR) != 0);

            pPush += 2;
        }
    }

    pDevice->EndPush(pPush);
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\d3dbase.cpp ===
//depot/xbox/private/windows/directx/dxg/d3d8/se/d3dbase.cpp#125 - edit change 24474 (text)
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3dbase.cpp
 *  Content:    Direct3D base device implementation
 *
 ***************************************************************************/

#include "precomp.hpp"

// Tell the linker to merge constant data and data sections into code section.
#pragma comment(linker, "/merge:D3D_RD=D3D")
#pragma comment(linker, "/merge:D3D_RW=D3D")
#pragma comment(linker, "/merge:D3D_URW=D3D")

// Tell the linker that the code section contains read/write data.
#pragma comment(linker, "/section:D3D,ERW")

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

//------------------------------------------------------------------------------
// g_DeviceCaps

D3DCONST D3DCAPS8 g_DeviceCaps = 
{
   D3DDEVTYPE_HAL                           , // DeviceType               
   0x0                                      , // AdapterOrdinal           
   KELVIN_CAPS_CAPS                         , // Caps                     
   0                                        , // Caps2                    
   0x0                                      , // Caps3                   
   D3DPRESENT_INTERVAL_ONE | D3DPRESENT_INTERVAL_TWO | D3DPRESENT_INTERVAL_IMMEDIATE                                
                                            , // PresentationIntervals    
   0x0                                      , // CursorCaps               
   KELVIN_DEVCAPS_FLAGS                     , // DevCaps                  
   KELVIN_TRICAPS_MISC                      , // PrimitiveMiscCaps        
   KELVIN_TRICAPS_RASTER                    , // RasterCaps               
   KELVIN_TRICAPS_ZCMP                      , // ZCmpCaps                 
   KELVIN_TRICAPS_SRCBLEND                  , // SrcBlendCaps             
   KELVIN_TRICAPS_DESTBLEND                 , // DestBlendCaps            
   KELVIN_TRICAPS_ALPHACMP                  , // AlphaCmpCaps             
   KELVIN_TRICAPS_SHADE                     , // ShadeCaps                
   KELVIN_TRICAPS_TEXTURE                   , // TextureCaps              
   KELVIN_TRICAPS_TEXTUREFILTER             , // TextureFilterCaps        
   KELVIN_TRICAPS_TEXTUREFILTER             , // CubeTextureFilterCaps    
   0x0                                      , // VolumeTextureFilterCaps  
   KELVIN_TRICAPS_TEXTUREADDRESS            , // TextureAddressCaps       
   0x0                                      , // VolumeTextureAddressCaps 
   KELVIN_CAPS_LINECAPS                     , // LineCaps                 
   0x1000                                   , // MaxTextureWidth          
   0x1000                                   , // MaxTextureHeight         
   0x0                                      , // MaxVolumeExtent          
   KELVIN_CAPS_MAX_TEXTURE_REPEAT           , // MaxTextureRepeat         
   KELVIN_CAPS_MAX_TEXTURE_ASPECT_RATIO     , // MaxTextureAspectRatio    
   KELVIN_CAPS_MAX_ANISOTROPY               , // MaxAnisotropy            
   1.0e10                                   , // MaxVertexW               
   KELVIN_CAPS_GUARD_BAND_LEFT              , // GuardBandLeft            
   KELVIN_CAPS_GUARD_BAND_TOP               , // GuardBandTop             
   KELVIN_CAPS_GUARD_BAND_RIGHT             , // GuardBandRight           
   KELVIN_CAPS_GUARD_BAND_BOTTOM            , // GuardBandBottom          
   KELVIN_CAPS_EXTENTS_ADJUST               , // ExtentsAdjust            
   KELVIN_CAPS_STENCILOPS                   , // StencilCaps              
   KELVIN_CAPS_FVF_CAPS                     , // FVFCaps                  
   KELVIN_CAPS_TEXTUREOPS                   , // TextureOpCaps            
   KELVIN_CAPS_MAX_TEXTURE_BLEND_STAGES     , // MaxTextureBlendStages    
   KELVIN_CAPS_MAX_SIMULTANEOUS_TEXTURES    , // MaxSimultaneousTextures  
   KELVIN_CAPS_VTXPCAPS                     , // VertexProcessingCaps     
   KELVIN_CAPS_MAX_ACTIVE_LIGHTS            , // MaxActiveLights          
   0                                        , // MaxUserClipPlanes [NOTE: Xbox doesn't support user clip planes]
   KELVIN_CAPS_MAX_VERTEX_BLEND_MATRICES    , // MaxVertexBlendMatrices   
   0                                        , // MaxVertexBlendMatrixIndex
   64.0f                                    , // MaxPointSize             
   0xffff                                   , // MaxPrimitiveCount        
   0xffff                                   , // MaxVertexIndex           
   KELVIN_CAPS_MAX_STREAMS                  , // MaxStreams               
   0xff                                     , // MaxStreamStride          
   D3DPS_VERSION(1,1)                       , // VertexShaderVersion      
   KELVIN_CAPS_MAX_VSHADER_CONSTS           , // MaxVertexShaderConst     
   D3DPS_VERSION(1,1)                       , // PixelShaderVersion       
   1                                        , // MaxPixelShaderValue      
};

//------------------------------------------------------------------------------
// D3DDevice_GetDirect3D

extern "C"
void WINAPI D3DDevice_GetDirect3D(
    Direct3D** ppD3D8) 
{ 
    COUNT_API(API_D3DDEVICE_GETDIRECT3D);

    *ppD3D8 = (Direct3D *) 1;
}

//------------------------------------------------------------------------------
// D3DDevice_GetDeviceCaps

extern "C"
void WINAPI D3DDevice_GetDeviceCaps(
    D3DCAPS8* pCaps) 
{ 
    COUNT_API(API_D3DDEVICE_GETDEVICECAPS);
  
    *pCaps = g_DeviceCaps;
}

//------------------------------------------------------------------------------
// D3DDevice_GetDisplayMode

extern "C"
void WINAPI D3DDevice_GetDisplayMode(
    D3DDISPLAYMODE* pMode) 
{ 
    COUNT_API(API_D3DDEVICE_GETDISPLAYMODE);
    
    // Note that initially this will be all zeroes before the first mode
    // set:

    CDevice* pDevice = g_pDevice;

    pMode->Width = PixelJar::GetWidth(pDevice->m_pFrameBuffer[1]);
    pMode->Height = PixelJar::GetHeight(pDevice->m_pFrameBuffer[1]);
    pMode->RefreshRate = pDevice->m_Miniport.GetRefreshRate();
    pMode->Flags = CMiniport::GetPresentFlagsFromAvInfo(pDevice->m_Miniport.m_CurrentAvInfo);
    
    // Always return the format of the post-filter buffer:

    pMode->Format = DecodeD3DFORMAT(pDevice->m_pFrameBuffer[1]->Format);
}

//------------------------------------------------------------------------------
// D3DDevice_GetDisplayMode
//
// DOC: Note restricted Xbox returns

extern "C"
void WINAPI D3DDevice_GetCreationParameters(
    D3DDEVICE_CREATION_PARAMETERS *pParameters) 
{ 
    COUNT_API(API_D3DDEVICE_GETCREATIONPARAMETERS);

    CDevice* pDevice = g_pDevice;

    ZeroMemory(pParameters, sizeof(*pParameters));

    pParameters->DeviceType = D3DDEVTYPE_HAL;

    pParameters->BehaviorFlags |= D3DCREATE_HARDWARE_VERTEXPROCESSING;

    if (pDevice->m_StateFlags & STATE_PUREDEVICE)
    {
        pParameters->BehaviorFlags |= D3DCREATE_PUREDEVICE;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_Reset

extern "C"
HRESULT WINAPI D3DDevice_Reset(
    D3DPRESENT_PARAMETERS* pPresentationParams) 
{ 
    COUNT_API(API_D3DDEVICE_RESET);
    HRESULT hr;

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        hr = PresentationParametersParameterCheck(pPresentationParams);
        if (FAILED(hr))
            return hr;
    }

    // Flush in case there is still rendering pending in the push buffer,
    // so that the reset is synchronous.

    KickOffAndWaitForIdle();

    // Wait for any last synchronized flip to get processed, in order to
    // make sure that the final frame is displayed, and so that the flip
    // synchronization code doesn't get messed up by the INCREMENT_READ_3D
    // done at the Vblank interrupt.

    while (pDevice->m_Miniport.IsFlipPending())
        ;

    // Recreate the frame and back buffers.

    pDevice->FreeFrameBuffers();
    hr = pDevice->InitializeFrameBuffers(pPresentationParams);

    if (FAILED(hr)) 
    {
        /// This is very bad, an application can't present now, and we're
        //  in the wrong mode:
        
        DXGRIP("Failed to recreate frame and back buffers on Reset!");
        pDevice->FreeFrameBuffers();
        return hr;
    }

    pDevice->m_Miniport.SetVideoMode(pPresentationParams->BackBufferWidth, 
                                     pPresentationParams->BackBufferHeight, 
                                     pPresentationParams->FullScreen_RefreshRateInHz,
                                     pPresentationParams->Flags,
                                     pPresentationParams->BackBufferFormat,
                                     pPresentationParams->FullScreen_PresentationInterval,
                                     PixelJar::GetPitch(pDevice->m_pFrameBuffer[1]));

    // Set the render target with the new buffers.

    D3DDevice_SetRenderTarget(pDevice->m_pFrameBuffer[0], pDevice->m_pAutoDepthBuffer);

    // Clear the Z and stencil buffers.  We do this mainly to clear stencil
    // to ensure that there's no random bits left in there which may muck
    // up the Z compression.
    //
    // Note that we don't bother with clearing the color buffer.

    D3DDevice_Clear(0, NULL, D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER, 0, 1.0f, 0);

    return S_OK;
}

//------------------------------------------------------------------------------
// g_LODBias
//
// A simple log2 table...

D3DCONST FLOAT g_LODBias2x[] = 
{ 
    0.000f, // 1.0
    0.585f, // 1.5
    1.000f, // 2.0
    1.322f, // 2.5
    1.585f, // 3.0
};

//------------------------------------------------------------------------------
// D3DDevice_SetRenderTarget

extern "C"
void WINAPI D3DDevice_SetRenderTarget(
    D3DSurface* pRenderTarget,
    D3DSurface* pZBuffer) 
{
    DWORD multisampleType;
    FLOAT xScale;
    FLOAT yScale;
    DWORD width;
    DWORD height;

    COUNT_API(API_D3DDEVICE_SETRENDERTARGET);

    CDevice *pDevice = g_pDevice;

    // If the render target is NULL, just reuse the existing target.

    if (pRenderTarget == NULL)
    {
        pRenderTarget = pDevice->m_pRenderTarget;
    }

    DWORD pitch = PixelJar::GetPitch(pRenderTarget);
    DWORD Zpitch = pZBuffer ? PixelJar::GetPitch(pZBuffer) : pitch;

    if (pRenderTarget == pDevice->m_pFrameBuffer[0]) 
    {
        // We're rendering to the back-buffer.  Compute the effective 
        // dimensions from the post-filter buffer size multiplied by
        // the antialiasing scale factor:

        multisampleType = D3D__RenderState[D3DRS_MULTISAMPLEMODE];
        xScale = pDevice->m_AntiAliasScaleX;
        yScale = pDevice->m_AntiAliasScaleY;
        width = Round(xScale * 
                      PixelJar::GetWidth(pDevice->m_pFrameBuffer[1]));
        height = Round(yScale * 
                       PixelJar::GetHeight(pDevice->m_pFrameBuffer[1]));

        // Make sure the resulting dimensions don't exceed our target
        // surface size:

        width = min(width, PixelJar::GetWidth(pDevice->m_pFrameBuffer[0]));
        height = min(height, PixelJar::GetHeight(pDevice->m_pFrameBuffer[0]));
    }
    else
    {
        // We're rendering to a non-back-buffer render target.

        multisampleType = D3D__RenderState[D3DRS_MULTISAMPLERENDERTARGETMODE];
        xScale = 1.0f;
        yScale = 1.0f;
        width = PixelJar::GetWidth(pRenderTarget);
        height = PixelJar::GetHeight(pRenderTarget);
    }

    if (DBG_CHECK(TRUE))
    {
        if (!PixelJar::IsValidRenderTarget(pRenderTarget))
        {
            DPF_ERR("Invalid render target format.");
        }

        if (!PixelJar::IsSurface(pRenderTarget))
        {
            DPF_ERR("Render target not a true surface (D3DCOMMON_TYPE_SURFACE)");
        }
        
        if ((pZBuffer != NULL) && (!PixelJar::IsSurface(pZBuffer)))
        {
            DPF_ERR("ZStencil not a true surface (D3DCOMMON_TYPE_SURFACE)");
        }

        if (pRenderTarget->Data % D3DSURFACE_ALIGNMENT)
        {
            DPF_ERR("The data for a render target must be 64-byte aligned.");
        }

        if (width > 4096 || height > 4096)
        {
            DPF_ERR("The render target can be at most 4096x4096.");
        }

        if (!PixelJar::IsSwizzled(pRenderTarget))
        {
            if (pitch < 64 || pitch > 65535 || (pitch & 0x3F) != 0)
            {
                DPF_ERR("An unswizzled render target requires a pitch that is nonzero, a multiple of 64 and is less than 64K.");
            }
        }
        else if (pitch < 64)
        {
            DPF_ERR("A swizzled render target needs a pitch >= 64 bytes (width * bytes per pixel, no padding).");
        }

        if (pZBuffer)
        {
            if (Zpitch < 64 || Zpitch > 65535 || (Zpitch & 0x3F) != 0)
            {
                DPF_ERR("An ZBuffer requires a pitch that is nonzero, a multiple of 64 and is less than 64K.");
            }
        }

        if (width == 1 && height != 1)
        {
            DPF_ERR("A render target that is only 1 pixel wide must also be 1 pixel high.");
        }

        if (pZBuffer)
        {
            if (PixelJar::IsSwizzled(pZBuffer))
            {
                DPF_ERR("A swizzled depth buffer can't be used in rendering.");
            }

            if (PixelJar::IsSwizzled(pRenderTarget)
                && PixelJar::GetBitsPerPixel(pRenderTarget) != PixelJar::GetBitsPerPixel(pZBuffer))
            {
                DPF_ERR("A swizzled render target requires a depth-buffer format with the same number of bits-per-pixel.");
            }

            if (!PixelJar::IsValidDepthBuffer(pZBuffer))
            {
                DPF_ERR("Invalid depth buffer format.");
            }

            if (pRenderTarget->Data % D3DSURFACE_ALIGNMENT)
            {
                DPF_ERR("The data for a ZBuffer must be 64-byte aligned.");
            }

            if ((width > PixelJar::GetWidth(pZBuffer)) 
                || (height > PixelJar::GetHeight(pZBuffer)))
            {
                DPF_ERR("The depth buffer must be at least as big as the "
                        "render target");
            }
        }
    }

    // Do what we can using hardware multisampling.
    //
    // 'width' and 'height' as given to SET_SURFACE_CLIP should not be
    // expanded values when multisampling.  

    DWORD setSurfaceFormatAntiAliasing = 0;
    pDevice->m_StateFlags &= ~STATE_MULTISAMPLING;
    if (multisampleType != D3DMULTISAMPLEMODE_1X)
    {
        pDevice->m_StateFlags |= STATE_MULTISAMPLING;

        // When multisampling, the hardware automatically scales
        // everything for us...

        xScale /= 2.0f;
        width = (width + 1) >> 1;
        setSurfaceFormatAntiAliasing = DRF_DEF(097, 
            _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_CORNER_2);

        if (multisampleType == D3DMULTISAMPLEMODE_4X)
        {
            yScale /= 2.0f;
            height = (height + 1) >> 1;
            setSurfaceFormatAntiAliasing = DRF_DEF(097, 
                _SET_SURFACE_FORMAT, _ANTI_ALIASING, _SQUARE_OFFSET_4);
        }
    }

    // Set the render target surface.  'm_pRenderTarget' can be NULL during
    // initialization.

    InternalAddRefSurface(pRenderTarget);

    if (pDevice->m_pRenderTarget)
    {
        pDevice->RecordSurfaceWritePush(pDevice->m_pRenderTarget);

        InternalReleaseSurface(pDevice->m_pRenderTarget);
    }

    pDevice->m_pRenderTarget = pRenderTarget;

    // Set the z-buffer surface.

    if (pDevice->m_pZBuffer)
    {
        pDevice->RecordSurfaceWritePush(pDevice->m_pZBuffer);

        InternalReleaseSurface(pDevice->m_pZBuffer);
    }

    pDevice->m_pZBuffer = pZBuffer;

    if (pZBuffer)
    {
        InternalAddRefSurface(pDevice->m_pZBuffer);

        PixelJar::GetDepthBufferScale(pZBuffer, &pDevice->m_ZScale);
    }

    // If range-checking is enabled, we modify the context DMAs to have the 
    // same range as the destination surface.  This is useful to try to catch
    // errant rendering:

    DWORD colorBase = pDevice->m_Miniport.SetDmaRange(
                            D3D_COLOR_CONTEXT_DMA_IN_VIDEO_MEMORY, 
                            pRenderTarget);

    DWORD zetaBase = pDevice->m_Miniport.SetDmaRange(
                            D3D_ZETA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                            pZBuffer); 

    ////////////////////////////////////////////////////////////////////////////
    // Tell the hardware about the new buffers.

    PPUSH pPush = pDevice->StartPush();

    // Work around a hardware problem we hit with numerous titles.  The 
    // problem was very timing dependent - typically after a day or so
    // of running, the hardware wouldn't properly register the new stride
    // or offset value, and would proceed to draw with the old values,
    // causing considerable memory corruption.  Nvidia still hasn't been
    // able to tell us why yet, but hitting the registers twice seems to 
    // fix the problem.  I'm not sure if the NOPs and WAIT_FOR_IDLEs are
    // necessary, but they won't hurt performance (since these commands 
    // have to do implicit WAIT_FOR_IDLEs anyways).

    DWORD colorOffset = pRenderTarget->Data - colorBase;
    DWORD Zoffset = (pZBuffer != NULL) ? (pZBuffer->Data - zetaBase) : 0;

    for (DWORD iterations = 0; iterations < 2; iterations++)
    {
        Push1(pPush, NV097_NO_OPERATION, 0);
        Push1(pPush + 2, NV097_SET_SURFACE_PITCH,
                     DRF_NUM(097, _SET_SURFACE_PITCH, _COLOR, pitch)
                   | DRF_NUM(097, _SET_SURFACE_PITCH, _ZETA, Zpitch));
        Push1(pPush + 4, NV097_NO_OPERATION, 0);
        Push1(pPush + 6, NV097_WAIT_FOR_IDLE, 0);
        pPush += 8;

        Push1(pPush, NV097_NO_OPERATION, 0);
        Push1(pPush + 2, NV097_SET_SURFACE_COLOR_OFFSET, colorOffset);
        Push1(pPush + 4, NV097_NO_OPERATION, 0);
        Push1(pPush + 6, NV097_WAIT_FOR_IDLE, 0);
        pPush += 8;

        Push1(pPush, NV097_NO_OPERATION, 0);
        Push1(pPush + 2, NV097_SET_SURFACE_ZETA_OFFSET, Zoffset);
        Push1(pPush + 4, NV097_NO_OPERATION, 0);
        Push1(pPush + 6, NV097_WAIT_FOR_IDLE, 0);
        pPush += 8;
    }

    Push2(pPush, NV097_SET_SURFACE_CLIP_HORIZONTAL, 

              // NV097_SET_SURFACE_CLIP_HORIZONTAL:

                 DRF_NUM(097, _SET_SURFACE_CLIP_HORIZONTAL, _X, 0)
               | DRF_NUM(097, _SET_SURFACE_CLIP_HORIZONTAL, _WIDTH, width),

              // NV097_SET_SURFACE_CLIP_VERTICAL:

                 DRF_NUM(097, _SET_SURFACE_CLIP_VERTICAL, _Y, 0)
               | DRF_NUM(097, _SET_SURFACE_CLIP_VERTICAL, _HEIGHT, height));

    // Set the special Z formats.

    pPush = CommonSetControl0(pDevice, pPush + 3);

    // Enable Z (or not).

    Push1(pPush, 
          NV097_SET_DEPTH_TEST_ENABLE, 
          ((D3D__RenderState[D3DRS_ZENABLE] != D3DZB_FALSE) && 
           (pDevice->m_pZBuffer != NULL)));

    // Enable stencil (or not).

    Push1(pPush + 2,
          NV097_SET_STENCIL_TEST_ENABLE,
          (D3D__RenderState[D3DRS_STENCILENABLE] && 
           (pDevice->m_pZBuffer != NULL)));

    pPush += 4;

    // Handle any pending flip synchronization:

    if ((pDevice->m_StateFlags & STATE_FLIPSTALLPENDING) &&
        (pRenderTarget == pDevice->m_pFrameBuffer[0]))
    {
        pDevice->m_StateFlags &= ~STATE_FLIPSTALLPENDING;

        Push1(pPush, NV097_FLIP_STALL, 0);

        pPush += 2;
    }

    // Set the surface type and multisampling mode.

    Push1(pPush, NV097_SET_SURFACE_FORMAT,
          setSurfaceFormatAntiAliasing
          | PixelJar::GetSurfaceFormat(pRenderTarget, pZBuffer));

    pDevice->EndPush(pPush + 2);

    ////////////////////////////////////////////////////////////////////////////

    pDevice->m_SuperSampleScaleX = xScale;
    pDevice->m_SuperSampleScaleY = yScale;

    FLOAT minScale = min(xScale, yScale);

    if (minScale != pDevice->m_SuperSampleScale)
    {
        pDevice->m_SuperSampleScale = minScale;
        pDevice->m_SuperSampleLODBias = g_LODBias2x[Round(2.0f * minScale) - 2];

        // Point sprites and line widths are both affected by the super-
        // sampling factor:

        D3D__DirtyFlags |= D3DDIRTYFLAG_POINTPARAMS;

        D3DDevice_SetRenderState(D3DRS_LINEWIDTH, 
                                 D3D__RenderState[D3DRS_LINEWIDTH]);
    }

    // Changing the antialiasing scale factors will affect the XYZRHW program
    // if loaded.

    CommonSetPassthroughProgram(pDevice);

    // Update the viewport, to reflect the new dimensions, possible new
    // ZScale, and new supersampling scaling.  

    D3DVIEWPORT8 viewport = { 0, 0, 0x7fffffff, 0x7fffffff, 0.0f, 1.0f };

    D3DDevice_SetViewport(&viewport);

    // Update the DXT noise-enable status if necessary:

    D3DDevice_SetRenderState_Dxt1NoiseEnable(
                                D3D__RenderState[D3DRS_DXT1NOISEENABLE]);
}

//------------------------------------------------------------------------------
// D3DDevice_GetBackBuffer

extern "C"
void WINAPI D3DDevice_GetBackBuffer(
    INT BackBuffer,
    D3DBACKBUFFER_TYPE Type,
    D3DSurface** ppBackBuffer) 
{ 
    DWORD index;

    COUNT_API(API_D3DDEVICE_GETBACKBUFFER);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (BackBuffer >= (INT) (pDevice->m_FrameBufferCount - 1))
        {
            DPF_ERR("BackBuffer index is too big.");
        }
        if (BackBuffer < -1)
        {
            DPF_ERR("Invalid index");
        }
        if (Type != D3DBACKBUFFER_TYPE_MONO)
        {
            DPF_ERR("Xbox supports only D3DBACKBUFFER_TYPE_MONO.");
        }
    }

    // -1 is the current frame buffer, 0 is the currently rendered back buffer:

    if (BackBuffer == -1)
        index = 1;
    else if (BackBuffer == 0)
        index = 0;
    else
        index = 2;

    *ppBackBuffer = pDevice->m_pFrameBuffer[index];
    (*ppBackBuffer)->AddRef();
}

//------------------------------------------------------------------------------
// D3DDevice_GetRasterStatus

extern "C"
void WINAPI D3DDevice_GetRasterStatus(
    D3DRASTER_STATUS* pRasterStatus) 
{ 
    COUNT_API(API_D3DDEVICE_GETRASTERSTATUS);
     
    ULONG value;
    CDevice* pDevice = g_pDevice;
    HWREG* NvBase = pDevice->m_NvBase;

    value = REG_RD_DRF(NvBase, _PCRTC, _RASTER, _POSITION);

    if (value == 0 || value >= PixelJar::GetHeight(pDevice->m_pFrameBuffer[1]))
    {
        pRasterStatus->InVBlank = TRUE;
        pRasterStatus->ScanLine = 0;
    }
    else
    {
        pRasterStatus->InVBlank = FALSE;
        pRasterStatus->ScanLine = value;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetGammaRamp

extern "C"
void WINAPI D3DDevice_SetGammaRamp(
    DWORD Flags,
    CONST D3DGAMMARAMP* pRamp) 
{  
    COUNT_API(API_D3DDEVICE_SETGAMMARAMP);

    CDevice* pDevice = g_pDevice;
    CMiniport* pMiniport = &(pDevice->m_Miniport);

    // We can only ever have a maximum of two Presents queued up in the push
    // buffer, since we throttle 

    // Choose between the two gamma ramps based on the LSB of
    // current present count

    ULONG RampNo = ((pDevice->m_SwapCount) & 1);

    memcpy(&(pMiniport->m_GammaRamp[RampNo]), pRamp, sizeof(D3DGAMMARAMP));
    
    pMiniport->m_GammaCurrentIndex = RampNo;

    if (Flags & D3DSGR_IMMEDIATE)
    {
        // Immediately set the gamma ramp values
        
        pMiniport->DacProgramGammaRamp(&(pMiniport->m_GammaRamp[RampNo]));
    }
    else
    {
        // Synchronize it with the Vblank flip or immediate flips 
        
        pMiniport->m_GammaUpdated[RampNo] = TRUE;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetGammaRamp

extern "C"
void WINAPI D3DDevice_GetGammaRamp(
    D3DGAMMARAMP* pRamp)
{
    COUNT_API(API_D3DDEVICE_GETGAMMARAMP);

    CDevice* pDevice = g_pDevice;

    ULONG RampNo = pDevice->m_Miniport.m_GammaCurrentIndex;
    memcpy(pRamp, &(pDevice->m_Miniport.m_GammaRamp[RampNo]), sizeof(D3DGAMMARAMP));
}

//------------------------------------------------------------------------------
// D3DDevice_CreateTexture
//
// 'CreateTexture', 'CMipMap::Create' and 'CMipMap::CMipMap' all rolled into
// one.

extern "C"
HRESULT WINAPI D3DDevice_CreateTexture(
    UINT Width,
    UINT Height,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    D3DTexture** ppTexture) 
{ 
    COUNT_API(API_D3DDEVICE_CREATETEXTURE);

    return CreateTexture(Width,
                         Height,
                         1,         // Depth
                         Levels, 
                         Usage,
                         Format,
                         false,     // isCubeMap
                         false,     // isVolumeTexture
                         (D3DBaseTexture **)ppTexture);
}

//------------------------------------------------------------------------------
// D3DDevice_CreateVolumeTexture

extern "C"
HRESULT WINAPI D3DDevice_CreateVolumeTexture(
    UINT Width,
    UINT Height,
    UINT Depth,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    D3DVolumeTexture** ppVolumeTexture) 
{ 
    COUNT_API(API_D3DDEVICE_CREATEVOLUMETEXTURE);

    return CreateTexture(Width,
                         Height,
                         Depth,
                         Levels, 
                         Usage,
                         Format,
                         false,
                         true,
                         (D3DBaseTexture **)ppVolumeTexture);
}

//------------------------------------------------------------------------------
// D3DDevice_CreateCubeTexture

extern "C"
HRESULT WINAPI D3DDevice_CreateCubeTexture(
    UINT EdgeLength,
    UINT Levels,
    DWORD Usage,
    D3DFORMAT Format,
    D3DPOOL Pool,
    D3DCubeTexture** ppCubeTexture) 
{ 
    COUNT_API(API_D3DDEVICE_CREATECUBETEXTURE);

    return CreateTexture(EdgeLength,
                         EdgeLength,
                         1,
                         Levels, 
                         Usage,
                         Format,
                         true,
                         false,
                         (D3DBaseTexture **)ppCubeTexture);
}

//------------------------------------------------------------------------------
// D3DDevice_CreateRenderTarget

extern "C"
HRESULT WINAPI D3DDevice_CreateRenderTarget(
    UINT Width, 
    UINT Height, 
    D3DFORMAT D3DFormat, 
    D3DMULTISAMPLE_TYPE MultiSample, 
    BOOL Lockable, 
    D3DSurface **ppSurface)
{ 
    COUNT_API(API_D3DDEVICE_CREATERENDERTARGET);

#if DBG
    if (!IsValidRenderTargetD3DFORMAT(D3DFormat))
    {
        DXGRIP("Invalid render target format");
    }
#endif

    return CreateStandAloneSurface(Width,
                                   Height,
                                   D3DFormat,
                                   ppSurface);
}

//------------------------------------------------------------------------------
// D3DDevice_CreateDepthStencilSurface

extern "C"
HRESULT WINAPI D3DDevice_CreateDepthStencilSurface(
    UINT Width, 
    UINT Height, 
    D3DFORMAT D3DFormat, 
    D3DMULTISAMPLE_TYPE MultiSample, 
    D3DSurface **ppSurface)
{ 
    COUNT_API(API_D3DDEVICE_CREATEDEPTHSTENCILSURFACE);

#if DBG
    if (!IsValidDepthBufferD3DFORMAT(D3DFormat))
    {
        DXGRIP("Invalid render target format");
    }
#endif

    return CreateStandAloneSurface(Width,
                                   Height,
                                   D3DFormat,
                                   ppSurface);
}

//------------------------------------------------------------------------------
// D3DDevice_CreateImageSurface

extern "C"
HRESULT WINAPI D3DDevice_CreateImageSurface(
    UINT Width,
    UINT Height,
    D3DFORMAT D3DFormat,
    D3DSurface** ppSurface) 
{ 
    COUNT_API(API_D3DDEVICE_CREATEIMAGESURFACE);

    return CreateStandAloneSurface(Width,
                                   Height,
                                   D3DFormat,
                                   ppSurface);
}

//------------------------------------------------------------------------------
// NV057FormatFromD3DRectColorFormat (also works with NV044...)

inline DWORD NV057FormatFromD3DRectColorFormat(
    D3DCOPYRECTCOLORFORMAT ColorFormat)
{
    ASSERT(ColorFormat > D3DCOPYRECT_COLOR_FORMAT_Y8);

    if (ColorFormat >= D3DCOPYRECT_COLOR_FORMAT_X8R8G8B8_Z8R8G8B8)
        return NV057_SET_COLOR_FORMAT_LE_A8R8G8B8;
    else if (ColorFormat >= D3DCOPYRECT_COLOR_FORMAT_R5G6B5)
        return NV057_SET_COLOR_FORMAT_LE_A16R5G6B5;

    return NV057_SET_COLOR_FORMAT_LE_X16A1R5G5B5;
}

#if DBG

//------------------------------------------------------------------------------
// ValidateCopyRectState

void ValidateCopyRectState(
    D3DCOPYRECTCOLORFORMAT ColorFormat,
    D3DCOPYRECTOPERATION Operation)
{
    switch(ColorFormat)
    {
    case D3DCOPYRECT_COLOR_FORMAT_DEFAULT:
        if (Operation != D3DCOPYRECT_SRCCOPY)
        {
            DXGRIP("D3DDevice_SetCopyRectsState: COLOR_FORMAT_DEFAULT only supports D3DCOPYRECT_SRCCOPY.");
        }
        break;

    case D3DCOPYRECT_COLOR_FORMAT_Y8:
    case D3DCOPYRECT_COLOR_FORMAT_Y16:
    case D3DCOPYRECT_COLOR_FORMAT_Y32:
        if (Operation != D3DCOPYRECT_SRCCOPY_AND &&
            Operation != D3DCOPYRECT_ROP_AND &&
            Operation != D3DCOPYRECT_SRCCOPY)
        {
            DXGRIP("D3DDevice_SetCopyRectsState: Invalid CopyRectOperation with COLOR_FORMAT_Y*.");
        }
        break;

    case D3DCOPYRECT_COLOR_FORMAT_X1A7R8G8B8_Z1A7R8G8B8:
    case D3DCOPYRECT_COLOR_FORMAT_X1A7R8G8B8_O1A7R8G8B8:
    case D3DCOPYRECT_COLOR_FORMAT_A8R8G8B8:
        if (Operation != D3DCOPYRECT_SRCCOPY &&
            Operation != D3DCOPYRECT_SRCCOPY_PREMULT)
        {
            DXGRIP("D3DDevice_SetCopyRectsState: Invalid CopyRectOperation with COLOR_FORMAT_A* or COLOR_FORMAT_X1A*.");
        }
        break;
    }
}

#endif

//------------------------------------------------------------------------------
// SetupCopyRectRopState

PPUSH
SetupCopyRectRopState(
    PPUSH pPush,
    D3DCOPYRECTCOLORFORMAT ColorFormat,
    CONST D3DCOPYRECTROPSTATE *pCopyRectRopState)
{
    CDevice* pDevice = g_pDevice;

    // Set ROP5

    Push1(pPush,
        SUBCH_RECTCOPYOPTIONS,
        NV043_SET_OBJECT,
        D3D_RECTANGLE_COPY_ROP);

    Push1(pPush + 2,
          SUBCH_RECTCOPY,
          NV05F_SET_CONTEXT_ROP,
          D3D_RECTANGLE_COPY_ROP);

    Push1(pPush + 4,
        SUBCH_RECTCOPYOPTIONS,
        NV043_SET_ROP5,
        pCopyRectRopState->Rop);

    pPush += 6;

    // Set Context Pattern

    Push1(pPush,
        SUBCH_RECTCOPYOPTIONS,
        NV044_SET_OBJECT,
        D3D_RECTANGLE_COPY_PATTERN);

    Push1(pPush + 2,
          SUBCH_RECTCOPY,
          NV05F_SET_CONTEXT_PATTERN,
          D3D_RECTANGLE_COPY_PATTERN);

    pPush += 4;

    //
    // Set shape, color format, earth's orbital spin, etc.
    //

    DWORD NV057ColorFormat = NV057FormatFromD3DRectColorFormat(ColorFormat);

    PushCount(pPush, SUBCH_RECTCOPYOPTIONS, NV044_SET_COLOR_FORMAT, 8);

    pPush[1] = NV057ColorFormat;                    // NV044_SET_COLOR_FORMAT
    pPush[2] = NV044_SET_MONOCHROME_FORMAT_CGA6_M1; // NV044_SET_MONOCHROME_FORMAT
    pPush[3] = pCopyRectRopState->Shape;            // NV044_SET_MONOCHROME_SHAPE
    pPush[4] = pCopyRectRopState->PatternSelect;    // NV044_SET_PATTERN_SELECT
    pPush[5] = pCopyRectRopState->MonoColor0;       // NV044_SET_MONOCHROME_COLOR0
    pPush[6] = pCopyRectRopState->MonoColor1;       // NV044_SET_MONOCHROME_COLOR
    pPush[7] = pCopyRectRopState->MonoPattern0;     // NV044_SET_MONOCHROME_PATTERN0
    pPush[8] = pCopyRectRopState->MonoPattern1;     // NV044_SET_MONOCHROME_PATTERN1

    pPush += 9;

    //
    // Set Color Pattern if needed
    //

    CONST DWORD *ColorPattern = pCopyRectRopState->ColorPattern;

    if (ColorPattern &&
        pCopyRectRopState->PatternSelect == NV044_SET_PATTERN_SELECT_COLOR)
    {
        DWORD Method;
        DWORD Count = 4 * 8;    // Assume 16-bit 4x8 DWORDS

        switch(NV057ColorFormat)
        {
        default:
            NODEFAULT("SetupCopyRectRopState - Invalid ColorFormat\n");

        case NV044_SET_COLOR_FORMAT_LE_A16R5G6B5:
            Method = NV044_SET_PATTERN_R5G6B5(0);
            break;

        case NV044_SET_COLOR_FORMAT_LE_X16A1R5G5B5:
            Method = NV044_SET_PATTERN_X1R5G5B5(0);
            break;

        case NV044_SET_COLOR_FORMAT_LE_A8R8G8B8:
            Method = NV044_SET_PATTERN_X8R8G8B8(0);
            Count = 8 * 8;
            break;
        }

        PushCount(pPush++, SUBCH_RECTCOPYOPTIONS, Method, Count);

        for(DWORD iPattern = 0; iPattern < Count; iPattern++)
        {
            *pPush++ = *ColorPattern++;
        }
    }

    return pPush;
}

//------------------------------------------------------------------------------
// D3DDevice_GetCopyRectsState

extern "C"
void WINAPI D3DDevice_GetCopyRectsState(
    D3DCOPYRECTSTATE *pCopyRectState,
    D3DCOPYRECTROPSTATE *pCopyRectRopState)
{
    CDevice* pDevice = g_pDevice;

    if (pCopyRectState)
    {
        *pCopyRectState = pDevice->m_CopyRectState;
    }

    if (pCopyRectRopState)
    {
        *pCopyRectRopState = pDevice->m_CopyRectRopState;

        // We are not keeping up to 256 bytes of crap around just
        // so some lazy programmer can call GetCopyRectsState and
        // get what they previously set. If you really want it
        // idle the chip and go look at NV_PGRAPH_PATTERN. :)
        pCopyRectRopState->ColorPattern = NULL;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetCopyRectsState

extern "C"
void WINAPI D3DDevice_SetCopyRectsState(
    CONST D3DCOPYRECTSTATE *pCopyRectState,
    CONST D3DCOPYRECTROPSTATE *pCopyRectRopState)
{
    CDevice* pDevice = g_pDevice;

    D3DCOPYRECTOPERATION Operation = pCopyRectState->Operation;
    D3DCOPYRECTCOLORFORMAT ColorFormat = pCopyRectState->ColorFormat;

#if DBG

    ValidateCopyRectState(ColorFormat, Operation);

#endif

    PPUSH pPush = pDevice->StartPush();

    // Save our state for those turkeys who call GetCopyRectsState.

    pDevice->m_CopyRectState = *pCopyRectState;

    Push1(pPush,
          SUBCH_RECTCOPY,
          NV05F_SET_OPERATION,
          Operation);
    pPush += 2;

    // Set up various state depending on the operation

    switch(Operation)
    {
    default:
        NODEFAULT("D3DDevice_SetCopyRectsState - Bad CopyRectOperation\n");

    case D3DCOPYRECT_SRCCOPY_AND:
    case D3DCOPYRECT_SRCCOPY:

        // Nothing to do. These aren't the droids you're looking for. Move along.

        break;

    case D3DCOPYRECT_ROP_AND:

        // Setup rop state.

        pPush = SetupCopyRectRopState(pPush, ColorFormat, pCopyRectRopState);
        pDevice->m_CopyRectRopState = *pCopyRectRopState;

        break;

    case D3DCOPYRECT_BLEND_AND:

        // Set beta1

        Push1(pPush,
            SUBCH_RECTCOPYOPTIONS,
            NV012_SET_OBJECT,
            D3D_RECTANGLE_COPY_BETA1);

        Push1(pPush + 2,
              SUBCH_RECTCOPY,
              NV05F_SET_CONTEXT_BETA1,
              D3D_RECTANGLE_COPY_BETA1);

        Push1(pPush + 4,
            SUBCH_RECTCOPYOPTIONS,
            NV012_SET_BETA_1D31,
            pCopyRectState->BlendAlpha);

        pPush += 6;
        break;

    case D3DCOPYRECT_SRCCOPY_PREMULT:
    case D3DCOPYRECT_BLEND_PREMULT:

        // Set beta4

        Push1(pPush,
            SUBCH_RECTCOPYOPTIONS,
            NV072_SET_OBJECT,
            D3D_RECTANGLE_COPY_BETA4);

        Push1(pPush + 2,
              SUBCH_RECTCOPY,
              NV05F_SET_CONTEXT_BETA4,
              D3D_RECTANGLE_COPY_BETA4);

        Push1(pPush + 4,
            SUBCH_RECTCOPYOPTIONS,
            NV072_SET_BETA_FACTOR,
            pCopyRectState->PremultAlpha);

        pPush += 6;
        break;
    }

    // Handle ColorKey.

    if (pCopyRectState->ColorKeyEnable)
    {
        if (DBG_CHECK(Operation == D3DCOPYRECT_BLEND_PREMULT))
        {
            DXGRIP("D3DDevice_SetCopyRectsState - ColorKey does not work with D3DCOPYRECT_BLEND_PREMULT.");
        }

        if (DBG_CHECK(ColorFormat <= D3DCOPYRECT_COLOR_FORMAT_Y8))
        {
            DXGRIP("D3DDevice_SetCopyRectsState - Invalid ColorKey ColorFormat.");
        }

        Push1(pPush,
            SUBCH_RECTCOPYOPTIONS,
            NV057_SET_OBJECT,
            D3D_RECTANGLE_COPY_COLOR_KEY);

        Push1(pPush + 2,
              SUBCH_RECTCOPY,
              NV05F_SET_CONTEXT_COLOR_KEY,
              D3D_RECTANGLE_COPY_COLOR_KEY);

        Push2(pPush + 4,
            SUBCH_RECTCOPYOPTIONS,
            NV057_SET_COLOR_FORMAT,

            // NV057_SET_COLOR_FORMAT:
            NV057FormatFromD3DRectColorFormat(ColorFormat),

            // NV057_SET_COLOR:
            pCopyRectState->ColorKeyValue);

        pPush += 7;
    }
    else
    {
        Push1(pPush,
              SUBCH_RECTCOPY,
              NV05F_SET_CONTEXT_COLOR_KEY,
              D3D_NULL_OBJECT);

        pPush += 2;
    }

    if (pCopyRectState->ClippingSize)
    {
        Push1(pPush,
            SUBCH_RECTCOPYOPTIONS,
            NV019_SET_OBJECT,
            D3D_RECTANGLE_COPY_CLIP_RECTANGLE);

        Push1(pPush + 2,
              SUBCH_RECTCOPY,
              NV05F_SET_CONTEXT_CLIP_RECTANGLE,
              D3D_RECTANGLE_COPY_CLIP_RECTANGLE);

        Push2(pPush + 4,
            SUBCH_RECTCOPYOPTIONS,
            NV019_SET_POINT,

            // NV019_SET_POINT:
            pCopyRectState->ClippingPoint,

            // NV019_SET_SIZE:
            pCopyRectState->ClippingSize);

        pPush += 7;
    }
    else
    {
        Push1(pPush,
              SUBCH_RECTCOPY,
              NV05F_SET_CONTEXT_CLIP_RECTANGLE,
              D3D_NULL_OBJECT);

        pPush += 2;
    }

    pDevice->EndPush(pPush);
}

//----------------------------------------------------------------------------
// Helper function to copy rectangles around in video memory.

VOID GPUCopyVideoRectangle(
    DWORD Format,
    DWORD SourceOffset,
    DWORD SourcePitch,
    DWORD DestOffset,                         
    DWORD DestPitch,
    DWORD Count,
    RECT *pRect,
    POINT *pPoint)
{
    CDevice *pDevice = g_pDevice;

    ASSERT(!(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER));
    ASSERT(Count <= 16);

    ASSERT(SourceOffset % 32 == 0);
    ASSERT(DestOffset % 32 == 0);
    ASSERT(SourcePitch % 64 == 0 && SourcePitch != 0 && SourcePitch <= 8128);
    ASSERT(DestPitch % 64 == 0 && DestPitch != 0 /*&& DestPitch <= 8128*/);

    PPUSH pPush;

    // Set up the surfaces.

    pPush = pDevice->StartPush();

    DWORD Pitch = DRF_NUM(062, _SET_PITCH, _SOURCE, SourcePitch)
                  | DRF_NUM(062, _SET_PITCH, _DESTIN, DestPitch);

    // NV062_SET_COLOR_FORMAT,
    // NV062_SET_PITCH,
    // NV062_SET_OFFSET_SOURCE and
    // NV062_SET_OFFSET_DESTIN

    Push4(pPush,
          SUBCH_RECTCOPYSURFACES,
          NV062_SET_COLOR_FORMAT,
          Format,
          Pitch,
          SourceOffset,
          DestOffset);

    pDevice->EndPush(pPush + 5);

    // Run the copies.

    while (Count--)
    {
        pPush = pDevice->StartPush();

        DWORD SourcePoint = DRF_NUM(05F, _CONTROL_POINT_IN, _X, pRect->left)
                            | DRF_NUM(05F, _CONTROL_POINT_IN, _Y, pRect->top);

        DWORD DestPoint = DRF_NUM(05F, _CONTROL_POINT_OUT, _X, pPoint->x)
                          | DRF_NUM(05F, _CONTROL_POINT_OUT, _Y, pPoint->y);

        DWORD Size = DRF_NUM(05F, _SIZE, _WIDTH, pRect->right - pRect->left)
                     | DRF_NUM(05F, _SIZE, _HEIGHT, pRect->bottom - pRect->top);

        // NV05F_CONTROL_POINT_IN,
        // NV05F_CONTROL_POINT_OUT,
        // NV05F_SIZE

        Push3(pPush,
              SUBCH_RECTCOPY,
              NV05F_CONTROL_POINT_IN,
              SourcePoint,
              DestPoint,
              Size);

        pDevice->EndPush(pPush + 4);

        pRect++;
        pPoint++;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_CopyRects

extern "C"
void WINAPI D3DDevice_CopyRects(
    D3DSurface* pSourceSurface,
    CONST RECT* pSourceRectsArray,
    UINT cRects,
    D3DSurface* pDestinationSurface,
    CONST POINT* pDestPointsArray) 
{ 
    COUNT_API(API_D3DDEVICE_COPYRECTS);

    const DWORD MaxRectangles = 16;

    RECT Rectangles[MaxRectangles];
    POINT Points[MaxRectangles];
    DWORD SwizzledColumns;
    DWORD SwizzledRows;

    DWORD BytesPerPixel = PixelJar::GetBitsPerPixel(pSourceSurface) / 8;
    DWORD SourcePitch = PixelJar::GetPitch(pSourceSurface);
    DWORD DestPitch = PixelJar::GetPitch(pDestinationSurface);

    BOOL IsSwizzledFormat      = PixelJar::IsSwizzled(pSourceSurface) 
                              || PixelJar::IsCompressed(pSourceSurface);

    CDevice* pDevice = g_pDevice;

    D3DCOPYRECTCOLORFORMAT CopyRectColorFormat = pDevice->m_CopyRectState.ColorFormat;

#if DBG

    DWORD SWidth, SHeight, SDepth, SPitch, SSlice;
    DWORD DWidth, DHeight, DDepth, DPitch, DSlice;

    PixelJar::GetSize(pSourceSurface, 0, &SWidth, &SHeight, &SDepth, &SPitch, &SSlice);
    PixelJar::GetSize(pDestinationSurface, 0, &DWidth, &DHeight, &DDepth, &DPitch, &DSlice);

    if (!IsSwizzledFormat && (SPitch < D3DTEXTURE_PITCH_MIN || DPitch < D3DTEXTURE_PITCH_MIN))
    {
        DXGRIP("D3DDevice_CopyRects - The source and destination surfaces must have a pitch of at least 64 bytes");
    }

#endif DBG

    if (DBG_CHECK(TRUE))
    {
        if (pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER)
        {
            DPF_ERR("Can't call CopyRects while recording a push-buffer");
        }

        if (PixelJar::GetFormat(pSourceSurface) != PixelJar::GetFormat(pDestinationSurface))
        {
            DXGRIP("D3DDevice_CopyRects - The source and destination surfaces must have the same format.");
        }

        // The dest pitch doesn't seem have the same restrictions as the source pitch...
        if (!IsSwizzledFormat && (SourcePitch > 8128 /*|| DestPitch > 8128*/))
        {
            DXGRIP("D3DDevice_CopyRects - CopyRects does not work on surfaces who pitch is greater than 8128 bytes.");
        }

        if (PixelJar::IsCompressed(pSourceSurface) &&
            CopyRectColorFormat != D3DCOPYRECT_COLOR_FORMAT_DEFAULT)
        {
            DXGRIP("D3DDevice_CopyRects - Must use D3DCOPYRECT_COLOR_FORMAT_DEFAULT with compressed surfaces.");
        }
    }

    // Special case, passing cRects == 0 will copy the entire first
    // surface to the second.
    //
    if (cRects == 0)
    {
        cRects = 1;
    }

    // Swizzled and compressed textures need to be jiggled to get them to 
    // copy using these routines, especially because this class has a 
    // minimum pitch of 64 bytes.
    //
    if (IsSwizzledFormat)
    {

#if DBG

        // Note that all this stuff below is going to mess up ClippingRects
        // and Patterns for swizzled textures. Technically we could check
        // if the width of the swizzled texture > 64, set the pitch
        // appropriately and run with it. However I'm not sure supporting
        // all that with swizzled textures is even worth it. Clipping
        // Rects are just plain messed up cause swizzled bits are all twiddled
        // and possibly someone can take their 8x8 pattern brush, pre-swizzle
        // format it and they can do full surface-->surface copies with
        // strange rops but I don't see the win. So warn the user that things
        // may not work as expected.

        if ((pDevice->m_CopyRectState.ClippingSize ||
            (pDevice->m_CopyRectState.Operation == D3DCOPYRECT_ROP_AND)) &&
            !g_WarnAboutCopyRectStateSwizzle)
        {
            WARNING("D3DDevice_CopyRects - Swizzled surfaces don't support "
                "ClippingRects and/or D3DCOPYRECT_ROP_AND.");
            g_WarnAboutCopyRectStateSwizzle = TRUE;
        }

#endif

        DWORD Slice = PixelJar::GetSlice(pSourceSurface);
        
        // The max pitch is 8128.  Just do one row if it fits.
        if (Slice <= 8128)
        {
            SourcePitch = (Slice + 63) & ~63;
            DestPitch   = SourcePitch;

            SwizzledColumns = Slice;
            SwizzledRows = 1;
        }

        // Otherwise we need to break this up into chunks.  Fortunately
        // we do know that the memory is always a multiple of two 
        // power-of-two numbers and is greater than 8128.
        //
        else
        {
            ASSERT(Slice % 4096 == 0);

            SourcePitch = 4096;
            DestPitch   = 4096;

            SwizzledColumns = 4096;
            SwizzledRows = Slice / 4096;
        }

        if (CopyRectColorFormat == D3DCOPYRECT_COLOR_FORMAT_DEFAULT)
        {
            // If we are just SRCCOPY'ing things then take the bytesperpixel
            // and run with it. Technically I'm 99.9% sure you can do the
            // BytesPerPixel divide below but since I really didn't want to
            // introduce any regressions whilst adding the CopyRectState
            // stuff I'm going this route.

            BytesPerPixel = 1;
        }
        else
        {
            // Ok - we're doing some type of blend operation so we can't
            // twiddle their pixel size. Take the new byte width and
            // divide it by BytesPerPixel.

            // Make sure we're not lopping any data off here.
            ASSERT((SwizzledColumns / BytesPerPixel) * BytesPerPixel == SwizzledColumns);

            SwizzledColumns /= BytesPerPixel;
        }
    }

    // Set up our ColorFormat.

    DWORD ColorFormat;

    if (CopyRectColorFormat == D3DCOPYRECT_COLOR_FORMAT_DEFAULT)
    {
        ASSERT(pDevice->m_CopyRectState.Operation == D3DCOPYRECT_SRCCOPY);

        switch (BytesPerPixel)
        {
        default:
            NODEFAULT(("GPUCopyVideoRectangle - Bad pixel size\n"));

        case 4:
            ColorFormat = NV062_SET_COLOR_FORMAT_LE_A8R8G8B8;
            break;

        case 2:
            ColorFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;
            break;

        case 1:
            ColorFormat = NV062_SET_COLOR_FORMAT_LE_Y8;
            break;
        }
    }
    else
    {
        ColorFormat = CopyRectColorFormat;

#if DBG

        DWORD ColorFormatBytes = 1;

        if (ColorFormat >= D3DCOPYRECT_COLOR_FORMAT_X8R8G8B8_Z8R8G8B8)
            ColorFormatBytes = 4;
        else if (ColorFormat >= D3DCOPYRECT_COLOR_FORMAT_X1R5G5B5_Z1R5G5B5)
            ColorFormatBytes = 2;

        if (BytesPerPixel != ColorFormatBytes)
            DXGRIP("D3DDevice_CopyRects - pixel size doesn't match ColorFormat CopyRectState size.");

#endif

    }

    // For debug purposes, modify the context DMA to ensure we stay within 
    // bounds.
    DWORD destinationBase = pDevice->m_Miniport.SetDmaRange(
                                D3D_COPY_CONTEXT_DMA_IN_VIDEO_MEMORY,
                                pDestinationSurface);

    // Copy 16 rectangles at a time.
    do
    {
        RECT *pRectangles;
        POINT *pPoints;
        
        DWORD RectangleCount = min(MaxRectangles, cRects);
        cRects -= RectangleCount;

        // Figure out the arrays of rectangles to copy.
        if (pSourceRectsArray)
        {
            pRectangles = (RECT *)pSourceRectsArray;

            pSourceRectsArray += MaxRectangles;
        }
        else
        {
            pRectangles = Rectangles;

            for (DWORD i = 0; i < RectangleCount; i++)
            {
                Rectangles[i].top = 0;
                Rectangles[i].bottom = PixelJar::GetHeight(pSourceSurface);
                Rectangles[i].left = 0;
                Rectangles[i].right = PixelJar::GetWidth(pSourceSurface);
            }
        }

        if (pDestPointsArray)
        {
            pPoints = (POINT *)pDestPointsArray;

            pDestPointsArray += MaxRectangles;
        }
        else
        {
            pPoints = Points;

            for (DWORD i = 0; i < RectangleCount; i++)
            {
                Points[i].x = pRectangles[i].left;
                Points[i].y = pRectangles[i].top;
            }
        }

#if DBG
        // Make sure those rectangles are legal.
        if (DBG_CHECK(TRUE))
        {
            for (DWORD i = 0; i < RectangleCount; i++)
            {
                if (PixelJar::IsSwizzled(pSourceSurface) || PixelJar::IsCompressed(pSourceSurface))
                {
                    if (   pPoints[i].x != 0 
                        || pPoints[i].y != 0
                        || pRectangles[i].top != 0
                        || pRectangles[i].left != 0
                        || pRectangles[i].right != (long)SWidth
                        || pRectangles[i].bottom != (long)SHeight)
                    {
                        DXGRIP("D3DDevice_CopyRects - CopyRects can only copy all of a swizzled surface.");
                    }

                    if (SWidth != DWidth || SHeight != DHeight)
                    {
                        DXGRIP("D3DDevice_CopyRects - The source and destination surfaces must be the same size when copying a swizzled surface.");
                    }
                }
                else
                {
                    if (pRectangles[i].top >= pRectangles[i].bottom
                        || pRectangles[i].left >= pRectangles[i].right)
                    {
                        DXGRIP("D3DDevice_CopyRects - Malformed source rectangle, one dimension is either zero size or is inverted.");
                    }

                    if (pRectangles[i].top < 0 || pRectangles[i].bottom > (long)SHeight
                        || pRectangles[i].left < 0 || pRectangles[i].right > (long)SWidth)
                    {
                        DXGRIP("D3DDevice_CopyRects - The source rectangle extends beyond the bounds of the source surface.");
                    }

                    if (pPoints[i].x < 0 
                        || pPoints[i].x + pRectangles[i].right - pRectangles[i].left > (long)DWidth
                        || pPoints[i].y < 0 
                        || pPoints[i].y + pRectangles[i].bottom - pRectangles[i].top > (long)DHeight)
                    {
                        // If they've set up a Clipping Rect assume they aren't going out of bounds and if they
                        // are that AndrewGo's mondo cool Dma Range checking will catch it. And if it doesn't go
                        // yell at him...
                        if(!pDevice->m_CopyRectState.ClippingSize)
                        {
                            DXGRIP("D3DDevice_CopyRects - The destination rectangle extends beyond the bounds of the destination surface.");
                        }
                    }
                }           
            }
        }
#endif DBG

        // Adjust the rectangles to handle swizzled and compressed
        // textures.
        //
        if (IsSwizzledFormat)
        {
            for (DWORD i = 0; i < RectangleCount; i++)
            {
                pRectangles[i].left  = 0;
                pRectangles[i].top   = 0;
                pRectangles[i].right = SwizzledColumns;
                pRectangles[i].bottom = SwizzledRows;
            }
        }

        GPUCopyVideoRectangle(
            ColorFormat,
            pSourceSurface->Data,  
            SourcePitch,
            pDestinationSurface->Data - destinationBase,
            DestPitch,
            RectangleCount,
            pRectangles,
            pPoints);
    }
    while (cRects);

    pDevice->RecordSurfaceWritePush(pSourceSurface);
    pDevice->RecordSurfaceWritePush(pDestinationSurface);
}

//------------------------------------------------------------------------------
// D3DDevice_GetRenderTarget

extern "C"
HRESULT WINAPI D3DDevice_GetRenderTarget(
    D3DSurface** ppRenderTarget) 
{ 
    COUNT_API(API_D3DDEVICE_GETRENDERTARGET);

    CDevice *pDevice = g_pDevice;  

    *ppRenderTarget = pDevice->m_pRenderTarget;

    if (*ppRenderTarget)
    {
        (*ppRenderTarget)->AddRef();
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_GetDepthStencilSurface

extern "C"
HRESULT WINAPI D3DDevice_GetDepthStencilSurface(
    D3DSurface** ppZStencilSurface) 
{ 
    COUNT_API(API_D3DDEVICE_GETDEPTHSTENCILSURFACE);

    CDevice *pDevice = g_pDevice;  

    *ppZStencilSurface = pDevice->m_pZBuffer;

    if (*ppZStencilSurface)
    {
        (*ppZStencilSurface)->AddRef();
        return S_OK;
    }
    else
    {
        return D3DERR_NOTFOUND;
    }
}

//------------------------------------------------------------------------------
// g_TransformDirtyTable

D3DCONST DWORD g_TransformDirtyTable[] =
{
    D3DDIRTYFLAG_TRANSFORM | D3DDIRTYFLAG_LIGHTS,       // D3DTS_VIEW
    D3DDIRTYFLAG_TRANSFORM,                             // D3DTS_PROJECTION
    D3DDIRTYFLAG_TEXTURE_TRANSFORM,                     // D3DTS_TEXTURE0
    D3DDIRTYFLAG_TEXTURE_TRANSFORM,                     // D3DTS_TEXTURE1
    D3DDIRTYFLAG_TEXTURE_TRANSFORM,                     // D3DTS_TEXTURE2
    D3DDIRTYFLAG_TEXTURE_TRANSFORM,                     // D3DTS_TEXTURE3
    D3DDIRTYFLAG_TRANSFORM,                             // D3DTS_WORLD
    D3DDIRTYFLAG_TRANSFORM,                             // D3DTS_WORLD1
    D3DDIRTYFLAG_TRANSFORM,                             // D3DTS_WORLD2
    D3DDIRTYFLAG_TRANSFORM,                             // D3DTS_WORLD3    
};

//------------------------------------------------------------------------------
// D3DDevice_SetTransform

extern "C"
void WINAPI D3DDevice_SetTransform(
    D3DTRANSFORMSTATETYPE State,
    CONST D3DMATRIX* pMatrix) 
{ 
    COUNT_API(API_D3DDEVICE_SETTRANSFORM);

    DWORD state = (DWORD) State;

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (state >= D3DTS_MAX)
        {
            D3D_ERR("Invalid state value passed to SetTransform");
        }
        if (pMatrix == NULL)
        {
            D3D_ERR("Invalid pointer");
        }
        if (D3D__DirtyFlags & D3DDIRTYFLAG_DIRECT_MODELVIEW)
        {
            WARNING("SetTransform called while Set[VertexBlend]ModelView in effect,\n"
                    "will be deferred");
        }
    }

#if DBG

    if ((state >= D3DTS_WORLD) && (state <= D3DTS_WORLD3))
    {
        COUNT_PERF(PERF_SETTRANSFORM_WORLD);
    }
    else if (state == D3DTS_VIEW)
    {
        COUNT_PERF(PERF_SETTRANSFORM_VIEW);
    }
    else if (state == D3DTS_PROJECTION)
    {
        COUNT_PERF(PERF_SETTRANSFORM_PROJECTION);
    }
    else if ((state >= D3DTS_TEXTURE0) && (state <= D3DTS_TEXTURE3))
    {
        COUNT_PERF(PERF_SETTRANSFORM_TEXTURE);
    }

    if (memcmp(pMatrix, &pDevice->m_Transform[state], sizeof(*pMatrix)) == 0)
    {
        COUNT_PERF(PERF_REDUNDANT_SETTRANSFORM);
    }

#endif

    pDevice->m_Transform[state] = *pMatrix;
    D3D__DirtyFlags |= g_TransformDirtyTable[state];

    // We do a bunch more work here for the infrequently changed projection
    // matrix:

    if (State == D3DTS_PROJECTION)
    {
        // Logic taken from UpdateWInfo:

        if ((pMatrix->_33 == pMatrix->_34) || (pMatrix->_33 == 0.0f))
        {
            WARNING("Cannot compute WNear and WFar from the supplied "
                     "projection matrix");
            WARNING("Setting wNear to 0.0 and wFar to 1.0");

            pDevice->m_WNear = 0.0f;
            pDevice->m_WFar = 1.0f;
        }
        else
        {
            pDevice->m_WNear = pMatrix->_44 - pMatrix->_43 
                / pMatrix->_33 * pMatrix->_34;

            pDevice->m_WFar = (pMatrix->_44 - pMatrix->_43) 
                / (pMatrix->_33 - pMatrix->_34)*pMatrix->_34 + pMatrix->_44;
        }

        pDevice->m_InverseWFar = 1.0f / pDevice->m_WFar;

        // Determine if the fog source is Z or W.  Logic taken from 
        // nvDP2SetTransform:

        pDevice->m_StateFlags &= ~STATE_FOGSOURCEZ;
        if ((pMatrix->_14 == 0.0f) &&
            (pMatrix->_24 == 0.0f) &&
            (pMatrix->_34 == 0.0f) &&
            (pMatrix->_44 == 1.0f))
        {
            pDevice->m_StateFlags |= STATE_FOGSOURCEZ;
        }

        // Update our cached projection-viewport transform:

        UpdateProjectionViewportTransform();

        // If the fog source has changed and passthrough is active, we need
        // to update the current passthrough program here:

        CommonSetPassthroughProgram(pDevice);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetTransform

extern "C"
void WINAPI D3DDevice_GetTransform(
    D3DTRANSFORMSTATETYPE State,
    D3DMATRIX* pMatrix) 
{ 
    COUNT_API(API_D3DDEVICE_GETTRANSFORM);

    DWORD state = (DWORD) State;

    if (DBG_CHECK(TRUE))
    {
        if (state >= D3DTS_MAX)
        {
            D3D_ERR("Invalid state value passed to GetTransform");
        }

        if (pMatrix == NULL)
        {
            D3D_ERR("Invalid pointer");
        }
    }

    CDevice *pDevice = g_pDevice;

    *pMatrix = pDevice->m_Transform[state];
}

//------------------------------------------------------------------------------
// D3DDevice_MultiplyTransform

extern "C"
void WINAPI D3DDevice_MultiplyTransform(
    D3DTRANSFORMSTATETYPE State,
    CONST D3DMATRIX* pMatrix) 
{ 
    COUNT_API(API_D3DDEVICE_MULTIPLYTRANSFORM);

    D3DALIGN D3DMATRIX result;
    D3DALIGN D3DMATRIX temp = *pMatrix;

    DWORD state = (DWORD) State;

    if (DBG_CHECK(TRUE))
    {
        if (state >= D3DTS_MAX)
        {
            D3D_ERR("Invalid state value passed to MultiplyTransform");
        }

        if (pMatrix == NULL)
        {
            D3D_ERR("Invalid pointer");
        }
    }

    CDevice* pDevice = g_pDevice;

    MatrixProduct4x4(&result, &temp, &pDevice->m_Transform[state]);

    D3DDevice_SetTransform(State, &result);
}

//------------------------------------------------------------------------------
// D3DDevice_SetViewport

extern "C"
void WINAPI D3DDevice_SetViewport(
    CONST D3DVIEWPORT8* pViewport) 
{ 
    D3DSurface* pSurface;

    COUNT_API(API_D3DDEVICE_SETVIEWPORT);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (pViewport == NULL)
        {
            D3D_ERR( "Invalid viewport pointer" );
        }
    }

    // Clip to the current render target.  For antialiasing, we always
    // use the size of the post-filter buffer:

    if (pDevice->m_pRenderTarget == pDevice->m_pFrameBuffer[0])
        pSurface = pDevice->m_pFrameBuffer[1];
    else
        pSurface = pDevice->m_pRenderTarget;

    DWORD left = max(pViewport->X, 0);
    DWORD top = max(pViewport->Y, 0);
    DWORD right = min(pViewport->X + pViewport->Width, 
                      (INT) PixelJar::GetWidth(pSurface));
    DWORD bottom = min(pViewport->Y + pViewport->Height,
                       (INT) PixelJar::GetHeight(pSurface));

    if (DBG_CHECK(TRUE))
    {
        if ((left >= right) || (top >= bottom) ||
            (right > 0xfff) || (bottom > 0xfff))
        {
            D3D_ERR("Invalid effective clip dimensions");
        }
    }

    // Stash away the result:

    pDevice->m_Viewport.X = left;
    pDevice->m_Viewport.Y = top;
    pDevice->m_Viewport.Width = right - left;
    pDevice->m_Viewport.Height = bottom - top;
    pDevice->m_Viewport.MinZ = pViewport->MinZ;
    pDevice->m_Viewport.MaxZ = pViewport->MaxZ;

    // Update the cached projection-viewport transform, and dirty the
    // transforms:

    UpdateProjectionViewportTransform();

    // Set the window clipping.

    D3DDevice_SetScissors(0, 0, NULL);

    // Set the viewport scaling.

    PPUSH pPush = pDevice->StartPush();

    pPush = CommonSetViewport(pDevice, pPush);

    pDevice->EndPush(pPush);

    // Point parameters are dependent upon the viewport height:

    D3D__DirtyFlags |= D3DDIRTYFLAG_POINTPARAMS;
}

//------------------------------------------------------------------------------
// D3DDevice_GetViewport

extern "C"
void WINAPI D3DDevice_GetViewport(
    D3DVIEWPORT8* pViewport) 
{ 
    COUNT_API(API_D3DDEVICE_GETVIEWPORT);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (pViewport == NULL)
        {
            D3D_ERR( "Invalid viewport pointer" );
        }
    }

    *pViewport = pDevice->m_Viewport;
}

//------------------------------------------------------------------------------
// D3DDevice_SetMaterial

extern "C"
void WINAPI D3DDevice_SetMaterial(
    CONST D3DMATERIAL8* pMaterial) 
{ 
    COUNT_API(API_D3DDEVICE_SETMATERIAL);

    if (DBG_CHECK(TRUE))
    {
        if (pMaterial == NULL)
        {
            D3D_ERR("Null material pointer");
        }
    }

    CDevice* pDevice = g_pDevice;

    pDevice->m_Material = *pMaterial;

    D3D__DirtyFlags |= D3DDIRTYFLAG_LIGHTS;
}

//------------------------------------------------------------------------------
// D3DDevice_GetMaterial

extern "C"
void WINAPI D3DDevice_GetMaterial(
    D3DMATERIAL8* pMaterial) 
{ 
    COUNT_API(API_D3DDEVICE_GETMATERIAL);

    if (DBG_CHECK(TRUE))
    {
        if (pMaterial == NULL)
        {
            D3D_ERR("Null material pointer");
        }
    }

    CDevice* pDevice = g_pDevice;

    *pMaterial = pDevice->m_Material;
}

//------------------------------------------------------------------------------
// D3DDevice_SetBackMaterial

extern "C"
void WINAPI D3DDevice_SetBackMaterial(
    CONST D3DMATERIAL8* pBackMaterial) 
{ 
    COUNT_API(API_D3DDEVICE_SETBACKMATERIAL);

    if (DBG_CHECK(TRUE))
    {
        if (pBackMaterial == NULL)
        {
            D3D_ERR("Null material pointer");
        }
    }

    CDevice* pDevice = g_pDevice;

    pDevice->m_BackMaterial = *pBackMaterial;

    D3D__DirtyFlags |= D3DDIRTYFLAG_LIGHTS;
}

//------------------------------------------------------------------------------
// D3DDevice_GetBackMaterial

extern "C"
void WINAPI D3DDevice_GetBackMaterial(
    D3DMATERIAL8* pBackMaterial) 
{ 
    COUNT_API(API_D3DDEVICE_GETBACKMATERIAL);

    if (DBG_CHECK(TRUE))
    {
        if (pBackMaterial == NULL)
        {
            D3D_ERR("Null material pointer");
        }
    }

    CDevice* pDevice = g_pDevice;

    *pBackMaterial = pDevice->m_BackMaterial;
}

//------------------------------------------------------------------------------
// CheckLightParameters

void CheckLightParameters(
    CONST D3DLIGHT8* lpData)
{
    if (lpData->Type != D3DLIGHT_POINT &&
        lpData->Type != D3DLIGHT_SPOT &&
        lpData->Type != D3DLIGHT_DIRECTIONAL)
    {
        D3D_ERR( "Invalid D3DLIGHT type" );
    }

    if (lpData->Type != D3DLIGHT_DIRECTIONAL)
    {
        if (lpData->Range < 0.0f)
        {
            D3D_ERR( "Invalid D3DLIGHT range" );
        }
        if (lpData->Attenuation0 == 0 &&
            lpData->Attenuation1 == 0 &&
            lpData->Attenuation2 == 0)
        {
            D3D_ERR( "Attenuation factors can not all be zero" );
        }
    }

    if (lpData->Type == D3DLIGHT_SPOT || lpData->Type == D3DLIGHT_DIRECTIONAL)
    {
        float   magnitude;
        magnitude = lpData->Direction.x * lpData->Direction.x +
            lpData->Direction.y * lpData->Direction.y +
            lpData->Direction.z * lpData->Direction.z;
        if (magnitude < 0.00001f)
        {
            D3D_ERR( "Invalid D3DLIGHT direction" );
        }
        if (lpData->Type == D3DLIGHT_SPOT)
        {
            if (lpData->Phi < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be >= 0" );
            }
            if (lpData->Phi > 3.1415927f)
            {
                D3D_ERR( "Invalid D3DLIGHT Phi angle, must be <= pi" );
            }
            if (lpData->Theta < 0.0f)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be >= 0" );
            }
            if (lpData->Theta > lpData->Phi)
            {
                D3D_ERR( "Invalid D3DLIGHT Theta angle, must be <= Phi" );
            }
            if (lpData->Attenuation0 < 0 ||
                lpData->Attenuation1 < 0 ||
                lpData->Attenuation2 < 0)
            {
                D3D_ERR( "Attenuation factor can not be negative" );
            }
        }
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetLight

extern "C"
HRESULT WINAPI D3DDevice_SetLight(
    DWORD Index,
    CONST D3DLIGHT8* pLight8) 
{ 
    COUNT_API(API_D3DDEVICE_SETLIGHT);

    if (DBG_CHECK(TRUE))
    {
        CheckLightParameters(pLight8);

        if (pLight8 == NULL)
        {
            D3D_ERR("Invalid light pointer");
        }

        // '4096' is a completely arbitrary limit:

        if (Index > 4095)
        {
            D3D_ERR("Light index is more than 4095");
        }
    }

    CDevice* pDevice = g_pDevice;

    // Grow the lights array if necessary:

    DWORD count = pDevice->m_LightCount;
    if (Index >= count)
    {
        // Always round up to a multiple of 16:

        DWORD newCount = (Index + 16) & ~0xf;
        Light* pLights = (Light*) MemAllocNoZero(newCount * sizeof(Light));

        if (pLights == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // Before the copy, run through the active lights linked-list
        // and add the offset to every pointer, thereby updating all
        // the 'Next' pointers:

        DWORD delta = (DWORD) pLights - (DWORD) pDevice->m_pLights;
        Light** ppNext = &pDevice->m_pActiveLights;
        Light** ppNextNext;

        while (*ppNext != NULL)
        {
            ppNextNext = &((*ppNext)->pNext);
            *((DWORD*) ppNext) += delta;
            ppNext = ppNextNext;
        }

        // Copy:

        memcpy(pLights, pDevice->m_pLights, count * sizeof(Light));
        ZeroMemory(pLights + count, (newCount - count) * sizeof(Light));

        // Free the old array and remember the new values:

        MemFree(pDevice->m_pLights);

        pDevice->m_LightCount = newCount;
        pDevice->m_pLights = pLights;
    }

    Light* pLight = &pDevice->m_pLights[Index];

    pLight->Light8 = *pLight8;
    pLight->Flags |= (LIGHT_SET | LIGHT_STATEBLOCK_SET);

    if (pLight->Light8.Type != D3DLIGHT_POINT)
    {
        // Negate direction vector to align with OpenGL:

        ReverseVector3(&pLight->Direction, &pLight->Light8.Direction);
        NormalizeVector3(&pLight->Direction);  // PERF: Necessary??

        if (pLight->Light8.Type == D3DLIGHT_SPOT)
        {
            // Calculate falloff and direction:
    
            Explut(pLight->Light8.Falloff, &pLight->Falloff_L, &pLight->Falloff_M);
    
            pLight->Falloff_N = 1.0f + pLight->Falloff_L - pLight->Falloff_M;
                
            // Attenuate the spot direction to get falloff to work:
    
            FLOAT theta2 = Cos(0.5f * pLight->Light8.Theta);
            FLOAT phi2 = Cos(0.5f * pLight->Light8.Phi);
    
            // Handle case in which theta gets close to or overtakes phi, since 
            // hardware can't:
    
            if (phi2 >= theta2)     // Outer angle <= inner angle, oops
            {        
                // Make outer angle cosine slightly smaller:
    
                phi2 = 0.999f * theta2;  
            }
    
            pLight->Scale = nvInv(theta2 - phi2);
            pLight->W = -phi2 * pLight->Scale;
        }
    }

    D3D__DirtyFlags |= D3DDIRTYFLAG_LIGHTS;

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_GetLight

extern "C"
void WINAPI D3DDevice_GetLight(
    DWORD Index,
    D3DLIGHT8* pLight8) 
{ 
    COUNT_API(API_D3DDEVICE_GETLIGHT);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (pLight8 == NULL)
        {
            D3D_ERR("Invalid light pointer");
        }

        // It seems a bit inconsistent that 'LightEnable' can automatically 
        // create a new light, but GetLight can't.  Oh well.

        if ((Index >= pDevice->m_LightCount) ||
            !(pDevice->m_pLights[Index].Flags & LIGHT_SET))
        {
            D3D_ERR("Invalid light index");
        }
    }

    *pLight8 = pDevice->m_pLights[Index].Light8;
}

//------------------------------------------------------------------------------
// D3DDevice_LightEnable
//
// DOC: Behavior when more than 8 lights enabled

extern "C"
HRESULT WINAPI D3DDevice_LightEnable(
    DWORD Index,
    BOOL Enable) 
{ 
    COUNT_API(API_D3DDEVICE_LIGHTENABLE);

    CDevice* pDevice = g_pDevice;

    // If the light hasn't already been created, we create a default light:

    if ((Index >= pDevice->m_LightCount) ||
        !(pDevice->m_pLights[Index].Flags & LIGHT_SET))
    {
        // Set the light's default value:

        D3DLIGHT8 light;
        ZeroMemory(&light, sizeof(light));

        light.Type = D3DLIGHT_DIRECTIONAL;
        light.Direction.z = 1.0f;
        light.Diffuse.r = 1.0f;
        light.Diffuse.g = 1.0f;
        light.Diffuse.b = 1.0f;

        // Ugh, even on retail we do a run-time check for failure here, to
        // account for allocation failure:

        HRESULT res = D3DDevice_SetLight(Index, &light);
        if (res != S_OK)
            return res;
    }

    Light* pLight = &pDevice->m_pLights[Index];

    // Make a note that this light has been enabled or disabled, for the
    // purposes of our state-block support:

    pLight->Flags |= LIGHT_STATEBLOCK_ENABLED;

    // First remove the light from the active list, if it's there.
    // Initially, &pPrevious->pNext == &pDevice->m_pActiveLights:

    Light* pPrevious = (Light*) ((BYTE*) &pDevice->m_pActiveLights 
                                            - offsetof(Light, pNext));
    Light* pThis = pDevice->m_pActiveLights;

    while (pThis != NULL)
    {
        if (pThis == pLight)
        {
            pPrevious->pNext = pThis->pNext;
            break;          // ======>
        }

        // Advance:

        pPrevious = pThis;
        pThis = pThis->pNext;
    }

    // If enabling, insert the light at the head of the list:

    if (Enable)
    {
        pLight->pNext = pDevice->m_pActiveLights;
        pDevice->m_pActiveLights = pLight;
    }

    D3D__DirtyFlags |= D3DDIRTYFLAG_LIGHTS;

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_GetLightEnable

extern "C"
void WINAPI D3DDevice_GetLightEnable(
    DWORD Index,
    BOOL* pEnable) 
{ 
    COUNT_API(API_D3DDEVICE_GETLIGHTENABLE);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (pEnable == NULL)
        {
            D3D_ERR("Invalid enable pointer");
        }

        // It seems a bit inconsistent that 'LightEnable' can automatically 
        // create a new light, but GetLight can't.  Oh well.

        if ((Index >= pDevice->m_LightCount) ||
            !(pDevice->m_pLights[Index].Flags & LIGHT_SET))
        {
            D3D_ERR("Invalid light index");
        }
    }

    // Since we *have* to keep an active list, I can't be bothered to
    // keep an 'active' flag in the light structure.  GetLightEnable will 
    // be rare, so simply loop through the active list to determine if
    // the light is enabled:

    Light* pLight = &pDevice->m_pLights[Index];
    Light* pActive = pDevice->m_pActiveLights;

    while (pActive != NULL)
    {
        if (pActive == pLight)
        {
            *pEnable = TRUE;
            return;
        }

        pActive = pActive->pNext;
    }

    *pEnable = FALSE;
}

//------------------------------------------------------------------------------
// D3DDevice_GetRenderState

extern "C"
void WINAPI D3DDevice_GetRenderState(
    D3DRENDERSTATETYPE State,
    DWORD* pValue) 
{ 
    COUNT_API(API_D3DDEVICE_GETRENDERSTATE);

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (State >= D3DRS_MAX || State == 0)
        {
            D3D_ERR("Invalid render state type");
        }
    }

    *pValue = D3D__RenderState[State];
}

//------------------------------------------------------------------------------
// D3DDevice_GetTexture

extern "C"
void WINAPI D3DDevice_GetTexture(
    DWORD Stage,
    D3DBaseTexture** ppTexture) 
{ 
    COUNT_API(API_D3DDEVICE_GETTEXTURE);

    CDevice *pDevice = g_pDevice;
    D3DBaseTexture **Textures = pDevice->m_Textures;

    if (DBG_CHECK(Stage >= D3DTSS_MAXSTAGES))
    {
        D3D_ERR("D3DDevice_GetTexture - Bad texture stage.");
    }

    if (Textures[Stage])
    {
        Textures[Stage]->AddRef();
    }

    *ppTexture = Textures[Stage];
}

//------------------------------------------------------------------------------
// D3DDevice_SetTexture

extern "C"
void WINAPI D3DDevice_SetTexture(
    DWORD Stage,
    D3DBaseTexture* pTexture) 
{ 
    PPUSH pPush;

    COUNT_API(API_D3DDEVICE_SETTEXTURE);

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(Stage >= D3DTSS_MAXSTAGES))
    {
        D3D_ERR("D3DDevice_SetTexture - Bad texture stage.");
    }

    if (DBG_CHECK(pTexture && IsChildSurface(pTexture)))
    {
        D3D_ERR("D3DDevice_SetTexture - a non-top-level surface was cast to a texture");
    }

    if (pTexture == pDevice->m_Textures[Stage])
    {
        COUNT_PERF(PERF_REDUNDANT_SETTEXTURE);
    }

    D3DBaseTexture* pPrevious = pDevice->m_Textures[Stage];

    if (pPrevious)
    {
        pDevice->RecordResourceReadPush(pPrevious);

        InternalRelease(pPrevious);
    }

    pDevice->m_Textures[Stage] = pTexture;

    if (!pTexture)
    {
        pPush = pDevice->StartPush();

        // Disable the texture unit:

        Push1(pPush, NV097_SET_TEXTURE_CONTROL0(Stage), 0);

        pDevice->EndPush(pPush + 2);

        // Set it up so that the new SetTexture will re-enable the shader
        // program again:

        pDevice->m_TextureCubemapAndDimension[Stage] = ~0;

        // The combiner logic needs to know whether a texture is present or
        // not.  We also need to update the shader program:

        D3D__DirtyFlags |= (D3DDIRTYFLAG_COMBINERS | 
                            D3DDIRTYFLAG_SHADER_STAGE_PROGRAM);
    }
    else
    {
        // Reference the new texture:

        InternalAddRef(pTexture);
    
        pPush = pDevice->StartPush();

        // Tell the hardware where and what format:
    
        Push2(pPush, 
              NV097_SET_TEXTURE_OFFSET(Stage), 

              // NV097_SET_TEXTURE_OFFSET:

              pTexture->Data,

              // NV097_SET_TEXTURE_FORMAT:

              pTexture->Format);

        pPush += 3;

        if (pTexture->Size != 0)
        {
            DWORD width = PixelJar::GetLinearWidth(pTexture);
            DWORD height = PixelJar::GetLinearHeight(pTexture);
            DWORD pitch = PixelJar::GetLinearPitch(pTexture);

            // It's an image format, so we have to set the dimension and
            // stride:

            Push1(pPush, 
                  NV097_SET_TEXTURE_CONTROL1(Stage), 
                  DRF_NUMFAST(097, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, pitch));

            Push1(pPush + 2, 
                  NV097_SET_TEXTURE_IMAGE_RECT(Stage), 
                  DRF_NUMFAST(097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, width)
                  | DRF_NUMFAST(097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, height));

            pPush += 4;
        }

        // If the cubemap-ness or dimensionality of the new texture is
        // different from that of the old, we have to reprogram the
        // shader stage program:

        DWORD cubenessAndDimensionality = pTexture->Format 
            & (DRF_NUM(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, ~0) | 
               DRF_NUM(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, ~0));

        if (pDevice->m_TextureCubemapAndDimension[Stage] 
                != cubenessAndDimensionality)
        {
            pDevice->m_TextureCubemapAndDimension[Stage] 
                = cubenessAndDimensionality;

            // Recompute the shader program because of the new texture type:

            D3D__DirtyFlags |= D3DDIRTYFLAG_SHADER_STAGE_PROGRAM;

            if (pPrevious == NULL)
            {
                // Enable the texture unit, since we got here because the 
                // previously set texture was NULL:

                Push1(pPush, 
                      NV097_SET_TEXTURE_CONTROL0(Stage), 
                      pDevice->m_TextureControl0Enabled[Stage]);

                pPush += 2;

                // The combiner logic needs to know whether a texture is 
                // present or not.

                D3D__DirtyFlags |= D3DDIRTYFLAG_COMBINERS;
            }
        }
        else
        {
            // This is the most common fall-through case, where this texture's
            // cubemap-ness and dimensionality is exactly the same as the old.
            // We should never hit this fall-through if the texture unit was
            // previously disabled, though:

            ASSERT(pPrevious != NULL);
        }

        pDevice->EndPush(pPush);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SwitchTexture[_Fast]

extern "C"
#if DBG
_declspec(naked) void D3DFASTCALL D3DDevice_SwitchTexture_Fast(
#else
_declspec(naked) void D3DFASTCALL D3DDevice_SwitchTexture(
#endif
    DWORD Method, // Already encoded with two-dword count
    DWORD Data,
    DWORD Format)
{ 
    COUNT_API(API_D3DDEVICE_SWITCHTEXTURE);

    _asm
    {
        ; ecx = Method 
        ; edx = Data 
        ; [esp+4] = Format 

    Switch_Start:
        mov     eax, g_Device.m_Pusher.m_pPut
        add     eax, 12
        cmp     eax, g_Device.m_Pusher.m_pThreshold
        jae     Switch_MakeSpace
        mov     [g_Device.m_Pusher.m_pPut], eax
        mov     [eax-12], ecx
        mov     ecx, [esp+4]
        mov     [eax-8], edx
        mov     [eax-4], ecx
        ret     4

    Switch_MakeSpace:
        push    edx
        push    ecx
        call    MakeSpace
        pop     ecx
        pop     edx
        jmp     Switch_Start
    }
}

#if DBG

//------------------------------------------------------------------------------
// D3DDevice_SwitchTexture (Debug only)

extern "C"
void D3DFASTCALL D3DDevice_SwitchTexture(
    DWORD Method,
    DWORD Data,
    DWORD Format)
{
    COUNT_API(API_D3DDEVICE_SWITCHTEXTURE);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        DWORD Stage = (Method - 
                PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_OFFSET(0), 2)) / 0x40;

        if ((Stage >= 3) ||
            (Method != 
             PUSHER_METHOD(SUBCH_3D, NV097_SET_TEXTURE_OFFSET(Stage), 2)))
        {
            DPF_ERR("Invalid texture unit encoding");
        }
        if (pDevice->m_Textures[Stage] == NULL)
        {
            DPF_ERR("Can't call SwitchTexture when previous SetTexture "
                    "for this stage was NULL");
        }
        if (IsLinearD3DFORMAT(DecodeD3DFORMAT(Format)))
        {
            DPF_ERR("Can't call SwitchTexture with a linear texture");
        }
        DWORD cubenessAndDimensionality = Format 
            & (DRF_NUM(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, ~0) | 
               DRF_NUM(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, ~0));

        if (pDevice->m_TextureCubemapAndDimension[Stage] 
                != cubenessAndDimensionality)
        {
            DPF_ERR("Cubemap-ness and dimensionality must be same as previous "
                    "texture");
        }
    }

    D3DDevice_SwitchTexture_Fast(Method, Data, Format);
}

#endif DBG

//------------------------------------------------------------------------------
// D3DDevice_GetPalette

extern "C"
void WINAPI D3DDevice_GetPalette(
    DWORD Stage,
    D3DPalette** ppPalette) 
{ 
    COUNT_API(API_D3DDEVICE_GETPALETTE);

    CDevice *pDevice = g_pDevice;
    D3DPalette **Palettes = pDevice->m_Palettes;

    if (DBG_CHECK(Stage >= D3DTSS_MAXSTAGES))
    {
        D3D_ERR("D3DDevice_GetPalette - Bad texture stage.");
    }

    if (Palettes[Stage])
    {
        Palettes[Stage]->AddRef();
    }

    *ppPalette = Palettes[Stage];
}

//------------------------------------------------------------------------------
// D3DDevice_SetPalette

extern "C"
void WINAPI D3DDevice_SetPalette(
    DWORD Stage, 
    D3DPalette *pPalette)
{
    COUNT_API(API_D3DDEVICE_SETPALETTE);

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(Stage >= D3DTSS_MAXSTAGES))
    {
        D3D_ERR("Bad texture stage.");
    }

    if (pPalette == pDevice->m_Palettes[Stage])
    {
        COUNT_PERF(PERF_REDUNDANT_SETPALETTE);
    }

    if (pDevice->m_Palettes[Stage])
    {
        pDevice->RecordResourceReadPush(pDevice->m_Palettes[Stage]);

        InternalRelease(pDevice->m_Palettes[Stage]);
    }

    pDevice->m_Palettes[Stage] = pPalette;

    if (pPalette)
    {
        InternalAddRef(pPalette);

        DWORD contextAndLength 
            = (pPalette->Common >> D3DPALETTE_COMMON_PALETTESET_SHIFT) 
            & D3DPALETTE_COMMON_PALETTESET_MASK;

        ASSERT((contextAndLength & 2) == 0);
        ASSERT(contextAndLength <= 
               (DRF_DEF(097, _SET_TEXTURE_PALETTE, _LENGTH, _32)
              | DRF_DEF(097, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, _B)));
        ASSERT((pPalette->Data & 63) == 0);

        PPUSH pPush = pDevice->StartPush();

        Push1(pPush, 
              NV097_SET_TEXTURE_PALETTE(Stage), 
              pPalette->Data | contextAndLength);

        pDevice->EndPush(pPush + 2);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetTextureStageState

extern "C"
void WINAPI D3DDevice_GetTextureStageState(
    DWORD Stage,
    D3DTEXTURESTAGESTATETYPE Type,
    DWORD* pValue) 
{ 
    COUNT_API(API_D3DDEVICE_GETTEXTURESTAGESTATE);

    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (Stage >= D3DTSS_MAXSTAGES 
            || Type == 0 
            || Type >= D3DTSS_MAX)
        {
            D3D_ERR( "Invalid texture stage or state index" );
        }
    }

    *pValue = D3D__TextureState[Stage][Type];
}

//------------------------------------------------------------------------------
// D3DDevice_SetIndices

extern "C"
void WINAPI D3DDevice_SetIndices(
    D3DIndexBuffer* pIndexBuffer,
    UINT BaseVertexIndex) 
{ 
    COUNT_API(API_D3DDEVICE_SETINDICES);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK((pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER) &&
                  (BaseVertexIndex != 0)))
    {
        D3D_ERR("Can't set non-zero BaseVertexIndex while recording a "
                "push-buffer");
    }
    
    // Reference the new, release the old, remembering that either may be
    // NULL:

    if (pIndexBuffer)
    {
        InternalAddRef(pIndexBuffer);

        D3D__IndexData = (WORD*) pIndexBuffer->Data;
    }
    else
    {
        D3D__IndexData = NULL;
    }

    if (pDevice->m_pIndexBuffer)
    {
        InternalRelease(pDevice->m_pIndexBuffer);
    }

    pDevice->m_pIndexBuffer = pIndexBuffer;
    pDevice->m_IndexBase = BaseVertexIndex;
}

//------------------------------------------------------------------------------
// D3DDevice_GetIndices

extern "C"
void WINAPI D3DDevice_GetIndices(
    D3DIndexBuffer** ppIndexData,
    UINT* pBaseVertexIndex) 
{ 
    COUNT_API(API_D3DDEVICE_GETINDICES);

    CDevice* pDevice = g_pDevice;

    D3DIndexBuffer* pIndexBuffer = pDevice->m_pIndexBuffer;
    if (pIndexBuffer)
    {
        pIndexBuffer->AddRef();

        *ppIndexData = pIndexBuffer;
        *pBaseVertexIndex = pDevice->m_IndexBase;
    }
    else
    {
        *ppIndexData = 0;
        *pBaseVertexIndex = 0;
    }
}

//------------------------------------------------------------------------------
// D3DDevice_AddRef

extern "C"
ULONG WINAPI D3DDevice_AddRef() 
{ 
    CDevice *pDevice = g_pDevice;

    return ++pDevice->m_cRefs;
}

//------------------------------------------------------------------------------
// D3DDevice_Release

extern "C"
ULONG WINAPI D3DDevice_Release() 
{ 
    CDevice *pDevice = g_pDevice;

    if (pDevice->m_cRefs == 1)
    {
        pDevice->UnInit();
        g_pPushBuffer = NULL;
        g_pDevice = NULL;
        ZeroMemory(pDevice, sizeof(*pDevice));

        return 0;
    }

    return --pDevice->m_cRefs;
}
 
//------------------------------------------------------------------------------
// D3DDevice_IsBusy

extern "C"
BOOL WINAPI D3DDevice_IsBusy()
{
    COUNT_API(API_D3DDEVICE_ISBUSY);

    CDevice *pDevice = g_pDevice;

    HWREG *reg = pDevice->m_NvBase;

    // See if the chip is idle.  

    if (GetPhysicalOffset((void*) pDevice->HwGet()) != 
        GetPhysicalOffset((void*) pDevice->m_pKickOff))
    {
        return TRUE;
    }

    // Note that the status check has to come AFTER the push-buffer
    // 'get' check:
    
    return (REG_RD32(reg, NV_PGRAPH_STATUS) != 0);
}

//------------------------------------------------------------------------------
// D3DDevice_BlockUntilIdle

extern "C"
void WINAPI D3DDevice_BlockUntilIdle()
{
    COUNT_API(API_D3DDEVICE_BLOCKUNTILIDLE);
    COUNT_PERFCYCLES(PERF_D3DDEVICE_BLOCKUNTILIDLE_WAITS);
    COUNT_PERFEVENT(D3DPERFEvent_BlockUntilIdle, FALSE);

    KickOffAndWaitForIdle();
}

//------------------------------------------------------------------------------
// D3DDevice_BlockOnFence
//
// Blocks the thread until a specific GPU time has passed.

extern "C"
void WINAPI D3DDevice_BlockOnFence(
    DWORD Time)
{
    COUNT_API(API_D3DDEVICE_BLOCKONFENCE);
    COUNT_PERFCYCLES(PERF_D3DDEVICE_BLOCKONFENCE_WAITS);
    COUNT_PERFEVENT(D3DPERFEvent_BlockOnFence, FALSE);

    BlockOnTime(Time, FALSE);
}

//------------------------------------------------------------------------------
// D3DDevice_KickPushBuffer

extern "C"
void WINAPI D3DDevice_KickPushBuffer()
{
    COUNT_API(API_D3DDEVICE_KICKPUSHBUFFER);

    g_pDevice->KickOff();
}

//------------------------------------------------------------------------------
// D3DDevice_BeginVisibilityTest

extern "C"
void WINAPI D3DDevice_BeginVisibilityTest()
{
    COUNT_API(API_D3DDEVICE_BEGINVISIBILITYTEST);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push2(pPush, NV097_CLEAR_REPORT_VALUE, 

          // NV097_CLEAR_REPORT_VALUE:

          NV097_CLEAR_REPORT_VALUE_TYPE_ZPASS_PIXEL_CNT,

          // NV097_SET_ZPASS_PIXEL_COUNT_ENABLE:

          TRUE);

    pDevice->EndPush(pPush + 3);
}

//------------------------------------------------------------------------------
// GetVisibilityAddress

BYTE* GetVisibilityAddress(
    DWORD Index)
{
    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (Index >= D3DVISIBILITY_TEST_MAX)
        {
            DPF_ERR("Index must be less than D3DVISIBILITY_TEST_MAX");
        }
    }

    // Assert that the divide and modulus we do here will really be shifts
    // and ANDs:

    ASSERT((REPORTS_PER_ALLOCATION & (REPORTS_PER_ALLOCATION - 1)) == 0);

    DWORD allocationIndex = Index / REPORTS_PER_ALLOCATION;
    if (pDevice->m_ReportAllocations[allocationIndex] == NULL)
    {
        // Technically, our allocations don't have to be contiguous, but
        // they do have to be page-locked, uncached, and in the lower 16MB
        // of physical memory:

        pDevice->m_ReportAllocations[allocationIndex]
            = MmAllocateContiguousMemoryEx(REPORTS_ALLOCATION_SIZE,
                                           0,
                                           REPORTS_MAXIMUM_ADDRESS - 1,
                                           0,
                                           PAGE_READWRITE);

        // DOC: If this fails, they can't call GetVisibilityTestResults
        //      for this index!

        if (pDevice->m_ReportAllocations[allocationIndex] == NULL)
        {
            return NULL;
        }
        if (DBG_CHECK(TRUE))
        {
            RtlFillMemoryUlong(pDevice->m_ReportAllocations[allocationIndex],
                               REPORTS_ALLOCATION_SIZE,
                               REPORTS_UNINITIALIZED_MARKER);
        }
    }

    BYTE *virtualAddress = (BYTE *)pDevice->m_ReportAllocations[allocationIndex]
        + (Index % REPORTS_PER_ALLOCATION) * REPORTS_SIZE;

    // When recording a state-block, the write-back never gets kicked off,
    // so don't actually mark the slot as used.  When they do the fix-up is
    // when this should happen.
    // !!! Actually, this should be a passed-in flag.

    if (!(pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER))
    {
        // The hardware always clears the fourth dword to zero, so we use that
        // for our marker:
    
        volatile DWORD* pMarker = (DWORD*) virtualAddress + 3;
    
        if (DBG_CHECK(*pMarker == REPORTS_INCOMPLETE_MARKER))
        {
            DPF_ERR("The previous visibility test for this index hasn't "
                    "completed yet");
        }
    
        *pMarker = REPORTS_INCOMPLETE_MARKER;
    }

    return virtualAddress;
}

//------------------------------------------------------------------------------
// D3DDevice_EndVisibilityTest

extern "C"
HRESULT WINAPI D3DDevice_EndVisibilityTest(
    DWORD Index)
{
    COUNT_API(API_D3DDEVICE_ENDVISIBILITYTEST);

    BYTE* virtualAddress = GetVisibilityAddress(Index);
    if (virtualAddress == NULL)
        return E_OUTOFMEMORY;

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push2(pPush, NV097_SET_ZPASS_PIXEL_COUNT_ENABLE,

          // NV097_SET_ZPASS_PIXEL_COUNT_ENABLE:

          FALSE,

          // NV097_GET_REPORT:
          
          DRF_DEF(097, _GET_REPORT, _TYPE, _ZPASS_PIXEL_CNT)
        | DRF_NUMFAST(097, _GET_REPORT, _OFFSET, GetGPUAddress(virtualAddress)));

    pDevice->EndPush(pPush + 3);

    // Make sure the GPU gets to the 'report' command as soon as possible.
    // This also helps retarded apps that immediately sit and spin on
    // GetVisibilityTestResult after calling EndVisibilityTest:

    pDevice->KickOff();

    return S_OK;
}

//------------------------------------------------------------------------------
// D3DDevice_GetVisibilityTestResult
//
// DOC: EndVisibilityTest doesn't flush the push-buffer, so if someone 
//      immediately spins after doing EndVisibilityTest, they may spin 
//      forever!  Need to expose API to start a push-buffer kickoff...
//
// DOC: Multisampling affects the results!

extern "C"
HRESULT WINAPI D3DDevice_GetVisibilityTestResult(
    DWORD Index,
    UINT* pResult,
    ULONGLONG* pTimeStamp) 
{
    COUNT_API(API_D3DDEVICE_GETVISIBILITYTESTRESULT);

    CDevice* pDevice = g_pDevice;

    DWORD allocationIndex = Index / REPORTS_PER_ALLOCATION;

    if (DBG_CHECK(TRUE))
    {
        if (Index >= D3DVISIBILITY_TEST_MAX)
        {
            DPF_ERR("Index must be less than D3DVISIBILITY_TEST_MAX");
        }
        if (pDevice->m_ReportAllocations[allocationIndex] == NULL)
        {
            DPF_ERR("EndVisibilityTest wasn't called on this index!  "
                    "(Or it failed.)");
        }
    }

    DWORD virtualAddress = (DWORD) pDevice->m_ReportAllocations[allocationIndex]
        + (Index % REPORTS_PER_ALLOCATION) * REPORTS_SIZE;

    // We use the fourth dword as the marker, since the hardware always sets
    // that to zero when done:

    DWORD* pMarker = (DWORD*) virtualAddress + 3;

    if (DBG_CHECK(*pMarker == REPORTS_UNINITIALIZED_MARKER))
    {
        DPF_ERR("EndVisibilityTest wasn't called on this index");
    }

    // These reads are coming from uncached memory, so will be a bit 
    // expensive:

    if (*pMarker == REPORTS_INCOMPLETE_MARKER)
        return D3DERR_TESTINCOMPLETE;

    // The count is in the third dword:

    *pResult = *((DWORD*) virtualAddress + 2);

    // The time-stamp is in the first two dwords:

    if (pTimeStamp)
    {
        *pTimeStamp = *((ULONGLONG*) virtualAddress);
    }

    return S_OK;
}


//------------------------------------------------------------------------------
// D3DDevice_GetDisplayFieldStatus

extern "C"
void WINAPI D3DDevice_GetDisplayFieldStatus(
    D3DFIELD_STATUS *pFieldStatus)
{
    COUNT_API(API_D3DDEVICE_GETDISPLAYFIELDSTATUS);

    CDevice *pDevice = g_pDevice;

    pFieldStatus->VBlankCount = pDevice->m_Miniport.m_VBlankCount;

    if (pDevice->m_Miniport.m_CurrentAvInfo & (AV_FLAGS_INTERLACED | AV_FLAGS_FIELD))
    {
        // Determine even/odd field if it's TV

        if (pDevice->m_Miniport.IsOddField())
        {
            pFieldStatus->Field = D3DFIELD_ODD;
        }
        else
        {
            pFieldStatus->Field = D3DFIELD_EVEN;
        }
    }
    else
    {
        pFieldStatus->Field = D3DFIELD_PROGRESSIVE;  
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetVerticalBlankCallback
//
// Sets the function that will be called on each vertical blank.
// This method will be called at DPC-time.  Set this to NULL to disable
// the callback.

extern "C"
void WINAPI D3DDevice_SetVerticalBlankCallback(
    D3DVBLANKCALLBACK pCallback)
{
    COUNT_API(API_D3DDEVICE_SETVERTICALBLANKCALLBACK);

    g_pDevice->m_Miniport.m_pVerticalBlankCallback = pCallback;
}

//------------------------------------------------------------------------------
// D3DDevice_SetSwapCallback
//
// Sets the function that will be called on each Swap call.
// This method will be called at DPC-time.  Set this to NULL to disable
// the callback.

extern "C"
void WINAPI D3DDevice_SetSwapCallback(
    D3DSWAPCALLBACK pCallback)
{
    COUNT_API(API_D3DDEVICE_SETSWAPCALLBACK);

    g_pDevice->m_Miniport.m_pSwapCallback = pCallback;
}

//------------------------------------------------------------------------------
// D3DDevice_BlockUntilVerticalBlank
//
// Block until the next vertical blank interrupt.  

extern "C"
void WINAPI D3DDevice_BlockUntilVerticalBlank()
{
    COUNT_API(API_D3DDEVICE_BLOCKUNTILVERTICALBLANK);
    COUNT_PERFCYCLES(PERF_D3DDEVICE_BLOCKUNTILVERTICALBLANK_WAITS);

    CDevice *pDevice = g_pDevice;

    // Reset the event.

    KeClearEvent(&pDevice->m_Miniport.m_VerticalBlankEvent);

    // Block on it.

#if DBG

    DWORD Status;
    LARGE_INTEGER TimeOut;

    TimeOut.QuadPart = (LONGLONG)D3D__DeadlockTimeOutVal * (LONGLONG)-10000;

    for (;;)
    {
        Status = KeWaitForSingleObject(&pDevice->m_Miniport.m_VerticalBlankEvent,
                                       UserRequest,
                                       UserMode,
                                       FALSE,
                                       &TimeOut
                                       );

        if (Status != STATUS_TIMEOUT)
        {
            break;
        }

        DXGRIP("Possible deadlock, blocked for more than %d ms.", D3D__DeadlockTimeOutVal);
    }

#else !DBG

    KeWaitForSingleObject(&pDevice->m_Miniport.m_VerticalBlankEvent,
                          UserRequest,
                          UserMode,
                          FALSE,
                          NULL);

#endif !DBG
}

//----------------------------------------------------------------------------
// Flush the vertex cache.

extern "C"
void WINAPI D3DDevice_FlushVertexCache()
{
    COUNT_API(API_D3DDEVICE_FLUSHVERTEXCACHE);

    CDevice *pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_INVALIDATE_VERTEX_CACHE_FILE, 0);

    pDevice->EndPush(pPush + 2);
}

//------------------------------------------------------------------------------
// D3DDevice_GetProjectionViewportMatrix

extern "C"
void WINAPI D3DDevice_GetProjectionViewportMatrix(
    D3DMATRIX* pProjectionViewport)
{
    COUNT_API(API_D3DDEVICE_GETPROJECTIONVIEWPORTMATRIX);

    *pProjectionViewport = g_pDevice->m_ProjectionViewportTransform;
}

//------------------------------------------------------------------------------
// D3DDevice_SetModelView

extern "C"
void WINAPI D3DDevice_SetModelView(
    CONST D3DMATRIX* pModelView,
    CONST D3DMATRIX* pInverseModelView,
    CONST D3DMATRIX* pComposite)
{
    COUNT_API(API_D3DDEVICE_SETMODELVIEW);

    CDevice *pDevice = g_pDevice;

    if (pComposite == NULL)
    {
        if (DBG_CHECK(TRUE))
        {
            if ((pInverseModelView != NULL) || (pModelView != NULL))
            {
                DPF_ERR("All pointers must be NULL to disable");
            }
        }

        D3D__DirtyFlags &= ~D3DDIRTYFLAG_DIRECT_MODELVIEW;
        D3D__DirtyFlags |= D3DDIRTYFLAG_TRANSFORM;

        return;
    }

    if (DBG_CHECK(TRUE))
    {                         
        if (pDevice->m_ConstantMode == D3DSCM_192CONSTANTS)
        {
            DPF_ERR("SetModelView will nuke negative constant registers");
        }
        if (D3D__RenderState[D3DRS_VERTEXBLEND])
        {
            DPF_ERR("Can call SetVertexBlendModelView only when "
                    "D3DRS_VERTEXBLEND is FALSE");
        }
    }

    D3D__DirtyFlags &= ~D3DDIRTYFLAG_TRANSFORM;
    D3D__DirtyFlags |= D3DDIRTYFLAG_DIRECT_MODELVIEW;

    PPUSH pPush = pDevice->StartPush();

    PushMatrixTransposed(pPush, NV097_SET_MODEL_VIEW_MATRIX0(0), pModelView);

    PushMatrixTransposed(pPush + 17, NV097_SET_COMPOSITE_MATRIX(0), pComposite);

    pPush += 34;

    if (pInverseModelView)
    {
        PushInverseModelViewMatrix(pPush, 
                             NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0), 
                             pInverseModelView);
        pPush += 13;
    }

    pDevice->EndPush(pPush);

    if (!(pDevice->m_StateFlags & STATE_PUREDEVICE))
    {
        memcpy(&pDevice->m_ModelViewTransform[0], pModelView, sizeof(D3DMATRIX));
    }
}

//------------------------------------------------------------------------------
// D3DDevice_GetModelView

extern "C"
HRESULT WINAPI D3DDevice_GetModelView(
    D3DMATRIX* pModelView)
{
    COUNT_API(API_D3DDEVICE_GETMODELVIEW);

    CDevice* pDevice = g_pDevice;

    if (pModelView)
    {
        memcpy(pModelView, &pDevice->m_ModelViewTransform[0], sizeof(D3DMATRIX));
    }

    return (D3D__DirtyFlags & D3DDIRTYFLAG_DIRECT_MODELVIEW) ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexBlendModelView

extern "C"
void WINAPI D3DDevice_SetVertexBlendModelView(
    UINT Count,
    CONST D3DMATRIX* pModelViews,
    CONST D3DMATRIX* pInverseModelViews,
    CONST D3DMATRIX* pProjectionViewport)
{
    DWORD i;

    COUNT_API(API_D3DDEVICE_SETVERTEXBLENDMODELVIEW);

    CDevice *pDevice = g_pDevice;

    if (pModelViews == NULL)
    {
        if (DBG_CHECK(TRUE))
        {
            if (pInverseModelViews != NULL)
            {
                DPF_ERR("All pointers must be NULL to disable");
            }
        }

        D3D__DirtyFlags &= ~D3DDIRTYFLAG_DIRECT_MODELVIEW;
        D3D__DirtyFlags |= D3DDIRTYFLAG_TRANSFORM;

        return;
    }

    if (DBG_CHECK(TRUE))
    {
        if (pDevice->m_ConstantMode == D3DSCM_192CONSTANTS)
        {
            DPF_ERR("SetVertexBlendModelViews will nuke negative constant "
                    "registers");
        }
        if ((Count == 0) || (Count > 4))
        {
            DPF_ERR("Count out of range");
        }
        if (!D3D__RenderState[D3DRS_VERTEXBLEND])
        {
            DPF_ERR("Can call SetVertexBlendModelView only when "
                    "D3DRS_VERTEXBLEND is TRUE");
        }
    }

    D3D__DirtyFlags &= ~D3DDIRTYFLAG_TRANSFORM;
    D3D__DirtyFlags |= D3DDIRTYFLAG_DIRECT_MODELVIEW;

    PPUSH pPush = pDevice->StartPush(17 * 2 * Count + 17);

    for (i = 0; i < Count; i++)
    {
        DWORD stride = NV097_SET_MODEL_VIEW_MATRIX1(0) 
                     - NV097_SET_MODEL_VIEW_MATRIX0(0);

        PushMatrixTransposed(pPush, 
                             NV097_SET_MODEL_VIEW_MATRIX0(0) + (i * stride),
                             &pModelViews[i]);

        pPush += 17;
    }

    if (pInverseModelViews)
    {
        for (i = 0; i < Count; i++)
        {
            DWORD stride = NV097_SET_INVERSE_MODEL_VIEW_MATRIX1(0) 
                         - NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0);

            PushInverseModelViewMatrix(
                pPush, 
                NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0) + (i * stride),
                &pInverseModelViews[i]);

            pPush += 13;
        }
    }

    PushMatrixTransposed(pPush,
                         NV097_SET_COMPOSITE_MATRIX(0),
                         pProjectionViewport);

    pPush += 17;

    pDevice->EndPush(pPush);

    if (!(pDevice->m_StateFlags & STATE_PUREDEVICE))
    {
        memcpy(&pDevice->m_ModelViewTransform[0], 
               pModelViews, 
               Count * sizeof(D3DMATRIX));

        memcpy(&pDevice->m_ProjectionViewport, 
               pProjectionViewport, 
               sizeof(D3DMATRIX));
    }
}

//------------------------------------------------------------------------------
// GetVertexBlendModelView

extern "C"
HRESULT WINAPI D3DDevice_GetVertexBlendModelView(
    UINT Count,
    D3DMATRIX* pModelViews,
    D3DMATRIX* pProjectionViewport)
{
    COUNT_API(API_D3DDEVICE_GETVERTEXBLENDMODELVIEW);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(Count > 4))
    {
        DPF_ERR("Can't request more than 4 matrices");
    }

    if (pModelViews)
    {
        memcpy(pModelViews, 
               &pDevice->m_ModelViewTransform[0], 
               Count * sizeof(D3DMATRIX));
    }

    if (pProjectionViewport)
    {
        memcpy(pProjectionViewport,
               &pDevice->m_ProjectionViewport,
               sizeof(D3DMATRIX));
    }

    return (D3D__DirtyFlags & D3DDIRTYFLAG_DIRECT_MODELVIEW) ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------------
// Nop
//
// Used to reserve space for the push-buffer Jump method.

extern "C"
void WINAPI D3DDevice_Nop()
{
    COUNT_API(API_D3DDEVICE_NOP);

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_NO_OPERATION, 0);

    pDevice->EndPush(pPush + 2);
}

//------------------------------------------------------------------------------
// SetTile

extern "C"
void WINAPI D3DDevice_SetTile(
    DWORD Index,
    CONST D3DTILE* pTile)
{
    COUNT_API(API_D3DDEVICE_SETTILE);

    DWORD i;

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if (g_pDevice == NULL)
        {
            DPF_ERR("Device hasn't been initialized yet");
        }
        if (Index >= D3DTILE_MAXTILES)
        {
            DPF_ERR("Can't set any tile index of D3DTILE_MAXTILES (8) or more");
        }
    }

    if ((pTile == NULL) || (pTile->pMemory == NULL))
    {
        // Note that we let the same tile be cleared multiple times.

        pDevice->m_Miniport.DestroyTile(Index, pDevice->m_Tile[Index].ZOffset);

        ZeroMemory(&pDevice->m_Tile[Index], sizeof(D3DTILE));

        return;
    }

    D3DTILE tile = *pTile;

    if (!(tile.Flags & D3DTILE_FLAGS_ZCOMPRESS))
    {
        tile.ZOffset = 0;
        tile.ZStartTag = 0;
    }

    if (DBG_CHECK(TRUE))
    {
        BOOL goodPitch = FALSE;

        AssertContiguous(tile.pMemory);

        if (pDevice->m_Tile[Index].Size != 0)
        {
            DPF_ERR("Tile already in use - set to NULL first if you want to reset");
        }
        if (tile.Flags & ~(D3DTILE_FLAGS_Z32BITS | D3DTILE_FLAGS_ZCOMPRESS | D3DTILE_FLAGS_ZBUFFER))
        {
            DPF_ERR("Invalid Flags");
        }
        if (tile.Size == 0)
        {
            DPF_ERR("Size can't be zero if pMemory is non-zero");
        }
        if ((DWORD) tile.pMemory & 0x3fff)
        {
            DPF_ERR("pMemory must be a multiple of D3DTILE_ALIGNMENT (16k)");
        }
        if (tile.Size & 0x3fff)
        {
            DPF_ERR("Size must be a multiple of D3DTILE_ALIGNMENT (16k)");
        }

#if 0
        // Not true.  The memory allocations can be padded in such a way that
        // the area to be tiled is not a multiple of the interesting pitch.
        // Try 620x240 field rendering with 2 back buffers, for example.
        //
        if ((tile.Size % tile.Pitch) != 0)
        {
            DPF_ERR("Size should be a multiple of Pitch");
        }
#endif

        for (i = 0; i < ARRAYSIZE(g_TilePitches); i++)
        {
            if (g_TilePitches[i] == tile.Pitch)
            {
                goodPitch = TRUE;
            }
        }
        if (!goodPitch)
        {
            DPF_ERR("Pitch must be a valid D3DTILE_PITCH_* value");
        }
        if (tile.Flags & D3DTILE_FLAGS_ZCOMPRESS)
        {
            if (tile.ZStartTag & 0xff)
            {
                DPF_ERR("ZStartTag must be a multiple of 256");
            }
            if (tile.ZStartTag >= D3DTILE_MAXTAGS)
            {
                DPF_ERR("ZStart can't be D3DTILE_MAXTAGS (76800) or more");
            }
            if (tile.ZOffset & 0x3fff)
            {
                DPF_ERR("ZOffset must be a multiple of D3DTILE_ALIGNMENT (16k)");
            }
            if ((tile.ZOffset != 0) && (D3DTILE_ZENDTAG(&tile) <= D3DTILE_MAXTAGS))
            {
                DPF_ERR("ZOffset can only be used for the last buffer - the one "
                        "in which \nthe tags run out (D3DTILE_ZENDTAG(pTile) > D3DTILE_MAXTAGS)");
            }
            for (i = 0; i < D3DTILE_MAXTILES; i++)
            {
                if (pDevice->m_Tile[i].Flags & D3DTILE_FLAGS_ZCOMPRESS)
                {
                    if ((tile.ZStartTag < D3DTILE_ZENDTAG(&pDevice->m_Tile[i])) &&
                        (D3DTILE_ZENDTAG(&tile) > pDevice->m_Tile[i].ZStartTag))
                    {
                        DPF_ERR("Z tag range overlaps with a tag range already in use");
                    }
                }
            }
        }
    }

    pDevice->m_Tile[Index] = tile;

    pDevice->m_Miniport.CreateTile(Index, 
                                   GetGPUAddress(tile.pMemory),
                                   tile.Size,
                                   tile.Pitch,
                                   tile.Flags,
                                   tile.ZStartTag,
                                   tile.ZOffset);
}

//------------------------------------------------------------------------------
// GetTile

extern "C"
void WINAPI D3DDevice_GetTile(
    DWORD Index,
    D3DTILE* pTile)
{
    COUNT_API(API_D3DDEVICE_GETTILE);

    if (DBG_CHECK(TRUE))
    {
        if (g_pDevice == NULL)
        {
            DPF_ERR("Device hasn't been initialized yet");
        }
        if (Index >= D3DTILE_MAXTILES)
        {
            DPF_ERR("Can't set any tile index of D3DTILE_MAXTILES (8) or more");
        }
    }

    *pTile = g_pDevice->m_Tile[Index];
}

//------------------------------------------------------------------------------
// SetTileCompressionTagBits

extern "C"
void WINAPI D3DDevice_SetTileCompressionTagBits(
    DWORD Partition,
    DWORD Address,
    CONST DWORD *pData,
    DWORD Count)
{
    if (DBG_CHECK(TRUE))
    {
        if (g_pDevice == NULL)
        {
            DPF_ERR("Device hasn't been initialized yet");
        }
        if (Partition >= 4)
        {
            DPF_ERR("Partition must be 0 - 3");
        }
        if (Address + Count > 600)
        {
            DPF_ERR("Address + Count must be <= 600");
        }
        if (REG_RD32(g_pDevice->m_NvBase, NV_PGRAPH_STATUS))
        {
            DPF_ERR("GPU should be idle for SetTileCompressionTagBits");
        }
    }

    HWREG *RegBase = g_pDevice->m_NvBase;
    DWORD DataAddress = Address % 16;
    Address /= 16;

    while (Count)
    {
        REG_WR32(RegBase, NV_PFB_RDI_INDEX,
             DRF_NUM(_PFB, _RDI_INDEX, _SELECT, NV_PFB_RDI_INDEX_SELECT_MC_ZTAG_P0 + Partition) |
             DRF_NUM(_PFB, _RDI_INDEX, _ADDRESS, Address++));

        DWORD DwordCount = min(Count, 16 - DataAddress);
        Count -= DwordCount;

        for (DWORD i = DataAddress; i < DwordCount; i++)
        {
            REG_WR32(RegBase, NV_PFB_RDI_DATA(i), *pData++);
        }

        DataAddress = 0;
    }
}

//------------------------------------------------------------------------------
// GetTileCompressionTagBits

extern "C"
void WINAPI D3DDevice_GetTileCompressionTagBits(
    DWORD Partition,
    DWORD Address,
    DWORD *pData,
    DWORD Count)
{
    if (DBG_CHECK(TRUE))
    {
        if (g_pDevice == NULL)
        {
            DPF_ERR("Device hasn't been initialized yet");
        }
        if (Partition >= 4)
        {
            DPF_ERR("Partition must be 0 - 3");
        }
        if (Address + Count > 600)
        {
            DPF_ERR("Address + Count must be <= 600");
        }
        if (REG_RD32(g_pDevice->m_NvBase, NV_PGRAPH_STATUS))
        {
            DPF_ERR("GPU should be idle for GetTileCompressionTagBits");
        }
    }

    HWREG *RegBase = g_pDevice->m_NvBase;
    DWORD DataAddress = Address % 16;
    Address /= 16;

    while (Count)
    {
        REG_WR32(RegBase, NV_PFB_RDI_INDEX,
             DRF_NUM(_PFB, _RDI_INDEX, _SELECT, NV_PFB_RDI_INDEX_SELECT_MC_ZTAG_P0 + Partition) |
             DRF_NUM(_PFB, _RDI_INDEX, _ADDRESS, Address++));

        DWORD DwordCount = min(Count, 16 - DataAddress);
        Count -= DwordCount;

        for (DWORD i = DataAddress; i < DwordCount; i++)
        {
            *pData++ = REG_RD32(RegBase, NV_PFB_RDI_DATA(i));
        }

        DataAddress = 0;
    }
}

//------------------------------------------------------------------------------
// GetTileCompressionTags

extern "C"
DWORD WINAPI D3DDevice_GetTileCompressionTags(
    DWORD ZStartTag,
    DWORD ZEndTag)
{
    COUNT_API(API_D3DDEVICE_GETTILECOMPRESSIONTAGS);

    if (DBG_CHECK(TRUE))
    {
        if (g_pDevice == NULL)
        {
            DPF_ERR("Device hasn't been initialized yet");
        }
        if (ZStartTag & 0xff)
        {
            DPF_ERR("ZStartTag must be a multiple of 256");
        }
        if (ZStartTag >= D3DTILE_MAXTAGS)
        {
            DPF_ERR("ZStart can't be D3DTILE_MAXTAGS (76800) or more");
        }
        if (ZEndTag & 0xff)
        {
            DPF_ERR("ZEndTag must be a multiple of 256");
        }
        if (ZEndTag > D3DTILE_MAXTAGS)
        {
            DPF_ERR("ZEndTag can't be greater than D3DTILE_MAXTAGS (76800)");
        }
        if (ZEndTag < ZStartTag)
        {
            DPF_ERR("ZEndTag must be greater than ZStartTag");
        }
    }

    // Block until the chip is idle
    KickOffAndWaitForIdle();

    /*
     * From: Stefan Gottschalk [SGottschalk@nvidia.com]
     *
     * As mentioned previously, there are 600 32-bit words in each RAM.
     *
     * We have RDI/RDO access to the tag rams.  The NV_PFB_RDI_INDEX has
     * two fields, NV_PFB_RDI_INDEX_SELECT and NV_PFB_RDI_INDEX_ADDRESS.  Setting
     * the select field to the value NV_PFB_RDI_INDEX_SELECT_MC_ZTAG_P0 (0x130)
     * will give access to the tag ram on partition 0.  Setting the address to 0x0
     * will select the first 16 32-bit words in this ram, accessible through the 16
     * registers at NV_PFB_RDI_DATA(0) through NV_PFB_RDI_DATA(15).  Setting the
     * address to 0x1 will select the second 16 words in the ram.  I hear that it
     * is an unusual system for RDI/RDO, but it permits faster access for
     * setting/reading large chunks of tag data.
     */

    HWREG *RegBase = g_pDevice->m_NvBase;

    // count of compressed blocks
    DWORD compressedtags = 0;

    // There are 4 partitions and 32 bits per dword
    DWORD DwordsPerPartition = (ZEndTag - ZStartTag) / (4 * 32);
    DWORD PartitionAddressStart = ZStartTag / (4 * 32);

    // 4 partitions
    for (DWORD partition = 0; partition < 4; partition++)
    {
        DWORD DwordsToRead = DwordsPerPartition;
        DWORD RDIDataStart = PartitionAddressStart % 16;

        // 600 tag DWORDs per partition read in blocks of 16
        for (DWORD AddressOffset = 0; DwordsToRead; AddressOffset++)
        {
            REG_WR32(RegBase, NV_PFB_RDI_INDEX,
                 DRF_NUM(_PFB, _RDI_INDEX, _SELECT, NV_PFB_RDI_INDEX_SELECT_MC_ZTAG_P0 + partition) |
                 DRF_NUM(_PFB, _RDI_INDEX, _ADDRESS, (PartitionAddressStart / 16) + AddressOffset));

            DWORD DwordCount = min(DwordsToRead, 16 - RDIDataStart);
            DwordsToRead -= DwordCount;

            for (DWORD i = RDIDataStart; i < DwordCount; i++)
            {
                DWORD data = REG_RD32(RegBase, NV_PFB_RDI_DATA(i));

                while (data)
                {
                    compressedtags++;
                    data &= (data - 1);
                }
            }

            RDIDataStart = 0;
        }
    }

    return compressedtags;
}


//------------------------------------------------------------------------------
// SetScissors

extern "C"
void WINAPI D3DDevice_SetScissors(
    DWORD Count, 
    BOOL Exclusive, 
    CONST D3DRECT *pRects)
{
    COUNT_API(API_D3DDEVICE_SETSCISSORS);

    CONST D3DRECT* pRect;
    D3DRECT rect;
    DWORD i;

    CDevice* pDevice = g_pDevice;    
    
    if (DBG_CHECK(TRUE))
    {
        if (Count >= D3DSCISSORS_MAX)
        {
            DPF_ERR("Count can't be more than D3DSCISSORS_MAX (8)");
        }
        if (Exclusive > TRUE)
        {
            DPF_ERR("Invalid Exclusive value");
        }
        if ((pRects == NULL) && (Count > 0))
        {
            DPF_ERR("pRects can be NULL only if Count is zero");
        }
        for (pRect = pRects, i = 0; i < Count; i++, pRect++)
        {
            if ((pRect->x1 >= pRect->x2) ||
                (pRect->y1 >= pRect->y2) ||
                (pRect->x1 < 0) ||
                (pRect->y1 < 0) ||
                (pRect->x2 > 4095) ||
                (pRect->y2 > 4095))
            {
                DPF_ERR("Rectangle dimension invalid or out of range");
            }
        }
    }

    if (Count == 0)
    {
        rect.x1 = pDevice->m_Viewport.X;
        rect.y1 = pDevice->m_Viewport.Y;
        rect.x2 = rect.x1 + pDevice->m_Viewport.Width;
        rect.y2 = rect.y1 + pDevice->m_Viewport.Height;

        Exclusive = FALSE;
        pRects = &rect;
        Count = 1;
    }

    // Let the hardware know:

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_WINDOW_CLIP_TYPE, Exclusive);

    pPush += 2;

    FLOAT xScale = pDevice->m_SuperSampleScaleX;
    FLOAT yScale = pDevice->m_SuperSampleScaleY;

    for (pRect = pRects, i = 0; i < Count; i++, pRect++)
    {
        Push1(pPush,
              NV097_SET_WINDOW_CLIP_HORIZONTAL(i),
              DRF_NUMFAST(097,
                          _SET_WINDOW_CLIP_HORIZONTAL,
                          _XMIN,
                          Round(xScale * pRect->x1)) |
              DRF_NUMFAST(097,
                          _SET_WINDOW_CLIP_HORIZONTAL,
                          _XMAX,
                          Round(xScale * pRect->x2) - 1));
    
        Push1(pPush + 2,
              NV097_SET_WINDOW_CLIP_VERTICAL(i),
              DRF_NUMFAST(097,
                          _SET_WINDOW_CLIP_VERTICAL,
                          _YMIN,
                          Round(yScale * pRect->y1)) |
              DRF_NUMFAST(097,
                          _SET_WINDOW_CLIP_VERTICAL,
                          _YMAX,
                          Round(yScale * pRect->y2) - 1));

        pPush += 4;
    }

    pDevice->EndPush(pPush);

    // Remember the new settings:

    memcpy(&pDevice->m_ScissorsRects[0], pRects, Count * sizeof(D3DRECT));

    pDevice->m_ScissorsCount = Count;

    pDevice->m_ScissorsExclusive = Exclusive;
}

//------------------------------------------------------------------------------
// GetScissors

extern "C"
void WINAPI D3DDevice_GetScissors(
    DWORD* pCount, 
    BOOL* pExclusive, 
    D3DRECT* pRects)
{
    COUNT_API(API_D3DDEVICE_GETSCISSORS);

    CDevice* pDevice = g_pDevice;

    if (pCount != NULL)
    {
        *pCount = pDevice->m_ScissorsCount;
    }
    if (pExclusive != NULL)
    {
        *pExclusive = pDevice->m_ScissorsExclusive;
    }
    if (pRects != NULL)
    {
        memcpy(pRects, 
               &pDevice->m_ScissorsRects[0], 
               pDevice->m_ScissorsCount * sizeof(D3DRECT));
    }
}

//------------------------------------------------------------------------------
// PersistDisplay

extern BOOL g_FlickerFilterSet;
extern BOOL g_SoftDisplayFilterSet;

extern "C"
HRESULT WINAPI D3DDevice_PersistDisplay()
{
    COUNT_API(API_D3DDEVICE_PERSISTDISPLAY);

    DWORD Width, Height;
    D3DFORMAT Format;
    SIZE_T AllocSize;
    D3DSurface *pPrimary, *pCopy;
    CDevice *pDevice = g_pDevice;
    HRESULT hr;

    pCopy = (D3DSurface*)AvGetSavedDataAddress();
     
    if (pCopy != NULL)
    {
        MmFreeContiguousMemory(pCopy);
        AvSetSavedDataAddress(NULL);
    }

    // Can't make a copy if the device has already been uninitialized.

    if (pDevice->m_cRefs == 0)
    {
        return E_FAIL;
    }

    // Wait for the present to be processed.

    while (pDevice->m_Miniport.IsFlipPending()) {};

    // Make a copy of the active frame.

    pPrimary = pDevice->m_pFrameBuffer[1];
    Format = PixelJar::GetFormat(pPrimary);
    Width = PixelJar::GetWidth(pPrimary);
    Height = PixelJar::GetHeight(pPrimary);

    hr = CreateSurfaceWithContiguousHeader(Width, Height, Format, &pCopy);
    if (FAILED(hr))
    {
        return hr;
    }

    // Make a copy of the current buffer using the GPU and wait for
    // it to finish, so we don't reboot prematurely.

    D3DDevice_CopyRects(pPrimary, NULL, 0, pCopy, NULL);
    KickOffAndWaitForIdle();

    void *RegisterBase = pDevice->m_Miniport.m_RegisterBase;
    DWORD DisplayMode = pDevice->m_Miniport.m_DisplayMode;
    ULONG Step = 0;

    do
    {
        Step = AvSetDisplayMode(
                RegisterBase,
                Step,
                DisplayMode,
                MapToLinearD3DFORMAT(Format),
                PixelJar::GetPitch(pCopy),
                pCopy->Data);
    }
    while (Step);

    // Make sure the next call to these APIs don't get short-circuited.
    g_FlickerFilterSet = FALSE;
    g_SoftDisplayFilterSet = FALSE;

    // Save the data address and persist this memory across reboots.

    AllocSize = MmQueryAllocationSize(pCopy);
    MmPersistContiguousMemory(pCopy, AllocSize, TRUE);
    AvSetSavedDataAddress(pCopy);

    return S_OK;
}

//------------------------------------------------------------------------------
// GetPersistedSurface

extern "C"
void WINAPI D3DDevice_GetPersistedSurface(
    IDirect3DSurface8 **ppSurface)
{
    *ppSurface = (D3DSurface*)AvGetSavedDataAddress();
}

//------------------------------------------------------------------------------
// Adjusts the aggressiveness of the flicker filter.

BOOL g_FlickerFilterSet;
DWORD g_FlickerFilterValue;

extern "C"
void WINAPI D3DDevice_SetFlickerFilter(
    DWORD Filter)
{
    CDevice *pDevice = g_pDevice;

    if (DBG_CHECK(Filter > 5))
    {
        RIP(("D3DDevice_SetFlickerFilter - Bad value, must be < 6."));
    }

    if (!g_FlickerFilterSet || g_FlickerFilterValue != Filter)
    {
        AvSendTVEncoderOption(pDevice->m_Miniport.m_RegisterBase, 
                              AV_OPTION_FLICKER_FILTER,
                              Filter,
                              NULL);

        g_FlickerFilterSet = TRUE;
        g_FlickerFilterValue = Filter;
    }
}

//------------------------------------------------------------------------------
// Enable the luma 

BOOL g_SoftDisplayFilterSet;
BOOL g_SoftDisplayFilterValue;

extern "C"
void WINAPI D3DDevice_SetSoftDisplayFilter(
    BOOL Enable)
{
    CDevice *pDevice = g_pDevice;

    if (!g_SoftDisplayFilterSet || g_SoftDisplayFilterValue != !!Enable)
    {
        AvSendTVEncoderOption(pDevice->m_Miniport.m_RegisterBase, 
                              AV_OPTION_ENABLE_LUMA_FILTER,
                              Enable,
                              NULL);

        g_SoftDisplayFilterSet = TRUE;
        g_SoftDisplayFilterValue = !!Enable;
    }
}

//
// Private helpers for hardware testing.
//

_declspec(selectany) DWORD g_DoChecksum; 
_declspec(selectany) DWORD g_Channel; 
_declspec(selectany) DWORD g_Value[3]; 

//------------------------------------------------------------------------------ 
// Callback used to calculate the checksum for the current display.  This must
// be passed to D3DDevice_SetVerticalBlankCallback once before
// D3DTest_ScreenChecksum is called.

extern "C"
void __cdecl D3DTest_ChecksumCallback(
    D3DVBLANKDATA *pData)
{ 
    if (g_DoChecksum) 
    { 
        if (g_Channel > 0) 
        { 
            g_Value[g_Channel - 1] = *(volatile DWORD *)0xFD680840 & 0x00FFFFFF; 
        } 

        if (g_Channel < 3) 
        { 
            *(volatile DWORD *)0xFD680844 = 0x411 | (g_Channel << 8); 
            *(volatile DWORD *)0xFD680844 = 0x410 | (g_Channel << 8); 

            g_Channel++; 
        } 
        else 
        { 
            g_Channel = 0; 
            g_DoChecksum = 0; 
        } 
    } 
} 

//------------------------------------------------------------------------------ 
// Calculates the frame's checksum. 

extern "C"
void D3DTest_GetScreenChecksum( 
    DWORD *pRed, 
    DWORD *pGreen, 
    DWORD *pBlue) 
{ 
    g_DoChecksum = 1; 

    while (g_DoChecksum) 
    { 
        D3DDevice_BlockUntilVerticalBlank(); 
    } 

    *pRed   = g_Value[0]; 
    *pGreen = g_Value[1]; 
    *pBlue  = g_Value[2]; 
} 

//------------------------------------------------------------------------------
// Push a fence into the push buffer.

extern "C"
DWORD WINAPI D3DDevice_InsertFence()
{
    COUNT_API(API_D3DDEVICE_INSERTFENCE);

    return SetFence(0);
}

//------------------------------------------------------------------------------
// SetScreenSpaceOffset

extern "C"
void WINAPI D3DDevice_SetScreenSpaceOffset(
    float x,
    float y)
{
    COUNT_API(API_D3DDEVICE_SETSCREENSPACEOFFSET);

    CDevice* pDevice = g_pDevice;

    // We always add KELVIN_BORDER to the offset to match D3D's pixel
    // conventions.  

    pDevice->m_ScreenSpaceOffsetX = x + KELVIN_BORDER;
    pDevice->m_ScreenSpaceOffsetY = y + KELVIN_BORDER;

    CommonSetPassthroughProgram(pDevice);

    PPUSH pPush = pDevice->StartPush();

    pPush = CommonSetViewport(pDevice, pPush);

    pDevice->EndPush(pPush);
}

//------------------------------------------------------------------------------
// GetScreenSpaceOffset

extern "C"
void WINAPI D3DDevice_GetScreenSpaceOffset(
    float *pX,
    float *pY)
{
    COUNT_API(API_D3DDEVICE_GETSCREENSPACEOFFSET);

    CDevice* pDevice = g_pDevice;

    *pX = pDevice->m_ScreenSpaceOffsetX - KELVIN_BORDER;
    *pY = pDevice->m_ScreenSpaceOffsetY - KELVIN_BORDER;
}

//------------------------------------------------------------------------------
// SetOverscanColor

DWORD g_OverscanColor;

extern "C"
void WINAPI D3DDevice_SetOverscanColor(
    D3DCOLOR Color)
{
    double R, G, B;

    DWORD Y, Cr, Cb;
    DWORD RegColor;

    void *RegisterBase = g_pDevice->m_Miniport.m_RegisterBase;
    DWORD AvInfo = g_pDevice->m_Miniport.GetDisplayCapabilities();

    if ((AvInfo & AV_PACK_MASK) == AV_PACK_SCART)
    {
        RegColor = Color & 0x00FFFFFF;
    }
    else
    {
        R = ((Color >> 16) & 0xFF);
        G = ((Color >>  8) & 0xFF);
        B = ((Color >>  0) & 0xFF);

        Y  = (DWORD)(0.2989 * R + 0.5866 * G + 0.1145 * B);
        Cr = (DWORD)(128.0 + 0.5000 * R - 0.4183 * G - 0.0816 * B);
        Cb = (DWORD)(128.0 - 0.1687 * R - 0.3312 * G + 0.5000 * B);

        RegColor = ((Cr & 0xFF) << 16) | ((Y & 0xFF) << 8) | ((Cb & 0xFF) << 0);
    }

    REG_WR32(RegisterBase, NV_PRAMDAC_FP_INACTIVE_PXL_COLOR, RegColor);

    g_OverscanColor = Color;
}

//------------------------------------------------------------------------------
// GetOverscanColor

extern "C"
D3DCOLOR WINAPI D3DDevice_GetOverscanColor()
{
    return g_OverscanColor;
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\d3di.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.hpp
 *  Content:    Direct3D internal include file
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

/*
 * Format of RGBA colors is
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *  |    alpha      |      red      |     green     |     blue      |
 *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 */

#define RGBA_GETALPHA(rgb)      ((rgb) >> 24)
#define RGBA_GETRED(rgb)        (((rgb) >> 16) & 0xff)
#define RGBA_GETGREEN(rgb)      (((rgb) >> 8) & 0xff)
#define RGBA_GETBLUE(rgb)       ((rgb) & 0xff)
#define RGBA_MAKE(r, g, b, a)   ((D3DCOLOR) (((a) << 24) | ((r) << 16) | ((g) << 8) | (b)))

#define D3DVAL(val) ((float)(val))

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\d3dver.h ===
#include <xboxverp.h>

//
// Force the linker to include library version info in the XBLD section
// if we are building d3d8$(D).lib - not d3d8ntpr$(D).lib, which has
// STARTUPANIMATION defined
//

#ifndef STARTUPANIMATION
extern "C"
{
#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_D3D8BuildNumberD")
__declspec(selectany) unsigned short D3D8BuildNumberD[8] = { 'D' | ('3' << 8), 'D' | ('8' << 8), 'D', 0,
                                                             VER_PRODUCTVERSION | 0x8000 };
#elif PROFILE
#pragma comment(linker, "/include:_D3D8BuildNumberP")
__declspec(selectany) unsigned short D3D8BuildNumberP[8] = { 'D' | ('3' << 8), 'D' | ('8' << 8), 'I', 0,
                                                             VER_PRODUCTVERSION };
#elif LTCG
#pragma comment(linker, "/include:_D3D8BuildNumberL")
__declspec(selectany) unsigned short D3D8BuildNumberL[8] = { 'D' | ('3' << 8), 'D' | ('8' << 8), 'L' | ('T' << 8), 'C' | ('G' << 8),
                                                             VER_PRODUCTVERSION | 0x4000 };
#else
#pragma comment(linker, "/include:_D3D8BuildNumber")
__declspec(selectany) unsigned short D3D8BuildNumber[8] = { 'D' | ('3' << 8), 'D' | ('8' << 8), 0, 0,
                                                            VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg()
}
#endif // ! STARTUPANIMATION
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\debug.cpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.cpp
 *  Content:    implementation for debug stuff.
 *
 ***************************************************************************/

#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#if DBG

VOID DXGRIP(PCHAR Format, ...)
{
    CHAR string[MAX_PATH];
    va_list arglist;

    va_start(arglist, Format);
    _vsnprintf(string, sizeof(string), Format, arglist);
    va_end(arglist);

#ifdef STARTUPANIMATION
    DbgPrint(string);
    __asm int 3;
#else
    XDebugError("D3D", string);
#endif
}

VOID WARNING(PCHAR Format, ...)
{
    CHAR string[MAX_PATH];
    va_list arglist;

    va_start(arglist, Format);
    _vsnprintf(string, sizeof(string), Format, arglist);
    va_end(arglist);

#ifdef STARTUPANIMATION
    DbgPrint(string);
#else
    XDebugWarning("D3D", string);
#endif
}

VOID ASSERTMSG(BOOL cond, PCHAR Format, ...)
{
    CHAR string[MAX_PATH];
    va_list arglist;

    if (cond)
    {
        return;
    }

    va_start(arglist, Format);
    _vsnprintf(string, sizeof(string), Format, arglist);
    va_end(arglist);

#ifdef STARTUPANIMATION
    DbgPrint(string);
    __asm int 3;
#else
    XDebugError("D3D", string);
#endif
}

#endif

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\device.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       device.hpp
 *  Content:    Contains all the device associated state.
 *
 ***************************************************************************/

//------------------------------------------------------------------------------
// Externally visible globals (see globals.cpp)

extern "C" 
{ 
    extern DWORD D3D__DeadlockTimeOutVal; 

    extern BOOL D3D__SingleStepPusher;

    extern DWORD D3D__DeadlockTimeOutVal;

    extern BOOL D3D__Parser; 

    extern volatile DWORD *D3D__GpuReg; 

    extern DWORD D3D__AvInfo;
}

//------------------------------------------------------------------------------
// Internally-only visible globals (see globals.cpp)

extern PPUSH g_StartPut;

extern DWORD g_NullHardwareGetPut[2];

// Enforce 16-byte alignment of SSE structure types:

#define D3DALIGN __declspec(align(16))

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{
 
class CDevice;

// This points to our active device structure.  In Xbox, there's only ever
// one...

extern CDevice* g_pDevice;

extern CDevice g_Device;

// Debug-only array for tracking loaded vertex shader programs:

extern BYTE g_LoadedVertexShaderSlot[];

// Debug-only variable for tracking if stencil was ever enabled:

extern BOOL g_StencilEverEnabled;

// Debug-only variable for tracking if caller was ever warned about Z-clears
// being faster if Stencil is cleared at the same time:

extern BOOL g_WarnedAboutStencil;

// Debug-only variable for tracking if caller was ever warned about 
// rops / clipping rects with swizzled textures.

extern BOOL g_WarnAboutCopyRectStateSwizzle;

// Handy prototypes:

BYTE* GetVisibilityAddress(DWORD Index);

VOID FastCopyToWC(PPUSH pPush, DWORD* pSource, DWORD dwCount);

// Make enough room in the push-buffer to hold more space:

PPUSH MakeSpace();

// Handy macros:

#define ARRAYSIZE(_a) (sizeof(_a) / sizeof((_a)[0]))

// The following macro reduces code by telling the compiler that the 'default'
// case in a switch statement should never be reached:

#if DBG
    #define NODEFAULT(Message) DXGRIP(Message)
#else 
    #define NODEFAULT(Message) __assume(0)
#endif

//------------------------------------------------------------------------------
// HWREG
//
// Handy struct declaration for direct access to hardware registers.

typedef union _HWREG
{
    volatile unsigned long Reg032[1];

} HWREG;

//------------------------------------------------------------------------------
// Canonical 'SetVertexDataArrayOffset' ordering, for the NV2A fixed-function
// pipeline:

#define SLOT_POSITION       0
#define SLOT_WEIGHT         1
#define SLOT_NORMAL         2
#define SLOT_DIFFUSE        3
#define SLOT_SPECULAR       4
#define SLOT_FOG            5
#define SLOT_POINT_SIZE     6
#define SLOT_BACK_DIFFUSE   7
#define SLOT_BACK_SPECULAR  8
#define SLOT_TEXTURE0       9
#define SLOT_TEXTURE1       10
#define SLOT_TEXTURE2       11
#define SLOT_TEXTURE3       12
#define SLOT_RESERVED1      13
#define SLOT_RESERVED2      14
#define SLOT_RESERVED3      15

//------------------------------------------------------------------------------
// Short time waster to help us avoid constant querying of the hardware when
// spinning.

VOID BusyLoop();

//------------------------------------------------------------------------------
// Maximum number of swaps that are permitted to be enqueued in the
// push-buffer at once (must be a power of 2):

#define SWAP_THROTTLE_QUEUE_SIZE 2

//------------------------------------------------------------------------------
// Stream

struct Stream
{
    // Stream stride, as specified by SetStreamSource:

    DWORD Stride;

    // Stream offset, as specified by SetStreamOffset:

    DWORD Offset;

    // The associated vertex buffer:

    D3DVertexBuffer* pVertexBuffer;
};

// g_Stream keeps track of all the current selected streams for the device.

extern Stream g_Stream[16];

//------------------------------------------------------------------------------
// VertexShaderSlot
//
// DX8 and the NV2A have 16 register 'slots' usable by the vertex shader
// program.  This structure describes where to find the associated data
// and how to interpret it.

struct VertexShaderSlot
{
    // Our data comes from the following stream:

    DWORD StreamIndex;

    // Byte offset from the start of the stream.  Note that the stream
    // has the actual memory start and stride.

    DWORD Offset;

    // Type and Size, pre-encoded for the SetVertexDataArrayFormat 
    // register, telling us the slot's dimensionality, type (e.g., 
    // 'FLOAT'), and whether it's enabled:

    DWORD SizeAndType;

    // Type of autocalc : 0=none, 1=normal, 2=autotex

    BYTE Flags;

    // Source register for a normal/uv autocalc

    BYTE Source;
};

//------------------------------------------------------------------------------
// VERTEXSHADER flags

// The program can write to the constant registers (has to be '1' so that
// we can just copy to the hardware register after doing an AND):

#define VERTEXSHADER_WRITE 0x1 // Must be 1

// The vertex shader is an XYZRHW passthrough FVF (meaning no hardware T&L
// is used), which we do using a special vertex shader program:

#define VERTEXSHADER_PASSTHROUGH 0x2 

// This is a vertex state shader:

#define VERTEXSHADER_STATE 0x8

// The vertex shader has a program that we have to load:

#define VERTEXSHADER_PROGRAM 0x10 // Must be 16

// The following flags indicate when the vertex shader has an attribute
// of the specified type (either persistent or from the data stream).
//
// These flags must match the values for the corresponding D3DUSAGE_ defines.

#define VERTEXSHADER_HASDIFFUSE 0x400 

#define VERTEXSHADER_HASSPECULAR 0x800 

#define VERTEXSHADER_HASBACKDIFFUSE 0x1000

#define VERTEXSHADER_HASBACKSPECULAR 0x2000

// On Kelvin, a disabled vertex slot has to have a type of 'float' and
// size of '0':

#define SIZEANDTYPE_DISABLED 0x2

// Total number of slots that can be assigned in a vertex shader declaration:

#define VERTEXSHADER_SLOTS 16
                   
//------------------------------------------------------------------------------
// VertexShader
//
// Encapsulates all the data needed to describe a vertex shader program.
                   
struct VertexShader
{
#if DBG

    // This contains the dword value 'Vshd' if the object is valid.

    DWORD Signature;

#endif

    // Reference count:

    DWORD RefCount;

    // VERTEXSHADER_ flags:

    DWORD Flags;

    // Size, in slots, of a programmed vertex shader program (unused for
    // pass-through or FVF shaders):

    DWORD ProgramSize;

    // Size, in dwords, of the push-buffer snippet that loads the vertex 
    // shader function (constants and program data):

    DWORD ProgramAndConstantsDwords;

    // Dimensionality of every texture coordinate specified (applies
    // only to the fixed-function pipeline).  Every byte contains the
    // corresponding dimension (zero if there is no associated texture
    // coordinate):

    DWORD Dimensionality;

    // How to find and interpret the data for each of the vertex shader
    // slots.

    VertexShaderSlot Slot[VERTEXSHADER_SLOTS];

    // Push-buffer snippet containing the push-buffer commands for
    // loading the vertex shader function (constant and program data):

    DWORD ProgramAndConstants[1];
};

// Vertex shader storage used whenever an FVF is specified as the current
// vertex shader program:

extern VertexShader g_FvfVertexShader;

// Vertex shader storage used whenever a struct is used to specify the 
// vertex attribute format:

extern VertexShader g_DirectVertexShader;

//------------------------------------------------------------------------------
// g_UnitsOfElement
//
// Converts from a Kelvin SetVertexDataArrayFormat.Size value to a count
// of units:

D3DCONST BYTE g_UnitsOfElement[] = { 0, 1, 2, 3, 4, 0, 0, 3 };

//------------------------------------------------------------------------------
// g_BytesPerUnit
//
// Converts from a Kelvin SetVertexDataArrayFormat.Type value to a count
// of bytes-per-unit:

D3DCONST BYTE g_BytesPerUnit[] = { 1, 2, 4, 0, 1, 2, 4 };

//------------------------------------------------------------------------------
// IsVertexProgram
//
// Returns TRUE if the vertex shader handle is for a vertex program; FALSE
// if the handle is actually an FVF.

FORCEINLINE BOOL IsVertexProgram(
    DWORD vertexShaderHandle)
{
    return vertexShaderHandle & D3DFVF_RESERVED0;
}

//------------------------------------------------------------------------------
// CheckVertexAttributeFormatStruct prototype
//
// Checks to make sure that valid formats have been provided in the 
// VertexAttributeFormat Struct and also that no formats overlap in a stream.

#if DBG
void CheckVertexAttributeFormatStruct(D3DVERTEXATTRIBUTEFORMAT *pVAF);
#endif

//------------------------------------------------------------------------------
// RestoreVertexShaders prototype

VOID RestoreVertexShaders(
    CONST DWORD* pProgram,
    DWORD Dwords);

//------------------------------------------------------------------------------
// ST
//
// Handy little macro for initializing the SetVertexDataArrayFormat field.

#define ST(Size, Type) \
    (((NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_##Size) << 4) | \
      (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_##Type))
                   
//------------------------------------------------------------------------------
// g_MinFilter

D3DCONST DWORD g_MinFilter[2][3] =
{
    // Min == POINT:

    DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _BOX_LOD0),        // Mip == NONE
    DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _BOX_NEARESTLOD),  // Mip == POINT
    DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _BOX_TENT_LOD),    // Mip == LINEAR

    // Min == LINEAR:

    DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _TENT_LOD0),       // Mip == NONE
    DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _TENT_NEARESTLOD), // Mip == POINT
    DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _TENT_TENT_LOD),   // Mip == LINEAR
};

//------------------------------------------------------------------------------
// MinFilter 

FORCEINLINE DWORD MinFilter(
    DWORD MinFilter,
    DWORD MipFilter)
{
    ASSERT((MinFilter <= D3DTEXF_LINEAR) && (MipFilter <= D3DTEXF_LINEAR));
    ASSERT(MinFilter > D3DTEXF_NONE);

    return g_MinFilter[MinFilter - 1][MipFilter];
}

//------------------------------------------------------------------------------
// PixelShader
//
// Encapsulates all the data needed to describe a pixel shader program.
                   
struct PixelShader
{
#if DBG

    // This contains the dword value 'Pshd' if the object is valid.

    DWORD Signature;

#endif

    // Reference count:

    DWORD RefCount;

    // Flag indicating whether D3D owns the pPSDef memory
    DWORD D3DOwned;

    // A copy of the pixel shader definition

    D3DPIXELSHADERDEF *pPSDef;
};

//------------------------------------------------------------------------------
// Light flags

// The light at this index position has been 'Set' via SetLight at any point
// in time:

#define LIGHT_SET 1

// This light was set since the last BeginStateBlock call:

#define LIGHT_STATEBLOCK_SET 2

// This light was enabled or disabled since the last BeginStateBlock call:

#define LIGHT_STATEBLOCK_ENABLED 4

//------------------------------------------------------------------------------
// Light structure

struct Light
{
    // Light parameters as specified to the API (unmodified);

    D3DLIGHT8 Light8;

    // LIGHT_* flags:

    DWORD Flags;

    // Direction, negated and normalized as for OpenGL:

    D3DVECTOR Direction;        

    // Spotlight falloff parameters:

    FLOAT Falloff_L;
    FLOAT Falloff_M;
    FLOAT Falloff_N;

    // Spotlight scale factor:

    FLOAT Scale;

    // Spotlight direction W:

    FLOAT W;

    // Next light on the active list, from newest to oldest:

    Light* pNext;
};

//------------------------------------------------------------------------------
// InlineAttributeData
//
// Structure describing each inline vertex attribute, for use by UP 
// DrawPrim calls.

struct InlineAttributeData
{
    // The count of dwords for this attribute:

    DWORD UP_Count;

    // The byte stride from the end of this attribute to the start
    // of the next, in the source vertex:

    DWORD UP_Delta;
};

//------------------------------------------------------------------------------
// D3D__DirtyFlags

// The following 'DIRECT' flags indicate that the direct (as opposed
// to the lazily evaluated) versions of these APIs were most recently
// invoked:

#define D3DDIRTYFLAG_DIRECT_MODELVIEW   0x80000000
#define D3DDIRTYFLAG_DIRECT_INPUT       0x40000000

#define D3DDIRTYFLAG_REALLY_FILTHY      (D3DDIRTYFLAG_POINTPARAMS          | \
                                         D3DDIRTYFLAG_TRANSFORM            | \
                                         D3DDIRTYFLAG_TEXTURE_TRANSFORM    | \
                                         D3DDIRTYFLAG_COMBINERS            | \
                                         D3DDIRTYFLAG_TEXTURE_STATE        | \
                                         D3DDIRTYFLAG_LIGHTS               | \
                                         D3DDIRTYFLAG_SPECFOG_COMBINER     | \
                                         D3DDIRTYFLAG_VERTEXFORMAT_VB      | \
                                         D3DDIRTYFLAG_VERTEXFORMAT_UP      | \
                                         D3DDIRTYFLAG_VERTEXFORMAT_OFFSETS | \
                                         D3DDIRTYFLAG_SHADER_STAGE_PROGRAM)

//------------------------------------------------------------------------------
// m_StateFlags

// The hardware currently has DXT noise enabled:

#define STATE_DXTNOISEENABLE 0x1 // Must be one

// Set if the current projection transform dictates that the fog source is
// Z (as opposed to W):

#define STATE_FOGSOURCEZ 0x2

// We're currently recording a push-buffer via BeginPushBuffer:

#define STATE_RECORDPUSHBUFFER 0x4

// The game has defined the D3DCREATE_PUREDEVICE compile-time flag.  In 
// this case, we don't need to remember any state for the purposes of 
// GetRenderState/GetTextureStageState or state blocks.

#define STATE_PUREDEVICE 0x10 // Same as D3DCREATE_PUREDEVICE

// We're currently recording a state block via BeginStateBlock:

#define STATE_RECORDBLOCK 0x20

// Combiner needs specular:

#define STATE_COMBINERNEEDSSPECULAR 0x40

// PushBufferGetOffset was called on the currently recording push-buffer,
// and was already padded with NOPS:

#define STATE_RECORDPUSHBUFFERPADDED 0x80

// The next time a SetRenderTarget is done back to the active back-buffer,
// we'll have to do a FLIPSTALL:

#define STATE_FLIPSTALLPENDING 0x100

// Don't bother setting the magic -38 and -37 registers for vertex shaders
// (they promise that all their vertex shaders will be #pragma screenspace):

#define STATE_NORESERVEDCONSTANTS 0x200

// Set whenever RunPushBuffer is called, on debug builds.  Use only for
// SetDmaRange.

#define STATE_RUNPUSHBUFFERWASCALLED 0x400

// We're in a GPU Begin/End bracket and sending vertices to the GPU:

#define STATE_BEGINENDBRACKET 0x800

// A segment fence should be written as soon as we get out of the Begin/End
// bracket:

#define STATE_SEGMENTFENCEPENDING 0x1000

// We've done all the initialization required to emulate inifinitely fast
// hardware:

#define STATE_NULLHARDWARE 0x2000

// Do the Swap using a copy-blt, either because they specified
// D3DSWAPEFFECT_COPY or because they're in an antialiased mode:

#define STATE_COPYSWAP 0x4000

// The hardware is currently in a multisampling mode:

#define STATE_MULTISAMPLING 0x8000

//------------------------------------------------------------------------------
// Flags for decoding the D3DRS_MULTISAMPLETYPE renderstate, which represents
// our current full-screen antialiasing control

#define ANTIALIAS_SAMPLE_MASK     0x03000
#define ANTIALIAS_MULTISAMPLE     0x01000       // Flag
#define ANTIALIAS_SUPERSAMPLE     0x02000       // Flag

#define ANTIALIAS_LINEAR          0x00000
#define ANTIALIAS_QUINCUNX        0x00100       // Flag
#define ANTIALIAS_GAUSSIAN        0x00200       // Flag

#define ANTIALIAS_XSCALE_MASK     0x00f0
#define ANTIALIAS_XSCALE_SHIFT    4

#define ANTIALIAS_YSCALE_MASK     0x000f
#define ANTIALIAS_YSCALE_SHIFT    0

#define ANTIALIAS_SCALE_MASK      0x000ff
#define ANTIALIAS_TYPE_MASK       0x0ffff

#define ANTIALIAS_FORMAT_MASK     0xf0000

// If any bit in 'ANTIALIAS_ACTIVE' is set, then we're doing antialiasing:

#define ANTIALIAS_ACTIVE ANTIALIAS_SAMPLE_MASK

// Default value when aliasing (sets stretch factors to 1):

#define ANTIALIAS_NONE 0x00011

// Decode the stretch factor:

#define ANTIALIAS_XSCALE(antiAliasType) \
    ((antiAliasType & ANTIALIAS_XSCALE_MASK) >> ANTIALIAS_XSCALE_SHIFT)
    
#define ANTIALIAS_YSCALE(antiAliasType) \
    ((antiAliasType & ANTIALIAS_YSCALE_MASK) >> ANTIALIAS_YSCALE_SHIFT)

//------------------------------------------------------------------------------
// Visibility test reporting stuff

// The memory manager gives us pages with no extra hidden fields, so we can
// use the whole page:

#define REPORTS_ALLOCATION_SIZE 4096

// The hardware writes 16 bytes for every report:

#define REPORTS_SIZE 16

// The hardware writes 16 bytes for every report, so a single page can
// hold 256 reports:

#define REPORTS_PER_ALLOCATION (REPORTS_ALLOCATION_SIZE / REPORTS_SIZE)

// We always allocate a page at a time, so this is the number of allocations
// we'd maximally have to do:

#define REPORTS_ALLOCATIONS_MAX (D3DVISIBILITY_TEST_MAX / REPORTS_PER_ALLOCATION)

// Reserved value which we use to indicate that the visibility 
// test is still incomplete:

#define REPORTS_INCOMPLETE_MARKER 0xffffffff

// Reserved value which we use on debug to tell if this index
// location didn't actually have an EndVisibilityTest done on it:

#define REPORTS_UNINITIALIZED_MARKER 0xfffffffe

// The Offset field of NV097_GET_REPORT is restricted to 24 bits.  For
// simplicity we use our standard DMA mapping for reports and so restrict
// the allocation area to the first 16 MBs:

#define REPORTS_MAXIMUM_ADDRESS (1 << 24)

//------------------------------------------------------------------------------
// CDevice                                                                
//
// Base object for the D3DDevice object

class CDevice : public D3DDevice
{
public:
    // Embedded push buffer structure.  This _must_ be the first variable in 
    // the device or the internal version of StartPush/EndPush will have to do
    // an extra add.
    // 
    // This structure currently only holds the members that need to be exposed
    // outside of the driver or need to be used directly in StartPush/EndPush.

    XMETAL_PushBuffer m_Pusher;

    //--------------------------------------------------------------------------
    // State stuff

    // State flags (STATE_*) that reflect current state: 

    DWORD m_StateFlags;

    // Contains the NV097_SET_TEXTURE_FORMAT style format for the currently
    // selected texture - but only the dimensionality and cubemap-enable 
    // fields are actually valid.  And this will be ~0 if the texture unit
    // is currently disabled.

    DWORD m_TextureCubemapAndDimension[D3DTSS_MAXSTAGES];

    // Current base vertex index as set by SetIndices:

    DWORD m_IndexBase;

    // Index base value for which we last set the vertex format offset 
    // registers (compare and contrast with 'm_IndexBase'):

    DWORD m_CachedIndexBase;

    //--------------------------------------------------------------------------
    // Pusher stuff

    // The size of the push buffer, in bytes. 

    static DWORD m_PushBufferSize;

    // The size of a push buffer segment, in bytes.

    static DWORD m_PushSegmentSize;

    // Points to the start of memory for the push buffer:

    PPUSH m_pPushBase;

    // Points to the first dword following the end of the push buffer:

    PPUSH m_pPushLimit;

    // This is the last 'm_pPut' value written to the hardware via
    // KickOff:

    PPUSH m_pKickOff;

    // The time which any data currently being written into the push
    // buffer will have been processed and it no longer needed by
    // the GPU.  This will get pushed into the segment after it ends.

    DWORD m_CpuTime;

    // Points to the push-buffer 'Time' at which the GPU is currently 
    // processing push-buffer data.  All resources with a time equal to or 
    // less than this value are no longer being used by the GPU.

    volatile DWORD* m_pGpuTime;

    // Index into m_PusherSegment array where the most recent segment's 
    // data was placed:

    DWORD m_PusherLastSegment;

    // AND this value with m_PusherLastSegment to find the segment's
    // index into the m_PusherSegment array:

    DWORD m_PusherSegmentMask;

    // Total number of bytes of RunPushBuffer calls ever inserted into
    // the main push-buffer (does not include any push-buffers called
    // from within a push-buffer). This is the total size at the time 
    // that we put the Run instruction into the push-buffer; 
    // m_Miniport.m_PusherGetRunTotal is the total size at the time that 
    // the Run instruction is actually executed by the GPU.

    DWORD m_PusherPutRunTotal;

    // The completed size of the push-buffer when we last had to wrap back
    // to the beginning:

    DWORD m_PusherLastSize;

    // Time at which the last RunPushBuffer was done, so that we know if
    // any RunPushBuffer commands are pending by the GPU or not:

    DWORD m_LastRunPushBufferTime;

    // Pointer to an array containing the regular-interval segment fences:

    Fence* m_PusherSegment;

    // An array containing the most recent fences, including both segment 
    // fences and inserted fences:

    Fence m_PusherFence[PUSHER_FENCE_COUNT];

    //--------------------------------------------------------------------------
    // Push-buffer record stuff:

    // The push-buffer object into which we're recording:

    D3DPushBuffer* m_pPushBufferRecordResource;

    // When the buffer is too small, we still want to be able to tell the
    // caller the size of the buffer that would have been needed.  This
    // value accounts for any 'wraps' of the push-buffer (where the size
    // needed is this plus the current pointer minus the start pointer).
    //
    // A non-zero value means that the buffer was too small (and so the
    // contents are invalid):

    DWORD m_PushBufferRecordWrapSize;

    // When recording a push-buffer, we hijack the 'm_pThreshold' pointer
    // and hold the old value here:

    PPUSH m_pPushBufferRecordSavedThreshold;

    // When recording a push-buffer, we hijack the 'm_pPut' pointer
    // and hold the old value here.  So this is the 'm_pPut' value at the
    // time that BeginPushBuffer was called:

    PPUSH m_pPushBufferRecordSavedPut;

    //--------------------------------------------------------------------------
    // Miscellaneous stuff

    // Hardware encoded register value that enables this texture stage:

    DWORD m_TextureControl0Enabled[D3DTSS_MAXSTAGES];

    // Pointer to the current pixel shader program (may be NULL):

    PixelShader* m_pPixelShader;

    // Indicates whether the currently installed pixel shader
    // uses the final combiner.  Non-zero if it does.  Only valid 
    // if a pixel shader is set.

    DWORD m_ShaderUsesSpecFog;

    // Indicates whether the currently installed pixel shader
    // wants the texture modes adjusted according to the textures
    // set in each stage.

    DWORD m_ShaderAdjustsTexMode;

    // Used to shadow the actual shader program that we send to the 
    // hardware.  This may be different than the shader program 
    // specified by the app because we have to change it based on 
    // the texture types currently set.

    DWORD m_PSShaderStageProgram;

    // Pointer to the current vertex shader program (will point to
    // g_FvfVertexShader if a FVF vertex type is current).  This
    // value is never NULL:

    VertexShader* m_pVertexShader;

    // Vertex shader handle, as passed in to SetVertexShader:

    DWORD m_VertexShaderHandle;

    // Vertex shader start address valid only if a vertex shader
    // is active.

    DWORD m_VertexShaderStart;

    // Current index buffer, as set by SetIndices:

    D3DIndexBuffer* m_pIndexBuffer;

    // Pointer to the allocated lights array:

    Light* m_pLights;

    // Count of elements in 'm_pLights' array:

    DWORD m_LightCount;

    // Linked list of active lights, in order of most recently activated
    // to least recently:

    Light* m_pActiveLights;

    // Array of pointers to our individual report allocations:

    VOID* m_ReportAllocations[REPORTS_ALLOCATIONS_MAX];

    // The next four member variables are used for pixel shader capture
    // The opcode is used to handshake between D3D and DM

    DWORD m_dwOpcode;
    
    // Indicates whether D3D is in capture mode and what the mode is

    DWORD m_dwSnapshot;
    
    // A pointer to a buffer to hold the capture data for a frame

    DWORD *m_pShaderCaptureBuffer;
    
    // The current write pointer into the capture buffer

    DWORD *m_pShaderCapturePtr;

    // Cache for D3D constants specified via SetPixelShaderConstant.
    // This storage isn't needed if we are a pure device

    DWORD m_pPixelShaderConstants[16];

    // pixelshader struct for use with user pixel shaders

    PixelShader m_UserPixelShader;

    // Holds the current debug marker set by the user

    DWORD m_dwDebugMarker;

    // Pointer to the base of the hardware registers.

    HWREG* m_NvBase;

    // Reference count for this object.

    DWORD m_cRefs;

    //--------------------------------------------------------------------------
    // Cached state

    // Near W, as computed from the perspective transform:

    FLOAT m_WNear;

    // Far W, as computed from the perspective transform:

    FLOAT m_WFar;

    // 1.0f / m_WFar:

    FLOAT m_InverseWFar;

    // Z scale, as based on the Z buffer depth, either 2^16 - 1 or
    // 2^24 - 1:

    FLOAT m_ZScale;

    // A bit array for every stage that indicates whether that stage has
    // a tex-gen mode set that requires the inverse modelview transform:

    DWORD m_TexGenInverseNeeded;

    // Supersampling 'amplifying' factors.  Note that we can have different 
    // scaling factors in X and in Y, so we also have to have a separate
    // scalar factor.
    //
    // Any of these values may be fractional.
    //
    // NOTE: These values are valid for the currently selected render target 
    //       only.

    FLOAT m_SuperSampleScaleX;
    FLOAT m_SuperSampleScaleY;
    FLOAT m_SuperSampleScale;
    FLOAT m_SuperSampleLODBias;

    // Antialiasing 'amplifying' factors for the back-buffer.  Whenever the
    // back-buffer is the current render target, m_SuperSampleScale* values
    // will be set to these:

    FLOAT m_AntiAliasScaleX;
    FLOAT m_AntiAliasScaleY;

    // Pre-computed composite transformation which is the combination of 
    // the projection transform, the viewport, the antialiasing state, and
    // the w-buffering state:

    D3DALIGN D3DMATRIX m_ProjectionViewportTransform;

    // The model-view transforms as set by Set[VertexBlend]ModelView:

    D3DMATRIX m_ModelViewTransform[4];
    D3DMATRIX m_ProjectionViewport;

    // The vertex shader handle as specified to SetVertexShaderInput:

    DWORD m_VertexShaderInputHandle;

    // The number of streams specified to SetVertexShaderInput:

    DWORD m_VertexShaderInputCount;

    // The stream data as specified to SetVertexShaderInput:

    D3DSTREAM_INPUT m_VertexShaderInputStream[16];

    //--------------------------------------------------------------------------
    // Inline vertex cached state
    //
    // Note that the following inline fields, for UP rendering, are cached
    // values valid only when the D3DDIRTYFLAG_VERTEXFORMAT_UP is not set.
    
    // This is the total count of dwords each vertex represents:

    DWORD m_InlineVertexDwords;

    // Start offset, in bytes, from the start of the vertex to the first
    // attribute that has to be sent via the UP inline rendering code:

    DWORD m_InlineStartOffset;

    // Offset, in bytes, from the end of the last attribute to the
    // start of the first attribute:

    DWORD m_InlineDelta;

    // This array describes each attribute of the current vertex shader
    // in a way that can best be chewed up by the UP inline rendering
    // functions:

    InlineAttributeData m_InlineAttributeData[16];

    // Number of attributes for the current vertex shader.  Note that 
    // attributes can be appended together, so this isn't a *true*
    // count of attributes, but is rather the count of elements in the
    // m_InlineAttributeData array.

    DWORD m_InlineAttributeCount;

    //--------------------------------------------------------------------------
    // API state we have to keep

    // Straight copy of whatever matrix was given to us at SetTransform
    // time, indexed using a D3DTS_ value:

    D3DALIGN D3DMATRIX m_Transform[D3DTS_MAX];

    // Current viewport, as set by SetViewport:

    D3DVIEWPORT8 m_Viewport;

    // Current screen space offset, as set by SetScreenSpaceOffset:

    FLOAT m_ScreenSpaceOffsetX;
    FLOAT m_ScreenSpaceOffsetY;

    // Current material as set by SetMaterial:

    D3DMATERIAL8 m_Material;

    // Current material as set by SetBackMaterial:

    D3DMATERIAL8 m_BackMaterial;

    // Current textures, as set by SetTexture:

    D3DBaseTexture *m_Textures[D3DTSS_MAXSTAGES];

    // Corresponding palettes for the textures.

    D3DPalette *m_Palettes[D3DTSS_MAXSTAGES];

    // Current pixel shader constants, as set by SetPixelShaderConstant:

    FLOAT m_PixelShaderConstants[D3DPS_CONSTREG_MAX_DX8][4];

    // Current vertex shader constants, as set by SetVertexShaderConstant:

    FLOAT m_VertexShaderConstants[D3DVS_CONSTREG_COUNT_XBOX][4];

    // Currently loaded vertex shader programs, as set by LoadVertexShader:

    DWORD m_VertexShaderProgramSlots[VSHADER_PROGRAM_SLOTS][4];

    // Constant mode as set by SetShaderConstantMode:

    D3DSHADERCONSTANTMODE m_ConstantMode;

    // Current color format set by SetCopyRectsState and used by CopyRects

    D3DCOPYRECTSTATE m_CopyRectState;
    D3DCOPYRECTROPSTATE m_CopyRectRopState;

    // Original MultiSampleType as passed in at creation/Reset:

    DWORD m_MultiSampleType;

    // Original SwapEffect as passed in at creation/Reset.  
    //
    // NOTE: 0 and D3DSWAPEFFECT_FLIP (2) should be treated equivalently.

    DWORD m_SwapEffect;

    // Swap type:

    DWORD m_PresentationInterval;

    // Keeps track of the times of the last swaps, for swap throttling
    // purposes:

    DWORD m_SwapTime[SWAP_THROTTLE_QUEUE_SIZE];

    //--------------------------------------------------------------------------
    // Screen information

    // Current render target.  This is never NULL (except during 
    // initialization).

    D3DSurface* m_pRenderTarget;

    // Current Z buffer surface.  This may be NULL.

    D3DSurface* m_pZBuffer;

    // The total number of frame buffers, including the front buffer (i.e., 
    // 2 if double buffering, 3 if triple buffering):

    DWORD m_FrameBufferCount;

    // Array of surfaces that point to each frame buffer.  The buffer that
    // is currently visible (that the DAC is scanning from) is at index 1, and 
    // the buffer currently being rendering to is at index 0.
    //
    // Note that with antialiasing, these buffers are not necessarily all the
    // same dimension or format.

    D3DSurface* m_pFrameBuffer[3];

    // Points to the auto-supplied Z buffer.  NULL if none was created or
    // supplied:

    D3DSurface* m_pAutoDepthBuffer;

    // Storage space for the D3D-allocated frame buffer structures, or a
    // copy if the title specified their own via the D3DPRESENT_PARAMETERS
    // BufferSurfaces[] field.

    D3DSurface m_BufferSurfaces[3];

    // Storage space for the D3D-allocate Z buffer structure, or a copy
    // if the title specified their own via the D3DPRESENT_PARAMETERS
    // DepthStencilSurface field.

    D3DSurface m_DepthStencilSurface;    
    
    // Start address for the D3D-allocated frame buffer (virtual address, used 
    // for freeing, NULL if title supplied its own):

    VOID* m_pFrameBufferBase;

    // Start address for the D3D-allocated antialias buffers (virtual address, 
    // used for freeing, NULL if title supplied its own):

    VOID* m_pAntiAliasBufferBase;

    // Start address for the D3D-allocated depth/stencil buffer (virtual address,
    // used for freeing, NULL if title supplied its own):

    VOID* m_pAutoDepthBufferBase;

    // Storage area for saving the original surfaces at the time of a Swap
    // call:

    D3DSurface* m_pSaveRenderTarget;
    D3DSurface* m_pSaveZBuffer;
    D3DBaseTexture* m_pSaveTexture;
    D3DVIEWPORT8 m_SaveViewport;

    // Maintains the status of all currently used tile regions:

    D3DTILE m_Tile[D3DTILE_MAXTILES];

    // The current scissors state:

    D3DRECT m_ScissorsRects[8];

    DWORD m_ScissorsCount;

    BOOL m_ScissorsExclusive;

    //--------------------------------------------------------------------------
    // Miniport stuff

    // Pointer to the hardware push buffer registers:

    Nv20ControlDma* m_pControlDma;

    // Miniport state

    CMiniport m_Miniport;

    // Number of swaps done:

    ULONG m_SwapCount;

    // Context DMA instances, used for modifying DMA contexts on-the-fly
    // for debug-build checking:

    DWORD m_ColorContextDmaInstance;
    DWORD m_ZetaContextDmaInstance;
    DWORD m_CopyContextDmaInstance;

    // Base for all of the cached contiguous memory allocated when the
    // device is initialized, not counting the frame buffers.

    BYTE* m_pCachedContiguousMemoryBase;

    // Notifiers for the memory copy class.
    
    volatile NvNotification* m_pMemCopyNotifiers;

    // Kelvin notifiers.

    volatile NvNotification* m_pKelvinNotifiers;

    //--------------------------------------------------------------------------
    // Methods

    // CDevice initializer:

    HRESULT Init(D3DPRESENT_PARAMETERS* pPresentationParameters);

    // Cleans up:

    VOID UnInit();

    // Creates the frame and back buffers.

    HRESULT InitializeFrameBuffers(D3DPRESENT_PARAMETERS* pPresentationParameters);

    // Frees the frame and back buffers.

    VOID FreeFrameBuffers();

    // Reset any dirty hardware state, for use by UP DrawPrim calls:

    VOID SetStateUP();

    // Reset any dirty hardware state, for use by vertex-buffer DrawPrim calls:

    VOID SetStateVB(DWORD IndexBase);

    //--------------------------------------------------------------------------
    // Pusher stuff

    // Use 'StartPush' if you're not sure at call time of the exact number
    // of dwords you'll be sticking into the buffer.  Give 'StartPush' an
    // upper bound of the count of dwords, and then call 'EndPush' with
    // the final pointer when you're done.
    //
    // Use StartPush() with no arguments to default to ensuring there
    // are at least PUSHER_THRESHOLD_SIZE = 128 dwords.
    //
    // Don't forget to call 'EndPush' when done.

    __forceinline PPUSH StartPush() 
    { 
        // We won't normally need to call 'MakeSpace':

        PPUSH pStart = m_Pusher.m_pPut;

        if (pStart >= m_Pusher.m_pThreshold)
            pStart = MakeSpace();

        DbgRecordPushStart(PUSHER_THRESHOLD_SIZE);

        return pStart;
    }

    __forceinline PPUSH StartPush(DWORD count) 
    { 
        return XMETAL_StartPushCount(&m_Pusher, count); 
    } 

    // 'EndPush' is the companion to 'StartPush', and its parameter is
    // the pointer one past the last dword added:
    
    __forceinline VOID EndPush(PPUSH pPush) 
    { 
        XMETAL_EndPush(&m_Pusher, pPush); 
    }

    // Suppress inserting any fences while we're in a GPU Begin/End bracket
    // (because the hardware falls over if we try):

    __forceinline VOID StartBracket()
    {
        DBG_CHECK(g_StartPut = m_Pusher.m_pPut);
        ASSERT(!(m_StateFlags & STATE_BEGINENDBRACKET));

        m_StateFlags |= STATE_BEGINENDBRACKET;
    }

    // Stop suppressing any fences, and insert an interval fence if one was
    // pending:

    __forceinline VOID EndBracket()
    {
    #if DBG
        DWORD distance = (DWORD) m_Pusher.m_pPut - (DWORD) g_StartPut;
        if ((INT) distance < 0)
            distance += m_PusherLastSize;
        if (distance > m_PushBufferSize / 2)
        {
            WARNING("Vertex or index data for this call exceeded half of the push-buffer size.\n"
                    "Reduce the call size or increase the push-buffer size with SetPushBufferSize.\n");
        }
    #endif
    
        ASSERT(m_StateFlags & STATE_BEGINENDBRACKET);
        if (m_StateFlags & STATE_SEGMENTFENCEPENDING)
        {
            SetFence(SETFENCE_SEGMENT);
        }
        m_StateFlags &= ~(STATE_SEGMENTFENCEPENDING | STATE_BEGINENDBRACKET);
    }

    // Update the hardware's 'put' address.  This lets the GPU start
    // processing whatever's been written into the push-buffer:

    VOID KickOff();

    // Set up the push buffer.

    HRESULT InitializePushBuffer();
    VOID UninitializePushBuffer();

    // Let the hardware know the latest 'put' address.
    
    VOID HwPut(PPUSH pPut) 
    { 
        WRITE_REGISTER(&m_pControlDma->Put, GetGPUAddress((void*) pPut)); 
    }

    // Read the hardware's current 'Get' pointer and shadow the value.
    //
    // NOTE: This register read is actually quite expensive - it affects the
    //       chip's internal pipeline!  
    //
    // NOTE: This returns a weird address if the GPU is currently executing
    //       a static push-buffer!

    PPUSH HwGet() 
    { 
        // The GetWriteCombinedAddress translates the physical memory
        // offset returned by m_pControlDma->Get into a write-
        // combined mapped pointer into the push buffer.  

        return (PPUSH)
            GetWriteCombinedAddress(READ_REGISTER(&m_pControlDma->Get));
    }

    // Returns the current GPU location in the main push-buffer.  
    //
    // NOTE: This returns a value that is always in the main push-buffer, 
    //       even if the GPU is currently executing a static push-buffer.

    PPUSH GpuGet()
    {
        PPUSH pGet = HwGet();
    
        // If the GPU is not currently pulling from the primary push-buffer,
        // then it must currently be executing a push-buffer called via
        // RunPushBuffer.  In that case, get the return address:
    
        if ((pGet < m_pPushBase) || (pGet >= m_pPushLimit))
        {
            // PUSHER_CALL is used every time a push-buffer resource is
            // called from the main push-buffer, so we can simply read
            // the following register to determine our location in the
            // main push-buffer.  (Note that nested push-buffers do not
            // use PUSHER_CALL, so we are guaranteed this address will
            // always be in the main push-buffer):

            pGet = (PPUSH) GetWriteCombinedAddress(
                REG_RD32(m_NvBase, NV_PFIFO_CACHE1_DMA_SUBROUTINE) 
                    & ~NV_PFIFO_CACHE1_DMA_SUBROUTINE_STATE_ACTIVE);

            ASSERT((pGet >= m_pPushBase) && (pGet <= m_pPushLimit));
        }
    
        return pGet;
    }

    // Returns the current GPU time: 

    __forceinline DWORD GpuTime()
    {
        return *m_pGpuTime;
    }

    // Because of potential DWORD time overflow, we can't simply 
    // compare two time values (e.g., 0x6 is 'newer' than 0x3, but 
    // 0xfffffffd may be 'older' than 0x3).  Fortunately, it's safe 
    // to compare 'ages', which are computed relative to the current 
    // time.
    //
    // 'Age' may also be thought of as how many fences ago the 
    // corresponding fence was written (if you shift the result down
    // by PUSHER_TIME_SHIFT).

    DWORD Age(DWORD Time)
    {
        return m_CpuTime - Time;
    }

    // Figure out if a time represents data still in the push buffer.
    // If 'true' is returned, then the GPU isn't yet finished with the
    // object.

    __forceinline BOOL IsTimePending(DWORD Time)
    {   
        ASSERT(Time != 0);

        return Age(Time) < Age(GpuTime());
    }

    // Record where an object is pushed into the push buffer so we know when
    // it can be locked.

    __forceinline VOID RecordResourceReadPush(IDirect3DResource8 *pResource)
    {
        ASSERT(!IsChildSurface(pResource));
        pResource->Lock = m_CpuTime;
    }

    // Record where an object is pushed into the push buffer so we know when
    // it can be locked.

    __forceinline VOID RecordSurfaceWritePush(IDirect3DResource8 *pResource)
    {
        ASSERT(PixelJar::IsSurface(pResource));

        D3DResource *pParent = ((D3DSurface*) pResource)->Parent;

        if (pParent)
        {
            pResource = pParent;
        }

        pResource->Lock = m_CpuTime;
    }
};

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\debug.hpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.hpp
 *  Content:    header file for debug hooks and stuff
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

// For consistency, we never use 'new' or 'delete'.  Use 'MemAlloc' and
// 'MemFree' instead.  (Yes, it's a pain, but allocating memory SHOULD BE
// A PAIN on Xbox.  Plus we get explicit control over zero-initialization.)

#define new dont_use_new
#define delete dont_use_delete

#if DBG

    // DBG_CHECK is to be used to for any parameter validation checks, 
    // in the form:
    //
    //      if (DBG_CHECK(dwFlags & INVALID_FLAGS))
    //          return DDERR_UNSUPPORTED;
    //
    // On free, retail builds, the macro gets converted to a constant '0'
    // and the compiler will remove all the associated code.
       
    #define DBG_CHECK(exp) (exp)
    
#else

    #define DBG_CHECK(exp) FALSE
    
#endif


#if DBG
    
    VOID DXGRIP(PCHAR Format, ...);
    VOID WARNING(PCHAR Format, ...);

    #undef ASSERT
    #define ASSERT(cond)   \
        {                  \
            if (! (cond))  \
            {              \
                DXGRIP("Assertion failure: %s", #cond); \
            }              \
        }

    #undef ASSERTMSG
    VOID ASSERTMSG(BOOL cond, PCHAR Format, ...);

    #define DPF(msg) DXGRIP(msg)
    #define DPF_ERR(msg) DXGRIP(msg)
    #define D3D_ERR(msg) DXGRIP(msg)
    #define DXGASSERT(cond) ASSERT(cond)
    #define DDASSERT(cond) ASSERT(cond)
    #define UNIMPLEMENTED() DXGRIP("Function not yet implemented")

#else

    #define DXGRIP 1 ? (void)0 : (void)
    #define WARNING 1 ? (void)0 : (void)
    
    #undef ASSERT
    #define ASSERT(cond) {}
    #undef ASSERTMSG
    #define ASSERTMSG 1 ? (void)0 : (void)

    #define DPF(msg) {}
    #define DPF_ERR(msg) {}
    #define D3D_ERR(msg) {}
    #define DXGASSERT(cond) {}
    #define DDASSERT(cond) {}
    #define UNIMPLEMENTED() {}

#endif

// Debug code to verify the 'this' pointers passed into our APIs.

#if DBG
    
    inline void CHECK(D3DResource *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        const DWORD Alignments[7] = 
        {
            D3DVERTEXBUFFER_ALIGNMENT,
            D3DINDEXBUFFER_ALIGNMENT,
            D3DPUSHBUFFER_ALIGNMENT,
            D3DPALETTE_ALIGNMENT,
            D3DTEXTURE_ALIGNMENT,
            1,
            D3DFIXUP_ALIGNMENT,
        };

        DWORD Alignment = Alignments[(p->Common & D3DCOMMON_TYPE_MASK) >> D3DCOMMON_TYPE_SHIFT];

        if (p->Data % Alignment)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DBaseTexture *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null this pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_TEXTURE)
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DTEXTURE_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DTexture *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_TEXTURE
            || (p->Format & D3DFORMAT_DIMENSION_MASK) != (2 << D3DFORMAT_DIMENSION_SHIFT)
            || (p->Format & D3DFORMAT_CUBEMAP))
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DTEXTURE_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DVolumeTexture *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_TEXTURE
            || (p->Format & D3DFORMAT_DIMENSION_MASK) != (3 << D3DFORMAT_DIMENSION_SHIFT))
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DTEXTURE_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DCubeTexture *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_TEXTURE
            || !(p->Format & D3DFORMAT_CUBEMAP))
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DTEXTURE_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DVertexBuffer *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_VERTEXBUFFER)
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DVERTEXBUFFER_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DIndexBuffer *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_INDEXBUFFER)
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DINDEXBUFFER_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DPushBuffer *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_PUSHBUFFER)
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DPUSHBUFFER_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DFixup *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_FIXUP)
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DFIXUP_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DPalette *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_PALETTE)
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }

        if (p->Data % D3DPALETTE_ALIGNMENT)
        {
            DXGRIP("%s - Bad data alignment.", func);
        }
    }

    inline void CHECK(D3DSurface *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_SURFACE
            || (p->Format & D3DFORMAT_DIMENSION_MASK) != (2 << D3DFORMAT_DIMENSION_SHIFT))
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }
    }

    inline void CHECK(D3DVolume *p, char *func)
    {
        if (p == NULL)
        {
            DXGRIP("%s - Null THIS pointer.", func);
        }

        if ((p->Common & D3DCOMMON_TYPE_MASK) != D3DCOMMON_TYPE_SURFACE
            || (p->Format & D3DFORMAT_DIMENSION_MASK) != (3 << D3DFORMAT_DIMENSION_SHIFT))
        {
            DXGRIP("%s - This points to the wrong type of object.", func);
        }
    }

#else

    #define CHECK(x, y) { }

#endif

// Debug code to check for blocking errors.  It will assert if we block
// for more than a second.

#if DBG

    extern bool g_DpcRIPFired;

    #define INITDEADLOCKCHECK()   DWORD dwDbgTimeCheck = NtGetTickCount();
    #define DODEADLOCKCHECK()     { if (NtGetTickCount() - dwDbgTimeCheck > D3D__DeadlockTimeOutVal) { RIP(("Possible deadlock, blocked for more than 2 seconds.")); }  if (g_DpcRIPFired) { RIP(("Graphics processor error.")); g_DpcRIPFired = false; } }

#else

    #define INITDEADLOCKCHECK()   {}
    #define DODEADLOCKCHECK()     {}

#endif

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\drawprim.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawprim.hpp
 *  Content:    DrawPrimitive common defines
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)

//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count for this count

D3DCONST DWORD g_TextureFormatMask[9] = 
{
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\dumper.hpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dumper.hpp
 *  Content:    header file for debug-only push buffer dumping
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#if DBG
 
//------------------------------------------------------------------------------
// FieldDescription
//
// Structure to describe every field of every method in an Nvidia class object.

typedef struct _FieldDescription
{
    // Method offset value:

    DWORD Method;

    // Method string:

    CHAR* MethodName;

    // Number of times this method is replicated.  Must be '1' or greater.

    DWORD ReplicationCount[2];

    // If a replicated method, 'Stride' is the byte offset value.  This will
    // be valid only for cases where MethodReplication > 1.

    DWORD ReplicationStride[2];

    // Field string:

    CHAR* FieldName;

    // Field's MSB position.  32 > FieldHighBit > FieldLowBit.

    DWORD FieldHighBit;

    // Field's LSB position.

    DWORD FieldLowBit;

    // Type description (i.e., 'f' for float or 'b' for bitfield).  Capital
    // letters denote write-only fields (which are suppressed from display).

    CHAR FieldType;

} FieldDescription;

#define Zero(method) \
    { method, #method, 1, 1, 0, 0, "Zero", 31, 0, 'b' }
    
#define Void(method, type) \
    { method, #method, 1, 1, 0, 0, "V", 31, 0, type }

#define Field(method, name, high, low, type) \
    { method, #method, 1, 1, 0, 0, name, high, low, type }
    
#define ZeroN(iCount, iStride, method, type) \
    { method(0), #method, iCount, 1, iStride, 0, "Zero", 31, 0, type }
    
#define VoidN(iCount, iStride, method, type) \
    { method(0), #method, iCount, 1, iStride, 0, "V", 31, 0, type }
    
#define FieldN(iCount, iStride, method, name, high, low, type) \
    { method(0), #method, iCount, 1, iStride, 0, name, high, low, type }
    
#define ZeroNm(iCount, jCount, iStride, jStride, method, type) \
    { method(0, 0), #method, iCount, jCount, iStride, jStride, "Zero", 31, 0, type }
    
#define VoidNm(iCount, jCount, iStride, jStride, method, type) \
    { method(0, 0), #method, iCount, jCount, iStride, jStride, "V", 31, 0, type }
    
#define FieldNm(iCount, jCount, iStride, jStride, method, name, high, low, type) \
    { method(0, 0), #method, iCount, jCount, iStride, jStride, name, high, low, type }
    
//------------------------------------------------------------------------------
// g_Kelvin

D3DCONST FieldDescription g_Kelvin[] =
{
Zero(NV097_NO_OPERATION),
Field(NV097_NOTIFY, "TYPE", 31, 0, 'b'),
Void(NV097_SET_WARNING_ENABLE, 'b'),
Field(NV097_GET_STATE, "GETSTATE", 31, 0, 'b'),
Zero(NV097_WAIT_FOR_IDLE),
Void(NV097_PM_TRIGGER, 'b'),
Void(NV097_SET_FLIP_READ, 'b'),
Void(NV097_SET_FLIP_WRITE, 'b'),
Void(NV097_SET_FLIP_MODULO, 'b'),
Zero(NV097_FLIP_INCREMENT_WRITE),
Zero(NV097_FLIP_STALL),
Void(NV097_SET_CONTEXT_DMA_NOTIFIES, 'b'),
Void(NV097_SET_CONTEXT_DMA_A, 'b'),
Void(NV097_SET_CONTEXT_DMA_B, 'b'),
Void(NV097_SET_CONTEXT_DMA_STATE, 'b'),
Void(NV097_SET_CONTEXT_DMA_COLOR, 'b'),
Void(NV097_SET_CONTEXT_DMA_ZETA, 'b'),
Void(NV097_SET_CONTEXT_DMA_VERTEX_A, 'b'),
Void(NV097_SET_CONTEXT_DMA_VERTEX_B, 'b'),
Void(NV097_SET_CONTEXT_DMA_SEMAPHORE, 'b'),
Void(NV097_SET_CONTEXT_DMA_REPORT, 'b'),
Field(NV097_SET_SURFACE_CLIP_HORIZONTAL, "X", 15, 0, 'b'),
Field(NV097_SET_SURFACE_CLIP_HORIZONTAL, "WIDTH", 31, 16, 'b'),
Field(NV097_SET_SURFACE_CLIP_VERTICAL, "Y", 15, 0, 'b'),
Field(NV097_SET_SURFACE_CLIP_VERTICAL, "HEIGHT", 31, 16, 'b'),
Field(NV097_SET_SURFACE_PITCH, "COLOR", 15, 0, 'b'),
Field(NV097_SET_SURFACE_PITCH, "ZETA", 31, 16, 'b'),
Void(NV097_SET_SURFACE_COLOR_OFFSET, 'b'),
Void(NV097_SET_SURFACE_ZETA_OFFSET, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "A_MAP", 31, 29, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "A_ALPHA", 28, 28, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "A_SOURCE", 27, 24, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "B_MAP", 23, 21, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "B_ALPHA", 20, 20, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "B_SOURCE", 19, 16, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "C_MAP", 15, 13, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "C_ALPHA", 12, 12, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "C_SOURCE", 11, 8, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "D_MAP", 7, 5, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "D_ALPHA", 4, 4, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_ICW, "D_SOURCE", 3, 0, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "A_MAP", 31, 29, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "A_ALPHA", 28, 28, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "A_SOURCE", 27, 24, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "B_MAP", 23, 21, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "B_ALPHA", 20, 20, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "B_SOURCE", 19, 16, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "C_MAP", 15, 13, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "C_ALPHA", 12, 12, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "C_SOURCE", 11, 8, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "D_MAP", 7, 5, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "D_ALPHA", 4, 4, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_ICW, "D_SOURCE", 3, 0, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_FACTOR0, "BLUE", 7, 0, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_FACTOR0, "GREEN", 15, 8, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_FACTOR0, "RED", 23, 16, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_FACTOR0, "ALPHA", 31, 24, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_FACTOR1, "BLUE", 7, 0, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_FACTOR1, "GREEN", 15, 8, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_FACTOR1, "RED", 23, 16, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_FACTOR1, "ALPHA", 31, 24, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_OCW, "OPERATION", 31, 15, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_OCW, "MUX_ENABLE", 14, 14, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_OCW, "SUM_DST", 11, 8, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_OCW, "AB_DST", 7, 4, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_ALPHA_OCW, "CD_DST", 3, 0, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "A_INVERSE", 31, 29, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "A_ALPHA", 28, 28, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "A_SOURCE", 27, 24, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "B_INVERSE", 23, 21, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "B_ALPHA", 20, 20, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "B_SOURCE", 19, 16, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "C_INVERSE", 15, 13, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "C_ALPHA", 12, 12, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "C_SOURCE", 11, 8, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "D_INVERSE", 7, 5, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "D_ALPHA", 4, 4, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "D_SOURCE", 3, 0, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "E_INVERSE", 31, 29, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "E_ALPHA", 28, 28, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "E_SOURCE", 27, 24, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "F_INVERSE", 23, 21, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "F_ALPHA", 20, 20, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "F_SOURCE", 19, 16, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "G_INVERSE", 15, 13, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "G_ALPHA", 12, 12, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "G_SOURCE", 11, 8, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "SPECULAR_CLAMP", 7, 7, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "SPECULAR_ADD_INVERT_R5", 6, 6, 'b'),
Field(NV097_SET_COMBINER_SPECULAR_FOG_CW0, "SPECULAR_ADD_INVERT_R12", 5, 0, 'b'),
Field(NV097_SET_CONTROL0, "COLOR_SPACE_CONVERT", 31, 28, 'b'),
Field(NV097_SET_CONTROL0, "PREMULTIPLIEDALPHA", 27, 24, 'b'),
Field(NV097_SET_CONTROL0, "TEXTUREPERSPECTIVE", 23, 20, 'b'),
Field(NV097_SET_CONTROL0, "Z_PERSPECTIVE_ENABLE", 19, 16, 'b'),
Field(NV097_SET_CONTROL0, "Z_FORMAT", 15, 12, 'b'),
Field(NV097_SET_CONTROL0, "STENCIL_WRITE_ENABLE", 7, 0, 'b'),
Field(NV097_SET_LIGHT_CONTROL, "LOCALEYE", 16, 16, 'b'),
Field(NV097_SET_LIGHT_CONTROL, "SOUT", 31, 17, 'b'),
Field(NV097_SET_LIGHT_CONTROL, "SEPARATE_SPECULAR_EN", 1, 0, 'b'),
Field(NV097_SET_COLOR_MATERIAL, "EMISSIVE_MATERIAL", 1, 0, 'b'),
Field(NV097_SET_COLOR_MATERIAL, "AMBIENT_MATERIAL", 3, 2, 'b'),
Field(NV097_SET_COLOR_MATERIAL, "DIFF_MATERIAL", 5, 4, 'b'),
Field(NV097_SET_COLOR_MATERIAL, "SPECULAR_MATERIAL", 7, 6, 'b'),
Field(NV097_SET_COLOR_MATERIAL, "BACK_EMISSIVE_MATERIAL", 9, 8, 'b'),
Field(NV097_SET_COLOR_MATERIAL, "BACK_AMBIENT_MATERIAL", 11, 10, 'b'),
Field(NV097_SET_COLOR_MATERIAL, "BACK_DIFF_MATERIAL", 13, 12, 'b'),
Field(NV097_SET_COLOR_MATERIAL, "SPECULAR_MATERIAL", 15, 14, 'b'),
Void(NV097_SET_FOG_MODE, 'b'),
Void(NV097_SET_FOG_GEN_MODE, 'b'),
Void(NV097_SET_FOG_ENABLE, 'b'),
Field(NV097_SET_FOG_COLOR, "RED", 7, 0, 'b'),
Field(NV097_SET_FOG_COLOR, "GREEN", 15, 8, 'b'),
Field(NV097_SET_FOG_COLOR, "BLUE", 23, 16, 'b'),
Field(NV097_SET_FOG_COLOR, "ALPHA", 31, 24, 'b'),
VoidN(4, 4, NV097_SET_COLOR_KEY_COLOR, 'b'),
Void(NV097_SET_WINDOW_CLIP_TYPE, 'b'),
FieldN(8, 4, NV097_SET_WINDOW_CLIP_HORIZONTAL, "XMIN", 11, 0, 'b'),
FieldN(8, 4, NV097_SET_WINDOW_CLIP_HORIZONTAL, "XMAX", 27, 16, 'b'),
FieldN(8, 4, NV097_SET_WINDOW_CLIP_VERTICAL, "YMIN", 11, 0, 'b'),
FieldN(8, 4, NV097_SET_WINDOW_CLIP_VERTICAL, "YMAX", 27, 16, 'b'),
Void(NV097_SET_ALPHA_TEST_ENABLE, 'b'),
Void(NV097_SET_BLEND_ENABLE, 'b'),
Void(NV097_SET_CULL_FACE_ENABLE, 'b'),
Void(NV097_SET_DEPTH_TEST_ENABLE, 'b'),
Void(NV097_SET_DITHER_ENABLE, 'b'),
Void(NV097_SET_LIGHTING_ENABLE, 'b'),
Void(NV097_SET_POINT_PARAMS_ENABLE, 'b'),
Void(NV097_SET_POINT_SMOOTH_ENABLE, 'b'),
Void(NV097_SET_LINE_SMOOTH_ENABLE, 'b'),
Void(NV097_SET_POLY_SMOOTH_ENABLE, 'b'),
Void(NV097_SET_STIPPLE_CONTROL, 'b'),
VoidN(32, 4, NV097_SET_STIPPLE_PATTERN, 'b'),
Void(NV097_SET_SKIN_MODE, 'b'),
Void(NV097_SET_STENCIL_TEST_ENABLE, 'b'),
Void(NV097_SET_POLY_OFFSET_POINT_ENABLE, 'b'),
Void(NV097_SET_POLY_OFFSET_LINE_ENABLE, 'b'),
Void(NV097_SET_POLY_OFFSET_FILL_ENABLE, 'b'),
Void(NV097_SET_ALPHA_FUNC, 'b'),
Void(NV097_SET_ALPHA_REF, 'b'),
Void(NV097_SET_BLEND_FUNC_SFACTOR, 'b'),
Void(NV097_SET_BLEND_FUNC_DFACTOR, 'b'),
Void(NV097_SET_BLEND_COLOR, 'b'),
Void(NV097_SET_BLEND_EQUATION, 'b'),
Void(NV097_SET_DEPTH_FUNC, 'b'),
Void(NV097_SET_COLOR_MASK, 'b'),
Void(NV097_SET_DEPTH_MASK, 'b'),
Void(NV097_SET_STENCIL_MASK, 'b'),
Void(NV097_SET_STENCIL_FUNC, 'b'),
Void(NV097_SET_STENCIL_FUNC_REF, 'b'),
Void(NV097_SET_STENCIL_FUNC_MASK, 'b'),
Void(NV097_SET_STENCIL_OP_FAIL, 'b'),
Void(NV097_SET_STENCIL_OP_ZFAIL, 'b'),
Void(NV097_SET_STENCIL_OP_ZPASS, 'b'),
Void(NV097_SET_SHADE_MODE, 'b'),
Void(NV097_SET_LINE_WIDTH, 'b'),
Void(NV097_SET_POLYGON_OFFSET_SCALE_FACTOR, 'f'),
Void(NV097_SET_POLYGON_OFFSET_BIAS, 'f'),
Void(NV097_SET_FRONT_POLYGON_MODE, 'b'),
Void(NV097_SET_BACK_POLYGON_MODE, 'b'),
Void(NV097_SET_CLIP_MIN, 'f'),
Void(NV097_SET_CLIP_MAX, 'f'),
Void(NV097_SET_CULL_FACE, 'b'),
Void(NV097_SET_FRONT_FACE, 'b'),
Void(NV097_SET_NORMALIZATION_ENABLE, 'b'),
VoidN(3, 4, NV097_SET_MATERIAL_EMISSION, 'f'),
Void(NV097_SET_MATERIAL_ALPHA, 'f'),
Void(NV097_SET_BACK_MATERIAL_ALPHA, 'f'),
Void(NV097_SET_SPECULAR_ENABLE, 'b'),
Field(NV097_SET_LIGHT_ENABLE_MASK, "LIGHT0", 1, 0, 'b'),
Field(NV097_SET_LIGHT_ENABLE_MASK, "LIGHT1", 3, 2, 'b'),
Field(NV097_SET_LIGHT_ENABLE_MASK, "LIGHT2", 5, 4, 'b'),
Field(NV097_SET_LIGHT_ENABLE_MASK, "LIGHT3", 7, 6, 'b'),
Field(NV097_SET_LIGHT_ENABLE_MASK, "LIGHT4", 9, 8, 'b'),
Field(NV097_SET_LIGHT_ENABLE_MASK, "LIGHT5", 11, 10, 'b'),
Field(NV097_SET_LIGHT_ENABLE_MASK, "LIGHT6", 13, 12, 'b'),
Field(NV097_SET_LIGHT_ENABLE_MASK, "LIGHT7", 15, 14, 'b'),
VoidNm(8, 2, 16, 4, NV097_SET_VERTEX_DATA2F_M, 'f'),
VoidNm(16, 4, 16, 4, NV097_SET_VERTEX_DATA4F_M, 'f'),
VoidN(16, 4, NV097_SET_VERTEX_DATA2S, 'b'),
VoidN(16, 4, NV097_SET_VERTEX_DATA4UB, 'b'),
VoidNm(16, 2, 8, 4, NV097_SET_VERTEX_DATA4S_M, 'b'),
VoidN(4, 16, NV097_SET_TEXGEN_S, 'b'),
VoidN(4, 16, NV097_SET_TEXGEN_T, 'b'),
VoidN(4, 16, NV097_SET_TEXGEN_R, 'b'),
VoidN(4, 16, NV097_SET_TEXGEN_Q, 'b'),
Void(NV097_SET_TEXGEN_VIEW_MODEL, 'b'),
VoidN(4, 4, NV097_SET_TEXTURE_MATRIX_ENABLE, 'b'),
Void(NV097_SET_POINT_SIZE, 'b'),
Void(NV097_SET_SWATH_WIDTH, 'b'),
Void(NV097_SET_FLAT_SHADE_OP, 'b'),
VoidN(16, 4, NV097_SET_PROJECTION_MATRIX, 'f'),
VoidN(16, 4, NV097_SET_MODEL_VIEW_MATRIX0, 'f'),
VoidN(16, 4, NV097_SET_MODEL_VIEW_MATRIX1, 'f'),
VoidN(16, 4, NV097_SET_MODEL_VIEW_MATRIX2, 'f'),
VoidN(16, 4, NV097_SET_MODEL_VIEW_MATRIX3, 'f'),
VoidN(16, 4, NV097_SET_INVERSE_MODEL_VIEW_MATRIX0, 'f'),
VoidN(16, 4, NV097_SET_INVERSE_MODEL_VIEW_MATRIX1, 'f'),
VoidN(16, 4, NV097_SET_INVERSE_MODEL_VIEW_MATRIX2, 'f'),
VoidN(16, 4, NV097_SET_INVERSE_MODEL_VIEW_MATRIX3, 'f'),
VoidN(16, 4, NV097_SET_COMPOSITE_MATRIX, 'f'),
VoidN(16, 4, NV097_SET_TEXTURE_MATRIX0, 'f'),
VoidN(16, 4, NV097_SET_TEXTURE_MATRIX1, 'f'),
VoidN(16, 4, NV097_SET_TEXTURE_MATRIX2, 'f'),
VoidN(16, 4, NV097_SET_TEXTURE_MATRIX3, 'f'),
VoidNm(4, 4, 64, 4, NV097_SET_TEXGEN_PLANE_S, 'f'),
VoidNm(4, 4, 64, 4, NV097_SET_TEXGEN_PLANE_T, 'f'),
VoidNm(4, 4, 64, 4, NV097_SET_TEXGEN_PLANE_R, 'f'),
VoidNm(4, 4, 64, 4, NV097_SET_TEXGEN_PLANE_Q, 'f'),
VoidN(3, 4, NV097_SET_FOG_PARAMS, 'f'),
VoidN(4, 4, NV097_SET_FOG_PLANE, 'f'),
VoidN(6, 4, NV097_SET_SPECULAR_PARAMS, 'f'),
VoidN(6, 4, NV097_SET_BACK_SPECULAR_PARAMS, 'f'),
VoidN(3, 4, NV097_SET_SCENE_AMBIENT_COLOR, 'f'),
VoidN(4, 4, NV097_SET_VIEWPORT_SCALE, 'f'),
VoidN(4, 4, NV097_SET_VIEWPORT_OFFSET, 'f'),
VoidN(8, 4, NV097_SET_POINT_PARAMS, 'f'),
VoidN(4, 4, NV097_SET_EYE_POSITION, 'f'),
VoidNm(8, 3, 64, 4, NV097_SET_BACK_LIGHT_AMBIENT_COLOR, 'f'),
VoidNm(8, 3, 64, 4, NV097_SET_BACK_LIGHT_DIFFUSE_COLOR, 'f'),
VoidNm(8, 3, 64, 4, NV097_SET_BACK_LIGHT_SPECULAR_COLOR, 'f'),
VoidNm(8, 3, 128, 4, NV097_SET_LIGHT_AMBIENT_COLOR, 'f'),
VoidNm(8, 3, 128, 4, NV097_SET_LIGHT_DIFFUSE_COLOR, 'f'),
VoidNm(8, 3, 128, 4, NV097_SET_LIGHT_SPECULAR_COLOR, 'f'),
VoidN(8, 128, NV097_SET_LIGHT_LOCAL_RANGE, 'f'),
VoidNm(8, 3, 128, 4, NV097_SET_LIGHT_INFINITE_HALF_VECTOR, 'f'),
VoidNm(8, 3, 128, 4, NV097_SET_LIGHT_INFINITE_DIRECTION, 'f'),
VoidNm(8, 3, 128, 4, NV097_SET_LIGHT_SPOT_FALLOFF, 'f'),
VoidNm(8, 4, 128, 4, NV097_SET_LIGHT_SPOT_DIRECTION, 'f'),
VoidNm(8, 3, 128, 4, NV097_SET_LIGHT_LOCAL_POSITION, 'f'),
VoidNm(8, 3, 128, 4, NV097_SET_LIGHT_LOCAL_ATTENUATION, 'f'),
VoidN(3, 4, NV097_SET_VERTEX3F, 'f'),
VoidN(4, 4, NV097_SET_VERTEX4F, 'f'),
VoidN(2, 4, NV097_SET_VERTEX4S, 'b'),
VoidN(3, 4, NV097_SET_NORMAL3F, 'f'),
VoidN(2, 4, NV097_SET_NORMAL3S, 'b'),
VoidN(4, 4, NV097_SET_DIFFUSE_COLOR4F, 'f'),
VoidN(3, 4, NV097_SET_DIFFUSE_COLOR3F, 'f'),
Void(NV097_SET_DIFFUSE_COLOR4UB, 'b'),
VoidN(4, 4, NV097_SET_SPECULAR_COLOR4F, 'f'),
VoidN(3, 4, NV097_SET_SPECULAR_COLOR3F, 'f'),
Void(NV097_SET_SPECULAR_COLOR4UB, 'b'),
VoidN(2, 4, NV097_SET_TEXCOORD0_2F, 'f'),
Void(NV097_SET_TEXCOORD0_2S, 'b'),
VoidN(4, 4, NV097_SET_TEXCOORD0_4F, 'f'),
VoidN(2, 4, NV097_SET_TEXCOORD0_4S, 'b'),
VoidN(2, 4, NV097_SET_TEXCOORD0_2F, 'f'),
Void(NV097_SET_TEXCOORD1_2S, 'b'),
VoidN(4, 4, NV097_SET_TEXCOORD1_4F, 'f'),
VoidN(2, 4, NV097_SET_TEXCOORD1_4S, 'b'),
VoidN(2, 4, NV097_SET_TEXCOORD1_2F, 'f'),
Void(NV097_SET_TEXCOORD2_2S, 'b'),
VoidN(4, 4, NV097_SET_TEXCOORD2_4F, 'f'),
VoidN(2, 4, NV097_SET_TEXCOORD2_4S, 'b'),
VoidN(2, 4, NV097_SET_TEXCOORD2_2F, 'f'),
Void(NV097_SET_TEXCOORD3_2S, 'b'),
VoidN(4, 4, NV097_SET_TEXCOORD3_4F, 'f'),
VoidN(2, 4, NV097_SET_TEXCOORD3_4S, 'b'),
Void(NV097_SET_FOG1F, 'f'),
Void(NV097_SET_WEIGHT1F, 'f'),
VoidN(2, 4, NV097_SET_WEIGHT2F, 'f'),
VoidN(3, 4, NV097_SET_WEIGHT3F, 'f'),
VoidN(4, 4, NV097_SET_WEIGHT4F, 'f'),
Void(NV097_SET_EDGE_FLAG, 'b'),
VoidN(4, 4, NV097_SET_TRANSFORM_FIXED_CONST0, 'f'),
VoidN(4, 4, NV097_SET_TRANSFORM_FIXED_CONST1, 'f'),
VoidN(4, 4, NV097_SET_TRANSFORM_FIXED_CONST2, 'f'),
VoidN(4, 4, NV097_SET_TRANSFORM_FIXED_CONST3, 'f'),
VoidN(3, 4, NV097_SET_TLCONST_ZERO, 'f'),
VoidN(3, 4, NV097_SET_EYE_DIRECTION, 'f'),
VoidN(3, 4, NV097_SET_LINEAR_FOG_CONST, 'f'),
Zero(NV097_INVALIDATE_VERTEX_CACHE_FILE),
Zero(NV097_INVALIDATE_VERTEX_FILE),
Zero(NV097_TL_NOP),
Zero(NV097_TL_SYNC),
FieldN(16, 4, NV097_SET_VERTEX_DATA_ARRAY_OFFSET, "CONTEXT_DMA", 31, 31, 'b'),
FieldN(16, 4, NV097_SET_VERTEX_DATA_ARRAY_OFFSET, "OFFSET", 30, 0, 'b'),
FieldN(16, 4, NV097_SET_VERTEX_DATA_ARRAY_FORMAT, "STRIDE", 31, 8, 'b'),
FieldN(16, 4, NV097_SET_VERTEX_DATA_ARRAY_FORMAT, "SIZE", 7, 4, 'b'),
FieldN(16, 4, NV097_SET_VERTEX_DATA_ARRAY_FORMAT, "TYPE", 3, 0, 'b'),
Void(NV097_SET_LOGIC_OP_ENABLE, 'b'),
Void(NV097_SET_LOGIC_OP, 'b'),
Field(NV097_SET_BEGIN_END, "OP", 31, 0, 'b'),
Field(NV097_ARRAY_ELEMENT16, "VERTEX0", 15, 0, 'b'),
Field(NV097_ARRAY_ELEMENT16, "VERTEX1", 31, 16, 'b'),
Void(NV097_ARRAY_ELEMENT32, 'b'),
Field(NV097_DRAW_ARRAYS, "COUNT", 31, 24, 'b'),
Field(NV097_DRAW_ARRAYS, "START_INDEX", 23, 0, 'b'),
Void(NV097_INLINE_VERTEX_REUSE, 'b'),
Void(NV097_INLINE_ARRAY, 'b'),
VoidN(4, 64, NV097_SET_TEXTURE_OFFSET, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "CONTEXT_DMA", 1, 0, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "CUBEMAP_ENABLE", 2, 2, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "BORDER_SOURCE", 3, 3, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "DIMENSIONALITY", 7, 4, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "COLOR", 15, 8, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "MIPMAP_LEVELS", 19, 16, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "BASE_SIZE_U", 23, 20, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "BASE_SIZE_V", 27, 24, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FORMAT, "BASE_SIZE_P", 31, 28, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_ADDRESS, "U", 3, 0, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_ADDRESS, "CYLWRAP_U", 7, 4, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_ADDRESS, "V", 11, 8, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_ADDRESS, "CYLWRAP_V", 15, 12, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_ADDRESS, "P", 19, 16, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_ADDRESS, "CYLWRAP_P", 23, 20, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_ADDRESS, "CYLWRAP_Q", 31, 24, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_CONTROL0, "ENABLE", 31, 30, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_CONTROL0, "MIN_LOD_CLAMP", 29, 18, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_CONTROL0, "MAX_LOD_CLAMP", 17, 6, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_CONTROL0, "LOG_MAX_ANISO", 5, 4, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_CONTROL0, "IMAGE_FIELD_ENABLE", 2, 2, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_CONTROL0, "COLOR_KEY_OPERATION", 1, 0, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_CONTROL1, "IMAGE_PITCH", 31, 16, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FILTER, "MIPMAP_LOD_BIAS", 12, 0, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FILTER, "CONVOLUTION_KERNEL", 15, 13, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FILTER, "MIN", 23, 16, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FILTER, "MAG", 27, 24, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FILTER, "ASIGNED", 28, 28, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FILTER, "RSIGNED", 29, 29, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FILTER, "GSIGNED", 30, 30, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_FILTER, "BSIGNED", 31, 31, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_IMAGE_RECT, "RECT_WIDTH", 31, 16, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_IMAGE_RECT, "RECT_HEIGHT", 15, 0, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_PALETTE, "CONTEXT_DMA", 1, 0, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_PALETTE, "LENGTH", 5, 2, 'b'),
FieldN(4, 64, NV097_SET_TEXTURE_PALETTE, "OFFSET", 31, 6, 'b'),
VoidN(4, 64, NV097_SET_TEXTURE_BORDER_COLOR, 'b'),
VoidN(4, 64, NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00, 'f'),
VoidN(4, 64, NV097_SET_TEXTURE_SET_BUMP_ENV_MAT01, 'f'),
VoidN(4, 64, NV097_SET_TEXTURE_SET_BUMP_ENV_MAT11, 'f'),
VoidN(4, 64, NV097_SET_TEXTURE_SET_BUMP_ENV_MAT10, 'f'),
VoidN(4, 64, NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE, 'f'),
VoidN(4, 64, NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET, 'f'),
Zero(NV097_PARK_ATTRIBUTE),
Zero(NV097_UNPARK_ATTRIBUTE),
Void(NV097_SET_SEMAPHORE_OFFSET, 'b'),
Void(NV097_BACK_END_WRITE_SEMAPHORE_RELEASE, 'b'),
Void(NV097_TEXTURE_READ_SEMAPHORE_RELEASE, 'b'),
Field(NV097_SET_ZMIN_MAX_CONTROL, "CULL_NEAR_FAR_EN", 3, 0, 'b'),
Field(NV097_SET_ZMIN_MAX_CONTROL, "ZCLAMP_EN", 7, 4, 'b'),
Field(NV097_SET_ZMIN_MAX_CONTROL, "CULL_IGNORE_W", 11, 8, 'b'),
Field(NV097_SET_ANTI_ALIASING_CONTROL, "ENABLE", 3, 0, 'b'),
Field(NV097_SET_ANTI_ALIASING_CONTROL, "ALPHA_TO_COVERAGE", 7, 4, 'b'),
Field(NV097_SET_ANTI_ALIASING_CONTROL, "ALPHA_TO_ONE", 11, 8, 'b'),
Field(NV097_SET_ANTI_ALIASING_CONTROL, "SAMPLE_MASK", 31, 16, 'b'),
Void(NV097_SET_COMPRESS_ZBUFFER_EN, 'b'),
Field(NV097_SET_OCCLUDE_ZSTENCIL_EN, "OCCLUDE_ZEN", 0, 0, 'b'),
Field(NV097_SET_OCCLUDE_ZSTENCIL_EN, "OCCLUDE_STENCIL_EN", 1, 1, 'b'),
Field(NV097_SET_SURFACE_FORMAT, "COLOR", 3, 0, 'b'),
Field(NV097_SET_SURFACE_FORMAT, "ZETA", 7, 4, 'b'),
Field(NV097_SET_SURFACE_FORMAT, "TYPE", 11, 8, 'b'),
Field(NV097_SET_SURFACE_FORMAT, "ANTI_ALIASING", 15, 12, 'b'),
Field(NV097_SET_SURFACE_FORMAT, "WIDTH", 23, 16, 'b'),
Field(NV097_SET_SURFACE_FORMAT, "HEIGHT", 31, 24, 'b'),
Void(NV097_SET_ZSTENCIL_CLEAR_VALUE, 'b'),
Void(NV097_SET_COLOR_CLEAR_VALUE, 'b'),
Field(NV097_CLEAR_SURFACE, "Z", 0, 0, 'b'),
Field(NV097_CLEAR_SURFACE, "STENCIL", 1, 1, 'b'),                   
Field(NV097_CLEAR_SURFACE, "R", 4, 4, 'b'),
Field(NV097_CLEAR_SURFACE, "G", 5, 5, 'b'),
Field(NV097_CLEAR_SURFACE, "B", 6, 6, 'b'),
Field(NV097_CLEAR_SURFACE, "A", 7, 7, 'b'),
Field(NV097_SET_CLEAR_RECT_HORIZONTAL, "XMIN", 15, 0, 'b'),
Field(NV097_SET_CLEAR_RECT_HORIZONTAL, "XMAX", 31, 16, 'b'),
Field(NV097_SET_CLEAR_RECT_VERTICAL, "YMIN", 15, 0, 'b'),
Field(NV097_SET_CLEAR_RECT_VERTICAL, "YMAX", 31, 16, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "POSITION_DEGREE", 3, 0, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM1_DEGREE", 7, 4, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM2_DEGREE", 11, 8, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM3_DEGREE", 15, 12, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM4_DEGREE", 19, 16, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM5_DEGREE", 23, 20, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM6_DEGREE", 27, 24, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM7_DEGREE", 31, 28, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM8_DEGREE", 3, 0, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM9_DEGREE", 7, 4, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM10_DEGREE", 11, 8, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM11_DEGREE", 15, 12, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM12_DEGREE", 19, 16, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM13_DEGREE", 23, 20, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM14_DEGREE", 27, 24, 'b'),
Field(NV097_SET_BEGIN_PATCH0, "PARAM15_DEGREE", 31, 28, 'b'),
Field(NV097_SET_BEGIN_PATCH2, "SWATCH_ROWS", 7, 0, 'b'),
Field(NV097_SET_BEGIN_PATCH2, "SWATCH_COLS", 15, 8, 'b'),
Field(NV097_SET_BEGIN_PATCH2, "SWATCH_SIZE", 20, 16, 'b'),
Field(NV097_SET_BEGIN_PATCH2, "PARTIAL_SWATCH_WIDTH", 25, 21, 'b'),
Field(NV097_SET_BEGIN_PATCH2, "PARTIAL_SWATCH_HEIGHT", 30, 26, 'b'),
Field(NV097_SET_BEGIN_PATCH2, "PATCH_TYPE", 30, 26, 'b'),
Field(NV097_SET_BEGIN_PATCH2, "PATCH_TYPE_SQUARE", 31, 31, 'b'),
Field(NV097_SET_BEGIN_PATCH3, "ROW_TRNS", 2, 0, 'b'),
Field(NV097_SET_BEGIN_PATCH3, "COL_TRNS", 5, 3, 'b'),
Field(NV097_SET_BEGIN_PATCH3, "POSITION_GUARD_CURVE_DEGREE", 9, 6, 'b'),
Field(NV097_SET_BEGIN_PATCH3, "NORMAL_GUARD_CURVE_DEGREE", 13, 10, 'b'),
Field(NV097_SET_BEGIN_PATCH3, "PRIMITIVE", 15, 14, 'b'),
Field(NV097_SET_BEGIN_PATCH3, "TESSELATION", 16, 16, 'b'),
Field(NV097_SET_BEGIN_PATCH3, "NUM_COEFFS", 31, 24, 'b'),
Zero(NV097_SET_END_PATCH),
Field(NV097_SET_BEGIN_END_SWATCH, "SWATCH_CMD", 3, 0, 'b'),
Field(NV097_SET_BEGIN_END_SWATCH, "NEW_SWATH", 7, 4, 'b'),
Field(NV097_SET_BEGIN_END_SWATCH, "SKIP_FIRST_ROW", 11, 8, 'b'),
Field(NV097_SET_BEGIN_END_SWATCH, "SKIP_FIRST_COL", 15, 12, 'b'),
Field(NV097_SET_BEGIN_END_SWATCH, "SHORT_SWATCH", 19, 16, 'b'),
Field(NV097_SET_BEGIN_END_SWATCH, "NARROW_SWATCH", 31, 20, 'b'),
Field(NV097_SET_BEGIN_END_CURVE, "CMD", 3, 0, 'b'),
VoidN(4, 4, NV097_SET_CURVE_COEFFICIENTS, 'f'),
Field(NV097_SET_BEGIN_TRANSITION0, "POSITION_DEGREE", 3, 0, 'b'),
Field(NV097_SET_BEGIN_TRANSITION0, "PARAM1_DEGREE", 7, 4, 'b'),
Field(NV097_SET_BEGIN_TRANSITION0, "PARAM2_DEGREE", 11, 8, 'b'),
Field(NV097_SET_BEGIN_TRANSITION0, "PARAM3_DEGREE", 15, 12, 'b'),
Field(NV097_SET_BEGIN_TRANSITION0, "PARAM4_DEGREE", 19, 16, 'b'),
Field(NV097_SET_BEGIN_TRANSITION0, "PARAM5_DEGREE", 23, 20, 'b'),
Field(NV097_SET_BEGIN_TRANSITION0, "PARAM6_DEGREE", 27, 24, 'b'),
Field(NV097_SET_BEGIN_TRANSITION0, "PARAM7_DEGREE", 31, 28, 'b'),
Field(NV097_SET_BEGIN_TRANSITION1, "PARAM8_DEGREE", 3, 0, 'b'),
Field(NV097_SET_BEGIN_TRANSITION1, "PARAM9_DEGREE", 7, 4, 'b'),
Field(NV097_SET_BEGIN_TRANSITION1, "PARAM10_DEGREE", 11, 8, 'b'),
Field(NV097_SET_BEGIN_TRANSITION1, "PARAM11_DEGREE", 15, 12, 'b'),
Field(NV097_SET_BEGIN_TRANSITION1, "PARAM12_DEGREE", 19, 16, 'b'),
Field(NV097_SET_BEGIN_TRANSITION1, "PARAM13_DEGREE", 23, 20, 'b'),
Field(NV097_SET_BEGIN_TRANSITION1, "PARAM14_DEGREE", 27, 24, 'b'),
Field(NV097_SET_BEGIN_TRANSITION1, "PARAM15_DEGREE", 31, 28, 'b'),
Field(NV097_SET_BEGIN_TRANSITION2, "INSIDE_SEGMENTS", 9, 0, 'b'),
Field(NV097_SET_BEGIN_TRANSITION2, "OUTSIDE_SEGMENTS", 19, 10, 'b'),
Field(NV097_SET_BEGIN_TRANSITION2, "NUM_COEFFS", 31, 24, 'b'),
Zero(NV097_SET_END_TRANSITION),
Void(NV097_SET_SHADOW_ZSLOPE_THRESHOLD, 'f'),
Void(NV097_SET_SHADOW_DEPTH_FUNC, 'b'),
Field(NV097_SET_SHADER_STAGE_PROGRAM, "STAGE0", 4, 0, 'b'),
Field(NV097_SET_SHADER_STAGE_PROGRAM, "STAGE1", 9, 5, 'b'),
Field(NV097_SET_SHADER_STAGE_PROGRAM, "STAGE2", 14, 10, 'b'),
Field(NV097_SET_SHADER_STAGE_PROGRAM, "STAGE3", 19, 15, 'b'),
VoidN(3, 4, NV097_SET_EYE_VECTOR, 'f'),
Field(NV097_SET_DOT_RGBMAPPING, "STAGE1", 3, 0, 'b'),
Field(NV097_SET_DOT_RGBMAPPING, "STAGE2", 7, 4, 'b'),
Field(NV097_SET_DOT_RGBMAPPING, "STAGE3", 11, 8, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE0_S", 0, 0, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE0_T", 1, 1, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE0_R", 2, 2, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE0_Q", 3, 3, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE1_S", 4, 4, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE1_T", 5, 5, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE1_R", 6, 6, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE1_Q", 7, 7, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE2_S", 8, 8, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE2_T", 9, 9, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE2_R", 10, 10, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE2_Q", 11, 11, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE3_S", 12, 12, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE3_T", 13, 13, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE3_R", 14, 14, 'b'),
Field(NV097_SET_SHADER_CLIP_PLANE_MODE, "STAGE3_Q", 15, 15, 'b'),
Field(NV097_SET_SHADER_OTHER_STAGE_INPUT, "STAGE1", 15, 0, 'b'),
Field(NV097_SET_SHADER_OTHER_STAGE_INPUT, "STAGE2", 19, 16, 'b'),
Field(NV097_SET_SHADER_OTHER_STAGE_INPUT, "STAGE3", 23, 20, 'b'),
FieldN(2, 4, NV097_SET_SPECULAR_FOG_FACTOR, "BLUE", 7, 0, 'b'),
FieldN(2, 4, NV097_SET_SPECULAR_FOG_FACTOR, "GREEN", 15, 8, 'b'),
FieldN(2, 4, NV097_SET_SPECULAR_FOG_FACTOR, "RED", 23, 16, 'b'),
FieldN(2, 4, NV097_SET_SPECULAR_FOG_FACTOR, "ALPHA", 31, 24, 'b'),
Field(NV097_SET_COMBINER_CONTROL, "ITERATION_COUNT", 7, 0, 'b'),
Field(NV097_SET_COMBINER_CONTROL, "MUX_SELECT", 11, 8, 'b'),
Field(NV097_SET_COMBINER_CONTROL, "FACTOR0", 15, 12, 'b'),
Field(NV097_SET_COMBINER_CONTROL, "FACTOR1", 31, 16, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "BLUETOALPHA_AB", 31, 19, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "BLUETOALPHA_CD", 18, 18, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "OP", 17, 15, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "MUX_ENABLE", 14, 14, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "AB_DOT_ENABLE", 13, 13, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "CD_DOT_ENABLE", 12, 12, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "SUM_DST", 11, 8, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "AB_DST", 7, 4, 'b'),
FieldN(8, 4, NV097_SET_COMBINER_COLOR_OCW, "CD_DST", 3, 0, 'b'),
Field(NV097_SET_TRANSFORM_EXECUTION_MODE, "MODE", 1, 0, 'b'),
Field(NV097_SET_TRANSFORM_EXECUTION_MODE, "RANGE_MODE", 31, 2, 'b'),
Void(NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, 'b'),
Field(NV097_SET_TRANSFORM_PROGRAM_LOAD, "PROG_LD_PTR", 31, 0, 'b'),
Void(NV097_SET_TRANSFORM_PROGRAM_START, 'b'),
VoidN(32, 4, NV097_SET_TRANSFORM_PROGRAM, 'B'),
Field(NV097_SET_TRANSFORM_CONSTANT_LOAD, "CONST_LD_PTR", 31, 0, 'b'),
VoidN(32, 4, NV097_SET_TRANSFORM_CONSTANT, 'F'),
VoidN(4, 4, NV097_SET_TRANSFORM_DATA, 'f'),
Void(NV097_LAUNCH_TRANSFORM_PROGRAM, 'b'),
Void(NV097_SET_TWO_SIDE_LIGHT_EN, 'b'),
VoidN(3, 4, NV097_SET_BACK_SCENE_AMBIENT_COLOR, 'f'),
VoidN(3, 4, NV097_SET_BACK_MATERIAL_EMISSION, 'f'),
Field(NV097_CLEAR_REPORT_VALUE, "TYPE_ZPASS_PIXEL_CNT", 31, 0, 'b'),
Void(NV097_SET_ZPASS_PIXEL_COUNT_ENABLE, 'b'),
Field(NV097_GET_REPORT, "OFFSET", 23, 0, 'b'),
Field(NV097_GET_REPORT, "TYPE", 31, 24, 'b'),
{ 0 } // Table terminator
};

#endif // DBG

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\drawprim.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawprim.cpp
 *  Content:    Handles the invocation of rendering commands.
 *
 ***************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

// DOC: Behavior when an index is out-of-bounds

// 'DRAW_COUNT_BATCH' is the maximum number of vertices we spew on every
// call to DRAW_ARRAYS.  256 is the maximum allowable hardware limit.

#define DRAW_COUNT_BATCH 256

// 'ARRAY_ELEMENT16_BATCH' is the maximum number of *pairs* of indices we 
// spew in consecutive writes to ARRAY_ELEMENT16.  2047 is the maximum
// allowable hardware limit.

#define ARRAY_ELEMENT16_BATCH 511

// MMXMemCpyDwordBlock writes 60 bytes followed by X number of 64 byte blocks.
// This allows us to write the ELEMENT16 hdr then call MMXMemCpyDwordBlock
// and keep the dest 32 byte aligned. This define tells us the minimum number
// of indices MMXMemCpyDwordBlock can handle.

// 60 + 64 bytes, 15 + 16 dwords, or 30 + 32 indices
#define ARRAY_ELEMENT16_BLOCK_VERTICES_MIN  (30 + 32)

// 'ARRAY_ELEMENT16_SLOP' is the number of *pairs* of indices that we
// ensure are in last loop iteration.                              
                              
#define ARRAY_ELEMENT16_SLOP 2

#if DBG

    // Global for tracking the Begin/End state:
    
    INT g_CurrentPrimitiveType;

#endif

//------------------------------------------------------------------------------
// FastCopyToWC
//
// Helper function for copying from cacheable memory to write-combined memory.
// Much better than 'rep movsd' when the size is large and the source isn't
// already in the cache.

VOID FastCopyToWC(
    PPUSH pPush,    
    DWORD* pSource, 
    DWORD dwCount)  
{
    __asm
    {
        mov esi,pSource
        mov edi,pPush
        mov edx,dwCount

        mov ecx,edi
        neg ecx
        and ecx,0x1f
        shr ecx,2       // (-dest & 0x1f) / 4

        cmp edx,ecx     // Enough to align?
        jg do_align

        mov ecx,edx     // Not enough, use simple copy
        jmp finish

    do_align:
        // 32 byte align dest.
        sub edx,ecx

        rep movsd

        mov ecx,edx
        jmp enter_loop

        ALIGN 16

    copy_loop:
        prefetchnta [esi+64]
        prefetchnta [esi+96]

        // Move 16 dwords
        movq mm0,[esi]
        movq mm1,[esi+8]
        movq mm2,[esi+16]
        movq mm3,[esi+24]
        movq mm4,[esi+32]
        movq mm5,[esi+40]
        movq mm6,[esi+48]
        movq mm7,[esi+56]

        movntq [edi],mm0
        movntq [edi+8],mm1
        movntq [edi+16],mm2
        movntq [edi+24],mm3
        movntq [edi+32],mm4
        movntq [edi+40],mm5
        movntq [edi+48],mm6
        movntq [edi+56],mm7

        nop
        nop

        add esi,64
        add edi,64

    enter_loop:
        sub ecx,16
        jge copy_loop

        add ecx,16

    finish:
        // Finish any left over.
        rep movsd

        emms
    }
}

//------------------------------------------------------------------------------
// D3DDevice_DrawVerticesUP
//
// User-pointer version of DrawPrimitive.  This uses the CPU to copy vertex 
// data from the specified buffer directly into the push buffer.
//
// This is by no means optimal.  It is, however, small, and handles all
// permutations of vertex component types for vertex shader programs.
// On Xbox, there's no real reason to be using UP primitives given that
// we're UMA and have most excellent VB support, so this is a reasonable
// tradeoff.
//
// Note that this 'DrawVertices' version takes a vertex count, rather than 
// a primitive count as with the 'DrawPrimitive' version.  This makes it
// easier for the caller, and eliminates two lookups to calculate the vertex 
// count.  DrawPrimitive is converted in-line in the caller to DrawVertices.
//
// Analagous to nvKelvinDispatchNonIndexedPrimitiveInline
//
// DOC: Unlike DX8, we do not set the stream zero settings to NULL
//
// DOC: Every vertex attribute has to be DWORD aligned

extern "C"
void WINAPI D3DDevice_DrawVerticesUP(
    D3DPRIMITIVETYPE PrimitiveType,
    UINT VertexCount,
    CONST void* pVertexStreamZeroData,
    UINT VertexStreamZeroStride) 
{ 
    DWORD i;

    COUNT_API(API_D3DDEVICE_DRAWVERTICESUP);
    COUNT_ADD_PERF(PERF_VERTICES, VertexCount);
    COUNT_PERFEVENT(D3DPERFEvent_DrawVerticesUP, TRUE);

    CDevice* pDevice = g_pDevice;

    // Whack the hardware into the correct state, *before* doing our
    // parameter checks:

    pDevice->SetStateUP();

    // Now do some parameter checking.  We do this after calling SetStateUP
    // because we examine the current state in one of our checks.

    if (DBG_CHECK(TRUE))
    {
        if ((D3D__RenderState[D3DRS_POINTSPRITEENABLE]) &&
            (PrimitiveType != D3DPT_POINTLIST))
        {
            DPF_ERR("Can only do D3DPT_POINTLIST when point sprites enabled");
        }
        if ((D3D__RenderState[D3DRS_ZENABLE] == D3DZB_USEW)
            && pDevice->m_pZBuffer
            && PixelJar::GetFormat(pDevice->m_pZBuffer) == D3DFMT_LIN_F24S8)
        {
            DPF_ERR("W buffering is not supported with a 24-bit floating point depth buffer");
        }
        if (VertexCount == 0)
        {
            DPF_ERR("Zero VertexCount");
        }
        if ((PrimitiveType <= 0) || (PrimitiveType >= D3DPT_MAX))
        {
            DPF_ERR("Invalid primitive type");
        }
        if (VertexStreamZeroStride == 0)
        {
            DPF_ERR("Invalid stride");
        }
        if (pVertexStreamZeroData == NULL)
        {
            DPF_ERR("NULL pointer");
        }

        // Since we do DWORD copies, enforcing DWORD alignment of every
        // attribute guarantees us that we'll never do an unaligned read 
        // of even a single byte past the end of an attribute that is less
        // than a DWORD in length - because inevitably that extra byte read
        // will be one byte past the end of the buffer on a page that isn't
        // there.  Those are nasty, nasty crashes.

        if ((((DWORD) pVertexStreamZeroData) & 3) || (VertexStreamZeroStride & 3))
        {
            DPF_ERR("DWORD alignment is required for the UP stream data");
        }
        for (i = 0; i < pDevice->m_InlineAttributeCount; i++)
        {
            if (pDevice->m_InlineAttributeData[i].UP_Delta & 3)
            {
                DPF_ERR("DWORD alignment is required for every UP attribute");
            }
        }
        if(pDevice->m_dwSnapshot)
        {
            HandleShaderSnapshot_DrawVerticesUP(PrimitiveType,
                                                VertexCount,
                                                pVertexStreamZeroData,
                                                VertexStreamZeroStride);
            return;
        }
    }

    PPUSH pPush = pDevice->StartPush();
    Push1(pPush, NV097_SET_BEGIN_END, PrimitiveType);
    pDevice->EndPush(pPush + 2);
    pDevice->StartBracket();
    
    InlineAttributeData* pAttributeData = &pDevice->m_InlineAttributeData[0];

    DWORD* pVertexStart = (DWORD*) ((BYTE*) pVertexStreamZeroData 
                                   + pDevice->m_InlineStartOffset);

    DWORD attributeCount = pDevice->m_InlineAttributeCount;

    // Adjust the last delta used in our inner loop so that it automatically
    // takes us from the end of the last attribute of the just-completed vertex
    // to the start of the first attribute of the next vertex:

    DWORD delta = (VertexStreamZeroStride + pDevice->m_InlineDelta);

    pAttributeData[attributeCount - 1].UP_Delta = delta;

    // We can send a maximum of 2047 dwords in a single push-buffer command.  
    // But our loop works by vertex, not by dword.  So figure out the number 
    // of vertices we can send in a single command:

    DWORD batchLimit = (VertexCount <= 16) 
                     ? 16 
                     : (MAX_PUSH_METHOD_SIZE / pDevice->m_InlineVertexDwords);

    while (TRUE)
    {
        // Number of vertices to do in this batch:

        DWORD batchCount = min(batchLimit, VertexCount);

        // Get count ready for next batch:

        VertexCount -= batchCount;

        // Count of DWORDs to do in this batch:

        DWORD count = batchCount * pDevice->m_InlineVertexDwords;

        // Reserve an extra DWORD for the INLINE_ARRAY command, and
        // an additional two DWORDs for the SET_BEGIN_END command:

        PPUSH pPush = pDevice->StartPush(count + 3);

        ASSERT((count) && (count < 2048));

        PushCount(pPush++, PUSHER_NOINC(NV097_INLINE_ARRAY), count);

        if ((count >= 128) && (attributeCount == 1) && (delta == 0))
        {
            // The data is nicely packed so that we can do one big memcpy.
            // The batch is also large enough that we're willing to pay
            // the fast-copy overhead:

            FastCopyToWC(pPush, pVertexStart, count);

            pVertexStart += count;
            pPush += count;
        }
        else
        {
            // D'oh, we have to copy attribute-by-attribute:

            _asm {
            
                mov edx, batchCount;
                mov esi, pVertexStart;
                mov edi, pPush;
            
            Vertex_Loop:
            
                mov ebx, pAttributeData;
                mov eax, attributeCount;
            
            Attribute_Loop:
            
                mov ecx, [ebx].UP_Count;
                rep movsd;
                add esi, [ebx].UP_Delta;
                add ebx, size InlineAttributeData;
                dec eax;
                jnz Attribute_Loop;
        
                dec edx;
                jnz Vertex_Loop;
        
                mov pPush, edi;
                mov pVertexStart, esi;
            }
        }

        // Are we done?

        if (VertexCount == 0)
        {
            Push1(pPush, NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);
            pDevice->EndPush(pPush + 2);
            pDevice->EndBracket();

            return;
        }

        pDevice->EndPush(pPush);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_DrawIndexedVerticesUP
//
// This is by no means optimal.  It is, however, small, and handles all
// permutations of vertex component types for vertex shader programs.
// On Xbox, there's no real reason to be using UP primitives given that
// we're UMA and have most excellent VB support, so this is a reasonable
// tradeoff.
//
// DOC: Unlike as is speced for DX8, we do not set the stream zero settings 
//      to NULL, nor do we make SetIndices also set to NULL
//
// Note that this 'DrawVertices' version takes a vertex count, rather than 
// a primitive count as with the 'DrawPrimitive' version.  This makes it
// easier for the caller, and eliminates two lookups to calculate the vertex 
// count.  DrawPrimitive is converted in-line in the caller to DrawVertices.

extern "C"
void WINAPI D3DDevice_DrawIndexedVerticesUP(
    D3DPRIMITIVETYPE PrimitiveType,
    UINT VertexCount,
    CONST void* pIndexData,
    CONST void* pVertexStreamZeroData,
    UINT VertexStreamZeroStride) 
{ 
    DWORD i;

    COUNT_API(API_D3DDEVICE_DRAWINDEXEDVERTICESUP);
    COUNT_ADD_PERF(PERF_VERTICES, VertexCount);
    COUNT_PERFEVENT(D3DPERFEvent_DrawIndexedVerticesUP, TRUE);

    CDevice* pDevice = g_pDevice;

    // Whack the hardware into the correct state:

    pDevice->SetStateUP();

    // Now do some parameter checking.  We do this after calling SetStateUP
    // because we examine the current state in one of our checks.

    if (DBG_CHECK(TRUE))
    {
        if ((D3D__RenderState[D3DRS_POINTSPRITEENABLE]) &&
            (PrimitiveType != D3DPT_POINTLIST))
        {
            DPF_ERR("Can only do D3DPT_POINTLIST when point sprites enabled");
        }
        if ((D3D__RenderState[D3DRS_ZENABLE] == D3DZB_USEW)
            && pDevice->m_pZBuffer
            && PixelJar::GetFormat(pDevice->m_pZBuffer) == D3DFMT_LIN_F24S8)
        {
            DPF_ERR("W buffering is not supported with a 24-bit floating point depth buffer");
        }
        if (VertexCount == 0)
        {
            DPF_ERR("Zero VertexCount");
        }
        if ((PrimitiveType <= 0) || (PrimitiveType >= D3DPT_MAX))
        {
            DPF_ERR("Invalid primitive type");
        }
        if (VertexStreamZeroStride == 0)
        {
            DPF_ERR("Invalid stride");
        }
        if ((pIndexData == NULL) || (pVertexStreamZeroData == NULL))
        {
            DPF_ERR("NULL pointer");
        }

        // Since we do DWORD copies, enforcing DWORD alignment of every
        // attribute guarantees us that we'll never do an unaligned read 
        // of even a single byte past the end of an attribute that is less
        // than a DWORD in length - because inevitably that extra byte read
        // will be one byte past the end of the buffer on a page that isn't
        // there.  Those are nasty, nasty crashes.

        if ((((DWORD) pVertexStreamZeroData) & 3) || (VertexStreamZeroStride & 3))
        {
            DPF_ERR("DWORD alignment is required for the UP stream data");
        }
        for (i = 0; i < pDevice->m_InlineAttributeCount; i++)
        {
            if (pDevice->m_InlineAttributeData[i].UP_Delta & 3)
            {
                DPF_ERR("DWORD alignment is required for every UP attribute");
            }
        }
        if(pDevice->m_dwSnapshot)
        {
            HandleShaderSnapshot_DrawIndexedVerticesUP(PrimitiveType,
                                                       VertexCount,
                                                       pIndexData,
                                                       pVertexStreamZeroData,
                                                       VertexStreamZeroStride);
            return;
        }
    }

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_BEGIN_END, PrimitiveType);

    pDevice->EndPush(pPush + 2);
    pDevice->StartBracket();

    InlineAttributeData *pAttributeData = &pDevice->m_InlineAttributeData[0];

    DWORD* pVertexStart = (DWORD*) ((BYTE*) pVertexStreamZeroData 
                                   + pDevice->m_InlineStartOffset);

    DWORD attributeCount = pDevice->m_InlineAttributeCount;

    // We can send a maximum of 2047 dwords in a single push-buffer command.  
    // But our loop works by vertex, not by dword.  So figure out the number 
    // of vertices we can send in a single command:

    DWORD batchLimit = (VertexCount <= 16) 
                     ? 16 
                     : (MAX_PUSH_METHOD_SIZE / pDevice->m_InlineVertexDwords);

    while (TRUE)
    {
        // Number of vertices to do in this batch:

        DWORD batchCount = min(batchLimit, VertexCount);

        // Get count ready for next batch:

        VertexCount -= batchCount;

        // Count of DWORDs to do in this batch:

        DWORD count = batchCount * pDevice->m_InlineVertexDwords;

        // Reserve an extra DWORD for the INLINE_ARRAY command, and
        // an additional two DWORDs for the SET_BEGIN_END command:

        PPUSH pPush = pDevice->StartPush(count + 3);

        ASSERT((count) && (count < 2048));

        PushCount(pPush++, PUSHER_NOINC(NV097_INLINE_ARRAY), count);
    
        _asm {
        
            mov edx, pIndexData
            mov edi, pPush;
        
        Vertex_Loop:
    
            movzx esi, word ptr [edx];
            add edx, 2;
            mov eax, attributeCount;
            imul esi, VertexStreamZeroStride;
            mov ebx, pAttributeData;
            add esi, pVertexStart
        
        Attribute_Loop:
        
            mov ecx, [ebx].UP_Count;
            rep movsd;
            add esi, [ebx].UP_Delta;
            add ebx, size InlineAttributeData;
            dec eax;
            jnz Attribute_Loop;
    
            dec batchCount;
            jnz Vertex_Loop;
    
            mov pPush, edi;
            mov pIndexData, edx;
        }

        // Are we done?

        if (VertexCount == 0)
        {
            Push1(pPush, NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);
            pDevice->EndPush(pPush + 2);
            pDevice->EndBracket();

            return;
        }

        pDevice->EndPush(pPush);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_DrawVertices
//
// Note that this 'DrawVertices' version takes a vertex count, rather than 
// a primitive count as with the 'DrawPrimitive' version.  This makes it
// easier for the caller, and eliminates two lookups to calculate the vertex 
// count.  DrawPrimitive is converted in-line in the caller to DrawVertices.

extern "C"
void WINAPI D3DDevice_DrawVertices(
    D3DPRIMITIVETYPE PrimitiveType,
    UINT StartVertex,
    UINT VertexCount) 
{ 
    COUNT_API(API_D3DDEVICE_DRAWVERTICES);
    COUNT_ADD_PERF(PERF_VERTICES, VertexCount);
    COUNT_PERFEVENT(D3DPERFEvent_DrawVertices, TRUE);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if ((D3D__RenderState[D3DRS_POINTSPRITEENABLE]) &&
            (PrimitiveType != D3DPT_POINTLIST))
        {
            DPF_ERR("Can only do D3DPT_POINTLIST when point sprites enabled");
        }
        if ((D3D__RenderState[D3DRS_ZENABLE] == D3DZB_USEW)
            && pDevice->m_pZBuffer
            && PixelJar::GetFormat(pDevice->m_pZBuffer) == D3DFMT_LIN_F24S8)
        {
            DPF_ERR("W buffering is not supported with a 24-bit floating point depth buffer");
        }
        if (VertexCount == 0)
        {
            DPF_ERR("Zero VertexCount");
        }
        if ((PrimitiveType <= 0) || (PrimitiveType >= D3DPT_MAX))
        {
            DPF_ERR("Invalid primitive type");
        }
        if (StartVertex > 0xffff)
        {
            DPF_ERR("Hardware can't take a StartVertex more than 0xffff");
        }
        if (StartVertex + VertexCount > 0xffff)
        {
            DPF_ERR("Hardware can't take more than 0xffff vertices");
        }
        if(pDevice->m_dwSnapshot)
        {
            HandleShaderSnapshot_DrawVertices(PrimitiveType,
                                              StartVertex,
                                              VertexCount);
            return;
        }
    }

    // Whack the hardware into the correct state:

    pDevice->SetStateVB(0);

    // Loop through the vertex count.  We have to loop because the chip can
    // take a 'Count' value of only 8 bits in size.

    DWORD drawArraysCount = ((VertexCount - 1) / DRAW_COUNT_BATCH) + 1;

    PPUSH pPush = pDevice->StartPush(drawArraysCount + 5);

    Push1(pPush, NV097_SET_BEGIN_END, PrimitiveType);

    PushCount(pPush + 2, PUSHER_NOINC(NV097_DRAW_ARRAYS), drawArraysCount);

    while (VertexCount > DRAW_COUNT_BATCH)
    {
        *(pPush + 3) = DRF_NUMFAST(097, _DRAW_ARRAYS, _COUNT, DRAW_COUNT_BATCH - 1)
                     | DRF_NUMFAST(097, _DRAW_ARRAYS, _START_INDEX, StartVertex);

        pPush++;
        StartVertex += DRAW_COUNT_BATCH;
        VertexCount -= DRAW_COUNT_BATCH;
        ASSERT(drawArraysCount-- > 1);
    }
    
    ASSERT(drawArraysCount == 1);
    ASSERT(VertexCount >= 1);

    *(pPush + 3) = DRF_NUMFAST(097, _DRAW_ARRAYS, _COUNT, VertexCount - 1) 
                 | DRF_NUMFAST(097, _DRAW_ARRAYS, _START_INDEX, StartVertex);

    Push1(pPush + 4, NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);

    pDevice->EndPush(pPush + 6);
}

//------------------------------------------------------------------------------
// MMXMemCpyDwords
//
// Copy count DWORDS from pSrc to pDst
//   Up to caller to handle emms.

// Disable warning: "No EMMS at end of function"
#pragma warning(push)
#pragma warning(disable:4799)

__forceinline void MMXMemCpyDwordBlock(
    const void *pDst,
    const void *pSrc,
    DWORD count)
{
    // We can handle a minimum of 31 dwords.
    ASSERT(count >= 15 + 16);

    // This routine only handles block copies.
    ASSERT( !((count - 15) % 16) );

    __asm
    {
        mov esi,pSrc
        mov edi,pDst

        mov ecx,count
        sub ecx,15
        shr ecx,4

        prefetchnta [esi+60]
        prefetchnta [esi+92]

        // Move 30 indices, 15 dwords
        mov eax,[esi+0]
        movq mm1,[esi+4]
        movq mm2,[esi+12]
        movq mm3,[esi+20]
        movq mm4,[esi+28]
        movq mm5,[esi+36]
        movq mm6,[esi+44]
        movq mm7,[esi+52]

        // The nops here drop the BUS_COMPLETED_PARTIAL_WRITES PIII counter
        // down a bit. Basically it allows the movs above to complete and
        // not interrupt the writes as much. At least that's the idea.
        nop
        nop

        mov [edi+4],eax
        movntq [edi+8],mm1
        movntq [edi+16],mm2
        movntq [edi+24],mm3
        movntq [edi+32],mm4
        movntq [edi+40],mm5
        movntq [edi+48],mm6
        movntq [edi+56],mm7

        add esi,60
        add edi,64

        align 16

    copy_loop:
        prefetchnta [esi+64]
        prefetchnta [esi+96]

        // Move 32 indices, 16 dwords
        movq mm0,[esi]
        movq mm1,[esi+8]
        movq mm2,[esi+16]
        movq mm3,[esi+24]
        movq mm4,[esi+32]
        movq mm5,[esi+40]
        movq mm6,[esi+48]
        movq mm7,[esi+56]

        nop
        nop
    
        movntq [edi],mm0
        movntq [edi+8],mm1
        movntq [edi+16],mm2
        movntq [edi+24],mm3
        movntq [edi+32],mm4
        movntq [edi+40],mm5
        movntq [edi+48],mm6
        movntq [edi+56],mm7

        add esi,64
        add edi,64

        dec ecx
        jnz copy_loop
    }
}

#pragma warning(pop)

//------------------------------------------------------------------------------
// D3DDevice_DrawIndexedVertices
//
// Note that this 'DrawVertices' version takes a vertex count, rather than 
// a primitive count as with the 'DrawPrimitive' version.  This makes it
// easier for the caller, and eliminates two lookups to calculate the vertex 
// count.  DrawPrimitive is converted in-line in the caller to DrawVertices.

extern "C"
void WINAPI D3DDevice_DrawIndexedVertices(
    D3DPRIMITIVETYPE PrimitiveType,
    UINT VertexCount,
    CONST WORD* pIndexData)
{ 
    COUNT_API(API_D3DDEVICE_DRAWINDEXEDVERTICES);
    COUNT_ADD_PERF(PERF_VERTICES, VertexCount);
    COUNT_PERFEVENT(D3DPERFEvent_DrawIndexedVertices, TRUE);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if ((D3D__RenderState[D3DRS_POINTSPRITEENABLE]) &&
            (PrimitiveType != D3DPT_POINTLIST))
        {
            DPF_ERR("Can only do D3DPT_POINTLIST when point sprites enabled");
        }
        if ((D3D__RenderState[D3DRS_ZENABLE] == D3DZB_USEW)
            && pDevice->m_pZBuffer
            && PixelJar::GetFormat(pDevice->m_pZBuffer) == D3DFMT_LIN_F24S8)
        {
            DPF_ERR("W buffering is not supported with a 24-bit floating point depth buffer");
        }
        if ((VertexCount == 0) || (VertexCount > 32*1024*1024))
        {
            DPF_ERR("Invalid VertexCount");
        }
        if ((PrimitiveType <= 0) || (PrimitiveType >= D3DPT_MAX))
        {
            DPF_ERR("Invalid primitive type");
        }
        if (pIndexData == NULL)
        {
            DPF_ERR("Pointer to index data is NULL");
        }
        if(pDevice->m_dwSnapshot)
        {
            HandleShaderSnapshot_DrawIndexedVertices(PrimitiveType,
                                                     VertexCount,
                                                     pIndexData);
            return;
        }
    }

    // Whack the hardware into the correct state:
    pDevice->SetStateVB(pDevice->m_IndexBase);
    pDevice->StartBracket();

    // 2: set begin/end, 7: alignment, 1: array_element16, indices
    PPUSH pPush = pDevice->StartPush(2 + 7 + 1 + ARRAY_ELEMENT16_BATCH);

    Push1(pPush, NV097_SET_BEGIN_END, PrimitiveType);
    pPush += 2;

    // The mmx copy routines performs much better with a 32 byte aligned dest.
    // Calculate the number of DWORDS needed to align that bugger.
    DWORD dwAlign = (DWORD) (-((INT) pPush) & 0x1f) / 4;

    // The mmx routine can only handle blocks >= 62 vertices (31 dwords)
    if ((VertexCount >= ARRAY_ELEMENT16_BLOCK_VERTICES_MIN + 2*dwAlign))
    {
        // 32 byte align the pushbuffer.
        if (dwAlign)
        {
            // Should never need to write more than 7 dwords.
            ASSERT(dwAlign <= 7);

            // subtract the header.
            dwAlign--;

            PushCount(pPush, 
                      PUSHER_NOINC(NV097_ARRAY_ELEMENT16), 
                      dwAlign);

            //memcpy(pPush + 1, pIndexData, Align * sizeof(DWORD));
            __asm
            {
                mov esi,pIndexData
                mov edi,pPush
                add edi,4
                mov ecx,dwAlign
                rep movsd
            }

            pPush += dwAlign + 1;
            pIndexData += dwAlign * 2;
            VertexCount -= dwAlign * 2;

            ASSERT(!((DWORD)pPush & 0x1f));
            ASSERT((INT) VertexCount >= 0);
        }

        // Figure out how many large batches we can do.
        DWORD CountOfBatches = VertexCount / (ARRAY_ELEMENT16_BATCH * 2);

        // Calc the number of remaing vertices.
        DWORD RemainingVertices =
            VertexCount - CountOfBatches * ARRAY_ELEMENT16_BATCH * 2;

        // The first time through the loop we'll take care of the vertices
        // which aren't large enough for a full batch but can be handled
        // by the mmx block copy routine. 
        DWORD arrayCount =
            (RemainingVertices >= ARRAY_ELEMENT16_BLOCK_VERTICES_MIN) ?
                (((RemainingVertices >> 1) + 1) & ~0xf) - 1 :
                    ARRAY_ELEMENT16_BATCH;

        do
        {
            PushCount(pPush, 
                      PUSHER_NOINC(NV097_ARRAY_ELEMENT16), 
                      arrayCount);

            // Write 15 + 16*x number of dwords. This plus the hdr above
            // keeps the destination 32-byte aligned.
            MMXMemCpyDwordBlock((void*) pPush, pIndexData, arrayCount);

            pIndexData += arrayCount*2;
            VertexCount -= arrayCount*2;

            ASSERT((INT) VertexCount >= 0);

            pDevice->EndPush(pPush + 1 + arrayCount);
            pPush = pDevice->StartPush(1 + ARRAY_ELEMENT16_BATCH + 4);

            // Do big batches from here on out.
            arrayCount = ARRAY_ELEMENT16_BATCH;

        } while(VertexCount >= ARRAY_ELEMENT16_BATCH * 2);

        // For MMXMemCpyDwordBlock.
       __asm emms
    }

    // Note that it's okay if we send an Element16 command with zero entries
    // (for the case where the vertex count given to us is less than 3):
    DWORD arrayCount = VertexCount >> 1;

    PushCount(pPush, PUSHER_NOINC(NV097_ARRAY_ELEMENT16), arrayCount);
    //memcpy(pPush + 1, pIndexData, arrayCount * sizeof(DWORD));
    __asm
    {
        mov esi,pIndexData
        mov edi,pPush
        add edi,4
        mov ecx,arrayCount
        rep movsd
    }

    pIndexData += 2 * arrayCount;
    pPush += arrayCount + 1;

    // Handle the last odd index.  Since we only have one index left, we
    // obviously can't whack ELEMENT16, since that takes pairs of indices...

    if (VertexCount & 1)
    {
        // Note that we can't cast 'pIndexData' to a DWORD* and then AND with
        // 0xffff, as that could cause us to read a WORD past the end of
        // our allocation:

        Push1(pPush, NV097_ARRAY_ELEMENT32, (DWORD) *pIndexData);
        pPush += 2;
    }

    Push1(pPush, NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);
    pDevice->EndPush(pPush + 2);
    pDevice->EndBracket();
}

//------------------------------------------------------------------------------
// D3DDevice_PrimeVertexCache
//
// This API is new to Xbox, and one we may actually remove once we have
// pre-compiled index buffers working.  
//
// Its function is to prime the cache for efficiently rendering meshes.
// It does T&L on the specified verticies and loads them into the vertex
// 'file' (to use Nvidia's terminology), without rendering anything.

extern "C"
void WINAPI D3DDevice_PrimeVertexCache(
    UINT VertexCount,
    CONST WORD *pIndexData)
{ 
    COUNT_API(API_D3DDEVICE_PRIMEVERTEXCACHE);
    COUNT_ADD_PERF(PERF_VERTICES, VertexCount);

    CDevice* pDevice = g_pDevice;

    if (DBG_CHECK(TRUE))
    {
        if ((VertexCount == 0) || (VertexCount > 32))
        {
            DPF_ERR("Goofy VertexCount");
        }
    }

    // Whack the hardware into the correct state.  
    //
    // Note that technically we only have to do whatever would affect 
    // transform and lighting, but they'll probably do a DrawPrimitive 
    // right after this call, so any extra state set doesn't really matter.

    pDevice->SetStateVB(pDevice->m_IndexBase);

    CONST WORD* pIndex = pIndexData;
    DWORD array16Count = (VertexCount >> 1);

    PPUSH pPush = pDevice->StartPush();

    // Copy the indices.  Note that we don't actually have to special 
    // case a count of '1', since this will still work:

    PushCount(pPush, PUSHER_NOINC(NV097_ARRAY_ELEMENT16), array16Count);
    memcpy((void*) (pPush + 1), pIndex, array16Count * sizeof(DWORD));

    pPush += array16Count + 1;

    if (!(VertexCount & 1))
    {
        pDevice->EndPush(pPush);
    }
    else
    {
        // Take care of that one straggling vertex:

        Push1(pPush, NV097_ARRAY_ELEMENT32, (DWORD) *(pIndex + 2*array16Count));
        pDevice->EndPush(pPush + 2);
    }
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexData2f

extern "C"
void WINAPI D3DDevice_SetVertexData2f(
    INT Register,
    FLOAT a,
    FLOAT b)
{
    COUNT_API(API_D3DDEVICE_SETVERTEXDATA2F);

    if (DBG_CHECK((Register < 0) || (Register > 15)))
    {
        DPF_ERR("Invalid register");
    }

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push2f(pPush, NV097_SET_VERTEX_DATA2F_M(Register, 0), a, b);

    pDevice->EndPush(pPush + 3);
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexData4f

extern "C"
void WINAPI D3DDevice_SetVertexData4f(
    INT Register,
    FLOAT a,
    FLOAT b,
    FLOAT c,
    FLOAT d)
{
    COUNT_API(API_D3DDEVICE_SETVERTEXDATA4F);

    // Note: D3DVSDE_VERTEX is only valid for SetVertexData4f

    COUNT_ADD_PERF(PERF_VERTICES, ((Register==D3DVSDE_VERTEX) ? 1 : 0));

    if (DBG_CHECK(TRUE))
    {
        if ((Register < -1) || (Register > 15))
        {
            DPF_ERR("Invalid register");
        }
        if ((Register == D3DVSDE_VERTEX) &&
            !(g_pDevice->m_StateFlags & STATE_BEGINENDBRACKET))
        {
            DPF_ERR("D3DVSDE_VERTEX specified outside a Begin/End bracket");
        }
    }

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push4f(pPush, 
           (Register == D3DVSDE_VERTEX) 
                ? NV097_SET_VERTEX4F(0)
                : NV097_SET_VERTEX_DATA4F_M(Register, 0), 
           a, b, c, d);

    pDevice->EndPush(pPush + 5);
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexData2s

extern "C"
void WINAPI D3DDevice_SetVertexData2s(
    INT Register,
    SHORT a,
    SHORT b)
{
    COUNT_API(API_D3DDEVICE_SETVERTEXDATA2S);

    if (DBG_CHECK((Register < 0) || (Register > 15)))
    {
        DPF_ERR("Invalid register");
    }

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, 
          NV097_SET_VERTEX_DATA2S(Register), 
          (USHORT) a | ((DWORD) b << 16));

    pDevice->EndPush(pPush + 2);
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexData4s

extern "C"
void WINAPI D3DDevice_SetVertexData4s(
    INT Register,
    SHORT a,
    SHORT b,
    SHORT c,
    SHORT d)
{
    COUNT_API(API_D3DDEVICE_SETVERTEXDATA4S);

    if (DBG_CHECK((Register < 0) || (Register > 15)))
    {
        DPF_ERR("Invalid register");
    }

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push2(pPush, 
          NV097_SET_VERTEX_DATA4S_M(Register, 0), 
          (USHORT) a | ((DWORD) b << 16),
          (USHORT) c | ((DWORD) d << 16));

    pDevice->EndPush(pPush + 3);
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexData4ub

extern "C"
void WINAPI D3DDevice_SetVertexData4ub(
    INT Register,
    BYTE a,
    BYTE b,
    BYTE c,
    BYTE d)
{
    COUNT_API(API_D3DDEVICE_SETVERTEXDATA4UB);

    if (DBG_CHECK((Register < 0) || (Register > 15)))
    {
        DPF_ERR("Invalid register");
    }

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, 
          NV097_SET_VERTEX_DATA4UB(Register), 
          a | ((DWORD) b << 8) | ((DWORD) c << 16) | ((DWORD) d << 24));

    pDevice->EndPush(pPush + 2);
}

//------------------------------------------------------------------------------
// D3DDevice_SetVertexDataColor

extern "C"
void WINAPI D3DDevice_SetVertexDataColor(
    INT Register,
    D3DCOLOR Color)
{
    COUNT_API(API_D3DDEVICE_SETVERTEXDATACOLOR);

    if (DBG_CHECK((Register < 0) || (Register > 15)))
    {
        DPF_ERR("Invalid register");
    }

    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_VERTEX_DATA4UB(Register), SwapRgb(Color));

    pDevice->EndPush(pPush + 2);
}

#if PROFILE

D3DPERFEvent *g_pD3DPerfEventBeginEnd = NULL;

#endif // PROFILE

extern "C"
void WINAPI D3DDevice_Begin(
    D3DPRIMITIVETYPE PrimitiveType)
{
    COUNT_API(API_D3DDEVICE_BEGIN);

    if (DBG_CHECK((PrimitiveType > D3DPT_POLYGON) || (PrimitiveType <= 0)))
    {
        DPF_ERR("Invalid primitive type");
    }

#if DBG
    if (g_CurrentPrimitiveType != 0)
    {
        DPF_ERR("D3DDevice_Begin - Begin before a previous Begin has been Ended.");
    }

    g_CurrentPrimitiveType = PrimitiveType;
#endif

    CDevice* pDevice = g_pDevice;
    PPUSH pPush;

#if PROFILE
    ASSERT(g_pD3DPerfEventBeginEnd == NULL);
    g_pD3DPerfEventBeginEnd = D3DPERF_PerfEventStart(D3DPERFEvent_BeginEnd, TRUE);
#endif

    SetState();
    pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_BEGIN_END, PrimitiveType);

    pDevice->EndPush(pPush + 2);
    pDevice->StartBracket();
}

//------------------------------------------------------------------------------
// D3DDevice_End

extern "C"
void WINAPI D3DDevice_End()
{
    COUNT_API(API_D3DDEVICE_END);

    CDevice* pDevice = g_pDevice;
    PPUSH pPush;

#if DBG 
    if (g_CurrentPrimitiveType == 0)
    { 
        DXGRIP("D3DDevice_End - End without a matching begin.");
    }

    g_CurrentPrimitiveType = 0;
#endif 
    
    pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);

    pDevice->EndPush(pPush + 2);
    pDevice->EndBracket();

#if PROFILE
    D3DPERF_PerfEventEnd(g_pD3DPerfEventBeginEnd, TRUE);
    g_pD3DPerfEventBeginEnd = NULL;
#endif
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\dumper.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dumper.cpp
 *  Content:    Debug help functions for dumping and viewing the push buffer 
 *              contents and current chip state.
 *
 ***************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#if DBG

//------------------------------------------------------------------------------
// g_ParseState, g_ParsePut
//
// Debug-only allocation for recording all of our state sets:

DWORD g_ParseState[65536 / 4];

// Keeps track of whether a method was modified:

BOOL g_Modified[65536 / 4];

// Debug-only global for tracking our last parse point:

PPUSH g_ParsePut;

// Keeps a copy of the loaded vertex shader programs:

DWORD g_TransformProgram[4*136];

// Current loading index:

DWORD g_TransformProgramLoad;

// Keeps a copy of the loaded vertex shader constants:

DWORD g_TransformConstant[4*192];

// Current loading index:

DWORD g_TransformConstantLoad;

// The next jump is a sub-routine call, ignore it for now:

BOOL g_IgnorePushBufferJump;

//------------------------------------------------------------------------------
// ParseMethodWrite

VOID ParseMethodWrite(
    DWORD Method,   // With sub-channel encoded, but not count of dwords
    PPUSH pPush,   // Write-combined memory, so expensive to read
    DWORD Count)
{
    DWORD i;

    // All valid offsets are a multiple of 4:

    ASSERT((Method & 3) == 0);

    // Get the last value written to this register:

    DWORD lastValue = *(pPush + Count - 1);

    // Mark that the Method has been written to:

    g_Modified[Method >> 2] = TRUE;

    // Record the last value written to the register:

    g_ParseState[Method >> 2] = lastValue;

    // Catch a particular write to register 0x1b70:

    // if ((Method == PUSHER_METHOD(SUBCH_3D, 0x1b70, 0)) && 
    //     ((lastValue & 0xffff0000) == 0xdead0000)) 
    //     _asm int 3; 

    // Watch for special cases:

    if (Method == PUSHER_METHOD(SUBCH_3D, NV097_NO_OPERATION, 0))
    {
        // For now, we don't parse called push-buffers.

        if ((*pPush == NVX_PUSH_BUFFER_RUN) || (*pPush == NVX_PUSH_BUFFER_FIXUP))
            g_IgnorePushBufferJump = TRUE;
    }
    else if (Method == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_PROGRAM_LOAD, 0))
    {
        // The previous load should have done a multiple of 4:

        ASSERT((g_TransformProgramLoad & 3) == 0);

        g_TransformProgramLoad = 4*lastValue;
    }
    else if (Method == PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT_LOAD, 0))
    {
        // The previous load should have done a multiple of 4:

        ASSERT((g_TransformConstantLoad & 3) == 0);

        g_TransformConstantLoad = 4*lastValue;
    }
    else if ((Method >= PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_PROGRAM(0), 0)) &&
             (Method < PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_PROGRAM(32), 0)))
    {
        for (i = 0; i < Count; i++)
        {
            g_TransformProgram[g_TransformProgramLoad++] = *pPush++;

            ASSERT(g_TransformProgramLoad <= sizeof(g_TransformProgram) / 4);
        }
    }
    else if ((Method >= PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT(0), 0)) &&
             (Method < PUSHER_METHOD(SUBCH_3D, NV097_SET_TRANSFORM_CONSTANT(32), 0)))
    {
        for (i = 0; i < Count; i++)
        {
            g_TransformConstant[g_TransformConstantLoad++] = *pPush++;

            ASSERT(g_TransformConstantLoad <= sizeof(g_TransformConstant) / 4);
        }
    }
}

//------------------------------------------------------------------------------
// PARSE_PUSH_BUFFER()
//
// Here we parse the command stream to build our global structure that tracks
// the hardware's current state.

VOID PARSE_PUSH_BUFFER()
{
    CDevice* pDevice = g_pDevice;

    // Reading from write-combined memory is painful, so the dumper is not
    // enabled by default:

    if (!D3D__Parser)
        return;

    // The parser doesn't understand about NULL hardware:

    if (D3D__NullHardware)
        return;

    // When we're recording push-buffer data, we don't parse the push-buffer
    // (the parsing will automatically happen when they do RunPushBuffer):

    if (pDevice->m_StateFlags & STATE_RECORDPUSHBUFFER)
        return;

    PPUSH pPush = g_ParsePut;

    // Catch up from our old parse point to our new:

    while (pPush != pDevice->m_Pusher.m_pPut)
    {
        DWORD push = *pPush;
        DWORD instruction = push >> 29;
        DWORD count = (push & 0x1ffc0000) >> 18;
        DWORD method = push & 0xffff;   // Note we include sub-channel
        DWORD jumpOffset = push & 0x1ffffffc;

        // Advance:

        pPush++;

        // Long jump or call

        if (((push & 3) == 1) || ((push & 3) == 2))
        {
            if (g_IgnorePushBufferJump)
            {
                // Skip over pushbuffer fixup info

                pPush += sizeof(CMiniport::PUSHBUFFERFIXUPINFO) / sizeof(DWORD);

                g_IgnorePushBufferJump = FALSE;
            }
            else
            {
                pPush = (DWORD *)GetWriteCombinedAddress(push & ~3);
            }
        }

        // Parse the instruction:

        else if (instruction == 0) // Immediate increment
        {
            while (count-- != 0)
            {
                ParseMethodWrite(method, pPush, 1);

                pPush++;
                method += 4;
            }
        }
        else if (instruction == 1) // Jump short instruction
        {
            pPush = pDevice->m_pPushBase + (jumpOffset >> 2);
        }
        else if (instruction == 2) // Immediate nonincrement
        {
            ParseMethodWrite(method, pPush, count);

            pPush += count;
        }
        else
        {
            DXGRIP("Unexpected push-buffer instruction: 0x%lx  at: 0x%lx", push, pPush - 1);
        }
    }

    // Remember the new push-buffer location:

    g_ParsePut = pDevice->m_Pusher.m_pPut;
}

//------------------------------------------------------------------------------
// BitField
//
// Given a dword and a bitfield range like 5:2, returns the numeric value.

DWORD BitField(
    DWORD Value,
    DWORD HighBit,
    DWORD LowBit)
{
    if (HighBit != 31)
    {
        Value &= ((1 << (HighBit + 1)) - 1);
    }

    Value >>= LowBit;

    return Value;
}

//------------------------------------------------------------------------------
// PrintFloat
//
// Hack-around to remove our sprintf CRT depedency, since libcntpr.lib 
// (currently) does not support floats with printf.

VOID PrintFloat(
    float* f)
{
    DWORD scaled = (DWORD)FloatToLong(*f * 1000.0f);

    DbgPrint("%li.%03li", scaled / 1000, scaled % 1000);
}

//------------------------------------------------------------------------------
// ShowDump()
//
// Show a dump of the current register state.

VOID ShowDump(
    DWORD subch)
{
    DWORD method;
    DWORD fieldCount;
    DWORD i;
    DWORD j;
    DWORD* pState;
    BOOL* pModified;
    FieldDescription* pField;
    FieldDescription* pFieldLimit;
    FieldDescription* pThis;
    BOOL showIt;

    if (subch == SUBCH_3D)
    {
        pField = (FieldDescription*)g_Kelvin;
        pFieldLimit = pField + ((sizeof(g_Kelvin) / sizeof(g_Kelvin[0])) - 1);

        pState = &g_ParseState[(subch << 13) >> 2];
        pModified = &g_Modified[(subch << 13) >> 2];
    }
    else
    {
        DbgPrint("No field description for subchannel %li", subch);
        return;
    }

    DbgPrint("-----------------------------------------------------------\n");

    // Loop through the description array in order:

    while (pField < pFieldLimit)
    {
        ASSERT((pField->ReplicationCount[0] != 0) &&
               (pField->ReplicationCount[1] != 0));

        showIt = FALSE;
        for (i = 0; i < pField->ReplicationCount[0]; i++)
        {
            for (j = 0; j < pField->ReplicationCount[1]; j++)
            {
                method = pField->Method
                       + i * pField->ReplicationStride[0]
                       + j * pField->ReplicationStride[1];

                if (pState[method >> 2] != 0)
                    showIt = TRUE;
            }
        }

        // Don't show fields that have zero values, or any fields with
        // capital letter 'types' (which denote read-only fields):

        if ((showIt) &&
            !((pField->FieldType >= 'A') && (pField->FieldType <= 'Z')))
        {
            // Handle replications specially:

            if (pField->ReplicationCount[0] > 1)
            {
                // Handle 1-d replications of dword values specially:

                if ((pField->ReplicationCount[1] <= 1) &&
                    (pField->ReplicationCount[0] > 1) &&
                    (pField->FieldHighBit == 31) &&
                    (pField->FieldLowBit == 0))
                {
                    // 0x400 - SET_MODEL_VIEW_MATRIX0
                    //     Zero:    0.0    1.0   2.0   3.0

                    DbgPrint("0x%lx - %s\n    %-20s:\t",
                             pField->Method,
                             pField->MethodName,
                             pField->FieldName);
                                            
                    for (i = 0; i < pField->ReplicationCount[0]; i++)
                    {
                        // Insert a return to make matrices appear 4x4:

                        if ((i > 0) && 
                            ((i & 3) == 0) && 
                            (pField->ReplicationCount[0] == 16))
                        {
                            DbgPrint("\n\t\t\t\t");
                        }

                        method = pField->Method 
                               + i * pField->ReplicationStride[0];

                        if (pField->FieldType == 'f')
                        {
                            PrintFloat((float*) &pState[method >> 2]);
                            DbgPrint(" \t");
                        }
                        else
                        {
                            DbgPrint("0x%lx\t", pState[method >> 2]);
                        }
                    }

                    DbgPrint("\n");
                }
                else
                {
                    for (i = 0; i < pField->ReplicationCount[0]; i++)
                    {
                        // Handle all 2-d replications specially.
                        // We assume there's no bitfields stuff in 2-d 
                        // replications.
    
                        if (pField->ReplicationCount[1] > 1)
                        {
                            ASSERT((pField->FieldHighBit == 31) &&
                                   (pField->FieldLowBit == 0));

                            // 0x800 - SET_LIGHT_AMBIENT_COLOR(3)
                            //     Zero:   0.0    0.0    0.0   0.0
        
                            DbgPrint("0x%lx - %s(%li)\n    %-20s:\t",
                                     pField->Method,
                                     pField->MethodName,
                                     i,
                                     pField->FieldName);
            
                            for (j = 0; j < pField->ReplicationCount[1]; j++)
                            {
                                // Insert a return to make matrices appear 4x4:
        
                                if ((j > 0) && 
                                    ((j & 3) == 0) && 
                                    (pField->ReplicationCount[1] == 16))
                                {
                                    DbgPrint("\n\t\t\t\t");
                                }
        
                                method = pField->Method 
                                       + i * pField->ReplicationStride[0]
                                       + j * pField->ReplicationStride[1];
        
                                if (pField->FieldType == 'f')
                                {
                                    PrintFloat((float*) &pState[method >> 2]);
                                    DbgPrint("\t ");
                                }
                                else
                                {
                                    DbgPrint("0x%lx\t", pState[method >> 2]);
                                }
                            }
        
                            DbgPrint("\n");
                        }
                        else
                        {
                            // 0x218 - SET_TEXTURE_FORMAT(2)
                            //     CONTEXT_DMA:     0x0
                            //     ENABLE:          0x0

                            method = pField->Method 
                                   + i * pField->ReplicationStride[0];

                            DbgPrint("0x%lx - %s(%li)\t\t\t0x%lx\n",
                                     pField->Method,
                                     pField->MethodName,
                                     i,
                                     pState[method >> 2]);

                            for (pThis = pField; 
                                 pThis->Method == pField->Method;
                                 pThis++)
                            {
                                DbgPrint("    %-20s:\t0x%lx\n",
                                         pThis->FieldName,
                                         BitField(pState[method >> 2],
                                                  pThis->FieldHighBit,
                                                  pThis->FieldLowBit));
                            }
                        }
                    }
                }
            }
            else
            {
                // 0x200 - SET_SURFACE_CLIP_HORIZONTAL 
                //     X:   0x0
                //     WIDTH:   0x1e0

                method = pField->Method;

                DbgPrint("0x%lx - %s\t\t\t0x%lx\n",
                         pField->Method,
                         pField->MethodName,
                         pState[method >> 2]);

                if (pField->FieldType == 'f')
                {
                    DbgPrint("    %-20s:\t",
                             pField->FieldName);
                    PrintFloat((float*) &pState[method >> 2]);
                    DbgPrint("\n");
                }
                else
                {
                    for (pThis = pField; 
                         pThis->Method == pField->Method;
                         pThis++)
                    {
                        DbgPrint("    %-20s:\t0x%lx\n",
                                 pThis->FieldName,
                                 BitField(pState[method >> 2],
                                          pThis->FieldHighBit,
                                          pThis->FieldLowBit));
                    }
                }
            }
        }

        // Advance and skip over any multiple bitfields for this method 
        // (since we already handled them above):

        pThis = pField;
        do {
            pField++;
        } while (pField->Method == pThis->Method);
    }
}

//------------------------------------------------------------------------------
// Like DRF_VAL, but without the dorky separate parameter requirement:

#define HW_VAL(Reg, Field, Val) (((Val)>>DRF_SHIFT(NV097##_##Reg##_## Field)) & \
    DRF_MASK(NV097##_##Reg##_##Field))

// Read back from the register state:

#define HW(Reg, Field) \
    HW_VAL(Reg, Field, g_ParseState[(NV097##_##Reg >> 2) + SUBCH_3D*2048])
    
#define HWx(x, Reg, Field) \
    HW_VAL(Reg, Field, g_ParseState[(NV097##_##Reg##(##x##) >> 2) + SUBCH_3D*2048])

//------------------------------------------------------------------------------
// PRIMITIVE_LAUNCH_STATE_TEST()
//
// Performs a test identical to that which the hardware does when it launches
// a primitive.  By doing this in software here, we can easily figure out
// what the exact problem is...

VOID PRIMITIVE_LAUNCH_STATE_TEST()
{
    // If the dumper is not enabled, we can't check the state:

    if (!D3D__Parser)
        return;

    // Make sure we've parsed everything added so far so that g_ParseState
    // is current:

    PARSE_PUSH_BUFFER();

    if ((((HW(SET_BLEND_ENABLE, V))) == NV097_SET_BLEND_ENABLE_V_TRUE) &&
        ((((HW(SET_BLEND_EQUATION, V))) == NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT_SIGNED) ||
         (((HW(SET_BLEND_EQUATION, V))) == NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED)) &&
        ((((HW(SET_SURFACE_FORMAT, COLOR))) == NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5) ||
         (((HW(SET_SURFACE_FORMAT, COLOR))) == NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5) ||
         (((HW(SET_SURFACE_FORMAT, COLOR))) == NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5) ||
         (((HW(SET_SURFACE_FORMAT, COLOR))) == NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8) ||
         (((HW(SET_SURFACE_FORMAT, COLOR))) == NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8)))
    {
        DXGRIP("Combination of signed SetBlendEquation and certain color formats is not allowed");
    }

    if ((((HWx(0, SET_TEXTURE_CONTROL0, LOG_MAX_ANISO)) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
        ((((HWx(0, SET_TEXTURE_FORMAT, BASE_SIZE_P))) > NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1) ||
         (((HWx(0, SET_TEXTURE_FORMAT, DIMENSIONALITY))) == NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE))) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, ENABLE)))))
    {
        DXGRIP("No aniso support for 3D textures");
    }

    if ((((HWx(1, SET_TEXTURE_CONTROL0, LOG_MAX_ANISO)) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
        ((((HWx(1, SET_TEXTURE_FORMAT, BASE_SIZE_P))) > NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1) ||
         (((HWx(1, SET_TEXTURE_FORMAT, DIMENSIONALITY))) == NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE))) &&
        (((HWx(1, SET_TEXTURE_CONTROL0, ENABLE)))))
    {
        DXGRIP("No aniso support for 3D textures");
    }

    if ((((HWx(2, SET_TEXTURE_CONTROL0, LOG_MAX_ANISO)) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
        ((((HWx(2, SET_TEXTURE_FORMAT, BASE_SIZE_P))) > NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1) ||
         (((HWx(2, SET_TEXTURE_FORMAT, DIMENSIONALITY))) == NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE))) &&
        (((HWx(2, SET_TEXTURE_CONTROL0, ENABLE)))))
    {
        DXGRIP("No aniso support for 3D textures");
    }

    if ((((HWx(3, SET_TEXTURE_CONTROL0, LOG_MAX_ANISO)) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
        ((((HWx(3, SET_TEXTURE_FORMAT, BASE_SIZE_P))) > NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1) ||
         (((HWx(3, SET_TEXTURE_FORMAT, DIMENSIONALITY))) == NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE))) &&
        (((HWx(3, SET_TEXTURE_CONTROL0, ENABLE)))))
    {
        DXGRIP("No aniso support for 3D textures");
    }

    if ((((HWx(0, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
        (((HWx(0, SET_TEXTURE_IMAGE_RECT, HEIGHT))) & 0x1) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
    {
        DXGRIP("Invalid height with field enable");
    }

    if ((((HWx(1, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
        (((HWx(1, SET_TEXTURE_IMAGE_RECT, HEIGHT))) & 0x1) &&
        (((HWx(1, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
    {
        DXGRIP("Invalid height with field enable");
    }

    if ((((HWx(2, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
        (((HWx(2, SET_TEXTURE_IMAGE_RECT, HEIGHT))) & 0x1) &&
        (((HWx(2, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
    {
        DXGRIP("Invalid height with field enable");
    }

    if ((((HWx(3, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
        (((HWx(3, SET_TEXTURE_IMAGE_RECT, HEIGHT))) & 0x1) &&
        (((HWx(3, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
    {
        DXGRIP("Invalid height with field enable");
    }

    if ((((HWx(0, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
        (((HWx(0, SET_TEXTURE_FORMAT, BORDER_SOURCE))) != NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
    {
        DXGRIP("Can't use ImageFieldEnable with border data in the texture");
    }

    if ((((HWx(1, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
        (((HWx(1, SET_TEXTURE_FORMAT, BORDER_SOURCE))) != NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR) &&
        (((HWx(1, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
    {
        DXGRIP("Can't use ImageFieldEnable with border data in the texture");
    }

    if ((((HWx(2, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
        (((HWx(2, SET_TEXTURE_FORMAT, BORDER_SOURCE))) != NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR) &&
        (((HWx(2, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
    {
        DXGRIP("Can't use ImageFieldEnable with border data in the texture");
    }

    if ((((HWx(3, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
        (((HWx(3, SET_TEXTURE_FORMAT, BORDER_SOURCE))) != NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR) &&
        (((HWx(3, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
    {
        DXGRIP("Can't use ImageFieldEnable with border data in the texture");
    }

    if ((((HWx(0, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE)))) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        (! ((((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8))))
    {
        DXGRIP("Can't use ImageFieldEnable unless texture is a linear format");
    }

    if ((((HWx(0, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE)))) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        (! ((((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
          (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8))))
    {
        DXGRIP("Can't use ImageFieldEnable unless texture is a linear format");
    }

    if ((((HWx(1, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE)))) &&
        (((HWx(1, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        (! ((((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
          (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8))))
    {
        DXGRIP("Can't use ImageFieldEnable unless texture is a linear format");
    }

    if ((((HWx(2, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE)))) &&
        (((HWx(2, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        (! ((((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
          (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8))))
    {
        DXGRIP("Can't use ImageFieldEnable unless texture is a linear format");
    }

    if ((((HWx(3, SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE)))) &&
        (((HWx(3, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        (! ((((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
          (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8))))
    {
        DXGRIP("Can't use ImageFieldEnable unless texture is a linear format");
    }

    if ((((HWx(0, SET_TEXTURE_CONTROL0, LOG_MAX_ANISO))) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
        ((((HWx(0, SET_TEXTURE_FILTER, MIN))) == NV097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0) ||
         (((HWx(0, SET_TEXTURE_FILTER, MAG))) == NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0)) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, ENABLE)))))
    {
        DXGRIP("No aniso support for convolution filter");
    }

    if ((((HWx(1, SET_TEXTURE_CONTROL0, LOG_MAX_ANISO))) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
        ((((HWx(1, SET_TEXTURE_FILTER, MIN))) == NV097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0) ||
         (((HWx(1, SET_TEXTURE_FILTER, MAG))) == NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0)) &&
        (((HWx(1, SET_TEXTURE_CONTROL0, ENABLE)))))
    {
        DXGRIP("No aniso support for convolution filter");
    }

    if ((((HWx(2, SET_TEXTURE_CONTROL0, LOG_MAX_ANISO))) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
        ((((HWx(2, SET_TEXTURE_FILTER, MIN))) == NV097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0) ||
         (((HWx(2, SET_TEXTURE_FILTER, MAG))) == NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0)) &&
        (((HWx(2, SET_TEXTURE_CONTROL0, ENABLE)))))
    {
        DXGRIP("No aniso support for convolution filter");
    }

    if ((((HWx(3, SET_TEXTURE_CONTROL0, LOG_MAX_ANISO))) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
        ((((HWx(3, SET_TEXTURE_FILTER, MIN))) == NV097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0) ||
         (((HWx(3, SET_TEXTURE_FILTER, MAG))) == NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0)) &&
        (((HWx(3, SET_TEXTURE_CONTROL0, ENABLE)))))
    {
        DXGRIP("No aniso support for convolution filter");
    }

    if (((((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8)) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        ((((HWx(0, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA) ||
         (((HWx(0, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA) ||
         (((HWx(0, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL)))
    {
        DXGRIP("No color-key support for compressed texture formats");
    }

    if (((((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8)) &&
        (((HWx(1, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        ((((HWx(1, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA) ||
         (((HWx(1, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA) ||
         (((HWx(1, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL)))
    {
        DXGRIP("No color-key support for compressed texture formats");
    }

    if (((((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8)) &&
        (((HWx(2, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        ((((HWx(2, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA) ||
         (((HWx(2, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA) ||
         (((HWx(2, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL)))
    {
        DXGRIP("No color-key support for compressed texture formats");
    }

    if (((((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8)) &&
        (((HWx(3, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        ((((HWx(3, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA) ||
         (((HWx(3, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA) ||
         (((HWx(3, SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL)))
    {
        DXGRIP("No color-key support for compressed texture formats");
    }

    if (((((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
         (((HWx(0, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8)) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        ((((HWx(0, SET_TEXTURE_ADDRESS, U))) == NV097_SET_TEXTURE_ADDRESS_U_WRAP) || 
         (((HWx(0, SET_TEXTURE_ADDRESS, U))) == NV097_SET_TEXTURE_ADDRESS_U_MIRROR) ||
         (((HWx(0, SET_TEXTURE_ADDRESS, V))) == NV097_SET_TEXTURE_ADDRESS_V_WRAP) || 
         (((HWx(0, SET_TEXTURE_ADDRESS, V))) == NV097_SET_TEXTURE_ADDRESS_V_MIRROR)))
    {
        DXGRIP("No wrap or mirror if texture is a linear format");
    }

    if (((((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
         (((HWx(1, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8)) &&
        (((HWx(1, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        ((((HWx(1, SET_TEXTURE_ADDRESS, U))) == NV097_SET_TEXTURE_ADDRESS_U_WRAP) || 
         (((HWx(1, SET_TEXTURE_ADDRESS, U))) == NV097_SET_TEXTURE_ADDRESS_U_MIRROR) ||
         (((HWx(1, SET_TEXTURE_ADDRESS, V))) == NV097_SET_TEXTURE_ADDRESS_V_WRAP) || 
         (((HWx(1, SET_TEXTURE_ADDRESS, V))) == NV097_SET_TEXTURE_ADDRESS_V_MIRROR)))
    {
        DXGRIP("No wrap or mirror if texture is a linear format");
    }

    if (((((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
         (((HWx(2, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8)) &&
        (((HWx(2, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        ((((HWx(2, SET_TEXTURE_ADDRESS, U))) == NV097_SET_TEXTURE_ADDRESS_U_WRAP) || 
         (((HWx(2, SET_TEXTURE_ADDRESS, U))) == NV097_SET_TEXTURE_ADDRESS_U_MIRROR) ||
         (((HWx(2, SET_TEXTURE_ADDRESS, V))) == NV097_SET_TEXTURE_ADDRESS_V_WRAP) || 
         (((HWx(2, SET_TEXTURE_ADDRESS, V))) == NV097_SET_TEXTURE_ADDRESS_V_MIRROR)))
    {
        DXGRIP("No wrap or mirror if texture is a linear format");
    }

    if (((((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
         (((HWx(3, SET_TEXTURE_FORMAT, COLOR))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8)) &&
        (((HWx(3, SET_TEXTURE_CONTROL0, ENABLE)))) &&
        ((((HWx(3, SET_TEXTURE_ADDRESS, U))) == NV097_SET_TEXTURE_ADDRESS_U_WRAP) || 
         (((HWx(3, SET_TEXTURE_ADDRESS, U))) == NV097_SET_TEXTURE_ADDRESS_U_MIRROR) ||
         (((HWx(3, SET_TEXTURE_ADDRESS, V))) == NV097_SET_TEXTURE_ADDRESS_V_WRAP) || 
         (((HWx(3, SET_TEXTURE_ADDRESS, V))) == NV097_SET_TEXTURE_ADDRESS_V_MIRROR)))
    {
        DXGRIP("No wrap or mirror if texture is a linear format");
    }

    if (((((HWx(0, SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
         (((HWx(0, SET_COMBINER_ALPHA_OCW, AB_DST))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
         (((HWx(0, SET_COMBINER_ALPHA_OCW, AB_DST))) == ((HWx(0, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
        ((((HWx(0, SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
         (((HWx(0, SET_COMBINER_ALPHA_OCW, CD_DST))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
         (((HWx(0, SET_COMBINER_ALPHA_OCW, CD_DST))) == ((HWx(0, SET_COMBINER_COLOR_OCW, CD_DST))))))
    {
        DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
    }

    if (((((HWx(1, SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
         (((HWx(1, SET_COMBINER_ALPHA_OCW, AB_DST))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
         (((HWx(1, SET_COMBINER_ALPHA_OCW, AB_DST))) == ((HWx(1, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
        ((((HWx(1, SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
         (((HWx(1, SET_COMBINER_ALPHA_OCW, CD_DST))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
         (((HWx(1, SET_COMBINER_ALPHA_OCW, CD_DST))) == ((HWx(1, SET_COMBINER_COLOR_OCW, CD_DST))))))
    {
        DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
    }

    if (((((HWx(2, SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
         (((HWx(2, SET_COMBINER_ALPHA_OCW, AB_DST))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
         (((HWx(2, SET_COMBINER_ALPHA_OCW, AB_DST))) == ((HWx(2, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
        ((((HWx(2, SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
         (((HWx(2, SET_COMBINER_ALPHA_OCW, CD_DST))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
         (((HWx(2, SET_COMBINER_ALPHA_OCW, CD_DST))) == ((HWx(2, SET_COMBINER_COLOR_OCW, CD_DST))))))
    {
        DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
    }

    if (((((HWx(3, SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
         (((HWx(3, SET_COMBINER_ALPHA_OCW, AB_DST))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
         (((HWx(3, SET_COMBINER_ALPHA_OCW, AB_DST))) == ((HWx(3, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
        ((((HWx(3, SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
         (((HWx(3, SET_COMBINER_ALPHA_OCW, CD_DST))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
         (((HWx(3, SET_COMBINER_ALPHA_OCW, CD_DST))) == ((HWx(3, SET_COMBINER_COLOR_OCW, CD_DST))))))
    {
        DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
    }

    if (((((HWx(4, SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
         (((HWx(4, SET_COMBINER_ALPHA_OCW, AB_DST))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
         (((HWx(4, SET_COMBINER_ALPHA_OCW, AB_DST))) == ((HWx(4, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
        ((((HWx(4, SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
         (((HWx(4, SET_COMBINER_ALPHA_OCW, CD_DST))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
         (((HWx(4, SET_COMBINER_ALPHA_OCW, CD_DST))) == ((HWx(4, SET_COMBINER_COLOR_OCW, CD_DST))))))
    {
        DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
    }

    if (((((HWx(5, SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
         (((HWx(5, SET_COMBINER_ALPHA_OCW, AB_DST))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
         (((HWx(5, SET_COMBINER_ALPHA_OCW, AB_DST))) == ((HWx(5, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
        ((((HWx(5, SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
         (((HWx(5, SET_COMBINER_ALPHA_OCW, CD_DST))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
         (((HWx(5, SET_COMBINER_ALPHA_OCW, CD_DST))) == ((HWx(5, SET_COMBINER_COLOR_OCW, CD_DST))))))
    {
        DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
    }

    if (((((HWx(6, SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
         (((HWx(6, SET_COMBINER_ALPHA_OCW, AB_DST))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
         (((HWx(6, SET_COMBINER_ALPHA_OCW, AB_DST))) == ((HWx(6, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
        ((((HWx(6, SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
         (((HWx(6, SET_COMBINER_ALPHA_OCW, CD_DST))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
         (((HWx(6, SET_COMBINER_ALPHA_OCW, CD_DST))) == ((HWx(6, SET_COMBINER_COLOR_OCW, CD_DST))))))
    {
        DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
    }

    if (((((HWx(7, SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
         (((HWx(7, SET_COMBINER_ALPHA_OCW, AB_DST))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
         (((HWx(7, SET_COMBINER_ALPHA_OCW, AB_DST))) == ((HWx(7, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
        ((((HWx(7, SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
         (((HWx(7, SET_COMBINER_ALPHA_OCW, CD_DST))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
         (((HWx(7, SET_COMBINER_ALPHA_OCW, CD_DST))) == ((HWx(7, SET_COMBINER_COLOR_OCW, CD_DST))))))
    {
        DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
    }

    if (((((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ST) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP_LUMINANCE) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_AR) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_GB) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT)) &&
        (((((HW(SET_SHADER_OTHER_STAGE_INPUT, STAGE2))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_1) &&
          ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE) ||
           (((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT) ||
           (((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE))) ||
         ((((HW(SET_SHADER_OTHER_STAGE_INPUT, STAGE2))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_0) &&
          ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE0))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE) ||
           (((HW(SET_SHADER_STAGE_PROGRAM, STAGE0))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE)))))
    {
        DXGRIP("Need a color in this stage");
    }

    if (((((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR) ||
         (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB)) &&
        (((((HW(SET_SHADER_OTHER_STAGE_INPUT, STAGE3))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_2) &&
          ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE) ||
           (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT) ||
           (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE))) ||
         ((((HW(SET_SHADER_OTHER_STAGE_INPUT, STAGE3))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_1) &&
          ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE) ||
           (((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT) ||
           (((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE))) ||
         ((((HW(SET_SHADER_OTHER_STAGE_INPUT, STAGE3))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_0) &&
          ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE0))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE) ||
           (((HW(SET_SHADER_STAGE_PROGRAM, STAGE0))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE)))))
    {
        DXGRIP("Need a color in this stage");
    }

    if ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE0))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE0))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE0))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE) &&
        (((HWx(0, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE))
    {
        DXGRIP("Stage requires a texture but none enabled");
    }

    if ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PASS_THROUGH) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE1))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE) &&
        (((HWx(1, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE))
    {
        DXGRIP("Stage requires a texture but none enabled");
    }

    if ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PASS_THROUGH) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE) &&
        (((HWx(2, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE))
    {
        DXGRIP("Stage requires a texture but none enabled");
    }

    if ((((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE2))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW) &&
        (((HW(SET_SHADER_STAGE_PROGRAM, STAGE3))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE) &&
        (((HWx(3, SET_TEXTURE_CONTROL0, ENABLE))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE))
    {
        DXGRIP("Stage requires a texture but none enabled");
    }
}

//------------------------------------------------------------------------------
// GetTextureAddress

DWORD GetTextureAddress(DWORD Stage)
{
    DWORD* pTextureStates = D3D__TextureState[Stage];

    DWORD texCoordIndex = pTextureStates[D3DTSS_TEXCOORDINDEX] & 0xffff;

    DWORD address
        = DRF_NUMFAST(097, _SET_TEXTURE_ADDRESS, _U,
                      pTextureStates[D3DTSS_ADDRESSU])
        | DRF_NUMFAST(097, _SET_TEXTURE_ADDRESS, _V,
                      pTextureStates[D3DTSS_ADDRESSV])
        | DRF_NUMFAST(097, _SET_TEXTURE_ADDRESS, _P,
                      pTextureStates[D3DTSS_ADDRESSW])
        | D3D__RenderState[D3DRS_WRAP0 + texCoordIndex];

    return address;
}

//------------------------------------------------------------------------------
// GetTextureControl0

DWORD GetTextureControl0(DWORD Stage)
{
    CDevice* pDevice = g_pDevice;

    if (pDevice->m_Textures[Stage] == NULL)
    {
        return 0;
    }
    else
    {
        return pDevice->m_TextureControl0Enabled[Stage];
    }
}

//------------------------------------------------------------------------------
// GetTextureFormat

DWORD GetTextureFormat(DWORD Stage)
{
    CDevice* pDevice = g_pDevice;

    if (pDevice->m_Textures[Stage])
    {
        return pDevice->m_Textures[Stage]->Format;
    }
    else
    {
        return 0;
    }
}

//------------------------------------------------------------------------------
// GetTextureImageRect

DWORD GetTextureImageRect(DWORD Stage)
{
    CDevice* pDevice = g_pDevice;
    D3DBaseTexture* pTexture = pDevice->m_Textures[Stage];

    if (pTexture == NULL)
    {
        return 0;
    }

    DWORD width = PixelJar::GetWidth(pTexture);
    DWORD height = PixelJar::GetHeight(pTexture);

    return (DRF_NUMFAST(097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, width) |
            DRF_NUMFAST(097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, height));
}

//------------------------------------------------------------------------------
// GetTextureFilter

DWORD GetTextureFilter(DWORD Stage)
{
    DWORD* pTextureStates = D3D__TextureState[Stage];

    if (pTextureStates == NULL)
    {
        return 0;
    }

    CDevice* pDevice = g_pDevice;
    DWORD minFilter = pTextureStates[D3DTSS_MINFILTER];
    DWORD magFilter = pTextureStates[D3DTSS_MAGFILTER];

    DWORD convolutionKernel = DRF_DEF(097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, _QUINCUNX);

    if ((minFilter >= D3DTEXF_ANISOTROPIC) || (magFilter >= D3DTEXF_ANISOTROPIC))
    {
        if ((minFilter > D3DTEXF_ANISOTROPIC) || (magFilter > D3DTEXF_ANISOTROPIC))
        {
            if ((minFilter == D3DTEXF_GAUSSIANCUBIC) ||
                (magFilter == D3DTEXF_GAUSSIANCUBIC))
            {
                convolutionKernel = DRF_DEF(097, _SET_TEXTURE_FILTER, 
                                            _CONVOLUTION_KERNEL, _GAUSSIAN_3);
            }

            convolutionKernel |= DRF_DEF(097, _SET_TEXTURE_FILTER, 
                                         _MIN, _CONVOLUTION_2D_LOD0);

            minFilter = D3DTEXF_LINEAR;
            magFilter = NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0;
        }
        else
        {
            DWORD maxAnisotropy = pTextureStates[D3DTSS_MAXANISOTROPY];
            if (maxAnisotropy == 0)
            {
                minFilter = D3DTEXF_POINT;
                magFilter = D3DTEXF_POINT;
            }
            else
            {
                minFilter = D3DTEXF_LINEAR;
                magFilter = D3DTEXF_LINEAR;
            }
        }
    }

    INT lodBias = Round(256.0f * (Floatify(pTextureStates[D3DTSS_MIPMAPLODBIAS])
                                  + pDevice->m_SuperSampleLODBias));

    if (lodBias < -0x1000)
        lodBias = -0x1000;
    if (lodBias > 0xfff)
        lodBias = 0xfff;

    DWORD colorSign = (pTextureStates[D3DTSS_COLOROP] >= D3DTOP_BUMPENVMAP)
        ? (D3DTSIGN_GSIGNED | D3DTSIGN_BSIGNED)
        : pTextureStates[D3DTSS_COLORSIGN];

    DWORD filter 
        = DRF_NUM(097, _SET_TEXTURE_FILTER, _MIPMAP_LOD_BIAS, lodBias)

        | convolutionKernel

        | MinFilter(minFilter, pTextureStates[D3DTSS_MIPFILTER])

        | DRF_NUMFAST(097, _SET_TEXTURE_FILTER, _MAG, magFilter)

        | colorSign;

    return filter;
}

//------------------------------------------------------------------------------
// GetShaderStageProgram

DWORD GetShaderStageProgram()
{
    CDevice* pDevice = g_pDevice;
    INT stage;
    DWORD shaderStageProgram = 0;

    D3D__DirtyFlags &= ~D3DDIRTYFLAG_SHADER_STAGE_PROGRAM;

    if (pDevice->m_pPixelShader == NULL)
    {
        for (stage = 3; stage >= 0; stage--)
        {
            DWORD shaderMode 
                = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE;

            D3DBaseTexture* pTexture = pDevice->m_Textures[stage];
    
            if (pTexture == NULL)
            {
                shaderMode = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE;
            }
            else if (D3D__TextureState[stage][D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP)
            {
                shaderMode = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP;
            }
            else if (D3D__TextureState[stage][D3DTSS_COLOROP] 
                == D3DTOP_BUMPENVMAPLUMINANCE)
            {
                shaderMode =
                    NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
            }
            else if (pTexture->Format &
                 DRF_DEF(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, _TRUE))
            {
                shaderMode = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP;
            }
            else if ((pTexture->Format & DRF_NUM(097, _SET_TEXTURE_FORMAT, 
                                                 _DIMENSIONALITY, ~0)) ==
                  DRF_DEF(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, _THREE))
            {
                shaderMode = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE;
            }
    
            shaderStageProgram = (shaderStageProgram << 5) | shaderMode;
        }
    }
    else
    {
        DWORD PSShaderStageProgram = pDevice->m_PSShaderStageProgram;

        if(pDevice->m_ShaderAdjustsTexMode == 0)
        {
            // don't adjust shader stage program
            shaderStageProgram = PSShaderStageProgram;
        }
        else
        {
            // adjust shader stage program according to set textures
            for (stage = 3; stage >= 0; stage--)
            {
                // Assume by default we'll keep the specified mode for this stage:
    
                DWORD shaderMode = (PSShaderStageProgram >> (stage * 5)) & 0x1f;
    
                // PERF: Disable texture unit for _NONE case?
    
                D3DBaseTexture* pTexture = pDevice->m_Textures[stage];
    
                if (pTexture == NULL)
                {
                    shaderMode = PS_TEXTUREMODES_NONE;
                }
                else if ((shaderMode >= PS_TEXTUREMODES_PROJECT2D) &&
                         (shaderMode <= PS_TEXTUREMODES_CUBEMAP))
                {
                    DWORD colorFormat = pTexture->Format 
                        & DRF_NUM(097, _SET_TEXTURE_FORMAT, _COLOR, ~0);
    
                    if (pTexture->Format & 
                        DRF_DEF(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, _TRUE))
                    {
                        shaderMode = PS_TEXTUREMODES_CUBEMAP;
                    }
                    else if (((pTexture->Format & DRF_NUM(097, _SET_TEXTURE_FORMAT, 
                                                          _DIMENSIONALITY, ~0)) 
                                == DRF_DEF(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, 
                                           _THREE)) ||
    
                             ((colorFormat >= DRF_DEF(097, _SET_TEXTURE_FORMAT, 
                                                      _COLOR, _SZ_DEPTH_X8_Y24_FIXED)) &&
                              (colorFormat <= DRF_DEF(097, _SET_TEXTURE_FORMAT, 
                                                      _COLOR, _LU_IMAGE_DEPTH_Y16_FLOAT))))
                    {
                        shaderMode = PS_TEXTUREMODES_PROJECT3D;
                    }
                    else
                    {
                        shaderMode = PS_TEXTUREMODES_PROJECT2D;
                    }
                }
                else if ((shaderMode == PS_TEXTUREMODES_DOT_STR_3D) ||
                         (shaderMode == PS_TEXTUREMODES_DOT_STR_CUBE))
                {
                    if (pTexture->Format & DRF_DEF(097, _SET_TEXTURE_FORMAT, 
                                                  _CUBEMAP_ENABLE, _TRUE))
                    {
                        shaderMode = PS_TEXTUREMODES_DOT_STR_CUBE;
                    }
                    else
                    {
                        shaderMode = PS_TEXTUREMODES_DOT_STR_3D;
                    }
                }
        
                shaderStageProgram = (shaderStageProgram << 5) | shaderMode;
            }
        }
    }

    return shaderStageProgram;
}

//------------------------------------------------------------------------------
// PRIMITIVE_LAUNCH_STATE_TEST2

VOID PRIMITIVE_LAUNCH_STATE_TEST2()
{
    CDevice* pDevice = g_pDevice;
    int i;

    DWORD SFmt = PixelJar::GetSurfaceFormat(pDevice->m_pRenderTarget, pDevice->m_pZBuffer);
    if (D3D__RenderState[D3DRS_ALPHABLENDENABLE] &&
        (D3D__RenderState[D3DRS_BLENDOP] == D3DBLENDOP_REVSUBTRACTSIGNED ||
         D3D__RenderState[D3DRS_BLENDOP] == D3DBLENDOP_ADDSIGNED) &&
        (((HW_VAL(SET_SURFACE_FORMAT, COLOR, SFmt)) == NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5) ||
         ((HW_VAL(SET_SURFACE_FORMAT, COLOR, SFmt)) == NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5) ||
         ((HW_VAL(SET_SURFACE_FORMAT, COLOR, SFmt)) == NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5) ||
         ((HW_VAL(SET_SURFACE_FORMAT, COLOR, SFmt)) == NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8) ||
         ((HW_VAL(SET_SURFACE_FORMAT, COLOR, SFmt)) == NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8)))
    {
        DXGRIP("Combination of signed SetBlendEquation and certain color formats is not allowed");
    }

    for (i = 0; i < 4; i++)
    {
        DWORD TCtl = GetTextureControl0(i);
        DWORD TFmt = GetTextureFormat(i);
        
        if ((((HW_VAL(SET_TEXTURE_CONTROL0, LOG_MAX_ANISO, TCtl)) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
            ((((HW_VAL(SET_TEXTURE_FORMAT, BASE_SIZE_P, TFmt))) > NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P_1) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, DIMENSIONALITY, TFmt))) == NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_THREE))) &&
            (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl)))))
        {
            DXGRIP("No aniso support for 3D textures");
        }
    }

    for (i = 0; i < 4; i++)
    {
        DWORD TCtl = GetTextureControl0(i);
        DWORD IRect = GetTextureImageRect(i);

        if ((((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
            (((HW_VAL(SET_TEXTURE_IMAGE_RECT, HEIGHT, IRect))) & 0x1) &&
            (((HW_VAL(SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE, TCtl))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
        {
            DXGRIP("Invalid height with field enable");
        }
    }

    for (i = 0; i < 4; i++)
    {
        DWORD TCtl = GetTextureControl0(i);
        DWORD TFmt = GetTextureFormat(i);

        if ((((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE) &&
            (((HW_VAL(SET_TEXTURE_FORMAT, BORDER_SOURCE, TFmt))) != NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR) &&
            (((HW_VAL(SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE, TCtl))) == NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE))
        {
            DXGRIP("Can't use ImageFieldEnable with border data in the texture");
        }
    }

    for (i = 0; i < 4; i++)
    {
        DWORD TCtl = GetTextureControl0(i);
        DWORD TFmt = GetTextureFormat(i);

        if ((((HW_VAL(SET_TEXTURE_CONTROL0, IMAGE_FIELD_ENABLE, TCtl)))) &&
            (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl)))) &&
            (! ((((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
              (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8))))
        {
            DXGRIP("Can't use ImageFieldEnable unless texture is a linear format");
        }
    }

    for (i = 0; i < 4; i++)
    {
        DWORD TCtl = GetTextureControl0(i);
        DWORD Fltr = GetTextureFilter(i);

        if ((((HW_VAL(SET_TEXTURE_CONTROL0, LOG_MAX_ANISO, TCtl))) > NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0) &&
            ((((HW_VAL(SET_TEXTURE_FILTER, MIN, Fltr))) == NV097_SET_TEXTURE_FILTER_MIN_CONVOLUTION_2D_LOD0) ||
             (((HW_VAL(SET_TEXTURE_FILTER, MAG, Fltr))) == NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0)) &&
            (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl)))))
        {
            DXGRIP("No aniso support for convolution filter");
        }
    }

    for (i = 0; i < 4; i++)
    {
        DWORD TFmt = GetTextureFormat(i);
        DWORD TCtl = GetTextureControl0(i);

        if (((((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8)) &&
            (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl)))) &&
            ((((HW_VAL(SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION, TCtl))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA) ||
             (((HW_VAL(SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION, TCtl))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA) ||
             (((HW_VAL(SET_TEXTURE_CONTROL0, COLOR_KEY_OPERATION, TCtl))) == NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL)))
        {
            DXGRIP("No color-key support for compressed texture formats");
        }
    }

    for (i = 0; i < 4; i++)
    {
        DWORD TFmt = GetTextureFormat(i);
        DWORD TAdr = GetTextureAddress(i);
        DWORD TCtl = GetTextureControl0(i);

        if (((((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G5B5A1) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R4G4B4A4) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_YB8CR8YA8CB8) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FLOAT) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FLOAT) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_A4V6YB6A4U6YA6) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_YB16YA16) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R6G5B5) ||
             (((HW_VAL(SET_TEXTURE_FORMAT, COLOR, TFmt))) == NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8CR8CB8Y8)) &&
            (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl)))) &&
            ((((HW_VAL(SET_TEXTURE_ADDRESS, U, TAdr))) == NV097_SET_TEXTURE_ADDRESS_U_WRAP) || 
             (((HW_VAL(SET_TEXTURE_ADDRESS, U, TAdr))) == NV097_SET_TEXTURE_ADDRESS_U_MIRROR) ||
             (((HW_VAL(SET_TEXTURE_ADDRESS, V, TAdr))) == NV097_SET_TEXTURE_ADDRESS_V_WRAP) || 
             (((HW_VAL(SET_TEXTURE_ADDRESS, V, TAdr))) == NV097_SET_TEXTURE_ADDRESS_V_MIRROR)))
        {
            DXGRIP("No wrap or mirror if texture is a linear format");
        }
    }

    for (i = 0; i < 7; i++)
    {
#if 0
        DWORD OCW = pDevice->m_ColorOCW[i];

        if (((((HW_VAL(SET_COMBINER_COLOR_OCW, BLUETOALPHA_AB, OCW))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE) &&
             (((HW_VAL(SET_COMBINER_ALPHA_OCW, AB_DST, OCW))) > NV097_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0) &&
             (((HW_VAL(SET_COMBINER_ALPHA_OCW, AB_DST, OCW))) == ((HWx(0, SET_COMBINER_COLOR_OCW, AB_DST))))) ||
            ((((HW_VAL(SET_COMBINER_COLOR_OCW, BLUETOALPHA_CD, OCW))) == NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE) &&
             (((HW_VAL(SET_COMBINER_ALPHA_OCW, CD_DST, OCW))) > NV097_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0) &&
             (((HW_VAL(SET_COMBINER_ALPHA_OCW, CD_DST, OCW))) == ((HWx(0, SET_COMBINER_COLOR_OCW, CD_DST))))))
        {
            DXGRIP("Can't have Color OCW combiner and Alpha OCW combiner going to same destination");
        }
#endif
    }

    if (pDevice->m_pPixelShader == NULL)
    {
        return;
    }

    DWORD SOSI = D3D__RenderState[D3DRS_PSINPUTTEXTURE];
    DWORD SSP = GetShaderStageProgram();

    if (((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ST) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP_LUMINANCE) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_AR) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_GB) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT)) &&
        (((((HW_VAL(SET_SHADER_OTHER_STAGE_INPUT, STAGE2, SOSI))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_1) &&
          ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE) ||
           (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT) ||
           (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE))) ||
         ((((HW_VAL(SET_SHADER_OTHER_STAGE_INPUT, STAGE2, SOSI))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_0) &&
          ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE0, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE) ||
           (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE0, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE)))))
    {
        DXGRIP("Need a color in this stage");
    }

    if (((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR) ||
         (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB)) &&
        (((((HW_VAL(SET_SHADER_OTHER_STAGE_INPUT, STAGE3, SOSI))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_2) &&
          ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE) ||
           (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT) ||
           (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE))) ||
         ((((HW_VAL(SET_SHADER_OTHER_STAGE_INPUT, STAGE3, SOSI))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_1) &&
          ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE) ||
           (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT) ||
           (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE))) ||
         ((((HW_VAL(SET_SHADER_OTHER_STAGE_INPUT, STAGE3, SOSI))) == NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_0) &&
          ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE0, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE) ||
           (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE0, SSP))) == NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE)))))
    {
        DXGRIP("Need a color in this stage");
    }

    DWORD TCtl = GetTextureControl0(0);
    if ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE0, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE0, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE0, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE) &&
        (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE))
    {
        DXGRIP("Stage requires a texture but none enabled");
    }

    TCtl = GetTextureControl0(1);
    if ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PASS_THROUGH) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE1, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE) &&
        (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE))
    {
        DXGRIP("Stage requires a texture but none enabled");
    }

    TCtl = GetTextureControl0(2);
    if ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PASS_THROUGH) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE) &&
        (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE))
    {
        DXGRIP("Stage requires a texture but none enabled");
    }

    TCtl = GetTextureControl0(3);
    if ((((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE2, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW) &&
        (((HW_VAL(SET_SHADER_STAGE_PROGRAM, STAGE3, SSP))) != NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE) &&
        (((HW_VAL(SET_TEXTURE_CONTROL0, ENABLE, TCtl))) == NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE))
    {
        DXGRIP("Stage requires a texture but none enabled");
    }
}

#endif // DBG

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\dxgcreate.cpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxgcreate.cpp
 *  Content     Creates the DirectX graphics device object
 *
 ***************************************************************************/
 
#include "precomp.hpp"
#include "dm.h"
#include <xbdm.h>

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

DWORD CDevice::m_PushBufferSize;
DWORD CDevice::m_PushSegmentSize;

//------------------------------------------------------------------------------
// InitializeKelvin
//
// One-time initialization for the kelvin class

VOID InitializeKelvin()
{
    CDevice* pDevice = g_pDevice;

    PPUSH pPush = pDevice->StartPush();

    PushCount(pPush, NV097_SET_CONTEXT_DMA_NOTIFIES, 3);

    // NV097_SET_CONTEXT_DMA_NOTIFIES:

    *(pPush + 1) = NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY; 

    // NV097_SET_CONTEXT_DMA_A:

    *(pPush + 2) = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;

    // NV097_SET_CONTEXT_DMA_B:

    *(pPush + 3) = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;                

    PushCount(pPush + 4, NV097_SET_CONTEXT_DMA_STATE, 6);

    // NV097_SET_CONTEXT_DMA_STATE:

    *(pPush + 5) = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;                

    // NV097_SET_CONTEXT_DMA_COLOR:

    *(pPush + 6) = D3D_COLOR_CONTEXT_DMA_IN_VIDEO_MEMORY;

    // NV097_SET_CONTEXT_DMA_ZETA:

    *(pPush + 7) = D3D_ZETA_CONTEXT_DMA_IN_VIDEO_MEMORY;

    // NV097_SET_CONTEXT_DMA_VERTEX_A:

    *(pPush + 8) = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;

    // NV097_SET_CONTEXT_DMA_VERTEX_B:

    *(pPush + 9) = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY; 

    // NV097_SET_CONTEXT_DMA_SEMAPHORE

    *(pPush + 10 ) = D3D_SEMAPHORE_CONTEXT_DMA_IN_MEMORY;

    PushCount(pPush + 11, NV097_SET_CONTEXT_DMA_REPORT, 1);

    // NV097_SET_CONTEXT_DMA_REPORT:

    *(pPush + 12) = D3D_CONTEXT_IN_CACHED_MEMORY;

    Push1(pPush + 13, NV097_SET_SEMAPHORE_OFFSET, 0);

    pDevice->EndPush(pPush + 15);

    // Set some state that the driver never changes:

    pPush = pDevice->StartPush();

    // D3D always says to take the first vertex color for flat shading:

    Push1(pPush, NV097_SET_FLAT_SHADE_OP, NV097_SET_FLAT_SHADE_OP_V_FIRST_VTX);

    // EXT: ?

    Push4f(pPush + 2, NV097_SET_EYE_POSITION(0), 0.0f, 0.0f, 0.0f, 1.0f);

    // Edge flags are pretty much useless for games, we don't bother exposing
    // this as an extension:

    Push1(pPush + 7, NV097_SET_EDGE_FLAG, NV097_SET_EDGE_FLAG_V_TRUE); 

    // The fixed function pipeline always expects dependent texture 
    // lookups to run between stages i and i+1, so set that now.

    Push1(pPush + 9, 
          NV097_SET_SHADER_OTHER_STAGE_INPUT,
          (DRF_DEF(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE1, _INSTAGE_0) |
           DRF_DEF(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE2, _INSTAGE_1) |
           DRF_DEF(097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE3, _INSTAGE_2)));

    // We never have to disable Z compression:

    Push1(pPush + 11, NV097_SET_COMPRESS_ZBUFFER_EN, TRUE);

    // According to Shaun Ho, "offset clamp has a functional bug. It is 
    // fine to use polygon_offset, but once a polygon is offset, it should 
    // not be clamped."  It should be initialized to positive infinity.

    Push1(pPush + 13, NV097_SET_SHADOW_ZSLOPE_THRESHOLD, F_POS_INFINITY);

    pDevice->EndPush(pPush + 15);

    // Load the fixed function pipeline constant registers and set the
    // texgen planes:

    pDevice->SetShaderConstantMode(D3DSCM_96CONSTANTS);

#if 0

    // Re-enable this snippet to verify that push buffer errors are being
    // reported by the miniport:

    pPush = pDevice->StartPush();
    Push1(pPush,  NV097_SET_WINDOW_CLIP_HORIZONTAL(0), 0xffffffff);

    pDevice->EndPush(pPush + 2);

#endif
}

//------------------------------------------------------------------------------
// InitializeHardware
//
// One-time hardware initialization.  
//
// Initializes the sub-channels to the static set of objects that the driver
// uses, and initializes those classes to the default state.

VOID InitializeHardware()
{
    PPUSH pPush;

    CDevice* pDevice = g_pDevice;

    // Initialize our stock subchannels:

    pPush = pDevice->StartPush();

    Push1(pPush,     SUBCH_MEMCOPY, NV039_SET_OBJECT, D3D_MEMORY_TO_MEMORY_COPY);
    Push1(pPush + 2, SUBCH_RECTCOPY, NV05F_SET_OBJECT, D3D_RECTANGLE_COPY);
    Push1(pPush + 4, SUBCH_RECTCOPYSURFACES, NV062_SET_OBJECT, D3D_RECTANGLE_COPY_SURFACES);
    Push1(pPush + 6, SUBCH_3D, NV097_SET_OBJECT, D3D_KELVIN_PRIMITIVE);
    pPush += 8;

    // Memcpy class.

    Push1(pPush, 
          SUBCH_MEMCOPY, 
          NV039_SET_CONTEXT_DMA_NOTIFIES, 
          D3D_MEMCOPY_NOTIFIER_CONTEXT_DMA_TO_MEMORY);

    // Rectcopy class
    
    Push1(pPush + 2,
          SUBCH_RECTCOPY,
          NV05F_SET_OPERATION,
          NV05F_SET_OPERATION_SRCCOPY);

    // We just initalized our CopyRect operation to SRCCOPY.

    ZeroMemory(&pDevice->m_CopyRectRopState, sizeof(pDevice->m_CopyRectRopState));

    ZeroMemory(&pDevice->m_CopyRectState, sizeof(pDevice->m_CopyRectState));

    pDevice->m_CopyRectState.Operation = D3DCOPYRECT_SRCCOPY;
    pDevice->m_CopyRectState.ColorFormat = D3DCOPYRECT_COLOR_FORMAT_DEFAULT;

    Push2(pPush + 4, 
          SUBCH_RECTCOPYSURFACES, 
          NV062_SET_CONTEXT_DMA_IMAGE_SOURCE, 

          // NV062_SET_CONTEXT_DMA_IMAGE_SOURCE:

          NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,

          // NV062_SET_CONTEXT_DMA_IMAGE_DESTIN:

          D3D_COPY_CONTEXT_DMA_IN_VIDEO_MEMORY);

    pPush += 7;

    PushCount(pPush, SUBCH_RECTCOPY, NV05F_SET_CONTEXT_COLOR_KEY, 7);

    pPush[1] = D3D_NULL_OBJECT;             // NV05F_SET_CONTEXT_COLOR_KEY
    pPush[2] = D3D_NULL_OBJECT;             // NV05F_SET_CONTEXT_CLIP_RECTANGLE
    pPush[3] = D3D_NULL_OBJECT;             // NV05F_SET_CONTEXT_PATTERN
    pPush[4] = D3D_NULL_OBJECT;             // NV05F_SET_CONTEXT_ROP
    pPush[5] = D3D_NULL_OBJECT;             // NV05F_SET_CONTEXT_BETA1
    pPush[6] = D3D_NULL_OBJECT;             // NV05F_SET_CONTEXT_BETA4
    pPush[7] = D3D_RECTANGLE_COPY_SURFACES; // NV05F_SET_CONTEXT_SURFACES

    pDevice->EndPush(pPush + 8);

    // The Kelvin class.

    InitializeKelvin();
}   

//------------------------------------------------------------------------------
// g_InitialRenderStates

D3DCONST DWORD g_InitialRenderStates[] =
{
    D3DCMP_LESSEQUAL,           // D3DRS_ZFUNC                     
    D3DCMP_ALWAYS,              // D3DRS_ALPHAFUNC                 
    FALSE,                      // D3DRS_ALPHABLENDENABLE          
    FALSE,                      // D3DRS_ALPHATESTENABLE           
    0,                          // D3DRS_ALPHAREF                  
    D3DBLEND_ONE,               // D3DRS_SRCBLEND                  
    D3DBLEND_ZERO,              // D3DRS_DESTBLEND                 
    TRUE,                       // D3DRS_ZWRITEENABLE              
    FALSE,                      // D3DRS_DITHERENABLE              
    D3DSHADE_GOURAUD,           // D3DRS_SHADEMODE                 
    D3DCOLORWRITEENABLE_ALL,    // D3DRS_COLORWRITEENABLE          
    D3DSTENCILOP_KEEP,          // D3DRS_STENCILZFAIL              
    D3DSTENCILOP_KEEP,          // D3DRS_STENCILPASS               
    D3DCMP_ALWAYS,              // D3DRS_STENCILFUNC               
    0,                          // D3DRS_STENCILREF                
    0xffffffff,                 // D3DRS_STENCILMASK               
    0xffffffff,                 // D3DRS_STENCILWRITEMASK          
    D3DBLENDOP_ADD,             // D3DRS_BLENDOP                   
    0,                          // D3DRS_BLENDCOLOR                
    D3DSWATH_128,               // D3DRS_SWATHWIDTH                
    0,                          // D3DRS_POLYGONOFFSETZSLOPESCALE  
    0,                          // D3DRS_POLYGONOFFSETZOFFSET      
    FALSE,                      // D3DRS_POINTOFFSETENABLE         
    FALSE,                      // D3DRS_WIREFRAMEOFFSETENABLE     
    FALSE,                      // D3DRS_SOLIDOFFSETENABLE         
    FALSE,                      // D3DRS_FOGENABLE                 
    D3DFOG_NONE,                // D3DRS_FOGTABLEMODE              
    0,                          // D3DRS_FOGSTART                  
    F_ONE,                      // D3DRS_FOGEND                    
    F_ONE,                      // D3DRS_FOGDENSITY                
    FALSE,                      // D3DRS_RANGEFOGENABLE            
    0,                          // D3DRS_WRAP0                     
    0,                          // D3DRS_WRAP1                     
    0,                          // D3DRS_WRAP2                     
    0,                          // D3DRS_WRAP3                     
    TRUE,                       // D3DRS_LIGHTING                  
    FALSE,                      // D3DRS_SPECULARENABLE            
    TRUE,                       // D3DRS_LOCALVIEWER               
    TRUE,                       // D3DRS_COLORVERTEX               
    D3DMCS_COLOR2,              // D3DRS_BACKSPECULARMATERIALSOURCE
    D3DMCS_COLOR1,              // D3DRS_BACKDIFFUSEMATERIALSOURCE 
    D3DMCS_MATERIAL,            // D3DRS_BACKAMBIENTMATERIALSOURCE 
    D3DMCS_MATERIAL,            // D3DRS_BACKEMISSIVEMATERIALSOURCE
    D3DMCS_COLOR2,              // D3DRS_SPECULARMATERIALSOURCE    
    D3DMCS_COLOR1,              // D3DRS_DIFFUSEMATERIALSOURCE     
    D3DMCS_MATERIAL,            // D3DRS_AMBIENTMATERIALSOURCE     
    D3DMCS_MATERIAL,            // D3DRS_EMISSIVEMATERIALSOURCE    
    0,                          // D3DRS_BACKAMBIENT               
    0,                          // D3DRS_AMBIENT                   
    F_ONE,                      // D3DRS_POINTSIZE                 
    0,                          // D3DRS_POINTSIZE_MIN             
    0,                          // D3DRS_POINTSPRITEENABLE         
    0,                          // D3DRS_POINTSCALEENABLE          
    F_ONE,                      // D3DRS_POINTSCALE_A              
    0,                          // D3DRS_POINTSCALE_B              
    0,                          // D3DRS_POINTSCALE_C              
    F_64,                       // D3DRS_POINTSIZE_MAX             
    D3DPATCHEDGE_DISCRETE,      // D3DRS_PATCHEDGESTYLE            
    F_ONE,                      // D3DRS_PATCHSEGMENTS             
    0xdeadbeef,                 // D3DRS_SWAPFILTER (already set)
    0,                          // D3DRS_PSTEXTUREMODES            
    D3DVBF_DISABLE,             // D3DRS_VERTEXBLEND               
    0,                          // D3DRS_FOGCOLOR                  
    D3DFILL_SOLID,              // D3DRS_FILLMODE                  
    D3DFILL_SOLID,              // D3DRS_BACKFILLMODE              
    FALSE,                      // D3DRS_TWOSIDEDLIGHTING          
    FALSE,                      // D3DRS_NORMALIZENORMALS          
    D3DZB_USEW,                 // D3DRS_ZENABLE (gets overwritten later)
    FALSE,                      // D3DRS_STENCILENABLE             
    D3DSTENCILOP_KEEP,          // D3DRS_STENCILFAIL               
    D3DFRONT_CW,                // D3DRS_FRONTFACE                 
    D3DCULL_CCW,                // D3DRS_CULLMODE                  
    0xffffffff,                 // D3DRS_TEXTUREFACTOR             
    0,                          // D3DRS_ZBIAS                     
    D3DLOGICOP_NONE,            // D3DRS_LOGICOP                   
    FALSE,                      // D3DRS_EDGEANTIALIAS             
    TRUE,                       // D3DRS_MULTISAMPLEANTIALIAS      
    0xffffffff,                 // D3DRS_MULTISAMPLEMASK           
    0xdeadbeef,                 // D3DRS_MULTISAMPLEMODE (already set)
    D3DMULTISAMPLEMODE_1X,      // D3DRS_MULTISAMPLEMODERENDERTARGETS
    D3DCMP_NEVER,               // D3DRS_SHADOWFUNC                
    F_ONE,                      // D3DRS_LINEWIDTH                 
    TRUE,                       // D3DRS_DXT1NOISEENABLE
    FALSE,                      // D3DRS_YUVENABLE
    TRUE,                       // D3DRS_OCCLUSIONCULLENABLE
    TRUE,                       // D3DRS_STENCILCULLENABLE
    FALSE,                      // D3DRS_ROPZCMPALWAYSREAD
    FALSE,                      // D3DRS_ROPZREAD
    FALSE,                      // D3DRS_DONOTCULLUNCOMPRESSED
};

//------------------------------------------------------------------------------
// g_InitialTextureStates

D3DCONST BYTE g_InitialTextureStates[] =
{
    D3DTADDRESS_WRAP,           // D3DTSS_ADDRESSU              
    D3DTADDRESS_WRAP,           // D3DTSS_ADDRESSV              
    D3DTADDRESS_WRAP,           // D3DTSS_ADDRESSW              
    D3DTEXF_POINT,              // D3DTSS_MAGFILTER             
    D3DTEXF_POINT,              // D3DTSS_MINFILTER             
    D3DTEXF_NONE,               // D3DTSS_MIPFILTER             
    0,                          // D3DTSS_MIPMAPLODBIAS         
    0,                          // D3DTSS_MAXMIPLEVEL           
    1,                          // D3DTSS_MAXANISOTROPY         
    D3DTCOLORKEYOP_DISABLE,     // D3DTSS_COLORKEYOP            
    0,                          // D3DTSS_COLORSIGN             
    D3DTALPHAKILL_DISABLE,      // D3DTSS_ALPHAKILL             
    D3DTOP_DISABLE,             // D3DTSS_COLOROP (gets overwritten later)
    D3DTA_CURRENT,              // D3DTSS_COLORARG0 
    D3DTA_TEXTURE,              // D3DTSS_COLORARG1             
    D3DTA_CURRENT,              // D3DTSS_COLORARG2             
    D3DTOP_DISABLE,             // D3DTSS_ALPHAOP (gets overwritten later)
    D3DTA_CURRENT,              // D3DTSS_ALPHAARG0             
    D3DTA_TEXTURE,              // D3DTSS_ALPHAARG1             
    D3DTA_CURRENT,              // D3DTSS_ALPHAARG2             
    D3DTA_CURRENT,              // D3DTSS_RESULTARG             
    D3DTTFF_DISABLE,            // D3DTSS_TEXTURETRANSFORMFLAGS 
    0,                          // D3DTSS_BUMPENVMAT00          
    0,                          // D3DTSS_BUMPENVMAT01          
    0,                          // D3DTSS_BUMPENVMAT11          
    0,                          // D3DTSS_BUMPENVMAT10          
    0,                          // D3DTSS_BUMPENVLSCALE         
    0,                          // D3DTSS_BUMPENVLOFFSET        
    0,                          // D3DTSS_TEXCOORDINDEX (gets overwritten later)
    0,                          // D3DTSS_BORDERCOLOR           
    0,                          // D3DTSS_COLORKEYCOLOR         
    0,                          // Unused
};

//------------------------------------------------------------------------------
// InitializeD3dState
//
// Initialize the D3D render, texture, and transform state to the defaults.

VOID InitializeD3dState()
{
    DWORD i;
    DWORD stage;

    CDevice* pDevice = g_pDevice;

    DBG_CHECK(VerifyHeaderFileEncodings());

    // Initialize the transforms.
    //
    // Note that the viewport is handled by the first SetRenderTarget call.

    for (i = 0; i < D3DTS_MAX; i++)
    {
        pDevice->SetTransform((D3DTRANSFORMSTATETYPE) i, &g_IdentityMatrix);
    }

    // Initialize the render states.
    //
    // The pixel shader state does not need to be initialized here.  The 
    // device state is initialized to 0 already and the pixel shader
    // registers don't get loaded until a pixel shader is set as active.

    ASSERT(ARRAYSIZE(g_InitialRenderStates) == (D3DRS_MAX - D3DRS_PS_MAX));

    for (i = D3DRS_PS_MAX; i < D3DRS_MAX; i++)
    {
        // D3DRS_MULTISAMPLEMODE and D3DRS_SWAPFILTER are already 
        // initialized at this point:

        if ((i != D3DRS_MULTISAMPLEMODE) && (i != D3DRS_SWAPFILTER))
        {
            pDevice->SetRenderState((D3DRENDERSTATETYPE) i, 
                                    g_InitialRenderStates[i - D3DRS_PS_MAX]);
        }
    }

    pDevice->SetRenderState(D3DRS_ZENABLE, pDevice->m_pAutoDepthBuffer != NULL); 

    // Initialize the texture stage states.

    ASSERT(ARRAYSIZE(g_InitialTextureStates) == D3DTSS_MAX);

    for (stage = 0; stage < D3DTSS_MAXSTAGES; stage++)
    {
        for (i = 0; i < D3DTSS_MAX; i++)
        {
            pDevice->SetTextureStageState(stage, 
                                          (D3DTEXTURESTAGESTATETYPE) i, 
                                          g_InitialTextureStates[i]);
        }

        pDevice->SetTextureStageState(stage, D3DTSS_TEXCOORDINDEX, stage);
    }

    pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
    pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    pDevice->SetScreenSpaceOffset(0, 0);
}

//------------------------------------------------------------------------------
// CDevice::Init
//
// This is called ONLY by CreateDevice().  It is NOT called by Reset().

extern DWORD g_AvInfo;

#if defined(PROFILE) && !defined(STARTUPANIMATION)

struct PERFCOUNTER
{
    CHAR* Name;
    DWORD Flags;
    VOID* Data;
};

D3DCONST PERFCOUNTER g_PerfCounter[] =
{
    { "(SwPut-HwGet)/PushBufferSize", DMCOUNT_VALUE | DMCOUNT_SYNC, PerfGetPushBufferDistance },
    { "Direct3D contiguous memory allocated", DMCOUNT_VALUE | DMCOUNT_ASYNC32, &D3D__AllocsContiguous },
    { "Direct3D non-contiguous memory allocated", DMCOUNT_VALUE | DMCOUNT_ASYNC32, &D3D__AllocsNoncontiguous }
};

#endif // PROFILE && !STARTUPANIMATION

HRESULT CDevice::Init(
    D3DPRESENT_PARAMETERS *pPresentationParams)
{
    HRESULT hr;
    DWORD i;

    if (DBG_CHECK(true))
    {
        hr = PresentationParametersParameterCheck(pPresentationParams);
        if (FAILED(hr))
            return hr;
    }

    // Calculate the amount of cached contiguous memory we need and allocate
    // it.

    DWORD SemaphoreSize = 32;
    DWORD NotifierSize = sizeof(NvNotification) * 4;  // 2 kelvin, 2 memcpy

    DWORD CachedSize = SemaphoreSize + NotifierSize;

    m_pCachedContiguousMemoryBase = 
        (BYTE *)MmAllocateContiguousMemoryEx(CachedSize,
                                             0,
                                             AGP_APERTURE_BYTES - 1,
                                             0,
                                             PAGE_READWRITE);

    if (!m_pCachedContiguousMemoryBase)
    {
        WARNING("CDevice::Init - unable to allocate notifier memory, Init failed.");
        return E_OUTOFMEMORY;
    }

    // Remember the semaphore location.

    m_pGpuTime = (volatile DWORD *)(m_pCachedContiguousMemoryBase);

    // Set up the notification buffers

    m_pKelvinNotifiers = (volatile NvNotification *)
        ((BYTE *)m_pGpuTime + SemaphoreSize);

    m_pMemCopyNotifiers = m_pKelvinNotifiers + 2;

    memset((void *)m_pKelvinNotifiers, 0, NotifierSize);

    // Initialize the push buffer

    hr = InitializePushBuffer();

    if (FAILED(hr)) 
    {
        return hr;    
    }

    // Make sure the very first DrawPrim initializes all the lazy state:

    D3D__DirtyFlags |= D3DDIRTYFLAG_REALLY_FILTHY;

    // Initialize miniport

    CMiniport* pMiniport = &m_Miniport;
    Nv20ControlDma *pControlDma;

    ULONG HostMemoryBase = 0;
    ULONG HostMemoryLimit = AGP_APERTURE_BYTES - INSTANCE_MEM_MAXSIZE - 1;

    CMiniport::OBJECTINFO InMemoryCtxDma;
    CMiniport::OBJECTINFO FromMemoryCtxDma;
    CMiniport::OBJECTINFO ToMemoryCtxDma;
    CMiniport::OBJECTINFO ColorCtxDma;
    CMiniport::OBJECTINFO ZetaCtxDma;
    CMiniport::OBJECTINFO CopyCtxDma;
    CMiniport::OBJECTINFO NotifierCtxDma;
    CMiniport::OBJECTINFO MemCopyNotifierCtxDma;
    CMiniport::OBJECTINFO CachedMemoryCtxDma;
    CMiniport::OBJECTINFO PusherCtxDma;
    CMiniport::OBJECTINFO SemaphoreCtxDma;
    CMiniport::OBJECTINFO KelvinObj;
    CMiniport::OBJECTINFO MemCopyObj;
    CMiniport::OBJECTINFO RectCopyObj;
    CMiniport::OBJECTINFO RectCopySurfacesObj;
    CMiniport::OBJECTINFO RectCopyPatternObj;
    CMiniport::OBJECTINFO RectCopyColorKeyObj;
    CMiniport::OBJECTINFO RectCopyRopObj;
    CMiniport::OBJECTINFO RectCopyBeta1Obj;
    CMiniport::OBJECTINFO RectCopyBeta4Obj;
    CMiniport::OBJECTINFO RectCopyClipRectangleObj;
    CMiniport::OBJECTINFO RectCopyNullObj;

    pMiniport->InitHardware();

    // Create DMA contexts for video memory

    pMiniport->CreateCtxDmaObject(NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY, 
                                  NV01_CONTEXT_DMA_IN_MEMORY,
                                  (PVOID)HostMemoryBase, 
                                  HostMemoryLimit,
                                  &InMemoryCtxDma);

    pMiniport->CreateCtxDmaObject(NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY, 
                                  NV01_CONTEXT_DMA_FROM_MEMORY,
                                  (PVOID)HostMemoryBase, 
                                  HostMemoryLimit,
                                  &FromMemoryCtxDma);

    pMiniport->CreateCtxDmaObject(NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY, 
                                  NV01_CONTEXT_DMA_TO_MEMORY,
                                  (PVOID)HostMemoryBase, 
                                  HostMemoryLimit,
                                  &ToMemoryCtxDma);

    // Create DMA context for renderable buffers (these will be modified
    // on-the-fly on debug builds):

    pMiniport->CreateCtxDmaObject(D3D_COLOR_CONTEXT_DMA_IN_VIDEO_MEMORY, 
                                  NV01_CONTEXT_DMA_IN_MEMORY,
                                  (PVOID)HostMemoryBase, 
                                  HostMemoryLimit,
                                  &ColorCtxDma);

    m_ColorContextDmaInstance = ColorCtxDma.Instance;

    pMiniport->CreateCtxDmaObject(D3D_ZETA_CONTEXT_DMA_IN_VIDEO_MEMORY,
                                  NV01_CONTEXT_DMA_IN_MEMORY,
                                  (PVOID)HostMemoryBase, 
                                  HostMemoryLimit,
                                  &ZetaCtxDma);

    m_ZetaContextDmaInstance = ZetaCtxDma.Instance;

    pMiniport->CreateCtxDmaObject(D3D_COPY_CONTEXT_DMA_IN_VIDEO_MEMORY, 
                                  NV01_CONTEXT_DMA_IN_MEMORY,
                                  (PVOID)HostMemoryBase, 
                                  HostMemoryLimit,
                                  &CopyCtxDma);

    m_CopyContextDmaInstance = CopyCtxDma.Instance;

    // Create DMA context for notifications

    pMiniport->CreateCtxDmaObject(NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY, 
                                  NV01_CONTEXT_DMA_TO_MEMORY,
                                  (void *)m_pKelvinNotifiers,
                                  (2 * sizeof(NvNotification) - 1),
                                  &NotifierCtxDma);

    // Create DMA context for notifications

    pMiniport->CreateCtxDmaObject(D3D_MEMCOPY_NOTIFIER_CONTEXT_DMA_TO_MEMORY, 
                                  NV01_CONTEXT_DMA_IN_MEMORY,
                                  (void *)m_pMemCopyNotifiers,
                                  (2 * sizeof(NvNotification) - 1),
                                  &MemCopyNotifierCtxDma);

    // Create DMA context for cached memory.

    pMiniport->CreateCtxDmaObject(D3D_CONTEXT_IN_CACHED_MEMORY, 
                                  NV01_CONTEXT_DMA_IN_MEMORY,
                                  (void *)XMETAL_MEMORY_TYPE_CONTIGUOUS,
                                  MM_BYTES_IN_PHYSICAL_MAP,
                                  &CachedMemoryCtxDma);

    // Allocate context DMA for the semaphore

    pMiniport->CreateCtxDmaObject(D3D_SEMAPHORE_CONTEXT_DMA_IN_MEMORY, 
                                  NV01_CONTEXT_DMA_IN_MEMORY,
                                  (PVOID)((void *)m_pGpuTime),
                                  SemaphoreSize,
                                  &SemaphoreCtxDma);

    // Allocate context DMA for the push buffer

    pMiniport->CreateCtxDmaObject(NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY, 
                                  NV01_CONTEXT_DMA_FROM_MEMORY,
                                  (PVOID)HostMemoryBase, 
                                  HostMemoryLimit,
                                  &PusherCtxDma);

    // Initialize the DMA channel

    pMiniport->InitDMAChannel(NV20_CHANNEL_DMA, 
                              NULL, 
                              &PusherCtxDma,
                              0,
                              (PVOID*)&(pControlDma));

    // Bind context DMAs to the channel

    pMiniport->BindToChannel(&PusherCtxDma);
    pMiniport->BindToChannel(&CachedMemoryCtxDma);
    pMiniport->BindToChannel(&NotifierCtxDma);
    pMiniport->BindToChannel(&MemCopyNotifierCtxDma);
    pMiniport->BindToChannel(&ToMemoryCtxDma);
    pMiniport->BindToChannel(&FromMemoryCtxDma);
    pMiniport->BindToChannel(&InMemoryCtxDma);
    pMiniport->BindToChannel(&ColorCtxDma);
    pMiniport->BindToChannel(&ZetaCtxDma);
    pMiniport->BindToChannel(&CopyCtxDma);
    pMiniport->BindToChannel(&SemaphoreCtxDma);

    // Create our various objects

    pMiniport->CreateGrObject(D3D_KELVIN_PRIMITIVE,              NV20_KELVIN_PRIMITIVE,        &KelvinObj);
    pMiniport->CreateGrObject(D3D_MEMORY_TO_MEMORY_COPY,         NV03_MEMORY_TO_MEMORY_FORMAT, &MemCopyObj);
    pMiniport->CreateGrObject(D3D_RECTANGLE_COPY,                NV15_IMAGE_BLIT,              &RectCopyObj);
    pMiniport->CreateGrObject(D3D_RECTANGLE_COPY_SURFACES,       NV10_CONTEXT_SURFACES_2D,     &RectCopySurfacesObj);
    pMiniport->CreateGrObject(D3D_RECTANGLE_COPY_PATTERN,        NV04_CONTEXT_PATTERN,         &RectCopyPatternObj);
    pMiniport->CreateGrObject(D3D_RECTANGLE_COPY_COLOR_KEY,      NV04_CONTEXT_COLOR_KEY,       &RectCopyColorKeyObj);
    pMiniport->CreateGrObject(D3D_RECTANGLE_COPY_ROP,            NV03_CONTEXT_ROP,             &RectCopyRopObj);
    pMiniport->CreateGrObject(D3D_RECTANGLE_COPY_BETA1,          NV01_CONTEXT_BETA,            &RectCopyBeta1Obj);
    pMiniport->CreateGrObject(D3D_RECTANGLE_COPY_BETA4,          NV04_CONTEXT_BETA,            &RectCopyBeta4Obj);
    pMiniport->CreateGrObject(D3D_RECTANGLE_COPY_CLIP_RECTANGLE, NV01_CONTEXT_CLIP_RECTANGLE,  &RectCopyClipRectangleObj);
    pMiniport->CreateGrObject(D3D_NULL_OBJECT,                   NV01_NULL,                    &RectCopyNullObj);

    // Remember the base address.

    m_NvBase = (HWREG *)pMiniport->m_RegisterBase;

    // Use the returned control DMA

    m_pControlDma = pControlDma;

    // This is exported to the DVD player:

    D3D__GpuReg = (volatile DWORD *)m_NvBase;

    // We need to get the control DMA to point to the beginning of
    // our push buffer instead of offset zero in its context DMA
    // (i.e. the beginning of memory).  Slip a jump into the first
    // 4 bytes of memory and run the pusher past it.  This memory
    // is mapped as MmCached, so we have to flush the processor's
    // cache to make this change visible to the GPU.

    PageZero()->m_PushBufferJump = 
        PUSHER_JUMP(GetGPUAddressFromWC((void*) m_pPushBase));

    __asm wbinvd;

    KickOff();

    INITDEADLOCKCHECK();

    while (GetPhysicalOffset((void*) HwGet()) 
        != GetPhysicalOffset((void*) m_Pusher.m_pPut))
    {
        DODEADLOCKCHECK();

        BusyLoop();
    }

    // Of course, the above will hide errors where we inadvertently cause
    // the pusher to jump back to zero.  Whack the memory back to an
    // invalid value (DEADBEEF works great).

    PageZero()->m_PushBufferJump = 0xDEADBEEF;

    // Initialize the hardware, load the classes and set up the push buffer.

    InitializeHardware();

    // Set up the frame buffers

    hr = InitializeFrameBuffers(pPresentationParams);

    if (FAILED(hr))
    {
        return hr;
    }

    pMiniport->SetVideoMode(pPresentationParams->BackBufferWidth, 
                            pPresentationParams->BackBufferHeight,
                            pPresentationParams->FullScreen_RefreshRateInHz,
                            pPresentationParams->Flags,
                            pPresentationParams->BackBufferFormat,
                            pPresentationParams->FullScreen_PresentationInterval,
                            PixelJar::GetPitch(m_pFrameBuffer[1]));

#ifdef STARTUPANIMATION

    DWORD DisplayMode = m_Miniport.m_DisplayMode;
    DWORD Format = m_Miniport.m_Format;
    DWORD Pitch = m_Miniport.m_SurfacePitch;
    void *RegisterBase = m_Miniport.m_RegisterBase;

    ULONG Step = 0;

    do
    {
        Step = AvSetDisplayMode(RegisterBase, Step, DisplayMode, Format, Pitch, NULL);
    }
    while (Step);

#endif

    // Initialize the vertex shader:

    m_pVertexShader = &g_FvfVertexShader;

    SetVertexShader(D3DFVF_XYZ);

    // Initialize the Direct vertex shader object

    ZeroMemory(&g_DirectVertexShader, sizeof(g_DirectVertexShader));
#if DBG
    g_DirectVertexShader.Signature = 'Vshd';
#endif
    g_DirectVertexShader.Flags = VERTEXSHADER_PROGRAM;


    // Set the render target.  

    SetRenderTarget(m_pFrameBuffer[0], m_pAutoDepthBuffer);

    // Initialize the rest of the D3D state to the default.

    InitializeD3dState();

    // Clear the Z and stencil buffers.  We do this mainly to clear stencil
    // to ensure that there's no random bits left in there which may muck
    // up the Z compression.
    //
    // Note that we don't bother with clearing the color buffer.

    Clear(0, NULL, D3DCLEAR_STENCIL | D3DCLEAR_ZBUFFER, 0, 1.0f, 0);

#ifndef STARTUPANIMATION

    // Tell the perf framework about our frame counter.  We use the 
    // VBlankFlipCount because it is incremented only when we do the
    // actual flip, even if the flip happens outside of the 
    // VBlank.

    PDMGD pdmgd = DmGetCurrentDmgd();
    if (pdmgd)
    {
        pdmgd->FrameCounter = &m_Miniport.m_VBlankFlipCount;
        pdmgd->FlipCounter  = &m_SwapCount;
        pdmgd->Surface      = m_pFrameBuffer[1];
        pdmgd->RegisterBase = &m_Miniport.m_RegisterBase;
        pdmgd->pdwOpcode    = &m_dwOpcode;
        pdmgd->ppSnapshotBuffer = (BYTE **)&m_pShaderCaptureBuffer;
    }

#if PROFILE

    for (i = 0; i < ARRAYSIZE(g_PerfCounter); i++)
    {
        DmTell_RegisterPerformanceCounter(g_PerfCounter[i].Name,
                                          g_PerfCounter[i].Flags,
                                          g_PerfCounter[i].Data);
    }

#endif // PROFILE

#endif // !STARTUPANIMATION

    // Reset the flicker filter and soft display filter.

    D3DDevice_SetFlickerFilter(5);
    D3DDevice_SetSoftDisplayFilter(FALSE);

    return S_OK;
} 

//------------------------------------------------------------------------------
// CDevice::UnInit

VOID CDevice::UnInit()
{
    DWORD i;

    ASSERT(!(m_StateFlags & (STATE_RECORDPUSHBUFFER)));

    if (m_Pusher.m_pPut)
    {
        // Make sure that the GPU has processed everything except for
        // this final little bit.  Otherwise the KickOffAndWaitForIdle
        // code will get confused by the jump back to the beginning.
    
        KickOffAndWaitForIdle();
    
        // Point GPU to the start of the push buffer so we can reset the push
        // buffer member variables in the next Init.
    
        *m_Pusher.m_pPut = PUSHER_JUMP(GetGPUAddressFromWC((void*) m_pPushBase));
    
        m_Pusher.m_pPut = m_pPushBase;
    
        KickOff();
    
        // We need to wait until the hardware is idle before we can destroy the
        // device.
    
        INITDEADLOCKCHECK();

        while (GetPhysicalOffset((void*) HwGet()) 
            != GetPhysicalOffset((void*) m_pPushBase))
        {
            BusyLoop();
        
            DODEADLOCKCHECK();
        }
    }

    // Wait for any last synchronized flip to get processed, in order to
    // make sure that the final frame is displayed, and so that the flip
    // synchronization code doesn't get messed up by the INCREMENT_READ_3D
    // done at the Vblank interrupt.

    while (m_Miniport.IsFlipPending())
        ;

#if PROFILE
    // Tell the perf framework that our frame counter is gone.

    PDMGD pdmgd = DmGetCurrentDmgd();
    if (pdmgd)
    {
        pdmgd->FrameCounter = NULL;
        pdmgd->FlipCounter  = NULL;
        pdmgd->Surface      = NULL;
    }

#ifndef STARTUPANIMATION

    for (i = 0; i < ARRAYSIZE(g_PerfCounter); i++)
    {
        DmTell_UnregisterPerformanceCounter(g_PerfCounter[i].Name);
    }

#endif // !STARTUPANIMATION

#endif // PROFILE

    // First, free all stuff that would also be freed if we did a Reset()
    // call:

    FreeFrameBuffers();

    // FreeFrameBuffers() should take care of the following:

    ASSERT((m_pRenderTarget == NULL) && (m_pZBuffer == NULL));

    // Free all the other referenced objects:

    UninitializePushBuffer();

    if (m_pIndexBuffer)
    {
        InternalRelease(m_pIndexBuffer);
    }

    for (i = 0; i < D3DTSS_MAXSTAGES; i++)
    {
        if (m_Textures[i])
        {
            InternalRelease(m_Textures[i]);
        }
        if (m_Palettes[i])
        {
            InternalRelease(m_Palettes[i]);
        }
    }

    for (i = 0; i < 16; i++)
    {
        if (g_Stream[i].pVertexBuffer)
        {
            InternalRelease(g_Stream[i].pVertexBuffer);
        }
    }

    for (i = 0; i < REPORTS_ALLOCATIONS_MAX; i++)
    {
        if (m_ReportAllocations[i])
        {
            MmFreeContiguousMemory(m_ReportAllocations[i]);
        }
    }

    if (m_pCachedContiguousMemoryBase)
    {
        MmFreeContiguousMemory(m_pCachedContiguousMemoryBase);
    }

    if (m_pLights)
    {
        MemFree(m_pLights);
    }

    // Disable interrupts and shutdown engines

    if (m_Miniport.m_RegisterBase)
    {
        m_Miniport.DisableInterrupts(m_Miniport.m_RegisterBase);
        m_Miniport.ShutdownEngines();
    }

    // Zero-initialize g_Stream for next time.  

    ZeroMemory(&g_Stream, sizeof(g_Stream));
}

//------------------------------------------------------------------------------
// Frees the frame and back buffers
//
// This can get called at either 'Init' or 'Reset' time. 

VOID CDevice::FreeFrameBuffers()
{
    DWORD i;

    if (!AvGetSavedDataAddress())
    {
        AvSendTVEncoderOption(m_Miniport.m_RegisterBase, 
                              AV_OPTION_BLANK_SCREEN, 
                              TRUE, 
                              NULL);
    }

    if (m_pRenderTarget)
    {
        RecordSurfaceWritePush(m_pRenderTarget);
        InternalReleaseSurface(m_pRenderTarget);
        m_pRenderTarget = NULL;
    }

    if (m_pZBuffer)
    {
        RecordSurfaceWritePush(m_pZBuffer);
        InternalReleaseSurface(m_pZBuffer);
        m_pZBuffer = NULL;
    }

    for (i = 0; i < m_FrameBufferCount; i++)
    {
        m_pFrameBuffer[i]->Release();
        m_pFrameBuffer[i] = NULL;
    }

    if (m_pAutoDepthBuffer != NULL)
    {
        m_pAutoDepthBuffer->Release();
        m_pAutoDepthBuffer = NULL;
    }

    if (m_pAutoDepthBufferBase)
    {
        SetTile(TILE_ZBUFFER, NULL);

        FreeContiguousMemory(m_pAutoDepthBufferBase);
        m_pAutoDepthBufferBase = NULL;
    }

    if (m_pFrameBufferBase)
    {
        SetTile(TILE_FRAMEBUFFER, NULL);

        FreeContiguousMemory(m_pFrameBufferBase);
        m_pFrameBufferBase = NULL;
    }

    if (m_pAntiAliasBufferBase)
    {
        FreeContiguousMemory(m_pAntiAliasBufferBase);
        m_pAntiAliasBufferBase = NULL;
    }
}

//------------------------------------------------------------------------------
// PresentationParametersParameterCheck

HRESULT PresentationParametersParameterCheck(
    D3DPRESENT_PARAMETERS* pPresentationParams)
{
    DWORD i;

    DWORD sampleType = pPresentationParams->MultiSampleType;
    if ((sampleType != D3DMULTISAMPLE_NONE) && (sampleType != 0))
    {
        if ((sampleType & ANTIALIAS_FORMAT_MASK) > 
                            D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8)
        {
            DPF_ERR("Invalid D3DMULTISAMPLE_PREFILTER_FORMAT type");
            return D3DERR_INVALIDCALL;
        }

        if (!(sampleType & ANTIALIAS_ACTIVE) &&
            (sampleType & ANTIALIAS_FORMAT_MASK))
        {
            DPF_ERR("Can't specifcy D3DMULTISAMPLE_PREFILTER_FORMAT if not "
                    "antialiasing");
            return D3DERR_INVALIDCALL;
        }

        if ((ANTIALIAS_XSCALE(sampleType) < 1) ||
            (ANTIALIAS_YSCALE(sampleType) < 1) ||
            (ANTIALIAS_XSCALE(sampleType) > 3) ||
            (ANTIALIAS_YSCALE(sampleType) > 3))
        {
            DPF_ERR("Improper D3DMULTISAMPLE scale encoding");
            return D3DERR_INVALIDCALL;
        }
    }

    if ((pPresentationParams->FullScreen_PresentationInterval &
         ~D3DPRESENT_INTERVAL_IMMEDIATE) > D3DPRESENT_INTERVAL_TWO)
    {
        DPF_ERR("Invalid FullScreen_PresentationInterval value");
        return D3DERR_INVALIDCALL;
    }

    if (pPresentationParams->FullScreen_RefreshRateInHz != 0
        && pPresentationParams->FullScreen_RefreshRateInHz != 50
        && pPresentationParams->FullScreen_RefreshRateInHz != 60)
    {
        DPF_ERR("FullScreen_RefreshRateInHz must be zero, 50 or 60");
    }

    if (pPresentationParams->SwapEffect != D3DSWAPEFFECT_DISCARD &&
        pPresentationParams->SwapEffect != D3DSWAPEFFECT_FLIP &&
        pPresentationParams->SwapEffect != D3DSWAPEFFECT_COPY &&
        pPresentationParams->SwapEffect != 0)
    {
        DPF_ERR("Invalid SwapEffect value");
        return D3DERR_INVALIDCALL;
    }

    if (pPresentationParams->BackBufferCount > 2)
    {
        DPF_ERR("No point in more than 2 back buffers, due to throttling");
        return D3DERR_INVALIDCALL;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Creates the frame and back buffers.
//
// Note: This expects Kelvin to have been initialized.

HRESULT CDevice::InitializeFrameBuffers(
    D3DPRESENT_PARAMETERS* pPresentationParams)
{
    DWORD format;
    DWORD size;
    D3DTILE tile;
    DWORD i;

    // A 'BackBufferCount' of zero is to be treated as one:

    DWORD backBufferCount = max(1, pPresentationParams->BackBufferCount);

    // Map any swizzled frame buffer formats to their linear equivalent.  
    // This is a concession to how people use D3D today even though it is a
    // lie in this driver.

    D3DFORMAT postfilterFormat 
        = MapToLinearD3DFORMAT(pPresentationParams->BackBufferFormat);

    D3DFORMAT autoDepthStencilFormat
        = MapToLinearD3DFORMAT(pPresentationParams->AutoDepthStencilFormat);

    DWORD backBufferWidth = pPresentationParams->BackBufferWidth;

    DWORD backBufferHeight = pPresentationParams->BackBufferHeight;

    // Save some other state:

    m_PresentationInterval = pPresentationParams->FullScreen_PresentationInterval;

    m_SwapEffect = pPresentationParams->SwapEffect;

    m_FrameBufferCount = backBufferCount + 1;

    // This routine can get called on Reset(), so clear here any flags that
    // we might set in this routine:

    m_StateFlags &= ~STATE_COPYSWAP;

    // We treat 'D3DSWAPEFFECT_COPY' as 1x antialiasing:

    BOOL doAntiAlias = FALSE;

    if ((pPresentationParams->MultiSampleType & ANTIALIAS_ACTIVE) ||
        (pPresentationParams->SwapEffect == D3DSWAPEFFECT_COPY))
    {
        doAntiAlias = TRUE;
        m_StateFlags |= STATE_COPYSWAP;
    }

    DWORD presentSampleType = pPresentationParams->MultiSampleType;
    if (presentSampleType == 0)
        presentSampleType = ANTIALIAS_NONE;

    m_MultiSampleType = presentSampleType;

    DWORD xScale = ANTIALIAS_XSCALE(presentSampleType);
    DWORD yScale = ANTIALIAS_YSCALE(presentSampleType);

    m_AntiAliasScaleX = (FLOAT) xScale;
    m_AntiAliasScaleY = (FLOAT) yScale;

    // Set some render states that are dependent on the presentation
    // parameters:

    DWORD typeRenderState = D3DMULTISAMPLEMODE_1X;
    if (presentSampleType & ANTIALIAS_MULTISAMPLE)
    {
        typeRenderState = D3DMULTISAMPLEMODE_4X;
        if ((presentSampleType & ANTIALIAS_SCALE_MASK) == 0x21)
        {
            typeRenderState = D3DMULTISAMPLEMODE_2X;
        }
    }

    DWORD filterRenderState = D3DTEXF_LINEAR;
    if (presentSampleType & ANTIALIAS_QUINCUNX)
        filterRenderState = D3DTEXF_QUINCUNX;
    else if (presentSampleType & ANTIALIAS_GAUSSIAN)
        filterRenderState = D3DTEXF_GAUSSIANCUBIC;

    D3D__RenderState[D3DRS_MULTISAMPLEMODE] = typeRenderState;
    D3D__RenderState[D3DRS_SWAPFILTER] = filterRenderState;

    if (pPresentationParams->BufferSurfaces[0] != NULL)
    {
        // The caller has chosen to pre-create their own color- and Z-buffers.
        //
        // Note that we'll eventually call SetRenderTarget, which does more
        // validation than what we do here.

        if (DBG_CHECK(TRUE))
        {
            if ((pPresentationParams->BufferSurfaces[1] == NULL) ||
                (pPresentationParams->BufferSurfaces[backBufferCount] == NULL))
            {
                DPF_ERR("Unexpected NULL BufferSurfaces surface");
            }
            for (i = doAntiAlias; i < backBufferCount; i++)
            {
                if (pPresentationParams->BufferSurfaces[i]->Size !=
                    pPresentationParams->BufferSurfaces[i+1]->Size)
                {
                    DPF_ERR("Not all BufferSurfaces have same dimension or "
                            "stride");
                }
                if (pPresentationParams->BufferSurfaces[i]->Format !=
                    pPresentationParams->BufferSurfaces[i+1]->Format)
                {
                    DPF_ERR("Not all BufferSurfaces have same format");
                }
            }
            if (PixelJar::GetFormat(pPresentationParams->BufferSurfaces[1])
                 != pPresentationParams->BackBufferFormat)
            {
                DPF_ERR("Unexpected mistmatch between BufferSurfaces and "
                        "BackBufferFormat (make sure BackBufferFormat\n"
                        "is correct)");
            }
            if ((PixelJar::GetWidth(pPresentationParams->BufferSurfaces[1])
                 < pPresentationParams->BackBufferWidth) ||
                (PixelJar::GetHeight(pPresentationParams->BufferSurfaces[1])
                 < pPresentationParams->BackBufferHeight))
            {
                DPF_ERR("Front-buffer surfaces must be at least as large "
                        "as BackBufferWidth/Height");
            }
            if (pPresentationParams->DepthStencilSurface)
            {
                if ((PixelJar::GetWidth(pPresentationParams->BufferSurfaces[0]) >
                     PixelJar::GetWidth(pPresentationParams->DepthStencilSurface)) ||
                    (PixelJar::GetHeight(pPresentationParams->BufferSurfaces[0]) >
                     PixelJar::GetHeight(pPresentationParams->DepthStencilSurface)))
                {
                    DPF_ERR("DepthStencilSurface must be at least as big as "
                            "BufferSurfaces");
                }
            }
        }

        // Initialize our pointers to the specified surfaces.  We'll add
        // reference counts in a bit...

        for (i = 0; i < backBufferCount + 1; i++)
        {
            m_BufferSurfaces[i] = *pPresentationParams->BufferSurfaces[i];
            m_pFrameBuffer[i] = &m_BufferSurfaces[i];
        }
        if (pPresentationParams->DepthStencilSurface != NULL)
        {
            m_DepthStencilSurface = *pPresentationParams->DepthStencilSurface;
            m_pAutoDepthBuffer = &m_DepthStencilSurface;
        }
    }
    else
    {
        // We have to allocate the buffers ourselves.

        // The caller can override the format of the pre-filter buffer, which
        // defaults to the same format as the post-filter buffer:
    
        D3DFORMAT prefilterFormat = postfilterFormat;
    
        switch (pPresentationParams->MultiSampleType & ANTIALIAS_FORMAT_MASK)
        {
        case D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5:
            prefilterFormat = D3DFMT_LIN_X1R5G5B5;
            break;
    
        case D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5:
            prefilterFormat = D3DFMT_LIN_R5G6B5;
            break;
    
        case D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8:
            prefilterFormat = D3DFMT_LIN_X8R8G8B8;
            break;
    
        case D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8:
            prefilterFormat = D3DFMT_LIN_A8R8G8B8;
            break;
        }
    
        DWORD width = xScale * backBufferWidth;
        DWORD height = yScale * backBufferHeight;
        DWORD pitch = CalcTilePitch(width, prefilterFormat);
    
        // Allocate the memory for our frame buffer and set up the frame-/back-
        // buffer surfaces.
    
        DWORD frameSize = PixelJar::EncodeFormat(width,
                                                 height,
                                                 1,          // Depth
                                                 1,          // Levels
                                                 prefilterFormat,
                                                 pitch,
                                                 false,      // isCubeMap
                                                 false,      // isVolume
                                                 &format,
                                                 &size);
    
        // Create only one buffer at the expanded, pre-filter size:
    
        DWORD frameCount = (doAntiAlias) ? 1 : (backBufferCount + 1);
            
        // The large 0x200 pitch alignment we gave to EncodeFormat should 
        // ensure that all surfaces are aligned to a 128 byte boundary:
    
        ASSERT((frameSize & (D3D_RENDER_MEMORY_ALIGNMENT - 1)) == 0);
    
        DWORD allocationSize = frameSize * frameCount;
    
        // Size must aligned on D3D_TILED_SURFACE_ALIGNMENT boundary as well.
    
        allocationSize = (allocationSize + D3D_TILED_SURFACE_ALIGNMENT - 1) 
                       & ~(D3D_TILED_SURFACE_ALIGNMENT - 1);
    
        BYTE* pFrame = (BYTE*) AllocateContiguousMemory(allocationSize,
                                                        D3D_TILED_SURFACE_ALIGNMENT);
        if (!pFrame)
        {
            WARNING("InitializeFrameBuffers - unable to allocate pre-filter buffer");
            return E_OUTOFMEMORY;
        }
    
        m_pFrameBufferBase = pFrame;
    
        for (i = 0; i < frameCount; i++)
        {
            m_pFrameBuffer[i] = &m_BufferSurfaces[i];

            InitializeSurface(m_pFrameBuffer[i], format, size, pFrame);
    
            pFrame += frameSize;
        }
    
        if (width != 1920)
        {
            tile.Flags = 0;
            tile.pMemory = m_pFrameBufferBase;
            tile.Size = allocationSize;
            tile.Pitch = PixelJar::GetPitch(m_pFrameBuffer[0]);
        
            SetTile(TILE_FRAMEBUFFER, &tile);
        }

        // Okay, now create the smaller, post-filter buffers.  Note that we
        // don't waste tiles on these, since they're only used once per frame
        // and they have different strides from the pre-filter buffer (although
        // they could be packed together...)

        if (doAntiAlias)
        {
            frameSize = PixelJar::EncodeFormat(backBufferWidth,
                                               backBufferHeight,
                                               1,          // Depth
                                               1,          // Levels
                                               postfilterFormat,
                                               0,
                                               false,      // isCubeMap
                                               false,      // isVolume
                                               &format,
                                               &size);

            // The large 0x200 pitch alignment we gave to EncodeFormat should 
            // ensure that all surfaces are aligned to a 128 byte boundary:

            ASSERT((frameSize & (D3D_RENDER_MEMORY_ALIGNMENT - 1)) == 0);

            DWORD allocationSize = frameSize * backBufferCount;

            // Note that we're not locating the antialiasing back buffers in 
            // a tile, so it doesn't need the more austere tile alignment 
            // restriction:

            BYTE *pFrame = (BYTE *)AllocateContiguousMemory(allocationSize,
                                                            D3D_TILED_SURFACE_ALIGNMENT);
            if (!pFrame)
            {
                WARNING("InitializeFrameBuffers - unable to allocate pre-filter buffer");
                return E_OUTOFMEMORY;
            }

            m_pAntiAliasBufferBase = pFrame;

            for (i = 1; i <= backBufferCount; i++)
            {
                m_pFrameBuffer[i] = &m_BufferSurfaces[i];

                InitializeSurface(m_pFrameBuffer[i], format, size, pFrame);

                pFrame += frameSize;
            }
        }

        // Set up the memory/surface for the auto-stencil buffer.
    
        if (pPresentationParams->EnableAutoDepthStencil)
        {
            pitch = CalcTilePitch(width, autoDepthStencilFormat);
    
            DWORD depthSize = PixelJar::EncodeFormat(width,
                                                     height,
                                                     1,
                                                     1,
                                                     autoDepthStencilFormat,
                                                     pitch,
                                                     false, 
                                                     false,
                                                     &format,
                                                     &size);
    
            depthSize = (depthSize + D3D_TILED_SURFACE_ALIGNMENT - 1) 
                      & ~(D3D_TILED_SURFACE_ALIGNMENT - 1);
    
            BYTE *pDepthBuffer 
                = (BYTE *)AllocateContiguousMemory(depthSize, 
                                                   D3D_TILED_SURFACE_ALIGNMENT);
    
            if (!pDepthBuffer)
            {
                WARNING("InitializeFrameBuffers - unable to allocate Z buffer");
                return E_OUTOFMEMORY;
            }
    
            m_pAutoDepthBufferBase = pDepthBuffer;

            m_pAutoDepthBuffer = &m_DepthStencilSurface;
    
            InitializeSurface(m_pAutoDepthBuffer, format, size, pDepthBuffer);
    
            // For the default auto-created depth buffer, we always automatically
            // create a compressed Z-buffer tile.  We also always start it at
            // tag 'zero'.  It's the caller's responsibility, if they're using
            // SetTile, to ensure that they've left enough tag bits starting at
            // zero if they Reset into a new mode.
    
            if (width != 1920)
            {
                tile.Flags = D3DTILE_FLAGS_ZBUFFER | D3DTILE_FLAGS_ZCOMPRESS;
                tile.pMemory = pDepthBuffer;
                tile.Size = depthSize;
                tile.Pitch = PixelJar::GetPitch(m_pAutoDepthBuffer);
                tile.ZOffset = 0;
                tile.ZStartTag = 0;
    
                if (BitsPerPixelOfD3DFORMAT(autoDepthStencilFormat) == 32)
                {
                    tile.Flags |= D3DTILE_FLAGS_Z32BITS;
                }
    
                SetTile(TILE_ZBUFFER, &tile);
            }
        }
    }

    // For surfaces supplied by the title, make sure we have a reference count 
    // on each:

    for (i = 0; i < m_FrameBufferCount; i++)
    {
        m_pFrameBuffer[i]->AddRef();
    }

    if (m_pAutoDepthBuffer != NULL)
    {
        m_pAutoDepthBuffer->AddRef();
    }

    PPUSH pPush = StartPush();

    // Inialize flip read/write values.  
    //
    // Set NV097_SET_FLIP_READ, NV097_SET_FLIP_WRITE, and NV097_SET_FLIP_MODULO
    // all in one call:

    Push3(pPush, NV097_SET_FLIP_READ, 0, 1, m_FrameBufferCount);

    EndPush(pPush + 4);

    return S_OK;
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\enum.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.hpp
 *  Content:    Class for the enumerator object.
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

class CEnum : public Direct3D
{
public:

    D3DFORMAT MapUnknownFormat(
        UINT         iAdapter,
        DWORD        Usage,
        D3DFORMAT    Format,
        D3DDEVTYPE   Type,
        D3DFORMAT    DisplayFormat) const;
}; 


} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\enum.cpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.cpp
 *  Content     Handles all of the enum functions for determing what device
 *              you want before you go there.
 *
 ***************************************************************************/
 
#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

D3DCONST D3DADAPTER_IDENTIFIER8 g_AdapterIdentifier = 
{
    "Xbox driver",
    "Xbox NV2A",
    D3D_SDK_VERSION
};

//------------------------------------------------------------------------------
// CheckDisplayFormat
//

inline BOOL CheckDisplayFormat(D3DFORMAT format)
{
    return IsValidRenderTargetD3DFORMAT(format);
}

//------------------------------------------------------------------------------
// Direct3DCreate8
//
// DLL exposed Creation function

extern "C"
Direct3D * WINAPI Direct3DCreate8(
    UINT SDKVersion)
{
    if (DBG_CHECK(SDKVersion != D3D_SDK_VERSION))
    {
        DXGRIP("\nD3D ERROR: This application compiled against improper D3D headers.\n"
             "D3D_SDK_VERSION is (%d) but should be (%d).\n"
             "Please recompile with an up-to-date SDK.\n\n",
           SDKVersion, D3D_SDK_VERSION);

        return NULL;
    }

    // This pointer is never used for anything, but we can't return 
    // NULL because that means this API failed.  Just return something
    // simple.
    //
    return (Direct3D *)(1);
} 

//------------------------------------------------------------------------------
// Direct3D_GetAdapterIdentifier

extern "C"
HRESULT WINAPI Direct3D_GetAdapterIdentifier(
    UINT Adapter,
    DWORD Flags,
    D3DADAPTER_IDENTIFIER8* pIdentifier) 
{ 
    COUNT_API(API_DIRECT3D_GETADAPTERIDENTIFIER);

    if (Adapter != 0)
    {
        return D3DERR_INVALIDCALL;
    }

    *pIdentifier = g_AdapterIdentifier;

    return S_OK;
}

//------------------------------------------------------------------------------
// Direct3D_GetAdapterModeCount

extern "C"
UINT WINAPI Direct3D_GetAdapterModeCount(
    UINT Adapter) 
{ 
    COUNT_API(API_DIRECT3D_GETADAPTERMODECOUNT);

    UINT Count = 0;

    const DISPLAYMODE *pMode = GetTableForCurrentAvInfo();

    DWORD SystemAvInfo = CMiniport::GetDisplayCapabilities();

    ULONG ModeAvPack    = pMode->AvInfo & AV_PACK_MASK;
    ULONG AvPack        = SystemAvInfo & AV_PACK_MASK;
    ULONG AvStandard    = SystemAvInfo & AV_STANDARD_MASK;
    ULONG AvRefresh     = SystemAvInfo & AV_REFRESH_MASK;
    ULONG AvHDTVModes   = SystemAvInfo & AV_HDTV_MODE_MASK;

    // Count the modes that meet our requirements.
    for (;; pMode++)
    {
        // Did we leave this AV pack?
        if ((pMode->AvInfo & AV_PACK_MASK) != ModeAvPack)
        {
            break;
        }

        // Throw away widescreen if we don't support it unless this is an 
        // HDTV mode that has implied widescreen support.
        //
        if ((AvPack != AV_PACK_HDTV || !(pMode->AvInfo & (AV_FLAGS_HDTV_720p | AV_FLAGS_HDTV_1080i)))
            && (pMode->AvInfo & AV_FLAGS_WIDESCREEN)
            && !(SystemAvInfo & AV_FLAGS_WIDESCREEN))
        {
            continue;
        }

        // Throw away any mode that uses a refresh rate the display doesn't
        // support.
        //
        if (!(pMode->AvInfo & AvRefresh))
        {
            continue;
        }

        // Throw away any HDTV mode that this display does not
        // support.
        //
        if (AvPack == AV_PACK_HDTV
            && !(pMode->AvInfo & AvHDTVModes)
            && (pMode->AvInfo & AV_HDTV_MODE_MASK) != 0)
        {
            continue;
        }

        Count++;        
    }

    // There are 4 valid formats for each mode.
    return Count * 4;
}

//------------------------------------------------------------------------------
// Direct3D_EnumAdapterModes

extern "C"
HRESULT WINAPI Direct3D_EnumAdapterModes(
    UINT Adapter,
    UINT Mode,
    D3DDISPLAYMODE* pModeRet) 
{ 
    COUNT_API(API_DIRECT3D_ENUMADAPTERMODES);

    DWORD Format = Mode % 4;
    Mode /= 4;

    const DISPLAYMODE *pMode = GetTableForCurrentAvInfo();

    DWORD SystemAvInfo = CMiniport::GetDisplayCapabilities();

    ULONG ModeAvPack    = pMode->AvInfo & AV_PACK_MASK;
    ULONG AvPack        = SystemAvInfo & AV_PACK_MASK;
    ULONG AvStandard    = SystemAvInfo & AV_STANDARD_MASK;
    ULONG AvRefresh     = SystemAvInfo & AV_REFRESH_MASK;
    ULONG AvHDTVModes   = SystemAvInfo & AV_HDTV_MODE_MASK;

    // Find the requested mode.
    for (;; pMode++)
    {
        // Did we leave this AV pack?
        if ((pMode->AvInfo & AV_PACK_MASK) != ModeAvPack)
        {
            DXGRIP(("Direct3D_EnumAdapterModes - Bad mode index."));
            return D3DERR_INVALIDCALL;
        }

        // Throw away widescreen if we don't support it unless this is an 
        // HDTV mode that has implied widescreen support.
        //
        if ((AvPack != AV_PACK_HDTV || !(pMode->AvInfo & (AV_FLAGS_HDTV_720p | AV_FLAGS_HDTV_1080i)))
            && (pMode->AvInfo & AV_FLAGS_WIDESCREEN)
            && !(SystemAvInfo & AV_FLAGS_WIDESCREEN))
        {
            continue;
        }

        // Throw away any mode that uses a refresh rate the display doesn't
        // support.
        //
        if (!(pMode->AvInfo & AvRefresh))
        {
            continue;
        }

        // Throw away any HDTV mode that this display does not
        // support.
        //
        if (AvPack == AV_PACK_HDTV
            && !(pMode->AvInfo & AvHDTVModes)
            && (pMode->AvInfo & AV_HDTV_MODE_MASK) != 0)
        {
            continue;
        }

        if (!Mode--)
        {
            pModeRet->Width = pMode->Width;
            pModeRet->Height = pMode->Height;
            pModeRet->RefreshRate = (pMode->AvInfo & AV_FLAGS_60Hz) ? 60 : 50;
            pModeRet->Flags = CMiniport::GetPresentFlagsFromAvInfo(pMode->AvInfo);
            
            switch(Format)
            {
            case 0:
                pModeRet->Format = D3DFMT_LIN_X8R8G8B8;
                break;

            case 1:
                pModeRet->Format = D3DFMT_LIN_R5G6B5;
                break;

            case 2:
                pModeRet->Format = D3DFMT_LIN_X1R5G5B5;
                break;

            case 3:
                pModeRet->Format = D3DFMT_LIN_A8R8G8B8;
                break;
            }

            return S_OK;
        }
    }
}

//------------------------------------------------------------------------------
// Direct3D_GetAdapterDisplayMode

extern "C"
HRESULT WINAPI Direct3D_GetAdapterDisplayMode(
    UINT Adapter,
    D3DDISPLAYMODE* pMode) 
{ 
    COUNT_API(API_DIRECT3D_GETADAPTERDISPLAYMODE);

    if (Adapter != 0)
    {
        return D3DERR_INVALIDCALL;
    }

    CDevice *pDevice = g_pDevice;

    if (pDevice == NULL)
    {
        ZeroMemory(pMode, sizeof(*pMode));
    }
    else
    {
        pMode->Width = PixelJar::GetWidth(pDevice->m_pFrameBuffer[1]);
        pMode->Height = PixelJar::GetHeight(pDevice->m_pFrameBuffer[1]);
        pMode->RefreshRate = pDevice->m_Miniport.GetRefreshRate();
        pMode->Format = DecodeD3DFORMAT(pDevice->m_pFrameBuffer[1]->Format);
        pMode->Flags = CMiniport::GetPresentFlagsFromAvInfo(pDevice->m_Miniport.m_CurrentAvInfo);
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Direct3D_CheckDeviceType

extern "C"
HRESULT WINAPI Direct3D_CheckDeviceType(
    UINT Adapter, 
    D3DDEVTYPE CheckType, 
    D3DFORMAT DisplayFormat, 
    D3DFORMAT BackBufferFormat, 
    BOOL Windowed)
{ 
    COUNT_API(API_DIRECT3D_CHECKDEVICETYPE);

    if (Adapter != 0)
    {
        return D3DERR_INVALIDCALL;
    }

    if (CheckType != D3DDEVTYPE_HAL)
    {
        return D3DERR_INVALIDDEVICE;
    }

    if (Windowed == TRUE)
    {
        return D3DERR_NOTAVAILABLE;
    }

    if (!CheckDisplayFormat(DisplayFormat))
    {
        return D3DERR_NOTAVAILABLE;
    }

    if (!CheckDisplayFormat(BackBufferFormat))
    {
        return D3DERR_NOTAVAILABLE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Direct3D_CheckDeviceFormat

extern "C"
HRESULT WINAPI Direct3D_CheckDeviceFormat(
    UINT Adapter,
    D3DDEVTYPE DeviceType,
    D3DFORMAT AdapterFormat,
    DWORD Usage,
    D3DRESOURCETYPE RType,
    D3DFORMAT CheckFormat) 
{ 
    COUNT_API(API_DIRECT3D_CHECKDEVICEFORMAT);

    if (Adapter != 0)
    {
        return D3DERR_INVALIDCALL;
    }

    if (DeviceType != D3DDEVTYPE_HAL)
    {
        return D3DERR_INVALIDDEVICE;
    }

    if (!CheckDisplayFormat(AdapterFormat))
    {
        return D3DERR_NOTAVAILABLE;
    }

    if (Usage & D3DUSAGE_DEPTHSTENCIL)
    {
        if (!IsValidDepthBufferD3DFORMAT(CheckFormat))
        {
            return D3DERR_NOTAVAILABLE;
        }
    }
    else if (Usage & D3DUSAGE_RENDERTARGET)
    {
        if (!CheckDisplayFormat(CheckFormat))
        {
            return D3DERR_NOTAVAILABLE;
        }
    }
    else
    {
        if (BitsPerPixelOfD3DFORMAT(CheckFormat) == 0)
        {
            return D3DERR_NOTAVAILABLE;
        }
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Direct3D_CheckDeviceMultiSampleType

extern "C"
HRESULT WINAPI Direct3D_CheckDeviceMultiSampleType(
    UINT Adapter,
    D3DDEVTYPE DeviceType,
    D3DFORMAT RenderTargetFormat,
    BOOL Windowed,
    D3DMULTISAMPLE_TYPE MultiSampleType) 
{ 
    COUNT_API(API_DIRECT3D_CHECKDEVICEMULTISAMPLETYPE);

    if (Adapter != 0)
    {
        return D3DERR_INVALIDCALL;
    }

    if (DeviceType != D3DDEVTYPE_HAL)
    {
        return D3DERR_INVALIDDEVICE;
    }

    if (Windowed == TRUE)
    {
        return D3DERR_NOTAVAILABLE;
    }

    if (!CheckDisplayFormat(RenderTargetFormat))
    {
        return D3DERR_NOTAVAILABLE;
    }

    if ((MultiSampleType != D3DMULTISAMPLE_NONE) && (MultiSampleType != 0))
    {
        if ((MultiSampleType & ANTIALIAS_FORMAT_MASK) >
                            D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8)
        {
            return D3DERR_INVALIDCALL;
        }

        if ((ANTIALIAS_XSCALE(MultiSampleType) < 1) ||
            (ANTIALIAS_YSCALE(MultiSampleType) < 1) ||
            (ANTIALIAS_XSCALE(MultiSampleType) > 3) ||
            (ANTIALIAS_YSCALE(MultiSampleType) > 3))
        {
            return D3DERR_NOTAVAILABLE;
        }
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Direct3D_CheckDepthStencilMatch

extern "C"
HRESULT WINAPI Direct3D_CheckDepthStencilMatch(
    UINT Adapter,
    D3DDEVTYPE DeviceType,
    D3DFORMAT AdapterFormat,
    D3DFORMAT RenderTargetFormat,
    D3DFORMAT DepthStencilFormat)
{
    COUNT_API(API_DIRECT3D_CHECKDEPTHSTENCILMATCH);

    if (Adapter != 0)
    {
        return D3DERR_INVALIDCALL;
    }

    if (DeviceType != D3DDEVTYPE_HAL)
    {
        return D3DERR_INVALIDDEVICE;
    }

    if (!CheckDisplayFormat(RenderTargetFormat))
    {
        return D3DERR_NOTAVAILABLE;
    }

    if (!IsValidDepthBufferD3DFORMAT(DepthStencilFormat))
    {
        return D3DERR_NOTAVAILABLE;
    }

    return S_OK; 
}

//------------------------------------------------------------------------------
// Direct3D_GetDeviceCaps

extern "C"
HRESULT WINAPI Direct3D_GetDeviceCaps(
    UINT Adapter,
    D3DDEVTYPE DeviceType,
    D3DCAPS8* pCaps) 
{ 
    COUNT_API(API_DIRECT3D_GETDEVICECAPS);

    if (Adapter != 0)
    {
        return D3DERR_INVALIDCALL;
    }

    if (DeviceType != D3DDEVTYPE_HAL)
    {
        return D3DERR_INVALIDDEVICE;
    }

    D3DDevice_GetDeviceCaps(pCaps);

    return S_OK;
}

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\floatmath.cpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       floatmath.cpp
 *  Content:    Private impementation of floating-point math routines.
 *
 ***************************************************************************/

#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

    // Converts a floating point value to a long.
    _declspec(naked) long FloatToLong(float f)
    {
        _asm
        {
            // Note that this does a truncate, not a floor:

            cvttss2si eax, [esp+4]
            ret 4
        }
    }

    // Cosine.
    _declspec(naked) float Cos(float e)
    {
        _asm
        {
            fld [esp+4]
            fcos
            ret 4
        }
    }

    // Exponent
    float Exp(float e)
    {
        WORD istat;
        WORD fstat;

        _asm 
        {
            fld [e]

	        xor	ch,ch		    ; result is always positive
	        fldl2e
	        fmul			    ; convert log base e to log base 2

	        fld	st(0)			; copy TOS
	        frndint 			; near round to integer
	        ftst
            fstsw   [istat]     ; save integer part status
	        fwait
	        fxch				; NOS gets integer part
	        fsub	st,st(1)		; TOS gets fraction
	        ftst
            fstsw   [fstat]     ; save fraction part status
	        fabs
	        f2xm1
        
            fld1
	        fadd
	        test	[fstat+1],1	; if fraction > 0 (TOS > 0)
	        jz	ExpNoInvert	    ;	 bypass 2^x invert

	        fld1
	        fdivrp	st(1),st(0)

        ExpNoInvert:
	        test	[istat+1],040h 	    ; if integer part was zero
	        jnz	ExpScaled	    ;	 bypass scaling to avoid bug
	        fscale			    ; now TOS = 2^x

        ExpScaled:
	        or	ch,ch		    ; check for negate flag
	        jz	expret
	        fchs			    ; negate result (negreal ^ odd integer)

        expret:
	        fxch
            fstp st(0)
        }
    }

    // Log
    _declspec(naked) float Log(float e)
    {
        if (DBG_CHECK(e <= 0.0f))
        {
            DXGRIP("Log - fast log doesn't handle zero or negative values.");
        }

        _asm
        {
            fldln2
            fld [esp+4]
            fyl2x
            ret 4
        }
    }

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\floatmath.hpp ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       floatmath.hpp
 *  Content:    Private impementation of floating-point math routines.
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{
    // Converts a floating point value to a long.
    long FloatToLong(float f);

    // Cosine.
    float Cos(float e);

    // Exponent
    float Exp(float e);

    // Log
    float Log(float e);

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\globals.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       globals.cpp
 *  Content:    Contains the declarations for all global variables that
 *              are externally visible to titles (and so can be linked
 *              to directly)
 *
 ***************************************************************************/
 
#include "precomp.hpp"

extern "C"
{

//------------------------------------------------------------------------------
// Externally Visible Globals - Debug and Retail

// Current state as set by SetRenderState:

DWORD D3D__RenderState[D3DRS_MAX];

// Current state as set by SetTextureStageState:

DWORD D3D__TextureState[D3DTSS_MAXSTAGES][D3DTSS_MAX];

// Dirty flags for deferred render and texture state:

DWORD D3D__DirtyFlags;

// This points to the data of the currently selected index buffer:

WORD* D3D__IndexData;

// Set D3D__NullHardware to TRUE to enable infinitely fast hardware (so fast 
// you can't even see the results).  

BOOL D3D__NullHardware;

// Used for setting up a fake pControlDma for D3D__NullHardware:

DWORD g_NullHardwareGetPut[2];

// Push-buffer state:

volatile DWORD *D3D__GpuReg; 

// For the tvtest app.

DWORD D3D__AvInfo;

//------------------------------------------------------------------------------
// Externally Visible Globals - Debug Builds Only

#if DBG

// Set D3D__SingleStepPusher to TRUE to have the pusher pause after each 
// EndPush until the push buffer is empty.

BOOL D3D__SingleStepPusher;

// Timeout value used when checking for possible deadlocks

DWORD D3D__DeadlockTimeOutVal = 10000;

// Set D3D__Parser to TRUE before the device is created in order to enable the
// dumper to parse and track all register writes to the hardware.  Marked as 
// 'extern "C"' so that stress or whatever can enable it.

BOOL D3D__Parser;

// Start push-buffer point for StartBracket:

PPUSH g_StartPut;

#endif

} // end extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\hw.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       hw.h
 *  Content:    Miscellaneous hardware defines
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

typedef enum
{
    // From nv32.h: NUMBER_OF_SUBCHANNELS is 8.

    SUBCH_3D                 = 0,   // D3D_KELVIN_PRIMITIVE (0x097)
    SUBCH_MEMCOPY            = 1,   // D3D_MEMORY_TO_MEMORY_COPY (0x039)
    SUBCH_RECTCOPY           = 2,   // D3D_RECTANGLE_COPY (0x5F)
    SUBCH_RECTCOPYSURFACES   = 3,   // D3D_RECTANGLE_COPY_SURFACES (0x062)
    SUBCH_RECTCOPYOPTIONS    = 4,   // D3D_RECTANGLE_COPY_COLOR_KEY, BETA1, ...

    SUBCH_UNUSED0            = 5,
    SUBCH_UNUSED1            = 6,
    SUBCH_UNUSED2            = 7,

} SubChannel;

// Object handles

#define NVX_SOFTWARE_CLASS_HANDLE                               1 // Old:0xDD008000 
#define NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY    2 // Old:0xDD00101A
#define NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY                   3 // Old:0xDD001010
#define NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY                   4 // Old:0xDD00101C
#define NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY                 5 // Old:0xDD001002
#define NV_DD_DMA_PUSHER_CONTEXT_DMA_FROM_MEMORY                6 // Old:0xDD005000
#define D3D_MEMCOPY_NOTIFIER_CONTEXT_DMA_TO_MEMORY              7 // Old:0xDD00101F
#define D3D_SEMAPHORE_CONTEXT_DMA_IN_MEMORY                     8
#define D3D_COLOR_CONTEXT_DMA_IN_VIDEO_MEMORY                   9
#define D3D_ZETA_CONTEXT_DMA_IN_VIDEO_MEMORY                   10
#define D3D_COPY_CONTEXT_DMA_IN_VIDEO_MEMORY                   11
#define D3D_CONTEXT_IN_CACHED_MEMORY                           12

#define D3D_KELVIN_PRIMITIVE                                   13 // Old:0xD3D09701
#define D3D_MEMORY_TO_MEMORY_COPY                              14 // Old:0xD3D03900
#define D3D_SCALED_IMAGE_FROM_MEMORY                           15 // Old:0xD3D07701  
#define D3D_RECTANGLE_COPY                                     16
#define D3D_RECTANGLE_COPY_SURFACES                            17

#define D3D_RECTANGLE_COPY_PATTERN                             18
#define D3D_RECTANGLE_COPY_COLOR_KEY                           19
#define D3D_RECTANGLE_COPY_ROP                                 20
#define D3D_RECTANGLE_COPY_BETA1                               21
#define D3D_RECTANGLE_COPY_BETA4                               22
#define D3D_RECTANGLE_COPY_CLIP_RECTANGLE                      24

#define D3D_NULL_OBJECT                                        25

// Handy register access macros:

#define READ_REGISTER(Register)         (*(volatile DWORD *)(Register))
#define WRITE_REGISTER(Register, Value) (*(volatile DWORD *)(Register) = (Value))


// Maximum number of DWORDs in a single push-buffer instruction:

#define MAX_PUSH_METHOD_SIZE 2047

// Number of skinning blend matrices:

#define NUM_BLEND_MATRICES 4
#define NUM_COMBINERS 8

// The user can apportion amongst 136 vertex shader program slots:

#define VSHADER_PROGRAM_SLOTS 136

// Because the h/w is OpenGL'ized, we must D3D'ize it by adding 0.5 so
// that D3D pixels line up with OpenGL pixels.  Halfsubpixelbias is
// to adjust for floating point numbers which are not accurately
// represented.  E.g., -.7 is actually represented as -.699999
// If coordinates were only positive, this would be ok since it would
// result in being just to the left of the pixel center (integer coord).
// But, since the viewport is -2K...2K and the negative portion is used
// first, we actually end up being to the right of pixel center.
// Since the h/w doesn't do rounding to nearest 1/16 of a pixel, we
// adjust this here by subtracting 1/32 to round it.

const float KELVIN_D3D2OGL = 0.5f;              // add 0.5 so that D3D pixels line up with OGL pixels
const float KELVIN_HALFSUBPIXELBIAS = 0.03125f; // round to nearest 1/16 pixel grid
const float KELVIN_BORDER = 0.53125f;           // (KELVIN_D3D2OGL + KELVIN_HALFSUBPIXELBIAS)


// maximum fog scale = 2^13. (the HW has 14 bits. we leave one for roundoff)

const float MAX_FOG_SCALE = 8192.0f;

//------------------------------------------------------------------------------
// SwapRgb
//
// OpenGL'ize the D3D color

FORCEINLINE DWORD SwapRgb(
    D3DCOLOR color) 
{ 
    return (color & 0xff00ff00) | 
           ((color & 0x00ff0000) >> 16) | 
           ((color & 0x000000ff) << 16); 
}

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:    header file for memory allocation
 *  History:
 *
 ***************************************************************************/

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

#if STARTUPANIMATION

// When building the startup animation, both the debug and the retail
// allocation functions get mapped to the same thing:

void *MemAlloc(DWORD Size);
void *MemAllocNoZero(DWORD Size);
void MemFree(void *p);

#elif DBG || PROFILE

// For normal debug builds and profile builds, we thunk the allocation calls:

void *MemAlloc(DWORD Size);
void *MemAllocNoZero(DWORD Size);
void MemFree(void *p);

#else

// For normal retail builds, we do the allocations inline:

#define MemAlloc(size) ((VOID*) LocalAlloc(LMEM_ZEROINIT, size))
#define MemAllocNoZero(size) ((VOID*) LocalAlloc(0, size))
#define MemFree(p) LocalFree((p))

#endif 

} // end namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\memory.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memory.cpp
 *  Content:    Video resource allocation routines.
 *
 ***************************************************************************/

#include "precomp.hpp"

#if DBG || PROFILE

// Counts of active allocations.
extern "C"
{
    DWORD D3D__AllocsContiguous;
    DWORD D3D__AllocsNoncontiguous;
}

#endif

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

// The following functions are not defined if building for startup animation 
// because the startup animation app provides its own implementation

#if (DBG || PROFILE) && !STARTUPANIMATION

//----------------------------------------------------------------------------
// Allocate non-contiguous memory, and automatically zero-initialize it.
//
void *MemAlloc(
    DWORD Size
    )
{
    void *pv = LocalAlloc(LMEM_ZEROINIT, Size);
    if (pv)
    {
        D3D__AllocsNoncontiguous += LocalSize(pv);
    }

    return pv;
}

//----------------------------------------------------------------------------
// Allocate non-contiguous memory, and don't zero-initialize it.
//
void *MemAllocNoZero(
    DWORD Size
    )
{
    void *pv = LocalAlloc(0, Size);
    if (pv)
    {
        D3D__AllocsNoncontiguous += LocalSize(pv);
    }

    return pv;
}

//----------------------------------------------------------------------------
// Free a non-contiguous memory allocation.
//
void MemFree(
    void *pv
    )
{
    if (pv)
    {
        DWORD size = LocalSize(pv);

        if (size == (DWORD)-1)
        {
            DXGRIP("MemFree - Invalid pointer %x", pv);
        }
        else
        {
            ASSERT(D3D__AllocsNoncontiguous >= size);

            D3D__AllocsNoncontiguous -= size;
        }
    }

    LocalFree(pv);
}

#endif 

//----------------------------------------------------------------------------
// Allocate a block of noncontiguous memory and return a pointer to it.
//
// NOTE: This is used only by XDash!  It uses Register() but wants D3D to
//       free the resource memory for it when all the reference counts go to 
//       zero.
//
extern "C"
void* WINAPI D3D_AllocNoncontiguousMemory(
    DWORD Size          // The size of the allocation in bytes
    )
{
    return MemAlloc(Size);
}

//----------------------------------------------------------------------------
// Frees memory allocated by the above method.
//
// NOTE: This is used only by XDash!  It uses Register() but wants D3D to
//       free the resource memory for it when all the reference counts go to 
//       zero.
//
extern "C"
void WINAPI D3D_FreeNoncontiguousMemory(
     void *pMemory       // The block of memory to free
    )
{
    MemFree(pMemory);
}

#if !STARTUPANIMATION

//----------------------------------------------------------------------------
// Allocate a block of contiguous memory and return a pointer to it.
//
extern "C"
void* WINAPI D3D_AllocContiguousMemory(
    DWORD Size,         // The size of the allocation in bytes
    DWORD Alignment     // The alignment of the allocation
    )
{
    return AllocateContiguousMemory(Size, Alignment);
}

//----------------------------------------------------------------------------
// Frees memory allocated by the above method.
//
extern "C"
void WINAPI D3D_FreeContiguousMemory(
     void *pMemory       // The block of memory to free
    )
{
    return FreeContiguousMemory(pMemory);
}

#endif STARTUPANIMATION

} // end of namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3d8\se\lazy.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       lazy.cpp
 *  Content:    Whacks the hardware for state changes that we handle
 *              lazily
 *
 ***************************************************************************/

#include "precomp.hpp"

#ifdef STARTUPANIMATION
namespace D3DK
#else
namespace D3D
#endif
{

const float FLOAT_64 = 64.0f;

//------------------------------------------------------------------------------
// LazySetPointParams
//
// DOC: For point sprites, Xbox takes everything from texture stage 3,
//      not 0

VOID LazySetPointParams(
    CDevice* pDevice)
{
    COUNT_PERF(PERF_SETSTATE_POINTPARAMS);

    PPUSH pPush = pDevice->StartPush();

    FLOAT min = Floatify(D3D__RenderState[D3DRS_POINTSIZE_MIN]);
    FLOAT max = Floatify(D3D__RenderState[D3DRS_POINTSIZE_MAX]);
    FLOAT size = Floatify(D3D__RenderState[D3DRS_POINTSIZE]);

    if (DBG_CHECK(min >= max))
    {
        DPF_ERR("D3DRS_POINTSIZE_MIN must be less than D3DRS_POINTSIZE_MAX");

        max = min + 0.001f; // This simply avoids a divide-by-zero 
    }

    BOOL pointScaleEnable = D3D__RenderState[D3DRS_POINTSCALEENABLE];

    if (!pointScaleEnable)
    {
        // Note that we don't have to adjust the point-size with scale-
        // enable, since that is already relative to the viewport size.

        size *= pDevice->m_SuperSampleScale;

        if (size < min)
            size = min;
        if (size > max) 
            size = max;
        if (size > FLOAT_64)
            size = FLOAT_64;
    }
    else
    {
        // !!! We need something analagous to the Hadden hack-around for
        //     scale-enable with a small size factor, due to the fact that
        //     we have to round a *world-space* value to 6.3
        //
        //     The ideal range for the size is between 32 and 64, and
        //     we can adjust the floating point exponents of 'size' and
        //     'height' directly to do this

        FLOAT height = (FLOAT) pDevice->m_Viewport.Height;
    
        FLOAT a = Floatify(D3D__RenderState[D3DRS_POINTSCALE_A]);
        FLOAT b = Floatify(D3D__RenderState[D3DRS_POINTSCALE_B]);
        FLOAT c = Floatify(D3D__RenderState[D3DRS_POINTSCALE_C]);
    
        // Shaun Ho on what we're doing with this delta/factor stuff:
        // The T&L hw will do (according to the dx spec):
        //
        //      MIN <= PointSize/sqrt(k0 + k1d + k2d*d) <= MAX
        //
        // Eventually this will end up with:
        //
        //      0 <= ((PointSize/(MAX-MIN))/sqrt(k0 + k1d + k2d*d)) 
        //           - MIN/(MAX-MIN) <= 1
        //
        // The PointParameter methods pre-calculate some terms in the 
        // equation and pass them down to the T&L hw.
    
        FLOAT delta = max - min;
        FLOAT factor = delta / (size * height);
        factor *= factor;
    
        // Shaun Ho on why delta is dup'd 3 times:
        //  delta is used to calculate the result. Strictly speaking, we do 
        //  not have to duplicate delta. In general, T&L generates a triple 
        //  (e.g., rgb) for downstream consumption. Since size is only one 
        //  component, we only have to send one delta.  Erik chose to 
        //  duplicate the result of the calculation to each component of a 
        //  triple. The downstream hw can thus pick up the size value from 
        //  any of the three components.
    
        PushCount(pPush, NV097_SET_POINT_PARAMS(0), 8);
    
        FLOAT* pParam = (FLOAT*) pPush + 1;
        *(pParam + 0) = a * factor;
        *(pParam + 1) = b * factor;
        *(pParam + 2) = c * factor;
        *(pParam + 3) = delta;
        *(pParam + 4) = delta;
        *(pParam + 5) = delta;
        *(pParam + 6) = -min / delta;
        *(pParam + 7) = min;

        pPush += 9;
    }

    Push2(pPush, 
          NV097_SET_POINT_PARAMS_ENABLE, 

          // NV097_SET_POINT_PARAMS_ENABLE:
        
          pointScaleEnable,

          // NV097_SET_POINT_SMOOTH_ENABLE:

          D3D__RenderState[D3DRS_POINTSPRITEENABLE]);

    DWORD fixedSize = Round(8.0f * size);

    // Clamp 64.0 and greater to 63.875.  We used to assert on this case,
    // but it seems like a value of 64.0 is reasonable and should be clamped
    // to the hardware's true maximum of 63.875.

    if (fixedSize > 0x1ff)
        fixedSize = 0x1ff;

    Push1(pPush + 3, NV097_SET_POINT_SIZE, fixedSize);
    
    pDevice->EndPush(pPush + 5);
}

//------------------------------------------------------------------------------
// LazySetShaderStageProgram

VOID LazySetShaderStageProgram(
    CDevice* pDevice)
{
    INT stage;
    DWORD shaderStageProgram = 0;

    if (pDevice->m_pPixelShader == NULL)
    {
        for (stage = 3; stage >= 0; stage--)
        {
            DWORD shaderMode 
                = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE;

            D3DBaseTexture* pTexture = pDevice->m_Textures[stage];
    
            if (pTexture == NULL)
            {
                shaderMode = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE;
            }
            else if ((stage != 0) &&
                     (D3D__TextureState[stage - 1][D3DTSS_COLOROP]
                      == D3DTOP_BUMPENVMAP))
            {
                shaderMode = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP;
            }
            else if ((stage != 0) &&
                     (D3D__TextureState[stage - 1][D3DTSS_COLOROP]
                      == D3DTOP_BUMPENVMAPLUMINANCE))
            {
                shaderMode =
                    NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
            }
            else if (pTexture->Format &
                 DRF_DEF(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, _TRUE))
            {
                shaderMode = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP;
            }
            else if ((pTexture->Format & DRF_NUM(097, _SET_TEXTURE_FORMAT, 
                                                 _DIMENSIONALITY, ~0)) ==
                  DRF_DEF(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, _THREE))
            {
                shaderMode = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE;
            }
    
            shaderStageProgram = (shaderStageProgram << 5) | shaderMode;
        }
    }
    else
    {
        DWORD PSShaderStageProgram = pDevice->m_PSShaderStageProgram;

        if(pDevice->m_ShaderAdjustsTexMode == 0)
        {
            // don't adjust shader stage program

            shaderStageProgram = PSShaderStageProgram;
        }
        else
        {
            // adjust shader stage program according to set textures

            for (stage = 3; stage >= 0; stage--)
            {
                // Assume by default we'll keep the specified mode for this stage:
    
                DWORD shaderMode = (PSShaderStageProgram >> (stage * 5)) & 0x1f;
    
                // PERF: Disable texture unit for _NONE case?
    
                D3DBaseTexture* pTexture = pDevice->m_Textures[stage];
    
                if((pTexture == NULL) &&
                   (shaderMode != PS_TEXTUREMODES_PASSTHRU) &&
                   (shaderMode != PS_TEXTUREMODES_CLIPPLANE) &&
                   (shaderMode != PS_TEXTUREMODES_DOT_ZW) &&
                   (shaderMode != PS_TEXTUREMODES_DOTPRODUCT))
                {
                    // no texture set but texture mode requires one

                    shaderMode = PS_TEXTUREMODES_NONE;
                }
                else if ((shaderMode >= PS_TEXTUREMODES_PROJECT2D) &&
                         (shaderMode <= PS_TEXTUREMODES_CUBEMAP))
                {
                    DWORD colorFormat = pTexture->Format 
                        & DRF_NUM(097, _SET_TEXTURE_FORMAT, _COLOR, ~0);
    
                    if (pTexture->Format & 
                        DRF_DEF(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, _TRUE))
                    {
                        shaderMode = PS_TEXTUREMODES_CUBEMAP;
                    }
                    else if (((pTexture->Format & DRF_NUM(097, _SET_TEXTURE_FORMAT, 
                                                          _DIMENSIONALITY, ~0)) 
                                == DRF_DEF(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, 
                                           _THREE)) ||
    
                             ((colorFormat >= DRF_DEF(097, _SET_TEXTURE_FORMAT, 
                                                      _COLOR, _SZ_DEPTH_X8_Y24_FIXED)) &&
                              (colorFormat <= DRF_DEF(097, _SET_TEXTURE_FORMAT, 
                                                      _COLOR, _LU_IMAGE_DEPTH_Y16_FLOAT))))
                    {
                        shaderMode = PS_TEXTUREMODES_PROJECT3D;
                    }
                    else
                    {
                        shaderMode = PS_TEXTUREMODES_PROJECT2D;
                    }
                }
                else if ((shaderMode == PS_TEXTUREMODES_DOT_STR_3D) ||
                         (shaderMode == PS_TEXTUREMODES_DOT_STR_CUBE))
                {
                    if (pTexture->Format & DRF_DEF(097, _SET_TEXTURE_FORMAT, 
                                                  _CUBEMAP_ENABLE, _TRUE))
                    {
                        shaderMode = PS_TEXTUREMODES_DOT_STR_CUBE;
                    }
                    else
                    {
                        shaderMode = PS_TEXTUREMODES_DOT_STR_3D;
                    }
                }
        
                shaderStageProgram = (shaderStageProgram << 5) | shaderMode;
            }
        }
    }

#if DBG
    ValidTextureModes(shaderStageProgram, "LazySetShaderStageProgram");
#endif

    PPUSH pPush = pDevice->StartPush();

    Push1(pPush, NV097_SET_SHADER_STAGE_PROGRAM, shaderStageProgram);

    pDevice->EndPush(pPush + 2);
}

//------------------------------------------------------------------------------
// LazySetTextureState - corresponds to nvSetKelvinTextureState

VOID LazySetTextureState(
    CDevice* pDevice)
{
    COUNT_PERF(PERF_SETSTATE_TEXTURESTATE);

    DWORD dirtyFlags = D3D__DirtyFlags;

    for (DWORD stage = 0; stage < D3DTSS_MAXSTAGES; stage++, dirtyFlags >>= 1)
    {
        if (dirtyFlags & D3DDIRTYFLAG_TEXTURE_STATE_0)
        {
            DWORD* pTextureStates = D3D__TextureState[stage];
    
            // NOTE: We CAN'T check for a NULL texture in this stage, and only
            //       do the following when it's non-NULL.  That's because we
            //       NEVER set D3DDIRTYFLAG_TEXTURE_STATE in SetTexture!
    
            // EXT: Expose Format.BorderSource functionality for having border
            //      come from the texture or the border color.  Can't simply
            //      be a D3DTADDRESS type because it can't be applied separately
            //      to U, V, and P.
    
            DWORD texCoordIndex
                = pTextureStates[D3DTSS_TEXCOORDINDEX] & 0xffff;
    
            DWORD address 
                = DRF_NUMFAST(097, _SET_TEXTURE_ADDRESS, _U, 
                              pTextureStates[D3DTSS_ADDRESSU])
                | DRF_NUMFAST(097, _SET_TEXTURE_ADDRESS, _V,
                              pTextureStates[D3DTSS_ADDRESSV])
                | DRF_NUMFAST(097, _SET_TEXTURE_ADDRESS, _P,
                              pTextureStates[D3DTSS_ADDRESSW])
                | D3D__RenderState[D3DRS_WRAP0 + texCoordIndex];
    
            // These are backward from OpenGL.  D3D can only set the maximum
            // mipmap level, by which they mean the OpenGL minimum level
            // (D3D maximum is the largest sized level to use, not the largest
            // level number).
            //
            // The D3D minimum level (the OpenGL/hardware maximum) is always
            // just the end of the chain.
            //
            // EXT: Expose MAX_LOD_CLAMP?
            //
            // The Nvidia driver sets MAX_LOD_CLAMP to getMipMapCount() - 1,
            // which I'd rather avoid because it would mean updating this
            // register at SetTexture time.  I'm assuming the hardware actually
            // takes the min of Format.MipmapLevels and Control0.MaxLodClamp.
    
            DWORD control0
                = DRF_NUMFAST(097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP,
                              pTextureStates[D3DTSS_MAXMIPLEVEL] << 8)
    
                | DRF_NUM(097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, ~0)
    
                | pTextureStates[D3DTSS_ALPHAKILL]
    
                | DRF_NUMFAST(097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, 
                              pTextureStates[D3DTSS_COLORKEYOP]);
    
            if (pDevice->m_Textures[stage] != NULL)
            {
                control0 |= DRF_DEF(097, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE);
            }
    
            DWORD minFilter = pTextureStates[D3DTSS_MINFILTER];
            DWORD magFilter = pTextureStates[D3DTSS_MAGFILTER];
    
            DWORD convolutionKernel 
                = DRF_DEF(097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, _QUINCUNX);
    
            if ((minFilter >= D3DTEXF_ANISOTROPIC) || 
                (magFilter >= D3DTEXF_ANISOTROPIC))
            {
                if ((minFilter > D3DTEXF_ANISOTROPIC) ||
                    (magFilter > D3DTEXF_ANISOTROPIC))
                {
                    // CONVOLUTION_2D_LOD0 has to be set in both the Min and Mag
                    // fields in order for a convolution filter to be used.  So
                    // convolution always wins if it's mixed with something else.
                    //
                    // Between Quincunx and Gaussian, Gaussian always wins.
    
                    if ((minFilter == D3DTEXF_GAUSSIANCUBIC) ||
                        (magFilter == D3DTEXF_GAUSSIANCUBIC))
                    {
                        convolutionKernel = DRF_DEF(097, _SET_TEXTURE_FILTER, 
                                                    _CONVOLUTION_KERNEL, _GAUSSIAN_3);
                    }
    
                    // CONVOLUTION_2D_LOD0 has a value of '7', so it doesn't 
                    // matter what the MinFilter() ORs into the 'Min' field a
                    // few lines down, since it will OR in values less than 7...
    
                    convolutionKernel |= DRF_DEF(097, _SET_TEXTURE_FILTER, 
                                                 _MIN, _CONVOLUTION_2D_LOD0);
    
                    minFilter = D3DTEXF_LINEAR;
    
                    magFilter = NV097_SET_TEXTURE_FILTER_MAG_CONVOLUTION_2D_LOD0;
                }
                else
                {
                    // Handle anisotropic filters.  If either min or mag filter 
                    // are anisotropic, we use anisotropic:
    
                    DWORD maxAnisotropy = pTextureStates[D3DTSS_MAXANISOTROPY];
                    if (maxAnisotropy == 0)
                    {
                        minFilter = D3DTEXF_POINT;
                        magFilter = D3DTEXF_POINT;
                    }
                    else
                    {
                        // DOC: We max out at a D3DTSS_MAXANISOTROPY of 4:
    
                        ASSERT(maxAnisotropy <= 4);
        
                        maxAnisotropy--;
                        minFilter = D3DTEXF_LINEAR;
                        magFilter = D3DTEXF_LINEAR;
                    }
        
                    control0 |= DRF_NUMFAST(097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO,
                                            maxAnisotropy);
                }
            }
    
            ASSERT((D3DTEXF_POINT == NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0) &&
                   (D3DTEXF_LINEAR == NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0));
    
            pDevice->m_TextureControl0Enabled[stage] = control0 
                | DRF_DEF(097, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE);
    
            INT lodBias = Round(256.0f * (Floatify(pTextureStates[D3DTSS_MIPMAPLODBIAS])
                                          + pDevice->m_SuperSampleLODBias));
    
            if (lodBias < -0x1000)
                lodBias = -0x1000;
            if (lodBias > 0xfff)
                lodBias = 0xfff;
    
            // We're about to assume that the bump-env color-ops come at the end
            // of the list so that we can use a single inequality comparison:
    
            ASSERT(((D3DTOP_BUMPENVMAP + 1) == D3DTOP_BUMPENVMAPLUMINANCE) &&
                   ((D3DTOP_BUMPENVMAP + 2) == D3DTOP_MAX));
    
            // When doing bump mapping, we always override the color-sign texture
            // stage state:
    
            DWORD colorSign = (pTextureStates[D3DTSS_COLOROP] >= D3DTOP_BUMPENVMAP)
                ? (D3DTSIGN_GSIGNED | D3DTSIGN_BSIGNED)
                : pTextureStates[D3DTSS_COLORSIGN];
    
            DWORD filter 
                = DRF_NUM(097, _SET_TEXTURE_FILTER, _MIPMAP_LOD_BIAS, lodBias)
    
                | convolutionKernel
    
                | MinFilter(minFilter, pTextureStates[D3DTSS_MIPFILTER])
    
                | DRF_NUMFAST(097, _SET_TEXTURE_FILTER, _MAG, magFilter)
    
                | colorSign;
    
            PPUSH pPush = pDevice->StartPush();
    
            // Hit NV097_SET_TEXTURE_ADDRESS and NV097_SET_TEXTURE_CONTROL0:
    
            Push2(pPush, NV097_SET_TEXTURE_ADDRESS(stage), address, control0);
            Push1(pPush + 3, NV097_SET_TEXTURE_FILTER(stage), filter);
    
            pDevice->EndPush(pPush + 5);
        }
    }

    // !!! Gotta set TEXGEN_VIEW_MODEL somewhere!
}

//------------------------------------------------------------------------------
// LazySetSpecFogCombiner - corresponds to nvSetKelvinSpecularFogCombiner

VOID LazySetSpecFogCom