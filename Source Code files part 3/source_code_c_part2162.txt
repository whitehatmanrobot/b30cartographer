)
#include <wtime.inl>
#endif

#define _WTIME_DEFINED
#endif

#if !defined(RC_INVOKED) && !defined(__midl)
#include <time.inl>
#endif

#if     !__STDC__ || defined(_POSIX_)

/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

/*
daylight, timezone, and tzname are not available under /clr:pure.
Please use _daylight, _timezone, and _tzname or 
_get_daylight, _get_timezone, and _get_tzname instead.
*/
#if !defined(_M_CEE_PURE)
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_daylight) _CRTIMP extern int daylight;
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_timezone) _CRTIMP extern long timezone;
_CRT_INSECURE_DEPRECATE_GLOBALS(_get_tzname) _CRTIMP extern char * tzname[2];
#endif /* !defined(_M_CEE_PURE) */

_CRT_NONSTDC_DEPRECATE(_tzset) _CRTIMP void __cdecl tzset(void);

#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\vcclr.h ===
//
//	vcclr.h - helper code for using the managed extensions to C++
//
//		Copyright (C) Microsoft Corporation
//		All rights reserved.
//

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_VCCLR)
#define _INC_VCCLR
#ifndef RC_INVOKED

#using <mscorlib.dll>
#include <gcroot.h>

#pragma warning(push)
#pragma warning(disable:4400)

#ifdef __cplusplus_cli
typedef cli::interior_ptr<const System::Char> __const_Char_ptr;
typedef cli::interior_ptr<const System::Byte> __const_Byte_ptr;
typedef cli::interior_ptr<System::Byte> _Byte_ptr;
typedef const System::String^ __const_String_handle;
#define _NULLPTR nullptr
#else
typedef const System::Char* __const_Char_ptr;
typedef const System::Byte* __const_Byte_ptr;
typedef System::Byte* _Byte_ptr;
typedef const System::String* __const_String_handle;
#define _NULLPTR 0
#endif


//
// get an interior gc pointer to the first character contained in a System::String object
//
inline __const_Char_ptr PtrToStringChars(__const_String_handle s) {

	_Byte_ptr bp = const_cast<_Byte_ptr>(reinterpret_cast<__const_Byte_ptr>(s));
	if( bp != _NULLPTR ) {
		unsigned offset = System::Runtime::CompilerServices::RuntimeHelpers::OffsetToStringData;
    	bp += offset;
	}
    return reinterpret_cast<__const_Char_ptr>(bp);
}

#pragma warning(pop)

#undef _NULLPTR

#endif /* RC_INVOKED */
#endif //_INC_VCCLR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STRING
#define _INC_STRING

#include <crtdefs.h>

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647  /* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif

/* Define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

/* For backwards compatibility */
#define _WConst_return _CONST_RETURN

/* Function prototypes */
#ifndef _CRT_MEMORY_DEFINED
#define _CRT_MEMORY_DEFINED
_CRTIMP void *  __cdecl _memccpy( _Out_opt_bytecap_(_MaxCount) void * _Dst, _In_ const void * _Src, _In_ int _Val, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP _CONST_RETURN void *  __cdecl memchr( _In_opt_bytecount_(_MaxCount) const void * _Buf , _In_ int _Val, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int     __cdecl _memicmp(_In_opt_bytecount_(_Size) const void * _Buf1, _In_opt_bytecount_(_Size) const void * _Buf2, _In_ size_t _Size);
_Check_return_ _CRTIMP int     __cdecl _memicmp_l(_In_opt_bytecount_(_Size) const void * _Buf1, _In_opt_bytecount_(_Size) const void * _Buf2, _In_ size_t _Size, _In_opt_ _locale_t _Locale);
        _Check_return_ int     __cdecl memcmp(_In_opt_bytecount_(_Size) const void * _Buf1, _In_opt_bytecount_(_Size) const void * _Buf2, _In_ size_t _Size);
        _CRT_INSECURE_DEPRECATE_MEMORY(memcpy_s) void *  __cdecl memcpy(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ size_t _Size);
#if __STDC_WANT_SECURE_LIB__
_CRTIMP errno_t  __cdecl memcpy_s(_Out_opt_bytecap_post_bytecount_(_DstSize, _MaxCount) void * _Dst, _In_ rsize_t _DstSize, _In_opt_bytecount_(_MaxCount) const void * _Src, _In_ rsize_t _MaxCount);
#endif
        void *  __cdecl memset(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_ int _Val, _In_ size_t _Size);

#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRT_NONSTDC_DEPRECATE(_memccpy) _CRTIMP void * __cdecl memccpy(_Out_opt_bytecap_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ int _Val, _In_ size_t _Size);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_memicmp) _CRTIMP int __cdecl memicmp(_In_opt_bytecount_(_Size) const void * _Buf1, _In_opt_bytecount_(_Size) const void * _Buf2, _In_ size_t _Size);
#endif  /* __STDC__ */

#endif

_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl _strset_s(_Inout_z_cap_(_DstSize) char * _Dst, _In_ size_t _DstSize, _In_ int _Value);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _strset_s, _Deref_prepost_z_ char, _Dest, _In_ int, _Value)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(char *, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, _strset, _Inout_z_, char, _Dest, _In_ int, _Value)
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl strcpy_s(_Out_z_cap_(_SizeInBytes) char * _Dst, _In_ rsize_t _SizeInBytes, _In_z_ const char * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcpy_s, _Deref_post_z_ char, _Dest, _In_z_ const char *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(char *, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, strcpy, _Pre_cap_for_(_Source) _Post_z_, char, _Dest, _In_z_ const char *, _Source)
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl strcat_s(_Inout_z_cap_(_SizeInBytes) char * _Dst, _In_ rsize_t _SizeInBytes, _In_z_ const char * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strcat_s, _Deref_prepost_z_ char, _Dest, _In_z_ const char *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(char *, __RETURN_POLICY_DST, __EMPTY_DECLSPEC, strcat, _Pre_cap_for_(_Source) _Prepost_z_, char, _Dest, _In_z_ const char *, _Source)
        _Check_return_ int     __cdecl strcmp(_In_z_ const char * _Str1, _In_z_ const char * _Str2);
        _Check_return_ size_t  __cdecl strlen(_In_z_ const char * _Str);
_Check_return_ _CRTIMP size_t  __cdecl strnlen(_In_z_ const char * _Str, _In_ size_t _MaxCount);
#if __STDC_WANT_SECURE_LIB__ && !defined (__midl)
_Check_return_ static __inline size_t  __CRTDECL strnlen_s(_In_z_  const char * _Str, _In_ size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}
#endif
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP errno_t __cdecl memmove_s(_Out_opt_bytecap_post_bytecount_(_DstSize,_MaxCount) void * _Dst, _In_ rsize_t _DstSize, _In_opt_bytecount_(_MaxCount) const void * _Src, _In_ rsize_t _MaxCount);
#endif

#if     defined(_M_IA64)
        _CRT_INSECURE_DEPRECATE_MEMORY(memmove_s) void *  __cdecl memmove(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ size_t _Size);
#else  /* defined (_M_IA64) */
_CRTIMP _CRT_INSECURE_DEPRECATE_MEMORY(memmove_s) void *  __cdecl memmove(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ size_t _Size);
#endif  /* defined (_M_IA64) */

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("_strdup")
#undef _strdup
#endif

_Check_return_ _CRTIMP char *  __cdecl _strdup(_In_opt_z_ const char * _Src);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_strdup")
#endif

_Check_return_ _CRTIMP _CONST_RETURN char *  __cdecl strchr(_In_z_ const char * _Str, _In_ int _Val);
_Check_return_ _CRTIMP int     __cdecl _stricmp(_In_z_  const char * _Str1, _In_z_  const char * _Str2);
_Check_return_ _CRTIMP int     __cdecl _strcmpi(_In_z_  const char * _Str1, _In_z_  const char * _Str2);
_Check_return_ _CRTIMP int     __cdecl _stricmp_l(_In_z_  const char * _Str1, _In_z_  const char * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int     __cdecl strcoll(_In_z_  const char * _Str1, _In_z_  const  char * _Str2);
_Check_return_ _CRTIMP int     __cdecl _strcoll_l(_In_z_  const char * _Str1, _In_z_  const char * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int     __cdecl _stricoll(_In_z_  const char * _Str1, _In_z_  const char * _Str2);
_Check_return_ _CRTIMP int     __cdecl _stricoll_l(_In_z_  const char * _Str1, _In_z_  const char * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int     __cdecl _strncoll  (_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int     __cdecl _strncoll_l(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int     __cdecl _strnicoll (_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int     __cdecl _strnicoll_l(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP size_t  __cdecl strcspn(_In_z_  const char * _Str, _In_z_  const char * _Control);
_Check_return_ _CRT_INSECURE_DEPRECATE(_strerror_s) _CRTIMP char *  __cdecl _strerror(_In_opt_z_ const char * _ErrMsg);
_Check_return_wat_ _CRTIMP errno_t __cdecl _strerror_s(_Out_z_cap_(_SizeInBytes) char * _Buf, _In_ size_t _SizeInBytes, _In_opt_z_ const char * _ErrMsg);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _strerror_s, char, _Buffer, _In_opt_z_ const char *, _ErrorMessage)
_Check_return_ _CRT_INSECURE_DEPRECATE(strerror_s) _CRTIMP char *  __cdecl strerror(_In_ int);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP errno_t __cdecl strerror_s(_Out_z_cap_(_SizeInBytes) char * _Buf, _In_ size_t _SizeInBytes, _In_ int _ErrNum);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, strerror_s, char, _Buffer, _In_ int, _ErrorMessage)
_Check_return_wat_ _CRTIMP errno_t __cdecl _strlwr_s(_Inout_z_cap_(_Size) char * _Str, _In_ size_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _strlwr_s, _Deref_prepost_z_ char, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_DST, _CRTIMP, _strlwr, _Inout_z_, char, _String)
_Check_return_wat_ _CRTIMP errno_t __cdecl _strlwr_s_l(_Inout_z_cap_(_Size) char * _Str, _In_ size_t _Size, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _strlwr_s_l, _Deref_prepost_z_ char, _String, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(char *, __RETURN_POLICY_DST, _CRTIMP, _strlwr_l, _strlwr_s_l, _Deref_inout_z_cap_c_(_Size) char, _Inout_z_, char, _String, _In_opt_ _locale_t, _Locale)
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl strncat_s(_Inout_z_cap_(_SizeInBytes) char * _Dst, _In_ rsize_t _SizeInBytes, _In_z_ const char * _Src, _In_ rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncat_s, _Deref_prepost_z_ char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count)
#pragma warning(push)
#pragma warning(disable:6059)
/* prefast noise VSW 489802 */
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _CRTIMP, strncat, strncat_s, _Deref_inout_z_cap_c_(_Size) char, _Inout_z_cap_(_Count), char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count)
#pragma warning(pop)
#if     defined(_M_IA64)
        _Check_return_ int     __cdecl strncmp(_In_z_  const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
#else
_Check_return_ _CRTIMP int     __cdecl strncmp(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
#endif
_Check_return_ _CRTIMP int     __cdecl _strnicmp(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int     __cdecl _strnicmp_l(_In_z_ const char * _Str1, _In_z_ const char * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl strncpy_s(_Out_z_cap_(_SizeInBytes) char * _Dst, _In_ rsize_t _SizeInBytes, _In_z_ const char * _Src, _In_ rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, strncpy_s, char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _CRTIMP_NOIA64, strncpy, strncpy_s, _Deref_out_z_cap_c_(_Size) char, _Out_cap_(_Count) _Post_maybez_, char, _Dest, _In_z_ const char *, _Source, _In_ size_t, _Count)
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl _strnset_s(_Inout_z_cap_(_SizeInBytes) char * _Str, _In_ size_t _SizeInBytes, _In_ int _Val, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _strnset_s, _Deref_prepost_z_ char, _Dest, _In_ int, _Val, _In_ size_t, _Count)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(char *, __RETURN_POLICY_DST, _CRTIMP, _strnset, _strnset_s, _Deref_inout_z_cap_c_(_Size) char, _Inout_z_cap_(_Count), char, _Dest, _In_ int, _Val, _In_ size_t, _Count)
_Check_return_ _CRTIMP _CONST_RETURN char *  __cdecl strpbrk(_In_z_ const char * _Str, _In_z_ const char * _Control);
_Check_return_ _CRTIMP _CONST_RETURN char *  __cdecl strrchr(_In_z_ const char * _Str, _In_ int _Ch);
_CRTIMP char *  __cdecl _strrev(_Inout_z_ char * _Str);
_Check_return_ _CRTIMP size_t  __cdecl strspn(_In_z_ const char * _Str, _In_z_ const char * _Control);
_Check_return_ _CRTIMP _CONST_RETURN char *  __cdecl strstr(_In_z_ const char * _Str, _In_z_ const char * _SubStr);
_Check_return_ _CRT_INSECURE_DEPRECATE(strtok_s) _CRTIMP char *  __cdecl strtok(_Inout_opt_z_ char * _Str, _In_z_ const char * _Delim);
#if __STDC_WANT_SECURE_LIB__
_Check_return_ _CRTIMP_ALTERNATIVE char *  __cdecl strtok_s(_Inout_opt_z_ char * _Str, _In_z_ const char * _Delim, _Inout_ _Deref_prepost_opt_z_ char ** _Context);
#endif
_Check_return_wat_ _CRTIMP errno_t __cdecl _strupr_s(_Inout_z_cap_(_Size) char * _Str, _In_ size_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _strupr_s, _Deref_prepost_z_ char, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(char *, __RETURN_POLICY_DST, _CRTIMP, _strupr, _Inout_z_, char, _String)
_Check_return_wat_ _CRTIMP errno_t __cdecl _strupr_s_l(_Inout_z_cap_(_Size) char * _Str, _In_ size_t _Size, _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _strupr_s_l, _Deref_prepost_z_ char, _String, _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(char *, __RETURN_POLICY_DST, _CRTIMP, _strupr_l, _strupr_s_l, _Deref_inout_z_cap_c_(_Size) char, _Inout_z_, char, _String, _In_opt_ _locale_t, _Locale)
_Check_return_opt_ _CRTIMP size_t  __cdecl strxfrm (_Out_opt_cap_(_MaxCount) _Post_maybez_ char * _Dst, _In_z_ const char * _Src, _In_ size_t _MaxCount);
_Check_return_opt_ _CRTIMP size_t  __cdecl _strxfrm_l(_Out_opt_cap_(_MaxCount) _Post_maybez_ char * _Dst, _In_z_ const char * _Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);

#ifdef __cplusplus
extern "C++" {
#ifndef _CPP_NARROW_INLINES_DEFINED
#define _CPP_NARROW_INLINES_DEFINED
_Check_return_ inline char * __CRTDECL strchr(_In_z_ char * _Str, _In_ int _Ch)
	{ return (char*)strchr((const char*)_Str, _Ch); }
_Check_return_ inline char * __CRTDECL strpbrk(_In_z_ char * _Str, _In_z_ const char * _Control)
	{ return (char*)strpbrk((const char*)_Str, _Control); }
_Check_return_ inline char * __CRTDECL strrchr(_In_z_ char * _Str, _In_ int _Ch)
	{ return (char*)strrchr((const char*)_Str, _Ch); }
_Check_return_ inline char * __CRTDECL strstr(_In_z_ char * _Str, _In_z_ const char * _SubStr)
	{ return (char*)strstr((const char*)_Str, _SubStr); }
#endif
#ifndef _CPP_MEMCHR_DEFINED
#define _CPP_MEMCHR_DEFINED
_Check_return_ inline void * __CRTDECL memchr(_In_opt_bytecount_(_N) void * _Pv, _In_ int _C, _In_ size_t _N)
	{ return (void*)memchr((const void*)_Pv, _C, _N); }
#endif
}
#endif

#if     !__STDC__

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("strdup")
#undef strdup
#endif

_Check_return_ _CRT_NONSTDC_DEPRECATE(_strdup) _CRTIMP char * __cdecl strdup(_In_opt_z_ const char * _Src);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("strdup")
#endif

/* prototypes for oldnames.lib functions */
_Check_return_ _CRT_NONSTDC_DEPRECATE(_strcmpi) _CRTIMP int __cdecl strcmpi(_In_z_ const char * _Str1, _In_z_ const char * _Str2);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_stricmp) _CRTIMP int __cdecl stricmp(_In_z_ const char * _Str1, _In_z_ const char * _Str2);
_CRT_NONSTDC_DEPRECATE(_strlwr) _CRTIMP char * __cdecl strlwr(_Inout_z_ char * _Str);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_strnicmp) _CRTIMP int __cdecl strnicmp(_In_z_ const char * _Str1, _In_z_ const char * _Str, _In_ size_t _MaxCount);
_CRT_NONSTDC_DEPRECATE(_strnset) _CRTIMP char * __cdecl strnset(_Inout_z_cap_(_MaxCount) char * _Str, _In_ int _Val, _In_ size_t _MaxCount);
_CRT_NONSTDC_DEPRECATE(_strrev) _CRTIMP char * __cdecl strrev(_Inout_z_ char * _Str);
_CRT_NONSTDC_DEPRECATE(_strset)         char * __cdecl strset(_Inout_z_ char * _Str, _In_ int _Val);
_CRT_NONSTDC_DEPRECATE(_strupr) _CRTIMP char * __cdecl strupr(_Inout_z_ char * _Str);

#endif  /* !__STDC__ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wcsdup")
#undef _wcsdup
#endif

_Check_return_ _CRTIMP wchar_t * __cdecl _wcsdup(_In_z_ const wchar_t * _Str);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wcsdup")
#endif

#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl wcscat_s(_Inout_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ rsize_t _SizeInWords, _In_z_ const wchar_t * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, wcscat_s, _Deref_prepost_z_ wchar_t, _Dest, _In_z_ const wchar_t *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcscat, _Pre_cap_for_(_Source) _Prepost_z_, wchar_t, _Dest, _In_z_ const wchar_t *, _Source)
_Check_return_ _CRTIMP _CONST_RETURN wchar_t * __cdecl wcschr(_In_z_ const wchar_t * _Str, wchar_t _Ch);
_Check_return_ _CRTIMP int __cdecl wcscmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl wcscpy_s(_Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ rsize_t _SizeInWords, _In_z_ const wchar_t * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, wcscpy_s, wchar_t, _Dest, _In_z_ const wchar_t *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcscpy, _Pre_cap_for_(_Source) _Post_z_, wchar_t, _Dest, _In_z_ const wchar_t *, _Source)
_Check_return_ _CRTIMP size_t __cdecl wcscspn(_In_z_ const wchar_t * _Str, _In_z_ const wchar_t * _Control);
_Check_return_ _CRTIMP size_t __cdecl wcslen(_In_z_ const wchar_t * _Str);
_Check_return_ _CRTIMP size_t __cdecl wcsnlen(_In_z_ const wchar_t * _Src, _In_ size_t _MaxCount);
#if __STDC_WANT_SECURE_LIB__ && !defined (__midl)
_Check_return_ static __inline size_t __CRTDECL wcsnlen_s(_In_z_ const wchar_t * _Src, _In_ size_t _MaxCount)
{
    return (_Src == NULL) ? 0 : wcsnlen(_Src, _MaxCount);
}
#endif
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl wcsncat_s(_Inout_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ rsize_t _SizeInWords, _In_z_ const wchar_t * _Src, _In_ rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, wcsncat_s, _Deref_prepost_z_ wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count)
#pragma warning(push)
#pragma warning(disable:6059)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcsncat, wcsncat_s, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_cap_(_Count), wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count)
#pragma warning(pop)
_Check_return_ _CRTIMP int __cdecl wcsncmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl wcsncpy_s(_Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ rsize_t _SizeInWords, _In_z_ const wchar_t * _Src, _In_ rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, wcsncpy_s, wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcsncpy, wcsncpy_s, _Pre_notnull_ _Post_maybez_ wchar_t, _Out_cap_(_Count) _Post_maybez_, wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count)
_Check_return_ _CRTIMP _CONST_RETURN wchar_t * __cdecl wcspbrk(_In_z_ const wchar_t * _Str, _In_z_ const wchar_t * _Control);
_Check_return_ _CRTIMP _CONST_RETURN wchar_t * __cdecl wcsrchr(_In_z_ const wchar_t * _Str, _In_ wchar_t _Ch);
_Check_return_ _CRTIMP size_t __cdecl wcsspn(_In_z_ const wchar_t * _Str, _In_z_ const wchar_t * _Control);
_Check_return_ _CRTIMP _CONST_RETURN wchar_t * __cdecl wcsstr(_In_z_ const wchar_t * _Str, _In_z_ const wchar_t * _SubStr);
_Check_return_ _CRT_INSECURE_DEPRECATE(wcstok_s) _CRTIMP wchar_t * __cdecl wcstok(_Inout_opt_z_ wchar_t * _Str, _In_z_ const wchar_t * _Delim);
#if __STDC_WANT_SECURE_LIB__
_Check_return_ _CRTIMP_ALTERNATIVE wchar_t * __cdecl wcstok_s(_Inout_opt_z_ wchar_t * _Str, _In_z_ const wchar_t * _Delim, _Inout_ _Deref_prepost_opt_z_ wchar_t ** _Context);
#endif
_Check_return_ _CRT_INSECURE_DEPRECATE(_wcserror_s) _CRTIMP wchar_t * __cdecl _wcserror(_In_ int _ErrNum);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcserror_s(_Out_opt_z_cap_(_SizeInWords) wchar_t * _Buf, _In_ size_t _SizeInWords, _In_ int _ErrNum);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wcserror_s, wchar_t, _Buffer, _In_ int, _Error)
_Check_return_ _CRT_INSECURE_DEPRECATE(__wcserror_s) _CRTIMP wchar_t * __cdecl __wcserror(_In_opt_z_ const wchar_t * _Str);
_Check_return_wat_ _CRTIMP errno_t __cdecl __wcserror_s(_Out_opt_z_cap_(_SizeInWords) wchar_t * _Buffer, _In_ size_t _SizeInWords, _In_z_ const wchar_t * _ErrMsg);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, __wcserror_s, wchar_t, _Buffer, _In_z_ const wchar_t *, _ErrorMessage)

_Check_return_ _CRTIMP int __cdecl _wcsicmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
_Check_return_ _CRTIMP int __cdecl _wcsicmp_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wcsnicmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _wcsnicmp_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl _wcsnset_s(_Inout_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ size_t _SizeInWords, _In_ wchar_t _Val, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _wcsnset_s, _Deref_prepost_z_ wchar_t, _Dst, wchar_t, _Val, _In_ size_t, _MaxCount)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsnset, _wcsnset_s, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_cap_(_MaxCount), wchar_t, _Str, wchar_t, _Val, _In_ size_t, _MaxCount)
_CRTIMP wchar_t * __cdecl _wcsrev(_Inout_z_ wchar_t * _Str);
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl _wcsset_s(_Inout_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ size_t _SizeInWords, _In_ wchar_t _Value);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wcsset_s, _Deref_prepost_z_ wchar_t, _Str, wchar_t, _Val)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsset, _wcsset_s, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_, wchar_t, _Str, wchar_t, _Val)

_Check_return_wat_ _CRTIMP errno_t __cdecl _wcslwr_s(_Inout_z_cap_(_SizeInWords) wchar_t * _Str, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wcslwr_s, _Deref_prepost_z_ wchar_t, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcslwr, _Inout_z_, wchar_t, _String)
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcslwr_s_l(_Inout_z_cap_(_SizeInWords) wchar_t * _Str, _In_ size_t _SizeInWords, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wcslwr_s_l, _Deref_prepost_z_ wchar_t, _String, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcslwr_l, _wcslwr_s_l, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_, wchar_t, _String, _In_opt_ _locale_t, _Locale)
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcsupr_s(_Inout_z_cap_(_Size) wchar_t * _Str, _In_ size_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wcsupr_s, _Deref_prepost_z_ wchar_t, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsupr, _Inout_z_, wchar_t, _String)
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcsupr_s_l(_Inout_z_cap_(_Size) wchar_t * _Str, _In_ size_t _Size, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wcsupr_s_l, _Deref_prepost_z_ wchar_t, _String, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsupr_l, _wcsupr_s_l, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_, wchar_t, _String, _In_opt_ _locale_t, _Locale)
_Check_return_opt_ _CRTIMP size_t __cdecl wcsxfrm(_Out_opt_cap_(_MaxCount) _Post_maybez_ wchar_t * _Dst, _In_z_ const wchar_t * _Src, _In_ size_t _MaxCount);
_Check_return_opt_ _CRTIMP size_t __cdecl _wcsxfrm_l(_Out_opt_cap_(_MaxCount) _Post_maybez_ wchar_t * _Dst, _In_z_ const wchar_t *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl wcscoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
_Check_return_ _CRTIMP int __cdecl _wcscoll_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wcsicoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
_Check_return_ _CRTIMP int __cdecl _wcsicoll_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t *_Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wcsncoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _wcsncoll_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wcsnicoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _wcsnicoll_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);

#ifdef  __cplusplus
#ifndef _CPP_WIDE_INLINES_DEFINED
#define _CPP_WIDE_INLINES_DEFINED
extern "C++" {
_Check_return_ inline wchar_t * __CRTDECL wcschr(_In_z_ wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
_Check_return_ inline wchar_t * __CRTDECL wcspbrk(_In_z_ wchar_t *_Str, _In_z_ const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
_Check_return_ inline wchar_t * __CRTDECL wcsrchr(_In_z_ wchar_t *_Str, _In_ wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
_Check_return_ inline wchar_t * __CRTDECL wcsstr(_In_z_ wchar_t *_Str, _In_z_ const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#endif
#endif

#if     !__STDC__

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("wcsdup")
#undef wcsdup
#endif

_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsdup) _CRTIMP wchar_t * __cdecl wcsdup(_In_z_ const wchar_t * _Str);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("wcsdup")
#endif

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsicmp) _CRTIMP int __cdecl wcsicmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsnicmp) _CRTIMP int __cdecl wcsnicmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
_CRT_NONSTDC_DEPRECATE(_wcsnset) _CRTIMP wchar_t * __cdecl wcsnset(_Inout_z_cap_(_MaxCount) wchar_t * _Str, _In_ wchar_t _Val, _In_ size_t _MaxCount);
_CRT_NONSTDC_DEPRECATE(_wcsrev) _CRTIMP wchar_t * __cdecl wcsrev(_Inout_z_ wchar_t * _Str);
_CRT_NONSTDC_DEPRECATE(_wcsset) _CRTIMP wchar_t * __cdecl wcsset(_Inout_z_ wchar_t * _Str, wchar_t _Val);
_CRT_NONSTDC_DEPRECATE(_wcslwr) _CRTIMP wchar_t * __cdecl wcslwr(_Inout_z_ wchar_t * _Str);
_CRT_NONSTDC_DEPRECATE(_wcsupr) _CRTIMP wchar_t * __cdecl wcsupr(_Inout_z_ wchar_t * _Str);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsicoll) _CRTIMP int __cdecl wcsicoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_STRING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\wtime.inl ===
/***
*wtime.inl - inline definitions for wctime()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definition of wctime().
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#if !defined(__CRTDECL)
#if defined(_M_CEE_PURE)
#define __CRTDECL
#else
#define __CRTDECL   __cdecl
#endif
#endif

#ifndef _INC_WTIME_INL
#define _INC_WTIME_INL
#ifndef RC_INVOKED

#pragma warning(push)
#pragma warning(disable:4996)

#ifdef _USE_32BIT_TIME_T
static __inline wchar_t * __CRTDECL _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime32(_Time);
#pragma warning( pop )
}

static __inline errno_t __CRTDECL _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime32_s(_Buffer, _SizeInWords, _Time);
}
#else
static __inline wchar_t * __CRTDECL _wctime(const time_t * _Time)
{
#pragma warning( push )
#pragma warning( disable : 4996 )
    return _wctime64(_Time);
#pragma warning( pop )
}

static __inline errno_t __CRTDECL _wctime_s(wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
#endif /* _USE_32BIT_TIME_T */

#pragma warning(pop)

#endif /* RC_INVOKED */
#endif /* _INC_WTIME_INL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\xlocinfo.h ===
/* xlocinfo.h internal header for Microsoft C */
#pragma once
#ifndef _XLOCINFO
#define _XLOCINFO
#include <ctype.h>
#include <locale.h>
#include <wchar.h>
#ifndef _YVALS
 #include <yvals.h>
#endif

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

_C_STD_BEGIN
#ifndef _M_CEE_PURE
_C_LIB_DECL
#endif

		/* SUPPLEMENTAL CTYPE MACROS & DECLARATIONS */
#define _XA		0x100		/* extra alphabetic */
#define _XS		0x000		/* extra space */
#define _BB		_CONTROL	/* BEL, BS, etc. */
#define _CN		_SPACE		/* CR, FF, HT, NL, VT */
#define _DI		_DIGIT		/* '0'-'9' */
#define _LO		_LOWER		/* 'a'-'z' */
#define _PU		_PUNCT		/* punctuation */
#define _SP		_BLANK		/* space */
#define _UP		_UPPER		/* 'A'-'Z' */
#define _XD		_HEX		/* '0'-'9', 'A'-'F', 'a'-'f' */

		/* SUPPLEMENTAL LOCALE MACROS AND DECLARATIONS */
#define _X_ALL			LC_ALL
#define _X_COLLATE		LC_COLLATE
#define _X_CTYPE		LC_CTYPE
#define _X_MONETARY		LC_MONETARY
#define _X_NUMERIC		LC_NUMERIC
#define _X_TIME 		LC_TIME
#define _X_MAX			LC_MAX
#define _X_MESSAGES		6
#define _NCAT			7

#define _CATMASK(n)	((1 << (n)) >> 1)
#define _M_COLLATE	_CATMASK(_X_COLLATE)
#define _M_CTYPE	_CATMASK(_X_CTYPE)
#define _M_MONETARY	_CATMASK(_X_MONETARY)
#define _M_NUMERIC	_CATMASK(_X_NUMERIC)
#define _M_TIME		_CATMASK(_X_TIME)
#define _M_MESSAGES	_CATMASK(_X_MESSAGES)
#define _M_ALL		(_CATMASK(_NCAT) - 1)

typedef struct _Collvec
	{	/* stuff needed by _Strcoll, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Collvec;

typedef struct _Ctypevec
	{	/* stuff needed by _Tolower, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	const short *_Table;
	int _Delfl;
	} _Ctypevec;

typedef struct _Cvtvec
	{	/* stuff needed by _Mbrtowc, etc. */
	unsigned long _Hand;	// LCID
	unsigned int _Page;		// UINT
	} _Cvtvec;

		/* FUNCTION DECLARATIONS */
_CRTIMP2_PURE _Collvec __CLRCALL_PURE_OR_CDECL _Getcoll();
_CRTIMP2_PURE _Ctypevec __CLRCALL_PURE_OR_CDECL _Getctype();
_MRTIMP2 _Cvtvec __cdecl _Getcvt();

_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Getdateorder();

_MRTIMP2 int __cdecl _Mbrtowc(_Out_opt_ wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _Stof(const char *, _Out_opt_ _Deref_post_opt_valid_ char **, long);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Stod(const char *, _Out_opt_ _Deref_post_opt_valid_ char **, long);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _Stold(const char *, _Out_opt_ _Deref_post_opt_valid_ char **, 
  long);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Strxfrm(
  _Out_cap_x_(_End1-_String1) _Post_count_( return) char * _String1, 
  _In_z_ char * _End1, const char *, const char *, const _Collvec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Tolower(int, const _Ctypevec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Toupper(int, const _Ctypevec *);
_MRTIMP2 int __cdecl _Wcrtomb(_Out_ char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
_CRTIMP2_PURE size_t __CLRCALL_PURE_OR_CDECL _Wcsxfrm(
  _Out_cap_x_(_End1-_String1) _Post_count_( return) wchar_t *_String1, 
  _In_z_ wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Getwctype(wchar_t, const _Ctypevec *);
_CRTIMP2_PURE const wchar_t * __CLRCALL_PURE_OR_CDECL _Getwctypes(const wchar_t *, const wchar_t *,
	short*, const _Ctypevec*);
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towlower(wchar_t, const _Ctypevec *);
_CRTIMP2_PURE wchar_t __CLRCALL_PURE_OR_CDECL _Towupper(wchar_t, const _Ctypevec *);
#ifndef _M_CEE_PURE
_END_C_LIB_DECL
#endif
_C_STD_END

_C_LIB_DECL
_CRTIMP void *__cdecl _Gettnames();
_CRTIMP char *__cdecl _Getdays();
_CRTIMP char *__cdecl _Getmonths();
_CRTIMP size_t __cdecl _Strftime(
  _Out_cap_(_Maxsize) char *, _In_ size_t _Maxsize, 
  _In_z_ __format_string const char *, _In_ const struct tm *, void *);
_END_C_LIB_DECL

_C_LIB_DECL
_locale_t __cdecl _GetLocaleForCP(unsigned int);
_END_C_LIB_DECL

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _XLOCINFO */

/*
 * Copyright (c) 1992-2006 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.02:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\xmath.h ===
/* xmath.h internal header for Microsoft C */
#ifndef _XMATH
#define _XMATH
#include <errno.h>
#include <math.h>
#include <stddef.h>
#ifndef _YMATH
 #include <ymath.h>
#endif

_C_STD_BEGIN

		/* FLOAT PROPERTIES */
#define _DBIAS	0x3fe
#define _DOFF	4
#define _FBIAS	0x7e
#define _FOFF	7
#define _FRND	1

 #define _D0	3	/* little-endian, small long doubles */
 #define _D1	2
 #define _D2	1
 #define _D3	0
 #define _DLONG	0
 #define _LBIAS	0x3fe
 #define _LOFF	4

		/* IEEE 754 double properties */
#define _DFRAC	((unsigned short)((1 << _DOFF) - 1))
#define _DMASK	((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX	((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN	((unsigned short)0x8000)
#define DSIGN(x)	(((unsigned short *)&(x))[_D0] & _DSIGN)
#define HUGE_EXP	(int)(_DMAX * 900L / 1000)
#define HUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define SAFE_EXP	((unsigned short)(_DMAX >> 1))

		/* IEEE 754 float properties */
#define _FFRAC	((unsigned short)((1 << _FOFF) - 1))
#define _FMASK	((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX	((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN	((unsigned short)0x8000)
#define FSIGN(x)	(((unsigned short *)&(x))[_F0] & _FSIGN)
#define FHUGE_EXP	(int)(_FMAX * 900L / 1000)
#define FHUGE_RAD	31.8	/* ~ 2^10 / pi */
#define FSAFE_EXP	((unsigned short)(_FMAX >> 1))

 #define _F0	1	/* little-endian order */
 #define _F1	0

		/* IEEE 754 long double properties */
#define _LFRAC	((unsigned short)(-1))
#define _LMASK	((unsigned short)0x7fff)
#define _LMAX	((unsigned short)0x7fff)
#define _LSIGN	((unsigned short)0x8000)
#define LSIGN(x)	(((unsigned short *)&(x))[_L0] & _LSIGN)
#define LHUGE_EXP	(int)(_LMAX * 900L / 1000)
#define LHUGE_RAD	2.73e9	/* ~ 2^33 / pi */
#define LSAFE_EXP	((unsigned short)(_LMAX >> 1))

 #define _L0	3	/* little-endian, small long doubles */
 #define _L1	2
 #define _L2	1
 #define _L3	0
 #define _L4	xxx

		/* return values for testing functions */
#define FINITE	_FINITE
#define INF		_INFCODE
#define NAN		_NANCODE

#ifndef _M_CEE_PURE
_C_LIB_DECL
#endif

		/* double declarations */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dnorm(unsigned short *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dscale(double *, long);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Poly(double, const double *, int);

extern _CRTIMP2_PURE /* const */ _Dconst _Eps, _Rteps;
extern _CRTIMP2_PURE /* const */ double _Xbig;

		/* float declarations */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDnorm(unsigned short *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDscale(float *, long);

extern _CRTIMP2_PURE /* const */ _Dconst _FEps, _FRteps;
extern _CRTIMP2_PURE /* const */ float _FXbig;

		/* long double functions */
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDnorm(unsigned short *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDscale(long double *, long);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LPoly(long double, const long double *, int);

extern _CRTIMP2_PURE /* const */ _Dconst _LEps, _LRteps;
extern _CRTIMP2_PURE /* const */ long double _LXbig;
#ifndef _M_CEE_PURE
_END_C_LIB_DECL
#endif
_C_STD_END
#endif /* _XMATH */

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\vadefs.h ===
/***
*vadefs.h - defines helper macros for stdarg.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is a helper file for stdarg.h
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_VADEFS
#define _INC_VADEFS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#undef _CRT_PACKING
#define _CRT_PACKING 8
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
#ifdef _M_CEE_PURE
typedef System::ArgIterator va_list;
#else
typedef char *  va_list;
#endif /* _M_CEE_PURE */
#define _VA_LIST_DEFINED
#endif

#ifdef  __cplusplus
#define _ADDRESSOF(v)   ( &reinterpret_cast<const char &>(v) )
#else
#define _ADDRESSOF(v)   ( &(v) )
#endif

#if     defined(_M_IA64) && !defined(_M_CEE_PURE)
#define _VA_ALIGN       8
#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define _VA_STRUCT_ALIGN  16 

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
        - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#else
#define _SLOTSIZEOF(t)   (sizeof(t))
#define _APALIGN(t,ap)  (__alignof(t))
#endif

#if     defined(_M_CEE)

extern void __cdecl __va_start(va_list*, ...);
extern void * __cdecl __va_arg(va_list*, ...);
extern void __cdecl __va_end(va_list*);

#define _crt_va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), \
                                __alignof(v), _ADDRESSOF(v)) )
#define _crt_va_arg(ap,t)    ( *(t *)__va_arg(&ap, _SLOTSIZEOF(t), \
                                _APALIGN(t,ap), (t *)0) )
#define _crt_va_end(ap)      ( __va_end(&ap) )

#elif   defined(_M_IX86)

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define _crt_va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define _crt_va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _crt_va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_IA64)

#ifdef  __cplusplus
extern void __cdecl __va_start(va_list*, ...);
#define _crt_va_start(ap,v)  ( __va_start(&ap, _ADDRESSOF(v), _SLOTSIZEOF(v), \
                          _ADDRESSOF(v)) )
#else
#define _crt_va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _SLOTSIZEOF(v) )
#endif

#define _crt_va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define _crt_va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)


extern void __cdecl __va_start(va_list *, ...);

#define _crt_va_start(ap, x) ( __va_start(&ap, x) )
#define _crt_va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define _crt_va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)   ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define _crt_va_start(ap,v)  ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define _crt_va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _crt_va_end(ap)      ( ap = (va_list)0 )

#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_VADEFS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines XENIX style macros for accessing arguments of a
*       function which takes a variable number of arguments.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_VARARGS
#define _INC_VARARGS

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#include <crtdefs.h>

#ifdef  _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

#if     __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef _W64 unsigned int   uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _VA_LIST_DEFINED
#ifdef _M_CEE_PURE
typedef System::ArgIterator va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef va_arg

#if     defined(_M_CEE)

#error varargs.h not supported when targetting _M_CEE (use stdarg.h)

#elif   defined(_M_IX86)

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */
#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t)    ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#elif defined(_M_IA64)

#ifndef _VA_LIST
#define _VA_LIST char*
#endif
typedef _VA_LIST va_list;

#define _VA_STRUCT_ALIGN  16 

#define _VA_ALIGN       8

#define _ALIGNOF(ap) ((((ap)+_VA_STRUCT_ALIGN - 1) & ~(_VA_STRUCT_ALIGN -1)) \
                            - (ap))
#define _APALIGN(t,ap)  (__alignof(t) > 8 ? _ALIGNOF((uintptr_t) ap) : 0)

#define _SLOTSIZEOF(t)   ( (sizeof(t) + _VA_ALIGN - 1) & ~(_VA_ALIGN - 1) )

#define va_dcl __int64  va_alist;

#define va_start(ap)    ( ap = (va_list)&va_alist )

#define va_arg(ap,t)    (*(t *)((ap += _SLOTSIZEOF(t)+ _APALIGN(t,ap)) \
                                                     -_SLOTSIZEOF(t)))

#define va_end(ap)      ( ap = (va_list)0 )

#elif defined(_M_AMD64)

extern void __cdecl __va_start(va_list *, ...);

#define va_dcl          va_list va_alist;

#define va_start(ap)   ( __va_start(&ap, 0) )

#define va_arg(ap, t)   \
    ( ( sizeof(t) > sizeof(__int64) || ( sizeof(t) & (sizeof(t) - 1) ) != 0 ) \
        ? **(t **)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) \
        :  *(t  *)( ( ap += sizeof(__int64) ) - sizeof(__int64) ) )
#define va_end(ap)      ( ap = (va_list)0 )

#else

/* A guess at the proper definitions for other platforms */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0


#endif

#endif


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_VARARGS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\wchar.h ===
/***
*wchar.h - declarations for wide character functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all wide character-related functions.  They may also be declared in
*       individual header files on a functional basis.
*       [ISO]
*
*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif


#ifndef _INC_WCHAR
#define _INC_WCHAR

#include <crtdefs.h>

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif

/*
 *  According to the standard, WCHAR_MIN and WCHAR_MAX need to be
 *  "constant expressions suitable for use in #if preprocessing directives, 
 *  and this expression shall have the same type as would an expression that 
 *  is an object of the corresponding type converted according to the integer
 *  promotions".
 */
#define WCHAR_MIN       0
#define WCHAR_MAX       0xffff

#ifndef _VA_LIST_DEFINED
#ifdef _M_CEE_PURE
typedef System::ArgIterator va_list;
#else
typedef char *  va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
        char *_ptr;
        int   _cnt;
        char *_base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif

/* Declare _iob[] array */

#ifndef _STDIO_DEFINED
_CRTIMP FILE * __cdecl __iob_func(void);
#endif  /* _STDIO_DEFINED */

#ifndef _STDSTREAM_DEFINED
#define stdin  (&__iob_func()[0])
#define stdout (&__iob_func()[1])
#define stderr (&__iob_func()[2])
#define _STDSTREAM_DEFINED
#endif 

#ifndef _FSIZE_T_DEFINED
typedef unsigned long _fsize_t; /* Could be 64 bits for Win32 */
#define _FSIZE_T_DEFINED
#endif

#ifndef _WFINDDATA_T_DEFINED

struct _wfinddata32_t {
        unsigned    attrib;
        __time32_t  time_create;    /* -1 for FAT file systems */
        __time32_t  time_access;    /* -1 for FAT file systems */
        __time32_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata32i64_t {
        unsigned    attrib;
        __time32_t  time_create;    /* -1 for FAT file systems */
        __time32_t  time_access;    /* -1 for FAT file systems */
        __time32_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

struct _wfinddata64i32_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        _fsize_t    size;
        wchar_t     name[260];
};

struct _wfinddata64_t {
        unsigned    attrib;
        __time64_t  time_create;    /* -1 for FAT file systems */
        __time64_t  time_access;    /* -1 for FAT file systems */
        __time64_t  time_write;
        __int64     size;
        wchar_t     name[260];
};

#ifdef _USE_32BIT_TIME_T
#define _wfinddata_t    _wfinddata32_t
#define _wfinddatai64_t _wfinddata32i64_t

#define _wfindfirst     _wfindfirst32
#define _wfindnext      _wfindnext32
#define _wfindfirsti64  _wfindfirst32i64
#define _wfindnexti64   _wfindnext32i64

#else                  
#define _wfinddata_t    _wfinddata64i32_t
#define _wfinddatai64_t _wfinddata64_t

#define _wfindfirst     _wfindfirst64i32
#define _wfindnext      _wfindnext64i32
#define _wfindfirsti64  _wfindfirst64
#define _wfindnexti64   _wfindnext64

#endif

#define _WFINDDATA_T_DEFINED
#endif


/* define NULL pointer value */
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#ifndef _CONST_RETURN
#ifdef  __cplusplus
#define _CONST_RETURN  const
#define _CRT_CONST_CORRECT_OVERLOADS
#else
#define _CONST_RETURN
#endif
#endif

/* For backwards compatibility */
#define _WConst_return _CONST_RETURN

#ifndef _CRT_CTYPEDATA_DEFINED
#define _CRT_CTYPEDATA_DEFINED
#ifndef _CTYPE_DISABLE_MACROS

#ifndef __PCTYPE_FUNC
#if defined(_CRT_DISABLE_PERFCRIT_LOCKS) && !defined(_DLL)
#define __PCTYPE_FUNC  _pctype
#else
#define __PCTYPE_FUNC   __pctype_func()
#endif  
#endif  /* __PCTYPE_FUNC */

_CRTIMP const unsigned short * __cdecl __pctype_func(void);
#if !defined(_M_CEE_PURE)
_CRTIMP extern const unsigned short *_pctype;
#else
#define _pctype (__pctype_func())
#endif /* !defined(_M_CEE_PURE) */
#endif  /* _CTYPE_DISABLE_MACROS */
#endif

#ifndef _CRT_WCTYPEDATA_DEFINED
#define _CRT_WCTYPEDATA_DEFINED
#ifndef _CTYPE_DISABLE_MACROS
#if !defined(_M_CEE_PURE)
_CRTIMP extern const unsigned short _wctype[];
#endif /* !defined(_M_CEE_PURE) */

_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
#if !defined(_M_CEE_PURE)
_CRTIMP extern const wctype_t *_pwctype;
#else
#define _pwctype (__pwctype_func())
#endif /* !defined(_M_CEE_PURE) */
#endif  /* _CTYPE_DISABLE_MACROS */
#endif

/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_Check_return_ _CRTIMP int __cdecl iswalpha(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswalpha_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswupper(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswupper_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswlower(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswlower_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswdigit(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswxdigit(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswspace(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswspace_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswpunct(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswpunct_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswalnum(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswalnum_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswprint(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswprint_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswgraph(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswgraph_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswcntrl(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswcntrl_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswascii(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl isleadbyte(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isleadbyte_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_Check_return_ _CRTIMP wint_t __cdecl towupper(_In_ wint_t _C);
_Check_return_ _CRTIMP wint_t __cdecl _towupper_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP wint_t __cdecl towlower(_In_ wint_t _C);
_Check_return_ _CRTIMP wint_t __cdecl _towlower_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale); 
_Check_return_ _CRTIMP int __cdecl iswctype(_In_ wint_t _C, _In_ wctype_t _Type);
_Check_return_ _CRTIMP int __cdecl _iswctype_l(_In_ wint_t _C, _In_ wctype_t _Type, _In_opt_ _locale_t _Locale);

_Check_return_ _CRTIMP int __cdecl __iswcsymf(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswcsymf_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl __iswcsym(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswcsym_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);

_CRT_OBSOLETE(iswctype) _CRTIMP int __cdecl is_wctype(_In_ wint_t _C, _In_ wctype_t _Type);

#define _WCTYPE_DEFINED
#endif

#ifndef _WDIRECT_DEFINED

/* also declared in direct.h */

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wgetcwd")
#pragma push_macro("_wgetdcwd")
#pragma push_macro("_wgetdcwd_nolock")
#undef _wgetcwd
#undef _wgetdcwd
#undef _wgetdcwd_nolock
#endif

_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wgetcwd(_Out_opt_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ int _SizeInWords);
_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wgetdcwd(_In_ int _Drive, _Out_opt_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ int _SizeInWords);
_Check_return_ _Ret_opt_z_ wchar_t * __cdecl _wgetdcwd_nolock(_In_ int _Drive, _Out_opt_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ int _SizeInWords);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wgetcwd")
#pragma pop_macro("_wgetdcwd")
#pragma pop_macro("_wgetdcwd_nolock")
#endif

_Check_return_ _CRTIMP int __cdecl _wchdir(_In_z_ const wchar_t * _Path);
_Check_return_ _CRTIMP int __cdecl _wmkdir(_In_z_ const wchar_t * _Path);
_Check_return_ _CRTIMP int __cdecl _wrmdir(_In_z_ const wchar_t * _Path);

#define _WDIRECT_DEFINED
#endif

#ifndef _WIO_DEFINED

_Check_return_ _CRTIMP int __cdecl _waccess(_In_z_ const wchar_t * _Filename, _In_ int _AccessMode);
_Check_return_wat_ _CRTIMP errno_t __cdecl _waccess_s(_In_z_ const wchar_t * _Filename, _In_ int _AccessMode);
_Check_return_ _CRTIMP int __cdecl _wchmod(_In_z_ const wchar_t * _Filename, _In_ int _Mode);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wcreat(_In_z_ const wchar_t * _Filename, _In_ int _PermissionMode);
_Check_return_ _CRTIMP intptr_t __cdecl _wfindfirst32(_In_z_ const wchar_t * _Filename, _Out_ struct _wfinddata32_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wfindnext32(_In_ intptr_t _FindHandle, _Out_ struct _wfinddata32_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wunlink(_In_z_ const wchar_t * _Filename);
_Check_return_ _CRTIMP int __cdecl _wrename(_In_z_ const wchar_t * _OldFilename, _In_z_ const wchar_t * _NewFilename);
_CRTIMP errno_t __cdecl _wmktemp_s(_Inout_z_cap_(_SizeInWords) wchar_t * _TemplateName, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wmktemp_s, wchar_t, _TemplateName)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wmktemp, _Inout_z_, wchar_t, _TemplateName)

_Check_return_ _CRTIMP intptr_t __cdecl _wfindfirst32i64(_In_z_ const wchar_t * _Filename, _Out_ struct _wfinddata32i64_t * _FindData);
_Check_return_ _CRTIMP intptr_t __cdecl _wfindfirst64i32(_In_z_ const wchar_t * _Filename, _Out_ struct _wfinddata64i32_t * _FindData);
_Check_return_ _CRTIMP intptr_t __cdecl _wfindfirst64(_In_z_ const wchar_t * _Filename, _Out_ struct _wfinddata64_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wfindnext32i64(_In_ intptr_t _FindHandle, _Out_ struct _wfinddata32i64_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wfindnext64i32(_In_ intptr_t _FindHandle, _Out_ struct _wfinddata64i32_t * _FindData);
_Check_return_ _CRTIMP int __cdecl _wfindnext64(_In_ intptr_t _FindHandle, _Out_ struct _wfinddata64_t * _FindData);

_Check_return_wat_ _CRTIMP errno_t __cdecl _wsopen_s(_Out_ int * _FileHandle, _In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, _In_ int _ShareFlag, _In_ int _PermissionFlag);

#if !defined(__cplusplus) || !defined(_M_IX86)

_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wopen(_In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wsopen(_In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, int _ShareFlag, ...);

#else

/* these function do not validate pmode; use _sopen_s */
extern "C++" _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wopen(_In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, _In_ int _PermissionMode = 0);
extern "C++" _CRT_INSECURE_DEPRECATE(_wsopen_s) _CRTIMP int __cdecl _wsopen(_In_z_ const wchar_t * _Filename, _In_ int _OpenFlag, _In_ int _ShareFlag, int _PermissionMode = 0);

#endif

#define _WIO_DEFINED
#endif

#ifndef _WLOCALE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

_Check_return_opt_ _CRTIMP wchar_t * __cdecl _wsetlocale(_In_ int _Category, _In_opt_z_ const wchar_t * _Locale);

#define _WLOCALE_DEFINED
#endif

#ifndef _WPROCESS_DEFINED

/* also declared in process.h */

_CRTIMP intptr_t __cdecl _wexecl(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wexecle(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wexeclp(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wexeclpe(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wexecv(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList);
_CRTIMP intptr_t __cdecl _wexecve(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList,
        _In_opt_z_ const wchar_t * const * _Env);
_CRTIMP intptr_t __cdecl _wexecvp(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList);
_CRTIMP intptr_t __cdecl _wexecvpe(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList, 
        _In_opt_z_ const wchar_t * const * _Env);
_CRTIMP intptr_t __cdecl _wspawnl(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wspawnle(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wspawnlp(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wspawnlpe(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _ArgList, ...);
_CRTIMP intptr_t __cdecl _wspawnv(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList);
_CRTIMP intptr_t __cdecl _wspawnve(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList,
        _In_opt_z_ const wchar_t * const * _Env);
_CRTIMP intptr_t __cdecl _wspawnvp(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList);
_CRTIMP intptr_t __cdecl _wspawnvpe(_In_ int _Mode, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * const * _ArgList,
        _In_opt_z_ const wchar_t * const * _Env);
#ifndef _CRT_WSYSTEM_DEFINED
#define _CRT_WSYSTEM_DEFINED
_CRTIMP int __cdecl _wsystem(_In_opt_z_ const wchar_t * _Command);
#endif

#define _WPROCESS_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED

#undef _CRT_WCTYPE_NOINLINE

#if !defined(__cplusplus) || defined(_M_CEE_PURE) || defined(MRTDLL) || defined(_CRT_WCTYPE_NOINLINE)
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define _iswalpha_l(_c,_p)    ( _iswctype_l(_c,_ALPHA, _p) )
#define _iswupper_l(_c,_p)    ( _iswctype_l(_c,_UPPER, _p) )
#define _iswlower_l(_c,_p)    ( _iswctype_l(_c,_LOWER, _p) )
#define _iswdigit_l(_c,_p)    ( _iswctype_l(_c,_DIGIT, _p) )
#define _iswxdigit_l(_c,_p)   ( _iswctype_l(_c,_HEX, _p) )
#define _iswspace_l(_c,_p)    ( _iswctype_l(_c,_SPACE, _p) )
#define _iswpunct_l(_c,_p)    ( _iswctype_l(_c,_PUNCT, _p) )
#define _iswalnum_l(_c,_p)    ( _iswctype_l(_c,_ALPHA|_DIGIT, _p) )
#define _iswprint_l(_c,_p)    ( _iswctype_l(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT, _p) )
#define _iswgraph_l(_c,_p)    ( _iswctype_l(_c,_PUNCT|_ALPHA|_DIGIT, _p) )
#define _iswcntrl_l(_c,_p)    ( _iswctype_l(_c,_CONTROL, _p) )
#ifndef _CTYPE_DISABLE_MACROS
#define isleadbyte(_c)  ( __PCTYPE_FUNC[(unsigned char)(_c)] & _LEADBYTE)
#endif  /* _CTYPE_DISABLE_MACROS */

#elif   0         /* __cplusplus */
_Check_return_ inline int iswalpha(_In_ wint_t _C) {return (iswctype(_C,_ALPHA)); }
_Check_return_ inline int iswupper(_In_ wint_t _C) {return (iswctype(_C,_UPPER)); }
_Check_return_ inline int iswlower(_In_ wint_t _C) {return (iswctype(_C,_LOWER)); }
_Check_return_ inline int iswdigit(_In_ wint_t _C) {return (iswctype(_C,_DIGIT)); }
_Check_return_ inline int iswxdigit(_In_ wint_t _C) {return (iswctype(_C,_HEX)); }
_Check_return_ inline int iswspace(_In_ wint_t _C) {return (iswctype(_C,_SPACE)); }
_Check_return_ inline int iswpunct(_In_ wint_t _C) {return (iswctype(_C,_PUNCT)); }
_Check_return_ inline int iswalnum(_In_ wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
_Check_return_ inline int iswprint(_In_ wint_t _C) {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
_Check_return_ inline int iswgraph(_In_ wint_t _C) {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
_Check_return_ inline int iswcntrl(_In_ wint_t _C) {return (iswctype(_C,_CONTROL)); }
_Check_return_ inline int iswascii(_In_ wint_t _C) {return ((unsigned)(_C) < 0x80); }

_Check_return_ inline int __CRTDECL _iswalpha_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_ALPHA, _Locale)); }
_Check_return_ inline int __CRTDECL _iswupper_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_UPPER, _Locale)); }
_Check_return_ inline int __CRTDECL _iswlower_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_LOWER, _Locale)); }
_Check_return_ inline int __CRTDECL _iswdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_DIGIT, _Locale)); }
_Check_return_ inline int __CRTDECL _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return(_iswctype_l(_C,_HEX, _Locale)); }
_Check_return_ inline int __CRTDECL _iswspace_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_SPACE, _Locale)); }
_Check_return_ inline int __CRTDECL _iswpunct_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_PUNCT, _Locale)); }
_Check_return_ inline int __CRTDECL _iswalnum_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_ALPHA|_DIGIT, _Locale)); }
_Check_return_ inline int __CRTDECL _iswprint_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT, _Locale)); }
_Check_return_ inline int __CRTDECL _iswgraph_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_PUNCT|_ALPHA|_DIGIT, _Locale)); }
_Check_return_ inline int __CRTDECL _iswcntrl_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale) {return (_iswctype_l(_C,_CONTROL, _Locale)); }

_Check_return_ inline int isleadbyte(int _C) {return (__PCTYPE_FUNC[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */


#ifndef _POSIX_

/* define structure for returning status information */

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif
#define _INO_T_DEFINED
#endif

#ifndef _DEV_T_DEFINED
typedef unsigned int _dev_t;        /* device code */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif
#define _DEV_T_DEFINED
#endif

#ifndef _OFF_T_DEFINED
typedef long _off_t;                /* file offset value */
#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif
#define _OFF_T_DEFINED
#endif

#ifndef _STAT_DEFINED

struct _stat32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

struct _stat32i64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

struct _stat64i32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

struct _stat64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

/*
 * We have to have same name for structure and the fuction so as to do the
 * macro magic.we need the structure name and function name the same.
 */
#define __stat64    _stat64

#ifdef _USE_32BIT_TIME_T
#define _fstat      _fstat32
#define _fstati64   _fstat32i64
#define _stat       _stat32
#define _stati64    _stat32i64
#define _wstat      _wstat32
#define _wstati64   _wstat32i64

#else
#define _fstat      _fstat64i32
#define _fstati64   _fstat64
#define _stat       _stat64i32
#define _stati64    _stat64
#define _wstat      _wstat64i32
#define _wstati64   _wstat64

#endif


#define _STAT_DEFINED
#endif

#ifndef _WSTAT_DEFINED

/* also declared in wchar.h */

_CRTIMP int __cdecl _wstat32(_In_z_ const wchar_t * _Name, _Out_ struct _stat32 * _Stat);

_CRTIMP int __cdecl _wstat32i64(_In_z_ const wchar_t * _Name, _Out_ struct _stat32i64 * _Stat);
_CRTIMP int __cdecl _wstat64i32(_In_z_ const wchar_t * _Name, _Out_ struct _stat64i32 * _Stat);
_CRTIMP int __cdecl _wstat64(_In_z_ const wchar_t * _Name, _Out_ struct _stat64 * _Stat);

#define _WSTAT_DEFINED
#endif

#endif  /* !_POSIX_ */


#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in conio.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

_Check_return_wat_ _CRTIMP errno_t __cdecl _cgetws_s(_Out_cap_post_count_(_SizeInWords, *_SizeRead) wchar_t * _Buffer, size_t _SizeInWords, _Out_ size_t * _SizeRead);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _cgetws_s, _Deref_post_count_(*_Buffer) wchar_t, _Buffer, size_t *, _Size)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(wchar_t *, _CRTIMP, _cgetws, _Inout_z_, wchar_t, _Buffer)
_Check_return_ _CRTIMP wint_t __cdecl _getwch(void);
_Check_return_ _CRTIMP wint_t __cdecl _getwche(void);
_Check_return_ _CRTIMP wint_t __cdecl _putwch(wchar_t _WCh);
_Check_return_ _CRTIMP wint_t __cdecl _ungetwch(wint_t _WCh);
_Check_return_opt_ _CRTIMP int __cdecl _cputws(_In_z_ const wchar_t * _String);
_Check_return_opt_ _CRTIMP int __cdecl _cwprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cwprintf_s(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_cwscanf_s) _CRTIMP int __cdecl _cwscanf(_In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_cwscanf_s_l) _CRTIMP int __cdecl _cwscanf_l(_In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cwscanf_s(_In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cwscanf_s_l(_In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vcwprintf(_In_z_ _Printf_format_string_ const wchar_t *_Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vcwprintf_s(_In_z_ _Printf_format_string_ const wchar_t *_Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _cwprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vcwprintf_p(_In_z_ _Printf_format_string_ const wchar_t*  _Format, va_list _ArgList);

_CRTIMP int __cdecl _cwprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_CRTIMP int __cdecl _cwprintf_s_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_CRTIMP int __cdecl _vcwprintf_l(_In_z_ _Printf_format_string_ const wchar_t *_Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_CRTIMP int __cdecl _vcwprintf_s_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_CRTIMP int __cdecl _cwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_CRTIMP int __cdecl _vcwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ wint_t __cdecl _putwch_nolock(wchar_t _WCh);
_Check_return_ wint_t __cdecl _getwch_nolock(void);
_Check_return_ wint_t __cdecl _getwche_nolock(void);
_Check_return_opt_ wint_t __cdecl _ungetwch_nolock(wint_t _WCh);

#if !defined(_MT)
#define _putwch()               _putwch_nolock()
#define _getwch()               _getwch_nolock()
#define _getwche()              _getwche_nolock()
#define _ungetwch()             _ungetwch_nolock()
#endif

#define _WCONIO_DEFINED
#endif  /* _WCONIO_DEFINED */

#ifndef _WSTDIO_DEFINED

/* wide function prototypes, also declared in stdio.h  */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

#ifdef  _POSIX_
_Check_return_ _CRTIMP FILE * __cdecl _wfsopen(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode);
#else
_Check_return_ _CRTIMP FILE * __cdecl _wfsopen(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode, _In_ int _ShFlag);
#endif

_Check_return_opt_ _CRTIMP wint_t __cdecl fgetwc(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl _fgetwchar(void);
_Check_return_opt_ _CRTIMP wint_t __cdecl fputwc(_In_ wchar_t _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl _fputwchar(_In_ wchar_t _Ch);
_Check_return_ _CRTIMP wint_t __cdecl getwc(_Inout_ FILE * _File);
_Check_return_ _CRTIMP wint_t __cdecl getwchar(void);
_Check_return_opt_ _CRTIMP wint_t __cdecl putwc(_In_ wchar_t _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl putwchar(_In_ wchar_t _Ch);
_Check_return_opt_ _CRTIMP wint_t __cdecl ungetwc(_In_ wint_t _Ch, _Inout_ FILE * _File);

_Check_return_opt_ _CRTIMP wchar_t * __cdecl fgetws(_Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ int _SizeInWords, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP int __cdecl fputws(_In_z_ const wchar_t * _Str, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wchar_t * __cdecl _getws_s(_Out_z_cap_(_SizeInWords) wchar_t * _Str, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(wchar_t *, _getws_s, wchar_t, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_SAME, _CRTIMP, _getws, _Pre_notnull_ _Post_z_, wchar_t, _String)
_Check_return_opt_ _CRTIMP int __cdecl _putws(_In_z_ const wchar_t * _Str);

_Check_return_opt_ _CRTIMP int __cdecl fwprintf(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl fwprintf_s(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#endif
_Check_return_opt_ _CRTIMP int __cdecl wprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl wprintf_s(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#endif
_Check_return_ _CRTIMP int __cdecl _scwprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl vfwprintf(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl vfwprintf_s(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#endif
_Check_return_opt_ _CRTIMP int __cdecl vwprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl vwprintf_s(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#endif

#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE int __cdecl swprintf_s(_Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int, swprintf_s, vswprintf_s, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
#if __STDC_WANT_SECURE_LIB__
_CRTIMP_ALTERNATIVE int __cdecl vswprintf_s(_Out_z_cap_(_SizeInWords) wchar_t * _Dst, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vswprintf_s, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format, va_list, _Args)

_Check_return_opt_ _CRTIMP int __cdecl _swprintf_c(_Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vswprintf_c(_Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snwprintf_s(_Out_z_cap_(_DstSizeInWords) wchar_t * _DstBuf, _In_ size_t _DstSizeInWords, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int, _snwprintf_s, _vsnwprintf_s, wchar_t, _Dest, _In_ size_t, _Count, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _vsnwprintf_s(_Out_z_cap_(_DstSizeInWords) wchar_t * _DstBuf, _In_ size_t _DstSizeInWords, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int, _vsnwprintf_s, wchar_t, _Dest, _In_ size_t, _Count, _In_z_ _Printf_format_string_ const wchar_t *, _Format, va_list, _Args)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _CRTIMP, _snwprintf, _vsnwprintf, _Pre_notnull_ _Post_maybez_ wchar_t, _Out_cap_(_Count) _Post_maybez_, wchar_t, _Dest, _In_ size_t, _Count, _In_z_ _Printf_format_string_ const wchar_t *, _Format)

_Check_return_opt_ _CRTIMP int __cdecl _fwprintf_p(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _wprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vfwprintf_p(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vwprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _swprintf_p(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vswprintf_p(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
_Check_return_ _CRTIMP int __cdecl _scwprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_ _CRTIMP int __cdecl _vscwprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _wprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _wprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _wprintf_s_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vwprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vwprintf_s_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _fwprintf_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _fwprintf_p_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _fwprintf_s_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vfwprintf_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vfwprintf_p_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vfwprintf_s_l(_Inout_ FILE * _File, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _swprintf_c_l(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _swprintf_p_l(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _swprintf_s_l(_Out_z_cap_(_DstSize) wchar_t * _DstBuf, _In_ size_t _DstSize, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vswprintf_c_l(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vswprintf_p_l(_Out_z_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _vswprintf_s_l(_Out_z_cap_(_DstSize) wchar_t * _DstBuf, _In_ size_t _DstSize, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_ _CRTIMP int __cdecl _scwprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRTIMP int __cdecl _scwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRTIMP int __cdecl _vscwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwprintf_s_l) _CRTIMP int __cdecl _snwprintf_l(_Out_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snwprintf_s_l(_Out_z_cap_(_DstSize) wchar_t * _DstBuf, _In_ size_t _DstSize, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_vsnwprintf_s_l) _CRTIMP int __cdecl _vsnwprintf_l(_Out_cap_(_MaxCount) wchar_t * _DstBuf, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _vsnwprintf_s_l(_Out_z_cap_(_DstSize) wchar_t * _DstBuf, _In_ size_t _DstSize, _In_ size_t _MaxCount, _In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

#ifndef _CRT_NON_CONFORMING_SWPRINTFS

#define _SWPRINTFS_DEPRECATED _CRT_DEPRECATE_TEXT("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")

#else

#define _SWPRINTFS_DEPRECATED 

#endif /* ifndef _CRT_NON_CONFORMING_SWPRINTFS */

/* we could end up with a double deprecation, disable warnings 4141 and 4996 */
#pragma warning(push)
#pragma warning(disable:4141 4996)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, _swprintf, _swprintf_s, _vswprintf, vswprintf_s, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(int, __RETURN_POLICY_SAME, _SWPRINTFS_DEPRECATED _CRTIMP, __swprintf_l, __vswprintf_l, _vswprintf_s_l, _Pre_notnull_ _Post_z_ wchar_t, _Out_, wchar_t, _Dest, _In_z_ _Printf_format_string_ const wchar_t *, _Format, _locale_t, _Plocinfo)
#pragma warning(pop)

#if !defined(RC_INVOKED) && !defined(__midl)
#include <swprintf.inl>
#endif

#ifdef _CRT_NON_CONFORMING_SWPRINTFS
#ifndef __cplusplus
#define swprintf _swprintf
#define vswprintf _vswprintf
#define _swprintf_l __swprintf_l
#define _vswprintf_l __vswprintf_l
#endif
#endif

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wtempnam")
#undef _wtempnam
#endif

_Check_return_ _CRTIMP wchar_t * __cdecl _wtempnam(_In_opt_z_ const wchar_t * _Directory, _In_opt_z_ const wchar_t * _FilePrefix);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wtempnam")
#endif

_Check_return_ _CRTIMP int __cdecl _vscwprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, va_list _ArgList);
_Check_return_ _CRTIMP int __cdecl _vscwprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_ _CRT_INSECURE_DEPRECATE(fwscanf_s) _CRTIMP int __cdecl fwscanf(_Inout_ FILE * _File, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_fwscanf_s_l) _CRTIMP int __cdecl _fwscanf_l(_Inout_ FILE * _File, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP int __cdecl fwscanf_s(_Inout_ FILE * _File, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
#endif
_Check_return_opt_ _CRTIMP int __cdecl _fwscanf_s_l(_Inout_ FILE * _File, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(swscanf_s) _CRTIMP int __cdecl swscanf(_In_z_ const wchar_t * _Src, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_swscanf_s_l) _CRTIMP int __cdecl _swscanf_l(_In_z_ const wchar_t * _Src, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl swscanf_s(_In_z_ const wchar_t *_Src, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
#endif
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _swscanf_s_l(_In_z_ const wchar_t * _Src, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwscanf_s) _CRTIMP int __cdecl _snwscanf(_In_count_(_MaxCount) _Pre_z_ const wchar_t * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_snwscanf_s_l) _CRTIMP int __cdecl _snwscanf_l(_In_count_(_MaxCount) _Pre_z_ const wchar_t * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snwscanf_s(_In_count_(_MaxCount) _Pre_z_ const wchar_t * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _snwscanf_s_l(_In_count_(_MaxCount) _Pre_z_ const wchar_t * _Src, _In_ size_t _MaxCount, _In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRT_INSECURE_DEPRECATE(wscanf_s) _CRTIMP int __cdecl wscanf(_In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_wscanf_s_l) _CRTIMP int __cdecl _wscanf_l(_In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
#if __STDC_WANT_SECURE_LIB__
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl wscanf_s(_In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
#endif
_Check_return_opt_ _CRTIMP_ALTERNATIVE int __cdecl _wscanf_s_l(_In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);

_Check_return_ _CRTIMP FILE * __cdecl _wfdopen(_In_ int _FileHandle , _In_z_ const wchar_t * _Mode);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wfopen_s) _CRTIMP FILE * __cdecl _wfopen(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wfopen_s(_Deref_out_opt_ FILE ** _File, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wfreopen_s) _CRTIMP FILE * __cdecl _wfreopen(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode, _Inout_ FILE * _OldFile);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wfreopen_s(_Deref_out_opt_ FILE ** _File, _In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _Mode, _Inout_ FILE * _OldFile);

#ifndef _CRT_WPERROR_DEFINED
#define _CRT_WPERROR_DEFINED
_CRTIMP void __cdecl _wperror(_In_opt_z_ const wchar_t * _ErrMsg);
#endif 
_Check_return_ _CRTIMP FILE * __cdecl _wpopen(_In_z_ const wchar_t *_Command, _In_z_ const wchar_t * _Mode);
_Check_return_ _CRTIMP int __cdecl _wremove(_In_z_ const wchar_t * _Filename);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wtmpnam_s(_Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wtmpnam_s, _Deref_post_z_ wchar_t, _Buffer)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wtmpnam, _Pre_maybenull_ _Post_z_, wchar_t, _Buffer)

_Check_return_opt_ _CRTIMP wint_t __cdecl _fgetwc_nolock(_Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl _fputwc_nolock(_In_ wchar_t _Ch, _Inout_ FILE * _File);
_Check_return_opt_ _CRTIMP wint_t __cdecl _ungetwc_nolock(_In_ wint_t _Ch, _Inout_ FILE * _File);

#undef _CRT_GETPUTWCHAR_NOINLINE

#if !defined(__cplusplus) || defined(_M_CEE_PURE) || defined(_CRT_GETPUTWCHAR_NOINLINE)
#define getwchar()      fgetwc(stdin)
#define putwchar(_c)    fputwc((_c),stdout)
#else   /* __cplusplus */
inline wint_t __CRTDECL getwchar()
        {return (fgetwc(stdin)); }   /* stdin */
inline wint_t __CRTDECL putwchar(wchar_t _C)
        {return (fputwc(_C, stdout)); }       /* stdout */
#endif  /* __cplusplus */

#define getwc(_stm)             fgetwc(_stm)
#define putwc(_c,_stm)          fputwc(_c,_stm)
#define _putwc_nolock(_c,_stm)     _fputwc_nolock(_c,_stm)
#define _getwc_nolock(_c)          _fgetwc_nolock(_c)

#if defined(_CRT_DISABLE_PERFCRIT_LOCKS) && !defined(_DLL)
#define fgetwc(_stm)            _getwc_nolock(_stm)
#define fputwc(_c,_stm)         _putwc_nolock(_c,_stm)
#define ungetwc(_c,_stm)        _ungetwc_nolock(_c,_stm)
#endif

#define _WSTDIO_DEFINED
#endif  /* _WSTDIO_DEFINED */

#ifndef _WSTDLIB_DEFINED

/* wide function prototypes, also declared in stdlib.h  */

_Check_return_wat_ _CRTIMP errno_t __cdecl _itow_s (_In_ int _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _itow_s, _In_ int, _Value, wchar_t, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _itow, _In_ int, _Value, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_ int, _Radix)
_Check_return_wat_ _CRTIMP errno_t __cdecl _ltow_s (_In_ long _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ltow_s, _In_ long, _Value, wchar_t, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _ltow, _In_ long, _Value, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_ int, _Radix)
_Check_return_wat_ _CRTIMP errno_t __cdecl _ultow_s (_In_ unsigned long _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _ultow_s, _In_ unsigned long, _Value, wchar_t, _Dest, _In_ int, _Radix)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _ultow, _In_ unsigned long, _Value, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _In_ int, _Radix)
_Check_return_ _CRTIMP double __cdecl wcstod(_In_z_ const wchar_t * _Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr);
_Check_return_ _CRTIMP double __cdecl _wcstod_l(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP long   __cdecl wcstol(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, int _Radix);
_Check_return_ _CRTIMP long   __cdecl _wcstol_l(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t **_EndPtr, int _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned long __cdecl wcstoul(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, int _Radix);
_Check_return_ _CRTIMP unsigned long __cdecl _wcstoul_l(_In_z_ const wchar_t *_Str, _Out_opt_ _Deref_post_z_ wchar_t **_EndPtr, int _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP _CRT_INSECURE_DEPRECATE(_wdupenv_s) wchar_t * __cdecl _wgetenv(_In_z_ const wchar_t * _VarName);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wgetenv_s(_Out_ size_t * _ReturnSize, _Out_z_cap_(_DstSizeInWords) wchar_t * _DstBuf, _In_ size_t _DstSizeInWords, _In_z_ const wchar_t * _VarName);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(errno_t, _wgetenv_s, _Out_ size_t *, _ReturnSize, wchar_t, _Dest, _In_z_ const wchar_t *, _VarName)

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wdupenv_s")
#undef _wdupenv_s
#endif

_Check_return_wat_ _CRTIMP errno_t __cdecl _wdupenv_s(_Out_ _Deref_post_opt_z_cap_(*_BufferSizeInWords) wchar_t **_Buffer, _Out_opt_ size_t *_BufferSizeInWords, _In_z_ const wchar_t *_VarName);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wdupenv_s")
#endif
#ifndef _CRT_WSYSTEM_DEFINED
#define _CRT_WSYSTEM_DEFINED
_CRTIMP int __cdecl _wsystem(_In_opt_z_ const wchar_t * _Command);
#endif
_Check_return_ _CRTIMP double __cdecl _wtof(_In_z_ const wchar_t *_Str);
_Check_return_ _CRTIMP double __cdecl _wtof_l(_In_z_ const wchar_t *_Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wtoi(_In_z_ const wchar_t *_Str);
_Check_return_ _CRTIMP int __cdecl _wtoi_l(_In_z_ const wchar_t *_Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP long __cdecl _wtol(_In_z_ const wchar_t *_Str);
_Check_return_ _CRTIMP long __cdecl _wtol_l(_In_z_ const wchar_t *_Str, _In_opt_ _locale_t _Locale);

_Check_return_wat_ _CRTIMP errno_t __cdecl _i64tow_s(_In_ __int64 _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
_CRTIMP _CRT_INSECURE_DEPRECATE(_i64tow_s) wchar_t * __cdecl _i64tow(_In_ __int64 _Val, _Pre_notnull_ _Post_z_ wchar_t * _DstBuf, _In_ int _Radix);
_Check_return_wat_ _CRTIMP errno_t __cdecl _ui64tow_s(_In_ unsigned __int64 _Val, _Out_z_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ size_t _SizeInWords, _In_ int _Radix);
_CRTIMP _CRT_INSECURE_DEPRECATE(_ui64tow_s) wchar_t * __cdecl _ui64tow(_In_ unsigned __int64 _Val, _Pre_notnull_ _Post_z_ wchar_t * _DstBuf, _In_ int _Radix);
_Check_return_ _CRTIMP __int64   __cdecl _wtoi64(_In_z_ const wchar_t *_Str);
_Check_return_ _CRTIMP __int64   __cdecl _wtoi64_l(_In_z_ const wchar_t *_Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP __int64   __cdecl _wcstoi64(_In_z_ const wchar_t * _Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_ int _Radix);
_Check_return_ _CRTIMP __int64   __cdecl _wcstoi64_l(_In_z_ const wchar_t * _Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_ int _Radix, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP unsigned __int64  __cdecl _wcstoui64(_In_z_ const wchar_t * _Str, _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_ int _Radix);
_Check_return_ _CRTIMP unsigned __int64  __cdecl _wcstoui64_l(_In_z_ const wchar_t *_Str , _Out_opt_ _Deref_post_z_ wchar_t ** _EndPtr, _In_ int _Radix, _In_opt_ _locale_t _Locale);

#define _WSTDLIB_DEFINED
#endif

#ifndef _POSIX_

#ifndef _WSTDLIBP_DEFINED

/* wide function prototypes, also declared in stdlib.h  */

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wfullpath")
#undef _wfullpath
#endif

_Check_return_ _CRTIMP wchar_t * __cdecl _wfullpath(_Out_opt_z_cap_(_SizeInWords) wchar_t * _FullPath, _In_z_ const wchar_t * _Path, _In_ size_t _SizeInWords);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wfullpath")
#endif

_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl _wmakepath_s(_Out_z_cap_(_SizeInBytes) wchar_t * _PathResult, _In_ size_t _SizeInBytes, _In_opt_z_ const wchar_t * _Drive, _In_opt_z_ const wchar_t * _Dir, _In_opt_z_ const wchar_t * _Filename,
        _In_opt_z_ const wchar_t * _Ext);        
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(errno_t, _wmakepath_s, wchar_t, _ResultPath, _In_opt_z_ const wchar_t *, _Drive, _In_opt_z_ const wchar_t *, _Dir, _In_opt_z_ const wchar_t *, _Filename, _In_opt_z_ const wchar_t *, _Ext)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(void, __RETURN_POLICY_VOID, _CRTIMP, _wmakepath, _Pre_notnull_ _Post_z_, wchar_t, _ResultPath, _In_opt_z_ const wchar_t *, _Drive, _In_opt_z_ const wchar_t *, _Dir, _In_opt_z_ const wchar_t *, _Filename, _In_opt_z_ const wchar_t *, _Ext)
#ifndef _CRT_WPERROR_DEFINED
#define _CRT_WPERROR_DEFINED
_CRTIMP void __cdecl _wperror(_In_opt_z_ const wchar_t * _ErrMsg);
#endif 
_Check_return_ _CRTIMP int    __cdecl _wputenv(_In_z_ const wchar_t * _EnvString);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wputenv_s(_In_z_ const wchar_t * _Name, _In_z_ const wchar_t * _Value);
_CRTIMP errno_t __cdecl _wsearchenv_s(_In_z_ const wchar_t * _Filename, _In_z_ const wchar_t * _EnvVar, _Out_z_cap_(_SizeInWords) wchar_t * _ResultPath, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(errno_t, _wsearchenv_s, _In_z_ const wchar_t *, _Filename, _In_z_ const wchar_t *, _EnvVar, wchar_t, _ResultPath)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(void, __RETURN_POLICY_VOID, _CRTIMP, _wsearchenv, _In_z_ const wchar_t *, _Filename, _In_z_ const wchar_t *, _EnvVar, _Pre_notnull_ _Post_z_, wchar_t, _ResultPath)
_CRT_INSECURE_DEPRECATE(_wsplitpath_s) _CRTIMP void   __cdecl _wsplitpath(_In_z_ const wchar_t * _FullPath, _Pre_maybenull_ _Post_z_ wchar_t * _Drive, _Pre_maybenull_ _Post_z_ wchar_t * _Dir, _Pre_maybenull_ _Post_z_ wchar_t * _Filename, _Pre_maybenull_ _Post_z_ wchar_t * _Ext);
_CRTIMP_ALTERNATIVE errno_t __cdecl _wsplitpath_s(_In_z_ const wchar_t * _FullPath, 
		_Out_opt_z_cap_(_DriveSize) wchar_t * _Drive, _In_ size_t _DriveSize, 
		_Out_opt_z_cap_(_DirSize) wchar_t * _Dir, _In_ size_t _DirSize, 
		_Out_opt_z_cap_(_FilenameSize) wchar_t * _Filename, _In_ size_t _FilenameSize, 
		_Out_opt_z_cap_(_ExtSize) wchar_t * _Ext, _In_ size_t _ExtSize);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(errno_t, _wsplitpath_s, wchar_t, _Path)

#define _WSTDLIBP_DEFINED
#endif

#endif  /* _POSIX_ */


#ifndef _WSTRING_DEFINED

/* wide function prototypes, also declared in string.h  */

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wcsdup")
#undef _wcsdup
#endif

_Check_return_ _CRTIMP wchar_t * __cdecl _wcsdup(_In_z_ const wchar_t * _Str);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wcsdup")
#endif

#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl wcscat_s(_Inout_z_cap_(_DstSize) wchar_t * _Dst, _In_ rsize_t _DstSize, const wchar_t * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, wcscat_s, wchar_t, _Dest, _In_z_ const wchar_t *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcscat, _Pre_cap_for_(_Source) _Prepost_z_, wchar_t, _Dest, _In_z_ const wchar_t *, _Source)
_Check_return_ _CRTIMP _CONST_RETURN wchar_t * __cdecl wcschr(_In_z_ const wchar_t * _Str, wchar_t _Ch);
_Check_return_ _CRTIMP int __cdecl wcscmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl wcscpy_s(_Out_z_cap_(_DstSize) wchar_t * _Dst, _In_ rsize_t _DstSize, _In_z_ const wchar_t * _Src);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, wcscpy_s, wchar_t, _Dest, _In_z_ const wchar_t *, _Source)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcscpy, _Pre_cap_for_(_Source) _Post_z_, wchar_t, _Dest, _In_z_ const wchar_t *, _Source)
_Check_return_ _CRTIMP size_t __cdecl wcscspn(_In_z_ const wchar_t * _Str, _In_z_ const wchar_t * _Control);
_Check_return_ _CRTIMP size_t __cdecl wcslen(_In_z_ const wchar_t * _Str);
_Check_return_ _CRTIMP size_t __cdecl wcsnlen(_In_z_ const wchar_t * _Src, _In_ size_t _MaxCount);
#if __STDC_WANT_SECURE_LIB__
_Check_return_ static __inline size_t __CRTDECL wcsnlen_s(_In_z_ const wchar_t * _Src, _In_ size_t _MaxCount)
{
    return (_Src == NULL) ? 0 : wcsnlen(_Src, _MaxCount);
}
#endif
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl wcsncat_s(_Inout_z_cap_(_DstSize) wchar_t * _Dst, _In_ rsize_t _DstSize, _In_z_ const wchar_t * _Src, _In_ rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, wcsncat_s, _Deref_prepost_z_ wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count)

#pragma warning(push)
#pragma warning(disable:6059)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcsncat, wcsncat_s, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_cap_(_Count), wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count)
#pragma warning(pop)

_Check_return_ _CRTIMP int __cdecl wcsncmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
#if __STDC_WANT_SECURE_LIB__
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl wcsncpy_s(_Out_z_cap_(_DstSize) wchar_t * _Dst, _In_ rsize_t _DstSize, _In_z_ const wchar_t * _Src, _In_ rsize_t _MaxCount);
#endif
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, wcsncpy_s, wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, wcsncpy, wcsncpy_s, _Deref_out_z_cap_c_(_Size) wchar_t, _Out_cap_(_Count) _Post_maybez_, wchar_t, _Dest, _In_z_ const wchar_t *, _Source, _In_ size_t, _Count)
_Check_return_ _CRTIMP _CONST_RETURN wchar_t * __cdecl wcspbrk(_In_z_ const wchar_t * _Str, _In_z_ const wchar_t * _Control);
_Check_return_ _CRTIMP _CONST_RETURN wchar_t * __cdecl wcsrchr(_In_z_ const wchar_t * _Str, _In_ wchar_t _Ch);
_Check_return_ _CRTIMP size_t __cdecl wcsspn(_In_z_ const wchar_t * _Str, _In_z_ const wchar_t * _Control);
_Check_return_ _CRTIMP _CONST_RETURN wchar_t * __cdecl wcsstr(_In_z_ const wchar_t * _Str, _In_z_ const wchar_t * _SubStr);
_Check_return_ _CRT_INSECURE_DEPRECATE(wcstok_s) _CRTIMP wchar_t * __cdecl wcstok(_Inout_opt_z_ wchar_t * _Str, _In_z_ const wchar_t * _Delim);
_Check_return_ _CRTIMP_ALTERNATIVE wchar_t * __cdecl wcstok_s(_Inout_opt_z_ wchar_t * _Str, _In_z_ const wchar_t * _Delim, _Inout_ _Deref_prepost_opt_z_ wchar_t ** _Context);
_Check_return_ _CRT_INSECURE_DEPRECATE(_wcserror_s) _CRTIMP wchar_t * __cdecl _wcserror(_In_ int _ErrNum);
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcserror_s(_Out_opt_z_cap_(_SizeInWords) wchar_t * _Buf, _In_ size_t _SizeInWords, _In_ int _ErrNum);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wcserror_s, wchar_t, _Buffer, _In_ int, _Error)
_Check_return_ _CRT_INSECURE_DEPRECATE(__wcserror_s) _CRTIMP wchar_t * __cdecl __wcserror(_In_opt_z_ const wchar_t * _Str);
_Check_return_wat_ _CRTIMP errno_t __cdecl __wcserror_s(_Out_opt_z_cap_(_SizeInWords) wchar_t * _Buffer, _In_ size_t _SizeInWords, _In_z_ const wchar_t * _ErrMsg);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, __wcserror_s, wchar_t, _Buffer, _In_z_ const wchar_t *, _ErrorMessage)

_Check_return_ _CRTIMP int __cdecl _wcsicmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
_Check_return_ _CRTIMP int __cdecl _wcsicmp_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wcsnicmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _wcsnicmp_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl _wcsnset_s(_Inout_z_cap_(_DstSizeInWords) wchar_t * _Dst, _In_ size_t _DstSizeInWords, wchar_t _Val, _In_ size_t _MaxCount);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(errno_t, _wcsnset_s, _Deref_prepost_z_ wchar_t, _Dst, wchar_t, _Val, _In_ size_t, _MaxCount)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsnset, _wcsnset_s, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_cap_(_MaxCount), wchar_t, _Str, wchar_t, _Val, _In_ size_t, _MaxCount)
_CRTIMP wchar_t * __cdecl _wcsrev(_Inout_z_ wchar_t * _Str);
_Check_return_wat_ _CRTIMP_ALTERNATIVE errno_t __cdecl _wcsset_s(_Inout_z_cap_(_SizeInWords) wchar_t * _Str, _In_ size_t _SizeInWords, wchar_t _Val);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wcsset_s, _Deref_prepost_z_ wchar_t, _Str, wchar_t, _Val)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsset, _wcsset_s, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_, wchar_t, _Str, wchar_t, _Val)

_Check_return_wat_ _CRTIMP errno_t __cdecl _wcslwr_s(_Inout_z_cap_(_SizeInWords) wchar_t * _Str, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wcslwr_s, wchar_t, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcslwr, _Inout_z_, wchar_t, _String)
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcslwr_s_l(_Inout_z_cap_(_SizeInWords) wchar_t * _Str, _In_ size_t _SizeInWords, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wcslwr_s_l, wchar_t, _String, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcslwr_l, _wcslwr_s_l, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_, wchar_t, _String, _In_opt_ _locale_t, _Locale)
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcsupr_s(_Inout_z_cap_(_Size) wchar_t * _Str, _In_ size_t _Size);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wcsupr_s, wchar_t, _String)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsupr, _Inout_z_, wchar_t, _String)
_Check_return_wat_ _CRTIMP errno_t __cdecl _wcsupr_s_l(_Inout_z_cap_(_Size) wchar_t * _Str, _In_ size_t _Size, _In_opt_ _locale_t _Locale);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wcsupr_s_l, _Deref_prepost_z_ wchar_t, _String, _In_opt_ _locale_t, _Locale)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wcsupr_l, _wcsupr_s_l, _Deref_inout_z_cap_c_(_Size) wchar_t, _Inout_z_, wchar_t, _String, _In_opt_ _locale_t, _Locale)
_Check_return_opt_ _CRTIMP size_t __cdecl wcsxfrm(_Out_opt_cap_(_MaxCount) _Post_maybez_ wchar_t * _Dst, _In_z_ const wchar_t * _Src, _In_ size_t _MaxCount);
_Check_return_opt_ _CRTIMP size_t __cdecl _wcsxfrm_l(_Out_opt_cap_(_MaxCount) _Post_maybez_ wchar_t * _Dst, _In_z_ const wchar_t *_Src, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl wcscoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
_Check_return_ _CRTIMP int __cdecl _wcscoll_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wcsicoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
_Check_return_ _CRTIMP int __cdecl _wcsicoll_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t *_Str2, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wcsncoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _wcsncoll_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _wcsnicoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
_Check_return_ _CRTIMP int __cdecl _wcsnicoll_l(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount, _In_opt_ _locale_t _Locale);

#ifdef  __cplusplus
#ifndef _CPP_WIDE_INLINES_DEFINED
#define _CPP_WIDE_INLINES_DEFINED
extern "C++" {
_Check_return_ inline wchar_t * __CRTDECL wcschr(_In_z_ wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
_Check_return_ inline wchar_t * __CRTDECL wcspbrk(_In_z_ wchar_t *_Str, _In_z_ const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
_Check_return_ inline wchar_t * __CRTDECL wcsrchr(_In_z_ wchar_t *_Str, _In_ wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }
_Check_return_ inline wchar_t * __CRTDECL wcsstr(_In_z_ wchar_t *_Str, _In_z_ const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#endif
#endif

#if     !__STDC__

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma push_macro("wcsdup")
#undef wcsdup
#endif

_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsdup) _CRTIMP wchar_t * __cdecl wcsdup(_In_z_ const wchar_t * _Str);

#if defined(_DEBUG) && defined(_CRTDBG_MAP_ALLOC)
#pragma pop_macro("wcsdup")
#endif

/* old names */
#define wcswcs wcsstr

/* prototypes for oldnames.lib functions */
_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsicmp) _CRTIMP int __cdecl wcsicmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsnicmp) _CRTIMP int __cdecl wcsnicmp(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2, _In_ size_t _MaxCount);
_CRT_NONSTDC_DEPRECATE(_wcsnset) _CRTIMP wchar_t * __cdecl wcsnset(_Inout_z_cap_(_MaxCount) wchar_t * _Str, _In_ wchar_t _Val, _In_ size_t _MaxCount);
_CRT_NONSTDC_DEPRECATE(_wcsrev) _CRTIMP wchar_t * __cdecl wcsrev(_Inout_z_ wchar_t * _Str);
_CRT_NONSTDC_DEPRECATE(_wcsset) _CRTIMP wchar_t * __cdecl wcsset(_Inout_z_ wchar_t * _Str, wchar_t _Val);
_CRT_NONSTDC_DEPRECATE(_wcslwr) _CRTIMP wchar_t * __cdecl wcslwr(_Inout_z_ wchar_t * _Str);
_CRT_NONSTDC_DEPRECATE(_wcsupr) _CRTIMP wchar_t * __cdecl wcsupr(_Inout_z_ wchar_t * _Str);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_wcsicoll) _CRTIMP int __cdecl wcsicoll(_In_z_ const wchar_t * _Str1, _In_z_ const wchar_t * _Str2);

#endif  /* !__STDC__ */

#define _WSTRING_DEFINED
#endif

#ifndef _TM_DEFINED
struct tm {
        int tm_sec;     /* seconds after the minute - [0,59] */
        int tm_min;     /* minutes after the hour - [0,59] */
        int tm_hour;    /* hours since midnight - [0,23] */
        int tm_mday;    /* day of the month - [1,31] */
        int tm_mon;     /* months since January - [0,11] */
        int tm_year;    /* years since 1900 */
        int tm_wday;    /* days since Sunday - [0,6] */
        int tm_yday;    /* days since January 1 - [0,365] */
        int tm_isdst;   /* daylight savings time flag */
        };
#define _TM_DEFINED
#endif

#ifndef _WTIME_DEFINED

/* wide function prototypes, also declared in time.h */
 
_CRT_INSECURE_DEPRECATE(_wasctime_s) _CRTIMP wchar_t * __cdecl _wasctime(_In_ const struct tm * _Tm);
_CRTIMP errno_t __cdecl _wasctime_s(_Out_cap_(_SizeInWords) _Post_count_c_(26) wchar_t *_Buf, _In_ size_t _SizeInWords, _In_ const struct tm * _Tm);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wasctime_s, _Deref_post_count_c_(26) wchar_t, _Buffer, _In_ const struct tm *, _Time)

_CRT_INSECURE_DEPRECATE(_wctime32_s) _CRTIMP wchar_t * __cdecl _wctime32(_In_ const __time32_t *_Time);
_CRTIMP errno_t __cdecl _wctime32_s(_Out_cap_(_SizeInWords) _Post_count_c_(26) wchar_t* _Buf, _In_ size_t _SizeInWords, _In_ const __time32_t * _Time);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wctime32_s, _Deref_post_count_c_(26) wchar_t, _Buffer, _In_ const __time32_t *, _Time)

_CRTIMP size_t __cdecl wcsftime(_Out_z_cap_(_SizeInWords) wchar_t * _Buf, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t * _Format,  _In_ const struct tm * _Tm);
_CRTIMP size_t __cdecl _wcsftime_l(_Out_z_cap_(_SizeInWords) wchar_t * _Buf, _In_ size_t _SizeInWords, _In_z_ _Printf_format_string_ const wchar_t *_Format, _In_ const struct tm *_Tm, _In_opt_ _locale_t _Locale);

_CRTIMP errno_t __cdecl _wstrdate_s(_Out_cap_(_SizeInWords) _Post_count_c_(9) wchar_t * _Buf, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wstrdate_s, _Deref_post_count_c_(9) wchar_t, _Buffer)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wstrdate, _Out_z_cap_c_(9), wchar_t, _Buffer)

_CRTIMP errno_t __cdecl _wstrtime_s(_Out_cap_(_SizeInWords) _Post_count_c_(9) wchar_t * _Buf, _In_ size_t _SizeInWords);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(errno_t, _wstrtime_s, _Deref_post_count_c_(9) wchar_t, _Buffer)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(wchar_t *, __RETURN_POLICY_DST, _CRTIMP, _wstrtime, _Out_z_cap_c_(9), wchar_t, _Buffer)

_CRT_INSECURE_DEPRECATE(_wctime64_s) _CRTIMP wchar_t * __cdecl _wctime64(_In_ const __time64_t * _Time);
_CRTIMP errno_t __cdecl _wctime64_s(_Out_cap_(_SizeInWords) _Post_count_c_(26) wchar_t* _Buf, _In_ size_t _SizeInWords, _In_ const __time64_t *_Time);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _wctime64_s, _Deref_post_count_c_(26) wchar_t, _Buffer, _In_ const __time64_t *, _Time)

#if !defined(RC_INVOKED) && !defined(__midl)
#include <wtime.inl>
#endif

#define _WTIME_DEFINED
#endif


typedef int mbstate_t;
typedef wchar_t _Wint_t;

_CRTIMP wint_t __cdecl btowc(int);
_CRTIMP size_t __cdecl mbrlen(_In_opt_bytecount_(_SizeInBytes) _Pre_opt_z_ const char * _Ch, _In_ size_t _SizeInBytes,
                              _Out_opt_ mbstate_t * _State);
_CRTIMP size_t __cdecl mbrtowc(_Pre_maybenull_ _Post_z_ wchar_t * _DstCh, _In_opt_bytecount_(_SizeInBytes) _Pre_opt_z_ const char * _SrcCh,
                               _In_ size_t _SizeInBytes, _Out_opt_ mbstate_t * _State);
_CRTIMP errno_t __cdecl mbsrtowcs_s(_Out_opt_ size_t* _Retval, _Out_opt_z_cap_(_Size) wchar_t * _Dst, _In_ size_t _Size, _Inout_ _Deref_prepost_opt_valid_ const char ** _PSrc, _In_ size_t _N, _Out_opt_ mbstate_t * _State);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(errno_t, mbsrtowcs_s, _Out_opt_ size_t *, _Retval, _Deref_post_z_ wchar_t, _Dest, _Inout_ _Deref_prepost_opt_valid_ const char **, _PSource, _In_ size_t, _Count, _Out_opt_ mbstate_t *, _State)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_CRTIMP, mbsrtowcs, _Pre_notnull_ _Post_z_, wchar_t, _Dest, _Inout_ _Deref_prepost_opt_valid_ const char **, _PSrc, _In_ size_t, _Count, _Inout_opt_ mbstate_t *, _State)

_CRTIMP errno_t __cdecl wcrtomb_s(_Out_opt_ size_t * _Retval, _Out_opt_z_bytecap_(_SizeInBytes) char * _Dst,
        _In_ size_t _SizeInBytes, _In_ wchar_t _Ch, _Out_opt_ mbstate_t * _State);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(errno_t, wcrtomb_s, _Out_opt_ size_t *, _Retval, _Out_opt_z_bytecap_(_Size) char, _Dest, _In_ wchar_t, _Source, _Out_opt_ mbstate_t *, _State)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_CRTIMP, wcrtomb, _Pre_maybenull_ _Post_z_, char, _Dest, _In_ wchar_t, _Source, _Out_opt_ mbstate_t *, _State)
_CRTIMP errno_t __cdecl wcsrtombs_s(_Out_opt_ size_t * _Retval, _Out_opt_bytecap_post_bytecount_(_SizeInBytes, *_Retval) char * _Dst,
        _In_ size_t _SizeInBytes, _Inout_ _Deref_prepost_z_ const wchar_t ** _Src, _In_ size_t _Size, _Out_opt_ mbstate_t * _State);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(errno_t, wcsrtombs_s, _Out_opt_ size_t *, _Retval, _Out_opt_z_bytecap_(_Size) char, _Dest, _Inout_ _Deref_prepost_z_ const wchar_t **, _PSrc, _In_ size_t, _Count, _Out_opt_ mbstate_t *, _State)
__DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_CRTIMP, wcsrtombs, _Pre_maybenull_ _Post_z_, char, _Dest, _Inout_ _Deref_prepost_z_ const wchar_t **, _PSource, _In_ size_t, _Count, _Out_opt_ mbstate_t *, _State)
_CRTIMP int __cdecl wctob(_In_ wint_t _WCh);

#ifndef __midl

/* memcpy and memmove are defined just for use in wmemcpy and wmemmove */
#if     defined(_M_IA64)
		_CRT_INSECURE_DEPRECATE_MEMORY(memmove_s) void *  __cdecl memmove(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ size_t _Size);
#else
_CRTIMP _CRT_INSECURE_DEPRECATE_MEMORY(memmove_s) void *  __cdecl memmove(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ size_t _Size);
#endif
_CRT_INSECURE_DEPRECATE_MEMORY(memcpy_s) void *  __cdecl memcpy(_Out_opt_bytecapcount_(_Size) void * _Dst, _In_opt_bytecount_(_Size) const void * _Src, _In_ size_t _Size);
#if __STDC_WANT_SECURE_LIB__
_CRTIMP errno_t __cdecl memcpy_s(_Out_opt_bytecap_post_bytecount_(_DstSize, _MaxCount) void * _Dst, _In_ rsize_t _DstSize, _In_opt_bytecount_(_MaxCount) const void * _Src, _In_ rsize_t _MaxCount);
_CRTIMP errno_t __cdecl memmove_s(_Out_opt_bytecap_post_bytecount_(_DstSize, _MaxCount) void * _Dst, _In_ rsize_t _DstSize, _In_opt_bytecount_(_MaxCount) const void * _Src, _In_ rsize_t _MaxCount);
#endif
__inline int __CRTDECL fwide(_In_opt_ FILE * _F, int _M)
        {(void)_F; return (_M); }
__inline int __CRTDECL mbsinit(_In_opt_ const mbstate_t *_P)
        {return (_P == NULL || *_P == 0); }
__inline _CONST_RETURN wchar_t * __CRTDECL wmemchr(_In_count_(_N) const wchar_t *_S, _In_ wchar_t _C, _In_ size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (_CONST_RETURN wchar_t *)(_S);
        return (0); }
__inline int __CRTDECL wmemcmp(_In_count_(_N) const wchar_t *_S1, _In_count_(_N) const wchar_t *_S2, _In_ size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }

__inline _CRT_INSECURE_DEPRECATE_MEMORY(wmemcpy_s) wchar_t * __CRTDECL wmemcpy(_Out_opt_cap_(_N) wchar_t *_S1, _In_opt_count_(_N) const wchar_t *_S2, _In_ size_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
            return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }

#if __STDC_WANT_SECURE_LIB__
__inline errno_t __CRTDECL wmemcpy_s(_Out_opt_cap_post_count_(_N1, _N) wchar_t *_S1, _In_ rsize_t _N1, _In_opt_count_(_N) const wchar_t *_S2, rsize_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 6386 )
            return memcpy_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
        }
#pragma warning( pop )
#endif

__inline _CRT_INSECURE_DEPRECATE_MEMORY(wmemmove_s) wchar_t * __CRTDECL wmemmove(_Out_opt_capcount_(_N) wchar_t *_S1, _In_opt_count_(_N) const wchar_t *_S2, _In_ size_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)
			/* prefast noise VSW 493303 */
            return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }

#if __STDC_WANT_SECURE_LIB__
__inline errno_t __CRTDECL wmemmove_s(_Out_opt_cap_post_count_(_N1, _N) wchar_t *_S1, _In_ rsize_t _N1, _In_opt_count_(_N) const wchar_t *_S2, _In_ rsize_t _N)
        {
#pragma warning( push )
#pragma warning( disable : 6386 )
            return memmove_s(_S1, _N1*sizeof(wchar_t), _S2, _N*sizeof(wchar_t));
#pragma warning( pop )
        }
#endif

__inline wchar_t * __CRTDECL wmemset(_Out_capcount_(_N) wchar_t *_S, _In_ wchar_t _C, _In_ size_t _N)
        {
            wchar_t *_Su = _S;
            for (; 0 < _N; ++_Su, --_N)
            {
                *_Su = _C;
            }
            return (_S);
        }

#ifdef __cplusplus
extern "C++" {
inline wchar_t * __CRTDECL wmemchr(_In_count_(_N) wchar_t *_S, _In_ wchar_t _C, _In_ size_t _N)
        { return (wchar_t *)wmemchr((const wchar_t *)_S, _C, _N); }
}
#endif
#endif

#ifdef  __cplusplus
}       /* end of extern "C" */
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\wmiatlprov.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2000 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWMIPROV_H__
#define __ATLWMIPROV_H__

#pragma once

#ifndef __cplusplus
    #error requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __wbemprov_h__
    #include <wbemprov.h>
#endif

#ifndef __wmiutils_h__
    #include <wmiutils.h>
#endif

namespace ATL
{

class ATL_NO_VTABLE IWbemInstProviderImpl : public IWbemServices,
                                            public IWbemProviderInit
    
{
public:

    //IWbemServices  

    HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
    
/*?*/HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
/*?*/HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};

};


class CProviderHelper
{   
private:
    CComPtr<IWbemClassObject> m_pErrorObject;
    HRESULT m_hr; // store the construction status here

public:
    //Construction:
    CProviderHelper(IWbemServices * pNamespace, IWbemContext *pCtx)
    {
        m_hr = WBEM_E_FAILED; // assume the worst to start
        m_pErrorObject == NULL;
        if (NULL == pNamespace)
        {
            m_hr = WBEM_E_INVALID_PARAMETER; 
            ATLASSERT (0);
            return;
        }
        BSTR bstrString = SysAllocString(L"__ExtendedStatus");
        if (NULL == bstrString)
        {
            m_hr = WBEM_E_OUT_OF_MEMORY;
            return;
        }
        m_hr = pNamespace->GetObject(bstrString, 
                                     0, 
                                     pCtx, 
                                     &m_pErrorObject, 
                                     NULL);
        SysFreeString(bstrString);
        return;
    }

    virtual ~CProviderHelper()
    {
    }   

    HRESULT STDMETHODCALLTYPE ConstructErrorObject (
                                                    /*in*/const ULONG ulStatusCode,
                                                    /*in*/const BSTR bstrDescription,
                                                    /*in*/const BSTR bstrOperation,
                                                    /*in*/const BSTR bstrParameter,
                                                    /*in*/const BSTR bstrProviderName,
                                                    /*out*/IWbemClassObject ** ppErrorObject)
    {

        static const LPWSTR lpwstrDescription = L"Description";
        static const LPWSTR lpwstrOperation = L"Operation";
        static const LPWSTR lpwstrStatusCode = L"StatusCode";
        static const LPWSTR lpwstrParameterInfo = L"ParameterInfo";
        static const LPWSTR lpwstrProviderName = L"ProviderName";

        if (FAILED (m_hr))
        {
            // constructor failed
            ATLASSERT (0);
            return m_hr;
        }

        if (NULL == ppErrorObject)
        {
            ATLASSERT (0);
            return WBEM_E_INVALID_PARAMETER;
        }

        HRESULT hr = m_pErrorObject->SpawnInstance(0, ppErrorObject);
        if(FAILED(hr))
        {
            return hr;
        }

        VARIANT var;
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = ulStatusCode;

        hr = (*ppErrorObject)->Put(lpwstrStatusCode, 0, &var, 0);
        if (FAILED(hr))
        {
            return hr;
        }

        var.vt = VT_BSTR;

        if (bstrDescription != NULL)
        {               
            var.bstrVal = bstrDescription;
            hr = (*ppErrorObject)->Put(lpwstrDescription, 0, &var, 0);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        
        if (bstrOperation != NULL)
        {
            var.bstrVal = bstrOperation;
            hr = (*ppErrorObject)->Put(lpwstrOperation, 0, &var, 0);
            if (FAILED(hr))
            {
                return hr;
            }
        }

        if (bstrParameter != NULL)
        {
            var.bstrVal = bstrParameter;
            hr = (*ppErrorObject)->Put(lpwstrParameterInfo, 0, &var, 0);
            if (FAILED(hr))
            {
                return hr;
            }
        }

        if (bstrProviderName != NULL)
        {
            var.bstrVal = bstrProviderName;
            hr = (*ppErrorObject)->Put(lpwstrProviderName, 0, &var, 0);
            if (FAILED(hr))
            {
                return hr;
            }
        }
            
        return hr;
    }
};

class CIntrinsicEventProviderHelper : public CProviderHelper
{
private:
    CComPtr<IWbemClassObject> m_pCreationEventClass;
    CComPtr<IWbemClassObject> m_pDeletionEventClass;
    CComPtr<IWbemClassObject> m_pModificationEventClass;
    HRESULT m_hr;

public:

    //Construction
    CIntrinsicEventProviderHelper( IWbemServices * pNamespace, IWbemContext * pCtx)
                : CProviderHelper ( pNamespace, pCtx)
    {
        m_hr = WBEM_E_FAILED; // assume the worst

        if (NULL == pNamespace || NULL == pCtx)
        {
            m_hr = WBEM_E_INVALID_PARAMETER;
            ATLASSERT (0);
            return;
        }

        m_pCreationEventClass = NULL;
        m_pModificationEventClass = NULL; 
        m_pDeletionEventClass = NULL;

        BSTR bstrString = SysAllocString(L"__InstanceCreationEvent");
        if (NULL == bstrString)
        {
            m_hr = WBEM_E_OUT_OF_MEMORY;
            return;
        }

        m_hr = pNamespace->GetObject(bstrString, 
                                     0, 
                                     pCtx, 
                                     &m_pCreationEventClass, 
                                     NULL);
        SysFreeString(bstrString);
        bstrString=NULL;
        if (FAILED(m_hr)) 
        {
            return;
        }

        bstrString = SysAllocString(L"__InstanceModificationEvent");
        if (NULL == bstrString)
        {
            m_hr = WBEM_E_OUT_OF_MEMORY;
            return;
        }
        m_hr = pNamespace->GetObject(bstrString, 
                                     0, 
                                     pCtx, //passing IWbemContext pointer to prevent deadlocks
                                     &m_pModificationEventClass, 
                                     NULL);
        SysFreeString(bstrString);
        bstrString=NULL;
        if (FAILED(m_hr)) 
        {
            return;
        }
        
        bstrString = SysAllocString(L"__InstanceDeletionEvent");
        if (NULL == bstrString)
        {
            m_hr = WBEM_E_OUT_OF_MEMORY;
            return;
        }
        m_hr = pNamespace->GetObject(bstrString, 
                                     0, 
                                     pCtx, //passing IWbemContext pointer to prevent deadlocks
                                     &m_pDeletionEventClass, 
                                     NULL);
        SysFreeString(bstrString);
        bstrString=NULL;           
        if (FAILED(m_hr)) 
        {
            return;
        }

        return;
    }

    virtual ~CIntrinsicEventProviderHelper()
    {
    }

    HRESULT STDMETHODCALLTYPE FireCreationEvent(
                                                /*in*/IWbemClassObject * pNewInstance,
                                                /*in*/IWbemObjectSink * pSink )
    {
        if (FAILED(m_hr))
        {
            // construction failed
            ATLASSERT (0);      
            return m_hr;
        }

        if (pNewInstance == NULL || pSink == NULL)
        {
            ATLASSERT (0);      
            return WBEM_E_INVALID_PARAMETER;
        }
        
        CComPtr<IWbemClassObject> pEvtInstance;
        HRESULT hr = m_pCreationEventClass->SpawnInstance(0, &pEvtInstance);
        if(FAILED(hr))
        {
            return hr;
        }
        
        VARIANT var;
        VariantInit(&var);
        var.vt = VT_UNKNOWN; 
        CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pNewInstance);
        var.punkVal = pTemp;
        hr = pEvtInstance->Put(L"TargetInstance", 0, &var, 0);
        if(FAILED(hr))
        {
            return hr;
        }

        IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
        return pSink->Indicate(1, &_pEvtInstance);
    }


    HRESULT STDMETHODCALLTYPE FireDeletionEvent(
                                    /*in*/IWbemClassObject * pInstanceToDelete,
                                    /*in*/IWbemObjectSink * pSink )
    {
        if (FAILED (m_hr))
        {
            // construction failed
            ATLASSERT (0);      
            return m_hr;
        }

        if (pInstanceToDelete == NULL || pSink == NULL)
        {
            ATLASSERT (0);      
            return WBEM_E_INVALID_PARAMETER;
        }

        CComPtr<IWbemClassObject> pEvtInstance;
        HRESULT hr = m_pDeletionEventClass->SpawnInstance(0, &pEvtInstance);
        if(FAILED(hr))
        {
            return hr;
        }

        VARIANT var;
        VariantInit(&var);
        var.vt = VT_UNKNOWN; 
        CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pInstanceToDelete);
        var.punkVal = pTemp;
        hr = pEvtInstance->Put(L"TargetInstance", 0, &var, 0);
        if(FAILED(hr))
        {
            return hr;
        }

        IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
        return pSink->Indicate(1, &_pEvtInstance);
    }


    HRESULT STDMETHODCALLTYPE FireModificationEvent(
                                                    /*in*/IWbemClassObject * pOldInstance,
                                                    /*in*/IWbemClassObject * pNewInstance,
                                                    /*in*/IWbemObjectSink * pSink )
    {
        if (FAILED (m_hr))
        {
            // construction failed
            ATLASSERT (0);      
            return m_hr;
        }

        if (pOldInstance == NULL || pNewInstance == NULL || pSink == NULL)
        {
            ATLASSERT (0);      
            return WBEM_E_INVALID_PARAMETER;
        }
                
        CComPtr<IWbemClassObject> pEvtInstance;
        HRESULT hr = m_pModificationEventClass->SpawnInstance(0, &pEvtInstance);
        if(FAILED(hr))
        {
            return hr;
        }

        VARIANT var;
        VariantInit(&var);
        var.vt = VT_UNKNOWN; 
        CComQIPtr<IUnknown, &IID_IUnknown>pTempNew(pNewInstance);
        var.punkVal = pTempNew;
        hr = pEvtInstance->Put(L"TargetInstance", 0, &var, 0);
        if (FAILED(hr)) 
        {       
            return hr;
        }
        
        CComQIPtr<IUnknown, &IID_IUnknown>pTempOld(pOldInstance);
        var.punkVal = pTempOld;
        hr = pEvtInstance->Put(L"PreviousInstance", 0, &var, 0);
        if (FAILED(hr)) 
        {       
            return hr;
        }
        
        IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
        return pSink->Indicate(1, &_pEvtInstance);
    }

};

class CInstanceProviderHelper : public CProviderHelper
{

public:

    CInstanceProviderHelper (IWbemServices * pNamespace, IWbemContext *pCtx)
                : CProviderHelper ( pNamespace, pCtx)
    {
    }

    virtual ~CInstanceProviderHelper()
    {
    }
    
    HRESULT STDMETHODCALLTYPE CheckInstancePath (
                                /*[in]*/ IClassFactory * pParserFactory,    //pointer to path parser class factory
                                /*[in]*/ const BSTR ObjectPath, //object path string
                                /*[in]*/ const BSTR ClassName,  //name of WMI class whose instances are provided
                                /*[in]*/ ULONGLONG ullTest)          //flags from WMI_PATH_STATUS_FLAG (defined in wmiutils.h)
    {   

        if (pParserFactory == NULL)
        {
            ATLASSERT (0);      
            return WBEM_E_INVALID_PARAMETER;
        }
        
        //Create path parser object
        CComPtr<IWbemPath>pPath;
        HRESULT hr = pParserFactory->CreateInstance(NULL,
                                            IID_IWbemPath,
                                            (void **) &pPath);
        if (FAILED(hr))
        {
            return WBEM_E_INVALID_PARAMETER;
        }

        hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
                                    ObjectPath);
        if(FAILED(hr))
        {
            return hr;
        }

        //check that the class requested is the class provided
        unsigned int nPathLen = SysStringLen(ObjectPath);  // assume this is a real BSTR not just WCHAR*
        if (nPathLen >= (unsigned long)(-1)) return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
        
        unsigned long ulBufLen = (unsigned long)(nPathLen + 1);
        WCHAR * wClass = new WCHAR[ulBufLen];
        if (NULL == wClass)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        hr = pPath->GetClassName(&ulBufLen, wClass);
        if(FAILED(hr))
        {
            delete[] wClass;
            return hr;
        }
        DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
        if (CSTR_EQUAL != CompareStringW(lcid, NORM_IGNORECASE, ClassName, -1, wClass, -1))
        {
            delete[] wClass;
            return WBEM_E_NOT_FOUND;
        }
        
        delete[] wClass;
        
        //check that the path reflects the object type
        unsigned __int64 ullPathInfo;
        hr = pPath->GetInfo(0L, &ullPathInfo);
        if(FAILED(hr))
        {
            return hr;
        }

        if (!(ullPathInfo & ullTest))
        {
            return WBEM_E_INVALID_OBJECT_PATH;
        }   
        
        return WBEM_S_NO_ERROR;     
    }

};


//IWbemPullClassProviderImpl class 

template <class T>
class ATL_NO_VTABLE IWbemPullClassProviderImpl : public IWbemServices,
                                                 public IWbemProviderInit
{
public:


    //IWbemServices  

    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR strNamespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult){return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    
    virtual HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
    
    
    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
    
    
    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR strSuperclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    
    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR strClass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR strQueryLanguage,
        /* [in] */ const BSTR strQuery,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ const BSTR strMethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    

};

class CImpersonateClientHelper
{
    private:
        BOOL m_bImpersonate;    
    public:
        CImpersonateClientHelper()
        { 
            m_bImpersonate = FALSE;
        }

        ~CImpersonateClientHelper()
        {
            if(m_bImpersonate)
                CoRevertToSelf();
        }

        HRESULT ImpersonateClient()
        {
            HRESULT hr = S_OK;
            if(SUCCEEDED(hr = CoImpersonateClient()))
            {
                m_bImpersonate = TRUE;
            }
            return hr;
        }

        HRESULT GetCurrentImpersonationLevel ( DWORD & a_Level )
        {
            DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
            HANDLE t_ThreadToken = NULL ;
            
            HRESULT t_Result = S_OK ;
            if(SUCCEEDED(t_Result = CoImpersonateClient()))
            {
                BOOL t_Status = OpenThreadToken (GetCurrentThread() ,TOKEN_QUERY,TRUE,&t_ThreadToken);
                if ( t_Status )
                {
                    SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
                    DWORD t_Returned = 0 ;
         
                    t_Status = GetTokenInformation (t_ThreadToken ,TokenImpersonationLevel ,&t_Level ,sizeof(SECURITY_IMPERSONATION_LEVEL),&t_Returned);
                    CloseHandle ( t_ThreadToken ) ;

                    if ( t_Status == FALSE )
                    {
                        t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError());
                    }
                    else
                    {
                        switch ( t_Level )
                        {
                            case SecurityAnonymous:
                            {
                                t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
                            }
                            break ;

                            case SecurityIdentification:
                            {
                                t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
                            }
                            break ;

                            case SecurityImpersonation:
                            {
                                t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
                            }
                            break ;

                            case SecurityDelegation:
                            {
                                t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
                            }
                            break ;

                            default:
                            {
                                t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,E_UNEXPECTED);
                            }
                            break ;
                        }
                    }
                }
                else
                {
                    t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError());
                }

                CoRevertToSelf();
            }

            a_Level = t_ImpersonationLevel ;
            return t_Result ; 
        }

    };
}       //namespace ATL

#endif  //__ATLWMIPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\CodeAnalysis\Warnings.h ===
#pragma once
#define ALL_CODE_ANALYSIS_WARNINGS 6001 6011 6029 6031 6053 6054 6057 6059 6063 6064 6066 6067 6200 6201 6202 6203 6204 6209 6211 6214 6215 6216 6217 6219 6220 6221 6225 6226 6230 6235 6236 6237 6239 6240 6242 6244 6246 6248 6250 6255 6258 6259 6260 6262 6263 6268 6269 6270 6271 6272 6273 6274 6276 6277 6278 6279 6280 6281 6282 6283 6284 6285 6286 6287 6288 6289 6290 6291 6292 6293 6294 6295 6296 6297 6298 6299 6302 6303 6305 6306 6308 6309 6310 6312 6313 6314 6315 6316 6317 6318 6319 6320 6322 6323 6324 6326 6327 6328 6329 6331 6332 6333 6334 6335 6336 6381 6383 6384 6385 6386 6387 6388 6400 6401 6500 6501 6503 6504 6505 6506 6507 6508 6509 6510 6511 6512 6513 6514 6515 6516 6517 6518 6521 6522 6523 6525 6526 6530 6535 6540 6990 6991 6992 6993 6994 6995
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\all.h ===
/***
*all.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Header file to include all MSL functionality
*
*       [Public]
*
****/

#pragma once

#if !defined(_INC_MSCLR_ALL)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif

#include <msclr\appdomain.h>
#include <msclr\auto_gcroot.h>
#include <msclr\auto_handle.h>
#include <msclr\event.h>
#include <msclr\lock.h>
#include <msclr\gcroot.h>
#include <msclr\com\ptr.h>

#define _INC_MSCLR_ALL

#endif // _INC_MSCLR_ALL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\wctype.h ===
/***
*wctype.h - declarations for wide character functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*       Created from wchar.h January 1996 by P.J. Plauger
*
*Purpose:
*       This file contains the types, macros and function declarations for
*       all ctype-style wide-character functions.  They may also be declared in
*       wchar.h.
*       [ISO]
*
*       Note: keep in sync with ctype.h and wchar.h.
*
*       [Public]
*
****/


#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_WCTYPE
#define _INC_WCTYPE

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#include <crtdefs.h>

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define _CRTIMP2 */
#ifndef _CRTIMP2
#if defined(_DLL) && !defined(_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else   /* ndef _DLL && !STATIC_CPPLIB */
#define _CRTIMP2
#endif  /* _DLL && !STATIC_CPPLIB */
#endif  /* _CRTIMP2 */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif


#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */
#ifndef _CRT_CTYPEDATA_DEFINED
#define _CRT_CTYPEDATA_DEFINED
#ifndef _CTYPE_DISABLE_MACROS

#ifndef __PCTYPE_FUNC
#if defined(_CRT_DISABLE_PERFCRIT_LOCKS) && !defined(_DLL)
#define __PCTYPE_FUNC  _pctype
#else
#define __PCTYPE_FUNC   __pctype_func()
#endif  
#endif  /* __PCTYPE_FUNC */

_CRTIMP const unsigned short * __cdecl __pctype_func(void);
#if !defined(_M_CEE_PURE)
_CRTIMP extern const unsigned short *_pctype;
#else
#define _pctype (__pctype_func())
#endif /* !defined(_M_CEE_PURE) */
#endif  /* _CTYPE_DISABLE_MACROS */
#endif

#ifndef _CRT_WCTYPEDATA_DEFINED
#define _CRT_WCTYPEDATA_DEFINED
#ifndef _CTYPE_DISABLE_MACROS
#if !defined(_M_CEE_PURE)
_CRTIMP extern const unsigned short _wctype[];
#endif /* !defined(_M_CEE_PURE) */

_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
#if !defined(_M_CEE_PURE)
_CRTIMP extern const wctype_t *_pwctype;
#else
#define _pwctype (__pwctype_func())
#endif /* !defined(_M_CEE_PURE) */
#endif  /* _CTYPE_DISABLE_MACROS */
#endif



/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* Function prototypes */

#ifndef _WCTYPE_DEFINED

/* Character classification function prototypes */
/* also declared in ctype.h */

_CRTIMP int __cdecl iswalpha(wint_t);
_CRTIMP int __cdecl iswupper(wint_t);
_CRTIMP int __cdecl iswlower(wint_t);
_CRTIMP int __cdecl iswdigit(wint_t);
_CRTIMP int __cdecl iswxdigit(wint_t);
_CRTIMP int __cdecl iswspace(wint_t);
_CRTIMP int __cdecl iswpunct(wint_t);
_CRTIMP int __cdecl iswalnum(wint_t);
_CRTIMP int __cdecl iswprint(wint_t);
_CRTIMP int __cdecl iswgraph(wint_t);
_CRTIMP int __cdecl iswcntrl(wint_t);
_CRTIMP int __cdecl iswascii(wint_t);
_CRTIMP int __cdecl isleadbyte(int);

_CRTIMP wint_t __cdecl towupper(wint_t);
_CRTIMP wint_t __cdecl towlower(wint_t);

_CRTIMP int __cdecl iswctype(wint_t, wctype_t);

_CRTIMP int __cdecl __iswcsymf(wint_t);
_CRTIMP int __cdecl __iswcsym(wint_t);

_CRT_OBSOLETE(iswctype) _CRTIMP int __cdecl is_wctype(wint_t, wctype_t);

#define _WCTYPE_DEFINED
#endif

#ifndef _WCTYPE_INLINE_DEFINED
#if !defined(__cplusplus) || defined(_M_CEE_PURE) || defined(MRTDLL)
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define isleadbyte(c) (__pctype_func()[(unsigned char)(c)] & _LEADBYTE)
#else   /* __cplusplus */
inline int __cdecl iswalpha(wint_t _C) {return (iswctype(_C,_ALPHA)); }
inline int __cdecl iswupper(wint_t _C) {return (iswctype(_C,_UPPER)); }
inline int __cdecl iswlower(wint_t _C) {return (iswctype(_C,_LOWER)); }
inline int __cdecl iswdigit(wint_t _C) {return (iswctype(_C,_DIGIT)); }
inline int __cdecl iswxdigit(wint_t _C) {return (iswctype(_C,_HEX)); }
inline int __cdecl iswspace(wint_t _C) {return (iswctype(_C,_SPACE)); }
inline int __cdecl iswpunct(wint_t _C) {return (iswctype(_C,_PUNCT)); }
inline int __cdecl iswalnum(wint_t _C) {return (iswctype(_C,_ALPHA|_DIGIT)); }
inline int __cdecl iswprint(wint_t _C)
        {return (iswctype(_C,_BLANK|_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswgraph(wint_t _C)
        {return (iswctype(_C,_PUNCT|_ALPHA|_DIGIT)); }
inline int __cdecl iswcntrl(wint_t _C) {return (iswctype(_C,_CONTROL)); }
inline int __cdecl iswascii(wint_t _C) {return ((unsigned)(_C) < 0x80); }

inline int __cdecl isleadbyte(int _C)
        {return (__pctype_func()[(unsigned char)(_C)] & _LEADBYTE); }
#endif  /* __cplusplus */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

typedef wchar_t wctrans_t;
_MRTIMP2 wint_t __cdecl towctrans(wint_t, wctrans_t);
_MRTIMP2 wctrans_t __cdecl wctrans(const char *);
_MRTIMP2 wctype_t __cdecl wctype(const char *);


#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_WCTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\xmmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * xmmintrin.h
 *
 * Principal header file for Streaming SIMD Extensions intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _MM_FUNCTIONALITY is defined; if it is, the C/x87 implementation
 * will be used (the "faux intrinsics").
 *
 *
 * Note that the m128 datatype provided using _MM2_FUNCTIONALITY mode is
 *   implemented as struct, will not be 128b aligned, will be passed
 *   via the stack, etc.  MM_FUNCTIONALITY mode is not intended for
 *   performance, just semantics.
 *
 */

#pragma once
#ifndef __midl
#ifndef _INCLUDED_MM2
#define _INCLUDED_MM2

#include <crtdefs.h>

#if defined(_M_CEE_PURE)
	#error ERROR: XMM intrinsics not supported in the pure mode!
#else

/*
 * the m64 type is required for the integer Streaming SIMD Extensions intrinsics
 */
#ifndef _MMINTRIN_H_INCLUDED
#include <mmintrin.h>
#endif

#ifdef _MM2_FUNCTIONALITY
/* support old notation */
#ifndef _MM_FUNCTIONALITY
#define _MM_FUNCTIONALITY
#endif
#endif

#ifdef __ICL
#ifdef _MM_FUNCTIONALITY
#include "xmm_func.h"
#else
/* using real intrinsics */
typedef long long __m128;
#endif
#else

typedef union __declspec(intrin_type) _CRT_ALIGN(16) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;

#ifndef _INC_MALLOC
/* pick up _mm_malloc() and _mm_free() */
#include <malloc.h>
#endif
#endif

/*******************************************************/
/* MACRO for shuffle parameter for _mm_shuffle_ps().   */
/* Argument fp3 is a digit[0123] that represents the fp*/
/* from argument "b" of mm_shuffle_ps that will be     */
/* placed in fp3 of result. fp2 is the same for fp2 in */
/* result. fp1 is a digit[0123] that represents the fp */
/* from argument "a" of mm_shuffle_ps that will be     */
/* places in fp1 of result. fp0 is the same for fp0 of */
/* result                                              */
/*******************************************************/
#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) (((fp3) << 6) | ((fp2) << 4) | \
                                     ((fp1) << 2) | ((fp0)))


/*******************************************************/
/* MACRO for performing the transpose of a 4x4 matrix  */
/* of single precision floating point values.          */
/* Arguments row0, row1, row2, and row3 are __m128     */
/* values whose elements form the corresponding rows   */
/* of a 4x4 matrix.  The matrix transpose is returned  */
/* in arguments row0, row1, row2, and row3 where row0  */
/* now holds column 0 of the original matrix, row1 now */
/* holds column 1 of the original matrix, etc.         */
/*******************************************************/
#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3) {                 \
            __m128 tmp3, tmp2, tmp1, tmp0;                          \
                                                                    \
            tmp0   = _mm_shuffle_ps((row0), (row1), 0x44);          \
            tmp2   = _mm_shuffle_ps((row0), (row1), 0xEE);          \
            tmp1   = _mm_shuffle_ps((row2), (row3), 0x44);          \
            tmp3   = _mm_shuffle_ps((row2), (row3), 0xEE);          \
                                                                    \
            (row0) = _mm_shuffle_ps(tmp0, tmp1, 0x88);              \
            (row1) = _mm_shuffle_ps(tmp0, tmp1, 0xDD);              \
            (row2) = _mm_shuffle_ps(tmp2, tmp3, 0x88);              \
            (row3) = _mm_shuffle_ps(tmp2, tmp3, 0xDD);              \
        }


/* constants for use with _mm_prefetch */
#define _MM_HINT_T0     1
#define _MM_HINT_T1     2
#define _MM_HINT_T2     3
#define _MM_HINT_NTA    0

/* (this declspec not supported with 0.A or 0.B) */
#define _MM_ALIGN16 _CRT_ALIGN(16)

/* MACRO functions for setting and reading the MXCSR */
#define _MM_EXCEPT_MASK       0x003f
#define _MM_EXCEPT_INVALID    0x0001
#define _MM_EXCEPT_DENORM     0x0002
#define _MM_EXCEPT_DIV_ZERO   0x0004
#define _MM_EXCEPT_OVERFLOW   0x0008
#define _MM_EXCEPT_UNDERFLOW  0x0010
#define _MM_EXCEPT_INEXACT    0x0020

#define _MM_MASK_MASK         0x1f80
#define _MM_MASK_INVALID      0x0080
#define _MM_MASK_DENORM       0x0100
#define _MM_MASK_DIV_ZERO     0x0200
#define _MM_MASK_OVERFLOW     0x0400
#define _MM_MASK_UNDERFLOW    0x0800
#define _MM_MASK_INEXACT      0x1000

#define _MM_ROUND_MASK        0x6000
#define _MM_ROUND_NEAREST     0x0000
#define _MM_ROUND_DOWN        0x2000
#define _MM_ROUND_UP          0x4000
#define _MM_ROUND_TOWARD_ZERO 0x6000

#define _MM_FLUSH_ZERO_MASK   0x8000
#define _MM_FLUSH_ZERO_ON     0x8000
#define _MM_FLUSH_ZERO_OFF    0x0000

#define _MM_SET_EXCEPTION_STATE(mask)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | (mask))
#define _MM_GET_EXCEPTION_STATE()                                   \
            (_mm_getcsr() & _MM_EXCEPT_MASK)

#define _MM_SET_EXCEPTION_MASK(mask)                                \
            _mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | (mask))
#define _MM_GET_EXCEPTION_MASK()                                    \
            (_mm_getcsr() & _MM_MASK_MASK)

#define _MM_SET_ROUNDING_MODE(mode)                                 \
            _mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | (mode))
#define _MM_GET_ROUNDING_MODE()                                     \
            (_mm_getcsr() & _MM_ROUND_MASK)

#define _MM_SET_FLUSH_ZERO_MODE(mode)                               \
            _mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | (mode))
#define _MM_GET_FLUSH_ZERO_MODE(mode)                               \
            (_mm_getcsr() & _MM_FLUSH_ZERO_MASK)

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif /* __cplusplus */

/*
 * FP, arithmetic
 */

extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);

/*
 * FP, logical
 */

extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);

/*
 * FP, comparison
 */

extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);

/*
 * FP, conversions
 */

extern int _mm_cvt_ss2si(__m128 _A);
extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
extern float _mm_cvtss_f32(__m128 _A);

/* 
 * Support for 64-bit extension intrinsics 
 */
#if defined(_M_AMD64)
extern __int64 _mm_cvtss_si64(__m128 _A);
extern __int64 _mm_cvttss_si64(__m128 _A);
extern __m128  _mm_cvtsi64_ss(__m128 _A, __int64 _B);
#endif

/*
 * FP, misc
 */

extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);


/*
 * Integer extensions
 */
extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);

/*
 * memory & initialization
 */

extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);

#ifdef __ICL
extern void* __cdecl _mm_malloc(size_t _Siz, size_t _Al);
extern void __cdecl _mm_free(void *_P);
#endif

/* Alternate intrinsic names definition */
#define _mm_cvtss_si32    _mm_cvt_ss2si
#define _mm_cvtps_pi32    _mm_cvt_ps2pi
#define _mm_cvttss_si32   _mm_cvtt_ss2si
#define _mm_cvttps_pi32   _mm_cvtt_ps2pi
#define _mm_cvtsi32_ss    _mm_cvt_si2ss
#define _mm_cvtpi32_ps    _mm_cvt_pi2ps
#define _mm_extract_pi16  _m_pextrw
#define _mm_insert_pi16   _m_pinsrw
#define _mm_max_pi16      _m_pmaxsw
#define _mm_max_pu8       _m_pmaxub
#define _mm_min_pi16      _m_pminsw
#define _mm_min_pu8       _m_pminub
#define _mm_movemask_pi8  _m_pmovmskb
#define _mm_mulhi_pu16    _m_pmulhuw
#define _mm_shuffle_pi16  _m_pshufw
#define _mm_maskmove_si64 _m_maskmovq
#define _mm_avg_pu8       _m_pavgb
#define _mm_avg_pu16      _m_pavgw
#define _mm_sad_pu8       _m_psadbw
#define _mm_set1_ps       _mm_set_ps1
#define _mm_load1_ps      _mm_load_ps1
#define _mm_store1_ps     _mm_store_ps1

/******************************************************/
/* UTILITY INTRINSICS FUNCTION DEFINITIONS START HERE */
/******************************************************/

/*********************************************************/
/*  NAME : _mm_cvtpi16_ps                                */
/*  DESCRIPTION : Convert 4 16-bit signed integer values */
/*                to 4 single-precision float values     */
/*  IN : __m64 a                                         */
/*  OUT : none                                           */
/*  RETURN : __m128 : (float)a                           */
/*********************************************************/
__inline __m128 _mm_cvtpi16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_cmpgt_pi16(_mm_setzero_si64(), a);

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp), 
                        _mm_unpacklo_pi16(a, ext_val)));
}


/***********************************************************/
/*  NAME : _mm_cvtpu16_ps                                  */
/*  DESCRIPTION : Convert 4 16-bit unsigned integer values */
/*                to 4 single-precision float values       */
/*  IN : __m64 a                                           */
/*  OUT : none                                             */
/*  RETURN : __m128 : (float)a                             */
/***********************************************************/
__inline __m128 _mm_cvtpu16_ps(__m64 a)
{
  __m128 tmp;
  __m64  ext_val = _mm_setzero_si64();

  tmp = _mm_cvtpi32_ps(_mm_setzero_ps(), _mm_unpackhi_pi16(a, ext_val));
  return(_mm_cvtpi32_ps(_mm_movelh_ps(tmp, tmp), 
                        _mm_unpacklo_pi16(a, ext_val)));
}


/******************************************************/
/*  NAME : _mm_cvtps_pi16                             */
/*  DESCRIPTION : Convert 4 single-precision float    */
/*                values to 4 16-bit integer values   */
/*  IN : __m128 a                                     */
/*  OUT : none                                        */
/*  RETURN : __m64 : (short)a                         */
/******************************************************/
__inline __m64 _mm_cvtps_pi16(__m128 a)
{
  return _mm_packs_pi32(_mm_cvtps_pi32(a), 
                        _mm_cvtps_pi32(_mm_movehl_ps(a, a)));
}


/******************************************************/
/*  NAME : _mm_cvtpi8_ps                              */
/*  DESCRIPTION : Convert 4 8-bit integer values to 4 */
/*                single-precision float values       */
/*  IN : __m64 a                                      */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a                        */
/******************************************************/
__inline __m128 _mm_cvtpi8_ps(__m64 a)
{
  __m64  ext_val = _mm_cmpgt_pi8(_mm_setzero_si64(), a);

  return _mm_cvtpi16_ps(_mm_unpacklo_pi8(a, ext_val));
}


/******************************************************/
/*  NAME : _mm_cvtpu8_ps                              */
/*  DESCRIPTION : Convert 4 8-bit unsigned integer    */
/*                values to 4 single-precision float  */
/*                values                              */
/*  IN : __m64 a                                      */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a                        */
/******************************************************/
__inline __m128 _mm_cvtpu8_ps(__m64 a)
{
  return _mm_cvtpu16_ps(_mm_unpacklo_pi8(a, _mm_setzero_si64()));
}


/******************************************************/
/*  NAME : _mm_cvtps_pi8                              */
/*  DESCRIPTION : Convert 4 single-precision float    */
/*                values to 4 8-bit integer values    */
/*  IN : __m128 a                                     */
/*  OUT : none                                        */
/*  RETURN : __m64 : (char)a                          */
/******************************************************/
__inline __m64 _mm_cvtps_pi8(__m128 a)
{
  return _mm_packs_pi16(_mm_cvtps_pi16(a), _mm_setzero_si64());
}


/******************************************************/
/*  NAME : _mm_cvtpi32x2_ps                           */
/*  DESCRIPTION : Convert 4 32-bit integer values     */
/*                to 4 single-precision float values  */
/*  IN : __m64 a : operand 1                          */
/*       __m64 b : operand 2                          */
/*  OUT : none                                        */
/*  RETURN : __m128 : (float)a,(float)b               */
/******************************************************/
__inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a), 
                       _mm_cvt_pi2ps(_mm_setzero_ps(), b)); 
}


#if defined __cplusplus
}; /* End "C" */
#endif /* __cplusplus */

#endif /* defined(_M_CEE_PURE) */

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\ymath.h ===
/* ymath.h internal header */
#pragma once
#ifndef _YMATH
#define _YMATH
#include <yvals.h>
_C_STD_BEGIN
#ifndef _M_CEE_PURE
_C_LIB_DECL
#endif

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

		/* MACROS FOR _Dtest RETURN (0 => ZERO) */
#define _DENORM		(-2)	/* C9X only */
#define _FINITE		(-1)
#define _INFCODE	1
#define _NANCODE	2

		/* MACROS FOR _Feraise ARGUMENT */
#define _FE_DIVBYZERO	0x04
#define _FE_INEXACT		0x20
#define _FE_INVALID		0x01
#define _FE_OVERFLOW	0x08
#define _FE_UNDERFLOW	0x10

		/* TYPE DEFINITIONS */
typedef union
	{	/* pun float types as integer array */
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		/* ERROR REPORTING */
void __CLRCALL_PURE_OR_CDECL _Feraise(int);

		/* double DECLARATIONS */
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Cosh(double, double);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Dtest(double *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _Exp(double *, double, short);
_CRTIMP2_PURE double __CLRCALL_PURE_OR_CDECL _Sinh(double, double);
extern _CRTIMP2_PURE /* const */ _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		/* float DECLARATIONS */
_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _FCosh(float, float);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FDtest(float *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _FExp(float *, float, short);
_CRTIMP2_PURE float __CLRCALL_PURE_OR_CDECL _FSinh(float, float);
extern _CRTIMP2_PURE /* const */ _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		/* long double DECLARATIONS */
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LCosh(long double, long double);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LDtest(long double *);
_CRTIMP2_PURE short __CLRCALL_PURE_OR_CDECL _LExp(long double *, long double, short);
_CRTIMP2_PURE long double __CLRCALL_PURE_OR_CDECL _LSinh(long double, long double);
extern _CRTIMP2_PURE /* const */ _Dconst _LDenorm, _LInf, _LNan, _LSnan;
#ifndef _M_CEE_PURE
_END_C_LIB_DECL
#endif
_C_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YMATH */

/*
 * Copyright (c) 1992-2006 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.02:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\auto_gcroot.h ===
/***
*auto_gcroot.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   automatic resource management, like std::auto_ptr which can be used
*           to embed a virtual handle into a native type
*
*       [Public]
*
****/

#pragma once

#if !defined(_INC_MSCLR_AUTO_GCROOT)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif

#include <vcclr.h>
#include <msclr\safebool.h>
#include <algorithm>

namespace msclr
{

// Forward Declaration
template<typename _element_type>
class auto_gcroot;

namespace _detail
{

// _auto_gcroot_ref is a proxy reference for auto_gcroot copying.
// auto_gcroot's copy constructor takes a non-const reference
// because it must assume ownership from the source. But this
// makes it impossible for auto_gcroot to be returned by value,
// because temporary objects cannot be bound to non-const
// references. Instead, a conversion to _auto_gcroot_ref is provided,
// and an auto_gcroot can be initialized from an _auto_gcroot_ref.

    template<typename _element_type>
    struct _auto_gcroot_ref
    {
        // construct from compatible auto_gcroot
        _auto_gcroot_ref( auto_gcroot<_element_type> & ref ) 
            : m_ref( ref )
        {
        }

        // reference to constructor argument
        auto_gcroot<_element_type> & m_ref;

    };

} // namespace detail

// wrap a resource to enforce strict ownership and ensure proper cleanup
template<typename _element_type>
class auto_gcroot
{
private:
    // disallow explicit comparisons to _safe_bool
    bool operator==( _detail_class::_safe_bool ) const;
    bool operator!=( _detail_class::_safe_bool ) const;
    
public:

    // Constructors
    
    // construct from object pointer
    auto_gcroot( _element_type _ptr = nullptr ) 
        : m_ptr( _ptr )
    {
    }

    // construct by assuming pointer from _right auto_gcroot
    auto_gcroot( auto_gcroot<_element_type> & _right ) 
            : m_ptr( _right.release() )
    {
    }

    // construct by assuming pointer from _right _detail::_auto_gcroot_ref
    auto_gcroot( _detail::_auto_gcroot_ref<_element_type> _right ) 
        : m_ptr( _right.m_ref.release() )
    {
    }

    template<typename _other_type>
    auto_gcroot( auto_gcroot<_other_type> & _right ) 
        : m_ptr( _right.release() )
    {
    }

    auto_gcroot<_element_type> & attach(_element_type _right)
    {
        reset(_right);
        return *this;
    }
    
    // assign compatible _right
    auto_gcroot<_element_type> & attach( 
        auto_gcroot<_element_type> & _right ) 
    {
        reset( _right.release() );
        return *this;
    }

    // assign compatible _right.ref
    auto_gcroot<_element_type> & attach( 
        _detail::_auto_gcroot_ref<_element_type> & _right ) 
    {
        reset( _right.m_ref.release() );
        return *this;
    }

    template<typename _other_type>
    auto_gcroot<_element_type> & attach(
    auto_gcroot<_other_type> & _right ) 
    {
        reset( _right.release() );
        return *this;
    }

    auto_gcroot<_element_type> & operator=(_element_type _right)
    {
        return attach(_right);
    }
    
    // assign compatible _right
    auto_gcroot<_element_type> & operator=( 
        auto_gcroot<_element_type> & _right ) 
    {
        return attach(_right);
    }

    // assign compatible _right.ref
    auto_gcroot<_element_type> & operator=( 
        _detail::_auto_gcroot_ref<_element_type> & _right ) 
    {
        return attach(_right);
    }

    template<typename _other_type>
    auto_gcroot<_element_type> & operator=(
    auto_gcroot<_other_type> & _right ) 
    {
        return attach(_right);
    }

    _element_type get() const 
    {
        return m_ptr;
    }

    // return pointer to class object (assume pointer)
    _element_type operator->() const 
    {
        return m_ptr;
    }

    // for use when auto_gcroot appears in a conditional
    operator _detail_class::_safe_bool() const 
    {
        return valid() ? _detail_class::_safe_true : _detail_class::_safe_false;
    }

    // for use when auto_gcroot appears in a conditional
    bool operator!() const 
    {
        return ! valid();
    }

    // convert to compatible _detail::_auto_gcroot_ref
    operator _detail::_auto_gcroot_ref<_element_type>() 
    {
        return _detail::_auto_gcroot_ref<_element_type>( *this );
    }

    template<typename _other_type>
    operator auto_gcroot<_other_type>() 
    {
        return auto_gcroot<_other_type>( *this );
    }

    template<typename _other_type>
    operator _detail::_auto_gcroot_ref<_other_type>() 
    {
        return _detail::_auto_gcroot_ref<_other_type>( *this );
    }

    void swap( auto_gcroot<_element_type> & _right ) 
    {
        m_ptr.swap( _right.m_ptr );
    }

    void reset( _element_type _new_ptr = nullptr ) 
    {
        if( _element_type(m_ptr) != _new_ptr )
        {
            if( valid() )
            {
                delete _element_type(m_ptr);
            }
            m_ptr = _new_ptr;
        }
    }

    _element_type release() 
    {
        _element_type _tmp_ptr = m_ptr;
        m_ptr = nullptr;
        return _tmp_ptr;
    }

    // destroy the object
    ~auto_gcroot()
    {
        if( valid() )
        {
            delete _element_type(m_ptr);
        }
    }

private:

    bool valid() const 
    {
        // see if the managed resource is in the invalid state.
        return _element_type(m_ptr) != nullptr;
    }

    // the wrapped object
    gcroot<_element_type> m_ptr;
};

// swap the contents of two auto_gcroot objects
template<typename _element_type>
void swap( auto_gcroot<_element_type> & _left, 
           auto_gcroot<_element_type> & _right ) 
{
    _left.swap( _right );
}

} // namespace msclr

#define _INC_MSCLR_AUTO_GCROOT

#endif // _INC_MSCLR_AUTO_GCROOT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\event.h ===
/***
*event.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   delegate_proxy_factory class
*
*       [Public]
*
****/

#pragma once

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif

#include <gcroot.h>

namespace msclr {
    namespace delegate_map {
        namespace internal {

        template <typename CLASS> class delegate_proxy_factory
        {
            typedef typename CLASS::delegate_proxy_type proxy_type;
            gcroot<proxy_type^> m_gc_managed_native_delegate_proxy;
    
            public:
            delegate_proxy_factory() {}
            
            virtual ~delegate_proxy_factory()
            {
                if((proxy_type^)m_gc_managed_native_delegate_proxy != nullptr) 
                {
                    m_gc_managed_native_delegate_proxy->detach();
                }
            }

            proxy_type^ get_proxy(CLASS* pNativeTarget)
            {
                if((proxy_type^)m_gc_managed_native_delegate_proxy == nullptr)
                {
                    m_gc_managed_native_delegate_proxy = gcnew proxy_type(pNativeTarget);
                }
                return (proxy_type^)m_gc_managed_native_delegate_proxy;                 
            }
        };

        }
    }
}


#define BEGIN_DELEGATE_MAP(CLASS)\
        ref class delegate_proxy_type;\
        msclr::delegate_map::internal::delegate_proxy_factory<CLASS> m_delegate_map_proxy;\
        \
        ref class delegate_proxy_type\
        {\
                CLASS* m_p_native_target;\
        public:\
                delegate_proxy_type(CLASS* pNativeTarget) : m_p_native_target(pNativeTarget) {}\
                void detach() { m_p_native_target = NULL; }

#define EVENT_DELEGATE_ENTRY(MEMBER,ARG0,ARG1)\
        void MEMBER(ARG0 arg0,ARG1 arg1)\
        {\
                if(m_p_native_target == NULL)\
                throw gcnew System::ArgumentNullException("Delegate call failed: Native sink was not attached or has already detached from the managed proxy (m_p_native_target == NULL). Hint: see if native sink was destructed or not constructed properly");\
                \
                m_p_native_target->MEMBER(arg0,arg1);\
        }

#define END_DELEGATE_MAP()\
        };

#define MAKE_DELEGATE(DELEGATE,MEMBER)\
        gcnew DELEGATE(m_delegate_map_proxy.get_proxy(this),&delegate_proxy_type::MEMBER)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\gcroot.h ===
/***
*gcroot.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:  Template class that wraps GCHandle from mscorlib.dll.
*
*	Use this class to declare gc "pointers" that live in the C++ heap.
*	
*	Example:
*		struct StringList {
*			msclr::gcroot<String^> str;
*			StringList *next;
*			StringList(); // should have ctors and dtors
*			~StringList();
*		};
*
*	By convention, we maintain a 1-to-1 relationship between C++ objects
*	and the handle slots they "point" to.  Thus, two distinct C++ objects
*	always refer to two distinct handles, even if they "point" to the same
*	object.  Therefore, when the C++ object is destroyed, its handle can
*	be freed without error.
*
*	Note that we cannot currently embed a GCHandle directly in an unmanaged C++
*	class.  We therefore store a void*, and use the conversion methods of
*	GCHandle to reconstitute a GCHandle from the void* on demand.
*
*   [Public]
*
****/

#pragma once

#if !defined(_INC_MSCLR_GCROOT)
#define _INC_MSCLR_GCROOT
#ifndef RC_INVOKED

#include <stddef.h>


#ifdef __cplusplus_cli
 #define __GCHANDLE_TO_VOIDPTR(x) ((GCHandle::operator System::IntPtr(x)).ToPointer())
 #define __VOIDPTR_TO_GCHANDLE(x) (GCHandle::operator GCHandle(System::IntPtr(x)))
 #define __NULLPTR nullptr
#else
 #define __GCHANDLE_TO_VOIDPTR(x) ((GCHandle::op_Explicit(x)).ToPointer())
 #define __VOIDPTR_TO_GCHANDLE(x) (GCHandle::op_Explicit(x))
 #define __NULLPTR 0
#endif

#ifndef __DEFINE_GCROOT_IN_GLOBAL_NAMESPACE
namespace msclr
{
#endif

template <class T> struct gcroot {

	typedef System::Runtime::InteropServices::GCHandle GCHandle;

	// always allocate a new handle during construction (see above)
	//
	[System::Diagnostics::DebuggerStepThroughAttribute]
	gcroot() {
		_handle = __GCHANDLE_TO_VOIDPTR(GCHandle::Alloc(__NULLPTR));
	}

	// this can't be T& here because & does not yet work on managed types
	// (T should be a pointer anyway).
	//
	gcroot(T t) {
		_handle = __GCHANDLE_TO_VOIDPTR(GCHandle::Alloc(t));
	}

	gcroot(const gcroot& r) {
		// don't copy a handle, copy what it points to (see above)
		_handle = __GCHANDLE_TO_VOIDPTR(
						GCHandle::Alloc(
							__VOIDPTR_TO_GCHANDLE(r._handle).Target ));
	}

	// Since C++ objects and handles are allocated 1-to-1, we can 
	// free the handle when the object is destroyed
	//
	[System::Diagnostics::DebuggerStepThroughAttribute]
	~gcroot() {
		GCHandle g = __VOIDPTR_TO_GCHANDLE(_handle);
		g.Free();
		_handle = 0; // should fail if reconstituted
	}

	[System::Diagnostics::DebuggerStepThroughAttribute]
	gcroot& operator=(T t) {
		// no need to check for valid handle; was allocated in ctor
		__VOIDPTR_TO_GCHANDLE(_handle).Target = t;
		return *this;
	}

	gcroot& operator=(const gcroot &r) {
		// no need to check for valid handle; was allocated in ctor
		T t = (T)r;
		__VOIDPTR_TO_GCHANDLE(_handle).Target = t;
		return *this;
	}

	void swap( gcroot<T> & _right )
	{
		using std::swap;
		swap( _handle, _right._handle );
	}

	operator T () const {
		// gcroot is typesafe, so use static_cast
		return static_cast<T>( __VOIDPTR_TO_GCHANDLE(_handle).Target );
	}

	// don't return T& here because & to gc pointer not yet implemented
	// (T should be a pointer anyway).
	T operator->() const {
		// gcroot is typesafe, so use static_cast
		return static_cast<T>(__VOIDPTR_TO_GCHANDLE(_handle).Target);
	}

private:
	// Don't let anyone copy the handle value directly, or make a copy
	// by taking the address of this object and pointing to it from
	// somewhere else.  The root will be freed when the dtor of this
	// object gets called, and anyone pointing to it still will
	// cause serious harm to the Garbage Collector.
	//
	void* _handle;
	T* operator& ();
};

template<typename T>
void swap( gcroot<T> & _left,
	gcroot<T> & _right )
{
	_left.swap( _right );
}

#ifndef __DEFINE_GCROOT_IN_GLOBAL_NAMESPACE
} // namespace msclr
#endif

#undef __GCHANDLE_TO_VOIDPTR
#undef __VOIDPTR_TO_GCHANDLE
#undef __NULLPTR

#endif /* RC_INVOKED */
#endif  // _INC_MSCLR_GCROOT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\yvals.h ===
/* yvals.h values header for Microsoft C/C++ */
#pragma once
#ifndef _YVALS
#define _YVALS

#include <crtdefs.h>

#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#define _CPPLIB_VER	503

/* Note on use of "deprecate":
 * Various places in this header and other headers use __declspec(deprecate) or macros that have the term DEPRECATE in them.
 * We use deprecate here ONLY to signal the compiler to emit a warning about these items. The use of deprecate
 * should NOT be taken to imply that any standard committee has deprecated these functions from the relevant standards.
 * In fact, these functions are NOT deprecated from the standard.
 *
 * Full details can be found in our documentation by searching for "Checked Iterators".
*/

#define __PURE_APPDOMAIN_GLOBAL

#ifndef __CRTDECL
#if defined(_M_CEE_PURE) || defined(MRTDLL)
#define __CRTDECL   __clrcall
#else
#define __CRTDECL   __cdecl
#endif
#endif

#ifndef __CLR_OR_THIS_CALL
#if defined(MRTDLL) || defined(_M_CEE_PURE)
#define __CLR_OR_THIS_CALL  __clrcall
#else
#define __CLR_OR_THIS_CALL
#endif
#endif

#ifndef __CLRCALL_OR_CDECL
#if defined(MRTDLL) || defined(_M_CEE_PURE)
#define __CLRCALL_OR_CDECL __clrcall
#else
#define __CLRCALL_OR_CDECL __cdecl
#endif
#endif

#ifndef __CLRCALL_PURE_OR_CDECL
#if defined(_M_CEE_PURE)
#define __CLRCALL_PURE_OR_CDECL __clrcall
#else
#define __CLRCALL_PURE_OR_CDECL __cdecl
#endif
#endif

		/* NAMING PROPERTIES */
#define _WIN32_C_LIB	1

		/* THREAD AND LOCALE CONTROL */
#define _MULTI_THREAD	1	/* nontrivial locks if multithreaded */
#define _IOSTREAM_OP_LOCKS	1	/* lock iostream operations */
#define _GLOBAL_LOCALE	0	/* 0 for per-thread locales, 1 for shared */

		/* THREAD-LOCAL STORAGE */
#define _COMPILER_TLS	1	/* 1 if compiler supports TLS directly */
 #if _MULTI_THREAD
  #define _TLS_QUAL	__declspec(thread)	/* TLS qualifier, if any */

 #else /* _MULTI_THREAD */
  #define _TLS_QUAL
 #endif /* _MULTI_THREAD */

 #ifndef _HAS_EXCEPTIONS
  #define  _HAS_EXCEPTIONS  1	/* predefine as 0 to disable exceptions */
 #endif /* _HAS_EXCEPTIONS */

 #ifndef _HAS_NAMESPACE
  #define  _HAS_NAMESPACE  1	/* predefine as 0 to disable exceptions */
 #endif /* _HAS_NAMESPACE */

#ifndef _HAS_IMMUTABLE_SETS
 #define _HAS_IMMUTABLE_SETS 0
#endif /* _HAS_IMMUTABLE_SETS */

#ifndef _HAS_STRICT_CONFORMANCE
 #define _HAS_STRICT_CONFORMANCE 0
#endif /* _HAS_STRICT_CONFORMANCE */

#ifndef _HAS_TRADITIONAL_STL
 #define _HAS_TRADITIONAL_STL 0
#endif /* _HAS_TRADITIONAL_STL */

#ifdef _MSC_VER
#define _GLOBAL_USING	1
#endif

#if !defined (_HAS_ITERATOR_DEBUGGING)
	#if defined (_DEBUG)
		#define _HAS_ITERATOR_DEBUGGING	1	/* for range checks, etc. */
	#else
		#define _HAS_ITERATOR_DEBUGGING	0
	#endif	/* defined (_DEBUG) */
#else
	#if !defined (_DEBUG) && _HAS_ITERATOR_DEBUGGING != 0
		#include <crtwrn.h>
		#pragma _CRT_WARNING( _NO_ITERATOR_DEBUGGING )
		#undef _HAS_ITERATOR_DEBUGGING
		#define _HAS_ITERATOR_DEBUGGING 0
	#endif
#endif /* !defined (_HAS_ITERATOR_DEBUGGING) */

/* _SECURE_CRT definitions */

#define __STR2WSTR(str)    L##str
#define _STR2WSTR(str)     __STR2WSTR(str)

#define __FILEW__          _STR2WSTR(__FILE__)
#define __FUNCTIONW__      _STR2WSTR(__FUNCTION__)

/* _SECURE_SCL switches: default values */

#if !defined (_SECURE_SCL)
#define _SECURE_SCL 1
#endif

/* See note on use of deprecate at the top of this file */
#if !defined(_SCL_SECURE_NO_WARNINGS) && defined(_SCL_SECURE_NO_DEPRECATE)
#define _SCL_SECURE_NO_WARNINGS
#endif

#if !defined (_SECURE_SCL_DEPRECATE)
#if defined(_SCL_SECURE_NO_WARNINGS)
#define _SECURE_SCL_DEPRECATE 0
#else
#define _SECURE_SCL_DEPRECATE 1
#endif
#endif

#if !defined (_SECURE_SCL_THROWS)
#define _SECURE_SCL_THROWS 0
#endif

/* _SECURE_SCL switches: helper macros */
/* See note on use of deprecate at the top of this file */

#if _SECURE_SCL_DEPRECATE
#define _SCL_CHECKED_ALGORITHM_WARN \
	_CRT_DEPRECATE_TEXT( \
		"Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " \
		"To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")
#else
#define _SCL_CHECKED_ALGORITHM_WARN
#endif

#if _SECURE_SCL && _SECURE_SCL_DEPRECATE
#define _SCL_INSECURE_DEPRECATE \
	_CRT_DEPRECATE_TEXT( \
		"Function call with parameters that may be unsafe - this call relies on the caller to check that the passed values are correct. " \
		"To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. See documentation on how to use Visual C++ 'Checked Iterators'")
#else
#define _SCL_INSECURE_DEPRECATE
#endif

/*
 * Assert in debug builds.
 * set errno and return
 *
 */
 #ifdef _DEBUG 

#ifndef _SCL_SECURE_INVALID_PARAMETER
#define _SCL_SECURE_INVALID_PARAMETER(expr) ::_invalid_parameter(__STR2WSTR(#expr), __FUNCTIONW__, __FILEW__, __LINE__, 0)
#endif

 #else

#ifndef _SCL_SECURE_INVALID_PARAMETER
#define _SCL_SECURE_INVALID_PARAMETER(expr) ::_invalid_parameter_noinfo()
#endif

 #endif

 #if _SECURE_SCL_THROWS

 #define _SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT		_Xinvarg()
 #define _SCL_SECURE_OUT_OF_RANGE_NO_ASSERT			_Xran()

 #else /* _SECURE_SCL_THROWS */

 #define _SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT		_SCL_SECURE_INVALID_PARAMETER("invalid argument")
 #define _SCL_SECURE_OUT_OF_RANGE_NO_ASSERT			_SCL_SECURE_INVALID_PARAMETER("out of range")

 #endif /* _SECURE_SCL_THROWS */

 #define _SCL_SECURE_ALWAYS_VALIDATE(cond)				\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE((#cond, 0));						\
			_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;		\
		}												\
		__analysis_assume(cond);						\
	}

 #define _SCL_SECURE_ALWAYS_VALIDATE_RANGE(cond)		\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE((#cond, 0));						\
			_SCL_SECURE_OUT_OF_RANGE_NO_ASSERT;			\
		}												\
		__analysis_assume(cond);						\
	}

// validation a la Secure CRT
 #define _SCL_SECURE_CRT_VALIDATE(cond, retvalue)		\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE((#cond, 0));						\
			_SCL_SECURE_INVALID_PARAMETER(cond);		\
			return (retvalue);							\
		}												\
	}

 #if _SECURE_SCL

 #define _SCL_SECURE_VALIDATE(cond)						\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE((#cond, 0));						\
			_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;		\
		}												\
		__analysis_assume(cond);						\
	}

 #define _SCL_SECURE_VALIDATE_RANGE(cond)				\
	{													\
		if (!(cond))									\
		{												\
			_ASSERTE((#cond, 0));						\
			_SCL_SECURE_OUT_OF_RANGE_NO_ASSERT;			\
		}												\
		__analysis_assume(cond);						\
	}

 #define _SCL_SECURE_INVALID_ARGUMENT					\
	{													\
		_ASSERTE(("Standard C++ Libraries Invalid Argument", 0)); \
		_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;			\
	}
 #define _SCL_SECURE_OUT_OF_RANGE						\
	{													\
		_ASSERTE(("Standard C++ Libraries Out of Range", 0)); \
		_SCL_SECURE_OUT_OF_RANGE_NO_ASSERT;				\
	}

 #define _SCL_SECURE_MOVE(func, dst, size, src, count)	func((dst), (size), (src), (count))
 #define _SCL_SECURE_COPY(func, dst, size, src, count)	func((dst), (size), (src), (count))

 #else /* _SECURE_SCL */
 
/* when users disable _SECURE_SCL to get performance, we don't want analysis warnings from SCL headers */
#if _HAS_ITERATOR_DEBUGGING
 #define _SCL_SECURE_VALIDATE(cond)			__analysis_assume(cond)
 #define _SCL_SECURE_VALIDATE_RANGE(cond)	__analysis_assume(cond)
#else
 #define _SCL_SECURE_VALIDATE(cond)
 #define _SCL_SECURE_VALIDATE_RANGE(cond)
#endif

 #define _SCL_SECURE_INVALID_ARGUMENT 
 #define _SCL_SECURE_OUT_OF_RANGE 

 #define _SCL_SECURE_MOVE(func, dst, size, src, count)	func((dst), (src), (count))
 #define _SCL_SECURE_COPY(func, dst, size, src, count)	func((dst), (src), (count))

 #endif /* _SECURE_SCL */

/* _SECURE_VALIDATION is the name of the bool template argument used to define iterators
   with secure validation selectively turned on or off (for an example, see the std::list
   iterators). Notice that all the _SCL_SECURE_TRAITS_* validation macros are almost identical
   to the _SCL_SECURE_* macros defined above. The only difference is the:
        
        if (_SECURE_VALIDATION) { }

   statement, which will statically evaluate to true or false. With optimizations on, the
   compiler will optimize the check away.
 */
 #define _SECURE_VALIDATION _Secure_validation

 #if _SECURE_SCL

 #define _SECURE_VALIDATION_DEFAULT true

 #define _SCL_SECURE_TRAITS_VALIDATE(cond)		\
	{											\
		__pragma(warning(push));				\
		__pragma(warning(disable: 4127));		\
		if (_SECURE_VALIDATION)					\
		{										\
			_SCL_SECURE_VALIDATE(cond)			\
		}										\
		__pragma(warning(pop));					\
	}

 #define _SCL_SECURE_TRAITS_VALIDATE_RANGE(cond) \
	{											\
		__pragma(warning(push));				\
		__pragma(warning(disable: 4127));		\
		if (_SECURE_VALIDATION)					\
		{										\
			_SCL_SECURE_VALIDATE_RANGE(cond)	\
		}										\
		__pragma(warning(pop));					\
	}

 #define _SCL_SECURE_TRAITS_INVALID_ARGUMENT	\
	{											\
		__pragma(warning(push));				\
		__pragma(warning(disable: 4127));		\
		if (_SECURE_VALIDATION)					\
		{										\
			_SCL_SECURE_INVALID_ARGUMENT		\
		}										\
		__pragma(warning(pop));					\
	}

 #define _SCL_SECURE_TRAITS_OUT_OF_RANGE		\
	{											\
		__pragma(warning(push));				\
		__pragma(warning(disable: 4127));		\
		if (_SECURE_VALIDATION)					\
		{										\
			_SCL_SECURE_OUT_OF_RANGE			\
		}										\
		__pragma(warning(pop));					\
	}

 #else

 #define _SECURE_VALIDATION_DEFAULT false

 #define _SCL_SECURE_TRAITS_VALIDATE(cond)
 #define _SCL_SECURE_TRAITS_VALIDATE_RANGE(cond)

 #define _SCL_SECURE_TRAITS_INVALID_ARGUMENT
 #define _SCL_SECURE_TRAITS_OUT_OF_RANGE

 #endif

#if __STDC_WANT_SECURE_LIB__
#define _CRT_SECURE_MEMCPY(dest, destsize, source, count) ::memcpy_s((dest), (destsize), (source), (count))
#define _CRT_SECURE_MEMMOVE(dest, destsize, source, count) ::memmove_s((dest), (destsize), (source), (count))
#define _CRT_SECURE_WMEMCPY(dest, destsize, source, count) ::wmemcpy_s((dest), (destsize), (source), (count))
#define _CRT_SECURE_WMEMMOVE(dest, destsize, source, count) ::wmemmove_s((dest), (destsize), (source), (count))
#else
#define _CRT_SECURE_MEMCPY(dest, destsize, source, count) ::memcpy((dest), (source), (count))
#define _CRT_SECURE_MEMMOVE(dest, destsize, source, count) ::memmove((dest), (source), (count))
#define _CRT_SECURE_WMEMCPY(dest, destsize, source, count) ::wmemcpy((dest), (source), (count))
#define _CRT_SECURE_WMEMMOVE(dest, destsize, source, count) ::wmemmove((dest), (source), (count))
#endif

#include <use_ansi.h>

#ifndef _VC6SP2
 #define _VC6SP2	0 /* define as 1 to fix linker errors with V6.0 SP2 */
#endif /* _VC6SP2 */

#if defined(_M_CEE) && defined(_STATIC_CPPLIB)
#include <crtwrn.h>
#pragma _CRT_WARNING( _CLR_AND_STATIC_CPPLIB )
#endif

/* Define _CRTIMP2 */
 #ifndef _CRTIMP2

   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _CRTIMP2	__declspec(dllimport)

   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _CRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */

 #endif  /* _CRTIMP2 */

/* Define _CRTIMP2_NCEEPURE */
 #ifndef _CRTIMP2_NCEEPURE
  #if defined(_M_CEE_PURE)
   #define _CRTIMP2_NCEEPURE
  #else
   #define _CRTIMP2_NCEEPURE _CRTIMP2
  #endif
 #endif

#ifndef _MRTIMP
    #define _MRTIMP __declspec(dllimport)
#endif  /* _MRTIMP */

/* Define _MRTIMP2 */
 #ifndef _MRTIMP2

   #if defined(_DLL) && !defined(_STATIC_CPPLIB)
    #define _MRTIMP2	__declspec(dllimport)

   #else   /* ndef _DLL && !STATIC_CPPLIB */
    #define _MRTIMP2
   #endif  /* _DLL && !STATIC_CPPLIB */

 #endif  /* _MRTIMP2 */

/* Define _MRTIMP2_NPURE */
 #ifndef _MRTIMP2_NPURE

   #if defined(_DLL) && defined(_M_CEE_PURE)
    #define _MRTIMP2_NPURE	__declspec(dllimport)

   #else
    #define _MRTIMP2_NPURE
   #endif

 #endif  /* _MRTIMP2_NPURE */

/* Define _MRTIMP2_NCEE */
 #ifndef _MRTIMP2_NCEE
  #if defined(_M_CEE)
   #define _MRTIMP2_NCEE
  #else
   #define _MRTIMP2_NCEE _MRTIMP2
  #endif
 #endif

/* Define _MRTIMP2_NCEEPURE */
 #ifndef _MRTIMP2_NCEEPURE
  #if defined(_M_CEE_PURE)
   #define _MRTIMP2_NCEEPURE
  #else
   #define _MRTIMP2_NCEEPURE _MRTIMP2
  #endif
 #endif

/* Define _MRTIMP2_NPURE_NCEEPURE */
 #ifndef _MRTIMP2_NPURE_NCEEPURE
  #if defined(_M_CEE_PURE)
   #define _MRTIMP2_NPURE_NCEEPURE
  #else
   #define _MRTIMP2_NPURE_NCEEPURE _MRTIMP2_NPURE
  #endif
 #endif

 #if defined(_DLL) && !defined(_STATIC_CPPLIB) && !defined(_M_CEE_PURE)
  #define _DLL_CPPLIB
 #endif

 #ifndef _CRTIMP2_PURE
   #ifdef  _M_CEE_PURE
     #define _CRTIMP2_PURE
   #else
     #define _CRTIMP2_PURE _CRTIMP2
   #endif
 #endif

#if !defined(_CRTDATA2)
    #define _CRTDATA2 _CRTIMP2
#endif


  #define _DEPRECATED	_CRT_DEPRECATE_TEXT("This is an obsolete part of the Standard C++ Library Implementation. Do not use it.")



		/* NAMESPACE */

 #if defined(__cplusplus)
  #define _STD_BEGIN	namespace std {
  #define _STD_END		}
  #define _STD	::std::

/*
We use the stdext (standard extension) namespace to contain extensions that are not part of the current standard
*/
  #define _STDEXT_BEGIN	    namespace stdext {
  #define _STDEXT_END		}
  #define _STDEXT	        ::stdext::

  #ifdef _STD_USING
   #define _C_STD_BEGIN	namespace std {	/* only if *.c compiled as C++ */
   #define _C_STD_END	}
   #define _CSTD	::std::

  #else /* _STD_USING */
/* #define _GLOBAL_USING	*.h in global namespace, c* imports to std */

   #define _C_STD_BEGIN
   #define _C_STD_END
   #define _CSTD	::
  #endif /* _STD_USING */

  #define _C_LIB_DECL		extern "C" {	/* C has extern "C" linkage */
  #define _END_C_LIB_DECL	}
  #define _EXTERN_C			extern "C" {
  #define _END_EXTERN_C		}

 #else /* __cplusplus */
  #define _STD_BEGIN
  #define _STD_END
  #define _STD

  #define _C_STD_BEGIN
  #define _C_STD_END
  #define _CSTD

  #define _C_LIB_DECL
  #define _END_C_LIB_DECL
  #define _EXTERN_C
  #define _END_EXTERN_C
 #endif /* __cplusplus */

 #define _Restrict	restrict

 #ifdef __cplusplus
_STD_BEGIN
typedef bool _Bool;
_STD_END
 #endif /* __cplusplus */

		/* VC++ COMPILER PARAMETERS */
#define _LONGLONG	__int64
#define _ULONGLONG	unsigned __int64
#define _LLONG_MAX	0x7fffffffffffffff
#define _ULLONG_MAX	0xffffffffffffffff

		/* INTEGER PROPERTIES */
#define _C2			1	/* 0 if not 2's complement */

#define _MAX_EXP_DIG	8	/* for parsing numerics */
#define _MAX_INT_DIG	32
#define _MAX_SIG_DIG	36

typedef _LONGLONG _Longlong;
typedef _ULONGLONG _ULonglong;

		/* STDIO PROPERTIES */
#define _Filet _iobuf

 #ifndef _FPOS_T_DEFINED
  #define _FPOSOFF(fp)	((long)(fp))
 #endif /* _FPOS_T_DEFINED */

#define _IOBASE	_base
#define _IOPTR	_ptr
#define _IOCNT	_cnt

		/* MULTITHREAD PROPERTIES */
		/* LOCK MACROS */
#define _LOCK_LOCALE	0
#define _LOCK_MALLOC	1
#define _LOCK_STREAM	2
#define _LOCK_DEBUG		3
#define _MAX_LOCK		4	/* one more than highest lock number */

 #ifdef __cplusplus
_STD_BEGIN
		// CLASS _Lockit

// warning 4412 is benign here
#pragma warning(push)
#pragma warning(disable:4412)
class _CRTIMP2_PURE _Lockit
	{	// lock while object in existence -- MUST NEST
public:
  #if _MULTI_THREAD

    #if defined(_M_CEE_PURE) || defined(MRTDLL)
	explicit __CLR_OR_THIS_CALL _Lockit()	// set default lock
        : _Locktype(0)
    {
        _Lockit_ctor(this);
    }
	explicit __CLR_OR_THIS_CALL _Lockit(int _Kind)	// set the lock
    {
        _Lockit_ctor(this, _Kind);
    }
	__CLR_OR_THIS_CALL ~_Lockit()	// clear the lock
    {
        _Lockit_dtor(this);
    }
    #else
    explicit __thiscall _Lockit();	// set default lock
	explicit __thiscall _Lockit(int);	// set the lock
	__thiscall ~_Lockit();	// clear the lock
    #endif

    static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(int);
    static _MRTIMP2_NPURE void __cdecl _Lockit_dtor(int);

private:
    static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(_Lockit *);
    static _MRTIMP2_NPURE void __cdecl _Lockit_ctor(_Lockit *, int);
    static _MRTIMP2_NPURE void __cdecl _Lockit_dtor(_Lockit *);

	__CLR_OR_THIS_CALL _Lockit(const _Lockit&);				// not defined
	_Lockit& __CLR_OR_THIS_CALL operator=(const _Lockit&);	// not defined

	int _Locktype;

  #else /* _MULTI_THREAD */

	explicit _Lockit()
		{	// do nothing
		}

	explicit _Lockit(int)
		{	// do nothing
		}

	~_Lockit()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */

	};

#ifdef _M_CEE

class _CRTIMP2_PURE _EmptyLockit
	{	// empty lock class used for bin compat
public:
  #if _MULTI_THREAD

private:
	int _Locktype;

  #else /* _MULTI_THREAD */

  #endif /* _MULTI_THREAD */
	};

#if defined(__cplusplus_cli)
 #define _M_CEE_FINALLY finally
#else
 #define _M_CEE_FINALLY __finally
#endif

#define _BEGIN_LOCK(_Kind) \
	{ \
		typedef int _TmpTestType; \
		__if_exists(_TmpTestType::ToString) \
		{ \
		bool _MustReleaseLock = false; \
		int _LockKind = _Kind; \
		System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions(); \
		try \
		} \
		{ \
			__if_exists(_TmpTestType::ToString) \
			{ \
			System::Runtime::CompilerServices::RuntimeHelpers::PrepareConstrainedRegions(); \
			try { } _M_CEE_FINALLY \
			{ \
				_STD _Lockit::_Lockit_ctor(_LockKind); \
				_MustReleaseLock = true; \
			} \
			} \
			__if_not_exists(_TmpTestType::ToString) \
			{ \
			_STD _Lockit _Lock(_Kind); \
			}

#define _END_LOCK() \
		} \
		__if_exists(_TmpTestType::ToString) \
		{ \
		_M_CEE_FINALLY \
		{ \
			if (_MustReleaseLock) \
			{ \
				_STD _Lockit::_Lockit_dtor(_LockKind); \
			} \
		} \
		} \
	}

#define _BEGIN_LOCINFO(_VarName) \
	_BEGIN_LOCK(_LOCK_LOCALE) \
	_Locinfo _VarName;

#define _END_LOCINFO() \
	_END_LOCK() \

#define _RELIABILITY_CONTRACT \
	[System::Runtime::ConstrainedExecution::ReliabilityContract( \
		System::Runtime::ConstrainedExecution::Consistency::WillNotCorruptState, \
		System::Runtime::ConstrainedExecution::Cer::Success)]

#else

#define _BEGIN_LOCK(_Kind) \
	{ \
		_STD _Lockit _Lock(_Kind);

#define _END_LOCK() \
	}

#define _BEGIN_LOCINFO(_VarName) \
	{ \
		_Locinfo _VarName;

#define _END_LOCINFO() \
	}

#define _RELIABILITY_CONTRACT

#endif

class _CRTIMP2_PURE _Mutex
	{	// lock under program control
public:

  #if _MULTI_THREAD
    
    #if defined(_M_CEE_PURE) || defined(MRTDLL)
	__CLR_OR_THIS_CALL _Mutex()
    {
        _Mutex_ctor(this);
    }
	__CLR_OR_THIS_CALL ~_Mutex()
    {
        _Mutex_dtor(this);
    }
	void __CLR_OR_THIS_CALL _Lock()
    {
        _Mutex_Lock(this);
    }
	void __CLR_OR_THIS_CALL _Unlock()
    {
        _Mutex_Unlock(this);
    }
    #else
    __thiscall _Mutex();
	__thiscall ~_Mutex();
	void __thiscall _Lock();
	void __thiscall _Unlock();
    #endif

private:
    static _MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex_ctor(_Mutex *);
    static _MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex_dtor(_Mutex *);
    static _MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex_Lock(_Mutex *);
    static _MRTIMP2_NPURE_NCEEPURE void __CLRCALL_PURE_OR_CDECL _Mutex_Unlock(_Mutex *);

	__CLR_OR_THIS_CALL _Mutex(const _Mutex&);				// not defined
	_Mutex& __CLR_OR_THIS_CALL operator=(const _Mutex&);	// not defined
	void *_Mtx;

  #else /* _MULTI_THREAD */
    void _Lock()
		{	// do nothing
		}

	void _Unlock()
		{	// do nothing
		}
  #endif /* _MULTI_THREAD */

	};

class _CRTIMP2_PURE _Init_locks
	{	// initialize mutexes
public:

 #if _MULTI_THREAD
    
    #if defined(_M_CEE_PURE) || defined(MRTDLL)
	__CLR_OR_THIS_CALL _Init_locks()
    {
        _Init_locks_ctor(this);
    }
	__CLR_OR_THIS_CALL ~_Init_locks()
    {
        _Init_locks_dtor(this);
    }
    #else
    __thiscall _Init_locks();
	__thiscall ~_Init_locks();
    #endif

private:
    static _MRTIMP2_NPURE void __cdecl _Init_locks_ctor(_Init_locks *);
    static _MRTIMP2_NPURE void __cdecl _Init_locks_dtor(_Init_locks *);

 #else /* _MULTI_THREAD */
	_Init_locks()
		{	// do nothing
		}

	~_Init_locks()
		{	// do nothing
		}
 #endif /* _MULTI_THREAD */

	};
#pragma warning(pop)
_STD_END
 #endif /* __cplusplus */

#ifndef _RELIABILITY_CONTRACT
#define _RELIABILITY_CONTRACT
#endif

		/* MISCELLANEOUS MACROS AND TYPES */
_C_STD_BEGIN
_MRTIMP2 void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;

#define _ATEXIT_T	void
#define _Mbstinit(x)	mbstate_t x = {0}
_C_STD_END

#ifdef _MSC_VER
  #define _EXTERN_TEMPLATE	template
  #define _THROW_BAD_ALLOC	_THROW1(...)
 #pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _YVALS */


/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\marshal_atl.h ===
/***
*marshal_atl.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Marshalling classes
*
*       [Public]
*
****/

#pragma once

#ifndef _INC_MSCLR_MARSHAL_ATL
#define _INC_MSCLR_MARSHAL_ATL

#include <atlsafe.h>
#include <atlbase.h>
#include <atlstr.h>
#include <vcclr.h>
#include <atlcomcli.h> 

#include <msclr\marshal.h>

#using <mscorlib.dll>

namespace msclr{
	namespace interop{

template <>
inline System::String^ marshal_as(const CComBSTR& _from_object)
{
	if (_from_object.m_str == NULL)
	{
		return nullptr;
	}
	// Using PtrToStringBSTR here instead of marshal_as<String^, BSTR>() because we want to perserve the embedded NULLs
	return System::Runtime::InteropServices::Marshal::PtrToStringBSTR(System::IntPtr(_from_object.m_str));
}

template <>
inline CComBSTR marshal_as(System::String^ const& _from_object)
{
	if (_from_object == nullptr)
	{
		return CComBSTR(static_cast<const wchar_t*>(NULL));
	}
	if(_from_object->Length == 0)
	{
		return CComBSTR(static_cast<const wchar_t*>(L""));
	}

	cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_object);
	return  CComBSTR( _from_object->Length, static_cast<const wchar_t *>(_pinned_ptr));
}

template <>
inline System::String^ marshal_as(const CStringA& _from_obj)
{
	return details::InternalAnsiToStringHelper(_from_obj.operator LPCSTR(), _from_obj.GetLength());
}

template <>
inline System::String^ marshal_as(const CStringW& _from_obj)
{
	// this will perserve the embedded nulls
	return details::InternalUnicodeToStringHelper(_from_obj.operator LPCWSTR(), _from_obj.GetLength());
}

template <>
inline CStringA marshal_as(System::String^ const & _from_obj)
{
	if (_from_obj == nullptr)
	{
		throw gcnew System::ArgumentNullException(_EXCEPTION_NULLPTR);
	}
	CStringA _to_obj;
	size_t _size = details::GetAnsiStringSize(_from_obj);
	
	//checking for overflow
	if (_size > INT_MAX)
	{
		throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_NULLPTR);
	}

	int _length = static_cast<int>(_size)-1;
	
	//GetBuffer() throws, so we don't need to check for NULL
	char* _dest_buf = _to_obj.GetBuffer(_length); 

	details::WriteAnsiString(_dest_buf, _size, _from_obj);
	_to_obj.ReleaseBuffer(_length); // We don't want to include the NULL.  This call will set the length to _length

	return _to_obj;
}

template <>
inline CStringW marshal_as(System::String^ const & _from_obj)
{
	if (_from_obj == nullptr)
	{
		throw gcnew System::ArgumentNullException(_EXCEPTION_NULLPTR);
	}
	cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_obj);
	return CStringW(static_cast<const wchar_t *>(_pinned_ptr), _from_obj->Length);
}

	} //namespace interop
} //namespace msclr

#endif // _INC_MSCLR_MARSHAL_ATL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\CodeAnalysis\sourceannotations.h ===
#if _MSC_VER >= 1400

#pragma once

#ifndef _M_CEE_SAFE  // Source annotation attributes don't work with /clr:safe

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif
#define _SIZE_T_DEFINED
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#pragma push_macro( "SA" )
#pragma push_macro( "REPEATABLE" )

#ifdef __cplusplus
#define SA( id ) id
#define REPEATABLE [repeatable]
#else  // !__cplusplus
#define SA( id ) SA_##id
#define REPEATABLE
#endif  // !__cplusplus

#ifdef __cplusplus
namespace vc_attributes
{
#endif  // __cplusplus

enum SA( YesNoMaybe )
{
	// Choose values that we can detect as invalid if they are or'd together
	SA( No ) = 0x0fff0001,
	SA( Maybe ) = 0x0fff0010,
	SA( Yes ) = 0x0fff0100
};

typedef enum SA( YesNoMaybe ) SA( YesNoMaybe );

enum SA( AccessType )
{
	SA( NoAccess ) = 0,
	SA( Read ) = 1,
	SA( Write ) = 2,
	SA( ReadWrite ) = 3
};

typedef enum SA( AccessType ) SA( AccessType );

#ifndef SAL_NO_ATTRIBUTE_DECLARATIONS

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct PreAttribute
{
#ifdef __cplusplus
	PreAttribute();
#endif

	unsigned int Deref;
	SA( YesNoMaybe ) Valid;
	SA( YesNoMaybe ) Null;
	SA( YesNoMaybe ) Tainted;
	SA( AccessType ) Access;
	size_t ValidElementsConst;
	size_t ValidBytesConst;
	const wchar_t* ValidElements;
	const wchar_t* ValidBytes;
	const wchar_t* ValidElementsLength;
	const wchar_t* ValidBytesLength;
	size_t WritableElementsConst;
	size_t WritableBytesConst;
	const wchar_t* WritableElements;
	const wchar_t* WritableBytes;
	const wchar_t* WritableElementsLength;
	const wchar_t* WritableBytesLength;
	size_t ElementSizeConst;
	const wchar_t* ElementSize;
	SA( YesNoMaybe ) NullTerminated;
	const wchar_t* Condition;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
struct PostAttribute
{
#ifdef __cplusplus
	PostAttribute();
#endif

	unsigned int Deref;
	SA( YesNoMaybe ) Valid;
	SA( YesNoMaybe ) Null;
	SA( YesNoMaybe ) Tainted;
	SA( AccessType ) Access;
	size_t ValidElementsConst;
	size_t ValidBytesConst;
	const wchar_t* ValidElements;
	const wchar_t* ValidBytes;
	const wchar_t* ValidElementsLength;
	const wchar_t* ValidBytesLength;
	size_t WritableElementsConst;
	size_t WritableBytesConst;
	const wchar_t* WritableElements;
	const wchar_t* WritableBytes;
	const wchar_t* WritableElementsLength;
	const wchar_t* WritableBytesLength;
	size_t ElementSizeConst;
	const wchar_t* ElementSize;
	SA( YesNoMaybe ) NullTerminated;
	SA( YesNoMaybe ) MustCheck;
	const wchar_t* Condition;
};

[source_annotation_attribute( SA( Parameter ) )]
struct FormatStringAttribute
{
#ifdef __cplusplus
	FormatStringAttribute();
#endif

	const wchar_t* Style;
	const wchar_t* UnformattedAlternative;
};

REPEATABLE
[source_annotation_attribute( SA( ReturnValue ) )]
struct InvalidCheckAttribute
{
#ifdef __cplusplus
	InvalidCheckAttribute();
#endif

	long Value;
};

[source_annotation_attribute( SA( Method ) )]
struct SuccessAttribute
{
#ifdef __cplusplus
	SuccessAttribute();
#endif

	const wchar_t* Condition;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct PreBoundAttribute
{
#ifdef __cplusplus
	PreBoundAttribute();
#endif
	unsigned int Deref;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
struct PostBoundAttribute
{
#ifdef __cplusplus
	PostBoundAttribute();
#endif
	unsigned int Deref;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter ) )]
struct PreRangeAttribute
{
#ifdef __cplusplus
	PreRangeAttribute();
#endif
	unsigned int Deref;
	const char* MinVal;
	const char* MaxVal;
};

REPEATABLE
[source_annotation_attribute( SA( Parameter )|SA( ReturnValue ) )]
struct PostRangeAttribute
{
#ifdef __cplusplus
	PostRangeAttribute();
#endif
	unsigned int Deref;
	const char* MinVal;
	const char* MaxVal;
};

#endif  // !SAL_NO_ATTRIBUTE_DECLARATIONS

#ifdef __cplusplus
};  // namespace vc_attributes
#endif  // __cplusplus

#pragma pop_macro( "REPEATABLE" )
#pragma pop_macro( "SA" )

#ifdef __cplusplus

#define SA_All All
#define SA_Class Class
#define SA_Constructor Constructor
#define SA_Delegate Delegate
#define SA_Enum Enum
#define SA_Event Event
#define SA_Field Field
#define SA_GenericParameter GenericParameter
#define SA_Interface Interface
#define SA_Method Method
#define SA_Module Module
#define SA_Parameter Parameter
#define SA_Property Property
#define SA_ReturnValue ReturnValue
#define SA_Struct Struct

typedef ::vc_attributes::YesNoMaybe SA_YesNoMaybe;
const ::vc_attributes::YesNoMaybe SA_Yes = ::vc_attributes::Yes;
const ::vc_attributes::YesNoMaybe SA_No = ::vc_attributes::No;
const ::vc_attributes::YesNoMaybe SA_Maybe = ::vc_attributes::Maybe;

typedef ::vc_attributes::AccessType SA_AccessType;
const ::vc_attributes::AccessType SA_NoAccess = ::vc_attributes::NoAccess;
const ::vc_attributes::AccessType SA_Read = ::vc_attributes::Read;
const ::vc_attributes::AccessType SA_Write = ::vc_attributes::Write;
const ::vc_attributes::AccessType SA_ReadWrite = ::vc_attributes::ReadWrite;

#ifndef SAL_NO_ATTRIBUTE_DECLARATIONS
typedef ::vc_attributes::PreAttribute          SA_Pre;
typedef ::vc_attributes::PostAttribute         SA_Post;
typedef ::vc_attributes::FormatStringAttribute SA_FormatString;
typedef ::vc_attributes::InvalidCheckAttribute SA_InvalidCheck; /*???*/
typedef ::vc_attributes::SuccessAttribute      SA_Success;
typedef ::vc_attributes::PreBoundAttribute     SA_PreBound;
typedef ::vc_attributes::PostBoundAttribute    SA_PostBound;
typedef ::vc_attributes::PreRangeAttribute     SA_PreRange;
typedef ::vc_attributes::PostRangeAttribute    SA_PostRange;
#endif //!SAL_NO_ATTRIBUTE_DECLARATIONS

#else  // !__cplusplus

typedef struct PreAttribute SA_Pre;
typedef struct PreAttribute PreAttribute;
typedef struct PostAttribute SA_Post;
typedef struct PostAttribute PostAttribute;
typedef struct FormatStringAttribute SA_FormatString;
typedef struct InvalidCheckAttribute SA_InvalidCheck; /*???*/
typedef struct SuccessAttribute      SA_Success;
typedef struct PreBoundAttribute     SA_PreBound;
typedef struct PostBoundAttribute    SA_PostBound;
typedef struct PreRangeAttribute     SA_PreRange;
typedef struct PostRangeAttribute    SA_PostRange;

#endif  // __cplusplus

#endif  // !_M_CEE_SAFE

#ifdef _MANAGED

#ifdef CODE_ANALYSIS
#define SA_SUPPRESS_MESSAGE( category, id, ... ) [::System::Diagnostics::CodeAnalysis::SuppressMessage( category, id, __VA_ARGS__ )]
#define CA_SUPPRESS_MESSAGE( ... ) [System::Diagnostics::CodeAnalysis::SuppressMessage( __VA_ARGS__ )]
#define CA_GLOBAL_SUPPRESS_MESSAGE( ... ) [assembly:System::Diagnostics::CodeAnalysis::SuppressMessage( __VA_ARGS__ )]
#else  // !CODE_ANALYSIS
#define SA_SUPPRESS_MESSAGE( category, id, ... )
#define CA_SUPPRESS_MESSAGE( ... )
#define CA_GLOBAL_SUPPRESS_MESSAGE( ... ) 
#endif  // !CODE_ANALYSIS

#endif  // _MANAGED

// Windows SDK Update Vista Beta2 (June 2006): __analysis_assume defined by specstrings.h
#ifdef _PREFAST_
// #define __analysis_assume(expr) __assume(expr)
#else  // !_PREFAST_
// #define __analysis_assume(expr) 
#endif  // _PREFAST_


#endif  // _MSC_VER >= 1400
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\marshal_windows.h ===
/***
*marshal_windows.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Marshalling classes
*
*       [Public]
*
****/

#pragma once

#ifndef _INC_MSCLR_MARSHAL_WINDOWS
#define _INC_MSCLR_MARSHAL_WINDOWS

#include <msclr\marshal.h>
#include <windows.h>
#include <comutil.h> 

#using <mscorlib.dll>

namespace msclr{
	namespace interop{

//--------------------------------------------------------------------------------
// Context-free conversions templates specialization for windows types
//--------------------------------------------------------------------------------

//
// for BSTR -> System::String^, please see wchar_t* -> String^ in marshal.h
//

template <>
inline System::String^ marshal_as(const _bstr_t & _from_object)
{
	BSTR _bstr = _from_object.copy(false);
	if (_bstr == NULL)
	{
		return nullptr;
	}
	// Using PtrToStringBSTR here instead of marshal_as<String^, BSTR>() because we want to perserve the embedded NULLs
	return System::Runtime::InteropServices::Marshal::PtrToStringBSTR(System::IntPtr(_bstr));
}

template <>
inline _bstr_t marshal_as(System::String^ const & _from_object)
{
	if (_from_object == nullptr)
	{
		return _bstr_t(static_cast<BSTR>(NULL));
	}

	_bstr_t _ret_bstr_t;
	cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_object);
	_ret_bstr_t.Attach(::SysAllocStringLen(_pinned_ptr, _from_object->Length));
	if (!_ret_bstr_t)
	{
		throw gcnew System::OutOfMemoryException();
	}
	return _ret_bstr_t;
}

template <>
inline System::IntPtr marshal_as(const HANDLE& _from_object)
{
	return System::IntPtr(_from_object);
}

template <class _To_Type>
inline _To_Type marshal_as(System::IntPtr _from_object);

template <>
inline HANDLE marshal_as(System::IntPtr _from_object)
{
	return static_cast<HANDLE>(_from_object.ToPointer());
}

//--------------------------------------------------------------------------------
// Context conversion templates specialization for windows types
//--------------------------------------------------------------------------------

template<>
ref class context_node<BSTR, System::String^> :
	public context_node_base
{
	private:
		System::IntPtr _ip;
	public:
		context_node(BSTR& _to_object, System::String^ from) 
		{
			_ip = System::Runtime::InteropServices::Marshal::StringToBSTR (from);
			_to_object = static_cast<BSTR>(_ip.ToPointer());
		}

		~context_node()
		{
			this->!context_node();
		}

	protected:
		!context_node()
		{
			if(_ip != System::IntPtr::Zero)
				System::Runtime::InteropServices::Marshal::FreeBSTR(_ip);
		}
};

	} //namespace interop
} //namespace msclr

#endif // _INC_MSCLR_MARSHAL_WINDOWS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\safebool.h ===
/***
*safebool.h - types and constants for implementing the "smart bool" idiom.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Prefer _safe_bool to an implicit conversion to bool. When a
*           type is implicitly convertible to bool, it is also implicitly
*           convertible to any integral type, and this is often not
*           desired.  Instead, provide a conversion to _safe_bool, which
*           is really a pointer to a member function on a dummy struct.
*           This pointer can be evaluated in Boolean context, but it will
*           never be converted to an integral type.
*
*       [Public]
*
****/

#pragma once

#if !defined(_INC_MSCLR_SAFEBOOL)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif

namespace msclr
{

value class _detail_class
{
public:
    value class dummy_struct
    {
    public:
        static initonly System::String^ dummy_string = "";
    };
    typedef System::String^ _safe_bool;
    static _safe_bool const _safe_true  = dummy_struct::dummy_string;
    static _safe_bool const _safe_false = nullptr;
};

}

 
#define _INC_MSCLR_SAFEBOOL

#endif // _INC_MSCLR_SAFEBOOL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\com\ptr.h ===
/***
*ptr.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   COM Wrapper for the Managed World
*
*       [Public]
*
****/

#pragma once

#if !defined(_INC_MSCLR_COM_PTR)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif

#include <vcclr.h>

#include <msclr\safebool.h>

namespace msclr
{

namespace _detail
{
    // COM::ptr::operator->() returns a smart_com_ptr instead of
    // a regular interface pointer so that a Release is done automatically
    // when the temporary is destroyed

    template<class _interface_type>
    ref class smart_com_ptr
    {
        public:
        smart_com_ptr(_interface_type * p)
        {
            ptr= p;
        }

        smart_com_ptr(smart_com_ptr % ip)
        {
            ptr = ip.ptr;
            ptr->AddRef();
        }

        _interface_type * operator ->()
        {
            return ptr;
        }

        ~smart_com_ptr()
        {
            ptr->Release();
        }

        private:
        _interface_type * ptr;
    };
} //namespace _detail


namespace com
{
    template<class _interface_type>
    ref class ptr
    {
        public:

        ptr():obj_rcw(nullptr)
        {
        }

        // Construct from interface pointer
        ptr(_interface_type * p)
        {
            obj_rcw = nullptr;
            assign(p);
        }

        // Attach to an interface pointer
        void Attach(_interface_type * _right)
        {
            if (valid()) 
            {
                throw gcnew System::InvalidOperationException("COM::ptr.Attach");
            }

            assign(_right);
        }

        // Assign an interface pointer
        ptr<_interface_type> % operator=(_interface_type * _right)
        {
            Attach(_right);
            return *this;
        }

        // All CreateInstance methods create an instance of a COM Object 
        // by calling CoCreateInstance
        void CreateInstance(System::String ^ prog_id, LPUNKNOWN pouter, DWORD cls_context)
        {
            wchar_t * pwszprog_id = NULL;
            
            if(prog_id != nullptr)
            {
                pin_ptr<const __wchar_t> _pinned_ptr = PtrToStringChars( prog_id );
                pwszprog_id = _wcsdup(_pinned_ptr);
            }

            try 
            {
                CreateInstance(pwszprog_id, pouter, cls_context);
            }
            finally 
            {
                free(pwszprog_id);
            }
        }

        void CreateInstance(System::String ^ prog_id, LPUNKNOWN pouter)
        {
            CreateInstance(prog_id, pouter, CLSCTX_ALL);
        }

        void CreateInstance(System::String ^ prog_id)
        {
            CreateInstance(prog_id, NULL, CLSCTX_ALL);
        }

        void CreateInstance(const wchar_t* progid, LPUNKNOWN pouter, DWORD cls_context)
        {
            CLSID clsid;
            System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(
                CLSIDFromProgID(progid, &clsid));
            CreateInstance(clsid, pouter, cls_context);
        }

        void CreateInstance(const wchar_t * progid, LPUNKNOWN pouter)
        {
            CreateInstance(progid, pouter, CLSCTX_ALL);
        }

        void CreateInstance(const wchar_t * progid)
        {
            CreateInstance(progid, NULL, CLSCTX_ALL);
        }

        void CreateInstance(REFCLSID rclsid,LPUNKNOWN pouter,DWORD cls_context)
        {
            if (valid()) 
            {
                throw gcnew System::InvalidOperationException("COM::ptr.CreateInstance");
            }

            _interface_type * interface_ptr = NULL;
            
            System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(CoCreateInstance(
                        rclsid, pouter, cls_context, __uuidof(_interface_type),
                        (void**)&interface_ptr));

            if (interface_ptr) 
            {
                assign(interface_ptr);
                interface_ptr->Release();
            }
        }

        void CreateInstance(REFCLSID rclsid,LPUNKNOWN pouter)
        {
            CreateInstance(rclsid, pouter, CLSCTX_ALL);
        }

        void CreateInstance(REFCLSID rclsid)
        {
            CreateInstance(rclsid, NULL, CLSCTX_ALL);
        }

        // Give up ownership of the interface pointer & return the
        // interface pointer
        _interface_type * Detach()
        {
            if(valid())
            {
                _interface_type * interface_ptr = GetInterface();
                destroy();
                return interface_ptr;
            }

            return NULL;
        }

        // Give up ownership of the interface pointer
        void Release()
        {
            if(valid())
            {
                destroy();
            }
        }
        
        // Operator ->() - to be used to call methods on the owned COM Object
        // We return a smart_com_ptr instead of an interface pointer so that
        // the reference is released automatically
        _detail::smart_com_ptr<_interface_type> operator->()
        {
            _detail::smart_com_ptr<_interface_type> interface_ptr(GetInterface());
            return interface_ptr;
        }

        // Return an interface pointer
        _interface_type * GetInterface()
        {
            if(!valid())
            {
                return NULL;
            }

            System::IntPtr iface_intptr = System::Runtime::InteropServices::Marshal::GetIUnknownForObject(obj_rcw);

            IUnknown * iunk = static_cast<IUnknown *>(static_cast<void*>(iface_intptr));

            _interface_type * interface_ptr;
            System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(iunk->QueryInterface(__uuidof(_interface_type), (void **)&interface_ptr));

            iunk->Release();

            interface_ptr->AddRef();
            System::Runtime::InteropServices::Marshal::Release(iface_intptr);

            return interface_ptr;
        }

        // QueryInteface & fillup up the passed it COM::ptr with the result
        template<class _other_type>
        void QueryInterface(ptr<_other_type> % other)
        {
            QueryInterface<_other_type>(__uuidof(_other_type), other);
        }

        // for use when com::ptr appears in a conditional
        operator _detail_class::_safe_bool()
        {
            return valid() ? _detail_class::_safe_true : _detail_class::_safe_false;
        }

        // for use when com::ptr appears in a conditional
        bool operator!()
        {
            return ! valid();
        }

        ~ptr()
        {
            if(valid())
            {
                destroy();
            }
        }

        private:

        void destroy()
        {
            System::Runtime::InteropServices::Marshal::ReleaseComObject(obj_rcw);
            obj_rcw = nullptr;
        }

        bool valid()
        {
            return (obj_rcw != nullptr);
        }


        void assign(_interface_type *p)
        {
            if(p)
            {
                obj_rcw = System::Runtime::InteropServices::Marshal::GetUniqueObjectForIUnknown(System::IntPtr(p));
            }
        }

        template<class _other_type>
        void QueryInterface(REFIID riid, ptr<_other_type> % other)
        {
            _detail::smart_com_ptr<_interface_type> interface_ptr(GetInterface());
            _other_type * other_ptr;

            System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(interface_ptr->QueryInterface(riid,(void **)&other_ptr));
            other.Attach(other_ptr);

            other_ptr->Release();
        }

        Object ^obj_rcw;
    };
} // namespace com

} // namespace msclr

#define _INC_MSCLR_COM_PTR
#endif // _INC_MSCLR_COM_PTR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\_vcclrit.h ===
/***
*_vcclrit.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defined the functions and variables used by users
*       to initialize the CRT and the dll in IJW scenarios. It is no longer
*       necessary to use this file and the functions it contains because
*       CRT initialization no longer causes managed code to execute
*       under the loader lock. It is now possible to use the CRT in
*       the standard way without problems. This header is shipped for
*       compatibility with the previous version only.
*
****/

#pragma once

#ifndef __midl
#ifndef _MSC_EXTENSIONS
#error ERROR: This initialisation code cannot be used with /Za
#endif

#ifdef _M_CEE_PURE
#error ERROR: This code is not useful for /clr:pure mode. Remove the include.
#endif

#include <crtwrn.h>
#include <windows.h>

#if !defined(_CRT_VCCLRIT_NO_DEPRECATE)
    #define _CRT_VCCLRIT_DEPRECATE _CRT_DEPRECATE_TEXT("These manual initialisation functions (plus link /noentry) are no longer appropriate for managed code DLLs. Instead, use a normal DLL entrypoint. See online help for more information.")
    #pragma _CRT_WARNING( _VCCLRIT_DEPRECATED )
#else
    #define _CRT_VCCLRIT_DEPRECATE 
#endif

#ifdef __cplusplus
extern "C" {
#endif

extern IMAGE_DOS_HEADER __ImageBase;

BOOL WINAPI _DllMainCRTStartup(
        HANDLE  _HDllHandle,
        DWORD   _DwReason,
        LPVOID  _Lpreserved
        );

typedef enum {
    __uninitialized,
    __initializing,
    __NSinitialized /* Renamed */
} __enative_startup_state;

extern __enative_startup_state __native_startup_state;
extern void *__native_startup_lock;
extern volatile unsigned int __native_vcclrit_reason;
#define __NO_REASON    0xffffffff    /* maximum unsigned int value */
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
#define __USE_GLOBAL_NAMESPACE(X)   (::X)
#define __THROW throw()
#define __REINTERPRET_CAST(T) reinterpret_cast<T>
#define __STATIC_CAST(T) static_cast<T>
#define __INLINE inline
#else
/* deliberately no parens here so we don't suppress macro expansion */
#define __USE_GLOBAL_NAMESPACE(X)   X
#define __THROW 
#define __REINTERPRET_CAST(T)   (T)
#define __STATIC_CAST(T)        (T)
#define __INLINE __inline
#endif

#ifdef _M_IX86
/* System version has problems especially for /Wp64 */
__INLINE void* WINAPI _CrtInterlockedExchangePointer(void** pp, void* pNew) __THROW
{
        return( __REINTERPRET_CAST(void*)(__STATIC_CAST(LONG_PTR)(__USE_GLOBAL_NAMESPACE(InterlockedExchange)(__REINTERPRET_CAST(LONG*)(pp), __STATIC_CAST(LONG)(__REINTERPRET_CAST(LONG_PTR)(pNew))))) );
}
#else
#define _CrtInterlockedExchangePointer(p, n) InterlockedExchangePointer(p, n)
#endif

/*
Used to lock 
*/
_CRT_VCCLRIT_DEPRECATE
__declspec( selectany ) LONG  volatile __lock_handle = 0;

/*
Init called
*/
_CRT_VCCLRIT_DEPRECATE
__declspec(selectany) BOOL volatile __initialized = FALSE;

/*
Term called
*/
_CRT_VCCLRIT_DEPRECATE
__declspec( selectany ) BOOL volatile __terminated = FALSE;

_CRT_VCCLRIT_DEPRECATE
__inline BOOL WINAPI __crt_dll_initialize()
{
    /*
    Try to make the variable names unique, so that the variables don't even clash with macros.
    */
    static BOOL volatile (__retval) = FALSE;
    static void * volatile (__lockFiberId) = 0;
    void * volatile (__currentFiberId) = ((PNT_TIB)__USE_GLOBAL_NAMESPACE(NtCurrentTeb)())->StackBase;
    int (__int_var)=0;
    int __nested=FALSE;
    
    /*
    Take Lock, This is needed for multithreaded scenario. Moreover the threads
    need to wait here to make sure that the dll is initialized when they get
    past this function.
    */
    while ( __USE_GLOBAL_NAMESPACE(InterlockedExchange)( &(__lock_handle), 1) == 1 )
        {
        ++(__int_var);
        if ((__lockFiberId) == (__currentFiberId)) 
        {
            return TRUE;
        }
                __USE_GLOBAL_NAMESPACE(Sleep)( (__int_var)>1000?100:0 );

        /*
        If you hang in this loop, this implies that your dllMainCRTStartup is hung on another
        thread. The most likely cause of this is a hang in one of your static constructors or
        destructors.
        */
        }
    /*
    Note that we don't really need any interlocked stuff here as the writes are always
    in the lock. Only reads are outside the lock.
    */
    (__lockFiberId) = (__currentFiberId);
    __try {
    
        void * __lock_free=0;
        while((__lock_free=InterlockedCompareExchangePointer(&__native_startup_lock, __currentFiberId, 0))!=0)
        {
            if(__lock_free==__currentFiberId)
            {
                __nested=TRUE;
                break;
            }

            /* some other thread is running native startup/shutdown during a cctor/domain unload. 
            Should only happen if this DLL was built using the Everett-compat loader lock fix in vcclrit.h
            */
            /* wait for the other thread to complete init before we return */
            Sleep(1000);
        }

        if ( (__terminated) == TRUE )
        {
            (__retval) = FALSE;
        }
        else if ( (__initialized) == FALSE )
        {
            /* cctor may have initialized native code already */
            if (__native_startup_state == __uninitialized)
            {
                __try
                {
                    __native_vcclrit_reason = DLL_PROCESS_ATTACH;
                    (__retval) = (_DllMainCRTStartup)( ( HINSTANCE )( &__ImageBase ), DLL_PROCESS_ATTACH, 0 );
                }
                __finally
                {
                    __native_vcclrit_reason = __NO_REASON;
                }
                (__initialized) = TRUE;
            }
        }

    } __finally {
        /* revert the __lockFiberId */
        (__lockFiberId) = 0;
        /* Release Lock */
        __USE_GLOBAL_NAMESPACE(InterlockedExchange)( &(__lock_handle), 0 );
        if(!__nested)
        {
            _CrtInterlockedExchangePointer( &(__native_startup_lock), 0 );
        }
    }
    return (__retval);
}

_CRT_VCCLRIT_DEPRECATE
__inline BOOL WINAPI __crt_dll_terminate()
{
    static BOOL volatile (__retval) = TRUE;
    static void * volatile (__lockFiberId) = 0;
    void * volatile (__currentFiberId) = ((PNT_TIB)__USE_GLOBAL_NAMESPACE(NtCurrentTeb)())->StackBase;
    int (__int_var)=0;
    int __nested=FALSE;
    
    /* Take Lock, this lock is needed to keep Terminate in sync with Initialize. */
    while ( __USE_GLOBAL_NAMESPACE(InterlockedExchange)( &(__lock_handle), 1) == 1 )
        {
        ++(__int_var);
        if ((__lockFiberId) == (__currentFiberId)) 
        {
            return TRUE;
        }
                __USE_GLOBAL_NAMESPACE(Sleep)( (__int_var)>1000?100:0 );

        /*
        If you hang in this loop, this implies that your dllMainCRTStartup is hung on another
        thread. The most likely cause of this is a hang in one of your static constructors or
        destructors.
        */
    }
    /*
    Note that we don't really need any interlocked stuff here as the writes are always
    in the lock. Only reads are outside the lock.
    */
    (__lockFiberId) = (__currentFiberId);
    __try {

        void *__lock_free=0;
        while((__lock_free=__USE_GLOBAL_NAMESPACE(InterlockedCompareExchangePointer)(&__native_startup_lock, __REINTERPRET_CAST(void *)(__STATIC_CAST(INT_PTR)(1)), 0))!=0)
        {
            /* some other thread is running native startup/shutdown during a cctor/domain unload. 
            Should only happen if this DLL was built using the Everett-compat loader lock fix in vcclrit.h
            */
            /* wait for the other thread to complete init before we return */
            Sleep(1000);
        }
        if ( (__initialized) == FALSE )
        {
            (__retval) = FALSE;
        }
        else if ( (__terminated) == FALSE )
        {
            __try
            {
                __native_vcclrit_reason = DLL_PROCESS_DETACH;
                (__retval) = _DllMainCRTStartup( ( HINSTANCE )( &(__ImageBase) ), DLL_PROCESS_DETACH, 0 );
            }
            __finally
            {
                __native_vcclrit_reason = __NO_REASON;
            }
            (__terminated) = TRUE;
        }

    } __finally {
        /* revert the __lockFiberId */
        (__lockFiberId) = 0;
        /* Release Lock */
        __USE_GLOBAL_NAMESPACE(InterlockedExchange)( &(__lock_handle), 0 );
        if(!__nested)
        {
            _CrtInterlockedExchangePointer( &(__native_startup_lock), 0 );
        }
    }
    return (__retval);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\locking.h ===
/***
*sys/locking.h - flags for locking() function
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the flags for the locking() function.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_LOCKING
#define _INC_LOCKING

#if !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#define _LK_UNLCK       0       /* unlock the file region */
#define _LK_LOCK        1       /* lock the file region */
#define _LK_NBLCK       2       /* non-blocking lock */
#define _LK_RLCK        3       /* lock for writing */
#define _LK_NBRLCK      4       /* non-blocking lock for writing */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK        _LK_UNLCK
#define LK_LOCK         _LK_LOCK
#define LK_NBLCK        _LK_NBLCK
#define LK_RLCK         _LK_RLCK
#define LK_NBRLCK       _LK_NBRLCK
#endif

#endif  /* _INC_LOCKING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\appdomain.h ===
/***
*appdomain.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Utitily for cross App Domain Calls
*
*       [Public]
*
****/

#pragma once

#if !defined(_INC_MSCLR_APPDOMAIN)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries require /clr and are not compatible with /clr:oldSyntax
#endif

#ifdef _M_CEE_PURE
#error ERROR: msclr appdomain helpers can only be used in mixed mode. Use a cross-domain delegate in pure mode 
#endif
#include <mscoree.h>
#include <crtdbg.h>

#if defined(_M_IX86)
#define _MSCLR_STDCALL_DISTINCT 1
#elif defined(_M_IA64)
#define _MSCLR_STDCALL_DISTINCT 0
#elif defined(_M_AMD64)
#define _MSCLR_STDCALL_DISTINCT 0
#else 
#error Need to add setting for different CPU
#endif

namespace msclr
{

namespace _detail
{

/* helper functions */

inline
void validate(HRESULT hr)
{
    _ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        System::Runtime::InteropServices::Marshal::ThrowExceptionForHR(hr);
    }
}

inline
ICLRRuntimeHost *get_clr_runtime_host(void)
{
    ICLRRuntimeHost *pClrHost = NULL;

    HRESULT hr = CorBindToRuntimeEx(
        NULL,                       // version of the runtime to request
        NULL,                       // flavor of the runtime to request
        0,                          // runtime startup flags
        CLSID_CLRRuntimeHost,       // clsid of ICLRRuntimeHost
        IID_ICLRRuntimeHost,        // IID of ICLRRuntimeHost
        (PVOID*)&pClrHost);         // a pointer to our punk that we get back

    if (FAILED(hr))
    {
        if (pClrHost != NULL)
        {
            pClrHost->Release();
        }
        validate(hr);
    }
    return pClrHost;
}

/* callback struct */

/* __stdcall version */

#if _MSCLR_STDCALL_DISTINCT

template <typename RetType>
struct callback_stdcall_struct0
{
    RetType (__stdcall *func)();
    RetType retValue;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct0 *pcs = (callback_stdcall_struct0*)cookie;
        pcs->retValue = pcs->func();
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1>
struct callback_stdcall_struct1
{
    RetType (__stdcall *func)(ArgType1);
    RetType retValue;
    ArgType1 arg1;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct1 *pcs = (callback_stdcall_struct1*)cookie;
        pcs->retValue = pcs->func(pcs->arg1);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2>
struct callback_stdcall_struct2
{
    RetType (__stdcall *func)(ArgType1, ArgType2);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct2 *pcs = (callback_stdcall_struct2*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3>
struct callback_stdcall_struct3
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct3 *pcs = (callback_stdcall_struct3*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
struct callback_stdcall_struct4
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct4 *pcs = (callback_stdcall_struct4*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
struct callback_stdcall_struct5
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct5 *pcs = (callback_stdcall_struct5*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
struct callback_stdcall_struct6
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct6 *pcs = (callback_stdcall_struct6*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
struct callback_stdcall_struct7
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct7 *pcs = (callback_stdcall_struct7*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
struct callback_stdcall_struct8
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct8 *pcs = (callback_stdcall_struct8*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
struct callback_stdcall_struct9
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct9 *pcs = (callback_stdcall_struct9*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
struct callback_stdcall_struct10
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct10 *pcs = (callback_stdcall_struct10*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
struct callback_stdcall_struct11
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct11 *pcs = (callback_stdcall_struct11*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
struct callback_stdcall_struct12
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct12 *pcs = (callback_stdcall_struct12*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
struct callback_stdcall_struct13
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct13 *pcs = (callback_stdcall_struct13*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
struct callback_stdcall_struct14
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct14 *pcs = (callback_stdcall_struct14*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
struct callback_stdcall_struct15
{
    RetType (__stdcall *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;
    ArgType15 arg15;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_struct15 *pcs = (callback_stdcall_struct15*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14, pcs->arg15);
        hr = S_OK;
        return hr;
    }
};

struct callback_stdcall_void_struct0
{
    void (__stdcall *func)();

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct0 *pcs = (callback_stdcall_void_struct0*)cookie;
        pcs->func();
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1>
struct callback_stdcall_void_struct1
{
    void (__stdcall * func)(ArgType1);
    ArgType1 arg1;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct1 *pcs = (callback_stdcall_void_struct1*)cookie;
        pcs->func(pcs->arg1);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2>
struct callback_stdcall_void_struct2
{
    void (__stdcall * func)(ArgType1, ArgType2);
    ArgType1 arg1;
    ArgType2 arg2;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct2 *pcs = (callback_stdcall_void_struct2*)cookie;
        pcs->func(pcs->arg1, pcs->arg2);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3>
struct callback_stdcall_void_struct3
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct3 *pcs = (callback_stdcall_void_struct3*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
struct callback_stdcall_void_struct4
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct4 *pcs = (callback_stdcall_void_struct4*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
struct callback_stdcall_void_struct5
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct5 *pcs = (callback_stdcall_void_struct5*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
struct callback_stdcall_void_struct6
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct6 *pcs = (callback_stdcall_void_struct6*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
struct callback_stdcall_void_struct7
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct7 *pcs = (callback_stdcall_void_struct7*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
struct callback_stdcall_void_struct8
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct8 *pcs = (callback_stdcall_void_struct8*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
struct callback_stdcall_void_struct9
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct9 *pcs = (callback_stdcall_void_struct9*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
struct callback_stdcall_void_struct10
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct10 *pcs = (callback_stdcall_void_struct10*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
struct callback_stdcall_void_struct11
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct11 *pcs = (callback_stdcall_void_struct11*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
struct callback_stdcall_void_struct12
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct12 *pcs = (callback_stdcall_void_struct12*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
struct callback_stdcall_void_struct13
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct13 *pcs = (callback_stdcall_void_struct13*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
struct callback_stdcall_void_struct14
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct14 *pcs = (callback_stdcall_void_struct14*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
struct callback_stdcall_void_struct15
{
    void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;
    ArgType15 arg15;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_stdcall_void_struct15 *pcs = (callback_stdcall_void_struct15*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14, pcs->arg15);
        hr = S_OK;
        return hr;
    }
};

#endif

/* __cdecl version */

template <typename RetType>
struct callback_cdecl_struct0
{
    RetType (__cdecl *func)();
    RetType retValue;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct0 *pcs = (callback_cdecl_struct0*)cookie;
        pcs->retValue = pcs->func();
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1>
struct callback_cdecl_struct1
{
    RetType (__cdecl *func)(ArgType1);
    RetType retValue;
    ArgType1 arg1;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct1 *pcs = (callback_cdecl_struct1*)cookie;
        pcs->retValue = pcs->func(pcs->arg1);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2>
struct callback_cdecl_struct2
{
    RetType (__cdecl *func)(ArgType1, ArgType2);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct2 *pcs = (callback_cdecl_struct2*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3>
struct callback_cdecl_struct3
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct3 *pcs = (callback_cdecl_struct3*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
struct callback_cdecl_struct4
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct4 *pcs = (callback_cdecl_struct4*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
struct callback_cdecl_struct5
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct5 *pcs = (callback_cdecl_struct5*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
struct callback_cdecl_struct6
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct6 *pcs = (callback_cdecl_struct6*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
struct callback_cdecl_struct7
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct7 *pcs = (callback_cdecl_struct7*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
struct callback_cdecl_struct8
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct8 *pcs = (callback_cdecl_struct8*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
struct callback_cdecl_struct9
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct9 *pcs = (callback_cdecl_struct9*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
struct callback_cdecl_struct10
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct10 *pcs = (callback_cdecl_struct10*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
struct callback_cdecl_struct11
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct11 *pcs = (callback_cdecl_struct11*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
struct callback_cdecl_struct12
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct12 *pcs = (callback_cdecl_struct12*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
struct callback_cdecl_struct13
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct13 *pcs = (callback_cdecl_struct13*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
struct callback_cdecl_struct14
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct14 *pcs = (callback_cdecl_struct14*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14);
        hr = S_OK;
        return hr;
    }
};

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
struct callback_cdecl_struct15
{
    RetType (__cdecl *func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15);
    RetType retValue;
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;
    ArgType15 arg15;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_struct15 *pcs = (callback_cdecl_struct15*)cookie;
        pcs->retValue = pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14, pcs->arg15);
        hr = S_OK;
        return hr;
    }
};

struct callback_cdecl_void_struct0
{
    void (__cdecl *func)();

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct0 *pcs = (callback_cdecl_void_struct0*)cookie;
        pcs->func();
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1>
struct callback_cdecl_void_struct1
{
    void (__cdecl * func)(ArgType1);
    ArgType1 arg1;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct1 *pcs = (callback_cdecl_void_struct1*)cookie;
        pcs->func(pcs->arg1);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2>
struct callback_cdecl_void_struct2
{
    void (__cdecl * func)(ArgType1, ArgType2);
    ArgType1 arg1;
    ArgType2 arg2;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct2 *pcs = (callback_cdecl_void_struct2*)cookie;
        pcs->func(pcs->arg1, pcs->arg2);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3>
struct callback_cdecl_void_struct3
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct3 *pcs = (callback_cdecl_void_struct3*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
struct callback_cdecl_void_struct4
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct4 *pcs = (callback_cdecl_void_struct4*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
struct callback_cdecl_void_struct5
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct5 *pcs = (callback_cdecl_void_struct5*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
struct callback_cdecl_void_struct6
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct6 *pcs = (callback_cdecl_void_struct6*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
struct callback_cdecl_void_struct7
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct7 *pcs = (callback_cdecl_void_struct7*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
struct callback_cdecl_void_struct8
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct8 *pcs = (callback_cdecl_void_struct8*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
struct callback_cdecl_void_struct9
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct9 *pcs = (callback_cdecl_void_struct9*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
struct callback_cdecl_void_struct10
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct10 *pcs = (callback_cdecl_void_struct10*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
struct callback_cdecl_void_struct11
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct11 *pcs = (callback_cdecl_void_struct11*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
struct callback_cdecl_void_struct12
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct12 *pcs = (callback_cdecl_void_struct12*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
struct callback_cdecl_void_struct13
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct13 *pcs = (callback_cdecl_void_struct13*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
struct callback_cdecl_void_struct14
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct14 *pcs = (callback_cdecl_void_struct14*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14);
        hr = S_OK;
        return hr;
    }
};

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
struct callback_cdecl_void_struct15
{
    void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15);
    ArgType1 arg1;
    ArgType2 arg2;
    ArgType3 arg3;
    ArgType4 arg4;
    ArgType5 arg5;
    ArgType6 arg6;
    ArgType7 arg7;
    ArgType8 arg8;
    ArgType9 arg9;
    ArgType10 arg10;
    ArgType11 arg11;
    ArgType12 arg12;
    ArgType13 arg13;
    ArgType14 arg14;
    ArgType15 arg15;

    static HRESULT __stdcall callback(void *cookie)
    {
        HRESULT hr = E_FAIL;
        if (cookie == NULL)
        {
            return hr;
        }
        callback_cdecl_void_struct15 *pcs = (callback_cdecl_void_struct15*)cookie;
        pcs->func(pcs->arg1, pcs->arg2, pcs->arg3, pcs->arg4, pcs->arg5, pcs->arg6, pcs->arg7, pcs->arg8, pcs->arg9, pcs->arg10, pcs->arg11, pcs->arg12, pcs->arg13, pcs->arg14, pcs->arg15);
        hr = S_OK;
		return hr;
	}
};

} // namespace _detail

/* __stdcall version */
#if _MSCLR_STDCALL_DISTINCT

template <typename RetType>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)())
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct0<RetType> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1), ArgType1 arg1)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct1<RetType, ArgType1> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2), ArgType1 arg1, ArgType2 arg2)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct2<RetType, ArgType1, ArgType2> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct3<RetType, ArgType1, ArgType2, ArgType3> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct4<RetType, ArgType1, ArgType2, ArgType3, ArgType4> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct5<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct6<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct7<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct8<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct9<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct10<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct11<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct12<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct13<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct14<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14, ArgType15 arg15)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_struct15<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;
    cs.arg15 = arg15;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)())
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct0 cs;

    // fill up the callback_stdcall_struct
    cs.func = func;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1), ArgType1 arg1)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct1<ArgType1> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2), ArgType1 arg1, ArgType2 arg2)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct2<ArgType1, ArgType2> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct3<ArgType1, ArgType2, ArgType3> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct4<ArgType1, ArgType2, ArgType3, ArgType4> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct5<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct6<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct7<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct8<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct9<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct10<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct11<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct12<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct13<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct14<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__stdcall * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14, ArgType15 arg15)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_stdcall_void_struct15<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15> cs;

    // fill up the callback_stdcall_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;
    cs.arg15 = arg15;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

#endif

/* __cdecl version */

template <typename RetType>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)())
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct0<RetType> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1), ArgType1 arg1)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct1<RetType, ArgType1> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2), ArgType1 arg1, ArgType2 arg2)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct2<RetType, ArgType1, ArgType2> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct3<RetType, ArgType1, ArgType2, ArgType3> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct4<RetType, ArgType1, ArgType2, ArgType3, ArgType4> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct5<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct6<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct7<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct8<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct9<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct10<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct11<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct12<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct13<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct14<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

template <typename RetType, typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
RetType inline call_in_appdomain(DWORD dwAppDomainId, RetType (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14, ArgType15 arg15)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_struct15<RetType, ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;
    cs.arg15 = arg15;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
    
    return cs.retValue;
}

void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)())
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct0 cs;

    // fill up the callback_cdecl_struct
    cs.func = func;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1), ArgType1 arg1)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct1<ArgType1> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2), ArgType1 arg1, ArgType2 arg2)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct2<ArgType1, ArgType2> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct3<ArgType1, ArgType2, ArgType3> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct4<ArgType1, ArgType2, ArgType3, ArgType4> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct5<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct6<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct7<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct8<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct9<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct10<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct11<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct12<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct13<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct14<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

template <typename ArgType1, typename ArgType2, typename ArgType3, typename ArgType4, typename ArgType5, typename ArgType6, typename ArgType7, typename ArgType8, typename ArgType9, typename ArgType10, typename ArgType11, typename ArgType12, typename ArgType13, typename ArgType14, typename ArgType15>
void inline call_in_appdomain(DWORD dwAppDomainId, void (__cdecl * func)(ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15), ArgType1 arg1, ArgType2 arg2, ArgType3 arg3, ArgType4 arg4, ArgType5 arg5, ArgType6 arg6, ArgType7 arg7, ArgType8 arg8, ArgType9 arg9, ArgType10 arg10, ArgType11 arg11, ArgType12 arg12, ArgType13 arg13, ArgType14 arg14, ArgType15 arg15)
{
    ICLRRuntimeHost *pClrHost = _detail::get_clr_runtime_host();
    _detail::callback_cdecl_void_struct15<ArgType1, ArgType2, ArgType3, ArgType4, ArgType5, ArgType6, ArgType7, ArgType8, ArgType9, ArgType10, ArgType11, ArgType12, ArgType13, ArgType14, ArgType15> cs;

    // fill up the callback_cdecl_struct
    cs.func = func;
    cs.arg1 = arg1;
    cs.arg2 = arg2;
    cs.arg3 = arg3;
    cs.arg4 = arg4;
    cs.arg5 = arg5;
    cs.arg6 = arg6;
    cs.arg7 = arg7;
    cs.arg8 = arg8;
    cs.arg9 = arg9;
    cs.arg10 = arg10;
    cs.arg11 = arg11;
    cs.arg12 = arg12;
    cs.arg13 = arg13;
    cs.arg14 = arg14;
    cs.arg15 = arg15;

    // call the function
    HRESULT hr = pClrHost->ExecuteInAppDomain(dwAppDomainId, &cs.callback, &cs);
    pClrHost->Release();
    _detail::validate(hr);
}

} // namespace msclr

#define _INC_MSCLR_APPDOMAIN

#endif // _INC_MSCLR_APPDOMAIN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\auto_handle.h ===
/***
*auto_handle.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   automatic resource management, like std::auto_ptr for ref classes
*
*       [Public]
*
****/

#pragma once

#if !defined(_INC_MSCLR_AUTO_HANDLE)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif

#include <msclr\safebool.h>

namespace msclr
{

    // wrap a resource to enforce strict ownership and ensure proper cleanup
    template<typename _element_type>
    ref class auto_handle
    {
    private:
        // disallow explicit comparisons to _safe_bool
        bool operator==( _detail_class::_safe_bool );
        bool operator!=( _detail_class::_safe_bool );
        
    public:

        // Constructors
        
        auto_handle() 
            : m_handle( nullptr )
        {
        }

        // construct from object pointer
        auto_handle( _element_type ^ _ptr ) 
            : m_handle( _ptr )
        {
        }

        // construct by assuming pointer from _right auto_handle
        auto_handle(auto_handle<_element_type> % _right ) 
                : m_handle( _right.release() )
        {
        }

        template<typename _other_type>
        auto_handle( auto_handle<_other_type> % _right ) 
                : m_handle( _right.release() )
        {
        }

        // assign compatible _right
        auto_handle<_element_type> % operator=( 
            auto_handle<_element_type> % _right ) 
        {
            reset( _right.release() );
            return *this;
        }


        template<typename _other_type>
        auto_handle<_element_type> % operator=(
            auto_handle<_other_type> % _right ) 
        {
            reset( _right.release() );
            return *this;
        }

        _element_type ^ get()
        {
            return m_handle;
        }

        // return pointer to class object (assume pointer)
        _element_type ^ operator->()
        {
            return m_handle;
        }

        // for use when auto_handle appears in a conditional
        operator _detail_class::_safe_bool()
        {
            return valid() ? _detail_class::_safe_true : _detail_class::_safe_false;
        }

        // for use when auto_handle appears in a conditional
        bool operator!()
        {
            return ! valid();
        }


        template<typename _other_type>
        operator auto_handle<_other_type>() 
        {
            return auto_handle<_other_type>( *this );
        }

        void swap( auto_handle<_element_type> % _right ) 
        {
			auto_handle<_element_type> tmp = _right;
			_right = *this;
			*this = tmp;
        }

        void reset( _element_type ^ _new_ptr ) 
        {
            if( m_handle != _new_ptr )
            {
                if( valid() )
                {
                    delete m_handle;
                }
                m_handle = _new_ptr;
            }
        }

        void reset( ) 
        {
            reset(nullptr);
        }

        _element_type ^ release() 
        {
            _element_type ^_tmp_ptr = m_handle;
            m_handle = nullptr;
            return _tmp_ptr;
        }

        // destroy the object
        ~auto_handle()
        {
            if( valid() )
            {
                delete m_handle;
            }
        }

        private:

        bool valid()
        {
            // see if the managed resource is in the invalid state.
            return m_handle != nullptr;

        }

        // the wrapped object
        _element_type ^ m_handle;
    };

    // swap the contents of two auto_handle objects
    template<typename _element_type>
    void swap( auto_handle<_element_type> % _left, 
               auto_handle<_element_type> % _right ) 
    {
        _left.swap( _right );
    }

} // namespace msclr

#define _INC_MSCLR_AUTO_HANDLE

#endif // _INC_MSCLR_AUTO_HANDLE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\lock.h ===
/***
*lock.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   lock class for automatically acquiring/releasing
*           the monitor lock on managed types.
*
*       [Public]
*
****/

#pragma once

#if !defined(_INC_MSCLR_LOCK)

#ifndef __cplusplus_cli
#error ERROR: msclr libraries are not compatible with /clr:oldSyntax
#endif

#using <mscorlib.dll>
#include <msclr\safebool.h>
#if !defined(_M_CEE_SAFE)
#include <vcclr.h>
#endif

namespace msclr
{

    // The lock_when enumeration is used to defer the lock object
    // from taking the lock.
    enum lock_when { lock_later };

    ref class lock
    {
    private:
        System::Object ^ m_object;
        bool             m_locked;

        template<class T,class U> value struct is_not { typedef int __dont_use_this_type__; };
        template<class T> value struct is_not<T,T> { };

    public:
        // By default, take the lock immediately with an infinite timeout.
        // Accept an optional timespan (in milliseconds) and throw on failure or timeout.
        template<class T> lock( T ^ _object) 
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);

            acquire(System::Threading::Timeout::Infinite);
        }

        template<class T> lock( T ^ _object, int _timeout )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);

            acquire( _timeout );
        }

        // By default, take the lock immediately within the specified timespan 
        // and throw on failure or timeout.
        template<class T> lock( T ^ _object, System::TimeSpan _timeout )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);

            acquire( _timeout );
        }

        // If you use the "lock_later" enumeration, it causes lock
        // to defer taking the lock.
        template<class T> lock( T ^ _object, lock_when )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);
        }

#if !defined(_M_CEE_SAFE)
        template<class T> lock( gcroot<T ^> _object) 
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);

            acquire(System::Threading::Timeout::Infinite);
        }


        template<class T> lock( gcroot<T ^> _object, int _timeout )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);

            acquire( _timeout );
        }

        // By default, take the lock immediately within the specified timespan 
        // and throw on failure or timeout.
        template<class T> lock( gcroot<T ^> _object, System::TimeSpan _timeout )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);

            acquire( _timeout );
        }

        // If you use the "lock_later" enumeration, it causes lock
        // to defer taking the lock.
        template<class T> lock( gcroot<T ^> _object, lock_when )
            : m_object( _object ),
              m_locked( false )
        {
            // ensure that T is not a ReaderWriterLock.
            is_not<T, System::Threading::ReaderWriterLock>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);
        }
#endif /* if !defined(_M_CEE_SAFE) */

        // release the lock if it is not currently held
        ~lock()
        {
            release();
        }

        // Check to see if this lock object is currently holding the lock
        bool is_locked()
        {
            return m_locked;
        }

        // Check to see if this lock object is currently holding the lock
        operator _detail_class::_safe_bool()
        {
            return is_locked() ? _detail_class::_safe_true : _detail_class::_safe_false;
        }

        // disallow explicit comparisons to _safe_bool
        template<class T> bool operator==( T t )
        {
            // ensure that T is not a _safe_bool.
            is_not<T, _detail_class::_safe_bool>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);

            return m_object == t;
        }

        template<class T> bool operator!=( T t )
        {
            // ensure that T is not a _safe_bool.
            is_not<T, _detail_class::_safe_bool>::__dont_use_this_type__ _Diagnostic;
            (_Diagnostic);

            return m_object != t;
        }

        // Take the lock within the specified timespan, or with an infinite
        // timespan if none is specified. Throw an ApplicationException on timeout.
        void acquire( int _timeout )
        {
            if( ! m_locked )
            {
                if( ! System::Threading::Monitor::TryEnter( m_object, _timeout ) )
                {
                    throw gcnew System::ApplicationException( "lock timeout" );
                }
                m_locked = true;
            }
        }

        void acquire()
        {
            if( ! m_locked )
            {
                if( ! System::Threading::Monitor::TryEnter( m_object, 
                          System::Threading::Timeout::Infinite ) )
                {
                    throw gcnew System::ApplicationException( "lock timeout" );
                }
                m_locked = true;
            }
        }

        // Take the lock within the specified timespan. 
        // Throw an ApplicationException on timeout.
        void acquire( System::TimeSpan _timeout )
        {
            if( ! m_locked )
            {
                if( ! System::Threading::Monitor::TryEnter( m_object, _timeout ) )
                {
                    throw gcnew System::ApplicationException( "lock timeout" );
                }
                m_locked = true;
            }
        }

        // Try to take the lock within the specified timespan. In the case
        // of timeout, return false.
        bool try_acquire( int _timeout ) // throw()
        {
            if( ! m_locked )
            {
                if( ! System::Threading::Monitor::TryEnter( m_object, _timeout ) )
                {
                    return false;
                }
                m_locked = true;
            }
            return true;
        }

        // Try to take the lock within the specified timespan. In the case
        // of timeout, return false.
        bool try_acquire( System::TimeSpan _timeout ) // throw()
        {
            if( ! m_locked )
            {
                if( ! System::Threading::Monitor::TryEnter( m_object, _timeout ) )
                {
                    return false;
                }
                m_locked = true;
            }
            return true;
        }

        // Release the lock if it is currently held
        void release()
        {
            if( m_locked )
            {
                m_locked = false;
                System::Threading::Monitor::Exit( m_object );
            }
        }
    };
}

#define _INC_MSCLR_LOCK

#endif // _INC_MSCLR_LOCK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\timeb.h ===
/***
*sys/timeb.h - definition/declarations for _ftime()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file define the _ftime() function and the types it uses.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TIMEB
#define _INC_TIMEB

#include <crtdefs.h>

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifdef  _USE_32BIT_TIME_T
#ifdef  _WIN64
#include <crtwrn.h>
#pragma _CRT_WARNING( _NO_32BIT_TIME_T )
#undef  _USE_32BIT_TIME_T
#endif
#endif

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else
typedef __time64_t time_t;      /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

/* Structure returned by _ftime system call */

#ifndef _TIMEB_DEFINED
struct __timeb32 {
        __time32_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#if     !__STDC__

/* Non-ANSI name for compatibility */
struct timeb {
        time_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };


#endif

struct __timeb64 {
        __time64_t time;
        unsigned short millitm;
        short timezone;
        short dstflag;
        };

#ifdef  _USE_32BIT_TIME_T

#define _timeb      __timeb32
#define _ftime      _ftime32
#define _ftime_s    _ftime32_s

#else

#define _timeb      __timeb64
#define _ftime      _ftime64
#define _ftime_s    _ftime64_s

#endif
#define _TIMEB_DEFINED
#endif

#include <crtdefs.h>

/* Function prototypes */

_CRT_INSECURE_DEPRECATE(_ftime32_s) _CRTIMP void __cdecl _ftime32(_Out_ struct __timeb32 * _Time);
_CRTIMP errno_t __cdecl _ftime32_s(_Out_ struct __timeb32 * _Time);
_CRT_INSECURE_DEPRECATE(_ftime64_s) _CRTIMP void __cdecl _ftime64(_Out_ struct __timeb64 * _Time);
_CRTIMP errno_t __cdecl _ftime64_s(_Out_ struct __timeb64 * _Time);

#if !defined(RC_INVOKED) && !defined(__midl)
#include <sys/timeb.inl>
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_TIMEB */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\timeb.inl ===
/***
*timeb.inl - inline definitions for low-level file handling and I/O functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definition of the _ftime() function.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#if !defined(__CRTDECL)
#if defined(_M_CEE_PURE)
#define __CRTDECL
#else
#define __CRTDECL   __cdecl
#endif
#endif

#ifndef _INC_TIMEB_INL
#define _INC_TIMEB_INL

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif

#if     !__STDC__

/* Non-ANSI name for compatibility */

#pragma warning(push)
#pragma warning(disable:4996)

#ifdef _USE_32BIT_TIME_T
static __inline void __CRTDECL ftime(struct timeb * _Tmb)
{
    _STATIC_ASSERT( sizeof(struct timeb) == sizeof(struct __timeb32) );
    _ftime32((struct __timeb32 *)_Tmb);
}
#else
static __inline void __CRTDECL ftime(struct timeb * _Tmb)
{
    _STATIC_ASSERT( sizeof(struct timeb) == sizeof(struct __timeb64) );
    _ftime64((struct __timeb64 *)_Tmb);
}
#endif /* _USE_32BIT_TIME_T */

#pragma warning(pop)

#endif /* !__STDC__ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\utime.h ===
/***
*sys/utime.h - definitions/declarations for utime()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the utime routine to set
*       new file access and modification times.  NOTE - MS-DOS
*       does not recognize access time, so this field will
*       always be ignored and the modification time field will be
*       used to set the new time.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#include <crtdefs.h>

#ifndef _INC_UTIME
#define _INC_UTIME

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#include <crtdefs.h>


#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifdef  _USE_32BIT_TIME_T
#ifdef  _WIN64
#include <crtwrn.h>
#pragma _CRT_WARNING( _NO_32BIT_TIME_T )
#undef  _USE_32BIT_TIME_T
#endif
#endif

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else
typedef __time64_t time_t;      /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

/* define struct used by _utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };

struct __utimbuf32 {
        __time32_t actime;      /* access time */
        __time32_t modtime;     /* modification time */
        };

struct __utimbuf64 {
        __time64_t actime;      /* access time */
        __time64_t modtime;     /* modification time */
        };

#if     !__STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
        time_t actime;          /* access time */
        time_t modtime;         /* modification time */
        };
        
struct utimbuf32 {
        __time32_t actime;      /* access time */
        __time32_t modtime;     /* modification time */
        };

#endif /* !__STDC__ */

#define _UTIMBUF_DEFINED
#endif


/* Function Prototypes */

_CRTIMP int __cdecl _utime32(_In_z_ const char * _Filename, _In_opt_ struct __utimbuf32 * _Time);

_CRTIMP int __cdecl _futime32(_In_ int _FileDes, _In_opt_ struct __utimbuf32 * _Time);

/* Wide Function Prototypes */
_CRTIMP int __cdecl _wutime32(_In_z_ const wchar_t * _Filename, _In_opt_ struct __utimbuf32 * _Time);

_CRTIMP int __cdecl _utime64(_In_z_ const char * _Filename, _In_opt_ struct __utimbuf64 * _Time);
_CRTIMP int __cdecl _futime64(_In_ int _FileDes, _In_opt_ struct __utimbuf64 * _Time);
_CRTIMP int __cdecl _wutime64(_In_z_ const wchar_t * _Filename, _In_opt_ struct __utimbuf64 * _Time);

#if !defined(RC_INVOKED) && !defined(__midl)
#include <sys/utime.inl>
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_UTIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\types.h ===
/***
*sys/types.h - types returned by system level calls for file and time info
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines types used in defining values returned by system
*       level calls for file status and time information.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_TYPES
#define _INC_TYPES

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif


#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifdef  _USE_32BIT_TIME_T
#ifdef  _WIN64
#include <crtwrn.h>
#pragma _CRT_WARNING( _NO_32BIT_TIME_T )
#undef  _USE_32BIT_TIME_T
#endif
#endif

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else
typedef __time64_t time_t;      /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#ifndef _INO_T_DEFINED

typedef unsigned short _ino_t;          /* i-node number (not used on DOS) */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif

#define _INO_T_DEFINED
#endif


#ifndef _DEV_T_DEFINED

typedef unsigned int _dev_t;            /* device code */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef unsigned int dev_t;
#endif

#define _DEV_T_DEFINED
#endif


#ifndef _OFF_T_DEFINED

typedef long _off_t;                    /* file offset value */

#if     !__STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif

#define _OFF_T_DEFINED
#endif

#endif  /* _INC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\wstat.inl ===
/***
*wstat.inl - inline definitions for low-level file handling and I/O functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function definitions for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#if !defined(__CRTDECL)
#if defined(_M_CEE_PURE)
#define __CRTDECL
#else
#define __CRTDECL   __cdecl
#endif
#endif

#ifndef _INC_WSTAT_INL
#define _INC_WSTAT_INL

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL _wstat(const wchar_t * _Filename, struct _stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct _stat) == sizeof(struct _stat32) );
    return _wstat32(_Filename,(struct _stat32 *)_Stat);
}
#else
static __inline int __CRTDECL _wstat(const wchar_t * _Filename, struct _stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct _stat) == sizeof(struct _stat64i32) );
    return _wstat64i32(_Filename,(struct _stat64i32 *)_Stat);
}
#endif /* _USE_32BIT_TIME_T */

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL _wstati64(const wchar_t * _Filename, struct _stati64 * _Stat)
{
    _STATIC_ASSERT( sizeof(struct _stati64) == sizeof(struct _stat32i64) );
    return _wstat32i64(_Filename,(struct _stat32i64*)_Stat);
}
#else
static __inline int __CRTDECL _wstati64(const wchar_t * _Filename, struct _stati64 * _Stat)
{
    _STATIC_ASSERT( sizeof(struct _stati64) == sizeof(struct _stat64) );
    return _wstat64(_Filename,(struct _stat64*)_Stat);
}
#endif /* _USE_32BIT_TIME_T */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\marshal_cppstd.h ===
/***
*marshal_cppstd.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Marshalling classes
*
*       [Public]
*
****/

#pragma once

#ifndef _INC_MSCLR_MARSHAL_CPPSTD
#define _INC_MSCLR_MARSHAL_CPPSTD

#include <string>
#include <vector>
#include <vcclr.h>

#include "marshal.h"

#using <mscorlib.dll>

namespace msclr{
	namespace interop{

template <>
inline System::String^ marshal_as(const std::string& _from_obj)
{
	return details::InternalAnsiToStringHelper(_from_obj.c_str(), _from_obj.length());
}

template <>
inline std::string marshal_as(System::String^ const & _from_obj)
{
	if (_from_obj == nullptr)
	{
		throw gcnew System::ArgumentNullException(_EXCEPTION_NULLPTR);
	}
	std::string _to_obj;
	size_t _size = details::GetAnsiStringSize(_from_obj);
	
	// -1 because resize will automatically +1 for the NULL
	_to_obj.resize(_size-1);
	char *_dest_buf = &(_to_obj[0]);

	details::WriteAnsiString(_dest_buf, _size, _from_obj);

	return _to_obj;
}

template <>
inline System::String^ marshal_as(const std::wstring& _from_obj)
{
	return details::InternalUnicodeToStringHelper(_from_obj.c_str(), _from_obj.length());
}

template <>
inline std::wstring marshal_as(System::String^ const & _from_obj)
{
	if(_from_obj != nullptr)
	{
		cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_obj);
		std::wstring _to_obj(static_cast<const wchar_t *>(_pinned_ptr), _from_obj->Length);

		return _to_obj;
	}
	else
	{
		throw gcnew System::ArgumentNullException(_EXCEPTION_NULLPTR);
	}
}

	} //namespace interop
} //namespace msclr

#endif // _INC_MSCLR_MARSHAL_CPPSTD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\abort.c ===
/***
*abort.c - abort a program by raising SIGABRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines abort() - print a message and raise SIGABRT.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <internal.h>
#include <rterr.h>
#include <signal.h>
#include <oscalls.h>
#include <mtdll.h>

#ifdef _DEBUG
#define _INIT_ABORT_BEHAVIOR _WRITE_ABORT_MSG
#else  /* _DEBUG */
#define _INIT_ABORT_BEHAVIOR (_WRITE_ABORT_MSG | _CALL_REPORTFAULT)
#endif  /* _DEBUG */

unsigned int __abort_behavior = _INIT_ABORT_BEHAVIOR;

/***
*void abort() - abort the current program by raising SIGABRT
*
*Purpose:
*   print out an abort message and raise the SIGABRT signal.  If the user
*   hasn't defined an abort handler routine, terminate the program
*   with exit status of 3 without cleaning up.
*
*   Multi-thread version does not raise SIGABRT -- this isn't supported
*   under multi-thread.
*
*Entry:
*   None.
*
*Exit:
*   Does not return.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl abort (
        void
        )
{
    _PHNDLR sigabrt_act = SIG_DFL;

    if (__abort_behavior & _WRITE_ABORT_MSG)
    {
        /* write the abort message */
        _NMSG_WRITE(_RT_ABORT);
    }


    /* Check if the user installed a handler for SIGABRT.
     * We need to read the user handler atomically in the case
     * another thread is aborting while we change the signal
     * handler.
     */
    sigabrt_act = __get_sigabrt();
    if (sigabrt_act != SIG_DFL)
    {
        raise(SIGABRT);
    }

    /* If there is no user handler for SIGABRT or if the user
     * handler returns, then exit from the program anyway
     */

    if (__abort_behavior & _CALL_REPORTFAULT)
    {
        /* Fake an exception to call reportfault. */
        EXCEPTION_RECORD ExceptionRecord;
        CONTEXT ContextRecord;
        EXCEPTION_POINTERS ExceptionPointers;

#ifdef _X86_
        __asm {
            mov dword ptr [ContextRecord.Eax], eax
            mov dword ptr [ContextRecord.Ecx], ecx
            mov dword ptr [ContextRecord.Edx], edx
            mov dword ptr [ContextRecord.Ebx], ebx
            mov dword ptr [ContextRecord.Esi], esi
            mov dword ptr [ContextRecord.Edi], edi
            mov word ptr [ContextRecord.SegSs], ss
            mov word ptr [ContextRecord.SegCs], cs
            mov word ptr [ContextRecord.SegDs], ds
            mov word ptr [ContextRecord.SegEs], es
            mov word ptr [ContextRecord.SegFs], fs
            mov word ptr [ContextRecord.SegGs], gs
            pushfd
            pop [ContextRecord.EFlags]
        }

        ContextRecord.ContextFlags = CONTEXT_CONTROL;
#pragma warning(push)
#pragma warning(disable:4311)
        ContextRecord.Eip = (ULONG)_ReturnAddress();
        ContextRecord.Esp = (ULONG)_AddressOfReturnAddress();
#pragma warning(pop)
        ContextRecord.Ebp = *((ULONG *)_AddressOfReturnAddress()-1);
#elif defined (_IA64_) || defined (_AMD64_)
        /* Need to fill up the Context in IA64 and AMD64. See VSW#286097 */
        RtlCaptureContext(&ContextRecord);
#else  /* defined (_IA64_) || defined (_AMD64_) */
        ZeroMemory(&ContextRecord, sizeof(ContextRecord));
#endif  /* defined (_IA64_) || defined (_AMD64_) */

        ZeroMemory(&ExceptionRecord, sizeof(ExceptionRecord));

        ExceptionRecord.ExceptionCode = STATUS_FATAL_APP_EXIT;
        ExceptionRecord.ExceptionAddress = _ReturnAddress();

        ExceptionPointers.ExceptionRecord = &ExceptionRecord;
        ExceptionPointers.ContextRecord = &ContextRecord;

        /* Make sure any filter already in place is deleted. */
        SetUnhandledExceptionFilter(NULL);

        UnhandledExceptionFilter(&ExceptionPointers);
    }


    /* If we don't want to call ReportFault, then we call _exit(3), which is the
     * same as invoking the default handler for SIGABRT
     */


    _exit(3);
}

/***
*unsigned int _set_abort_behavior(unsigned int, unsigned int) - set the behavior on abort
*
*Purpose:
*
*Entry:
*   unsigned int flags - the flags we want to set
*   unsigned int mask - mask the flag values
*
*Exit:
*   Return the old behavior flags
*
*Exceptions:
*   None
*
*******************************************************************************/

unsigned int __cdecl _set_abort_behavior(unsigned int flags, unsigned int mask)
{
    unsigned int oldflags = __abort_behavior;
    __abort_behavior = oldflags & (~mask) | flags & mask;
    return oldflags;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\msclr\marshal.h ===
/***
*marshal.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:   Marshalling classes
*
*       [Public]
*
****/

#pragma once

#ifndef _INC_MSCLR_MARSHAL
#define _INC_MSCLR_MARSHAL

#using <mscorlib.dll>
#using <system.dll>

#include <sal.h>
#include <windows.h>
#include <vcclr.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <memory>

#pragma comment(lib, "comsupp.lib")
#pragma comment(lib, "oleaut32.lib")

#pragma warning(push)
#pragma warning(error : 4996)

namespace msclr{
	namespace interop{

namespace details
{
#define _EXCEPTION_GREATER_THAN_INT_MAX "Size of string exceeds INT_MAX."
#define _EXCEPTION_NULLPTR "NULLPTR is not supported for this conversion."
#define _EXCEPTION_MB2WC "Conversion from MultiByte to WideChar failed.  Please check the content of the string and/or locale settings."
#define _EXCEPTION_WC2MB "Conversion from WideChar to MultiByte failed.  Please check the content of the string and/or locale settings."

	inline __checkReturn size_t GetAnsiStringSize(System::String^ _str)
	{
		size_t _size = 0;
		cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_str);
		
		_size = ::WideCharToMultiByte(CP_THREAD_ACP, WC_NO_BEST_FIT_CHARS, _pinned_ptr, _str->Length, NULL, 0, NULL,NULL);
		if (_size == 0 && _str->Length != 0)
		{
			throw gcnew System::ArgumentException(_EXCEPTION_WC2MB);
		}
		// adding 1 for terminating nul
		_size+=1;
		return _size;
	}

	inline void WriteAnsiString(__out_ecount_full_z(_size) char* _buf, size_t _size, System::String^ _str)
	{
		cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_str);
		
		//checking for overflow
		if (_size > INT_MAX)
		{
			// this should never happen if _size was returned by GetAnsiStringSize()
			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
		}
		size_t _written = ::WideCharToMultiByte(CP_THREAD_ACP, WC_NO_BEST_FIT_CHARS, _pinned_ptr, _str->Length, _buf, static_cast<int>(_size) ,NULL,NULL);
		if( _written >= _size || 
				(_written == 0 && _size != 1)) // allowing empty string
		{
			throw gcnew System::ArgumentException(_EXCEPTION_WC2MB);
		}
		_buf[_written] = '\0';
	}

	inline __checkReturn size_t GetUnicodeStringLength(__in_ecount_z(_count+1) const char* _str, size_t _count)
	{
		size_t _size = 0;
		if (_count > INT_MAX)
		{
			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
		}
		_size = ::MultiByteToWideChar(CP_THREAD_ACP, 0, _str, static_cast<int>(_count), NULL, 0);
		
		if (_size == 0 && _count != 0)
		{
			throw gcnew System::ArgumentException(_EXCEPTION_MB2WC);
		}
		//adding 1 for terminating nul
		_size+=1;
		return _size;
	}

	inline void WriteUnicodeString(__out_ecount_full_z(_size) wchar_t* _dest, size_t _size, __in_bcount(_count)const char* _src, size_t _count)
	{
		//checking for overflow
		if (_size > INT_MAX || _count > INT_MAX)
		{
			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
		}

		size_t _written = ::MultiByteToWideChar(CP_THREAD_ACP, 0, _src, static_cast<int>(_count), _dest, static_cast<int>(_size));
		if( _written >= _size || 
				(_written == 0 && _size != 1)) // allowing empty string
		{
			throw gcnew System::ArgumentException(_EXCEPTION_MB2WC);
		}
		_dest[_written] = L'\0';
	}

	inline System::String^ InternalAnsiToStringHelper(__in_ecount_z(_count+1)const char* _src, size_t _count)
	{
		size_t _size = details::GetUnicodeStringLength(_src, _count);
		if (_size > INT_MAX || _size <=0 )
		{
			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
		}
		std::auto_ptr<wchar_t> _wchar_buf(new wchar_t[_size]);
		if (_wchar_buf.get() == NULL)
		{
			throw gcnew System::OutOfMemoryException();
		}

		details::WriteUnicodeString(_wchar_buf.get(), _size, _src, _count);

		return gcnew System::String(_wchar_buf.get(), 0, static_cast<int>(_size)-1);
	}

	inline System::String^ InternalUnicodeToStringHelper(__in_ecount_z(_count+1)const wchar_t* _src, size_t _count)
	{
		if (_count > INT_MAX)
		{
			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
		}
		
		return gcnew System::String(_src, 0 ,static_cast<int>(_count));
	}
} // namespace details

//--------------------------------------------------------------------------------
// Forward declarations
//--------------------------------------------------------------------------------

template <class _To_Type, class _From_Type, 
	 bool _Needs_Context = context_node<_To_Type,_From_Type>::_Needs_Context>
class error_reporting_helper;

ref class context_node_base;

template<class _To_Type>
inline _To_Type marshal_as(__in_z const char  _from_object[])
{
	const char* _ptr = _from_object;
	return marshal_as<_To_Type, const char *>(_ptr);
}

template<class _To_Type>
inline _To_Type marshal_as(__in_z const wchar_t  _from_object[])
{
	const wchar_t* _ptr = _from_object;
	return marshal_as<_To_Type, const wchar_t*>(_ptr);
}

template<class _To_Type, class _From_Type>
ref class context_node;

ref class marshal_context;

template <class _To_Type, class _From_Type>
inline _To_Type marshal_as(const _From_Type&);

//--------------------------------------------------------------------------------
// Context-free conversion generic templates
//--------------------------------------------------------------------------------

template <class _To_Type, class _From_Type>
class error_reporting_helper<_To_Type, _From_Type, /* _Needs_Context */ false> 
{
	public:
		__declspec(deprecated("This conversion is not supported by the library or the header file needed for this conversion is not included.  Please refer to the documentation on 'How to: Extend the Marshaling Library' for adding your own marshaling method."))
		static _To_Type marshal_as(const _From_Type& _from_object)
		{
			return _This_conversion_is_not_supported;
		}
};

template <class _To_Type, class _From_Type>
class error_reporting_helper<_To_Type, _From_Type, /* _Needs_Context */ true> 
{
	public:
		__declspec(deprecated("This conversion requires a marshal_context.  Please use a marshal_context for this conversion."))
		static _To_Type marshal_as(const _From_Type& _from_object)
		{
			return _This_conversion_requires_a_context;
		}
};

template <class _To_Type, class _From_Type>
inline _To_Type marshal_as(const _From_Type& _from_object)
{
	return error_reporting_helper<_To_Type, _From_Type>::marshal_as(_from_object);
}

//--------------------------------------------------------------------------------
// Context conversion generic templates
//--------------------------------------------------------------------------------

ref class context_node_base 
{
	public:
		static const bool _Needs_Context= true;
};

template<class _To_Type, class _From_Type>
ref class context_node : public context_node_base
{
	public:
		static const bool _Needs_Context= false;
};

ref class marshal_context 
{
	internal:
		//The list of objects that need to be cleaned up. Basically all those that have a destructor
		System::Collections::Generic::LinkedList <Object^> _clean_up_list;

		template<class _To_Type, class _From_Type, bool _Needs_Context>
		ref class internal_marshaler;

		template<class _To_Type, class _From_Type>
		ref class internal_marshaler<_To_Type, _From_Type, true>
		{
			public:
			// This is a supported context conversation.
			// Convert and added it to the list of cleanup
			static inline _To_Type marshal_as(const _From_Type& _from, System::Collections::Generic::LinkedList<Object^>% _clean_up_list)
			{
				typedef context_node<_To_Type, _From_Type> _cn;

				_To_Type _to_object;
				//Create a context node and assign marshalling result to the 'to' variable
				_cn^ _obj = gcnew _cn(_to_object, _from);
				_clean_up_list.AddLast(_obj);
				return _to_object;
			};
		};

		template<class _To_Type, class _From_Type>
		ref class internal_marshaler<_To_Type, _From_Type, false>
		{
			public:
			// This is not a supported context conversation.
			// This maybe a context-free conversation or a unsupported converstaion.
			// Both cases will be handed by the Marshal_as object.
			static inline _To_Type marshal_as(const _From_Type& _from, System::Collections::Generic::LinkedList<Object^>% _clean_up_list)
			{
				(_clean_up_list); // not using this variable intentionally
				return ::msclr::interop::marshal_as<_To_Type, _From_Type>(_from);
			};
		};

	public:
		template<class _To_Type, class _From_Type>
		inline _To_Type marshal_as(const _From_Type& _from) 
		{
			typedef context_node<_To_Type, _From_Type> _cn;
			return internal_marshaler<_To_Type, _From_Type, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
		}

		// special case marshal_as() that doesn't fit the usual marshal_as<To,From>() templates
		template<class _To_Type>
		inline _To_Type marshal_as(__in_z const char _from[]) 
		{
			typedef context_node<_To_Type, const char *> _cn;
			return internal_marshaler<_To_Type, const char*, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
		}

		template<class _To_Type>
		inline _To_Type marshal_as(__in_z const wchar_t _from[]) 
		{
			typedef context_node<_To_Type, const wchar_t *> _cn;
			return internal_marshaler<_To_Type, const wchar_t*, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
		}

		template<class _To_Type>
		inline _To_Type marshal_as(System::IntPtr _from) 
		{
			return ::msclr::interop::marshal_as<_To_Type>(_from);
		}

	marshal_context()
	{};

	~marshal_context()
	{
		for each(Object^ _obj in _clean_up_list)
			delete _obj;
	}
};

//--------------------------------------------------------------------------------
// Context-free conversions templates specialization for basic types
//--------------------------------------------------------------------------------

template <>
inline System::String^ marshal_as(__in_z const char * const & _from_object) 
{
	if (!_from_object)
	{
		return nullptr;
	}
	return details::InternalAnsiToStringHelper(_from_object, strlen(_from_object));
}

template<>
inline System::String^ marshal_as(__in_z char * const & _from_object) 
{
	return marshal_as<System::String^, const char *>(_from_object);
}

template <>
inline System::String^ marshal_as(__in_z const wchar_t* const & _from_object) 
{
	if (_from_object == NULL)
	{
		return nullptr;
	}
	return gcnew System::String(_from_object);
}

// Note: BSTR and wchar_t* are actually typedef alias.  Therefore, we can not define the
// conversion BSTR -> System::String^.  BSTR actually will use this function.
template <>
inline System::String^ marshal_as(__in_z wchar_t* const& _from_object)
{
	return marshal_as<System::String^, const wchar_t *>(_from_object);
}

//--------------------------------------------------------------------------------
// Context conversion templates specialization for basic types
//--------------------------------------------------------------------------------

template<>
ref class context_node<const char*, System::String^> :
	public context_node_base
{
	private:
		char* _ptr;
	public:
		context_node(__out_z const char*& _to_object, System::String^ _from_object)
		{
			_ptr = NULL;
			if (_from_object == nullptr)
			{
				_to_object =nullptr;
				return;
			}

			size_t _size = details::GetAnsiStringSize(_from_object);

			std::auto_ptr<char> _char_buf(new char[_size]);
			if (_char_buf.get() == NULL)
			{
				throw gcnew System::OutOfMemoryException();
			}

			details::WriteAnsiString(_char_buf.get(), _size, _from_object);

			_ptr = _char_buf.release();
			_to_object = _ptr;
		}

		~context_node()
		{
			this->!context_node();
		}

	protected:
		!context_node()
		{
			if(_ptr != NULL)
				delete [] _ptr;
		}
};


template<>
ref class context_node<const wchar_t*, System::String^> :
	public context_node_base
{
	private:
		System::IntPtr _ip;
	public:
		context_node(__out_z const wchar_t*& _to_object, System::String^ _from_object) 
		{
			_ip = System::Runtime::InteropServices::Marshal::StringToHGlobalUni (_from_object);
			_to_object = static_cast<wchar_t*>(_ip.ToPointer());
		}

		~context_node()
		{
			this->!context_node();
		}

	protected:
		!context_node()
		{
			if(_ip != System::IntPtr::Zero)
				System::Runtime::InteropServices::Marshal::FreeHGlobal(_ip);
		}
};

	} //namespace interop
} //namespace msclr

#pragma warning(pop) // error:4996
#endif // _INC_MSCLR_MARSHAL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\asctime.c ===
/***
*asctime.c - convert date/time structure to ASCII string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Contains asctime() - convert a date/time structure to ASCII string.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <malloc.h>
#include <stddef.h>
#include <tchar.h>
#include <dbgint.h>

#define _ASCBUFSIZE   26
static _TSCHAR buf[_ASCBUFSIZE];

/*
** This prototype must be local to this file since the procedure is static
*/

static _TSCHAR * __cdecl store_dt(_TSCHAR *, int);

static _TSCHAR * __cdecl store_dt (
    REG1 _TSCHAR *p,
    REG2 int val
    )
{
    *p++ = (_TSCHAR)(_T('0') + val / 10);
    *p++ = (_TSCHAR)(_T('0') + val % 10);
    return(p);
}


/***
*errno_t asctime_s(buffer, sizeInChars, time) - convert a structure time to
*ascii string
*
*Purpose:
*   Converts a time stored in a struct tm to a charcater string.
*   The string is always exactly 26 characters of the form
*       Tue May 01 02:34:55 1984\n\0
*
*Entry:
*   struct tm *time - ptr to time structure
*   _TSCHAR *buffer - ptr to output buffer
*   size_t sizeInChars - size of the buffer in characters including sapce for
*                        NULL terminator
*
*Exit:
*   errno_t = 0 success
*       out buffer with time string.
*   errno_t = correct error code
*       out buffer NULL terminated if it is at least 1 character in size
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tasctime_s (
    _TSCHAR *buffer,
    size_t sizeInChars,
    REG1 const struct tm *tb
    )
{
    REG2 _TSCHAR *p = buffer;
    int day, mon;
    int i;

    _VALIDATE_RETURN_ERRCODE(
        ( buffer != NULL ) && ( sizeInChars > 0 ),
        EINVAL
    )

    _RESET_STRING(buffer, sizeInChars);

    _VALIDATE_RETURN_ERRCODE(
        ( sizeInChars >= _ASCBUFSIZE ),
        EINVAL
    )
    _VALIDATE_RETURN_ERRCODE(
        ( tb != NULL ),
        EINVAL
    )
    _VALIDATE_RETURN_ERRCODE(
        ( tb->tm_year >= 0 ),
        EINVAL
    )
    // month 0 based
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_mon  >= 0 ) && ( tb->tm_mon  <= 11 ) ),
        EINVAL
    )
    // hour/min/sec 0 based
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_hour >= 0 ) && ( tb->tm_hour <= 23 ) ),
        EINVAL
    )
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_min  >= 0 ) && ( tb->tm_min  <= 59 ) ),
        EINVAL
    )
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_sec  >= 0 ) && ( tb->tm_sec  <= 59 ) ),
        EINVAL
    )
    // day 1 based
    _VALIDATE_RETURN_ERRCODE(
        (
            ( tb->tm_mday >= 1 ) &&
            (
                // Day is in valid range for the month
                ( ( _days[ tb->tm_mon + 1 ] - _days[ tb->tm_mon ] ) >=
                        tb->tm_mday ) ||
                // Special case for Feb in a leap year
                (
                    ( IS_LEAP_YEAR( tb->tm_year + 1900 ) ) &&
                    ( tb->tm_mon == 1 ) &&
                    ( tb->tm_mday <= 29 )
                )
            )
        ),
        EINVAL
    )
    // week day 0 based
    _VALIDATE_RETURN_ERRCODE(
        ( ( tb->tm_wday >= 0 ) && ( tb->tm_wday <= 6 ) ),
        EINVAL
    )


    /* copy day and month names into the buffer */

    day = tb->tm_wday * 3;      /* index to correct day string */
    mon = tb->tm_mon * 3;       /* index to correct month string */
    for (i=0; i < 3; i++,p++) {
        *p = *(__dnames + day + i);
        *(p+4) = *(__mnames + mon + i);
    }

    *p = _T(' ');           /* blank between day and month */

    p += 4;

    *p++ = _T(' ');
    p = store_dt(p, tb->tm_mday);   /* day of the month (1-31) */
    *p++ = _T(' ');
    p = store_dt(p, tb->tm_hour);   /* hours (0-23) */
    *p++ = _T(':');
    p = store_dt(p, tb->tm_min);    /* minutes (0-59) */
    *p++ = _T(':');
    p = store_dt(p, tb->tm_sec);    /* seconds (0-59) */
    *p++ = _T(' ');
    p = store_dt(p, 19 + (tb->tm_year/100)); /* year (after 1900) */
    p = store_dt(p, tb->tm_year%100);
    *p++ = _T('\n');
    *p = _T('\0');


    return 0;
}

/***
*char *asctime(time) - convert a structure time to ascii string
*
*Purpose:
*   Converts a time stored in a struct tm to a charcater string.
*   The string is always exactly 26 characters of the form
*       Tue May 01 02:34:55 1984\n\0
*
*Entry:
*   struct tm *time - ptr to time structure
*
*Exit:
*   returns pointer to static string with time string.
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tasctime (
    REG1 const struct tm *tb
    )
{
    REG2 _TSCHAR *p = buf;
    errno_t e = 0;

    _TSCHAR *retval;            /* holds retval pointer */
    _ptiddata ptd = _getptd_noexit();

    /* Use per thread buffer area (malloc space, if necessary) */
    if (ptd) {
#ifdef _UNICODE
        if ( (ptd->_wasctimebuf != NULL) || ((ptd->_wasctimebuf =
            (wchar_t *)_calloc_crt(_ASCBUFSIZE, sizeof(wchar_t))) != NULL) )
            p = ptd->_wasctimebuf;
#else  /* _UNICODE */
        if ( (ptd->_asctimebuf != NULL) || ((ptd->_asctimebuf =
            (char *)_calloc_crt(_ASCBUFSIZE, sizeof(char))) != NULL) )
            p = ptd->_asctimebuf;
#endif  /* _UNICODE */
    }

    retval = p;         /* save return value for later */


    e = _tasctime_s( p, _ASCBUFSIZE, tb );
    if ( e != 0 )
    {
        return NULL;
    }

    return (retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\stat.h ===
/***
*sys/stat.h - defines structure used by stat() and fstat()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the structure used by the _stat() and _fstat()
*       routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_STAT
#define _INC_STAT

#if     !defined(_WIN32)
#error ERROR: Only Win32 target supported!
#endif

#include <crtdefs.h>


#ifdef  _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */


/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <sys/types.h>

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else
#define _W64
#endif
#endif

#ifdef  _USE_32BIT_TIME_T
#ifdef  _WIN64
#include <crtwrn.h>
#pragma _CRT_WARNING( _NO_32BIT_TIME_T )
#undef  _USE_32BIT_TIME_T
#endif
#endif

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else
typedef __time64_t time_t;      /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define structure for returning status information */

#ifndef _STAT_DEFINED

struct _stat32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

#if     !__STDC__
/* Non-ANSI names for compatibility */
struct stat {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };

#endif  /* __STDC__ */

struct _stat32i64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

struct _stat64i32 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        _off_t     st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

struct _stat64 {
        _dev_t     st_dev;
        _ino_t     st_ino;
        unsigned short st_mode;
        short      st_nlink;
        short      st_uid;
        short      st_gid;
        _dev_t     st_rdev;
        __int64    st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

/*
 * We have to have same name for structure and the fuction so as to do the
 * macro magic.we need the structure name and function name the same.
 */
#define __stat64    _stat64

#ifdef _USE_32BIT_TIME_T
#define _fstat      _fstat32
#define _fstati64   _fstat32i64
#define _stat       _stat32
#define _stati64    _stat32i64
#define _wstat      _wstat32
#define _wstati64   _wstat32i64

#else
#define _fstat      _fstat64i32
#define _fstati64   _fstat64
#define _stat       _stat64i32
#define _stati64    _stat64
#define _wstat      _wstat64i32
#define _wstati64   _wstat64

#endif

#define _STAT_DEFINED
#endif


#define _S_IFMT         0xF000          /* file type mask */
#define _S_IFDIR        0x4000          /* directory */
#define _S_IFCHR        0x2000          /* character special */
#define _S_IFIFO        0x1000          /* pipe */
#define _S_IFREG        0x8000          /* regular */
#define _S_IREAD        0x0100          /* read permission, owner */
#define _S_IWRITE       0x0080          /* write permission, owner */
#define _S_IEXEC        0x0040          /* execute/search permission, owner */


/* Function prototypes */

_CRTIMP int __cdecl _fstat32(_In_ int _FileDes, _Out_ struct _stat32 * _Stat);
_CRTIMP int __cdecl _stat32(_In_z_ const char * _Name, _Out_ struct _stat32 * _Stat);

_CRTIMP int __cdecl _fstat32i64(_In_ int _FileDes, _Out_ struct _stat32i64 * _Stat);
_CRTIMP int __cdecl _fstat64i32(_In_ int _FileDes, _Out_ struct _stat64i32 * _Stat);
_CRTIMP int __cdecl _fstat64(_In_ int _FileDes, _Out_ struct _stat64 * _Stat);
_CRTIMP int __cdecl _stat32i64(_In_z_ const char * _Name, _Out_ struct _stat32i64 * _Stat);
_CRTIMP int __cdecl _stat64i32(_In_z_ const char * _Name, _Out_ struct _stat64i32 * _Stat);
_CRTIMP int __cdecl _stat64(_In_z_ const char * _Name, _Out_ struct _stat64 * _Stat);

#ifndef _WSTAT_DEFINED

/* also declared in wchar.h */

_CRTIMP int __cdecl _wstat32(_In_z_ const wchar_t * _Name, _Out_ struct _stat32 * _Stat);

_CRTIMP int __cdecl _wstat32i64(_In_z_ const wchar_t * _Name, _Out_ struct _stat32i64 * _Stat);
_CRTIMP int __cdecl _wstat64i32(_In_z_ const wchar_t * _Name, _Out_ struct _stat64i32 * _Stat);
_CRTIMP int __cdecl _wstat64(_In_z_ const wchar_t * _Name, _Out_ struct _stat64 * _Stat);

#define _WSTAT_DEFINED
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

#endif  /* __STDC__ */

/*
 * This file is included for __inlined non stdc functions. i.e. stat and fstat
 */
#if !defined(RC_INVOKED) && !defined(__midl)
#include <sys/stat.inl>
#endif

#ifdef  __cplusplus
}
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_STAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\adjustfd.c ===
/***
*adjustfd.c - define the compiler-helper variable _adjust_fdiv
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The compiler generates references to this variable.  It must be
*       defined in the local module (EXE or DLL) and is actually imported
*       from MSVCRT*.DLL when this module starts up.
*
*******************************************************************************/

#if defined (CRTDLL)

int _adjust_fdiv;

#endif  /* defined (CRTDLL) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\stat.inl ===
/***
*stat.inl - inline definitions for low-level file handling and I/O functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function definitions for the low-level
*       file handling and I/O functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#if !defined(__CRTDECL)
#if defined(_M_CEE_PURE)
#define __CRTDECL
#else
#define __CRTDECL   __cdecl
#endif
#endif

#ifndef _INC_STAT_INL
#define _INC_STAT_INL

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif

#if     !__STDC__

/* Non-ANSI names for compatibility */

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL fstat(int _Desc, struct stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat32) );
    return _fstat32(_Desc,(struct _stat32 *)_Stat);
}
static __inline int __CRTDECL stat(const char * _Filename, struct stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat32) );
    return _stat32(_Filename,(struct _stat32 *)_Stat);
}
#else
static __inline int __CRTDECL fstat(int _Desc, struct stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
    return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);
}
static __inline int __CRTDECL stat(const char * _Filename, struct stat * _Stat)
{
    _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
    return _stat64i32(_Filename,(struct _stat64i32 *)_Stat);
}
#endif /* _USE_32BIT_TIME_T */
#endif /* !__STDC__ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\access.c ===
/***
*access.c - access function
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _access() function which checks on file accessability.
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <oscalls.h>
#include <stdlib.h>
#include <errno.h>
#include <msdos.h>
#include <internal.h>
#include <tchar.h>

/***
*int _access(path, amode) - check whether file can be accessed under mode
*
*Purpose:
*       Checks to see if the specified file exists and can be accessed
*       in the given mode.
*
*Entry:
*       _TSCHAR *path - pathname
*       int amode -     access mode
*                       (0 = exist only, 2 = write, 4 = read, 6 = read/write)
*
*Exit:
*       returns 0 if file has given mode
*       returns -1 and sets errno if file does not have given mode or
*       does not exist
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _taccess (
        const _TSCHAR *path,
        int amode
        )
{
    errno_t e;
    e = _taccess_s(path,amode);

    return e ? -1 : 0 ;
}

/***
*errno_t _access_s(path, amode) - check whether file can be accessed under mode
*
*Purpose:
*       Checks to see if the specified file exists and can be accessed
*       in the given mode.
*
*Entry:
*       _TSCHAR *path - pathname
*       int amode -     access mode
*                       (0 = exist only, 2 = write, 4 = read, 6 = read/write)
*
*Exit:
*       returns 0 if file has given mode
*       returns errno_t for any other errors
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _taccess_s (
        const _TSCHAR *path,
        int amode
        )
{

        DWORD attr;

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE( (path != NULL), EINVAL);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE( ((amode & (~6)) == 0), EINVAL);

        attr = GetFileAttributes((LPTSTR)path);
        if (attr  == 0xffffffff) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return errno;
        }

        if(attr & FILE_ATTRIBUTE_DIRECTORY)
        {
            /* All directories have read & write access */
            return 0;
        }

        /* no error; see if returned premission settings OK */
        if ( (attr & FILE_ATTRIBUTE_READONLY) && (amode & 2) ) {
                /* no write permission on file, return error */
                _doserrno = E_access;
                errno = EACCES;
                return errno;
        }
        else
                /* file exists and has requested permission setting */
                return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\abs.c ===
/***
*abs.c - find absolute value
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines abs() - find the absolute value of an int.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

#pragma function(abs, _abs64)

/***
*int abs(number) - find absolute value of number
*
*Purpose:
*       Returns the absolute value of number (if number >= 0, returns number,
*       else returns -number).
*
*Entry:
*       int number - number to find absolute value of
*
*Exit:
*       returns the aboslute value of number
*
*Exceptions:
*
*******************************************************************************/

int __cdecl abs (
        int number
        )
{
        return( number>=0 ? number : -number );
}
__int64 __cdecl _abs64(
        __int64 num
        )
{
        return (num >=0 ? num : -num);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\atodbl.inl ===
/***
*atodbl.inl - convert a string to a floating point value
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Converts a string to a floating point value.
*
*******************************************************************************/

#ifdef _SAFECRT_IMPL
#define _LOCALE_DATA dec_point
#else  /* _SAFECRT_IMPL */
#define _LOCALE_DATA _loc_update.GetLocaleT()
#endif  /* _SAFECRT_IMPL */

/***
*int _atodbl(_CRT_DOUBLE *, char *) - char string to convert floating point
*
*Purpose:
*   _atodbl like atod converts string to floating point. but this function
*   tries to avoid floating point exceptions by using _CRT_DOUBLE struct
*   which keeps the value in normal register.
*
*Entry:
*   _CRT_DOUBLE * - number to be converted to.
*   char * - string to be converted.
*
*Exit:
*   returns 0, when sucessful or _UNDERFLOW, _OVERFLOW when applicable.
*
*Exceptions:
*
*******************************************************************************/
#ifdef _SAFECRT_IMPL
int  _safecrt_atodbl(_CRT_DOUBLE *d, char *str, char dec_point)
#else  /* _SAFECRT_IMPL */
int  _atodbl_l(_CRT_DOUBLE *d, char *str, _locale_t plocinfo)
#endif  /* _SAFECRT_IMPL */
{
    const char *EndPtr;
    _LDBL12 ld12;
    unsigned int retval1=0;
    INTRNCVT_STATUS retval2=INTRNCVT_OK;

#ifndef _SAFECRT_IMPL
    _LocaleUpdate _loc_update(plocinfo);
#endif  /* _SAFECRT_IMPL */

    /*
     * The return valued of this return is 0, _OVERFLOW or _UNDERFLOW
     * The reason behind this is once we make these routines public,
     * we need some return value that are defined in shiped headers.
     */
    retval1 = __strgtold12_l(&ld12, &EndPtr, str, 0, 0, 0, 0, _LOCALE_DATA);
    retval2 = _ld12tod(&ld12, d);
    if ((retval1 & (SLD_OVERFLOW|SLD_UNDERFLOW))==0) {
        if (retval2 == INTRNCVT_OVERFLOW) {
            return _OVERFLOW;
        } else if (retval2 == INTRNCVT_UNDERFLOW) {
            return _UNDERFLOW;
        }
    } else if (retval1 & SLD_UNDERFLOW){
        return _UNDERFLOW;
    } else if (retval1 & SLD_OVERFLOW) {
        return _OVERFLOW;
    }
    return 0;
}

#ifndef _SAFECRT_IMPL
int  _atodbl(_CRT_DOUBLE *d, char *str)
{
    return _atodbl_l(d, str, NULL);
}
#endif  /* _SAFECRT_IMPL */

#ifdef _SAFECRT_IMPL
int _safecrt_atoldbl(_LDOUBLE *d, char *str, char dec_point)
#else  /* _SAFECRT_IMPL */
int _atoldbl_l(_LDOUBLE *d, char *str, _locale_t plocinfo)
#endif  /* _SAFECRT_IMPL */
{
    const char *EndPtr;
    _LDBL12 ld12;
    unsigned int retval1=0;
    INTRNCVT_STATUS retval2=INTRNCVT_OK;

#ifndef _SAFECRT_IMPL
    _LocaleUpdate _loc_update(plocinfo);
#endif  /* _SAFECRT_IMPL */
    /*
     * The return valued of this return is 0, _OVERFLOW or _UNDERFLOW
     * The reason behind this is once we make these routines public,
     * we need some return value that are defined in shiped headers.
     */
    retval1 = __strgtold12_l(&ld12, &EndPtr, str, 1, 0, 0, 0, _LOCALE_DATA);
    retval2 = _ld12told(&ld12, d);
    if ((retval1 & (SLD_OVERFLOW|SLD_UNDERFLOW))==0) {
        if (retval2 == INTRNCVT_OVERFLOW) {
            return _OVERFLOW;
        } else if (retval2 == INTRNCVT_UNDERFLOW) {
            return _UNDERFLOW;
        }
    } else if (retval1 & SLD_UNDERFLOW){
        return _UNDERFLOW;
    } else if (retval1 & SLD_OVERFLOW) {
        return _OVERFLOW;
    }
    return 0;
}

#ifndef _SAFECRT_IMPL
int _atoldbl(_LDOUBLE *d, char *str)
{
    return _atoldbl_l(d, str, NULL);
}
#endif  /* _SAFECRT_IMPL */

#ifdef _SAFECRT_IMPL
int _safecrt_atoflt(_CRT_FLOAT *d, char *str, char dec_point)
#else  /* _SAFECRT_IMPL */
int _atoflt_l(_CRT_FLOAT *d, char *str, _locale_t plocinfo)
#endif  /* _SAFECRT_IMPL */
{
    const char *EndPtr;
    _LDBL12 ld12;
    unsigned int retval1=0;
    INTRNCVT_STATUS retval2=INTRNCVT_OK;

#ifndef _SAFECRT_IMPL
    _LocaleUpdate _loc_update(plocinfo);
#endif  /* _SAFECRT_IMPL */
    /*
     * The return valued of this return is 0, _OVERFLOW or _UNDERFLOW
     * The reason behind this is once we make these routines public,
     * we need some return value that are defined in shiped headers.
     */
    retval1 = __strgtold12_l(&ld12, &EndPtr, str, 0, 0, 0, 0, _LOCALE_DATA);
    retval2 = _ld12tof(&ld12, d);
    if ((retval1 & (SLD_OVERFLOW|SLD_UNDERFLOW))==0) {
        if (retval2 == INTRNCVT_OVERFLOW) {
            return _OVERFLOW;
        } else if (retval2 == INTRNCVT_UNDERFLOW) {
            return _UNDERFLOW;
        }
    } else if (retval1 & SLD_UNDERFLOW){
        return _UNDERFLOW;
    } else if (retval1 & SLD_OVERFLOW) {
        return _OVERFLOW;
    }
    return 0;
}

#ifndef _SAFECRT_IMPL
int _atoflt(_CRT_FLOAT *d, char *str)
{
    return _atoflt_l(d, str, NULL);
}
#endif  /* _SAFECRT_IMPL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\align.c ===
/***
*align.c - Aligned allocation, reallocation or freeing of memory in the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _aligned_malloc(),
*                   _aligned_realloc(),
*                   _aligned_recalloc(),
*                   _aligned_offset_malloc(),
*                   _aligned_offset_realloc(),
*                   _aligned_offset_recalloc(),
*                   _aligned_free(),
*                   _aligned_msize() functions.
*
*******************************************************************************/

#include <dbgint.h>
#include <crtdbg.h>
#include <errno.h>
#include <string.h>
#include <malloc.h>
#include <stddef.h>
#include <stdlib.h>
#include <internal.h>

#define IS_2_POW_N(X)   (((X)&(X-1)) == 0)
#define PTR_SZ          sizeof(void *)
/***
*
* |1|___6___|2|3|4|_________5__________|_6_|
*
* 1 -> Pointer to start of the block allocated by malloc.
* 2 -> Value of 1.
* 3 -> Gap used to get 1 aligned on sizeof(void *).
* 4 -> Pointer to the start of data block.
* 4+5 -> Data block.
* 6 -> Wasted memory at rear of data block.
* 6 -> Wasted memory.
*
*******************************************************************************/

/***
* void *_aligned_malloc_base(size_t size, size_t alignment)
*       - Get a block of aligned memory from the heap.
*
* Purpose:
*       Allocate of block of aligned memory aligned on the alignment of at least
*       size bytes from the heap and return a pointer to it.
*
* Entry:
*       size_t size - size of block requested
*       size_t alignment - alignment of memory (needs to be a power of 2)
*
* Exit:
*       Success: Pointer to memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_malloc_base(
    size_t size,
    size_t alignment
    )
{
    return _aligned_offset_malloc_base(size, alignment, 0);
}
/***
* void *_aligned_offset_malloc_base(size_t size, size_t alignment, int offset)
*       - Get a block of memory from the heap.
*
* Purpose:
*       Allocate a block of memory which is shifted by offset from alignment of
*       at least size bytes from the heap and return a pointer to it.
*
* Entry:
*       size_t size - size of block of memory
*       size_t alignment - alignment of memory (needs to be a power of 2)
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Success: Pointer to memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/


void * __cdecl _aligned_offset_malloc_base(
    size_t size,
    size_t align,
    size_t offset
    )
{
    uintptr_t ptr, retptr, gap;

    /* validation section */
    _VALIDATE_RETURN(IS_2_POW_N(align), EINVAL, NULL);
    _VALIDATE_RETURN(offset == 0 || offset < size, EINVAL, NULL);

    align = (align > PTR_SZ ? align : PTR_SZ) -1;

    /* gap = number of bytes needed to round up offset to align with PTR_SZ*/
    gap = (0 - offset)&(PTR_SZ -1);

    if ( (ptr =(uintptr_t)malloc(PTR_SZ +gap +align +size)) == (uintptr_t)NULL)
        return NULL;

    retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;
    ((uintptr_t *)(retptr - gap))[-1] = ptr;

    return (void *)retptr;
}

/***
*
* void *_aligned_realloc_base(void * memblock, size_t size, size_t alignment)
*       - Reallocate a block of aligned memory from the heap.
*
* Purpose:
*       Reallocates of block of aligned memory aligned on the alignment of at
*       least size bytes from the heap and return a pointer to it. Size can be
*       either greater or less than the original size of the block.
*       The reallocation may result in moving the block as well as changing the
*       size.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t size - size of block requested
*       size_t alignment - alignment of memory
*
* Exit:
*       Success: Pointer to re-allocated memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_realloc_base(
    void *memblock,
    size_t size,
    size_t alignment
    )
{
    return _aligned_offset_realloc_base(memblock, size, alignment, 0);
}

/***
*
* void *_aligned_recalloc_base(void * memblock, size_t count, size_t size, size_t alignment)
*       - Reallocate a block of aligned memory from the heap.
*
* Purpose:
*       Reallocates of block of aligned memory aligned on the alignment of at
*       least size bytes from the heap and return a pointer to it. Size can be
*       either greater or less than the original size of the block.
*       The reallocation may result in moving the block as well as changing the
*       size.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t count - count of items
*       size_t size - size of item
*       size_t alignment - alignment of memory
*
* Exit:
*       Success: Pointer to re-allocated memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_recalloc_base(
    void *memblock,
    size_t count,
    size_t size,
    size_t alignment
    )
{
    return _aligned_offset_recalloc_base(memblock, count, size, alignment, 0);
}

/***
*
* void *_aligned_offset_realloc_base (void * memblock, size_t size,
*                                     size_t alignment, int offset)
*       - Reallocate a block of memory from the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t size - size of block of memory
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Success: Pointer to re-allocated memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_offset_realloc_base(
    void *memblock,
    size_t size,
    size_t align,
    size_t offset
    )
{
    uintptr_t ptr, retptr, gap, stptr, diff;
    uintptr_t movsz, reqsz;
    int bFree = 0;

    /* special cases */
    if (memblock == NULL)
    {
        return _aligned_offset_malloc_base(size, align, offset);
    }
    if (size == 0)
    {
        _aligned_free_base(memblock);
        return NULL;
    }

    /* validation section */
    _VALIDATE_RETURN(IS_2_POW_N(align), EINVAL, NULL);
    _VALIDATE_RETURN(offset == 0 || offset < size, EINVAL, NULL);

    stptr = (uintptr_t)memblock;

    /* ptr points to the pointer to starting of the memory block */
    stptr = (stptr & ~(PTR_SZ -1)) - PTR_SZ;

    /* ptr is the pointer to the start of memory block*/
    stptr = *((uintptr_t *)stptr);

    align = (align > PTR_SZ ? align : PTR_SZ) -1;
    /* gap = number of bytes needed to round up offset to align with PTR_SZ*/
    gap = (0 -offset)&(PTR_SZ -1);

    diff = (uintptr_t)memblock - stptr;
    /* Mov size is min of the size of data available and sizw requested.
     */
    movsz = _msize((void *)stptr) - ((uintptr_t)memblock - stptr);
    movsz = movsz > size? size: movsz;
    reqsz = PTR_SZ +gap +align +size;

    /* First check if we can expand(reducing or expanding using expand) data
     * safely, ie no data is lost. eg, reducing alignment and keeping size
     * same might result in loss of data at the tail of data block while
     * expanding.
     *
     * If no, use malloc to allocate the new data and move data.
     *
     * If yes, expand and then check if we need to move the data.
     */
    if ((stptr +align +PTR_SZ +gap)<(uintptr_t)memblock)
    {
        if ((ptr = (uintptr_t)malloc(reqsz)) == (uintptr_t) NULL)
            return NULL;
        bFree = 1;
    }
    else
    {
        /* we need to save errno, which can be modified by _expand */
        errno_t save_errno = errno;
        if ((ptr = (uintptr_t)_expand((void *)stptr, reqsz)) == (uintptr_t)NULL)
        {
            errno = save_errno;
            if ((ptr = (uintptr_t)malloc(reqsz)) == (uintptr_t) NULL)
                return NULL;
            bFree = 1;
        }
        else
            stptr = ptr;
    }


    if ( ptr == ((uintptr_t)memblock - diff)
         && !( ((size_t)memblock + gap +offset) & ~(align) ))
    {
        return memblock;
    }

    retptr =((ptr +PTR_SZ +gap +align +offset)&~align)- offset;
    memmove((void *)retptr, (void *)(stptr + diff), movsz);
    if ( bFree)
        free ((void *)stptr);

    ((uintptr_t *)(retptr - gap))[-1] = ptr;
    return (void *)retptr;
}


/***
*
* size_t _aligned_msize_base(void *memblock, size_t align, size_t offset)
*
* Purpose:
*       Computes the size of an aligned block.
*
* Entry:
*       void * memblock - pointer to the aligned block of memory
*
* Exceptions:
*       None. If memblock == NULL 0 is returned.
*
*******************************************************************************/

size_t __cdecl _aligned_msize_base(void *memblock, size_t align, size_t offset)
{
    size_t header_size = 0; /* Size of the header block */
    size_t footer_size = 0; /* Size of the footer block */
    size_t total_size  = 0; /* total size of the allocated block */
    size_t user_size   = 0; /* size of the user block*/
    uintptr_t gap      = 0; /* keep the alignment of the data block */
                             /* after the sizeof(void*) aligned pointer */
                             /* to the beginning of the allocated block */
    uintptr_t ptr      = 0; /* computes the beginning of the allocated block */

    _VALIDATE_RETURN (memblock != NULL, EINVAL, -1);

    /* HEADER SIZE + FOOTER SIZE = GAP + ALIGN + SIZE OF A POINTER*/
    /* HEADER SIZE + USER SIZE + FOOTER SIZE = TOTAL SIZE */

    ptr = (uintptr_t)memblock;            /* ptr points to the start of the aligned memory block */
    ptr = (ptr & ~(PTR_SZ - 1)) - PTR_SZ; /* ptr is one position behind memblock */
                                          /* the value in ptr is the start of the real allocated block */
    ptr = *((uintptr_t *)ptr);            /* after dereference ptr points to the beginning of the allocated block */

    total_size = _msize((void*)ptr);
    header_size = (uintptr_t) memblock - ptr;
    gap = (0 - offset) & (PTR_SZ - 1);
    /* Alignment cannot be less than sizeof(void*) */
    align = (align > PTR_SZ ? align : PTR_SZ) -1;
    footer_size = gap + align + PTR_SZ - header_size;
    user_size = total_size - header_size - footer_size;

    return user_size;
}

/***
*
* void *_aligned_offset_recalloc_base (void * memblock, size_t size, size_t count, size_t alignment, int offset)
*       - Reallocate a block of memory from the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t count - count of items
*       size_t size - size of items
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Success: Pointer to re-allocated memory block
*       Failure: Null, errno is set
*
* Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

void * __cdecl _aligned_offset_recalloc_base(
    void * memblock,
    size_t count,
    size_t size,
    size_t align,
    size_t offset
    )
{
    size_t user_size  = 0;    /* wanted size, passed to aligned realoc */
    size_t start_fill = 0;    /* location where aligned recalloc starts to fill with 0 */
                              /* filling must start from the end of the previous user block */
    void * retptr     = NULL; /* result of aligned recalloc*/
    uintptr_t ptr     = 0;    /* points to the beginning of the allocated block*/

    /* ensure that (size * num) does not overflow */
    if (count > 0)
    {
        _VALIDATE_RETURN((_HEAP_MAXREQ / count) >= size, ENOMEM, NULL);
    }

    user_size = size * count;

    if (memblock != NULL)
    {
        start_fill = _aligned_msize(memblock, align, offset);
    }

    retptr = _aligned_offset_realloc_base(memblock, user_size, align, offset);

    if (retptr != NULL)
    {
        if (start_fill < user_size)
        {
            memset ((char*)retptr + start_fill, 0, user_size - start_fill);
        }
    }
    return retptr;
}

/***
*
* void *_aligned_free_base(void *memblock)
*       - Free the memory which was allocated using _aligned_malloc or
*       _aligned_offset_memory
*
* Purpose:
*       Frees the aligned memory block which was allocated using _aligned_malloc.
*
* Entry:
*       void * memblock - pointer to the block of memory
*
* Exceptions:
*       None. If memblock == NULL we simply return without doing anything.
*
*******************************************************************************/

void  __cdecl _aligned_free_base(void *memblock)
{
    uintptr_t ptr;

    if (memblock == NULL)
        return;

    ptr = (uintptr_t)memblock;

    /* ptr points to the pointer to starting of the memory block */
    ptr = (ptr & ~(PTR_SZ -1)) - PTR_SZ;

    /* ptr is the pointer to the start of memory block*/
    ptr = *((uintptr_t *)ptr);
    free((void *)ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\atof.c ===
/***
*atof.c - convert char string to floating point number
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into a floating point number.
*
*******************************************************************************/

#include <stdlib.h>
#include <math.h>
#include <cruntime.h>
#include <fltintrn.h>
#include <string.h>
#include <ctype.h>
#include <mbctype.h>
#include <locale.h>
#include <internal.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*double atof(nptr) - convert string to floating point number
*
*Purpose:
*       atof recognizes an optional string of whitespace, then
*       an optional sign, then a string of digits optionally
*       containing a decimal point, then an optional e or E followed
*       by an optionally signed integer, and converts all this to
*       to a floating point number.  The first unrecognized
*       character ends the string.
*
*Entry:
*       nptr - pointer to string to convert
*
*Exit:
*       returns floating point value of character representation
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

double __cdecl _atof_l(
        REG1 const char *nptr,
        _locale_t plocinfo
        )
{

        struct _flt fltstruct;      /* temporary structure */
        _LocaleUpdate _loc_update(plocinfo);

        /* validation section */
        _VALIDATE_RETURN(nptr != NULL, EINVAL, 0.0);

        /* scan past leading space/tab characters */

        while ( _isspace_l((int)(unsigned char)*nptr, _loc_update.GetLocaleT()) )
                nptr++;

        /* let _fltin routine do the rest of the work */

        return( *(double *)&(_fltin2( &fltstruct, nptr, (int)strlen(nptr), 0, 0, _loc_update.GetLocaleT())->dval) );
}

double __cdecl atof(
        REG1 const char *nptr
        )
{
    return _atof_l(nptr, NULL);
}

unsigned int __strgtold12
(
    _LDBL12 *pld12,
    const char * *p_end_ptr,
    const char * str,
    int mult12,
    int scale,
    int decpt,
    int implicit_E
)
{
        _LocaleUpdate _loc_update(NULL);

        return __strgtold12_l(pld12, p_end_ptr, str, mult12, scale, decpt, implicit_E, _loc_update.GetLocaleT());
}

unsigned __STRINGTOLD
(
        _LDOUBLE *pld,
        const char  * *p_end_ptr,
        const char  *str,
        int mult12
)
{
        _LocaleUpdate _loc_update(NULL);

        return __STRINGTOLD_L(pld, p_end_ptr, str, mult12, _loc_update.GetLocaleT());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\include\sys\utime.inl ===
/***
*utime.inl - inline definitions for time handling functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definition of the _utime() function.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#if !defined(__CRTDECL)
#if defined(_M_CEE_PURE)
#define __CRTDECL
#else
#define __CRTDECL   __cdecl
#endif
#endif

#ifndef _INC_UTIME_INL
#define _INC_UTIME_INL

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL _utime(const char * _Filename, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf32) );
    return _utime32(_Filename,(struct __utimbuf32 *)_Utimbuf);
}
static __inline int __CRTDECL _futime(int _Desc, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf32) );
    return _futime32(_Desc,(struct __utimbuf32 *)_Utimbuf);
}
static __inline int __CRTDECL _wutime(const wchar_t * _Filename, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf32) );
    return _wutime32(_Filename,(struct __utimbuf32 *)_Utimbuf);
}
#else
static __inline int __CRTDECL _utime(const char * _Filename, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf64) );
    return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);
}
static __inline int __CRTDECL _futime(int _Desc, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf64) );
    return _futime64(_Desc,(struct __utimbuf64 *)_Utimbuf);
}
static __inline int __CRTDECL _wutime(const wchar_t * _Filename, struct _utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct _utimbuf) == sizeof(struct __utimbuf64) );
    return _wutime64(_Filename,(struct __utimbuf64 *)_Utimbuf);
}
#endif /* _USE_32BIT_TIME_T */


#if     !__STDC__

/* Non-ANSI name for compatibility */

#ifdef _USE_32BIT_TIME_T
static __inline int __CRTDECL utime(const char * _Filename, struct utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct utimbuf) == sizeof(struct __utimbuf32) );
    return _utime32(_Filename,(struct __utimbuf32 *)_Utimbuf);
}
#else
static __inline int __CRTDECL utime(const char * _Filename, struct utimbuf * _Utimbuf)
{
    _STATIC_ASSERT( sizeof(struct utimbuf) == sizeof(struct __utimbuf64) );
    return _utime64(_Filename,(struct __utimbuf64 *)_Utimbuf);
}
#endif

#endif /* !__STDC__ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\atox.c ===
/***
*atox.c - atoi and atol conversion
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts a character string into an int or long.
*
*******************************************************************************/

#include <cruntime.h>
#include <mtdll.h>
#include <stdlib.h>
#include <ctype.h>
#include <mbctype.h>
#include <tchar.h>
#include <setlocal.h>
#ifdef _MBCS
#undef _MBCS
#endif  /* _MBCS */
#include <tchar.h>

/***
*long atol(char *nptr) - Convert string to long
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       It behaves exactly like strtol(nptr, NULL, 10).
*       Please refer to the strtol implementation for details.
*
*Entry:
*       nptr = ptr to string to convert
*
*       string format: [whitespace] [sign] [digits]
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               LONG_MAX or LONG_MIN
*               errno == ERANGE
*
*       No digits or other error condition return:
*               0
*
*Exceptions:
*       Input parameters are validated. Refer to the strtox function family.
*
*******************************************************************************/

long __cdecl _tstol(
        const _TCHAR *nptr
        )
{
    return _tcstol(nptr, NULL, 10);
}


long __cdecl _tstol_l(
        const _TCHAR *nptr,
        _locale_t plocinfo
        )
{
    return _tcstol_l(nptr, NULL, 10, plocinfo);
}


/***
*int atoi(char *nptr) - Convert string to int
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       It behaves exactly like (int)strtol(nptr, NULL, 10).
*       Please refer to the strtol implementation for details.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               INT_MAX or INT_MIN
*               errno == ERANGE
*
*       No digits or other error condition return:
*               0
*
*Exceptions:
*       Input parameters are validated. Refer to the strtox function family.
*
*******************************************************************************/

int __cdecl _tstoi(
        const _TCHAR *nptr
        )
{
    return (int)_tstol(nptr);
}

int __cdecl _tstoi_l(
        const _TCHAR *nptr,
        _locale_t plocinfo
        )
{
    return (int)_tstol_l(nptr, plocinfo);
}

#ifndef _NO_INT64

/***
*int atoi64(char *nptr) - Convert string to int64
*
*Purpose:
*       Converts ASCII string pointed to by nptr to binary.
*       It behaves exactly like (int)strtoi64(nptr, NULL, 10).
*       Please refer to the strtoi64 implementation for details.
*
*Entry:
*       nptr = ptr to string to convert
*
*Exit:
*       Good return:
*               result
*
*       Overflow return:
*               _I64_MAX or _I64_MIN
*               errno == ERANGE
*
*       No digits or other error condition return:
*               0
*
*Exceptions:
*       Input parameters are validated. Refer to the strtox function family.
*
*******************************************************************************/

__int64 __cdecl _tstoi64(
        const _TCHAR *nptr
        )
{
    return _tcstoi64(nptr, NULL, 10);
}

__int64 __cdecl _tstoi64_l(
        const _TCHAR *nptr,
        _locale_t plocinfo
        )
{
    return _tcstoi64_l(nptr, NULL, 10, plocinfo);
}

#endif  /* _NO_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\aw_com.c ===
/***
*aw_com.c - W version of GetCommandLine.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Wrapper for GetCommandLineW
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>

/***
*LPWSTR __cdecl __crtGetCommandLineW - Get wide command line.
*
*Purpose:
*       Internal support function.
*
*Entry:
*       VOID
*
*Exit:
*       LPWSTR - pointer to environment block
*
*Exceptions:
*
*******************************************************************************/

LPWSTR __cdecl __crtGetCommandLineW(
        VOID
        )
{
    return GetCommandLineW();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\assert.c ===
/***
*assert.c - Display a message and abort
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <file2.h>
#include <internal.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <string.h>
#include <signal.h>
#include <awint.h>
#include <limits.h>
#include <dbgint.h>

#ifdef NDEBUG
#undef NDEBUG
#endif  /* NDEBUG */
#define _ASSERT_OK
#include <assert.h>


/*
 * assertion format string for use with output to stderr
 */
static TCHAR _assertstring[] = _T("Assertion failed: %s, file %s, line %d\n");

/*      Format of MessageBox for assertions:
*
*       ================= Microsft Visual C++ Debug Library ================
*
*       Assertion Failed!
*
*       Program: c:\test\mytest\foo.exe
*       File: c:\test\mytest\bar.c
*       Line: 69
*
*       Expression: <expression>
*
*       For information on how your program can cause an assertion
*       failure, see the Visual C++ documentation on asserts
*
*       (Press Retry to debug the application - JIT must be enabled)
*
*       ===================================================================
*/

/*
 * assertion string components for message box
 */
#define BOXINTRO    _T("Assertion failed!")
#define PROGINTRO   _T("Program: ")
#define FILEINTRO   _T("File: ")
#define LINEINTRO   _T("Line: ")
#define EXPRINTRO   _T("Expression: ")
#define INFOINTRO   _T("For information on how your program can cause an assertion\n") \
                    _T("failure, see the Visual C++ documentation on asserts")
#define HELPINTRO   _T("(Press Retry to debug the application - JIT must be enabled)")

static TCHAR * dotdotdot = _T("...");
static TCHAR * newline = _T("\n");
static TCHAR * dblnewline = _T("\n\n");

#define DOTDOTDOTSZ 3
#define NEWLINESZ   1
#define DBLNEWLINESZ   2

#define MAXLINELEN  60 /* max length for line in message box */
#define ASSERTBUFSZ (MAXLINELEN * 9) /* 9 lines in message box */

#if defined (_M_IX86)
#define _DbgBreak() __asm { int 3 }
#elif defined (_M_IA64)
void __break(int);
#pragma intrinsic (__break)
#define _DbgBreak() __break(0x80016)
#else  /* defined (_M_IA64) */
#define _DbgBreak() DebugBreak()
#endif  /* defined (_M_IA64) */

#ifdef _UNICODE
void __cdecl _assert (const char *, const char *,unsigned);
#endif  /* _UNICODE */

/***
*_assert() - Display a message and abort
*
*Purpose:
*       The assert macro calls this routine if the assert expression is
*       true.  By placing the assert code in a subroutine instead of within
*       the body of the macro, programs that call assert multiple times will
*       save space.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#ifdef _UNICODE
void __cdecl _wassert (
        const wchar_t *expr,
        const wchar_t *filename,
        unsigned lineno
        )
#else  /* _UNICODE */
void __cdecl _assert (

        const char *expr,
        const char *filename,
        unsigned lineno
        )
#endif  /* _UNICODE */
{
        /*
         * Build the assertion message, then write it out. The exact form
         * depends on whether it is to be written out via stderr or the
         * MessageBox API.
         */
        if ( (_set_error_mode(_REPORT_ERRMODE)== _OUT_TO_STDERR) ||
             ((_set_error_mode(_REPORT_ERRMODE) == _OUT_TO_DEFAULT) &&
              (__app_type == _CONSOLE_APP)) )
        {
#ifdef _UNICODE
            {
                TCHAR assertbuf[ASSERTBUFSZ];
                HANDLE hErr ;
                DWORD written;

                hErr = GetStdHandle(STD_ERROR_HANDLE);

                if(hErr!=INVALID_HANDLE_VALUE && hErr!=NULL)
                {
                    if(swprintf(assertbuf, ASSERTBUFSZ,_assertstring,expr,filename,lineno) >= 0)
                    {
                        if(GetFileType(hErr) == FILE_TYPE_CHAR)
                        {
                            if(WriteConsoleW(hErr, assertbuf, (unsigned long)wcslen(assertbuf), &written, NULL))
                            {
                                abort();
                            }
                        }
                    }
                }
            }

#endif  /* _UNICODE */

            /*
             * Build message and write it out to stderr. It will be of the
             * form:
             *        Assertion failed: <expr>, file <filename>, line <lineno>
             */
            if ( !anybuf(stderr) )
            /*
             * stderr is unused, hence unbuffered, as yet. set it to
             * single character buffering (to avoid a malloc() of a
             * stream buffer).
             */
             (void) setvbuf(stderr, NULL, _IONBF, 0);


            _ftprintf(stderr, _assertstring, expr, filename, lineno);
            fflush(stderr);

        }
        else {
            int nCode;
            TCHAR * pch;
            TCHAR assertbuf[ASSERTBUFSZ];
            TCHAR progname[MAX_PATH + 1];

            /*
             * Line 1: box intro line
             */
            _ERRCHECK(_tcscpy_s( assertbuf, ASSERTBUFSZ, BOXINTRO ));
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dblnewline ));

            /*
             * Line 2: program line
             */
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, PROGINTRO ));

            progname[MAX_PATH] = _T('\0');
            if ( !GetModuleFileName( NULL, progname, MAX_PATH ))
                _ERRCHECK(_tcscpy_s( progname, MAX_PATH + 1, _T("<program name unknown>")));

            pch = (TCHAR *)progname;

            /* sizeof(PROGINTRO) includes the NULL terminator */
            if ( (sizeof(PROGINTRO)/sizeof(TCHAR)) + _tcslen(progname) + NEWLINESZ > MAXLINELEN )
            {
                pch += ((sizeof(PROGINTRO)/sizeof(TCHAR)) + _tcslen(progname) + NEWLINESZ) - MAXLINELEN;
                _ERRCHECK(_tcsncpy_s( pch, (MAX_PATH + 1) - (pch - progname), dotdotdot, DOTDOTDOTSZ ));
            }

            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, pch ));
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, newline ));

            /*
             * Line 3: file line
             */
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, FILEINTRO ));

            /* sizeof(FILEINTRO) includes the NULL terminator */
            if ( (sizeof(FILEINTRO)/sizeof(TCHAR)) + _tcslen(filename) + NEWLINESZ > MAXLINELEN )
            {
                size_t p, len, ffn;

                pch = (TCHAR *) filename;
                ffn = MAXLINELEN - (sizeof(FILEINTRO)/sizeof(TCHAR)) - NEWLINESZ;

                for ( len = _tcslen(filename), p = 1;
                      pch[len - p] != _T('\\') && pch[len - p] != _T('/') && p < len;
                      p++ );

                /* keeping pathname almost 2/3rd of full filename and rest
                 * is filename
                 */
                if ( (ffn - ffn/3) < (len - p) && ffn/3 > p )
                {
                    /* too long. using first part of path and the
                       filename string */
                    _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, pch, ffn - DOTDOTDOTSZ - p ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, pch + len - p ));
                }
                else if ( ffn - ffn/3 > len - p )
                {
                    /* pathname is smaller. keeping full pathname and putting
                     * dotdotdot in the middle of filename
                     */
                    p = p/2;
                    _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, pch, ffn - DOTDOTDOTSZ - p ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, pch + len - p ));
                }
                else
                {
                    /* both are long. using first part of path. using first and
                     * last part of filename.
                     */
                    _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, pch, ffn - ffn/3 - DOTDOTDOTSZ ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
                    _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, pch + len - p, ffn/6 - 1 ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
                    _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, pch + len - (ffn/3 - ffn/6 - 2) ));
                }

            }
            else
                /* plenty of room on the line, just append the filename */
                _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, filename ));

            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, newline ));

            /*
             * Line 4: line line
             */
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, LINEINTRO ));
            _ERRCHECK(_itot_s( lineno, assertbuf + _tcslen(assertbuf), ASSERTBUFSZ - _tcslen(assertbuf), 10 ));
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dblnewline ));

            /*
             * Line 5: message line
             */
            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, EXPRINTRO ));

            /* sizeof(HELPINTRO) includes the NULL terminator */

            if (    _tcslen(assertbuf) +
                    _tcslen(expr) +
                    2*DBLNEWLINESZ +
                    (sizeof(INFOINTRO)/sizeof(TCHAR)) - 1 +
                    (sizeof(HELPINTRO)/sizeof(TCHAR)) > ASSERTBUFSZ )
            {
                _ERRCHECK(_tcsncat_s( assertbuf, ASSERTBUFSZ, expr,
                    ASSERTBUFSZ -
                    (_tcslen(assertbuf) +
                    DOTDOTDOTSZ +
                    2*DBLNEWLINESZ +
                    (sizeof(INFOINTRO)/sizeof(TCHAR))-1 +
                    (sizeof(HELPINTRO)/sizeof(TCHAR)))));
                _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dotdotdot ));
            }
            else
                _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, expr ));

            _ERRCHECK(_tcscat_s( assertbuf, ASSERTBUFSZ, dblnewline ));

            /*
             * Line 6, 7: info line
             */

            _ERRCHECK(_tcscat_s(assertbuf, ASSERTBUFSZ, INFOINTRO));
            _ERRCHECK(_tcscat_s(assertbuf, ASSERTBUFSZ, dblnewline ));

            /*
             * Line 8: help line
             */
            _ERRCHECK(_tcscat_s(assertbuf, ASSERTBUFSZ, HELPINTRO));

            /*
             * Write out via MessageBox
             */

            nCode = __crtMessageBox(assertbuf,
                _T("Microsoft Visual C++ Runtime Library"),
                MB_ABORTRETRYIGNORE|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);

            /* Abort: abort the program */
            if (nCode == IDABORT)
            {
                /* raise abort signal */
                raise(SIGABRT);

                /* We usually won't get here, but it's possible that
                   SIGABRT was ignored.  So exit the program anyway. */

                _exit(3);
            }

            /* Retry: call the debugger */
            if (nCode == IDRETRY)
            {
                _DbgBreak();
                /* return to user code */
                return;
            }

            /* Ignore: continue execution */
            if (nCode == IDIGNORE)
                return;
        }

        abort();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\awint.h ===
/***
*awint.h - internal definitions for A&W Win32 wrapper routines.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains internal definitions/declarations for A&W wrapper functions.
*       Not included in internal.h since windows.h is required for these.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifdef _WIN32

#ifndef _INC_AWINC
#define _INC_AWINC

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#include <sal.h>
#include <windows.h>

/* internal A&W routines */
struct  threadlocaleinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;

int __cdecl __crtCompareStringW
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID     _Locale,
    _In_ DWORD    _DwCmpFlags,
    _In_count_(_CchCount1) LPCWSTR  _LpString1,
    _In_ int      _CchCount1,
    _In_count_(_CchCount2) LPCWSTR  _LpString2,
    _In_ int      _CchCount2,
    _In_ int      _Code_page
);

int __cdecl __crtCompareStringA
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID     _Locale,
    _In_ DWORD    _DwCmpFlags,
    _In_count_(_CchCount1) LPCSTR   _LpString1,
    _In_ int      _CchCount1,
    _In_count_(_CchCount2) LPCSTR   _LpString2,
    _In_ int      _CchCount2,
    _In_ int      _Code_page
);

int __cdecl __crtGetLocaleInfoW
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID    _Locale,
    _In_ LCTYPE  _LCType,
    _Out_opt_cap_(_CchData) LPWSTR  _LpLCData,
    _In_ int     _CchData,
    _In_ int     _Code_page
);

int __cdecl __crtGetLocaleInfoA
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID    _Locale,
    _In_ LCTYPE  _LCType,
    _Out_opt_cap_(_CchData) LPSTR   _LpLCData,
    _In_ int     _CchData,
    _In_ int     _Code_page
);

int __cdecl __crtLCMapStringW
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID _Locale,
    _In_ DWORD _DWMapFlag,
    _In_count_(_CchSrc) LPCWSTR _LpSrcStr ,
    _In_ int _CchSrc,
    _Out_opt_cap_(_CchDest) LPWSTR _LpDestStr,
    _In_ int _CchDest,
    _In_ int _Code_page
);

int __cdecl __crtLCMapStringA
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID _Locale,
        _In_ DWORD _DwMapFlag,
    _In_count_(_CchSrc) LPCSTR _LpSrcStr,
    _In_ int _CchSrc,
    _Out_opt_cap_(_CchDest) LPSTR _LpDestStr,
    _In_ int _CchDest,
    _In_ int _Code_page,
    _In_ BOOL _BError
);

BOOL __cdecl __crtGetStringTypeW
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ DWORD _DWInfoType,
    _In_count_(_CchSrc) LPCWSTR _LpSrcStr,
    _In_ int _CchSrc,
    _Out_ LPWORD _LpCharType,
    _In_ int _Code_page,
    _In_ int _Lcid
);

BOOL __cdecl __crtGetStringTypeA
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ DWORD _DWInfoType,
    _In_ LPCSTR _LpSrcStr,
    _In_ int _CchSrc,
    _Out_ LPWORD _LpCharType,
    _In_ int _Code_page,
    _In_ int _Lcid,
    _In_ BOOL _BError
);

LPVOID __cdecl __crtGetEnvironmentStringsW(VOID);
LPVOID __cdecl __crtGetEnvironmentStringsA(VOID);

LPWSTR __cdecl __crtGetCommandLineW(VOID);

int __cdecl __crtMessageBoxA
(
    _In_ LPCSTR _LpText,
    _In_ LPCSTR _LpCaption,
    _In_ UINT _UType
);

int __cdecl __crtMessageBoxW
(
    _In_ LPCWSTR _LpText,
    _In_ LPCWSTR _LpCaption,
    _In_ UINT _UType
);


int __cdecl __crtCompareStringW_mt
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID     _Locale,
    _In_ DWORD    _DwCmpFlags,
    _In_count_(_CchCount1) LPCWSTR  _LpString1,
    _In_ int      _CchCount1,
    _In_count_(_CchCount2) LPCWSTR  _LpString2,
    _In_ int      _CchCount2,
    _In_ int      _Code_page
);

int __cdecl __crtCompareStringA_mt
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID     _Locale,
    _In_ DWORD    _DwCmpFlags,
    _In_count_(_CchCount1) LPCSTR   _LpString1,
    _In_ int      _CchCount1,
    _In_count_(_CchCount2) LPCSTR   _LpString2,
    _In_ int      _CchCount2,
    _In_ int      _Code_page
);

int __cdecl __crtLCMapStringW_mt
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID _Locale,
    _In_ DWORD _DWMapFlag,
    _In_count_(_CchSrc) LPCWSTR _LpSrcStr ,
    _In_ int _CchSrc,
    _Out_opt_cap_(_CchDest) LPWSTR _LpDestStr,
    _In_ int _CchDest,
    _In_ int _Code_page
);

int __cdecl __crtLCMapStringA_mt
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ LCID _Locale,
        _In_ DWORD _DwMapFlag,
    _In_count_(_CchSrc) LPCSTR _LpSrcStr,
    _In_ int _CchSrc,
    _Out_opt_cap_(_CchDest) LPSTR _LpDestStr,
    _In_ int _CchDest,
    _In_ int _Code_page,
    _In_ BOOL _BError
);

BOOL __cdecl __crtGetStringTypeW_mt
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ DWORD _DWInfoType,
    _In_count_(_CchSrc) LPCWSTR _LpSrcStr,
    _In_ int _CchSrc,
    _Out_ LPWORD _LpCharType,
    _In_ int _Code_page,
    _In_ int _Lcid
);

BOOL __cdecl __crtGetStringTypeA_mt
(
    _In_opt_ _locale_t _Plocinfo,
    _In_ DWORD _DWInfoType,
    _In_ LPCSTR _LpSrcStr,
    _In_ int _CchSrc,
    _Out_ LPWORD _LpCharType,
    _In_ int _Code_page,
    _In_ int _Lcid,
    _In_ BOOL _BError
);

/* internal routines for supporting A&W routines */

int __cdecl __ansicp(_In_ int _Lcid);
char * __cdecl __convertcp
(
    _In_ int _FromCp,
    _In_ int _ToCp,
    _In_count_(_PCchSrc) _Pre_z_ const char * _LpSrcStr,
    _Inout_ int * _PCchSrc,
    _Out_opt_z_cap_(_CchDest) char * _LpDestStr,
    _In_ int _CchDest
);


#define __CRTCOMPARESTRINGW_MT(ploci, Locale, dwCmpFlags,                       \
        lpString1, cchCount1, lpString2, cchCount2, code_page)                  \
    __crtCompareStringW_mt(ploci, Locale, dwCmpFlags,                           \
        lpString1, cchCount1, lpString2, cchCount2, code_page)

#define __CRTCOMPARESTRINGA_MT(ploci, Locale, dwCmpFlags,                       \
        lpString1, cchCount1, lpString2, cchCount2, code_page)                  \
    __crtCompareStringA_mt(ploci, Locale, dwCmpFlags,                           \
        lpString1, cchCount1, lpString2, cchCount2, code_page)


#define __CRTLCMAPSTRINGW_MT(ploci, Locale, dwCmpFlags,                         \
        lpString1, cchCount1, lpString2, cchCount2, code_page)                  \
    __crtLCMapStringW_mt(ploci, Locale, dwCmpFlags,                             \
        lpString1, cchCount1, lpString2, cchCount2, code_page)

#define __CRTLCMAPSTRINGA_MT(ploci, Locale, dwCmpFlags,                         \
        lpString1, cchCount1,lpString2,cchCount2, code_page, bError)            \
    __crtLCMapStringA_mt(ploci, Locale, dwCmpFlags,                             \
        lpString1, cchCount1, lpString2, cchCount2, code_page, bError)


#define __CRTGETSTRINGTYPEW_MT(ploci, dwInfoType, lpSrcStr,                     \
        cchSrc, lpCharType, code_page, lcid)                                    \
    __crtGetStringTypeW_mt(ploci, dwInfoType, lpSrcStr,                         \
        cchSrc, lpCharType, code_page, lcid)

#define __CRTGETSTRINGTYPEA_MT(ploci, dwInfoType, lpSrcStr,                     \
        cchSrc, lpCharType, code_page, lcid, bError)                            \
    __crtGetStringTypeA_mt(ploci, dwInfoType, lpSrcStr,                         \
        cchSrc, lpCharType, code_page, lcid, bError)




#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_AWINC */

#endif  /* _WIN32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\a_loc.c ===
/***
*a_loc.c - A versions of GetLocaleInfo.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either GetLocaleInfoA or GetLocaleInfoW depending on which is
*       available
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl __crtGetLocaleInfoA - Get locale info and return it as an ASCII
*       string
*
*Purpose:
*       Internal support function. Assumes info in ANSI string format. Tries
*       to use NLS API call GetLocaleInfoA if available (Chicago) and uses
*       GetLocaleInfoA if it must (NT). If neither are available it fails and
*       returns 0.
*
*Entry:
*       LCID     Locale      - locale context for the comparison.
*       LCTYPE   LCType      - see NT\Chicago docs
*       LPSTR    lpLCData    - pointer to memory to return data
*       int      cchData     - char (byte) count of buffer (including NULL)
*                              (if 0, lpLCData is not referenced, size needed
*                              is returned)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*Exit:
*       Success: the number of characters copied (including NULL).
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl __crtGetLocaleInfoA_stat(
        _locale_t plocinfo,
        LCID    Locale,
        LCTYPE  LCType,
        LPSTR   lpLCData,
        int     cchData,
        int     code_page
        )
{
    static int f_use = 0;

    /*
     * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
     * Must actually call the function to ensure it's not a stub.
     */

    if (0 == f_use)
    {
        if (0 != GetLocaleInfoW(0, LOCALE_ILANGUAGE, NULL, 0))
            f_use = USE_W;

        else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
            f_use = USE_A;
    }

    /* Use "A" version */

    if (USE_A == f_use || f_use == 0)
    {
        return GetLocaleInfoA(Locale, LCType, lpLCData, cchData);
    }

    /* Use "W" version */

    if (USE_W == f_use)
    {
        int retval = 0;
        int buff_size;
        wchar_t *wbuffer;

        /*
         * Use __lc_codepage for conversion if code_page not specified
         */

        if (0 == code_page)
            code_page = plocinfo->locinfo->lc_codepage;

        /* find out how big buffer needs to be */
        if (0 == (buff_size = GetLocaleInfoW(Locale, LCType, NULL, 0)))
            return 0;

        /* allocate buffer */
        wbuffer = (wchar_t *)_calloca( buff_size, sizeof(wchar_t) );
        if ( wbuffer == NULL ) {
            return 0;
        }

        /* get the info in wide format */
        if (0 == GetLocaleInfoW(Locale, LCType, wbuffer, buff_size))
            goto error_cleanup;

        /* convert from Wide Char to ANSI */
        if (0 == cchData)
        {
            /* convert into local buffer */
            retval = WideCharToMultiByte( code_page,
                                          0,
                                          wbuffer,
                                          -1,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL );
        }
        else {
            /* convert into user buffer */
            retval = WideCharToMultiByte( code_page,
                                          0,
                                          wbuffer,
                                          -1,
                                          lpLCData,
                                          cchData,
                                          NULL,
                                          NULL );
        }

error_cleanup:
        _freea(wbuffer);

        return retval;
    }
    else   /* f_use is neither USE_A nor USE_W */
        return 0;
}

extern "C" int __cdecl __crtGetLocaleInfoA(
        _locale_t plocinfo,
        LCID    Locale,
        LCTYPE  LCType,
        LPSTR   lpLCData,
        int     cchData,
        int     code_page
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return __crtGetLocaleInfoA_stat(
            _loc_update.GetLocaleT(),
            Locale,
            LCType,
            lpLCData,
            cchData,
            code_page
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\atodbl.c ===
/***
*atodbl.c - convert a string to a floating point value
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Converts a string to a floating point value.
*
*******************************************************************************/

#include <fltintrn.h>
#include <float.h>
#include <math.h>
#include <mtdll.h>
#include <internal.h>
#include <setlocal.h>

#include <atodbl.inl>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\binmode.c ===
/***
*binmode.c - set global file mode to binary
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file mode flag to binary.  Linking with this file
*       sets all files to be opened in binary mode.
*
*******************************************************************************/

#define SPECIAL_CRTEXE

#include <cruntime.h>
#include <fcntl.h>
#include <stdlib.h>

/* set default file mode */
int _fmode = _O_BINARY;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\assert.h ===
/***
*assert.h - define the assert macro
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the assert(exp) macro.
*       [ANSI/System V]
*
*       [Public]
*
****/

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */
#ifndef _INTERNAL_IFSTRIP_
#ifndef _ASSERT_OK
#error assert.h not for CRT internal use, use dbgint.h
#endif  /* _ASSERT_OK */
#include <cruntime.h>
#endif  /* _INTERNAL_IFSTRIP_ */
#include <crtdefs.h>

#undef  assert

#ifdef NDEBUG

#define assert(_Expression)     ((void)0)

#else  /* NDEBUG */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

_CRTIMP void __cdecl _wassert(_In_z_ const wchar_t * _Message, _In_z_ const wchar_t *_File, _In_ unsigned _Line);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#define assert(_Expression) (void)( (!!(_Expression)) || (_wassert(_CRT_WIDE(#_Expression), _CRT_WIDE(__FILE__), __LINE__), 0) )

#endif  /* NDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\a_env.c ===
/***
*a_env.c - A version of GetEnvironmentStrings.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Use GetEnvironmentStringsW if available, otherwise use A version.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>

#define USE_W   1
#define USE_A   2

/***
*LPVOID __cdecl __crtGetEnvironmentStringsA - Get normal environment block
*
*Purpose:
*       Internal support function. Since GetEnvironmentStrings returns in OEM
*       and we want ANSI (note that GetEnvironmentVariable returns ANSI!) and
*       SetFileApistoAnsi() does not affect it, we have no choice but to
*       obtain the block in wide character and convert to ANSI.
*
*Entry:
*       VOID
*
*Exit:
*       LPVOID - pointer to environment block
*
*Exceptions:
*
*******************************************************************************/

LPVOID __cdecl __crtGetEnvironmentStringsA(
        VOID
        )
{
        static int f_use = 0;
        wchar_t *wEnv = NULL;
        wchar_t *wTmp;
        char *aEnv = NULL;
        char *aTmp;
        int nSizeW;
        int nSizeA;

        /*
         * Look for 'preferred' flavor. Otherwise use available flavor.
         * Must actually call the function to ensure it's not a stub.
         */

        if ( 0 == f_use )
        {
            if ( NULL != (wEnv = GetEnvironmentStringsW()) )
                f_use = USE_W;

            else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                f_use = USE_A;
        }

        /* Use "W" version */

        if (USE_W == f_use)
        {
            /* obtain wide environment block */
            if ( NULL == wEnv )
                if ( NULL == (wEnv = GetEnvironmentStringsW()) )
                    return NULL;

            /* look for double null that indicates end of block */
            wTmp = wEnv;
            while ( *wTmp != L'\0' ) {
                if ( *++wTmp == L'\0' )
                    wTmp++;
            }

            /* calculate total size of block, including all nulls */
            nSizeW = (int)(wTmp - wEnv + 1);

            /* find out how much space needed for multi-byte environment */
            nSizeA = WideCharToMultiByte(   CP_ACP,
                                            0,
                                            wEnv,
                                            nSizeW,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL );

            /* allocate space for multi-byte string */
            if ( (nSizeA == 0) ||
                 ((aEnv = (char *)_malloc_crt(nSizeA)) == NULL) )
            {
                FreeEnvironmentStringsW( wEnv );
                return NULL;
            }

            /* do the conversion */
            if ( !WideCharToMultiByte(  CP_ACP,
                                        0,
                                        wEnv,
                                        nSizeW,
                                        aEnv,
                                        nSizeA,
                                        NULL,
                                        NULL ) )
            {
                _free_crt( aEnv );
                aEnv = NULL;
            }

            FreeEnvironmentStringsW( wEnv );
            return aEnv;
        }

        /* Use "A" version */

        if (USE_A == f_use || f_use == 0)
        {
            if ( NULL == aEnv )
                if ( NULL == (aEnv = GetEnvironmentStringsA()) )
                    return NULL;

            /* determine how big a buffer is needed */

            aTmp = aEnv;

            while ( *aTmp != '\0' ) {
                if ( *++aTmp == '\0' )
                    aTmp++;
            }

            nSizeA = (int)(aTmp - aEnv + 1);

            if ( NULL == (aTmp = _malloc_crt( nSizeA )) ) {
                FreeEnvironmentStringsA( aEnv );
                return NULL;
            }

            memcpy( aTmp, aEnv, nSizeA );

            FreeEnvironmentStringsA( aEnv );

            return aTmp;
        }

        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\a_map.c ===
/***
*a_map.c - A version of LCMapString.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Use either LCMapStringA or LCMapStringW depending on which is available
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl strncnt - count characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string before
*       null. If null is not found in n chars, then return n.
*
*Entry:
*       const char *string   - start of string
*       int n                - byte count
*
*Exit:
*       returns number of bytes from start of string to
*       null (exclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl strncnt (
        const char *string,
        int cnt
        )
{
        int n = cnt;
        char *cp = (char *)string;

        while (n-- && *cp)
            cp++;

        return cnt - n - 1;
}


/***
*int __cdecl __crtLCMapStringA - Get type information about an ANSI string.
*
*Purpose:
*       Internal support function. Assumes info in ANSI string format. Tries
*       to use NLS API call LCMapStringA if available and uses LCMapStringW
*       if it must. If neither are available it fails and returns 0.
*
*Entry:
*       LCID     Locale      - locale context for the comparison.
*       DWORD    dwMapFlags  - see NT\Chicago docs
*       LPCSTR   lpSrcStr    - pointer to string to be mapped
*       int      cchSrc      - wide char (word) count of input string
*                              (including NULL if any)
*                              (-1 if NULL terminated)
*       LPSTR    lpDestStr   - pointer to memory to store mapping
*       int      cchDest     - char (byte) count of buffer (including NULL)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*       BOOL     bError      - TRUE if MB_ERR_INVALID_CHARS set on call to
*                              MultiByteToWideChar when GetStringTypeW used.
*
*Exit:
*       Success: number of chars written to lpDestStr (including NULL)
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl __crtLCMapStringA_stat(
        _locale_t plocinfo,
        LCID     Locale,
        DWORD    dwMapFlags,
        LPCSTR   lpSrcStr,
        int      cchSrc,
        LPSTR    lpDestStr,
        int      cchDest,
        int      code_page,
        BOOL     bError
        )
{
    static int f_use = 0;

    /*
     * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
     * Must actually call the function to ensure it's not a stub.
     * (Always try wide version first so WinNT can process codepage correctly.)
     */

    if (0 == f_use) {
        if (0 != LCMapStringW(0, LCMAP_LOWERCASE, L"\0", 1, NULL, 0))
            f_use = USE_W;
        else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
            f_use = USE_A;
    }

    /*
     * LCMapString will map past NULL. Must find NULL if in string
     * before cchSrc characters.
     */
    if (cchSrc > 0) {
        int cchSrcCnt = strncnt(lpSrcStr, cchSrc);
        /*
         * Include NULL in cchSrc if lpSrcStr terminated within cchSrc bytes.
         */
        if (cchSrcCnt < cchSrc) {
            cchSrc = cchSrcCnt + 1;
        } else {
            cchSrc = cchSrcCnt;
        }
    }

    /* Use "A" version */

    if (USE_A == f_use || f_use == 0) {
        char *cbuffer = NULL;
        char *cbuffer1 = NULL;
        char *cbuffer2 = NULL;
        int ret;
        int AnsiCP;
        int buff_size;

        if (0 == Locale)
            Locale = plocinfo->locinfo->lc_handle[LC_CTYPE];
        if (0 == code_page)
            code_page = plocinfo->locinfo->lc_codepage;

        if ( -1 == (AnsiCP = __ansicp(Locale)))
            return FALSE;
        /* LCMapStringA uses ANSI code page to map the string. Check if
         * codepage is ansi, if not convert the input string to ansi
         * codepage then map to a temporary string and then convert temp
         * string to DestStr.
         */
        if ( AnsiCP != code_page)
        {
            cbuffer = __convertcp(code_page, AnsiCP, lpSrcStr, &cchSrc, NULL, 0);
            if (cbuffer == NULL)
                return FALSE;
            lpSrcStr = cbuffer;
            if (0 == (buff_size = LCMapStringA( Locale,
                                                dwMapFlags,
                                                lpSrcStr,
                                                cchSrc,
                                                0,
                                                0 )))
            {
                ret = FALSE;
                goto cleanupA;
            }
            cbuffer1 = (char *)_calloca(sizeof(char), buff_size);
            if ( cbuffer1 == NULL ) {
                ret = FALSE;
                goto cleanupA;
            }
            memset(cbuffer1, 0, sizeof(char) * buff_size);

            if (0 == (buff_size = LCMapStringA( Locale,
                                                dwMapFlags,
                                                lpSrcStr,
                                                cchSrc,
                                                cbuffer1,
                                                buff_size)))
            {
                ret = FALSE;
            } else {
                if ( NULL == (cbuffer2 = __convertcp(AnsiCP,
                                         code_page,
                                         cbuffer1,
                                         &buff_size,
                                         lpDestStr,
                                         cchDest)))
                    ret = FALSE;
                else
                    ret = buff_size;

            }
cleanupA:
            if ( cbuffer1 != NULL )
                _freea(cbuffer1);
        } else
        {
            ret = LCMapStringA( Locale, dwMapFlags, lpSrcStr, cchSrc,
                                lpDestStr, cchDest );
        }
        if ( cbuffer != NULL)
            _free_crt(cbuffer);
        if ( (cbuffer2 != NULL) && (lpDestStr != cbuffer2))
             _free_crt(cbuffer2);
        return ret;
    }

    /* Use "W" version */

    if (USE_W == f_use)
    {
        int retval = 0;
        int inbuff_size;
        int outbuff_size;
        wchar_t *inwbuffer = NULL;
        wchar_t *outwbuffer = NULL;

        /*
         * Convert string and return the requested information. Note that
         * we are converting to a wide string so there is not a
         * one-to-one correspondence between number of wide chars in the
         * input string and the number of *bytes* in the buffer. However,
         * there had *better be* a one-to-one correspondence between the
         * number of wide characters and the number of multibyte characters
         * or the resulting mapped string will be worthless to the user.
         */

        /*
         * Use __lc_codepage for conversion if code_page not specified
         */

        if (0 == code_page)
            code_page = plocinfo->locinfo->lc_codepage;

        /* find out how big a buffer we need (includes NULL if any) */
        if ( 0 == (inbuff_size =
                   MultiByteToWideChar( code_page,
                                        bError ? MB_PRECOMPOSED |
                                            MB_ERR_INVALID_CHARS :
                                            MB_PRECOMPOSED,
                                        lpSrcStr,
                                        cchSrc,
                                        NULL,
                                        0 )) )
            return 0;

        /* allocate enough space for wide chars */
        inwbuffer = (wchar_t *)_calloca( inbuff_size, sizeof(wchar_t) );
        if ( inwbuffer == NULL ) {
            return 0;
        }

        /* do the conversion */
        if ( 0 == MultiByteToWideChar( code_page,
                                       MB_PRECOMPOSED,
                                       lpSrcStr,
                                       cchSrc,
                                       inwbuffer,
                                       inbuff_size) )
            goto error_cleanup;

        /* get size required for string mapping */
        if ( 0 == (retval = LCMapStringW( Locale,
                                          dwMapFlags,
                                          inwbuffer,
                                          inbuff_size,
                                          NULL,
                                          0 )) )
            goto error_cleanup;

        if (dwMapFlags & LCMAP_SORTKEY) {
            /* retval is size in BYTES */

            if (0 != cchDest) {

                if (retval > cchDest)
                    goto error_cleanup;

                /* do string mapping */
                if ( 0 == LCMapStringW( Locale,
                                        dwMapFlags,
                                        inwbuffer,
                                        inbuff_size,
                                        (LPWSTR)lpDestStr,
                                        cchDest ) )
                    goto error_cleanup;
            }
        }
        else {
            /* retval is size in wide chars */

            outbuff_size = retval;

            /* allocate enough space for wide chars (includes NULL if any) */
            outwbuffer = (wchar_t *)_calloca( outbuff_size, sizeof(wchar_t) );
            if ( outwbuffer == NULL ) {
                goto error_cleanup;
            }

            /* do string mapping */
            if ( 0 == LCMapStringW( Locale,
                                    dwMapFlags,
                                    inwbuffer,
                                    inbuff_size,
                                    outwbuffer,
                                    outbuff_size ) )
                goto error_cleanup;

            if (0 == cchDest) {
                /* get size required */
                if ( 0 == (retval =
                           WideCharToMultiByte( code_page,
                                                0,
                                                outwbuffer,
                                                outbuff_size,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL )) )
                    goto error_cleanup;
            }
            else {
                /* convert mapping */
                if ( 0 == (retval =
                           WideCharToMultiByte( code_page,
                                                0,
                                                outwbuffer,
                                                outbuff_size,
                                                lpDestStr,
                                                cchDest,
                                                NULL,
                                                NULL )) )
                    goto error_cleanup;
            }
        }

error_cleanup:
        if ( outwbuffer != NULL )
            _freea(outwbuffer);

        _freea(inwbuffer);

        return retval;
    }
    else   /* f_use is neither USE_A nor USE_W */
        return 0;
}

extern "C" int __cdecl __crtLCMapStringA(
        _locale_t plocinfo,
        LCID     Locale,
        DWORD    dwMapFlags,
        LPCSTR   lpSrcStr,
        int      cchSrc,
        LPSTR    lpDestStr,
        int      cchDest,
        int      code_page,
        BOOL     bError
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return __crtLCMapStringA_stat(
            _loc_update.GetLocaleT(),
            Locale,
            dwMapFlags,
            lpSrcStr,
            cchSrc,
            lpDestStr,
            cchDest,
            code_page,
            bError
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\atonexit.c ===
/***
*atonexit.c - _onexit/atexit for using the MSVCRT* model of C run-time
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       atexit and _onexit are handled differently for EXE's and DLL's linked
*       with MSVCRT.LIB to call MSVCRT*.DLL.  Specifically, the _onexit/atexit
*       list for DLL's must be maintained on a per-module basis and must be
*       processed at DLL process detach .  For EXE's the atexit/_onexit list
*       should be maintained by MSVCRT*.DLL and processed at process exit.
*
*******************************************************************************/

/*
 * SPECIAL BUILD MACRO! Note that atonexit.c is linked in with the client's
 * code. It does not go into crtdll.dll! Therefore, it must be built under
 * the _DLL switch (like user code) and CRTDLL must be undefined.
 */

#undef  CRTDLL
#ifndef _DLL
#define _DLL
#endif  /* _DLL */

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <stdlib.h>
#include <mtdll.h>

/*
 * Pointers to beginning and end of the table of function pointers manipulated
 * by _onexit()/atexit().  If this module is an EXE, _onexitbegin will be -1.
 * Otherwise _onexitbegin will point to a block of malloc-ed memory used to
 * maintain the DLL module's private onexit list of terminator routines.
 * NOTE - the pointers are stored encoded.
 */

_PVFV *__onexitbegin;
_PVFV *__onexitend;


/***
*_onexit, atexit - calls to _onexit & atexit in MSVCRT*.DLL
*
*Purpose:
*       A DLL linked with MSVCRT.LIB must not call the standard _onexit or
*       atexit exported from MSVCRT*.DLL, but an EXE linked with MSVCRT.LIB
*       will call the standard versions of those two routines.  The standard
*       names are not exported from MSVCRT*.DLL, but the _imp__* names are,
*       so this module can just invoke the standard versions if linked into
*       an EXE module (indicated by __onexitbegin == -1).  If this module is
*       linked into a DLL (indicated by __onexitbegin != -1), it will call a
*       helper routine in MSVCRT*.DLL called __dllonexit to manage the DLL's
*       private onexit list.
*
*Entry:
*       Same as the regular versions of _onexit, atexit.
*
*Exit:
*       Same as the regular versions of _onexit, atexit.
*
*Exceptions:
*
*******************************************************************************/

extern _onexit_t __dllonexit(_onexit_t, _PVFV**, _PVFV**);

#ifdef _M_IX86
extern _onexit_t (__cdecl *_imp___onexit)(_onexit_t func);
#else  /* _M_IX86 */
extern _onexit_t (__cdecl *__imp__onexit)(_onexit_t func);
#endif  /* _M_IX86 */

_onexit_t __cdecl _onexit (
        _onexit_t func
        )
{
        _PVFV * onexitbegin;
        _PVFV * onexitend;
        _onexit_t retval;

        onexitbegin = (_PVFV *)_decode_pointer(__onexitbegin);

        if (onexitbegin == (_PVFV *)-1)
        {
            /* EXE */
#ifdef _M_IX86
            return (*_imp___onexit)(func);
#else  /* _M_IX86 */
            return (*__imp__onexit)(func);
#endif  /* _M_IX86 */
        }

        /*
         * Note that we decode/encode the onexit array pointers on the
         * client side, not the CRT DLL side, to ease backwards compatibility.
         * That means we have to take a lock on this side, making the lock
         * found in __dllonexit redundant.
         */

        _lock(_EXIT_LOCK1);

        __try
        {
            onexitbegin = (_PVFV *)_decode_pointer(__onexitbegin);
            onexitend   = (_PVFV *)_decode_pointer(__onexitend);

            retval = __dllonexit((_onexit_t)_encode_pointer(func), &onexitbegin, &onexitend);

            __onexitbegin = (_PVFV *)_encode_pointer(onexitbegin);
            __onexitend   = (_PVFV *)_encode_pointer(onexitend);
        }
        __finally
        {
            _unlock(_EXIT_LOCK1);
        }

        return retval;
}

int __cdecl atexit (
        _PVFV func
        )
{
        return (_onexit((_onexit_t)func) == NULL) ? -1 : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\a_str.c ===
/***
*a_str.c - A version of GetStringType.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either GetStringTypeA or GetStringTypeW depending on which is
*       unstubbed.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <awint.h>
#include <mtdll.h>
#include <setlocal.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl __crtGetStringTypeA - Get type information about an ANSI string.
*
*Purpose:
*       Internal support function. Assumes info in ANSI string format. Tries
*       to use NLS API call GetStringTypeA if available and uses GetStringTypeW
*       if it must. If neither are available it fails and returns FALSE.
*
*Entry:
*       DWORD    dwInfoType  - see NT\Chicago docs
*       LPCSTR   lpSrcStr    - char (byte) string for which character types
*                              are requested
*       int      cchSrc      - char (byte) count of lpSrcStr (including NULL
*                              if any)
*       LPWORD   lpCharType  - word array to receive character type information
*                              (must be twice the size of lpSrcStr)
*       int      code_page   - for MB/WC conversion. If 0, use __lc_codepage
*       int      lcid        - for A call, specify LCID, If 0, use
*                              __lc_handle[LC_CTYPE].
*       BOOL     bError      - TRUE if MB_ERR_INVALID_CHARS set on call to
*                              MultiByteToWideChar when GetStringTypeW used.
*
*Exit:
*       Success: TRUE
*       Failure: FALSE
*
*Exceptions:
*
*******************************************************************************/

static BOOL __cdecl __crtGetStringTypeA_stat(
        _locale_t plocinfo,
        DWORD    dwInfoType,
        LPCSTR   lpSrcStr,
        int      cchSrc,
        LPWORD   lpCharType,
        int      code_page,
        int      lcid,
        BOOL     bError
        )
{
    static int f_use = 0;

    /*
     * Look for unstubbed 'preferred' flavor. Otherwise use available
     * flavor. Must actually call the function to ensure it's not a stub.
     * (Always try wide version first so WinNT can process codepage correctly.)
     */

    if (0 == f_use)
    {
        unsigned short dummy;

        if (0 != GetStringTypeW(CT_CTYPE1, L"\0", 1, &dummy))
            f_use = USE_W;

        else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
            f_use = USE_A;
    }

    /* Use "A" version */

    if (USE_A == f_use || f_use == 0)
    {
        char *cbuffer = NULL;
        int ret;
        int AnsiCP;

        if (0 == lcid)
            lcid = plocinfo->locinfo->lc_handle[LC_CTYPE];
        if (0 == code_page)
            code_page = plocinfo->locinfo->lc_codepage;

        if ( -1 == (AnsiCP = __ansicp(lcid)))
            return FALSE;
        /* If current code-page is not ansi code page, convert it to ansi code page
         * as GetStringTypeA uses ansi code page to find the strig type.
         */
        if ( AnsiCP != code_page)
        {
            cbuffer = __convertcp(code_page, AnsiCP, lpSrcStr, &cchSrc, NULL, 0);
            if (cbuffer == NULL)
                return FALSE;
            lpSrcStr = cbuffer;
        }

        ret = GetStringTypeA(lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        if ( cbuffer != NULL)
            _free_crt(cbuffer);
        return ret;
    }

    /* Use "W" version */

    if (USE_W == f_use)
    {
        int retval1;
        int buff_size;
        wchar_t *wbuffer;
        BOOL retval2 = FALSE;

        /*
         * Convert string and return the requested information. Note that
         * we are converting to a wide character string so there is not a
         * one-to-one correspondence between number of multibyte chars in the
         * input string and the number of wide chars in the buffer. However,
         * there had *better be* a one-to-one correspondence between the
         * number of multibyte characters and the number of WORDs in the
         * return buffer.
         */

        /*
         * Use __lc_codepage for conversion if code_page not specified
         */

        if (0 == code_page)
            code_page = plocinfo->locinfo->lc_codepage;

        /* find out how big a buffer we need */
        if ( 0 == (buff_size = MultiByteToWideChar( code_page,
                                                    bError ?
                                                        MB_PRECOMPOSED |
                                                        MB_ERR_INVALID_CHARS
                                                        : MB_PRECOMPOSED,
                                                    lpSrcStr,
                                                    cchSrc,
                                                    NULL,
                                                    0 )) )
            return FALSE;

        /* allocate enough space for wide chars */
        wbuffer = (wchar_t *)_calloca( sizeof(wchar_t), buff_size );
        if ( wbuffer == NULL ) {
            return FALSE;
        }
        (void)memset( wbuffer, 0, sizeof(wchar_t) * buff_size );

        /* do the conversion */
        if ( 0 != (retval1 = MultiByteToWideChar( code_page,
                                                 MB_PRECOMPOSED,
                                                 lpSrcStr,
                                                 cchSrc,
                                                 wbuffer,
                                                 buff_size )) )
            /* obtain result */
            retval2 = GetStringTypeW( dwInfoType,
                                      wbuffer,
                                      retval1,
                                      lpCharType );

        _freea(wbuffer);

        return retval2;
    }
    else   /* f_use is neither USE_A nor USE_W */
        return FALSE;
}

extern "C" BOOL __cdecl __crtGetStringTypeA(
        _locale_t plocinfo,
        DWORD    dwInfoType,
        LPCSTR   lpSrcStr,
        int      cchSrc,
        LPWORD   lpCharType,
        int      code_page,
        int      lcid,
        BOOL     bError
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return __crtGetStringTypeA_stat(
            _loc_update.GetLocaleT(),
            dwInfoType,
            lpSrcStr,
            cchSrc,
            lpCharType,
            code_page,
            lcid,
            bError
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\bswap.c ===
/***
*rotl.c - rotate an unsigned integer left
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _byteswap() - performs a byteswap on an unsigned integer.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma function(_byteswap_ulong, _byteswap_uint64, _byteswap_ushort)
#endif  /* _MSC_VER */

/***
*unsigned long _byteswap_ulong(i) - long byteswap
*
*Purpose:
*       Performs a byte swap on an unsigned integer.
*
*Entry:
*       unsigned long i:        value to swap
*
*Exit:
*       returns swaped
*
*Exceptions:
*       None.
*
*******************************************************************************/


unsigned long __cdecl _byteswap_ulong(unsigned long i)
{
    unsigned int j;
    j =  (i << 24);
    j += (i <<  8) & 0x00FF0000;
    j += (i >>  8) & 0x0000FF00;
    j += (i >> 24);
    return j;
}

unsigned short __cdecl _byteswap_ushort(unsigned short i)
{
    unsigned short j;
    j =  (i << 8) ;
    j += (i >> 8) ;
    return j;
}

unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 i)
{
    unsigned __int64 j;
    j =  (i << 56);
    j += (i << 40)&0x00FF000000000000;
    j += (i << 24)&0x0000FF0000000000;
    j += (i <<  8)&0x000000FF00000000;
    j += (i >>  8)&0x00000000FF000000;
    j += (i >> 24)&0x0000000000FF0000;
    j += (i >> 40)&0x000000000000FF00;
    j += (i >> 56);
    return j;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\calloc_impl.c ===
/***
*calloc_impl.c - implementation of _calloc_impl
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _calloc_impl() function.
*
*******************************************************************************/

#ifdef WINHEAP

#include <malloc.h>
#include <string.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>

void * __cdecl _calloc_impl (size_t num, size_t size, int * errno_tmp)
{
        size_t  size_orig;
        void *  pvReturn;

        /* ensure that (size * num) does not overflow */
        if (num > 0)
        {
            _VALIDATE_RETURN((_HEAP_MAXREQ / num) >= size, ENOMEM, NULL);
        }
        size_orig = size = size * num;


        /* force nonzero size */
        if (size == 0)
            size = 1;

        for (;;)
        {
            pvReturn = NULL;

            if (size <= _HEAP_MAXREQ)
            {
#ifndef _WIN64
                if ( __active_heap == __V6_HEAP )
                {
                    /* round up to nearest paragraph */
                    if (size <= _HEAP_MAXREQ)
                        size = (size + BYTES_PER_PARA - 1) & ~(BYTES_PER_PARA - 1);

                    if ( size_orig <= __sbh_threshold )
                    {
                        //  Allocate the block from the small-block heap and
                        //  initialize it with zeros.
                        _mlock( _HEAP_LOCK );
                        __try {
                        pvReturn = __sbh_alloc_block((int)size_orig);
                        }
                        __finally {
                            _munlock( _HEAP_LOCK );
                        }

                        if (pvReturn != NULL)
                            memset(pvReturn, 0, size_orig);
                    }
                }
#ifdef CRTDLL
                else if ( __active_heap == __V5_HEAP )
                {
                    /* round up to nearest paragraph */
                    if (size <= _HEAP_MAXREQ)
                        size = (size + BYTES_PER_PARA - 1) & ~(BYTES_PER_PARA - 1);

                    if ( size <= __old_sbh_threshold )
                    {
                        //  Allocate the block from the small-block heap and
                        //  initialize it with zeros.
                        _mlock(_HEAP_LOCK);
                        __try {
                        pvReturn = __old_sbh_alloc_block(size >> _OLD_PARASHIFT);
                        }
                        __finally {
                            _munlock(_HEAP_LOCK);
                        }
                        if ( pvReturn != NULL )
                            memset(pvReturn, 0, size);
                    }
                }
#endif  /* CRTDLL */
#endif  /* _WIN64 */

                if (pvReturn == NULL)
                    pvReturn = HeapAlloc(_crtheap, HEAP_ZERO_MEMORY, size);
            }

            if (pvReturn || _newmode == 0)
            {
                RTCCALLBACK(_RTC_Allocate_hook, (pvReturn, size_orig, 0));
                if (pvReturn == NULL)
                {
                    if ( errno_tmp )
                        *errno_tmp = ENOMEM;
                }
                return pvReturn;
            }

            /* call installed new handler */
            if (!_callnewh(size))
            {
                if ( errno_tmp )
                    *errno_tmp = ENOMEM;
                return NULL;
            }

            /* new handler was successful -- try to allocate again */
        }

}
#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cerr.cpp ===
// cerr -- initialize standard error stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)
static std::_Init_locks  initlocks;

_STD_BEGIN
		// OBJECT DECLARATIONS

__PURE_APPDOMAIN_GLOBAL static filebuf ferr(_cpp_stderr);
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream cerr(&ferr);
_MRTIMP2 ostream& __cdecl _Cerr_func()
{
    return cerr;
}

		// INITIALIZATION CODE
struct _Init_cerr
	{	// ensures that cerr is initialized
	__CLR_OR_THIS_CALL _Init_cerr()
		{	// initialize cerr
		_Ptr_cerr = &cerr;
		cerr.tie(_Ptr_cout);
		cerr.setf(ios_base::unitbuf);
		}
	};
__PURE_APPDOMAIN_GLOBAL static _Init_cerr init_cerr;

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cfinfo.c ===
This file is going to be deleted.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\a_cmp.c ===
/***
*a_cmp.c - A version of CompareString.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Use either CompareStringA or CompareStringW depending on which is
*       available
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <dbgint.h>
#include <stdlib.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <awint.h>
#include <mtdll.h>
#include <setlocal.h>

#define USE_W   1
#define USE_A   2

/***
*int __cdecl strncnt - count characters in a string, up to n.
*
*Purpose:
*       Internal local support function. Counts characters in string before NULL.
*       If NULL not found in n chars, then return n.
*
*Entry:
*       const char *string   - start of string
*       int n                - byte count
*
*Exit:
*       returns number of bytes from start of string to
*       NULL (exclusive), up to n.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl strncnt (
        const char *string,
        int cnt
        )
{
        int n = cnt;
        char *cp = (char *)string;

        while (n-- && *cp)
            cp++;

        return cnt - n - 1;
}

/***
*int __cdecl __crtCompareStringA - Get type information about an ANSI string.
*
*Purpose:
*       Internal support function. Assumes info in ANSI string format. Tries
*       to use NLS API call CompareStringA if available and uses CompareStringW
*       if it must. If neither are available it fails and returns 0.
*
*Entry:
*       LCID    Locale      - locale context for the comparison.
*       DWORD   dwCmpFlags  - see NT\Chicago docs
*       LPCSTR  lpStringn   - multibyte string to be compared
*       int     cchCountn   - char (byte) count (NOT including NULL)
*                             (-1 if NULL terminated)
*       int     code_page   - for MB/WC conversion. If 0, use __lc_codepage
*
*Exit:
*       Success: 1 - if lpString1 <  lpString2
*                2 - if lpString1 == lpString2
*                3 - if lpString1 >  lpString2
*       Failure: 0
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl __crtCompareStringA_stat(
        _locale_t plocinfo,
        LCID     Locale,
        DWORD    dwCmpFlags,
        LPCSTR   lpString1,
        int      cchCount1,
        LPCSTR   lpString2,
        int      cchCount2,
        int      code_page
        )
{
    static int f_use = 0;
    /*
     * Look for unstubbed 'preferred' flavor. Otherwise use available flavor.
     * Must actually call the function to ensure it's not a stub.
     * (Always try wide version first so WinNT can process codepage correctly.)
     */

    if (0 == f_use)
    {
        if (0 != CompareStringW(0, 0, L"\0", 1, L"\0", 1))
            f_use = USE_W;

        else if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
            f_use = USE_A;
    }

    /*
     * CompareString will compare past NULL. Must find NULL if in string
     * before cchCountn chars.
     */

    if (cchCount1 > 0)
        cchCount1 = strncnt(lpString1, cchCount1);
    else if ( cchCount1 < -1 )
        return FALSE;
    if (cchCount2 > 0)
        cchCount2 = strncnt(lpString2, cchCount2);
    else if ( cchCount2 < -1 )
        return FALSE;


    /* Use "A" version */

    if (USE_A == f_use || f_use == 0)
    {
        char *cbuffer1 = NULL;
        char *cbuffer2 = NULL;
        int ret;
        int AnsiCP;

        if (0 == Locale)
            Locale = plocinfo->locinfo->lc_handle[LC_CTYPE];
        if (0 == code_page)
            code_page = plocinfo->locinfo->lc_codepage;

        if ( -1 == (AnsiCP = __ansicp(Locale)))
            return FALSE;
        /* If current CP is not ANSI CP for the given Locale, convert the
         * string from current CP to ansi CP as CompareStringA uses
         * ANSI CP to compare strings.
         */
        if ( AnsiCP != code_page)
        {
            cbuffer1 = __convertcp(code_page,
                                   AnsiCP,
                                   lpString1,
                                   &cchCount1,
                                   NULL,
                                   0);
            if (cbuffer1 == NULL)
                return FALSE;
            cbuffer2 = __convertcp(code_page,
                                   AnsiCP,
                                   lpString2,
                                   &cchCount2,
                                   NULL,
                                   0);
            if (cbuffer2 == NULL)
            {
                _free_crt(cbuffer1);
                return FALSE;
            }
            lpString1 = cbuffer1;
            lpString2 = cbuffer2;
        }

        ret = CompareStringA( Locale,
                              dwCmpFlags,
                              lpString1,
                              cchCount1,
                              lpString2,
                              cchCount2 );
        if ( cbuffer1 != NULL)
        {
            _free_crt(cbuffer1);
            _free_crt(cbuffer2);
        }
        return ret;
    }

    /* Use "W" version */

    if (USE_W == f_use)
    {
        int buff_size1;
        int buff_size2;
        wchar_t *wbuffer1;
        wchar_t *wbuffer2;
        int retcode = 0;

        /*
         * Use __lc_codepage for conversion if code_page not specified
         */

        if (0 == code_page)
            code_page = plocinfo->locinfo->lc_codepage;

        /*
         * Special case: at least one count is zero
         */

        if (!cchCount1 || !cchCount2)
        {
            unsigned char *cp;  // char pointer
            CPINFO lpCPInfo;    // struct for use with GetCPInfo

            /* both strings zero */
            if (cchCount1 == cchCount2)
                return 2;

            /* string 1 greater */
            if (cchCount2 > 1)
                return 1;

            /* string 2 greater */
            if (cchCount1 > 1)
                return 3;

            /*
             * one has zero count, the other has a count of one
             * - if the one count is a naked lead byte, the strings are equal
             * - otherwise it is a single character and they are unequal
             */

            if (GetCPInfo(code_page, &lpCPInfo) == FALSE)
                return 0;

            _ASSERTE(cchCount1==0 && cchCount2==1 || cchCount1==1 && cchCount2==0);

            /* string 1 has count of 1 */
            if (cchCount1 > 0)
            {
                if (lpCPInfo.MaxCharSize < 2)
                    return 3;

                for ( cp = (unsigned char *)lpCPInfo.LeadByte ;
                      cp[0] && cp[1] ;
                      cp += 2 )
                    if ( (*(unsigned char *)lpString1 >= cp[0]) &&
                         (*(unsigned char *)lpString1 <= cp[1]) )
                        return 2;

                return 3;
            }

            /* string 2 has count of 1 */
            if (cchCount2 > 0)
            {
                if (lpCPInfo.MaxCharSize < 2)
                return 1;

                for ( cp = (unsigned char *)lpCPInfo.LeadByte ;
                      cp[0] && cp[1] ;
                      cp += 2 )
                    if ( (*(unsigned char *)lpString2 >= cp[0]) &&
                         (*(unsigned char *)lpString2 <= cp[1]) )
                        return 2;

                return 1;
            }
        }

        /*
         * Convert strings and return the requested information.
         */

        /* find out how big a buffer we need (includes NULL if any) */
        if ( 0 == (buff_size1 = MultiByteToWideChar( code_page,
                                                     MB_PRECOMPOSED |
                                                        MB_ERR_INVALID_CHARS,
                                                     lpString1,
                                                     cchCount1,
                                                     NULL,
                                                     0 )) )
            return 0;

        /* allocate enough space for chars */
        wbuffer1 = (wchar_t *)_calloca( buff_size1, sizeof(wchar_t) );
        if ( wbuffer1 == NULL ) {
            return 0;
        }

        /* do the conversion */
        if ( 0 == MultiByteToWideChar( code_page,
                                       MB_PRECOMPOSED,
                                       lpString1,
                                       cchCount1,
                                       wbuffer1,
                                       buff_size1 ) )
            goto error_cleanup;

        /* find out how big a buffer we need (includes NULL if any) */
        if ( 0 == (buff_size2 = MultiByteToWideChar( code_page,
                                                     MB_PRECOMPOSED |
                                                        MB_ERR_INVALID_CHARS,
                                                     lpString2,
                                                     cchCount2,
                                                     NULL,
                                                     0 )) )
            goto error_cleanup;

        /* allocate enough space for chars */
        wbuffer2 = (wchar_t *)_calloca( buff_size2, sizeof(wchar_t) );
        if ( wbuffer2 == NULL ) {
            goto error_cleanup;
        }

        /* do the conversion */
        if ( 0 != MultiByteToWideChar( code_page,
                                       MB_PRECOMPOSED,
                                       lpString2,
                                       cchCount2,
                                       wbuffer2,
                                       buff_size2 ) )
            retcode = CompareStringW( Locale,
                                      dwCmpFlags,
                                      wbuffer1,
                                      buff_size1,
                                      wbuffer2,
                                      buff_size2 );

        _freea(wbuffer2);

error_cleanup:
        _freea(wbuffer1);

        return retcode;
    }
    else   /* f_use is neither USE_A nor USE_W */
        return 0;
}

extern "C" int __cdecl __crtCompareStringA(
        _locale_t plocinfo,
        LCID     Locale,
        DWORD    dwCmpFlags,
        LPCSTR   lpString1,
        int      cchCount1,
        LPCSTR   lpString2,
        int      cchCount2,
        int      code_page
        )
{
    _LocaleUpdate _loc_update(plocinfo);

    return __crtCompareStringA_stat(
            _loc_update.GetLocaleT(),
            Locale,
            dwCmpFlags,
            lpString1,
            cchCount1,
            lpString2,
            cchCount2,
            code_page
            );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\bsearch.c ===
/***
*bsearch.c - do a binary search
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines bsearch() - do a binary search an an array
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <search.h>
#include <internal.h>

#if defined (_M_CEE)
#define __fileDECL  __clrcall
#else  /* defined (_M_CEE) */
#define __fileDECL  __cdecl
#endif  /* defined (_M_CEE) */
/***
*char *bsearch() - do a binary search on an array
*
*Purpose:
*   Does a binary search of a sorted array for a key.
*
*Entry:
*   const char *key    - key to search for
*   const char *base   - base of sorted array to search
*   unsigned int num   - number of elements in array
*   unsigned int width - number of bytes per element
*   int (*compare)()   - pointer to function that compares two array
*           elements, returning neg when #1 < #2, pos when #1 > #2, and
*           0 when they are equal. Function is passed pointers to two
*           array elements.
*
*Exit:
*   if key is found:
*           returns pointer to occurrence of key in array
*   if key is not found:
*           returns NULL
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#define __COMPARE(context, p1, p2) (*compare)(context, p1, p2)
#else  /* __USE_CONTEXT */
#define __COMPARE(context, p1, p2) (*compare)(p1, p2)
#endif  /* __USE_CONTEXT */

#if !defined (_M_CEE)
_CRTIMP
#endif  /* !defined (_M_CEE) */

#ifdef __USE_CONTEXT
void * __fileDECL bsearch_s (
    REG4 const void *key,
    const void *base,
    size_t num,
    size_t width,
    int (__fileDECL *compare)(void *, const void *, const void *),
    void *context
    )
#else  /* __USE_CONTEXT */
void * __fileDECL bsearch (
    REG4 const void *key,
    const void *base,
    size_t num,
    size_t width,
    int (__fileDECL *compare)(const void *, const void *)
    )
#endif  /* __USE_CONTEXT */
{
    REG1 char *lo = (char *)base;
    REG2 char *hi = (char *)base + (num - 1) * width;
    REG3 char *mid;
    size_t half;
    int result;

    /* validation section */
    _VALIDATE_RETURN(base != NULL || num == 0, EINVAL, NULL);
    _VALIDATE_RETURN(width > 0, EINVAL, NULL);
    _VALIDATE_RETURN(compare != NULL, EINVAL, NULL);

        /*
        We allow a NULL key here because it breaks some older code and because we do not dereference
        this ourselves so we can't be sure that it's a problem for the comparison function
        */

    while (lo <= hi)
    {
        if ((half = num / 2) != 0)
        {
            mid = lo + (num & 1 ? half : (half - 1)) * width;
            if (!(result = __COMPARE(context, key, mid)))
                return(mid);
            else if (result < 0)
            {
                hi = mid - width;
                num = num & 1 ? half : half-1;
            }
            else
            {
                lo = mid + width;
                num = half;
            }
        }
        else if (num)
            return (__COMPARE(context, key, lo) ? NULL : lo);
        else
            break;
    }

    return NULL;
}

#undef __fileDECL
#undef __COMPARE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cgets.c ===
/***
*cgets.c - buffered keyboard input
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cgets() - read a string directly from console
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <conio.h>
#include <stdlib.h>
#include <internal.h>
#include <internal_securecrt.h>

/*
 * mask to clear the bits required to be 0 in the handle state passed to
 * DOSSETFHSTATE.
 */
#define FHSTATEMASK 0xffd07888

/*
 * declaration for console handle
 */

extern intptr_t _coninpfh;

/*
 * Use of the following buffer variables is primarily for syncronizing with
 * _cgets_s. _cget_s fills the MBCS buffer and if the user passes in single
 * character buffer and the unicode character is not converted to single byte
 * MBC, then _cget_s should buffer that character so that next call to
 * _cgetws_s can return the same character.
 */
extern wchar_t __console_wchar_buffer;
extern int __console_wchar_buffer_used;

/***
*errno_t _cgets_s(string, sizeInBytes, pSizeRead) - read string from console
*
*Purpose:
*       Reads a string from the console. Always null-terminate the buffer.
*
*Entry:
*       char *string - place to store read string
*       sizeInBytes  - max length to read
*       pSizeRead - sets the max read in this
*
*Exit:
*       returns error code or 0 if no error occurs
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _cgets_s (
        char *string,
        size_t sizeInBytes,
        size_t * pSizeRead
        )
{
        errno_t err = 0;
        size_t available;

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((string != NULL), EINVAL);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((sizeInBytes > 0), EINVAL);
        _RESET_STRING(string, sizeInBytes);

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((pSizeRead != NULL), EINVAL);

        available = sizeInBytes - 1;

        _mlock(_CONIO_LOCK);            /* lock the console */
        __TRY
            /*
             * The implementation of cgets is slightly tricky. The reason being,
             * the code page for console is different from the CRT code page.
             * What this means is the program may interpret character
             * differently from it's acctual value. To fix this, what we really
             * want to do is read the input as unicode string and then convert
             * it to proper MBCS representation.
             *
             * This fix this we are really converting from Unicode to MBCS.
             * This adds performance problem as we may endup doing this
             * character by character. The basic problem here is that we have
             * no way to know how many UNICODE characters will be needed to fit
             * them in given size of MBCS buffer. To fix this issue we will be
             * converting one Unicode character at a time to MBCS. This makes
             * this slow, but then this is already console input,
             */
            *pSizeRead = 0;
            do {
                wchar_t wchar_buff[2];
                size_t sizeRead=0;
                if ((err = _cgetws_s(wchar_buff, _countof(wchar_buff), &sizeRead)) == 0)
                {
                    int sizeConverted = 0;
                    if (wchar_buff[0] == L'\0')
                    {
                        break;
                    }
                    else if ((err = wctomb_s(&sizeConverted, string, available, wchar_buff[0])) == 0)
                    {
                        string += sizeConverted;
                        (*pSizeRead) += sizeConverted;
                        available -= sizeConverted;
                    }
                    else
                    {
                        /*
                         * Put the wchar back to the buffer so that the
                         * unutilized wchar is still in the stream.
                         */
                        __console_wchar_buffer = wchar_buff[0];
                        __console_wchar_buffer_used = 1;
                        break;
                    }
                }
                else
                {
                    break;
                }
            } while (available > 0);

        __FINALLY
            _munlock(_CONIO_LOCK);          /* unlock the console */
        __END_TRY_FINALLY

        *string++ = '\0';

        if (err != 0)
        {
            errno = err;
        }
        return err;
}

/***
*char *_cgets(string) - read string from console
*
*Purpose:
*       Reads a string from the console via ReadConsole on a cooked console
*       handle.  string[0] must contain the maximum length of the
*       string.  Returns pointer to str[2].
*
*       NOTE: _cgets() does NOT check the pushback character buffer (i.e.,
*       _chbuf).  Thus, _cgets() will not return any character that is
*       pushed back by the _ungetch() call.
*
*Entry:
*       char *string - place to store read string, str[0] = max length.
*
*Exit:
*       returns pointer to str[2], where the string starts.
*       returns NULL if error occurs
*
*Exceptions:
*
*******************************************************************************/
char * __cdecl _cgets (
        char *string)
{
        size_t sizeInBytes;
        size_t sizeRead = 0;
        errno_t err;

        _VALIDATE_CLEAR_OSSERR_RETURN((string != NULL), EINVAL, NULL);

        sizeInBytes = (size_t)string[0];

        err = _cgets_s(string + 2, sizeInBytes, &sizeRead);

        string[1] = (char)(sizeRead);

        if (err != 0)
        {
            return NULL;
        }

        return string + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\charmax.c ===
/***
*charmax.c - definition of _charmax variable
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _charmax
*
*       According to ANSI, certain elements of the lconv structure must be
*       initialized to CHAR_MAX and the value of CHAR_MAX changes when
*       the user compiles -J.  To reflect this change in the lconv structure,
*       we initialize the structure to SCHAR_MAX, and when any of the users
*       modules are compiled -J, the structure is updated.
*
*       Note that this is not done for DLLs linked to the CRT DLL, because
*       we do not want such DLLs to override the -J setting for an EXE
*       linked to the CRT DLL.  See comments in crtexe.c.
*
*       Files involved:
*
*       locale.h - if -J, generates an unresolved external to _charmax
*       charmax.c - defines _charmax and sets to UCHAR_MAX (255), places
*               _lconv_init in startup initializer table if pulled in by -J
*       lconv.c - initializes lconv structure to SCHAR_MAX (127),
*               since libraries built without -J
*       lcnvinit.c - sets lconv members to 25.
**
*******************************************************************************/

#ifdef _MSC_VER

#include <sect_attribs.h>
#include <internal.h>

int __lconv_init(void);

int _charmax = 255;

_CRTALLOC(".CRT$XIC") static _PIFV pinit = __lconv_init;

#endif  /* _MSC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\bsearch_s.c ===
/***
*bsearch_s.c - do a binary search
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   defines bsearch_s() - do a binary search an an array
*
*******************************************************************************/

/***
*char *bsearch_s() - do a binary search on an array
*
*Purpose:
*   Does a binary search of a sorted array for a key.
*
*Entry:
*   const char *key    - key to search for
*   const char *base   - base of sorted array to search
*   unsigned int num   - number of elements in array
*   unsigned int width - number of bytes per element
*   int (*compare)()   - pointer to function that compares two array
*           elements, returning neg when #1 < #2, pos when #1 > #2, and
*           0 when they are equal. Function is passed pointers to two
*           array elements, together with a pointer to a context.
*   void *context - pointer to the context in which the function is
*           called. This context is passed to the comparison function.
*
*Exit:
*   if key is found:
*           returns pointer to occurrence of key in array
*   if key is not found:
*           returns NULL
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

#ifdef __USE_CONTEXT
#error __USE_CONTEXT should be undefined
#endif  /* __USE_CONTEXT */

#define __USE_CONTEXT
#include "bsearch.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\chdir.c ===
/***
*chdir.c - change directory
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _chdir() function - change current directory.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <direct.h>
#include <stdlib.h>
#include <tchar.h>
#include <malloc.h>
#include <dbgint.h>

/***
*int _chdir(path) - change current directory
*
*Purpose:
*       Changes the current working directory to that given in path.
*
*Entry:
*       _TSCHAR *path - directory to change to
*
*Exit:
*       returns 0 if successful,
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tchdir (
        const _TSCHAR *path
        )
{
        _TSCHAR env_var[4];
        _TSCHAR abspath[MAX_PATH+1];
        _TSCHAR *apath=abspath;
        int memfree=0;
        int r;
        int retval = -1;

        _VALIDATE_CLEAR_OSSERR_RETURN((path != NULL), EINVAL, -1);

        if ( SetCurrentDirectory((LPTSTR)path) )
        {
            /*
             * If the new current directory path is NOT a UNC path, we must
             * update the OS environment variable specifying the current
             * directory for what is now current drive. To do this, get the
             * full current directory, build the environment variable string
             * and call SetEnvironmentVariable(). We need to do this because
             * SetCurrentDirectory does not (i.e., does not update the
             * current-directory-on-drive environment variables) and other
             * functions (fullpath, spawn, etc) need them to be set.
             *
             * If associated with a 'drive', the current directory should
             * have the form of the example below:
             *
             *  D:\nt\private\mytests
             *
             * so that the environment variable should be of the form:
             *
             *  =D:=D:\nt\private\mytests
             *
             */
            r = GetCurrentDirectory(MAX_PATH+1,(LPTSTR)apath);
            if (r > MAX_PATH) {
                if ((apath = (_TSCHAR *)_calloc_crt(r+1, sizeof(_TSCHAR))) == NULL) {
                    r = 0;
                } else {
                    memfree = 1;
                }

                if (r)
                    r = GetCurrentDirectory(r+1,(LPTSTR)apath);
            }
            if (r)
            {
                /*
                 * check if it is a UNC name, just return if is
                 */
                if ( ((apath[0] == _T('\\')) || (apath[0] == _T('/'))) &&
                     (apath[0] == apath[1]) )
                    retval = 0;
                else {

                    env_var[0] = _T('=');
                    env_var[1] = (_TSCHAR) _totupper((_TUCHAR)apath[0]);
                    env_var[2] = _T(':');
                    env_var[3] = _T('\0');

                    if ( SetEnvironmentVariable(env_var, apath) )
                        retval = 0;
                }
            }
        }

        if( 0 != retval )
        {
            /* error occured -- map error code */
            _dosmaperr( GetLastError() );
        }

        if (memfree)
            _free_crt(apath);
        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\chmod.c ===
/***
*chmod.c - change file attributes
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _chmod() - change file attributes
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tchar.h>

/***
*int _chmod(path, mode) - change file mode
*
*Purpose:
*       Changes file mode permission setting to that specified in
*       mode.  The only XENIX mode bit supported is user write.
*
*Entry:
*       _TSCHAR *path - file name
*       int mode - mode to change to
*
*Exit:
*       returns 0 if successful
*       returns -1 and sets errno if not successful
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tchmod (
        const _TSCHAR *path,
        int mode
        )
{
        DWORD attr;

        _VALIDATE_CLEAR_OSSERR_RETURN((path != NULL), EINVAL, -1);

        attr = GetFileAttributes((LPTSTR)path);
        if (attr  == 0xffffffff) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        if (mode & _S_IWRITE) {
                /* clear read only bit */
                attr &= ~FILE_ATTRIBUTE_READONLY;
        }
        else {
                /* set read only bit */
                attr |= FILE_ATTRIBUTE_READONLY;
        }

        /* set new attribute */
        if (!SetFileAttributes((LPTSTR)path, attr)) {
                /* error occured -- map error code and return */
                _dosmaperr(GetLastError());
                return -1;
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cinitexe.c ===
/***
*cinitexe.c - C Run-Time Startup Initialization
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Do C++ initialization segment declarations for the EXE in CRT DLL
*       model
*
*Notes:
*       The C++ initializers will exist in the user EXE's data segment
*       so the special segments to contain them must be in the user EXE.
*
*******************************************************************************/

#include <stdio.h>
#include <internal.h>
#include <sect_attribs.h>

_CRTALLOC(".CRT$XIA") _PVFV __xi_a[] = { NULL };

_CRTALLOC(".CRT$XIZ") _PVFV __xi_z[] = { NULL };

_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };

_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };


#pragma comment(linker, "/merge:.CRT=.rdata")

#pragma comment(linker, "/defaultlib:kernel32.lib")

#pragma comment(linker, "/disallowlib:libc.lib")
#pragma comment(linker, "/disallowlib:libcd.lib")
#pragma comment(linker, "/disallowlib:libcmt.lib")
#pragma comment(linker, "/disallowlib:libcmtd.lib")
#ifdef _DEBUG
#pragma comment(linker, "/disallowlib:msvcrt.lib")
#else  /* _DEBUG */
#pragma comment(linker, "/disallowlib:msvcrtd.lib")
#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\clock.c ===
/***
*clock.c - Contains the clock runtime
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The clock runtime returns the processor time used by
*       the current process.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <time.h>

#include <internal.h>
#include <sys\timeb.h>
#include <sys\types.h>



int __cdecl __inittime(void);

#ifdef _MSC_VER

_CRTALLOC(".CRT$XIC") static _PIFV pinit = __inittime;

#endif  /* _MSC_VER */

static unsigned __int64 start_tics;

/***
*clock_t clock() - Return the processor time used by this process.
*
*Purpose:
*       This routine calculates how much time the calling process
*       has used.  At startup time, startup calls __inittime which stores
*       the initial time.  The clock routine calculates the difference
*       between the current time and the initial time.
*
*       Clock must reference _cinitime so that _cinitim.asm gets linked in.
*       That routine, in turn, puts __inittime in the startup initialization
*       routine table.
*
*Entry:
*       No parameters.
*       itime is a static structure of type timeb.
*
*Exit:
*       If successful, clock returns the number of CLK_TCKs (milliseconds)
*       that have elapsed.  If unsuccessful, clock returns -1.
*
*Exceptions:
*       None.
*
*******************************************************************************/

clock_t __cdecl clock (
        void
        )
{
        unsigned __int64 current_tics;
        FILETIME ct;

        GetSystemTimeAsFileTime( &ct );

        current_tics = (unsigned __int64)ct.dwLowDateTime +
                       (((unsigned __int64)ct.dwHighDateTime) << 32);

        /* calculate the elapsed number of 100 nanosecond units */
        current_tics -= start_tics;

        /* return number of elapsed milliseconds */
        return (clock_t)(current_tics / 10000);
}

/***
*int __inittime() - Initialize the time location
*
*Purpose:
*       This routine stores the time of the process startup.
*       It is only linked in if the user issues a clock runtime call.
*
*Entry:
*       No arguments.
*
*Exit:
*       Returns 0 to indicate no error.
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl __inittime (
        void
        )
{
        FILETIME st;

        GetSystemTimeAsFileTime( &st );

        start_tics = (unsigned __int64)st.dwLowDateTime +
                     (((unsigned __int64)st.dwHighDateTime) << 32);

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\clearerr.c ===
/***
*clearerr.c - clear error and eof flags
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines clearerr() - clear error and eof flags from a stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <mtdll.h>
#include <internal.h>
#include <msdos.h>

/***
*errno_t clearerr(stream) - clear error and eof flags on a stream
*
*Purpose:
*       Resets the error and eof indicators for a stream to 0
*
*Entry:
*       FILE *stream - stream to set indicators on
*
*Exit:
*       0 on success, Otherwise error code
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl clearerr_s (FILE * stream)
{
        _VALIDATE_RETURN_ERRCODE((stream != NULL), EINVAL);

        _lock_str(stream);
        __try {

        /* Clear stdio level flags */
        stream->_flag &= ~(_IOERR|_IOEOF);

        /* Clear lowio level flags */

        _osfile_safe(_fileno(stream)) &= ~(FEOFLAG);

        }
        __finally {
            _unlock_str(stream);
        }
    return 0;
}

/***
*void clearerr(stream) - clear error and eof flags on a stream
*
*Purpose:
*       Resets the error and eof indicators for a stream to 0
*
*Entry:
*       FILE *stream - stream to set indicators on
*
*Exit:
*       No return value.
*       changes the _flag field of the FILE struct.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl clearerr (
        FILE *stream
        )
{
    clearerr_s(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\clog.cpp ===
// clog -- initialize standard log stream
#include <fstream>
#include <iostream>

#ifndef MRTDLL
#pragma warning(disable: 4074)
#pragma init_seg(compiler)
static std::_Init_locks  initlocks;
#endif

_STD_BEGIN
		// OBJECT DECLARATIONS

__PURE_APPDOMAIN_GLOBAL static filebuf flog(_cpp_stderr);
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream clog(&flog);
_MRTIMP2 ostream& __cdecl _Clog_func()
{
    return clog;
}

		// INITIALIZATION CODE
struct _Init_clog
	{	// ensures that clog is initialized
	__CLR_OR_THIS_CALL _Init_clog()
		{	// initialize clog
		_Ptr_clog = &clog;
		clog.tie(_Ptr_cout);
		}
	};
__PURE_APPDOMAIN_GLOBAL static _Init_clog init_clog;

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\calloc.c ===
/***
*calloc.c - allocate storage for an array from the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the calloc() function.
*
*******************************************************************************/

#ifdef WINHEAP

#include <malloc.h>
#include <string.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>

void * __cdecl _calloc_impl (size_t num, size_t size, int * errno_tmp);

/***
*void *calloc(size_t num, size_t size) - allocate storage for an array from
*       the heap
*
*Purpose:
*       Allocate a block of memory from heap big enough for an array of num
*       elements of size bytes each, initialize all bytes in the block to 0
*       and return a pointer to it.
*
*Entry:
*       size_t num  - number of elements in the array
*       size_t size - size of each element
*
*Exit:
*       Success:  void pointer to allocated block
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _calloc_base (size_t num, size_t size)
{
    int errno_tmp = 0;
    void * pv = _calloc_impl(num, size, &errno_tmp);

    if ( pv == NULL && errno_tmp != 0 && _errno())
    {
        errno = errno_tmp; // recall, #define errno *_errno()
    }
    return pv;
}

#else  /* WINHEAP */


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>
#include <dbgint.h>

/***
*void *calloc(size_t num, size_t size) - allocate storage for an array from
*       the heap
*
*Purpose:
*       Allocate a block of memory from heap big enough for an array of num
*       elements of size bytes each, initialize all bytes in the block to 0
*       and return a pointer to it.
*
*Entry:
*       size_t num  - number of elements in the array
*       size_t size - size of each element
*
*Exit:
*       Success:  void pointer to allocated block block
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl _calloc_base (
        size_t num,
        size_t size
        )
{
        void *retp;
        REG1 size_t *startptr;
        REG2 size_t *lastptr;

        size_t  size_orig;

        /* ensure that (size * num) does not overflow */
        if (num > 0)
        {
            return NULL;
        }
        size_orig = size * num;
        /* try to malloc the requested space
         */
        retp = _malloc_base(size_orig);

        /* if malloc() succeeded, initialize the allocated space to zeros.
         * note the assumptions that the size of the allocation block is an
         * integral number of sizeof(size_t) bytes and that (size_t)0 is
         * sizeof(size_t) bytes of 0.
         */
        if ( retp != NULL ) {
            size*=num;
            startptr = (size_t *)retp;
            lastptr = startptr + ((size + sizeof(size_t) - 1) /
            sizeof(size_t));
            while ( startptr < lastptr )
                *(startptr++) = 0;
        }

        return retp;
}

#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cenvarg.c ===
/***
*cenvarg.c - set up environment, command line blocks
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cenvarg() - setup environment/command line blocks
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <errno.h>
#include <msdos.h>
#include <stdlib.h>
#include <stdarg.h>
#include <internal.h>
#include <string.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>

/* local tchar */
#ifdef WPRFLAG
#define _tenvptr    _wenvptr
#else  /* WPRFLAG */
#define _tenvptr    _aenvptr
#endif  /* WPRFLAG */

/***
*int _cenvarg(argv, envp, argblk, envblk, name) - set up cmd line/environ
*
*Purpose:
*       Set up the block forms of  the environment and the command line.
*       If "envp" is null, "_environ" is used instead.
*
*Entry:
*       _TSCHAR **argv   - argument vector
*       _TSCHAR **envp   - environment vector
*       _TSCHAR **argblk - pointer to pointer set to malloc'ed space for args
*       _TSCHAR **envblk - pointer to pointer set to malloc'ed space for env
*       _TSCHAR *name    - name of program being invoked
*
*Exit:
*       returns 0 if ok, -1 if fails
*       stores through argblk and envblk
*       (calls malloc)
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
int __cdecl _wcenvarg (
#else  /* WPRFLAG */
int __cdecl _cenvarg (
#endif  /* WPRFLAG */
        const _TSCHAR * const *argv,
        const _TSCHAR * const *envp,
        _TSCHAR **argblk,
        _TSCHAR **envblk,
        const _TSCHAR *name
        )
{
        REG1 const _TSCHAR * const *vp;
        REG2 unsigned tmp;
        REG3 _TSCHAR *cptr;
        unsigned arg_len;
        unsigned env_len;
        int cfi_len;            /* counts the number of file handles in CFI */
        int retval = 0;

        /*
         * Null environment pointer "envp" means use global variable,
         * "_environ"
         */

        int cwd_start;
        int cwd_end;            /* length of "cwd" strings in environment */

        _TSCHAR envpfx[] = _T("SystemRoot");
        _TSCHAR *envbuf = NULL;
        int envsize = 0;
        int defined = 0;

        /*
         * Allocate space for command line string
         *  tmp counts the number of bytes in the command line string
         *      including spaces between arguments
         *  An empty string is special -- 2 bytes
         */

        for (vp = argv, tmp = 2; *vp; tmp += (unsigned int)_tcslen(*vp++) + 1) ;

        arg_len = tmp;

        /*
         * Allocate space for the command line plus 2 null bytes
         */

        if ( (*argblk = _calloc_crt(tmp, sizeof(_TSCHAR))) == NULL)
        {
                *envblk = NULL;
                errno = ENOMEM;
                _doserrno = E_nomem;
                return(-1);
        }

        if (_ERRCHECK_EINVAL(_tdupenv_s_crt(&envbuf, NULL, envpfx)) != 0)
        {
                retval = -1;
                goto error;
        }

        envsize = (int)_tcslen(envpfx) + 2;
        if (envbuf != NULL)
        {
            envsize += (int)_tcslen(envbuf);
        }

        /*
         * Allocate space for environment strings
         *  tmp counts the number of bytes in the environment strings
         *      including nulls between strings
         *  Also add "_C_FILE_INFO=" string
         */
        if (envp)
                for (vp = envp, tmp = 2; *vp; tmp += (unsigned int)_tcslen(*vp++) + 1) ;

        /*
         * The _osfile and _osfhnd arrays are passed as binary data in
         * dospawn.c
         */
        cfi_len = 0;    /* no _C_FILE_INFO */

        if (!envp)
                *envblk = NULL;
        else {
                /*
                 * Now that we've decided to pass our own environment block,
                 * compute the size of the "current directory" strings to
                 * propagate to the new environment.
                 */

#ifdef WPRFLAG
                /*
                 * Make sure wide environment exists.
                 */
                if (!_wenvptr)
                {
                        if ((_wenvptr = (wchar_t *)__crtGetEnvironmentStringsW()) == NULL)
                        {
                                retval = -1;
                                goto error;
                        }
                }
#else  /* WPRFLAG */
                if (!_aenvptr)
                {
                        if ((_aenvptr = (char *)__crtGetEnvironmentStringsA()) == NULL)
                        {
                                retval = -1;
                                goto error;
                        }
                }
#endif  /* WPRFLAG */

                /*
                 * search for the first one
                 */
                for (cwd_start = 0;
                     _tenvptr[cwd_start] != _T('\0') &&
                       _tenvptr[cwd_start] != _T('=');
                     cwd_start += (int)_tcslen(&_tenvptr[cwd_start]) + 1)
                {
                }

                /* find the total size of all contiguous ones */
                cwd_end = cwd_start;
                while (_tenvptr[cwd_end+0] == _T('=') &&
                       _tenvptr[cwd_end+1] != _T('\0') &&
                       _tenvptr[cwd_end+2] == _T(':') &&
                       _tenvptr[cwd_end+3] == _T('='))
                {
                        cwd_end += 4 + (int)_tcslen(&_tenvptr[cwd_end+4]) + 1;
                }
                tmp += cwd_end - cwd_start;

                /*
                 * Allocate space for the environment strings plus extra null byte
                 */
                env_len = tmp;

                /*
                 * Check if SystemRoot is already defined in environment provided
                 */
                for (vp = envp; *vp; vp++) {
                        if (_tcsncicmp(*vp, envpfx, _tcslen(envpfx)) == 0) {
                                defined = 1;
                                break;
                        }
                }

                if (!defined)
                        tmp += envsize;

                if( !(*envblk = _calloc_crt(tmp, sizeof(_TSCHAR))) )
                {
                        _free_crt(*argblk);
                        *argblk = NULL;
                        errno = ENOMEM;
                        _doserrno = E_nomem;
                        retval = -1;
                        goto done;
                }
        }

        /*
         * Build the command line by concatenating the argument strings
         * with spaces between, and two null bytes at the end.
         * NOTE: The argv[0] argument is followed by a null.
         */

        cptr = *argblk;
        vp = argv;

        if (!*vp)       /* Empty argument list ? */
                ++cptr; /* just two null bytes */
        else {          /* argv[0] must be followed by a null */
                _ERRCHECK(_tcscpy_s(cptr, arg_len - (cptr - *argblk), *vp));
                cptr += (int)_tcslen(*vp++) + 1;
        }

        while( *vp ) {
                _ERRCHECK(_tcscpy_s(cptr, arg_len - (cptr - *argblk), *vp));
                cptr += (int)_tcslen(*vp++);
                *cptr++ = ' ';
        }

        *cptr = cptr[ -1 ] = _T('\0'); /* remove extra blank, add double null */

        /*
         * Build the environment block by concatenating the environment
         * strings with nulls between and two null bytes at the end
         */

        cptr = *envblk;

        if (envp != NULL) {
                /*
                 * Copy the "cwd" strings to the new environment.
                 */
                memcpy(cptr, &_tenvptr[cwd_start], (cwd_end - cwd_start) * sizeof(_TSCHAR));
                cptr += cwd_end - cwd_start;

                /*
                 * Copy the environment strings from "envp".
                 */
                vp = envp;
                while( *vp ) {
                        _ERRCHECK(_tcscpy_s(cptr, env_len - (cptr - *envblk), *vp));
                        cptr += 1 + (int)_tcslen(*vp++);
                }

                if (!defined) {
                        /*
                         * Copy SystemRoot to the new environment.
                         */
                        _ERRCHECK(_tcscpy_s(cptr, envsize, envpfx));
                        _ERRCHECK(_tcscat_s(cptr, envsize, _T("=")));
                        if (envbuf != NULL)
                        {
                            _ERRCHECK(_tcscat_s(cptr, envsize, envbuf));
                        }
                        cptr += envsize;
                }
        }

        if (cptr != NULL) {
                if (cptr == *envblk) {
                        /*
                         * Empty environment block ... this requires two
                         * nulls.
                         */
                        *cptr++ = _T('\0');
                }
                /*
                 * Extra null terminates the segment
                 */
                *cptr = _T('\0');
        }

        goto done;

error:
        _free_crt(*argblk);
        *argblk = NULL;
        *envblk = NULL;

done:

#ifdef WPRFLAG
        if (_wenvptr)
                _free_crt(_wenvptr);
        _wenvptr = NULL;
#else  /* WPRFLAG */
        if (_aenvptr)
                _free_crt(_aenvptr);
        _aenvptr = NULL;
#endif  /* WPRFLAG */
        if (envbuf)
                _free_crt(envbuf);

        return retval;
}


#ifndef _M_IX86

/***
*int _capture_argv(arglist, static_argv, max_static_entries) - set up argv array
*       for exec?? functions
*
*Purpose:
*       Set up the argv array for the exec?? functions by captures the
*       arguments from the passed va_list into the static_argv array.  If the
*       size of the static_argv array as specified by the max_static_entries
*       parameter is not large enough, then allocates a dynamic array to hold
*       the arguments. Return the address of the final argv array.  If NULL
*       then not enough memory to hold argument array.  If different from
*       static_argv parameter then call must free the return argv array when
*       done with it.
*
*       The scan of the arglist is terminated when a NULL argument is
*       reached. The terminating NULL parameter is stored in the resulting
*       argv array.
*
*Entry:
*       va_list *arglist          - pointer to variable length argument list.
*       _TSCHAR *firstarg            - first argument to store in array
*       _TSCHAR **static_argv        - pointer to static argv to use.
*       size_t max_static_entries - maximum number of entries that can be
*                                   placed in static_argv array.
*
*Exit:
*       returns NULL if no memory.
*       Otherwise returns pointer to argv array.
*       (sometimes calls malloc)
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
_TSCHAR ** __cdecl _wcapture_argv(
#else  /* WPRFLAG */
_TSCHAR ** __cdecl _capture_argv(
#endif  /* WPRFLAG */
        va_list *arglist,
        const _TSCHAR *firstarg,
        _TSCHAR **static_argv,
        size_t max_static_entries
        )
{
        _TSCHAR ** argv;
        _TSCHAR * nextarg;
        size_t i;
        size_t max_entries;

        nextarg = (_TSCHAR *)firstarg;
        argv = static_argv;
        max_entries = max_static_entries;
        i = 0;
        for (;;) {
            if (i >= max_entries) {
                /* The math here looks slightly odd. We really want (max_entries*2)*sizeof(_TSCHAR), but that can overflow
                   We take advantage of calloc's ability to catch overflow and the fact that sizeof(_TSCHAR)*2 cannot overflow
                */
                if (argv == static_argv)
                {
                    argv = _calloc_crt(max_entries, sizeof(_TSCHAR *)*2);
                }
                else
                {
                    argv = _recalloc_crt(argv, max_entries, sizeof(_TSCHAR *)*2);
                }

                if (argv == NULL) break;
                max_entries += max_entries;
            }

            argv[ i++ ] = nextarg;
            if (nextarg == NULL) break;
            nextarg = va_arg(*arglist, _TSCHAR *);
        }

        return argv;
}

#endif  /* _M_IX86 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\commit.c ===
/***
*commit.c - flush buffer to disk
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _commit() - flush buffer to disk
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <errno.h>
#include <io.h>
#include <internal.h>
#include <msdos.h>      /* for FOPEN */
#include <mtdll.h>
#include <stdlib.h>     /* for _doserrno */

/***
*int _commit(filedes) - flush buffer to disk
*
*Purpose:
*       Flushes cache buffers for the specified file handle to disk
*
*Entry:
*       int filedes - file handle of file
/*
*Exit:
*       returns success code
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _commit (
        int filedes
        )
{
        int retval;

        /* if filedes out of range, complain */
        _CHECK_FH_RETURN( filedes, EBADF, -1 );
        _VALIDATE_RETURN((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_RETURN((_osfile(filedes) & FOPEN), EBADF, -1);

        _lock_fh(filedes);
        __try {
                if (_osfile(filedes) & FOPEN) {

        if ( !FlushFileBuffers((HANDLE)_get_osfhandle(filedes)) ) {
                retval = GetLastError();
        }
        else {
                retval = 0;     /* return success */
        }

        /* map the OS return code to C errno value and return code */
        if (retval == 0)
                goto good;

        _doserrno = retval;

                }

        errno = EBADF;
        retval = -1;

        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
good :
        ; }
        __finally {
                _unlock_fh(filedes);
        }
        return (retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\commode.c ===
/***
*commode.c - set global file commit mode to commit
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the global file commit mode flag to commit.  Linking with
*       this file sets all files to be opened in commit mode by default.
*
*******************************************************************************/

#define SPECIAL_CRTEXE

#include <cruntime.h>
#include <file2.h>
#include <internal.h>

/* set default file commit mode to commit */
int _commode = _IOCOMMIT;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\closeall.c ===
/***
*closeall.c - close all open files
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fcloseall() - closes all open files except stdin, stdout
*       stdprn, stderr, and stdaux.
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <stdio.h>
#include <file2.h>
#include <internal.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>


/***
*int _fcloseall() - close all open streams
*
*Purpose:
*       Closes all streams currently open except for stdin/out/err/aux/prn.
*       tmpfile() files are among those closed.
*
*Entry:
*       None.
*
*Exit:
*       returns number of streams closed if OK
*       returns EOF if fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fcloseall (
        void
        )
{
        REG2 int count = 0;
        REG1 i;

        _mlock(_IOB_SCAN_LOCK);
        __try {

        for ( i = 3 ; i < _nstream ; i++ ) {

            if ( __piob[i] != NULL ) {
                /*
                 * if the stream is in use, close it
                 */
                if ( inuse( (FILE *)__piob[i] ) && (fclose( __piob[i] ) !=
                     EOF) )
                        count++;

                /*
                 * if stream is part of a _FILEX we allocated, free it.
                 */
                if ( i >= _IOB_ENTRIES ) {

                    DeleteCriticalSection( &(((_FILEX *)__piob[i])->lock) );
                    _free_crt( __piob[i] );
                    __piob[i] = NULL;
                }
            }
        }

        }
        __finally {
            _munlock(_IOB_SCAN_LOCK);
        }

        return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cgetws.c ===
/***
*cgetws.c - buffered keyboard input
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cgetws() - read a string directly from console
*
*******************************************************************************/
#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <conio.h>
#include <stdlib.h>
#include <internal.h>
#include <internal_securecrt.h>

#define BUF_MAX_LEN 64

extern intptr_t _coninpfh;
static int bUseW = 2;

/*
 * Use of the following buffer variables is primarily for syncronizing with
 * _cgets_s. _cget_s fills the MBCS buffer and if the user passes in single
 * character buffer and the unicode character is not converted to single byte
 * MBC, then _cget_s should buffer that character so that next call to
 * _cgetws_s can return the same character.
 */
wchar_t __console_wchar_buffer;
int __console_wchar_buffer_used = 0;

/***
*errno_t _cgetws_s(string, sizeInBytes, pSizeRead) - read string from console
*
*Purpose:
*       Reads a string from the console via ReadConsole on a cooked console
*       handle.
*
*Entry:
*       wchar_t *string - place to store read string
*       sizeInBytes  - max length to read
*       pSizeRead - sets the max read in this
*
*Exit:
*       returns error code or 0 if no error occurs
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _cgetws_s (
        wchar_t *string,
        size_t sizeInWords,
        size_t * pSizeRead
        )
{
        ULONG oldstate;
        ULONG num_read;
        errno_t err = 0;

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((string != NULL), EINVAL);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((sizeInWords > 0), EINVAL);
        _RESET_STRING(string, sizeInWords);

        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((pSizeRead != NULL), EINVAL);

        _mlock(_CONIO_LOCK);            /* lock the console */
        __TRY

            /*
             * We need to decrement sizeInWords because ReadConsole reads as
             * many characters as the parameter passed, doesn't null terminate
             */

            --sizeInWords;
            *pSizeRead = 0;

            /*
             * If the __console_whcar_buffer_used is set, then first fill the
             * buffered character and then proceed.
             */
            if (__console_wchar_buffer_used != 0 && sizeInWords > 0)
            {
                *string++ = __console_wchar_buffer;
                __console_wchar_buffer = 0;
                --sizeInWords;
                (*pSizeRead)++;
                if (__console_wchar_buffer == L'\0')
                    sizeInWords = 0;
            }

                        /* if the user only asked for one character, we have now filled their request
                        */
            if (sizeInWords != 0)
                        {
                                /*
                                * _coninpfh, the handle to the console input, is created the first
                                * time that either _getch() or _cgets() or _kbhit() is called.
                                */

                                if ( _coninpfh == -2 )
                                        __initconin();

                                if ( _coninpfh != -1 ) {

                                        GetConsoleMode( (HANDLE)_coninpfh, &oldstate );
                                        SetConsoleMode( (HANDLE)_coninpfh, ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT );
                                        // First try usual way just as _cgets
                                        if ( bUseW)
                                        {
                                                if ( !ReadConsoleW( (HANDLE)_coninpfh,
                                                                                        (LPVOID)string,
                                                                                        (DWORD)sizeInWords,
                                                                                        &num_read,
                                                                                        NULL )
                                                        )
                                                {
                                                        if ( bUseW == 2 )
                                                        {
                                                                if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                                                                        bUseW = FALSE;
                                                                else
                                                                        bUseW = TRUE;
                                                        }
                                                }
                                                else
                                                {
                                                        bUseW = TRUE;

                                                        /* set length of string and null terminate it */

                                                        if (num_read >= 2 && string[num_read - 2] == L'\r') {
                                                                (*pSizeRead) += num_read - 2;
                                                                string[num_read - 2] = L'\0';
                                                        } else if ( (num_read == sizeInWords) &&
                                                                                (string[num_read - 1] == L'\r') ) {
                                                        /* special case 1 - \r\n straddles the boundary */
                                                                (*pSizeRead) += num_read -1;
                                                                string[num_read - 1] = L'\0';
                                                        } else if ( (num_read == 1) && (string[0] == L'\n') ) {
                                                                /* special case 2 - read a single '\n'*/
                                                                string[0] = L'\0';
                                                                (*pSizeRead) += 0;
                                                        } else {
                                                                (*pSizeRead) += num_read;
                                                                string[num_read] = L'\0';
                                                        }
                                                }
                                        }
                                        // If ReadConsoleW is not present, use ReadConsoleA and then convert
                                        // to Wide Char.
                                        if ( !bUseW)
                                        {
                                                static char AStr[BUF_MAX_LEN +1];
                                                static int in_buff = 0, was_buff_full = 0;
                                                unsigned int Copy, Sz, consoleCP;
                                                unsigned int last_read = 0, i;
                                                consoleCP = GetConsoleCP();
                                                do {
                                                        if (!in_buff)
                                                        {
                                                                if ( ReadConsoleA( (HANDLE)_coninpfh,
                                                                                                        (LPVOID)AStr,
                                                                                                        BUF_MAX_LEN,
                                                                                                        &num_read,
                                                                                   NULL) &&
                                                                     num_read <= BUF_MAX_LEN
                                                                        ) {
                                                                        if (num_read >= 2 && AStr[num_read -2] == '\r')
                                                                        {
                                                                                AStr[num_read -2] = '\0';
                                                                        }
                                                                        else if (num_read == BUF_MAX_LEN &&
                                                                                        AStr[num_read -1] == '\r')
                                                                                AStr[num_read -1] = '\0';
                                                                        else if (num_read == 1 && AStr[0] == '\n')
                                                                                AStr[0] = '\0';
                                                                        else
                                                                                AStr[num_read] = '\0';
                                                                } else {
                                                                        _dosmaperr(GetLastError());
                                                                        err = errno;
                                                                }
                                                        }
                                                        for ( i = 0; AStr[i] != '\0' &&
                                                                                i < (BUF_MAX_LEN) &&
                                                                                last_read < sizeInWords; i += Sz)
                                                        {
                                                                // Check if this character is lead byte. If yes, the size
                                                                // of this character is 2. Else 1.
                                                                if ( IsDBCSLeadByteEx( GetConsoleCP(), AStr[i]))
                                                                        Sz = 2;
                                                                else
                                                                        Sz = 1;
                                                                if ( (Copy = MultiByteToWideChar( consoleCP,
                                                                                                                                MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                                                                                                                                &AStr[i],
                                                                                                                                Sz,
                                                                                                                                &string[last_read],
                                                                                                                                (int)sizeInWords - last_read)))
                                                                {
                                                                        last_read += Copy;
                                                                }
                                                        }
                                                        // Check if this conversion was from buffer. If yes, was
                                                        // buffer fully filled when it was first read using
                                                        // ReadConsoleA. If the buffer not fully filled, we don't need
                                                        // to read more from buffer. This is necessary to make it
                                                        // behave same as if we are reading using ReadConsoleW.
                                                        if ( in_buff && i == strlen(AStr))
                                                        {
                                                                in_buff = 0;
                                                                if ( was_buff_full)
                                                                {
                                                                        was_buff_full = 0;
                                                                        continue;
                                                                }
                                                                else
                                                                {
                                                                        break;
                                                                }
                                                        }
                                                        else if ( i < (BUF_MAX_LEN))
                                                                break;
                                                } while (last_read < sizeInWords);
                                                // We save the buffer to be used again.
                                                if ( i < strlen(AStr))
                                                {
                                                        in_buff = 1;
                                                        if ( strlen(AStr) == (BUF_MAX_LEN))
                                                                was_buff_full = 1;
                                                        memmove(AStr, &AStr[i], BUF_MAX_LEN +1 - i);
                                                }
                                                string[last_read] = '\0';
                                                (*pSizeRead) += last_read;
                                        }

                                        SetConsoleMode( (HANDLE)_coninpfh, oldstate );
                                } else {
                                        _dosmaperr(GetLastError());
                                        err = errno;
                                }
                        }

        __FINALLY
            _munlock(_CONIO_LOCK);          /* unlock the console */
        __END_TRY_FINALLY

        if (err != 0)
        {
            errno = err;
        }
        return err;
}

/***
*wchar_t *_cgetws(string) - read string from console
*
*Purpose:
*       Reads a string from the console via ReadConsoleW on a cooked console
*       handle.  string[0] must contain the maximum length of the
*       string.  Returns pointer to str[2].
*
*       NOTE: _cgetsw() does NOT check the pushback character buffer (i.e.,
*       _chbuf).  Thus, _cgetws() will not return any character that is
*       pushed back by the _ungetwch() call.
*Entry:
*       char *string - place to store read string, str[0] = max length.
*
*Exit:
*       returns pointer to str[2], where the string starts.
*       returns NULL if error occurs
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl _cgetws (
        wchar_t *string)
{
        size_t sizeInWords;
        size_t sizeRead;
        errno_t err;

        _VALIDATE_CLEAR_OSSERR_RETURN((string != NULL), EINVAL, NULL);

        sizeInWords = (size_t)string[0];

        err = _cgetws_s(string + 2, sizeInWords, &sizeRead);

        if(err != 0)
        {
            return NULL;
        }

       string[1] = (wchar_t)sizeRead;

       return string + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cmiscdat.c ===
/***
*cmiscdat.c - miscellaneous C run-time data
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Includes floating point conversion table (for C float output).
*
*       When floating point I/O conversions are done, but no floating-point
*       variables or expressions are used in the C program, we use the
*       _cfltcvt_tab[] to map these cases to the _fptrap entry point,
*       which prints "floating point not loaded" and dies.
*
*       This table is initialized to six copies of _fptrap by default.
*       If floating-point is linked in (_fltused), these table entries
*       are reset (see input.c, output.c, fltused.asm, and fltuseda.asm).
*
*******************************************************************************/

#if !defined (CRTDLL)

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>
#include <fltintrn.h>

/*-
 *  ... table of (model-dependent) code pointers ...
 *
 *  Entries all point to _fptrap by default,
 *  but are changed to point to the appropriate
 *  routine if the _fltused initializer (_cfltcvt_init)
 *  is linked in.
 *
 *  if the _fltused modules are linked in, then the
 *  _cfltcvt_init initializer sets the entries of
 *  _cfltcvt_tab.
-*/

PFV _cfltcvt_tab[10] = {
    _fptrap,    /*  _cfltcvt */
    _fptrap,    /*  _cropzeros */
    _fptrap,    /*  _fassign */
    _fptrap,    /*  _forcdecpt */
    _fptrap,    /*  _positive */
    _fptrap,    /*  _cldcvt */
    _fptrap,    /*  _cfltcvt_l */
    _fptrap,    /*  _fassign_l */
    _fptrap,    /*  _cropzeros_l */
    _fptrap     /*  _forcdecpt_l */
};

void __cdecl _initp_misc_cfltcvt_tab()
{
    int i;
    for (i = 0; i < _countof(_cfltcvt_tab); ++i)
    {
        _cfltcvt_tab[i] = (PFV)_encode_pointer(_cfltcvt_tab[i]);
    }
}

#endif  /* !defined (CRTDLL) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cin.cpp ===
// cin -- initialize standard input stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)
static std::_Init_locks  initlocks;

_STD_BEGIN
		// OBJECT DECLARATIONS

__PURE_APPDOMAIN_GLOBAL static filebuf fin(_cpp_stdin);
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 istream cin(&fin);
_MRTIMP2 istream& __cdecl _Cin_func()
{
    return cin;
}

		// INITIALIZATION CODE
struct _Init_cin
	{	// ensures that cin is initialized
	__CLR_OR_THIS_CALL _Init_cin()
		{	// initialize cin
		_Ptr_cin = &cin;
		cin.tie(_Ptr_cout);
		}
	};
__PURE_APPDOMAIN_GLOBAL static _Init_cin init_cin;

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cout.cpp ===
// cout -- initialize standard output stream
#include <fstream>
#include <iostream>

#pragma warning(disable: 4074)
#pragma init_seg(compiler)
static std::_Init_locks  initlocks;

_STD_BEGIN
		// OBJECT DECLARATIONS

__PURE_APPDOMAIN_GLOBAL static filebuf fout(_cpp_stdout);
__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream cout(&fout);
_MRTIMP2 ostream& __cdecl _Cout_func()
{
    return cout;
}

		// INITIALIZATION CODE
struct _Init_cout
	{	// ensures that cout is initialized
	__CLR_OR_THIS_CALL _Init_cout()
		{	// initialize cout
		_Ptr_cout = &cout;
		if (_Ptr_cin != 0)
			_Ptr_cin->tie(_Ptr_cout);
		if (_Ptr_cerr != 0)
			_Ptr_cerr->tie(_Ptr_cout);
		if (_Ptr_clog != 0)
			_Ptr_clog->tie(_Ptr_cout);
		}
	};
__PURE_APPDOMAIN_GLOBAL static _Init_cout init_cout;

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\chsize.c ===
/***
*chsize.c - change size of a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains the _chsize() function - changes the size of a file.
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <dbgint.h>
#include <fcntl.h>
#include <msdos.h>
#include <io.h>
#include <string.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>

/***
*erccode _chsize_s(filedes, size) - change size of a file
*
*Purpose:
*       Change file size. Assume file is open for writing, or we can't do it.
*       The DOS way to do this is to go to the right spot and write 0 bytes. The
*       Xenix way to do this is to make a system call. We write '\0' bytes because
*       DOS won't do this for you if you lseek beyond eof, though Xenix will.
*
*Entry:
*       int filedes - file handle to change size of
*       __int64 size - new size of file
*
*Exit:
*       return 0 if successful
*       returns errno_t on failure
*
*Exceptions:
*
*******************************************************************************/


/* define normal version that locks/unlocks, validates fh */

errno_t __cdecl _chsize_s (
        REG1 int filedes,
        __int64 size
        )
{
        int r;                          /* return value */

        _CHECK_FH_CLEAR_OSSERR_RETURN_ERRCODE( filedes, EBADF );
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((_osfile(filedes) & FOPEN), EBADF);
        _VALIDATE_CLEAR_OSSERR_RETURN_ERRCODE((size >= 0), EINVAL);

        _lock_fh(filedes);

        __try {
                if ( _osfile(filedes) & FOPEN )
                        r = _chsize_nolock(filedes,size);
                else {
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                        r = errno = EBADF;
                }
        }
        __finally {
                _unlock_fh(filedes);
        }

        return r;
}

/* now define version that doesn't lock/unlock, validate fh */
errno_t __cdecl _chsize_nolock (
        REG1 int filedes,
        __int64 size
        )
{
        __int64 filend;
        __int64 extend;
        __int64 place;
        int cnt;
        int oldmode;
        __int64 retval = 0; /* assume good return */
        errno_t err = 0;



        /* Get current file position and seek to end */
        if ( ((place = _lseeki64_nolock(filedes, 0i64, SEEK_CUR)) == -1i64) ||
             ((filend = _lseeki64_nolock(filedes, 0i64, SEEK_END)) == -1i64) )
            return errno;

        extend = size - filend;

        /* Grow or shrink the file as necessary */

        if (extend > 0i64) {

            /* extending the file */
            char *bl = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, _INTERNAL_BUFSIZ);

            if (!bl) {
                err = errno = ENOMEM;
                retval= -1i64;
            } else {
                oldmode = _setmode_nolock(filedes, _O_BINARY);

                /* pad out with nulls */
                do  {
                    cnt = (extend >= (__int64)_INTERNAL_BUFSIZ ) ?
                          _INTERNAL_BUFSIZ : (int)extend;
                    if ( (cnt = _write_nolock( filedes,
                                           bl,
                                           (extend >= (__int64)_INTERNAL_BUFSIZ) ?
                                                _INTERNAL_BUFSIZ : (int)extend ))
                         == -1 )
                    {
                        /* Error on write */
                        if (_doserrno == ERROR_ACCESS_DENIED)
                            err = errno = EACCES;

                        retval = cnt;
                        break;  /* leave write loop */
                    }
                }
                while ((extend -= (__int64)cnt) > 0i64);

                _setmode_nolock(filedes, oldmode);

                HeapFree(GetProcessHeap(), 0, bl);
            }

            /* retval set correctly */
        }

        else  if ( extend < 0i64 ) {
            /* shortening the file */

            /*
             * Set file pointer to new eof...and truncate it there.
             */
            retval = _lseeki64_nolock(filedes, size, SEEK_SET);


            if(retval != -1i64)
            {
                if ( (retval = SetEndOfFile((HANDLE)_get_osfhandle(filedes)) ?
                     0 : -1) == -1 )
                {
                    err = errno = EACCES;
                    _doserrno = GetLastError();
                }
            }
        }

        /* else */
        /* no file change needed */
        /* retval = 0; */


/* Common return code */

        if(retval == -1 || (_lseeki64_nolock(filedes, place, SEEK_SET) == -1i64))
        {
            return errno;
        }

        return 0;
}

/***
*int _chsize(filedes, size) - change size of a file
*
*Purpose:
*       Change file size. Assume file is open for writing, or we can't do it.
*       The DOS way to do this is to go to the right spot and write 0 bytes. The
*       Xenix way to do this is to make a system call. We write '\0' bytes because
*       DOS won't do this for you if you lseek beyond eof, though Xenix will.
*
*Entry:
*       int filedes - file handle to change size of
*       long size - new size of file
*
*Exit:
*       return 0 if successful
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _chsize (
        REG1 int filedes,
        long size
        )
{
    errno_t e;
    e = _chsize_s(filedes, (__int64)size) ;

    return e == 0 ? 0 : -1 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\close.c ===
/***
*close.c - close file handle for Windows NT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _close() - close a file handle
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <io.h>
#include <mtdll.h>
#include <errno.h>
#include <stdlib.h>
#include <msdos.h>
#include <internal.h>

/***
*int _close(fh) - close a file handle
*
*Purpose:
*       Closes the file associated with the file handle fh.
*
*Entry:
*       int fh - file handle to close
*
*Exit:
*       returns 0 if successful, -1 (and sets errno) if fails
*
*Exceptions:
*
*******************************************************************************/


/* define normal version that locks/unlocks, validates fh */

int __cdecl _close (
        int fh
        )
{
        int r;                          /* return value */

        /* validate file handle */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);

        _lock_fh(fh);                   /* lock file */

        __try {
                if ( _osfile(fh) & FOPEN )
                        r = _close_nolock(fh);
                else {
                        errno = EBADF;
                        r = -1;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                _unlock_fh(fh);         /* unlock the file */
        }

        return r;
}

/* now define version that doesn't lock/unlock, validate fh */
int __cdecl _close_nolock (
        int fh
        )
{
        DWORD dosretval;

        /*
         * Close the underlying OS file handle. Special cases:
         *      1. If _get_osfhandle(fh) is INVALID_HANDLE_VALUE, don't try
         *         to actually close it. Just reset the lowio info so the
         *         handle can be reused. The standard handles are setup like
         *         this in Windows app, or a background app.
         *      2. If fh is STDOUT or STDERR, and if STDOUT and STDERR are
         *         mapped to the same OS file handle, skip the CloseHandle
         *         is skipped (without error). STDOUT and STDERR are the only
         *         handles for which this support is provided. Other handles
         *         are mapped to the same OS file handle only at the
         *         programmer's risk.
         */

        if ( (_get_osfhandle(fh) == (intptr_t)INVALID_HANDLE_VALUE) ||
             (((fh == 1 && (_osfile(2) & FOPEN)) ||
               (fh == 2 && (_osfile(1) & FOPEN))) &&
              (_get_osfhandle(1) == _get_osfhandle(2)) ) ||
             CloseHandle( (HANDLE)_get_osfhandle(fh) ) )
        {

                dosretval = 0L;
        }
        else
                dosretval = GetLastError();

        _free_osfhnd(fh);

        _osfile(fh) = 0;                /* clear file flags */

        if (dosretval) {
                /* OS error */
                _dosmaperr(dosretval);
                return -1;
        }

        return 0;                       /* good return */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cprintfs.c ===
/***
*cprintfs.c - Secure version of cprintf
*
*   Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This has format validations as compared to cprintf
*
*******************************************************************************/

#define FORMAT_VALIDATIONS 1
#define CPRFLAG 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cputs.c ===
/***
*cputs.c - direct console output
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _cputs() - write string directly to console
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <mtdll.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
 * declaration for console handle
 */
extern intptr_t _confh;

/***
*int _cputs(string) - put a string to the console
*
*Purpose:
*       Writes the string directly to the console.  No newline
*       is appended.
*
*Entry:
*       char *string - string to write
*
*Exit:
*       Good return = 0
*       Error return = !0
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _cputs (
        const char *string
        )
{
        int error = 0;                   /* error occurred? */

        _VALIDATE_CLEAR_OSSERR_RETURN((string != NULL), EINVAL, -1);

        _mlock(_CONIO_LOCK);             /* acquire console lock */
        __try {

            /*
             * _confh, the handle to the console output, is created the
             * first time that either _putch() or _cputs() is called.
             */

            if (_confh == -2)
                __initconout();

            /* write string to console file handle */

            /*
             * What is more important when writing to console. I don't think if
             * speed should matter too much. This justification is used for writing
             * the string to Console. Here we are converting each and every
             * character to wide character and then writing it to console.
             */
            while(*string)
            {
                if (_putch_nolock(*string++) == EOF) {
                    error = -1;
                    break;
                }
            }

        }
        __finally {
            _munlock(_CONIO_LOCK);          /* release console lock */
        }

        return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cprintfp.c ===
/***
*cprintfp.c - Positional version of cprintf
*
*   Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This has format validations & positional parameters as compared to cprintf
*
*******************************************************************************/

#define POSITIONAL_PARAMETERS 1
#define CPRFLAG 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\convrtcp.c ===
/***
*convrtcp.c - support routines for Ansi WinAPIs.
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Implementation of routines to convert multibyte string from one code
*       page to another.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <setlocal.h>
#include <locale.h>
#include <awint.h>
#include <dbgint.h>
#include <malloc.h>
#include <stdlib.h>
#include <wchar.h>

/***
*int __cdecl __ansicp - count characters in a string, up to n.
*
*Purpose:
*       return ansi codepage for given Locale
*
*Entry:
*       int lcid                - Locale ID
*
*Exit:
*   returns ansi codepage corrosponding to the locale.
*
*Exceptions:
*   return -1
*
*******************************************************************************/
int __cdecl __ansicp(int lcid)
{
    char ch[7];
    int ret;
    ch[6] = 0;

    if (!GetLocaleInfoA(lcid, LOCALE_IDEFAULTANSICODEPAGE, ch, 6))
        ret = -1;
    else
        ret = atol(ch);
    return ret;
}

/***
*int __cdecl __convertcp - converts string from one code page to other.
*
*Purpose:
*       Convert string from one code page to other.
*
*Entry:
*       int fromCP  - Codepage to convert from
*       int toCP    - Codepage to convert to
*       const char *lpSrcStr    - String to be converted
*       int *pcchSrc    - Length of lpSrcStr.
*       char *lpDestSrc - Destenation string. If NULL, create new string.
*       char cchDest    - Destenation string length. No use if lpDestStr = NULL
*
*Exit:
*       returns pointer to new string (or Destination string)
*
*Exceptions:
*       return NULL
*
*******************************************************************************/
char * __cdecl __convertcp(int fromCP,
                   int toCP,
                   const char *lpSrcStr,
                   int *pcchSrc,
                   char *lpDestStr,
                   int cchDest
                   )
{
    char *cbuffer = NULL;
    int buff_size;
    int cchSrc = *pcchSrc;
    int sb = FALSE;

    if (fromCP != toCP)
    {
        wchar_t *wbuffer=NULL;
        CPINFO cpi;
        // Find if both the codepages have no MBCS
        if ( GetCPInfo(fromCP, &cpi))
        {
            if ( cpi.MaxCharSize == 1 && GetCPInfo(toCP, &cpi))
                if (cpi.MaxCharSize == 1)
                    sb = TRUE;
        }
        // If no MBCS in both then set buff_size and use if for all allocation
        if (sb)
        {
            if ( cchSrc != -1)
                buff_size = cchSrc;
            else
                //NULL character included
                buff_size = (int)strlen(lpSrcStr) + 1;
        }
        // If sb then no need to find buff_size
        if ( !sb &&  !(buff_size = MultiByteToWideChar( fromCP,
                                                        MB_PRECOMPOSED,
                                                        lpSrcStr,
                                                        cchSrc,
                                                        NULL,
                                                        0 )) )
            return NULL;

        /* allocate enough space for wide chars */
        wbuffer = (wchar_t *)_calloca( sizeof(wchar_t), buff_size);
        if ( wbuffer == NULL ) {
            return NULL;
        }
        (void)memset( wbuffer, 0, sizeof(wchar_t) * buff_size);

        /* do the conversion to WideChar */
        if ( 0 != MultiByteToWideChar( fromCP,
                                       MB_PRECOMPOSED,
                                       lpSrcStr,
                                       cchSrc,
                                       wbuffer,
                                       buff_size ))
        {
            if ( lpDestStr != NULL)
            {
                if (WideCharToMultiByte(toCP,
                                         0,
                                         wbuffer,
                                         buff_size,
                                         lpDestStr,
                                         cchDest,
                                         NULL,
                                         NULL))
                    cbuffer = lpDestStr;
            } else {
                /* do the conversion back to MultiByte using ANSI_CP */
                if ( sb || (buff_size = WideCharToMultiByte( toCP,
                                                             0,
                                                             wbuffer,
                                                             buff_size,
                                                             0,
                                                             0,
                                                             NULL,
                                                             NULL)))
                {
                    if ( (cbuffer = (char *)_calloc_crt(sizeof(char),buff_size)) != NULL)
                    {
                        if ( 0 == (buff_size = WideCharToMultiByte( toCP,
                                                                    0,
                                                                    wbuffer,
                                                                    buff_size,
                                                                    cbuffer,
                                                                    buff_size,
                                                                    NULL,
                                                                    NULL)))
                        {
                            _free_crt(cbuffer);
                            cbuffer = NULL;
                        } else {
                            if ( cchSrc != -1)
                                *pcchSrc = buff_size;
                        }
                    }
                }
            }
        }
        if(wbuffer)
        {
            _freea(wbuffer);
        }
    }
    return cbuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cprintf.c ===
/***
*cprintf.c - Conio version of printf
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Perform formatted i/o directly to the console.
*
*******************************************************************************/

#define CPRFLAG 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for
*       the MS C V2.03 compatible console I/O routines.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_CONIO
#define _INC_CONIO

#include <crtdefs.h>
#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* Function prototypes */

_Check_return_wat_ _CRTIMP errno_t __cdecl _cgets_s(_Out_z_cap_(_Size)                char * _Buffer, size_t _Size, _Out_ size_t * _SizeRead);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _cgets_s, _Deref_post_count_(*_Buffer) char, _Buffer, _Out_ size_t *, _Size)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(char *, _CRTIMP, _cgets, _Pre_notnull_ _Post_z_, char, _Buffer)
_Check_return_opt_ _CRTIMP int __cdecl _cprintf(_In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cprintf_s(_In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cputs(_In_z_ const char * _Str);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_cscanf_s) _CRTIMP int __cdecl _cscanf(_In_z_ _Scanf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_cscanf_s_l) _CRTIMP int __cdecl _cscanf_l(_In_z_ _Scanf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cscanf_s(_In_z_ _Scanf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cscanf_s_l(_In_z_ _Scanf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_ _CRTIMP int __cdecl _getch(void);
_Check_return_ _CRTIMP int __cdecl _getche(void);
_Check_return_opt_ _CRTIMP int __cdecl _vcprintf(_In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vcprintf_s(_In_z_ _Printf_format_string_ const char * _Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _cprintf_p(_In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vcprintf_p(_In_z_ const char * _Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _cprintf_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cprintf_s_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vcprintf_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vcprintf_s_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _cprintf_p_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vcprintf_p_l(_In_z_ _Printf_format_string_ const char * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

#ifdef _M_IX86
int __cdecl _inp(unsigned short);
unsigned short __cdecl _inpw(unsigned short);
unsigned long __cdecl _inpd(unsigned short);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _kbhit(void);
#ifdef _M_IX86
int __cdecl _outp(unsigned short, int);
unsigned short __cdecl _outpw(unsigned short, unsigned short);
unsigned long __cdecl _outpd(unsigned short, unsigned long);
#endif  /* _M_IX86 */
_CRTIMP int __cdecl _putch(_In_ int _Ch);
_CRTIMP int __cdecl _ungetch(_In_ int _Ch);

_Check_return_ _CRTIMP int __cdecl _getch_nolock(void);
_Check_return_ _CRTIMP int __cdecl _getche_nolock(void);
_CRTIMP int __cdecl _putch_nolock(_In_ int _Ch);
_CRTIMP int __cdecl _ungetch_nolock(_In_ int _Ch);



#ifndef _WCONIO_DEFINED

/* wide function prototypes, also declared in wchar.h */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif  /* WEOF */

_Check_return_wat_ _CRTIMP errno_t __cdecl _cgetws_s(_Out_cap_post_count_(_SizeInWords, *_SizeRead) wchar_t * _Buffer, size_t _SizeInWords, _Out_ size_t * _SizeRead);
__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(errno_t, _cgetws_s, _Deref_post_count_(*_Buffer) wchar_t, _Buffer, size_t *, _Size)
__DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(wchar_t *, _CRTIMP, _cgetws, _Pre_notnull_ _Post_z_, wchar_t, _Buffer)
_Check_return_ _CRTIMP wint_t __cdecl _getwch(void);
_Check_return_ _CRTIMP wint_t __cdecl _getwche(void);
_Check_return_ _CRTIMP wint_t __cdecl _putwch(wchar_t _WCh);
_Check_return_ _CRTIMP wint_t __cdecl _ungetwch(wint_t _WCh);
_Check_return_opt_ _CRTIMP int __cdecl _cputws(_In_z_ const wchar_t * _String);
_Check_return_opt_ _CRTIMP int __cdecl _cwprintf(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cwprintf_s(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_cwscanf_s) _CRTIMP int __cdecl _cwscanf(_In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRT_INSECURE_DEPRECATE(_cwscanf_s_l) _CRTIMP int __cdecl _cwscanf_l(_In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cwscanf_s(_In_z_ _Scanf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _cwscanf_s_l(_In_z_ _Scanf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vcwprintf(_In_z_ _Printf_format_string_ const wchar_t *_Format, va_list _ArgList);
_Check_return_opt_ _CRTIMP int __cdecl _vcwprintf_s(_In_z_ _Printf_format_string_ const wchar_t *_Format, va_list _ArgList);

_Check_return_opt_ _CRTIMP int __cdecl _cwprintf_p(_In_z_ _Printf_format_string_ const wchar_t * _Format, ...);
_Check_return_opt_ _CRTIMP int __cdecl _vcwprintf_p(_In_z_ _Printf_format_string_ const wchar_t*  _Format, va_list _ArgList);

_CRTIMP int __cdecl _cwprintf_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_CRTIMP int __cdecl _cwprintf_s_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_CRTIMP int __cdecl _vcwprintf_l(_In_z_ _Printf_format_string_ const wchar_t *_Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_CRTIMP int __cdecl _vcwprintf_s_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);
_CRTIMP int __cdecl _cwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, ...);
_CRTIMP int __cdecl _vcwprintf_p_l(_In_z_ _Printf_format_string_ const wchar_t * _Format, _In_opt_ _locale_t _Locale, va_list _ArgList);

_Check_return_opt_ _CRTIMP wint_t __cdecl _putwch_nolock(wchar_t _WCh);
_Check_return_ _CRTIMP wint_t __cdecl _getwch_nolock(void);
_Check_return_ _CRTIMP wint_t __cdecl _getwche_nolock(void);
_Check_return_opt_ _CRTIMP wint_t __cdecl _ungetwch_nolock(wint_t _WCh);


#define _WCONIO_DEFINED
#endif  /* _WCONIO_DEFINED */

#if !__STDC__

/* Non-ANSI names for compatibility */

#pragma warning(push)
#pragma warning(disable: 4141) /* Using deprecated twice */
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_cgets) _CRT_INSECURE_DEPRECATE(_cgets_s) _CRTIMP char * __cdecl cgets(_Out_z_cap_x_(*_Buffer+2) char * _Buffer);
#pragma warning(pop)
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_cprintf) _CRTIMP int __cdecl cprintf(_In_z_ _Printf_format_string_ const char * _Format, ...);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_cputs) _CRTIMP int __cdecl cputs(_In_z_ const char * _Str);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_cscanf) _CRTIMP int __cdecl cscanf(_In_z_ _Scanf_format_string_ const char * _Format, ...);
#ifdef _M_IX86
_CRT_NONSTDC_DEPRECATE(_inp) int __cdecl inp(unsigned short);
_CRT_NONSTDC_DEPRECATE(_inpw) unsigned short __cdecl inpw(unsigned short);
#endif  /* _M_IX86 */
_Check_return_ _CRT_NONSTDC_DEPRECATE(_getch) _CRTIMP int __cdecl getch(void);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_getche) _CRTIMP int __cdecl getche(void);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_kbhit) _CRTIMP int __cdecl kbhit(void);
#ifdef _M_IX86
_CRT_NONSTDC_DEPRECATE(_outp) int __cdecl outp(unsigned short, int);
_CRT_NONSTDC_DEPRECATE(_outpw) unsigned short __cdecl outpw(unsigned short, unsigned short);
#endif  /* _M_IX86 */
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_putch) _CRTIMP int __cdecl putch(int _Ch);
_Check_return_opt_ _CRT_NONSTDC_DEPRECATE(_ungetch) _CRTIMP int __cdecl ungetch(int _Ch);

#endif  /* !__STDC__ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_CONIO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crt0fp.c ===
/***
*crt0fp.asm - floating point not loaded trap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To trap certain cases where certain necessary floating-point
*       software is not loaded.  Two specific cases are when no emulator
*       is linked in but no coprocessor is present, and when floating
*       point i/o conversions are done, but no floating-point variables
*       or expressions are used in the program.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <rterr.h>

/***
*_fptrap - trap for missing floating-point software
*
*Purpose:
*       Catches these cases of incomplete f.p. software linked into a program.
*
*       (1) no coprocessor present, and no emulator linked in
*
*       (2) "%e", "%f", and "%g" i/o conversion formats specified, but
*           not all conversion software has been linked in, because the
*           program did not use any floating-point variables or expressions.
*
*Entry:
*       None.
*
*Exit:
*       Never returns.
*
*Exceptions:
*       Transfers control to _amsg_exit which ...
*       - Writes error message to standard error:  "floating point not loaded"
*       - Terminates the program by calling _exit().
*******************************************************************************/

void __cdecl _fptrap(
        void
        )
{
        _amsg_exit(_RT_FLOAT);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cmsgs.h ===
/***
*cmsgs.h - runtime errors
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       The file defines, in one place, all error message strings used within
*       the C run-time library.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_CMSGS
#define _INC_CMSGS

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/*
 * runtime error and termination messages
 */

#define EOL "\r\n"

#define _RT_STACK_TXT      "R6000" EOL "- stack overflow" EOL

#define _RT_FLOAT_TXT      "R6002" EOL "- floating point support not loaded" EOL

#define _RT_INTDIV_TXT     "R6003" EOL "- integer divide by 0" EOL

#define _RT_SPACEARG_TXT   "R6008" EOL "- not enough space for arguments" EOL

#define _RT_SPACEENV_TXT   "R6009" EOL "- not enough space for environment" EOL

#define _RT_ABORT_TXT      "" EOL "This application has requested the Runtime to terminate it in an unusual way.\nPlease contact the application's support team for more information." EOL

#define _RT_THREAD_TXT     "R6016" EOL "- not enough space for thread data" EOL

#define _RT_LOCK_TXT       "R6017" EOL "- unexpected multithread lock error" EOL

#define _RT_HEAP_TXT       "R6018" EOL "- unexpected heap error" EOL

#define _RT_OPENCON_TXT    "R6019" EOL "- unable to open console device" EOL

#define _RT_NONCONT_TXT    "R6022" EOL "- non-continuable exception" EOL

#define _RT_INVALDISP_TXT  "R6023" EOL "- invalid exception disposition" EOL

/*
 * _RT_ONEXIT_TXT is specific to Win32 and Dosx32 platforms
 */
#define _RT_ONEXIT_TXT     "R6024" EOL "- not enough space for _onexit/atexit table" EOL

#define _RT_PUREVIRT_TXT   "R6025" EOL "- pure virtual function call" EOL

#define _RT_STDIOINIT_TXT  "R6026" EOL "- not enough space for stdio initialization" EOL

#define _RT_LOWIOINIT_TXT  "R6027" EOL "- not enough space for lowio initialization" EOL

#define _RT_HEAPINIT_TXT   "R6028" EOL "- unable to initialize heap" EOL

#define _RT_CRT_NOTINIT_TXT "R6030" EOL "- CRT not initialized" EOL

#define _RT_CRT_INIT_CONFLICT_TXT "R6031" EOL "- Attempt to initialize the CRT more than once.\n" \
    "This indicates a bug in your application." EOL

#define _RT_LOCALE_TXT "R6032" EOL "- not enough space for locale information" EOL

#define _RT_CRT_INIT_MANAGED_CONFLICT_TXT "R6033" EOL "- Attempt to use MSIL code from this assembly during native code initialization\n" \
    "This indicates a bug in your application. It is most likely the result of calling an MSIL-compiled (/clr) function from a native constructor or from DllMain." EOL

#ifndef _DEBUG
#define _RT_CHECKMANIFEST_TXT "R6034" EOL "An application has made an attempt to load the C runtime library incorrectly.\nPlease contact the application's support team for more information." EOL
#else  /* _DEBUG */
#define _RT_CHECKMANIFEST_TXT "R6034" EOL "An application has made an attempt to load the C runtime library without using a manifest.\n" \
    "This is an unsupported way to load Visual C++ DLLs. You need to modify your application to build with a manifest.\n" \
    "For more information, see the \"Visual C++ Libraries as Shared Side-by-Side Assemblies\" topic in the product documentation." EOL
#endif  /* _DEBUG */

/*
 * _RT_COOKIE_INIT_TXT is used directly as the argument to FatalAppExitA, since it is
 * used in __security_init_cookie when __crtMessageBox may not be available yet.
 */
#define _RT_COOKIE_INIT_TXT "Microsoft Visual C++ Runtime Library, Error R6035 - " \
                            "A module in this application is initializing the module's " \
                            "global security cookie while a function relying on that " \
                            "security cookie is active.  Call __security_init_cookie earlier."

/*
 * _RT_DOMAIN_TXT, _RT_SING_TXT and _RT_TLOSS_TXT are used by the floating
 * point library.
 */
#define _RT_DOMAIN_TXT     "DOMAIN error" EOL

#define _RT_SING_TXT       "SING error" EOL

#define _RT_TLOSS_TXT      "TLOSS error" EOL


#define _RT_CRNL_TXT       EOL

#define _RT_BANNER_TXT     "runtime error "


#endif  /* _INC_CMSGS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crt0init.c ===
/***
*crt0init.c - Initialization segment declarations.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Do initialization segment declarations.
*
*Notes:
*       In the 16-bit C world, the X*B and X*E segments were empty except for
*       a label.  This will not work with COFF since COFF throws out empty
*       sections.  Therefore we must put a zero value in them.  (Zero because
*       the routine to traverse the initializers will skip over zero entries.)
*
*******************************************************************************/

#include <sect_attribs.h>
#include <stdio.h>
#include <internal.h>

_CRTALLOC(".CRT$XIA") _PIFV __xi_a[] = { NULL };

_CRTALLOC(".CRT$XIZ") _PIFV __xi_z[] = { NULL };

_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };

_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };

_CRTALLOC(".CRT$XPA") _PVFV __xp_a[] = { NULL };

_CRTALLOC(".CRT$XPZ") _PVFV __xp_z[] = { NULL };

_CRTALLOC(".CRT$XTA") _PVFV __xt_a[] = { NULL };

_CRTALLOC(".CRT$XTZ") _PVFV __xt_z[] = { NULL };

#pragma comment(linker, "/merge:.CRT=.rdata")

#pragma comment(linker, "/defaultlib:kernel32.lib")

#pragma comment(linker, "/disallowlib:libc.lib")
#pragma comment(linker, "/disallowlib:libcd.lib")
#if !(!defined (_DEBUG))
#pragma comment(linker, "/disallowlib:libcmt.lib")
#endif  /* !(!defined (_DEBUG)) */
#if !(defined (_DEBUG))
#pragma comment(linker, "/disallowlib:libcmtd.lib")
#endif  /* !(defined (_DEBUG)) */
#pragma comment(linker, "/disallowlib:msvcrt.lib")
#pragma comment(linker, "/disallowlib:msvcrtd.lib")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crt0msg.c ===
/***
*crt0msg.c - startup error messages
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Prints out banner for runtime error messages.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <rterr.h>
#include <cmsgs.h>
#include <awint.h>
#include <windows.h>
#include <dbgint.h>

/* struct used to lookup and access runtime error messages */

struct rterrmsgs {
        int rterrno;        /* error number */
        char *rterrtxt;     /* text of error message */
};

/* runtime error messages */

static struct rterrmsgs rterrs[] = {

        /* 2 */
        { _RT_FLOAT, _RT_FLOAT_TXT },

        /* 8 */
        { _RT_SPACEARG, _RT_SPACEARG_TXT },

        /* 9 */
        { _RT_SPACEENV, _RT_SPACEENV_TXT },

        /* 10 */
        { _RT_ABORT, _RT_ABORT_TXT },

        /* 16 */
        { _RT_THREAD, _RT_THREAD_TXT },

        /* 17 */
        { _RT_LOCK, _RT_LOCK_TXT },

        /* 18 */
        { _RT_HEAP, _RT_HEAP_TXT },

        /* 19 */
        { _RT_OPENCON, _RT_OPENCON_TXT },

        /* 22 */
        /* { _RT_NONCONT, _RT_NONCONT_TXT }, */

        /* 23 */
        /* { _RT_INVALDISP, _RT_INVALDISP_TXT }, */

        /* 24 */
        { _RT_ONEXIT, _RT_ONEXIT_TXT },

        /* 25 */
        { _RT_PUREVIRT, _RT_PUREVIRT_TXT },

        /* 26 */
        { _RT_STDIOINIT, _RT_STDIOINIT_TXT },

        /* 27 */
        { _RT_LOWIOINIT, _RT_LOWIOINIT_TXT },

        /* 28 */
        { _RT_HEAPINIT, _RT_HEAPINIT_TXT },

        ///* 29 */
        //{ _RT_BADCLRVERSION, _RT_BADCLRVERSION_TXT },

        /* 30 */
        { _RT_CRT_NOTINIT, _RT_CRT_NOTINIT_TXT },

        /* 31 */
        { _RT_CRT_INIT_CONFLICT, _RT_CRT_INIT_CONFLICT_TXT},

        /* 32 */
        { _RT_LOCALE, _RT_LOCALE_TXT},

        /* 33 */
        { _RT_CRT_INIT_MANAGED_CONFLICT, _RT_CRT_INIT_MANAGED_CONFLICT_TXT},

        /* 34 */
        { _RT_CHECKMANIFEST, _RT_CHECKMANIFEST_TXT},

        ///* 35 - not for _NMSG_WRITE, text passed directly to FatalAppExit */
        //{ _RT_COOKIE_INIT, _RT_COOKIE_INIT_TXT},

        /* 120 */
        { _RT_DOMAIN, _RT_DOMAIN_TXT },

        /* 121 */
        { _RT_SING, _RT_SING_TXT },

        /* 122 */
        { _RT_TLOSS, _RT_TLOSS_TXT },

        /* 252 */
        { _RT_CRNL, _RT_CRNL_TXT },

        /* 255 */
        { _RT_BANNER, _RT_BANNER_TXT }

};

/* number of elements in rterrs[] */

#define _RTERRCNT   ( sizeof(rterrs) / sizeof(struct rterrmsgs) )

/***
*_FF_MSGBANNER - writes out first part of run-time error messages
*
*Purpose:
*       This routine writes "\r\nrun-time error " to standard error.
*
*Entry:
*       No arguments.
*
*Exit:
*       Nothing returned.
*
*Exceptions:
*       None handled.
*
*******************************************************************************/

void __cdecl _FF_MSGBANNER (
        void
        )
{

        if ( (_set_error_mode(_REPORT_ERRMODE) == _OUT_TO_STDERR) ||
             ((_set_error_mode(_REPORT_ERRMODE) == _OUT_TO_DEFAULT) &&
              (__app_type == _CONSOLE_APP)) )
        {
            _NMSG_WRITE(_RT_CRNL);  /* new line to begin error message */
            _NMSG_WRITE(_RT_BANNER); /* run-time error message banner */
        }
}


/***
*__NMSGWRITE(message) - write a given message to handle 2 (stderr)
*
*Purpose:
*       This routine writes the message associated with rterrnum
*       to stderr.
*
*Entry:
*       int rterrnum - runtime error number
*
*Exit:
*       no return value
*
*Exceptions:
*       none
*
*******************************************************************************/

void __cdecl _NMSG_WRITE (
        int rterrnum
        )
{
        int tblindx;
        DWORD bytes_written;            /* bytes written */

        for ( tblindx = 0 ; tblindx < _RTERRCNT ; tblindx++ )
            if ( rterrnum == rterrs[tblindx].rterrno )
                break;

        if ( tblindx < _RTERRCNT )
        {
#ifdef _DEBUG
            /*
             * Report error.
             *
             * If _CRT_ERROR has _CRTDBG_REPORT_WNDW on, and user chooses
             * "Retry", call the debugger.
             *
             * Otherwise, continue execution.
             *
             */

            if (rterrnum != _RT_CRNL && rterrnum != _RT_BANNER && rterrnum != _RT_CRT_NOTINIT)
            {
                if (1 == _CrtDbgReport(_CRT_ERROR, NULL, 0, NULL, rterrs[tblindx].rterrtxt))
                    _CrtDbgBreak();
            }
#endif  /* _DEBUG */
            if ( (_set_error_mode(_REPORT_ERRMODE) == _OUT_TO_STDERR) ||
                 ((_set_error_mode(_REPORT_ERRMODE) == _OUT_TO_DEFAULT) &&
                  (__app_type == _CONSOLE_APP)) )
            {
                HANDLE hStdErr = GetStdHandle(STD_ERROR_HANDLE);
                if (hStdErr && hStdErr!=INVALID_HANDLE_VALUE)
                {
                    WriteFile( hStdErr,
                                  rterrs[tblindx].rterrtxt,
                                  (unsigned long)strlen(rterrs[tblindx].rterrtxt),
                                  &bytes_written,
                                  NULL );
                }
            }
            else if (rterrnum != _RT_CRNL)
            {
                #define MSGTEXTPREFIX "Runtime Error!\n\nProgram: "
                static char outmsg[sizeof(MSGTEXTPREFIX) + _MAX_PATH + 2 + 500];
                    // runtime error msg + progname + 2 newline + runtime error text.
                char * progname = &outmsg[sizeof(MSGTEXTPREFIX)-1];
                size_t progname_size = _countof(outmsg) - (progname - outmsg);
                char * pch = progname;

                _ERRCHECK(strcpy_s(outmsg, _countof(outmsg), MSGTEXTPREFIX));

                progname[MAX_PATH] = '\0';
                if (!GetModuleFileName(NULL, progname, MAX_PATH))
                    _ERRCHECK(strcpy_s(progname, progname_size, "<program name unknown>"));

                #define MAXLINELEN 60
                if (strlen(pch) + 1 > MAXLINELEN)
                {
                    pch += strlen(progname) + 1 - MAXLINELEN;
                    _ERRCHECK(strncpy_s(pch, progname_size - (pch - progname), "...", 3));
                }

                _ERRCHECK(strcat_s(outmsg, _countof(outmsg), "\n\n"));
                _ERRCHECK(strcat_s(outmsg, _countof(outmsg), rterrs[tblindx].rterrtxt));

                __crtMessageBoxA(outmsg,
                        "Microsoft Visual C++ Runtime Library",
                        MB_OK|MB_ICONHAND|MB_SETFOREGROUND|MB_TASKMODAL);
            }
        }
}


/***
*_GET_RTERRMSG(message) - returns ptr to error text for given runtime error
*
*Purpose:
*       This routine returns the message associated with rterrnum
*
*Entry:
*       int rterrnum - runtime error number
*
*Exit:
*       no return value
*
*Exceptions:
*       none
*
*******************************************************************************/

char * __cdecl _GET_RTERRMSG (
        int rterrnum
        )
{
        int tblindx;

        for ( tblindx = 0 ; tblindx < _RTERRCNT ; tblindx++ )
            if ( rterrnum == rterrs[tblindx].rterrno )
                return rterrs[tblindx].rterrtxt;

        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crt0dat.c ===
/***
*crt0dat.c - 32-bit C run-time initialization/termination routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the routines _cinit, exit, and _exit
*       for C run-time startup and termination.  _cinit and exit
*       are called from the _astart code in crt0.asm.
*       This module also defines several data variables used by the
*       runtime.
*
*       [NOTE: Lock segment definitions are at end of module.]
*
*******************************************************************************/

#include <cruntime.h>
#include <msdos.h>
#include <rtcapi.h>
#include <dos.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <dbgint.h>
#include <sect_attribs.h>
#include <mbctype.h>
#include <mbdata.h>

/* define errno */




/* define umask */
int _umaskval = 0;


/* argument vector and environment */

_CRTIMP int __argc = 0;
_CRTIMP char **__argv = NULL;
_CRTIMP wchar_t **__wargv = NULL;
_CRTIMP char **_environ = NULL;
_CRTIMP char **__initenv = NULL;
_CRTIMP wchar_t **_wenviron = NULL;
_CRTIMP wchar_t **__winitenv = NULL;
_CRTIMP char *_pgmptr = NULL;           /* ptr to program name */
_CRTIMP wchar_t *_wpgmptr = NULL;       /* ptr to wide program name */

void (__cdecl * _aexit_rtn)(int) = _exit;   /* RT message return procedure */


/* callable exit flag */
char _exitflag = 0;

/*
 * flag indicating if C runtime termination has been done. set if exit,
 * _exit, _cexit or _c_exit has been called. checked when _CRTDLL_INIT
 * is called with DLL_PROCESS_DETACH.
 */
int _C_Termination_Done = FALSE;
int _C_Exit_Done = FALSE;

#ifndef CRTDLL
/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
int __env_initialized;

#endif  /* CRTDLL */

#ifdef _MBCS
/*
 * Flag to ensure multibyte ctype table is only initialized once
 */
int __mbctype_initialized;
#endif  /* _MBCS */


/*
 * NOTE: THE USE OF THE POINTERS DECLARED BELOW DEPENDS ON THE PROPERTIES
 * OF C COMMUNAL VARIABLES. SPECIFICALLY, THEY ARE NON-NULL IFF THERE EXISTS
 * A DEFINITION ELSEWHERE INITIALIZING THEM TO NON-NULL VALUES.
 */

/*
 * pointers to initialization functions
 */

#ifndef CRTDLL
const _PVFI _FPinit;                            /* floating point init. */
#endif  /* CRTDLL */

/*
 * pointers to initialization sections
 */

extern _CRTALLOC(".CRT$XIA") _PIFV __xi_a[];
extern _CRTALLOC(".CRT$XIZ") _PIFV __xi_z[];    /* C initializers */
extern _CRTALLOC(".CRT$XCA") _PVFV __xc_a[];
extern _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[];    /* C++ initializers */
extern _CRTALLOC(".CRT$XPA") _PVFV __xp_a[];
extern _CRTALLOC(".CRT$XPZ") _PVFV __xp_z[];    /* C pre-terminators */
extern _CRTALLOC(".CRT$XTA") _PVFV __xt_a[];
extern _CRTALLOC(".CRT$XTZ") _PVFV __xt_z[];    /* C terminators */

/*
 * pointers to the start and finish of the _onexit/atexit table
 * NOTE - the pointers are stored encoded.
 */
_PVFV *__onexitbegin;
_PVFV *__onexitend;

/*
 * Pointer to callback function to initialize any dynamically initialized
 * __declspec(thread) variables.  This relies on a subtle aspect of C.
 * The pointer is defined here uninitialized.  It is defined initialized in
 * tlsdyn.c.  If user code uses dynamically initialized __declspec(thread)
 * variables, then compiler-injected dependencies cause tlsdyn.obj to be
 * linked.  In that case, the non-zero definition of __dyn_tls_init_callback
 * in tlsdyn.obj will take precedence, and the startup code will execute the
 * callback.  This use of multiple definitions is only legal in C, not C++.
 */

#ifndef CRTDLL
const PIMAGE_TLS_CALLBACK __dyn_tls_init_callback;
#endif  /* CRTDLL */

/*
 * static (internal) functions that walk a table of function pointers,
 * calling each entry between the two pointers, skipping NULL entries
 *
 * _initterm needs to be exported for CRT DLL so that C++ initializers in the
 * client EXE / DLLs can be initialized.
 *
 * _initterm_e calls function pointers that return a nonzero error code to
 * indicate an initialization failed fatally.
 */
#ifdef CRTDLL
void __cdecl _initterm(_PVFV *, _PVFV *);
#else  /* CRTDLL */
static void __cdecl _initterm(_PVFV *, _PVFV *);
#endif  /* CRTDLL */
int  __cdecl _initterm_e(_PIFV *, _PIFV *);


#define INCR_WAIT                          1000
#define _MAX_WAIT_MALLOC_CRT 60000

// _crt_waiting_on_module_handle is only called if GetModuleHandleW in _crt_wait_module_handle fails.
__declspec(noinline)  HMODULE _crt_waiting_on_module_handle(LPCWSTR szModuleName)
{
        unsigned long nWaitTime = INCR_WAIT;
        HMODULE hMod = NULL;

        while(hMod == NULL)
        {
                Sleep(nWaitTime);
                hMod = GetModuleHandleW(szModuleName);
                nWaitTime += INCR_WAIT;
                if(nWaitTime > _MAX_WAIT_MALLOC_CRT)
                {
                        break;
                }
        }
        return hMod;
}

#ifdef CRTDLL


/*
    Copied from dllstuff\crtexe.c.
*/

/***
*check_managed_app() - Check for a managed executable
*
*Purpose:
*       Determine if the EXE the startup code is linked into is a managed app
*       by looking for the COM Runtime Descriptor in the Image Data Directory
*       of the PE or PE+ header.
*
*Entry:
*       None
*
*Exit:
*       1 if managed app, 0 if not.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl check_managed_app (
        void
        )
{
        PIMAGE_DOS_HEADER pDOSHeader;
        PIMAGE_NT_HEADERS pPEHeader;
        PIMAGE_OPTIONAL_HEADER32 pNTHeader32;
        PIMAGE_OPTIONAL_HEADER64 pNTHeader64;

        pDOSHeader = (PIMAGE_DOS_HEADER)GetModuleHandleW(NULL);
        if ( pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE )
            return 0;

        pPEHeader = (PIMAGE_NT_HEADERS)((char *)pDOSHeader +
                                        pDOSHeader->e_lfanew);
        if ( pPEHeader->Signature != IMAGE_NT_SIGNATURE )
            return 0;

        pNTHeader32 = (PIMAGE_OPTIONAL_HEADER32)&pPEHeader->OptionalHeader;
        switch ( pNTHeader32->Magic ) {
        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
            /* PE header */
            /* prefast assumes we are overflowing __ImageBase */
#pragma warning(push)
#pragma warning(disable:26000)
            if ( pNTHeader32->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
#pragma warning(pop)
            return !! pNTHeader32 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
            /* PE+ header */
            pNTHeader64 = (PIMAGE_OPTIONAL_HEADER64)pNTHeader32;
            if ( pNTHeader64->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
            return !! pNTHeader64 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        }

        /* Not PE or PE+, so not managed */
        return 0;
}

#endif  /* CRTDLL */
/***
*_cinit - C initialization
*
*Purpose:
*       This routine performs the shared DOS and Windows initialization.
*       The following order of initialization must be preserved -
*
*       1.  Check for devices for file handles 0 - 2
*       2.  Integer divide interrupt vector setup
*       3.  General C initializer routines
*
*Entry:
*       No parameters: Called from __crtstart and assumes data
*       set up correctly there.
*
*Exit:
*       Initializes C runtime data.
*       Returns 0 if all .CRT$XI internal initializations succeeded, else
*       the _RT_* fatal error code encountered.
*
*Exceptions:
*
*******************************************************************************/

#ifndef CRTDLL
extern void __cdecl _initp_misc_cfltcvt_tab();
#endif  /* CRTDLL */

int __cdecl _cinit (
        int initFloatingPrecision
        )
{
        int initret;

        /*
         * initialize floating point package, if present
         */
#ifdef CRTDLL
        _fpmath(initFloatingPrecision);
#else  /* CRTDLL */
        if (_FPinit != NULL &&
            _IsNonwritableInCurrentImage((PBYTE)&_FPinit))
        {
            (*_FPinit)(initFloatingPrecision);
        }
        _initp_misc_cfltcvt_tab();
#endif  /* CRTDLL */

        /*
         * do initializations
         */
        initret = _initterm_e( __xi_a, __xi_z );
        if ( initret != 0 )
            return initret;

#ifdef _RTC
        atexit(_RTC_Terminate);
#endif  /* _RTC */
        /*
         * do C++ initializations
         */
        _initterm( __xc_a, __xc_z );

#ifndef CRTDLL
        /*
         * If we have any dynamically initialized __declspec(thread)
         * variables, then invoke their initialization for the thread on
         * which the DLL is being loaded, by calling __dyn_tls_init through
         * a callback defined in tlsdyn.obj.  We can't rely on the OS
         * calling __dyn_tls_init with DLL_PROCESS_ATTACH because, on
         * Win2K3 and before, that call happens before the CRT is
         * initialized.
         */
        if (__dyn_tls_init_callback != NULL &&
            _IsNonwritableInCurrentImage((PBYTE)&__dyn_tls_init_callback))
        {
            __dyn_tls_init_callback(NULL, DLL_THREAD_ATTACH, NULL);
        }
#endif  /* CRTDLL */

        return 0;
}


/***
*exit(status), _exit(status), _cexit(void), _c_exit(void) - C termination
*
*Purpose:
*
*       Entry points:
*
*           exit(code):  Performs all the C termination functions
*               and terminates the process with the return code
*               supplied by the user.
*
*           _exit(code):  Performs a quick exit routine that does not
*               do certain 'high-level' exit processing.  The _exit
*               routine terminates the process with the return code
*               supplied by the user.
*
*           _cexit():  Performs the same C lib termination processing
*               as exit(code) but returns control to the caller
*               when done (i.e., does NOT terminate the process).
*
*           _c_exit():  Performs the same C lib termination processing
*               as _exit(code) but returns control to the caller
*               when done (i.e., does NOT terminate the process).
*
*       Termination actions:
*
*           exit(), _cexit():
*
*           1.  call user's terminator routines
*           2.  call C runtime preterminators
*
*           _exit(), _c_exit():
*
*           3.  call C runtime terminators
*           4.  return to DOS or caller
*
*       Notes:
*
*       The termination sequence is complicated due to the multiple entry
*       points sharing the common code body while having different entry/exit
*       sequences.
*
*       Multi-thread notes:
*
*       1. exit() should NEVER be called when mthread locks are held.
*          The exit() routine can make calls that try to get mthread locks.
*
*       2. _exit()/_c_exit() can be called from anywhere, with or without locks held.
*          Thus, _exit() can NEVER try to get locks (otherwise, deadlock
*          may occur).  _exit() should always 'work' (i.e., the process
*          should always terminate successfully).
*
*       3. Only one thread is allowed into the exit code (see _lockexit()
*          and _unlockexit() routines).
*
*Entry:
*       exit(), _exit()
*           int status - exit status (0-255)
*
*       _cexit(), _c_exit()
*           <no input>
*
*Exit:
*       exit(), _exit()
*           <EXIT to DOS>
*
*       _cexit(), _c_exit()
*           Return to caller
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

/* worker routine prototype */
static void __cdecl doexit (int code, int quick, int retcaller);

void __cdecl exit (
        int code
        )
{
        doexit(code, 0, 0); /* full term, kill process */
}


void __cdecl _exit (
        int code
        )
{
        doexit(code, 1, 0); /* quick term, kill process */
}

void __cdecl _cexit (
        void
        )
{
        doexit(0, 0, 1);    /* full term, return to caller */
}

void __cdecl _c_exit (
        void
        )
{
        doexit(0, 1, 1);    /* quick term, return to caller */
}


/***
*_amsg_exit(rterrnum) - Fast exit fatal errors
*
*Purpose:
*       Exit the program with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls exit() (for integer divide-by-0) or _exit() indirectly
*       through _aexit_rtn [amsg_exit].
*       For multi-thread: calls _exit() function
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _amsg_exit (
        int rterrnum
        )
{
        void(__cdecl *ertn)(int);

        _FF_MSGBANNER();    /* write run-time error banner */
        _NMSG_WRITE(rterrnum);  /* write message */
        ertn = (void(__cdecl*)(int)) _decode_pointer(_aexit_rtn);
        ertn(255);        /* normally _exit(255) */
}


#ifdef _DEBUG
/***
* __freeCrtMemory()
*
* Purpose:
*       To free as much as CRT memory as possible. This helps in keeping CRT leaks as
*       minimum.
*
*******************************************************************************/
void __cdecl __freeCrtMemory()
{
    void **pptr;
    for (pptr = _wenviron; pptr != NULL && *pptr != NULL; ++pptr) {
        _free_crt(*pptr);
    }
    _free_crt(_wenviron);
    _wenviron = NULL;
    pptr = _environ;
    for (; pptr != NULL && *pptr != NULL; ++pptr) {
        _free_crt(*pptr);
    }
    _free_crt(_environ);
    _environ = NULL;
    _free_crt(__wargv);
    _free_crt(__argv);
    _free_crt(_decode_pointer(__onexitbegin));
    __wargv = NULL;
    __argv = NULL;
    __onexitbegin = (_PVFV *)_encoded_null();
    if (InterlockedDecrement(&(__ptmbcinfo->refcount)) == 0 && __ptmbcinfo != &__initialmbcinfo)
    {
        _free_crt(__ptmbcinfo);
        __ptmbcinfo = &__initialmbcinfo;
    }
    InterlockedIncrement(&(__ptmbcinfo->refcount));
}
#endif  /* _DEBUG */

static void __cdecl doexit (
        int code,
        int quick,
        int retcaller
        )
{
#ifdef _DEBUG
        static int fExit = 0;
#endif  /* _DEBUG */

#ifdef CRTDLL
        if (!retcaller && check_managed_app())
        {
            /*
               Only if the EXE is managed then we call CorExitProcess.
               Native cleanup is done in .cctor of the EXE
               If the Exe is Native then native clean up should be done
               before calling (Cor)ExitProcess.
            */
            __crtCorExitProcess(code);
        }
#endif  /* CRTDLL */

        _lockexit();        /* assure only 1 thread in exit path */
        __TRY

        if (_C_Exit_Done != TRUE) {
            _C_Termination_Done = TRUE;

            /* save callable exit flag (for use by terminators) */
            _exitflag = (char) retcaller;  /* 0 = term, !0 = callable exit */

            if (!quick) {

                /*
                 * do _onexit/atexit() terminators
                 * (if there are any)
                 *
                 * These terminators MUST be executed in reverse order (LIFO)!
                 *
                 * NOTE:
                 *  This code assumes that __onexitbegin points
                 *  to the first valid onexit() entry and that
                 *  __onexitend points past the last valid entry.
                 *  If __onexitbegin == __onexitend, the table
                 *  is empty and there are no routines to call.
                 */

                _PVFV * onexitbegin = (_PVFV *)_decode_pointer(__onexitbegin);
                if (onexitbegin) {
                    _PVFV * onexitend = (_PVFV *)_decode_pointer(__onexitend);
                    _PVFV function_to_call = NULL;

                    /* save the start and end for later comparison */
                    _PVFV * onexitbegin_saved = onexitbegin;
                    _PVFV * onexitend_saved = onexitend;

                    while (1)
                    {
                        _PVFV * onexitbegin_new = NULL;
                        _PVFV * onexitend_new = NULL;

                        /* find the last valid function pointer to call. */
                        while (--onexitend >= onexitbegin && *onexitend == _encoded_null())
                        {
                            /* keep going backwards. */
                        }

                        if (onexitend < onexitbegin)
                        {
                            /* there are no more valid entries in the list, we are done. */
                            break;
                        }

                        /* cache the function to call. */
                        function_to_call = (_PVFV)_decode_pointer(*onexitend);

                        /* mark the function pointer as visited. */
                        *onexitend = (_PVFV)_encoded_null();

                        /* call the function, which can eventually change __onexitbegin and __onexitend */
                        (*function_to_call)();

                        onexitbegin_new = (_PVFV *)_decode_pointer(__onexitbegin);
                        onexitend_new = (_PVFV *)_decode_pointer(__onexitend);

                        if ( ( onexitbegin_saved != onexitbegin_new ) || ( onexitend_saved != onexitend_new ) )
                        {
                            /* reset only if either start or end has changed */
                            onexitbegin = onexitbegin_saved = onexitbegin_new;
                            onexitend = onexitend_saved = onexitend_new;
                        }
                    }
                }
#ifndef CRTDLL
                /*
                 * do pre-terminators
                 */
                _initterm(__xp_a, __xp_z);
#endif  /* CRTDLL */
            }

#ifndef CRTDLL
            /*
             * do terminators
             */
            _initterm(__xt_a, __xt_z);
#endif  /* CRTDLL */

#ifdef _DEBUG
            /* Dump all memory leaks */
            if (!fExit && _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
            {
                fExit = 1;
#ifndef CRTDLL
                __freeCrtMemory();
                _CrtDumpMemoryLeaks();
#endif  /* CRTDLL */
            }
#endif  /* _DEBUG */

        }
        /* return to OS or to caller */

        __FINALLY
            if (retcaller)
                _unlockexit();      /* unlock the exit code path */
        __END_TRY_FINALLY
        if (retcaller)
            return;


        _C_Exit_Done = TRUE;

        _unlockexit();      /* unlock the exit code path */

        __crtExitProcess(code);
}

#ifdef CRTDLL
/***
* __crtdll_callstaticterminators
*
*Purpose:
*       call terminators. This is called from CRT_INIT when dll entrypoint is
*       called with DLL_PROCESS_DETACH. We can't call the terminators from exit
*       as there may be some dll that may need crt functionality during
*       DLL_PROCESS_DETACH
*
*******************************************************************************/
void __crtdll_callstaticterminators(void) {
    /*
     * do pre-terminators
     */
    _initterm(__xp_a, __xp_z);

    /*
     * do terminators
     */
    _initterm(__xt_a, __xt_z);
}
#endif  /* CRTDLL */
/***
* __crtCorExitProcess - CRT wrapper for CorExitProcess
* __crtExitProcess - CRT wrapper for ExitProcess
*
*Purpose:
*       If we're part of a managed app, then call the CorExitProcess,
*       otherwise call ExitProcess.  For managed apps, calling ExitProcess can
*       be problematic, because it doesn't give the managed FinalizerThread a
*       chance to clean up.
*
*       To determine if we're a managed app, we check if mscoree.dll is loaded.
*       Then, if CorExitProcess is available, we call it.
*
*Entry:
*       int status - exit code
*
*Exit:
*       Does not return
*
*Exceptions:
*
*******************************************************************************/

typedef void (WINAPI * PFN_EXIT_PROCESS)(UINT uExitCode);

void __cdecl __crtCorExitProcess (
        int status
        )
{
        HMODULE hmod;
        PFN_EXIT_PROCESS pfn;

        hmod = GetModuleHandleW(L"mscoree.dll");
        if (hmod != NULL) {
            pfn = (PFN_EXIT_PROCESS)GetProcAddress(hmod, "CorExitProcess");
            if (pfn != NULL) {
                pfn(status);
            }
        }

        /*
         * Either mscoree.dll isn't loaded,
         * or CorExitProcess isn't exported from mscoree.dll,
         * or CorExitProcess returned (should never happen).
         * Just call return.
         */
}

void __cdecl __crtExitProcess (
        int status
        )
{
        __crtCorExitProcess(status);

        /*
         * Either mscoree.dll isn't loaded,
         * or CorExitProcess isn't exported from mscoree.dll,
         * or CorExitProcess returned (should never happen).
         * Just call ExitProcess.
         */

        ExitProcess(status);
}


/***
* _lockexit - Aquire the exit code lock
*
*Purpose:
*       Makes sure only one thread is in the exit code at a time.
*       If a thread is already in the exit code, it must be allowed
*       to continue.  All other threads must pend.
*
*       Notes:
*
*       (1) It is legal for a thread that already has the lock to
*       try and get it again(!).  That is, consider the following
*       sequence:
*
*           (a) program calls exit()
*           (b) thread locks exit code
*           (c) user onexit() routine calls _exit()
*           (d) same thread tries to lock exit code
*
*       Since _exit() must ALWAYS be able to work (i.e., can be called
*       from anywhere with no regard for locking), we must make sure the
*       program does not deadlock at step (d) above.
*
*       (2) If a thread executing exit() or _exit() aquires the exit lock,
*       other threads trying to get the lock will pend forever.  That is,
*       since exit() and _exit() terminate the process, there is not need
*       for them to unlock the exit code path.
*
*       (3) Note that onexit()/atexit() routines call _lockexit/_unlockexit
*       to protect mthread access to the onexit table.
*
*       (4) The 32-bit OS semaphore calls DO allow a single thread to acquire
*       the same lock multiple times* thus, this version is straight forward.
*
*Entry: <none>
*
*Exit:
*       Calling thread has exit code path locked on return.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _lockexit (
        void
        )
{
        _mlock(_EXIT_LOCK1);
}

/***
* _unlockexit - Release exit code lock
*
*Purpose:
*       [See _lockexit() description above.]
*
*       This routine is called by _cexit(), _c_exit(), and onexit()/atexit().
*       The exit() and _exit() routines never unlock the exit code path since
*       they are terminating the process.
*
*Entry:
*       Exit code path is unlocked.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _unlockexit (
        void
        )
{
        _munlock(_EXIT_LOCK1);
}


/***
*_init_pointers() - initialize global function pointers with OS encoded values
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

extern void __cdecl _initp_eh_hooks(void*);
extern void __cdecl _initp_heap_handler(void*);
extern void __cdecl _initp_misc_initcrit(void*);
extern void __cdecl _initp_misc_invarg(void*);
extern void __cdecl _initp_misc_purevirt(void*);
extern void __cdecl _initp_misc_rand_s(void*);
extern void __cdecl _initp_misc_winsig(void*);
extern void __cdecl _initp_misc_winxfltr(void*);

void __cdecl _init_pointers() {
        void *enull = _encoded_null();

        _initp_heap_handler(enull);
        _initp_misc_initcrit(enull);
        _initp_misc_invarg(enull);
        _initp_misc_purevirt(enull);
        _initp_misc_rand_s(enull);
        _initp_misc_winsig(enull);
        _initp_misc_winxfltr(enull);
        _initp_eh_hooks(enull);

        /* startup\crt0dat.c */
         _aexit_rtn = (void(__cdecl*)(int)) _encode_pointer(_exit);
}

/***
* static void _initterm(_PVFV * pfbegin, _PVFV * pfend) - call entries in
*       function pointer table
*
*Purpose:
*       Walk a table of function pointers, calling each entry, as follows:
*
*           1. walk from beginning to end, pfunctbl is assumed to point
*              to the beginning of the table, which is currently a null entry,
*              as is the end entry.
*           2. skip NULL entries
*           3. stop walking when the end of the table is encountered
*
*Entry:
*       _PVFV *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PVFV *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       No return value
*
*Notes:
*       This routine must be exported in the CRT DLL model so that the client
*       EXE and client DLL(s) can call it to initialize their C++ constructors.
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

#ifdef CRTDLL
void __cdecl _initterm (
#else  /* CRTDLL */
static void __cdecl _initterm (
#endif  /* CRTDLL */
        _PVFV * pfbegin,
        _PVFV * pfend
        )
{
        /*
         * walk the table of function pointers from the bottom up, until
         * the end is encountered.  Do not skip the first entry.  The initial
         * value of pfbegin points to the first valid entry.  Do not try to
         * execute what pfend points to.  Only entries before pfend are valid.
         */
        while ( pfbegin < pfend )
        {
            /*
             * if current table entry is non-NULL, call thru it.
             */
            if ( *pfbegin != NULL )
                (**pfbegin)();
            ++pfbegin;
        }
}

/***
* static int  _initterm_e(_PIFV * pfbegin, _PIFV * pfend) - call entries in
*       function pointer table, return error code on any failure
*
*Purpose:
*       Walk a table of function pointers in the same way as _initterm, but
*       here the functions return an error code.  If an error is returned, it
*       will be a nonzero value equal to one of the _RT_* codes.
*
*Entry:
*       _PIFV *pfbegin  - pointer to the beginning of the table (first
*                         valid entry).
*       _PIFV *pfend    - pointer to the end of the table (after last
*                         valid entry).
*
*Exit:
*       No return value
*
*Notes:
*       This routine must be exported in the CRT DLL model so that the client
*       EXE and client DLL(s) can call it.
*
*Exceptions:
*       If either pfbegin or pfend is NULL, or invalid, all bets are off!
*
*******************************************************************************/

int __cdecl _initterm_e (
        _PIFV * pfbegin,
        _PIFV * pfend
        )
{
        int ret = 0;

        /*
         * walk the table of function pointers from the bottom up, until
         * the end is encountered.  Do not skip the first entry.  The initial
         * value of pfbegin points to the first valid entry.  Do not try to
         * execute what pfend points to.  Only entries before pfend are valid.
         */
        while ( pfbegin < pfend  && ret == 0)
        {
            /*
             * if current table entry is non-NULL, call thru it.
             */
            if ( *pfbegin != NULL )
                ret = (**pfbegin)();
            ++pfbegin;
        }

        return ret;
}

/***
*errno_t _get_wpgmptr() - get _wpgmptr, i.e. the module (EXE) wide name
*
*Purpose:
*       Get the value of _wpgmptr
*
*Entry:
*       wchar_t **pValue - pointer where to store the value
*
*Exit:
*       The error code
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
errno_t _get_wpgmptr(wchar_t **pValue)
{
    /* validation section */
    _VALIDATE_RETURN_ERRCODE(pValue != NULL, EINVAL);

_BEGIN_SECURE_CRT_DEPRECATION_DISABLE

    _VALIDATE_RETURN_ERRCODE(_wpgmptr != NULL, EINVAL);

    *pValue = _wpgmptr;
_END_SECURE_CRT_DEPRECATION_DISABLE
    return 0;
}

/***
*errno_t _get_pgmptr() - get _pgmptr, i.e. the module (EXE) name
*
*Purpose:
*       Get the value of _pgmptr
*
*Entry:
*       char **pValue - pointer where to store the value
*
*Exit:
*       The error code
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
errno_t _get_pgmptr(char **pValue)
{
    /* validation section */
    _VALIDATE_RETURN_ERRCODE(pValue != NULL, EINVAL);

_BEGIN_SECURE_CRT_DEPRECATION_DISABLE

    _VALIDATE_RETURN_ERRCODE(_pgmptr != NULL, EINVAL);

    *pValue = _pgmptr;
_END_SECURE_CRT_DEPRECATION_DISABLE
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\creat.c ===
/***
*creat.c - create a new file or truncate existing file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _creat() - create new file
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <fcntl.h>
#include <share.h>
#include <tchar.h>

/***
*int _creat(path, pmode) - create a new file
*
*Purpose:
*       If file specified does not exist, _creat creates a new file
*       with the given permission setting and opens it for writing.
*       If the file already exists and its permission allows writing,
*       _creat truncates it to 0 length and open it for writing.
*       The only Xenix mode bit supprted by DOS is user write (S_IWRITE).
*
*Entry:
*       _TSCHAR *path - filename to create
*       int pmode - permission mode setting for new file
*
*Exit:
*       returns handle for created file
*       returns -1 and sets errno if fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _tcreat (
        const _TSCHAR *path,
        int pmode
        )
{
        /* creat is just the same as open... */
        int fh = -1;
        errno_t e = _tsopen_s(&fh, path, _O_CREAT + _O_TRUNC + _O_RDWR, _SH_DENYNO, pmode);
        return (e == 0 ? fh : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtexew.c ===
/***
*crtexew.c - Initialization for Windows EXE using CRT DLL
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for Windows apps.  It calls the
*       user's main routine WinMain() after performing C Run-Time Library
*       initialization.
*
*******************************************************************************/

#ifdef CRTDLL

#define _WINMAIN_
#include "crtexe.c"

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crt0.c ===
/***
*crt0.c - C runtime initialization routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps.  It calls the user's main
*       routine [w]main() or [w]WinMain after performing C Run-Time Library
*       initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrt0.c     the startup routine for console apps with wide chars
*       wincrt0.c   the startup routine for Windows apps
*       wwincrt0.c  the startup routine for Windows apps with wide chars
*
*******************************************************************************/

#ifndef CRTDLL

#include <cruntime.h>
#include <dos.h>
#include <internal.h>
#include <process.h>
#include <stdlib.h>
#include <string.h>
#include <rterr.h>
#include <rtcapi.h>
#include <windows.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>
#include <locale.h>
#include <sect_attribs.h>

#if defined (_WIN64) && defined (_M_IA64)
#pragma section(".base", long, read)
__declspec(allocate(".base"))
extern
IMAGE_DOS_HEADER __ImageBase;
#else  /* defined (_WIN64) && defined (_M_IA64) */
extern
IMAGE_DOS_HEADER __ImageBase;
#endif  /* defined (_WIN64) && defined (_M_IA64) */

/*
 * This has been moved from unhandld.cpp to here because, we only
 * want to set the UnhandledExceptionFilter when this crt is loaded
 * by an EXE (ie. not loaded by a DLL)
 */
int  __cdecl __CxxSetUnhandledExceptionFilter(void);
_CRTALLOC(".CRT$XIY") static _PIFV pinit = &__CxxSetUnhandledExceptionFilter;

#ifdef WPRFLAG
_TUCHAR * __cdecl _wwincmdln(void);
#else  /* WPRFLAG */
_TUCHAR * __cdecl _wincmdln(void);
#endif  /* WPRFLAG */

/*
 * command line, environment, and a few other globals
 */

#ifdef WPRFLAG
wchar_t *_wcmdln;           /* points to wide command line */
#else  /* WPRFLAG */
char *_acmdln;              /* points to command line */
#endif  /* WPRFLAG */

char *_aenvptr = NULL;      /* points to environment block */
wchar_t *_wenvptr = NULL;   /* points to wide environment block */


static void __cdecl fast_error_exit(int);   /* Error exit via ExitProcess */

static int __cdecl check_managed_app(void); /* Determine if a managed app */

/*
 * _error_mode and _apptype, together, determine how error messages are
 * written out.
 */
int __error_mode = _OUT_TO_DEFAULT;
#ifdef _WINMAIN_
int __app_type = _GUI_APP;
#else  /* _WINMAIN_ */
int __app_type = _CONSOLE_APP;
#endif  /* _WINMAIN_ */


/***
*mainCRTStartup(void)
*wmainCRTStartup(void)
*WinMainCRTStartup(void)
*wWinMainCRTStartup(void)
*
*Purpose:
*       These routines do the C runtime initialization, call the appropriate
*       user entry function, and handle termination cleanup.  For a managed
*       app, they then return the exit code back to the calling routine, which
*       is the managed startup code.  For an unmanaged app, they call exit and
*       never return.
*
*       Function:               User entry called:
*       mainCRTStartup          main
*       wmainCRTStartup         wmain
*       WinMainCRTStartup       WinMain
*       wWinMainCRTStartup      wWinMain
*
*Entry:
*
*Exit:
*       Managed app: return value from main() et al, or the exception code if
*                 execution was terminated by the __except guarding the call
*                 to main().
*       Unmanaged app: never return.
*
*******************************************************************************/

#ifdef _WINMAIN_

#ifdef WPRFLAG
#define _tmainCRTStartup    wWinMainCRTStartup
#else  /* WPRFLAG */
#define _tmainCRTStartup    WinMainCRTStartup
#endif  /* WPRFLAG */

#else  /* _WINMAIN_ */

#ifdef WPRFLAG
#define _tmainCRTStartup    wmainCRTStartup
#else  /* WPRFLAG */
#define _tmainCRTStartup    mainCRTStartup
#endif  /* WPRFLAG */

#endif  /* _WINMAIN_ */

#ifdef WPRFLAG

#define _twincmdln  _wwincmdln
#define _tinitenv   __winitenv
#define _targv      __wargv
#define _tcmdln     _wcmdln
#define _tenvptr    _wenvptr
#define _tsetargv   _wsetargv
#define _tsetenvp   _wsetenvp
#define GetCommandLineT         __crtGetCommandLineW
#define GetEnvironmentStringsT  __crtGetEnvironmentStringsW

#else  /* WPRFLAG */

#define _twincmdln  _wincmdln
#define _tinitenv   __initenv
#define _targv      __argv
#define _tcmdln     _acmdln
#define _tenvptr    _aenvptr
#define _tsetargv   _setargv
#define _tsetenvp   _setenvp
#define GetCommandLineT         GetCommandLineA
#define GetEnvironmentStringsT  __crtGetEnvironmentStringsA

#endif  /* WPRFLAG */

static
int
__tmainCRTStartup(
         void
         );

int
_tmainCRTStartup(
        void
        )
{
        /*
         * The /GS security cookie must be initialized before any exception
         * handling targetting the current image is registered.  No function
         * using exception handling can be called in the current image until
         * after __security_init_cookie has been called.
         */
        __security_init_cookie();

        return __tmainCRTStartup();
}

__declspec(noinline)
int
__tmainCRTStartup(
         void
         )
{
        int initret;
        int mainret=0;
        int managedapp;
#ifdef _WINMAIN_
        _TUCHAR *lpszCommandLine;
        STARTUPINFO StartupInfo;

        __try {
            /*
            Note: MSDN specifically notes that GetStartupInfo returns no error, and throws unspecified SEH if it fails, so
            the very general exception handler below is appropriate
            */
            GetStartupInfo( &StartupInfo );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return 255;
        }
#endif  /* _WINMAIN_ */
        /*
         * Determine if this is a managed application
         */
        managedapp = check_managed_app();

        if ( !_heap_init(1) )               /* initialize heap */
            fast_error_exit(_RT_HEAPINIT);  /* write message and die */

        if( !_mtinit() )                    /* initialize multi-thread */
            fast_error_exit(_RT_THREAD);    /* write message and die */

        /* Enable buffer count checking if linking against static lib */
        _CrtSetCheckCount(TRUE);

        /*
         * Initialize the Runtime Checks stuff
         */
#ifdef _RTC
        _RTC_Initialize();
#endif  /* _RTC */
        /*
         * Guard the remainder of the initialization code and the call
         * to user's main, or WinMain, function in a __try/__except
         * statement.
         */

        __try {

            if ( _ioinit() < 0 )            /* initialize lowio */
                _amsg_exit(_RT_LOWIOINIT);

            /* get wide cmd line info */
            _tcmdln = (_TSCHAR *)GetCommandLineT();

            /* get wide environ info */
            _tenvptr = (_TSCHAR *)GetEnvironmentStringsT();

            if ( _tsetargv() < 0 )
                _amsg_exit(_RT_SPACEARG);
            if ( _tsetenvp() < 0 )
                _amsg_exit(_RT_SPACEENV);

            initret = _cinit(TRUE);                  /* do C data initialize */
            if (initret != 0)
                _amsg_exit(initret);

#ifdef _WINMAIN_


            lpszCommandLine = _twincmdln();
            mainret = _tWinMain( (HINSTANCE)&__ImageBase,
                                 NULL,
                                 lpszCommandLine,
                                 StartupInfo.dwFlags & STARTF_USESHOWWINDOW
                                      ? StartupInfo.wShowWindow
                                      : SW_SHOWDEFAULT
                                );
#else  /* _WINMAIN_ */
            _tinitenv = _tenviron;
            mainret = _tmain(__argc, _targv, _tenviron);
#endif  /* _WINMAIN_ */

            if ( !managedapp )
                exit(mainret);

            _cexit();

        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
            /*
             * Should never reach here
             */

            mainret = GetExceptionCode();

            if ( !managedapp )
                _exit(mainret);

            _c_exit();

        } /* end of try - except */

        return mainret;
}


/***
*fast_error_exit(rterrnum) - Faster exit fatal errors
*
*Purpose:
*       Exit the process with error code of 255 and appropriate error
*       message.
*
*Entry:
*       int rterrnum - error message number (amsg_exit only).
*
*Exit:
*       Calls ExitProcess (through __crtExitProcess).
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl fast_error_exit (
        int rterrnum
        )
{
    /*
     * Note that here there is no other option other then to use __error_mode
     * as even if we use _set_error_mode, there is very slim possiblity if
     * proper _ser_error_mode forwarding is really working.
     */
#ifdef _WINMAIN_
        if ( __error_mode == _OUT_TO_STDERR )
#else  /* _WINMAIN_ */
        if ( __error_mode != _OUT_TO_MSGBOX )
#endif  /* _WINMAIN_ */
            _FF_MSGBANNER();    /* write run-time error banner */

        _NMSG_WRITE(rterrnum);  /* write message */
        __crtExitProcess(255);  /* normally _exit(255) */
}

/***
*check_managed_app() - Check for a managed executable
*
*Purpose:
*       Determine if the EXE the startup code is linked into is a managed app
*       by looking for the COM Runtime Descriptor in the Image Data Directory
*       of the PE or PE+ header.
*
*Entry:
*       None
*
*Exit:
*       1 if managed app, 0 if not.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl check_managed_app (
        void
        )
{
        PIMAGE_DOS_HEADER pDOSHeader;
        PIMAGE_NT_HEADERS pPEHeader;

        pDOSHeader = &__ImageBase;
        if ( pDOSHeader == NULL || pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE )
            return 0;

        pPEHeader = (PIMAGE_NT_HEADERS)((char *)pDOSHeader +
                                        pDOSHeader->e_lfanew);

        if ( pPEHeader->Signature != IMAGE_NT_SIGNATURE )
            return 0;

        if (pPEHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)
            return 0;

        /* prefast assumes we are overflowing __ImageBase */
#pragma warning(push)
#pragma warning(disable:26000)
        if (pPEHeader->OptionalHeader.NumberOfRvaAndSizes <= IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR)
            return 0;
#pragma warning(push)

        return pPEHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR].VirtualAddress != 0;
}

#ifndef WPRFLAG


#endif  /* WPRFLAG */

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtheap.c ===
/***
*crtheap.c - Get a block of memory from the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _malloc_crt(), _calloc_crt(), _realloc_crt() function.
*
*******************************************************************************/
#include <malloc.h>
#include <windows.h>

#define INCR_WAIT 1000

unsigned long _maxwait = 0;

__forceinline unsigned long wait_a_bit(unsigned long WaitTime)
{
     Sleep(WaitTime);
     WaitTime += INCR_WAIT;
     if (WaitTime > _maxwait)      // ~30 minutes total
         WaitTime = -1;
     return WaitTime;
}

#ifdef _SYSCRT
#undef _CRTIMP
#define _CRTIMP
#endif  /* _SYSCRT */

_CRTIMP unsigned long __cdecl _set_malloc_crt_max_wait(unsigned long newvalue)
{
    unsigned long oldvalue = _maxwait;
    _maxwait = newvalue;
    return oldvalue;
}

_CRTIMP void * __cdecl _malloc_crt(size_t cb)
{
    unsigned long WaitTime = 0;
    void *pv;

Retry:
    pv = malloc(cb);
    if (!pv && _maxwait > 0) {
        WaitTime = wait_a_bit(WaitTime);
        if (WaitTime != -1)
            goto Retry;
    }
    return pv;
}

_CRTIMP void * __cdecl _calloc_crt(size_t count, size_t size)
{
    unsigned long WaitTime = 0;
    void *pv;

    extern void * __cdecl _calloc_impl (size_t, size_t, int *);

Retry:
    pv = _calloc_impl(count, size, NULL);
    if (!pv && _maxwait > 0) {
        WaitTime = wait_a_bit(WaitTime);
        if (WaitTime != -1)
            goto Retry;
    }
    return pv;
}

_CRTIMP void * __cdecl _realloc_crt(void *ptr, size_t size)
{
    unsigned long WaitTime = 0;
    void *pv;

Retry:
    pv = realloc(ptr, size);
    if (!pv && size && _maxwait > 0) {
        WaitTime = wait_a_bit(WaitTime);
        if (WaitTime != -1)
            goto Retry;
    }
    return pv;
}

_CRTIMP void * __cdecl _recalloc_crt(void *ptr, size_t count, size_t size)
{
    unsigned long WaitTime = 0;
    void *pv;

Retry:
    pv = _recalloc(ptr, count, size);
    if (!pv && size && _maxwait > 0)
    {
        WaitTime = wait_a_bit(WaitTime);
        if (WaitTime != -1)
        {
            goto Retry;
        }
    }
    return pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtmbox.c ===
/***
*crtmbox.c - CRT MessageBoxA wrapper.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Wrap MessageBoxA.
*
*******************************************************************************/

#include <tchar.h>
#include <windows.h>
#include <stdlib.h>
#include <awint.h>
#include <internal.h>

/***
*__crtMessageBox - call MessageBoxA dynamically.
*
*Purpose:
*       Avoid static link with user32.dll. Only load it when actually needed.
*
*Entry:
*       see MessageBoxA docs.
*
*Exit:
*       see MessageBoxA docs.
*
*Exceptions:
*
*******************************************************************************/
#ifdef _UNICODE
int __cdecl __crtMessageBoxW(
#else  /* _UNICODE */
int __cdecl __crtMessageBoxA(
#endif  /* _UNICODE */
        LPCTSTR lpText,
        LPCTSTR lpCaption,
        UINT uType
        )
{
        typedef int (APIENTRY *PFNMessageBox)(HWND, LPCTSTR, LPCTSTR, UINT);
        typedef HWND (APIENTRY *PFNGetActiveWindow)(void);
        typedef HWND (APIENTRY *PFNGetLastActivePopup)(HWND);
        typedef HWINSTA (APIENTRY *PFNGetProcessWindowStation)(void);
        typedef BOOL (APIENTRY *PFNGetUserObjectInformation)(HANDLE, int, PVOID, DWORD, LPDWORD);

        void *pfn = NULL;
        void *enull = _encoded_null();
        static PFNMessageBox pfnMessageBox = NULL;
        static PFNGetActiveWindow pfnGetActiveWindow = NULL;
        static PFNGetLastActivePopup pfnGetLastActivePopup = NULL;
        static PFNGetProcessWindowStation pfnGetProcessWindowStation = NULL;
        static PFNGetUserObjectInformation pfnGetUserObjectInformation = NULL;

        HWND hWndParent = NULL;
        BOOL fNonInteractive = FALSE;
        HWINSTA hwinsta=NULL;
        USEROBJECTFLAGS uof;
        DWORD nDummy;

        if (NULL == pfnMessageBox)
        {
            HMODULE hlib=LoadLibrary(_T("USER32.DLL"));
            if(hlib==NULL)
            {
                return 0;
            }

            if (NULL == (pfn =
#ifdef _UNICODE
                            GetProcAddress(hlib, "MessageBoxW")))
#else  /* _UNICODE */
                            GetProcAddress(hlib, "MessageBoxA")))
#endif  /* _UNICODE */
                return 0;

            pfnMessageBox = (PFNMessageBox) _encode_pointer(pfn);

            pfnGetActiveWindow = (PFNGetActiveWindow)
                _encode_pointer(GetProcAddress(hlib, "GetActiveWindow"));

            pfnGetLastActivePopup = (PFNGetLastActivePopup)
                _encode_pointer(GetProcAddress(hlib, "GetLastActivePopup"));

            pfn =
#ifdef _UNICODE
                GetProcAddress(hlib, "GetUserObjectInformationW");
#else  /* _UNICODE */
                GetProcAddress(hlib, "GetUserObjectInformationA");
#endif  /* _UNICODE */

            pfnGetUserObjectInformation = (PFNGetUserObjectInformation) _encode_pointer(pfn);

            if (pfnGetUserObjectInformation != NULL)
                pfnGetProcessWindowStation = (PFNGetProcessWindowStation)
                _encode_pointer(GetProcAddress(hlib, "GetProcessWindowStation"));
        }

        /*
         * If the current process isn't attached to a visible WindowStation,
         * (e.g. a non-interactive service), then we need to set the
         * MB_SERVICE_NOTIFICATION flag, else the message box will be
         * invisible, hanging the program.
         *
         * This check only applies to Windows NT-based systems (for which we
         * retrieved the address of GetProcessWindowStation above).
         */

        if (pfnGetProcessWindowStation != enull && pfnGetUserObjectInformation != enull)
        {
            /* check for NULL expliticly to pacify prefix */
            PFNGetProcessWindowStation dpfnGetProcessWindowStation=(PFNGetProcessWindowStation) _decode_pointer(pfnGetProcessWindowStation);
            PFNGetUserObjectInformation dpfnGetUserObjectInformation=(PFNGetUserObjectInformation) _decode_pointer(pfnGetUserObjectInformation);

            if(dpfnGetProcessWindowStation && dpfnGetUserObjectInformation)
            {
                if (NULL == (hwinsta = (dpfnGetProcessWindowStation)()) ||
                    !(dpfnGetUserObjectInformation)
                    (hwinsta, UOI_FLAGS, &uof, sizeof(uof), &nDummy) ||
                    (uof.dwFlags & WSF_VISIBLE) == 0)
                {
                    fNonInteractive = TRUE;
                }
            }
        }

        if (fNonInteractive)
        {
            uType |= MB_SERVICE_NOTIFICATION;
        }
        else
        {
            if (pfnGetActiveWindow != enull)
            {
                PFNGetActiveWindow dpfnGetActiveWindow=(PFNGetActiveWindow) _decode_pointer(pfnGetActiveWindow);
                if(dpfnGetActiveWindow)
                {
                    hWndParent = (dpfnGetActiveWindow)();
                }
            }

            if (hWndParent != NULL && pfnGetLastActivePopup != enull)
            {
                PFNGetLastActivePopup dpfnGetLastActivePopup=(PFNGetLastActivePopup) _decode_pointer(pfnGetLastActivePopup);
                if(dpfnGetLastActivePopup)
                {
                    hWndParent = (dpfnGetLastActivePopup)(hWndParent);
                }
            }
        }

        /* scope */
        {
            PFNMessageBox dpfnMessageBox=(PFNMessageBox) _decode_pointer(pfnMessageBox);
            if(dpfnMessageBox)
            {
                return (dpfnMessageBox)(hWndParent, lpText, lpCaption, uType);
            }
            else
            {
                /* should never happen */
                return 0;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtexe.c ===
/***
*crtexe.c - Initialization for console EXE using CRT DLL
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps linking to the CRT DLL.
*       It calls the user's main routine [w]main() or [w]WinMain after
*       performing C Run-Time Library initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrtexe.c   the startup routine for console apps with wide chars
*       crtexew.c   the startup routine for Windows apps
*       wcrtexew.c  the startup routine for Windows apps with wide chars
*
*******************************************************************************/

#ifdef CRTDLL

/*
 * SPECIAL BUILD MACROS! Note that crtexe.c (and crtexew.c) is linked in with
 * the client's code. It does not go into crtdll.dll! Therefore, it must be
 * built under the _DLL switch (like user code) and CRTDLL must be undefined.
 * The symbol SPECIAL_CRTEXE is turned on to suppress the normal CRT DLL
 * definition of _fmode and _commode using __declspec(dllexport).  Otherwise
 * this module would not be able to refer to both the local and DLL versions
 * of these two variables.
 */

#undef  CRTDLL
#ifndef _DLL
#define _DLL
#endif  /* _DLL */

/*
 * We need the manifest information in crtexe.obj so that user exe's which
 * do not include any headers get a manifest
 */
#undef _CRT_NOFORCE_MANIFEST
#undef _VC_NODEFAULTLIB

#define SPECIAL_CRTEXE

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <process.h>
#include <math.h>
#include <rterr.h>
#include <stdlib.h>
#include <tchar.h>
#include <rtcapi.h>
#include <sect_attribs.h>
#include <locale.h>

#if defined (_WIN64) && defined (_M_IA64)
#pragma section(".base", long, read)
__declspec(allocate(".base"))
extern
IMAGE_DOS_HEADER __ImageBase;
#else  /* defined (_WIN64) && defined (_M_IA64) */
extern
IMAGE_DOS_HEADER __ImageBase;
#endif  /* defined (_WIN64) && defined (_M_IA64) */

/*
 * This has been moved from unhandld.cpp to here because, we only
 * want to set the UnhandledExceptionFilter when this crt is loaded
 * by an EXE (ie. not loaded by a DLL)
 */
int  __cdecl __CxxSetUnhandledExceptionFilter(void);
_CRTALLOC(".CRT$XIY") static _PIFV pinit = &__CxxSetUnhandledExceptionFilter;

#define SPACECHAR   _T(' ')
#define DQUOTECHAR  _T('\"')

#ifdef _M_IX86

/*
 * The local copy of the Pentium FDIV adjustment flag
 * and the address of the flag in MSVCRT*.DLL.
 */

extern int _adjust_fdiv;

extern int * _imp___adjust_fdiv;

#endif  /* _M_IX86 */


/* default floating point precision - X86 only! */

#ifdef _M_IX86
extern void _setdefaultprecision();
#endif  /* _M_IX86 */


/*
 * Declare function used to install a user-supplied _matherr routine.
 */
_CRTIMP void __setusermatherr( int (__cdecl *)(struct _exception *) );


/*
 * Declare the names of the exports corresponding to _fmode and _commode
 */
#ifdef _M_IX86

#define _IMP___FMODE    (__p__fmode())
#define _IMP___COMMODE  (__p__commode())

#else  /* _M_IX86 */

/* assumed to be MIPS or Alpha */

#define _IMP___FMODE    __imp__fmode
#define _IMP___COMMODE  __imp__commode

#endif  /* _M_IX86 */

#if !defined (_M_IX86)
extern int * _IMP___FMODE;      /* exported from the CRT DLL */
extern int * _IMP___COMMODE;    /* these names are implementation-specific */
#endif  /* !defined (_M_IX86) */

extern int _fmode;          /* must match the definition in <stdlib.h> */
extern int _commode;        /* must match the definition in <internal.h> */
extern int _dowildcard;     /* passed to __getmainargs() */

/*
 * Declare/define communal that serves as indicator the default matherr
 * routine is being used.
 */
int __defaultmatherr;

/*
 * routine in DLL to do initialization (in this case, C++ constructors)
 */
extern int __cdecl _initterm_e(_PIFV *, _PIFV *);
extern void __cdecl _initterm(_PVFV *, _PVFV *);

/*
 * routine to check if this is a managed application
 */
static int __cdecl check_managed_app(void);

/*
 * pointers to initialization sections
 */
extern _CRTALLOC(".CRT$XIA") _PIFV __xi_a[];
extern _CRTALLOC(".CRT$XIZ") _PIFV __xi_z[];    /* C initializers */
extern _CRTALLOC(".CRT$XCA") _PVFV __xc_a[];
extern _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[];    /* C++ initializers */

/*
 * Pointer to callback function to initialize any dynamically initialized
 * __declspec(thread) variables.  This relies on a subtle aspect of C.
 * The pointer is defined here uninitialized.  It is defined initialized in
 * tlsdyn.c.  If user code uses dynamically initialized __declspec(thread)
 * variables, then compiler-injected dependencies cause tlsdyn.obj to be
 * linked.  In that case, the non-zero definition of __dyn_tls_init_callback
 * in tlsdyn.obj will take precedence, and the startup code will execute the
 * callback.  This use of multiple definitions is only legal in C, not C++.
 */

const PIMAGE_TLS_CALLBACK __dyn_tls_init_callback;

/*
 * Pointers to beginning and end of the table of function pointers manipulated
 * by _onexit()/atexit().  The atexit/_onexit code is shared for both EXE's and
 * DLL's but different behavior is required.  These values are set to -1 to
 * mark this module as an EXE.
 * NOTE - the pointers are stored encoded.
 */

extern _PVFV *__onexitbegin;
extern _PVFV *__onexitend;

/*
 * All the below variables are made static global for this file. This facilitates
 * in communicating mainCRTStartup and initialization code. Along with making these
 * variables global, two new functions are created pre_c_init, pre_cpp_init. The functions
 * are executed before anything in c_init and cpp_init sections repsectively.
 */

static int argc;   /* three standard arguments to main */
static _TSCHAR **argv;
static _TSCHAR **envp;

static int argret;
static int mainret=0;
static int managedapp;
static int has_cctor = 0;
static _startupinfo    startinfo;

static int __cdecl pre_c_init(void);
static void __cdecl pre_cpp_init(void);

_CRTALLOC(".CRT$XIAA") static _PIFV pcinit = pre_c_init;
_CRTALLOC(".CRT$XCAA") static _PVFV pcppinit = pre_cpp_init;

/***
*pre_c_init(void)
*
*Purpose:
*       The code in mainCRTStartup that was executed before executing C
*       initializers was shifted in this function. Also this funciton is the
*       first thing that is executed in c init section.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

static int __cdecl pre_c_init(void)
{
    /*
     * Determine if this is a managed application
     */
    managedapp = check_managed_app();

    /*
     * Set __app_type properly
     */
#ifdef _WINMAIN_
    __set_app_type(_GUI_APP);
#else  /* _WINMAIN_ */
    __set_app_type(_CONSOLE_APP);
#endif  /* _WINMAIN_ */

    /*
     * Mark this module as an EXE file so that atexit/_onexit
     * will do the right thing when called, including for C++
     * d-tors.
     */
    __onexitbegin = __onexitend = (_PVFV *)_encode_pointer((_PVFV *)(-1));

    /*
     * Propogate the _fmode and _commode variables to the DLL
     */
    *_IMP___FMODE = _fmode;
    *_IMP___COMMODE = _commode;

#ifdef _M_IX86
    /*
     * Set the local copy of the Pentium FDIV adjustment flag
     */

    _adjust_fdiv = * _imp___adjust_fdiv;
#endif  /* _M_IX86 */

    /*
     * Run the RTC initialization code for this DLL
     */
#ifdef _RTC
    _RTC_Initialize();
#endif  /* _RTC */

    /*
     * Call _setargv(), which will trigger a call to __setargv() if
     * SETARGV.OBJ is linked with the EXE.  If SETARGV.OBJ is not
     * linked with the EXE, a dummy _setargv() will be called.
     */
#ifdef WPRFLAG
    _wsetargv();
#else  /* WPRFLAG */
    _setargv();
#endif  /* WPRFLAG */

    /*
     * If the user has supplied a _matherr routine then set
     * __pusermatherr to point to it.
     */
    if ( !__defaultmatherr )
        __setusermatherr(_matherr);

#ifdef _M_IX86
    _setdefaultprecision();
#endif  /* _M_IX86 */

    /* Enable per-thread locale if user asked for it */
    if(__globallocalestatus == -1)
    {
        _configthreadlocale(-1);
    }

    return 0;
}

/***
*pre_cpp_init(void)
*
*Purpose:
*       The code in mainCRTStartup that was executed after C initializers and
*       before C++ initializers is shifted in this function. Also this funciton
*       is the first thing that is executed in C++ init section.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

static void __cdecl pre_cpp_init(void)
{
#ifdef _RTC
    atexit(_RTC_Terminate);
#endif  /* _RTC */

    /*
     * Get the arguments for the call to main. Note this must be
     * done explicitly, rather than as part of the dll's
     * initialization, to implement optional expansion of wild
     * card chars in filename args
     */

    startinfo.newmode = _newmode;


#ifdef WPRFLAG
    argret = __wgetmainargs(&argc, &argv, &envp,
                            _dowildcard, &startinfo);
#else  /* WPRFLAG */
    argret = __getmainargs(&argc, &argv, &envp,
                           _dowildcard, &startinfo);
#endif  /* WPRFLAG */

#ifndef _SYSCRT
    if (argret < 0)
        _amsg_exit(_RT_SPACEARG);
#endif  /* _SYSCRT */
}

/***
*mainCRTStartup(void)
*wmainCRTStartup(void)
*WinMainCRTStartup(void)
*wWinMainCRTStartup(void)
*
*Purpose:
*       These routines do the C runtime initialization, call the appropriate
*       user entry function, and handle termination cleanup.  For a managed
*       app, they then return the exit code back to the calling routine, which
*       is the managed startup code.  For an unmanaged app, they call exit and
*       never return.
*
*       Function:               User entry called:
*       mainCRTStartup          main
*       wmainCRTStartup         wmain
*       WinMainCRTStartup       WinMain
*       wWinMainCRTStartup      wWinMain
*
*Entry:
*
*Exit:
*       Managed app: return value from main() et al, or the exception code if
*                 execution was terminated by the __except guarding the call
*                 to main().
*       Unmanaged app: never return.
*
*******************************************************************************/

static
int
__tmainCRTStartup(
         void
         );

#ifdef _WINMAIN_

#ifdef WPRFLAG
int wWinMainCRTStartup(
#else  /* WPRFLAG */
int WinMainCRTStartup(
#endif  /* WPRFLAG */

#else  /* _WINMAIN_ */

#ifdef WPRFLAG
int wmainCRTStartup(
#else  /* WPRFLAG */
int mainCRTStartup(
#endif  /* WPRFLAG */

#endif  /* _WINMAIN_ */
        void
        )
{
        /*
         * The /GS security cookie must be initialized before any exception
         * handling targetting the current image is registered.  No function
         * using exception handling can be called in the current image until
         * after __security_init_cookie has been called.
         */
        __security_init_cookie();

        return __tmainCRTStartup();
}

__declspec(noinline)
int
__tmainCRTStartup(
        void
        )
{
#ifdef _WINMAIN_
        _TUCHAR *lpszCommandLine;
        STARTUPINFO StartupInfo;
        BOOL inDoubleQuote=FALSE;

        __try {
                        /*
                        Note: MSDN specifically notes that GetStartupInfo returns no error, and throws unspecified SEH if it fails, so
                        the very general exception handler below is appropriate
                        */
            GetStartupInfo( &StartupInfo );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            return 255;
        }
#endif  /* _WINMAIN_ */


        /*
         * Guard the initialization code and the call to user's main, or
         * WinMain, function in a __try/__except statement.
         */

        __try
        {
            /*
             * There is a possiblity that the module where this object is
             * linked into is a mixed module. In all the cases we gurantee that
             * native initialization will occur before managed initialization.
             * Also in anycase this code should never be called when some other
             * code is initializing native code, that's why we exit in that case.
             *
             * Do runtime startup initializers.
             *
             * Note: the only possible entry we'll be executing here is for
             * __lconv_init, pulled in from charmax.obj only if the EXE was
             * compiled with -J.  All other .CRT$XI* initializers are only
             * run as part of the CRT itself, and so for the CRT DLL model
             * are not found in the EXE.  For that reason, we call _initterm,
             * not _initterm_e, because __lconv_init will never return failure,
             * and _initterm_e is not exported from the CRT DLL.
             *
             * Note further that, when using the CRT DLL, executing the
             * .CRT$XI* initializers is only done for an EXE, not for a DLL
             * using the CRT DLL.  That is to make sure the -J setting for
             * the EXE is not overriden by that of any DLL.
             */
            void *lock_free=0;
            void *fiberid=((PNT_TIB)NtCurrentTeb())->StackBase;
            int nested=FALSE;
            while((lock_free=InterlockedCompareExchangePointer((volatile PVOID *)&__native_startup_lock, fiberid, 0))!=0)
            {
                if(lock_free==fiberid)
                {
                    nested=TRUE;
                    break;
                }

                /* some other thread is running native startup/shutdown during a cctor/domain unload.
                    Should only happen if this DLL was built using the Everett-compat loader lock fix in vcclrit.h
                */
                /* wait for the other thread to complete init before we return */
                Sleep(1000);
            }

            if (__native_startup_state == __initializing)
            {
                _amsg_exit( _RT_CRT_INIT_CONFLICT);
            }
            else if (__native_startup_state == __uninitialized)
            {
                __native_startup_state = __initializing;
#ifndef _SYSCRT
                if (_initterm_e( __xi_a, __xi_z ) != 0)
                {
                    return 255;
                }
#else  /* _SYSCRT */
                _initterm((_PVFV *)(void *)__xi_a, (_PVFV *)(void *)__xi_z);
#endif  /* _SYSCRT */
            }
            else
            {
                has_cctor = 1;
            }

            /*
            * do C++ constructors (initializers) specific to this EXE
            */
            if (__native_startup_state == __initializing)
            {
                _initterm( __xc_a, __xc_z );
                __native_startup_state = __initialized;
            }
            _ASSERTE(__native_startup_state == __initialized);
            if(!nested)
            {
                /* For X86, the definition of InterlockedExchangePointer wrongly causes warning C4312 */
#pragma warning(push)
#pragma warning(disable:4312)
                InterlockedExchangePointer((volatile PVOID *)&__native_startup_lock, 0);
#pragma warning(pop)
            }

            /*
             * If we have any dynamically initialized __declspec(thread)
             * variables, then invoke their initialization for the primary
             * thread used to start the process, by calling __dyn_tls_init
             * through a callback defined in tlsdyn.obj.
             */
            if (__dyn_tls_init_callback != NULL &&
                _IsNonwritableInCurrentImage((PBYTE)&__dyn_tls_init_callback))
            {
                __dyn_tls_init_callback(NULL, DLL_THREAD_ATTACH, NULL);
            }

            /* Enable buffer count checking if linking against static lib */
            _CrtSetCheckCount(TRUE);

#ifdef _WINMAIN_
            /*
             * Skip past program name (first token in command line).
             * Check for and handle quoted program name.
             */
#ifdef WPRFLAG
            /* OS may not support "W" flavors */
            if (_wcmdln == NULL)
                return 255;
            lpszCommandLine = (wchar_t *)_wcmdln;
#else  /* WPRFLAG */
            lpszCommandLine = (unsigned char *)_acmdln;
#endif  /* WPRFLAG */

            while (*lpszCommandLine > SPACECHAR ||
                   (*lpszCommandLine&&inDoubleQuote)) {
                /*
                 * Flip the count from 1 to 0 or 0 to 1 if current character
                 * is DOUBLEQUOTE
                 */
                if (*lpszCommandLine==DQUOTECHAR) inDoubleQuote=!inDoubleQuote;
#ifdef _MBCS
                if (_ismbblead(*lpszCommandLine)) {
                    if (lpszCommandLine) {
                        lpszCommandLine++;
                    }
                }
#endif  /* _MBCS */
                ++lpszCommandLine;
            }

            /*
             * Skip past any white space preceeding the second token.
             */
            while (*lpszCommandLine && (*lpszCommandLine <= SPACECHAR)) {
                lpszCommandLine++;
            }

#ifdef WPRFLAG
            mainret = wWinMain(
#else  /* WPRFLAG */
            mainret = WinMain(
#endif  /* WPRFLAG */
                       (HINSTANCE)&__ImageBase,
                       NULL,
                       lpszCommandLine,
                       StartupInfo.dwFlags & STARTF_USESHOWWINDOW
                        ? StartupInfo.wShowWindow
                        : SW_SHOWDEFAULT
                      );
#else  /* _WINMAIN_ */

#ifdef WPRFLAG
            __winitenv = envp;
            mainret = wmain(argc, argv, envp);
#else  /* WPRFLAG */
            __initenv = envp;
            mainret = main(argc, argv, envp);
#endif  /* WPRFLAG */

#endif  /* _WINMAIN_ */

            /*
             * Note that if the exe is managed app, we don't really need to
             * call exit or _c_exit. .cctor should be able to take care of
             * this.
             */
            if ( !managedapp )
                exit(mainret);

            if (has_cctor == 0)
                _cexit();

        }
        __except ( _XcptFilter(GetExceptionCode(), GetExceptionInformation()) )
        {
            /*
             * Should never reach here
             */

            mainret = GetExceptionCode();

            /*
             * Note that if the exe is managed app, we don't really need to
             * call exit or _c_exit. .cctor should be able to take care of
             * this.
             */
            if ( !managedapp )
                _exit(mainret);

            if (has_cctor == 0)
                _cexit();
        } /* end of try - except */

        return mainret;
}

/***
*check_managed_app() - Check for a managed executable
*
*Purpose:
*       Determine if the EXE the startup code is linked into is a managed app
*       by looking for the COM Runtime Descriptor in the Image Data Directory
*       of the PE or PE+ header.
*
*Entry:
*       None
*
*Exit:
*       1 if managed app, 0 if not.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl check_managed_app (
        void
        )
{
        PIMAGE_DOS_HEADER pDOSHeader;
        PIMAGE_NT_HEADERS pPEHeader;
        PIMAGE_OPTIONAL_HEADER32 pNTHeader32;
        PIMAGE_OPTIONAL_HEADER64 pNTHeader64;

        pDOSHeader = (PIMAGE_DOS_HEADER)&__ImageBase;
        if ( pDOSHeader->e_magic != IMAGE_DOS_SIGNATURE )
            return 0;

        pPEHeader = (PIMAGE_NT_HEADERS)((char *)pDOSHeader +
                                        pDOSHeader->e_lfanew);
        if ( pPEHeader->Signature != IMAGE_NT_SIGNATURE )
            return 0;

        pNTHeader32 = (PIMAGE_OPTIONAL_HEADER32)&pPEHeader->OptionalHeader;
        switch ( pNTHeader32->Magic ) {
        case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
            /* PE header */
            /* prefast assumes we are overflowing __ImageBase */
#pragma warning(push)
#pragma warning(disable:26000)
            if ( pNTHeader32->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
#pragma warning(pop)
            return !! pNTHeader32 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
            /* PE+ header */
            pNTHeader64 = (PIMAGE_OPTIONAL_HEADER64)pNTHeader32;
            if ( pNTHeader64->NumberOfRvaAndSizes <=
                    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR )
                return 0;
            return !! pNTHeader64 ->
                      DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR] .
                      VirtualAddress;
        }

        /* Not PE or PE+, so not managed */
        return 0;
}

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtdefs.h ===
/***
*crtdefs.h - definitions/declarations common to all CRT
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has mostly defines used by the entire CRT.
*
*       [Public]
*
****/

/* Lack of pragma once is deliberate */

/* Define _CRTIMP */
#ifndef _CRTIMP
#ifdef CRTDLL
#define _CRTIMP __declspec(dllexport)
#else  /* CRTDLL */
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else  /* _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#ifndef _INC_CRTDEFS
#define _INC_CRTDEFS

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifndef _INTERNAL_IFSTRIP_

/* Turn off cpp overloads internally */
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0

#endif  /* _INTERNAL_IFSTRIP_ */

#if defined (__midl)
/* MIDL does not want to see this stuff */
#undef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
#undef _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
#undef _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
#endif  /* defined (__midl) */

#if !defined (_WIN32)
#error ERROR: Only Win32 target supported!
#endif  /* !defined (_WIN32) */

/* Note on use of "deprecate":
 * Various places in this header and other headers use __declspec(deprecate) or macros that have the term DEPRECATE in them.
 * We use deprecate here ONLY to signal the compiler to emit a warning about these items. The use of deprecate
 * should NOT be taken to imply that any standard committee has deprecated these functions from the relevant standards.
 * In fact, these functions are NOT deprecated from the standard.
 *
 * Full details can be found in our documentation by searching for "Security Enhancements in the CRT".
*/

#ifdef _CRTBLD
#ifndef _INTERNAL_IFSTRIP_
#ifndef _CRT_NOFORCE_MANIFEST
#define _CRT_FORCE_MANIFEST
#endif  /* _CRT_NOFORCE_MANIFEST */
#endif  /* _INTERNAL_IFSTRIP_ */
#endif  /* _CRTBLD */

#ifdef _CRT_NOFORCE_MANIFEST

#ifdef _CRT_FORCE_MANIFEST
        #pragma message ("_CRT_FORCE_MANIFEST and _CRT_NOFORCE_MANIFEST defined. Define just one")
        #pragma message ("_CRT_FORCE_MANIFEST ignored")
#endif  /* _CRT_FORCE_MANIFEST */

#else  /* _CRT_NOFORCE_MANIFEST */

#if !defined (_CRT_FORCE_MANIFEST) && defined (_VC_NODEFAULTLIB)
        #define _CRT_NOFORCE_MANIFEST
#endif  /* !defined (_CRT_FORCE_MANIFEST) && defined (_VC_NODEFAULTLIB) */

#endif  /* _CRT_NOFORCE_MANIFEST */

#include <sal.h>

#ifdef _DLL

#if !defined (_CRT_NOFORCE_MANIFEST)

#ifdef _DEBUG
#ifdef _CRT_MANIFEST_RETAIL
#define _CRT_MANIFEST_INCONSISTENT
#else  /* _CRT_MANIFEST_RETAIL */
#define _CRT_MANIFEST_DEBUG
#endif  /* _CRT_MANIFEST_RETAIL */
#else  /* _DEBUG */
#ifdef _CRT_MANIFEST_DEBUG
#define _CRT_MANIFEST_INCONSISTENT
#else  /* _CRT_MANIFEST_DEBUG */
#define _CRT_MANIFEST_RETAIL
#endif  /* _CRT_MANIFEST_DEBUG */
#endif  /* _DEBUG */

#ifdef _CRT_MANIFEST_INCONSISTENT
#error You have included some C++/C library header files with _DEBUG defined and some with _DEBUG not defined. This will not work correctly. Please have _DEBUG set or clear consistently.
#endif  /* _CRT_MANIFEST_INCONSISTENT */

#include <crtassem.h>

#ifdef _M_IX86

#ifdef _DEBUG
#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
        "name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".DebugCRT' "         \
        "version='" _CRT_ASSEMBLY_VERSION "' "                          \
        "processorArchitecture='x86' "                                  \
        "publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'\"")
#else  /* _DEBUG */
#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
        "name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".CRT' "              \
        "version='" _CRT_ASSEMBLY_VERSION "' "                          \
        "processorArchitecture='x86' "                                  \
        "publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'\"")
#endif  /* _DEBUG */

#endif  /* _M_IX86 */

#ifdef _M_AMD64

#ifdef _DEBUG
#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
        "name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".DebugCRT' "         \
        "version='" _CRT_ASSEMBLY_VERSION "' "                          \
        "processorArchitecture='amd64' "                                \
        "publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'\"")
#else  /* _DEBUG */
#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
        "name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".CRT' "              \
        "version='" _CRT_ASSEMBLY_VERSION "' "                          \
        "processorArchitecture='amd64' "                                \
        "publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'\"")
#endif  /* _DEBUG */

#endif  /* _M_AMD64 */

#ifdef _M_IA64

#ifdef _DEBUG
#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
        "name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".DebugCRT' "         \
        "version='" _CRT_ASSEMBLY_VERSION "' "                          \
        "processorArchitecture='ia64' "                                 \
        "publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'\"")
#else  /* _DEBUG */
#pragma comment(linker,"/manifestdependency:\"type='win32' "            \
        "name='" __LIBRARIES_ASSEMBLY_NAME_PREFIX ".CRT' "              \
        "version='" _CRT_ASSEMBLY_VERSION "' "                          \
        "processorArchitecture='ia64' "                                 \
        "publicKeyToken='" _VC_ASSEMBLY_PUBLICKEYTOKEN "'\"")
#endif  /* _DEBUG */

#endif  /* _M_IA64 */

#endif  /* !defined (_CRT_NOFORCE_MANIFEST) */

#endif  /* _DLL */

#ifdef _MSC_VER
#undef _CRT_PACKING
#define _CRT_PACKING 8

#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#include <vadefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* preprocessor string helpers */
#ifndef _CRT_STRINGIZE
#define __CRT_STRINGIZE(_Value) #_Value
#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)
#endif  /* _CRT_STRINGIZE */

#ifndef _CRT_WIDE
#define __CRT_WIDE(_String) L ## _String
#define _CRT_WIDE(_String) __CRT_WIDE(_String)
#endif  /* _CRT_WIDE */

#ifndef _CRT_APPEND
#define __CRT_APPEND(_Value1, _Value2) _Value1 ## _Value2
#define _CRT_APPEND(_Value1, _Value2) __CRT_APPEND(_Value1, _Value2)
#endif  /* _CRT_APPEND */

#if !defined (_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
#define _W64 __w64
#else  /* !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 */
#define _W64
#endif  /* !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300 */
#endif  /* !defined (_W64) */

#ifndef _INTERNAL_IFSTRIP_
/* Define _CRTIMP1 */

#ifndef _CRTIMP1
#ifdef CRTDLL1
#define _CRTIMP1 __declspec(dllexport)
#else  /* CRTDLL1 */
#define _CRTIMP1 _CRTIMP
#endif  /* CRTDLL1 */
#endif  /* _CRTIMP1 */
#endif  /* _INTERNAL_IFSTRIP_ */

/* Define _CRTIMP_NOIA64 */
#ifndef _CRTIMP_NOIA64
#if defined (_M_IA64)
#define _CRTIMP_NOIA64
#else  /* defined (_M_IA64) */
#define _CRTIMP_NOIA64 _CRTIMP
#endif  /* defined (_M_IA64) */
#endif  /* _CRTIMP_NOIA64 */

/* Define _CRTIMP2 */

#ifndef _CRTIMP2
#if defined (CRTDLL2)
#define _CRTIMP2 __declspec(dllexport)
#else  /* defined (CRTDLL2) */
#if defined (_DLL) && !defined (_STATIC_CPPLIB)
#define _CRTIMP2 __declspec(dllimport)
#else  /* defined (_DLL) && !defined (_STATIC_CPPLIB) */
#define _CRTIMP2
#endif  /* defined (_DLL) && !defined (_STATIC_CPPLIB) */
#endif  /* defined (CRTDLL2) */
#endif  /* _CRTIMP2 */

/* Define _CRTIMP_ALTERNATIVE */

#ifndef _INTERNAL_IFSTRIP_
/* This _CRTIMP_ALTERNATIVE is used to mark the secure functions implemented in safecrt.lib, which are
   meant to be available downlevel. In Windows, they will be merged in msvcrt.lib (the import
   library, so Windows should change:
        #define _CRTIMP_ALTERNATIVE __declspec(dllimport)
   to:
        #define _CRTIMP_ALTERNATIVE
   since these function will never be compiled in the msvcrt.dll.
   Here the trick is done based on _CRT_ALTERNATIVE_INLINES which enforce that safecrt.h is included before
   every other standard include files.
 */
#endif  /* _INTERNAL_IFSTRIP_ */
#ifndef _CRTIMP_ALTERNATIVE
#ifdef CRTDLL
#ifdef _SAFECRT_IMPL
    #define _CRTIMP_ALTERNATIVE
#else  /* _SAFECRT_IMPL */
    #define _CRTIMP_ALTERNATIVE __declspec(dllexport)
#endif  /* _SAFECRT_IMPL */
#else  /* CRTDLL */
#ifdef _DLL
#ifdef _CRT_ALTERNATIVE_INLINES
#define _CRTIMP_ALTERNATIVE
#else  /* _CRT_ALTERNATIVE_INLINES */
#define _CRTIMP_ALTERNATIVE _CRTIMP
#define _CRT_ALTERNATIVE_IMPORTED
#endif  /* _CRT_ALTERNATIVE_INLINES */
#else  /* _DLL */
#define _CRTIMP_ALTERNATIVE
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP_ALTERNATIVE */

/* Define _MRTIMP */

#ifndef _MRTIMP
#ifdef MRTDLL
#if !defined (_M_CEE_PURE)
    #define _MRTIMP __declspec(dllexport)
#else  /* !defined (_M_CEE_PURE) */
    #define _MRTIMP
#endif  /* !defined (_M_CEE_PURE) */
#else  /* MRTDLL */
#define _MRTIMP __declspec(dllimport)
#endif  /* MRTDLL */
#endif  /* _MRTIMP */

/* Define _MRTIMP2 */
#ifndef _MRTIMP2
#if defined (CRTDLL2)
#define _MRTIMP2        __declspec(dllexport)
#elif defined (MRTDLL)
#define _MRTIMP2 _MRTIMP
#else  /* defined (MRTDLL) */

#if defined (_DLL) && !defined (_STATIC_CPPLIB)
#define _MRTIMP2        __declspec(dllimport)

#else  /* defined (_DLL) && !defined (_STATIC_CPPLIB) */
#define _MRTIMP2
#endif  /* defined (_DLL) && !defined (_STATIC_CPPLIB) */

#endif  /* defined (MRTDLL) */
#endif  /* _MRTIMP2 */


#ifndef _MCRTIMP
#if defined (CRTDLL) || defined (MRTDLL)
#define _MCRTIMP __declspec(dllexport)
#else  /* defined (CRTDLL) || defined (MRTDLL) */
#ifdef _DLL
#define _MCRTIMP __declspec(dllimport)
#else  /* _DLL */
#define _MCRTIMP
#endif  /* _DLL */
#endif  /* defined (CRTDLL) || defined (MRTDLL) */
#endif  /* _MCRTIMP */

#ifndef __CLR_OR_THIS_CALL
#if defined (MRTDLL) || defined (_M_CEE_PURE)
#define __CLR_OR_THIS_CALL  __clrcall
#else  /* defined (MRTDLL) || defined (_M_CEE_PURE) */
#define __CLR_OR_THIS_CALL
#endif  /* defined (MRTDLL) || defined (_M_CEE_PURE) */
#endif  /* __CLR_OR_THIS_CALL */

#ifndef __CLRCALL_OR_CDECL
#if defined (MRTDLL) || defined (_M_CEE_PURE)
#define __CLRCALL_OR_CDECL __clrcall
#else  /* defined (MRTDLL) || defined (_M_CEE_PURE) */
#define __CLRCALL_OR_CDECL __cdecl
#endif  /* defined (MRTDLL) || defined (_M_CEE_PURE) */
#endif  /* __CLRCALL_OR_CDECL */

#ifndef _CRTIMP_PURE
#if defined (_M_CEE_PURE) || defined (_STATIC_CPPLIB)
  #define _CRTIMP_PURE
#elif defined (MRTDLL)
  #define _CRTIMP_PURE
#else  /* defined (MRTDLL) */
  #define _CRTIMP_PURE _CRTIMP
#endif  /* defined (MRTDLL) */
#endif  /* _CRTIMP_PURE */

#ifndef _PGLOBAL
#ifdef _M_CEE
#if defined (__cplusplus_cli)
    #define _PGLOBAL __declspec(process)
#else  /* defined (__cplusplus_cli) */
    #define _PGLOBAL
#endif  /* defined (__cplusplus_cli) */
#else  /* _M_CEE */
#define _PGLOBAL
#endif  /* _M_CEE */
#endif  /* _PGLOBAL */

#ifndef _AGLOBAL
#ifdef _M_CEE
#define _AGLOBAL __declspec(appdomain)
#else  /* _M_CEE */
#define _AGLOBAL
#endif  /* _M_CEE */
#endif  /* _AGLOBAL */

/* define a specific constant for mixed mode */
#ifdef _M_CEE
#ifndef _M_CEE_PURE
#define _M_CEE_MIXED
#endif  /* _M_CEE_PURE */
#endif  /* _M_CEE */

/* Define __STDC_SECURE_LIB__ */
#define __STDC_SECURE_LIB__ 200411L

/* Retain__GOT_SECURE_LIB__ for back-compat */
#define __GOT_SECURE_LIB__ __STDC_SECURE_LIB__

/* Default value for __STDC_WANT_SECURE_LIB__ is 1 */
#ifndef __STDC_WANT_SECURE_LIB__
#define __STDC_WANT_SECURE_LIB__ 1
#endif  /* __STDC_WANT_SECURE_LIB__ */

/* Turn off warnings if __STDC_WANT_SECURE_LIB__ is 0 */
#if !__STDC_WANT_SECURE_LIB__ && !defined (_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif  /* !__STDC_WANT_SECURE_LIB__ && !defined (_CRT_SECURE_NO_WARNINGS) */

/* See note on use of deprecate at the top of this file */
#if _MSC_FULL_VER >= 140050320
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))
#else  /* _MSC_FULL_VER >= 140050320 */
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated)
#endif  /* _MSC_FULL_VER >= 140050320 */

/* Define _CRT_INSECURE_DEPRECATE */
/* See note on use of deprecate at the top of this file */
#if defined (_CRT_SECURE_NO_DEPRECATE) && !defined (_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif  /* defined (_CRT_SECURE_NO_DEPRECATE) && !defined (_CRT_SECURE_NO_WARNINGS) */

#ifndef _CRT_INSECURE_DEPRECATE
#ifdef _CRT_SECURE_NO_WARNINGS
#define _CRT_INSECURE_DEPRECATE(_Replacement)
#else  /* _CRT_SECURE_NO_WARNINGS */
#define _CRT_INSECURE_DEPRECATE(_Replacement) _CRT_DEPRECATE_TEXT("This function or variable may be unsafe. Consider using " #_Replacement " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")
#endif  /* _CRT_SECURE_NO_WARNINGS */
#endif  /* _CRT_INSECURE_DEPRECATE */

/* Define _CRT_INSECURE_DEPRECATE_MEMORY */
/* See note on use of deprecate at the top of this file */
#if defined (_CRT_SECURE_DEPRECATE_MEMORY) && !defined (_CRT_SECURE_WARNINGS_MEMORY)
#define _CRT_SECURE_WARNINGS_MEMORY
#endif  /* defined (_CRT_SECURE_DEPRECATE_MEMORY) && !defined (_CRT_SECURE_WARNINGS_MEMORY) */

#ifndef _CRT_INSECURE_DEPRECATE_MEMORY
#if !defined (_CRT_SECURE_WARNINGS_MEMORY)
#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement)
#else  /* !defined (_CRT_SECURE_WARNINGS_MEMORY) */
#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) _CRT_INSECURE_DEPRECATE(_Replacement)
#endif  /* !defined (_CRT_SECURE_WARNINGS_MEMORY) */
#endif  /* _CRT_INSECURE_DEPRECATE_MEMORY */

/* Define _CRT_INSECURE_DEPRECATE_GLOBALS */
/* See note on use of deprecate at the top of this file */
#if !defined (RC_INVOKED)
#if defined (_CRT_SECURE_NO_DEPRECATE_GLOBALS) && !defined (_CRT_SECURE_NO_WARNINGS_GLOBALS)
#define _CRT_SECURE_NO_WARNINGS_GLOBALS
#endif  /* defined (_CRT_SECURE_NO_DEPRECATE_GLOBALS) && !defined (_CRT_SECURE_NO_WARNINGS_GLOBALS) */
#endif  /* !defined (RC_INVOKED) */

#ifndef _CRT_INSECURE_DEPRECATE_GLOBALS
#if defined (RC_INVOKED)
#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement)
#else  /* defined (RC_INVOKED) */
#if defined (_CRT_SECURE_NO_WARNINGS_GLOBALS)
#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement)
#else  /* defined (_CRT_SECURE_NO_WARNINGS_GLOBALS) */
#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement) _CRT_INSECURE_DEPRECATE(_Replacement)
#endif  /* defined (_CRT_SECURE_NO_WARNINGS_GLOBALS) */
#endif  /* defined (RC_INVOKED) */
#endif  /* _CRT_INSECURE_DEPRECATE_GLOBALS */

/* Define _CRT_MANAGED_HEAP_DEPRECATE */
/* See note on use of deprecate at the top of this file */
#if defined (_CRT_MANAGED_HEAP_NO_DEPRECATE) && !defined (_CRT_MANAGED_HEAP_NO_WARNINGS)
#define _CRT_MANAGED_HEAP_NO_WARNINGS
#endif  /* defined (_CRT_MANAGED_HEAP_NO_DEPRECATE) && !defined (_CRT_MANAGED_HEAP_NO_WARNINGS) */

#ifndef _CRT_MANAGED_HEAP_DEPRECATE
#ifdef _CRT_MANAGED_HEAP_NO_WARNINGS
#define _CRT_MANAGED_HEAP_DEPRECATE
#else  /* _CRT_MANAGED_HEAP_NO_WARNINGS */
#if defined (_M_CEE)
#define _CRT_MANAGED_HEAP_DEPRECATE
/* Disabled to allow QA tests to get fixed
_CRT_DEPRECATE_TEXT("Direct heap access is not safely possible from managed code.")
*/
#else  /* defined (_M_CEE) */
#define _CRT_MANAGED_HEAP_DEPRECATE
#endif  /* defined (_M_CEE) */
#endif  /* _CRT_MANAGED_HEAP_NO_WARNINGS */
#endif  /* _CRT_MANAGED_HEAP_DEPRECATE */

/* Change the __FILL_BUFFER_PATTERN to 0xFE to fix security function buffer overrun detection bug */
#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE

/* obsolete stuff */
#ifdef _CRTBLD
#ifndef _INTERNAL_IFSTRIP_
/* These are still used in the CRT sources only */
#define _CRT_OBSOLETE(_NewItem)
#else  /* _INTERNAL_IFSTRIP_ */

/* Define _CRT_OBSOLETE */
/* See note on use of deprecate at the top of this file */
#if defined (_CRT_OBSOLETE_NO_DEPRECATE) && !defined (_CRT_OBSOLETE_NO_WARNINGS)
#define _CRT_OBSOLETE_NO_WARNINGS
#endif  /* defined (_CRT_OBSOLETE_NO_DEPRECATE) && !defined (_CRT_OBSOLETE_NO_WARNINGS) */

#ifndef _CRT_OBSOLETE
#ifdef _CRT_OBSOLETE_NO_WARNINGS
#define _CRT_OBSOLETE(_NewItem)
#else  /* _CRT_OBSOLETE_NO_WARNINGS */
#define _CRT_OBSOLETE(_NewItem) _CRT_DEPRECATE_TEXT("This function or variable has been superceded by newer library or operating system functionality. Consider using " #_NewItem " instead. See online help for details.")
#endif  /* _CRT_OBSOLETE_NO_WARNINGS */
#endif  /* _CRT_OBSOLETE */

#endif  /* _INTERNAL_IFSTRIP_ */
#endif  /* _CRTBLD */

/* jit64 instrinsic stuff */
#ifndef _CRT_JIT_INTRINSIC
#if defined (_M_CEE) && (defined (_M_AMD64) || defined (_M_IA64))
/* This is only needed when managed code is calling the native APIs, targeting the 64-bit runtime */
#define _CRT_JIT_INTRINSIC __declspec(jitintrinsic)
#else  /* defined (_M_CEE) && (defined (_M_AMD64) || defined (_M_IA64)) */
#define _CRT_JIT_INTRINSIC
#endif  /* defined (_M_CEE) && (defined (_M_AMD64) || defined (_M_IA64)) */
#endif  /* _CRT_JIT_INTRINSIC */

/* Define overload switches */
#if !defined (RC_INVOKED)
#if !defined (_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
  #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
#else  /* !defined (_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES) */
#if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
   #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
#endif  /* !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES */
#endif  /* !defined (_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES) */
#endif  /* !defined (RC_INVOKED) */

#if !defined (RC_INVOKED)
#if !defined (_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT)
  /* _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT is ignored if _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES is set to 0 */
  #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
#else  /* !defined (_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT) */
#if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT
   #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
#endif  /* !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT */
#endif  /* !defined (_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT) */
#endif  /* !defined (RC_INVOKED) */

#if !defined (RC_INVOKED)
#if !defined (_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES)
#if __STDC_WANT_SECURE_LIB__
   #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
#else  /* __STDC_WANT_SECURE_LIB__ */
   #define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 0
#endif  /* __STDC_WANT_SECURE_LIB__ */
#else  /* !defined (_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES) */
#if !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES
   #error Cannot use Secure CRT C++ overloads when __STDC_WANT_SECURE_LIB__ is 0
#endif  /* !__STDC_WANT_SECURE_LIB__ && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES */
#endif  /* !defined (_CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES) */
#endif  /* !defined (RC_INVOKED) */

/* Define _CRT_NONSTDC_DEPRECATE */
/* See note on use of deprecate at the top of this file */
#if defined (_CRT_NONSTDC_NO_DEPRECATE) && !defined (_CRT_NONSTDC_NO_WARNINGS)
#define _CRT_NONSTDC_NO_WARNINGS
#endif  /* defined (_CRT_NONSTDC_NO_DEPRECATE) && !defined (_CRT_NONSTDC_NO_WARNINGS) */

#if !defined (_CRT_NONSTDC_DEPRECATE)
#if defined (_CRT_NONSTDC_NO_WARNINGS)
#define _CRT_NONSTDC_DEPRECATE(_NewName)
#else  /* defined (_CRT_NONSTDC_NO_WARNINGS) */
#define _CRT_NONSTDC_DEPRECATE(_NewName) _CRT_DEPRECATE_TEXT("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " #_NewName ". See online help for details.")
#endif  /* defined (_CRT_NONSTDC_NO_WARNINGS) */
#endif  /* !defined (_CRT_NONSTDC_DEPRECATE) */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef _W64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

#if __STDC_WANT_SECURE_LIB__
#ifndef _RSIZE_T_DEFINED
typedef size_t rsize_t;
#define _RSIZE_T_DEFINED
#endif  /* _RSIZE_T_DEFINED */
#endif  /* __STDC_WANT_SECURE_LIB__ */

#ifndef _INTPTR_T_DEFINED
#ifdef _WIN64
typedef __int64             intptr_t;
#else  /* _WIN64 */
typedef _W64 int            intptr_t;
#endif  /* _WIN64 */
#define _INTPTR_T_DEFINED
#endif  /* _INTPTR_T_DEFINED */

#ifndef _UINTPTR_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    uintptr_t;
#else  /* _WIN64 */
typedef _W64 unsigned int   uintptr_t;
#endif  /* _WIN64 */
#define _UINTPTR_T_DEFINED
#endif  /* _UINTPTR_T_DEFINED */

#ifndef _PTRDIFF_T_DEFINED
#ifdef _WIN64
typedef __int64             ptrdiff_t;
#else  /* _WIN64 */
typedef _W64 int            ptrdiff_t;
#endif  /* _WIN64 */
#define _PTRDIFF_T_DEFINED
#endif  /* _PTRDIFF_T_DEFINED */

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _WCTYPE_T_DEFINED
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED
#endif  /* _WCTYPE_T_DEFINED */

#ifndef _VA_LIST_DEFINED
#ifdef _M_CEE_PURE
typedef System::ArgIterator va_list;
#else  /* _M_CEE_PURE */
typedef char *  va_list;
#endif  /* _M_CEE_PURE */
#define _VA_LIST_DEFINED
#endif  /* _VA_LIST_DEFINED */

#ifdef _USE_32BIT_TIME_T
#ifdef _WIN64
#error You cannot use 32-bit time_t (_USE_32BIT_TIME_T) with _WIN64
#undef  _USE_32BIT_TIME_T
#endif  /* _WIN64 */
#endif  /* _USE_32BIT_TIME_T */

#ifndef _ERRCODE_DEFINED
#define _ERRCODE_DEFINED
/* errcode is deprecated in favor or errno_t, which is part of the standard proposal */
#if !defined (__midl)
_CRT_DEPRECATE_TEXT("This name was supported during some Whidbey pre-releases. Instead, use the standard name errno_t." ) typedef int errcode;
#else  /* !defined (__midl) */
typedef int errcode;
#endif  /* !defined (__midl) */

typedef int errno_t;
#endif  /* _ERRCODE_DEFINED */

#ifndef _TIME32_T_DEFINED
typedef _W64 long __time32_t;   /* 32-bit time value */
#define _TIME32_T_DEFINED
#endif  /* _TIME32_T_DEFINED */

#ifndef _TIME64_T_DEFINED
typedef __int64 __time64_t;     /* 64-bit time value */
#define _TIME64_T_DEFINED
#endif  /* _TIME64_T_DEFINED */

#ifndef _TIME_T_DEFINED
#ifdef _USE_32BIT_TIME_T
typedef __time32_t time_t;      /* time value */
#else  /* _USE_32BIT_TIME_T */
typedef __time64_t time_t;      /* time value */
#endif  /* _USE_32BIT_TIME_T */
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif  /* _TIME_T_DEFINED */

#ifndef _CONST_RETURN
#ifdef __cplusplus
#define _CONST_RETURN  const
#define _CRT_CONST_CORRECT_OVERLOADS
#else  /* __cplusplus */
#define _CONST_RETURN
#endif  /* __cplusplus */
#endif  /* _CONST_RETURN */

#if !defined (UNALIGNED)
#if defined (_M_IA64) || defined (_M_AMD64)
#define UNALIGNED __unaligned
#else  /* defined (_M_IA64) || defined (_M_AMD64) */
#define UNALIGNED
#endif  /* defined (_M_IA64) || defined (_M_AMD64) */
#endif  /* !defined (UNALIGNED) */

#if !defined (_CRT_ALIGN)
#if defined (__midl)
#define _CRT_ALIGN(x)
#else  /* defined (__midl) */
#define _CRT_ALIGN(x) __declspec(align(x))
#endif  /* defined (__midl) */
#endif  /* !defined (_CRT_ALIGN) */

/* Define _CRTNOALIAS, _CRTRESTRICT */

#if _MSC_FULL_VER >= 13102050
#if !defined (_MSC_VER_GREATER_THEN_13102050)
#define _MSC_VER_GREATER_THEN_13102050
#endif  /* !defined (_MSC_VER_GREATER_THEN_13102050) */
#endif  /* _MSC_FULL_VER >= 13102050 */

#if ( defined(_M_IA64) && defined(_MSC_VER_GREATER_THEN_13102050) ) || _MSC_VER >= 1400
#ifndef _CRTNOALIAS
#define _CRTNOALIAS __declspec(noalias)
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT __declspec(restrict)
#endif  /* _CRTRESTRICT */

#else  /* ( defined(_M_IA64) && defined(_MSC_VER_GREATER_THEN_13102050) ) || _MSC_VER >= 1400 */

#ifndef _CRTNOALIAS
#define _CRTNOALIAS
#endif  /* _CRTNOALIAS */

#ifndef _CRTRESTRICT
#define _CRTRESTRICT
#endif  /* _CRTRESTRICT */

#endif  /* ( defined(_M_IA64) && defined(_MSC_VER_GREATER_THEN_13102050) ) || _MSC_VER >= 1400 */

/* Define __cdecl for non-Microsoft compilers */
#if (!defined (_MSC_VER) && !defined (__cdecl))
#define __cdecl
#endif  /* (!defined (_MSC_VER) && !defined (__cdecl)) */

#if !defined (__CRTDECL)
#if defined (_M_CEE_PURE)
#define __CRTDECL
#else  /* defined (_M_CEE_PURE) */
#define __CRTDECL   __cdecl
#endif  /* defined (_M_CEE_PURE) */
#endif  /* !defined (__CRTDECL) */

#ifndef _INTERNAL_IFSTRIP_
#define __UPDATE_LOCALE(ptd, ptloci)  if( ( (ptloci) != __ptlocinfo) &&      \
                                          !( (ptd)->_ownlocale & __globallocalestatus)) \
                                      {                                     \
                                          (ptloci) = __updatetlocinfo();    \
                                      }

#define __UPDATE_MBCP(ptd, ptmbci)  if( ( (ptmbci) != __ptmbcinfo) &&      \
                                          !( (ptd)->_ownlocale & __globallocalestatus)) \
                                      {                                     \
                                          (ptmbci) = __updatetmbcinfo();    \
                                      }

/* small function to set global read-only variables */
#ifndef _DEFINE_SET_FUNCTION
#define _DEFINE_SET_FUNCTION(_FuncName, _Type, _VarName) \
    __inline \
    void _FuncName(_Type _Value) \
    { \
        __pragma(warning(push)) \
        __pragma(warning(disable:4996)) \
        _VarName = _Value; \
        __pragma(warning(pop)) \
    }
#endif  /* _DEFINE_SET_FUNCTION */

#endif  /* _INTERNAL_IFSTRIP_ */

#define _ARGMAX 100

/* _TRUNCATE */
#if !defined (_TRUNCATE)
#define _TRUNCATE ((size_t)-1)
#endif  /* !defined (_TRUNCATE) */

/* helper macros for cpp overloads */
#if !defined (RC_INVOKED)
#if defined (__cplusplus) && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType, _FuncName, _DstType, _Dst) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) \
    { \
        return _FuncName(_Dst, _Size); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        return _FuncName(_Dst, _Size, _TArg1); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return _FuncName(_Dst, _Size, _TArg1, _TArg2); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return _FuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        return _FuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        return _FuncName(_HArg1, _Dst, _Size, _TArg1); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return _FuncName(_HArg1, _Dst, _Size, _TArg1, _TArg2); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return _FuncName(_HArg1, _Dst, _Size, _TArg1, _TArg2, _TArg3); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst) \
    extern "C++" \
    { \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[_Size]) \
    { \
        return _FuncName(_HArg1, _HArg2, _Dst, _Size); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1) \
    extern "C++" \
    { \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        return _VFuncName(_Dst, _Size, _TArg1, _ArgList); \
    } \
        __pragma(warning(pop)); \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    extern "C++" \
    { \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        return _VFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList); \
    } \
        __pragma(warning(pop)); \
    }

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType, _FuncName, _DstType, _Src) \
    extern "C++" \
    { \
    template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> \
    inline \
    _ReturnType __CRTDECL _FuncName(_In_ const _DstType *_Src, _DstType (&_Drive)[_DriveSize], _DstType (&_Dir)[_DirSize], _DstType (&_Name)[_NameSize], _DstType (&_Ext)[_ExtSize]) \
    { \
        return _FuncName(_Src, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); \
    } \
    }

#else  /* defined (__cplusplus) && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES */

#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType, _FuncName, _DstType, _Dst)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType, _FuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType, _FuncName, _HType1, _HArg1, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _DstType, _Dst)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType, _FuncName, _VFuncName, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType, _FuncName, _DstType, _Src)

#endif  /* defined (__cplusplus) && _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES */
#endif  /* !defined (RC_INVOKED) */

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _VFuncName, _VFuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _VFuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst) \

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName##_s, _VFuncName, _VFuncName##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#if !defined (RC_INVOKED)
#if defined (__cplusplus) && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES

#define __RETURN_POLICY_SAME(_FunctionCall, _Dst) return (_FunctionCall)
#define __RETURN_POLICY_DST(_FunctionCall, _Dst) return ((_FunctionCall) == 0 ? _Dst : 0)
#define __RETURN_POLICY_VOID(_FunctionCall, _Dst) (_FunctionCall); return
#define __EMPTY_DECLSPEC

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst); \
        return _FuncName(_Dst); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst) \
    { \
        return __insecure_##_FuncName(_Dst); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst); \
        return _FuncName(_Dst); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst) \
    { \
        return __insecure_##_FuncName(_Dst); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size]) \
    { \
        size_t _SizeRead = 0; \
        errno_t _Err = _FuncName##_s(_Dst + 2, (_Size - 2) < ((size_t)_Dst[0]) ? (_Size - 2) : ((size_t)_Dst[0]), &_SizeRead); \
        _Dst[1] = (_DstType)(_SizeRead); \
        return (_Err == 0 ? _Dst + 2 : 0); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) \
    { \
        return __insecure_##_FuncName((_DstType *)_Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName<2>(_DstType (&_Dst)[2]) \
    { \
        return __insecure_##_FuncName((_DstType *)_Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1); \
        return _FuncName(_Dst, _TArg1); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2); \
        return _FuncName(_Dst, _TArg1, _TArg2); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3); \
        return _FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4); \
        return _FuncName(_Dst, _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3, _TArg4); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3, _TArg4), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3, _TArg4), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _DstType *_Dst, _TType1 _TArg1); \
        return _FuncName(_HArg1, _Dst, _TArg1); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_HArg1, static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, const _T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_HArg1, static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType * &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_HArg1, _Dst, _TArg1); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _DstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_HArg1, _Dst, _Size, _TArg1), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_HType1 _HArg1, _DstType (&_Dst)[1], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_HArg1, _Dst, 1, _TArg1), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst) \
    { \
        _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType *_Dst); \
        return _FuncName(_HArg1, _HArg2, _Dst); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _T &_Dst) \
    { \
        return __insecure_##_FuncName(_HArg1, _HArg2, static_cast<_DstType *>(_Dst)); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, const _T &_Dst) \
    { \
        return __insecure_##_FuncName(_HArg1, _HArg2, static_cast<_DstType *>(_Dst)); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType * &_Dst) \
    { \
        return __insecure_##_FuncName(_HArg1, _HArg2, _Dst); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[_Size]) \
    { \
        _ReturnPolicy(_SecureFuncName(_HArg1, _HArg2, _Dst, _Size), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_HType1 _HArg1, _HType2 _HArg2, _DstType (&_Dst)[1]) \
    { \
        _ReturnPolicy(_SecureFuncName(_HArg1, _HArg2, _Dst, 1), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _ArgList) \
    { \
        _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, va_list _ArgList); \
        return _VFuncName(_Dst, _TArg1, _ArgList); \
    } \
    extern "C++" \
    { \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
    } \
        __pragma(warning(pop)); \
        \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
        template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        return __insecure_##_VFuncName(_Dst, _TArg1, _ArgList); \
    } \
        __pragma(warning(pop)); \
        \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
        template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _ArgList), _Dst); \
    } \
        __pragma(warning(pop)); \
        \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg1); \
        _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _ArgList), _Dst); \
    } \
        __pragma(warning(pop)); \
        \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(_T &_Dst, _TType1 _TArg1, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(const _T &_Dst, _TType1 _TArg1, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _ArgList); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(_DstType *&_Dst, _TType1 _TArg1, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(_Dst, _TArg1, _ArgList); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _VFuncName(_DstType (&_Dst)[_Size], _TType1 _TArg1, va_list _ArgList) \
    { \
        _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _ArgList), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, va_list _ArgList) \
    { \
        _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _ArgList), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureVFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        _DeclSpec _ReturnType __cdecl _VFuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList); \
        return _VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
    } \
    extern "C++" \
    { \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
    template <typename _T> \
    inline \
        _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
    } \
    template <typename _T> \
    inline \
        _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
    } \
        __pragma(warning(pop)); \
        \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
    template <> \
    inline \
        _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        return __insecure_##_VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
    } \
        __pragma(warning(pop)); \
        \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList), _Dst); \
    } \
        __pragma(warning(pop)); \
        \
        __pragma(warning(push)); \
        __pragma(warning(disable: 4793)); \
    template <> \
    inline \
        _CRT_INSECURE_DEPRECATE(_FuncName##_s) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, ...) \
    { \
        va_list _ArgList; \
        _crt_va_start(_ArgList, _TArg2); \
        _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _TArg2, _ArgList), _Dst); \
    } \
        __pragma(warning(pop)); \
        \
    template <typename _T> \
    inline \
        _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
    } \
    template <typename _T> \
    inline \
        _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _ArgList); \
    } \
    template <> \
    inline \
        _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName(_DstType *&_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        return __insecure_##_VFuncName(_Dst, _TArg1, _TArg2, _ArgList); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _VFuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        _ReturnPolicy(_SecureVFuncName(_Dst, _Size, _TArg1, _TArg2, _ArgList), _Dst); \
    } \
    template <> \
    inline \
        _CRT_INSECURE_DEPRECATE(_SecureVFuncName) \
    _ReturnType __CRTDECL _VFuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, va_list _ArgList) \
    { \
        _ReturnPolicy(_SecureVFuncName(_Dst, 1, _TArg1, _TArg2, _ArgList), _Dst); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __inline \
    size_t __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _DeclSpec size_t __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2); \
        return _FuncName(_Dst, _TArg1, _TArg2); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
    } \
    template <size_t _Size> \
    inline \
    size_t __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        size_t _Ret = 0; \
        _SecureFuncName(&_Ret, _Dst, _Size, _TArg1, _TArg2); \
        return (_Ret > 0 ? (_Ret - 1) : _Ret); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        size_t _Ret = 0; \
        _SecureFuncName(&_Ret, _Dst, 1, _TArg1, _TArg2); \
        return (_Ret > 0 ? (_Ret - 1) : _Ret); \
    } \
    }

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __inline \
    size_t __CRTDECL __insecure_##_FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _DeclSpec size_t __cdecl _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3); \
        return _FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    template <size_t _Size> \
    inline \
    size_t __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        size_t _Ret = 0; \
        _SecureFuncName(&_Ret, _Dst, _Size, _TArg1, _TArg2, _TArg3); \
        return (_Ret > 0 ? (_Ret - 1) : _Ret); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    size_t __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        size_t _Ret = 0; \
        _SecureFuncName(&_Ret, _Dst, 1, _TArg1, _TArg2, _TArg3); \
        return (_Ret > 0 ? (_Ret - 1) : _Ret); \
    } \
    }

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst)); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst) \
    { \
        return __insecure_##_FuncName(_Dst); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size]) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1]) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1), _Dst); \
    } \
    }

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1), _Dst); \
    } \
    }

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2), _Dst); \
    } \
    }

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __inline \
    _ReturnType __CRTDECL __insecure_##_FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    extern "C++" \
    { \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <typename _T> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(const _T &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(static_cast<_DstType *>(_Dst), _TArg1, _TArg2, _TArg3); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName(_DstType * &_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        return __insecure_##_FuncName(_Dst, _TArg1, _TArg2, _TArg3); \
    } \
    template <size_t _Size> \
    inline \
    _ReturnType __CRTDECL _FuncName(_SecureDstType (&_Dst)[_Size], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, _Size, _TArg1, _TArg2, _TArg3), _Dst); \
    } \
    template <> \
    inline \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    _ReturnType __CRTDECL _FuncName<1>(_DstType (&_Dst)[1], _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3) \
    { \
        _ReturnPolicy(_SecureFuncName(_Dst, 1, _TArg1, _TArg2, _TArg3), _Dst); \
    } \
    }

#if !defined (RC_INVOKED) && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _VFuncName##_s, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
    __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType _DstType, _Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
    __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
    __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType _DstType, _Dst, _TType1, _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
    __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#else  /* !defined (RC_INVOKED) && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT */

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
        _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
        _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName,_VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#endif  /* !defined (RC_INVOKED) && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT */

#else  /* defined (__cplusplus) && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES */

#define __RETURN_POLICY_SAME(_FunctionCall)
#define __RETURN_POLICY_DST(_FunctionCall)
#define __RETURN_POLICY_VOID(_FunctionCall)
#define __EMPTY_DECLSPEC

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType, _DeclSpec, _FuncName, _SalAttributeDst, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureVFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _SecureFuncName, _VFuncName, _SecureVFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); \
    _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_FuncName##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); \
    _CRT_INSECURE_DEPRECATE(_VFuncName##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);

#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3) \
    _CRT_INSECURE_DEPRECATE(_SecureFuncName) \
    __inline \
    _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)

#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _FuncName, _SecureFuncName, _SecureDstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)

#endif  /* defined (__cplusplus) && _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES */
#endif  /* !defined (RC_INVOKED) */

struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;

#ifndef _TAGLC_ID_DEFINED
typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;
#define _TAGLC_ID_DEFINED
#endif  /* _TAGLC_ID_DEFINED */

#ifndef _THREADLOCALEINFO
typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6]; /* LCID */
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;
#define _THREADLOCALEINFO
#endif  /* _THREADLOCALEINFO */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if defined (_PREFAST_) && defined (_PFT_SHOULD_CHECK_RETURN)
#define _Check_return_opt_ _Check_return_
#else  /* defined (_PREFAST_) && defined (_PFT_SHOULD_CHECK_RETURN) */
#define _Check_return_opt_
#endif  /* defined (_PREFAST_) && defined (_PFT_SHOULD_CHECK_RETURN) */

#if defined (_PREFAST_) && defined (_PFT_SHOULD_CHECK_RETURN_WAT)
#define _Check_return_wat_ _Check_return_
#else  /* defined (_PREFAST_) && defined (_PFT_SHOULD_CHECK_RETURN_WAT) */
#define _Check_return_wat_
#endif  /* defined (_PREFAST_) && defined (_PFT_SHOULD_CHECK_RETURN_WAT) */

#if !defined (__midl) && !defined (MIDL_PASS) && defined (_PREFAST_)
#define __crt_typefix(ctype)              __declspec("SAL_typefix(" __CRT_STRINGIZE(ctype) ")")
#else  /* !defined (__midl) && !defined (MIDL_PASS) && defined (_PREFAST_) */
#define __crt_typefix(ctype)
#endif  /* !defined (__midl) && !defined (MIDL_PASS) && defined (_PREFAST_) */

#if (defined (__midl))
/* suppress tchar inlines */
#ifndef _NO_INLINING
#define _NO_INLINING
#endif  /* _NO_INLINING */
#endif  /* (defined (__midl)) */

#ifndef _CRT_UNUSED
#define _CRT_UNUSED(x) (void)x
#endif  /* _CRT_UNUSED */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_CRTDEFS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtmboxw.c ===
/***
*crtmboxw.c - CRT MessageBoxB wrapper.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Wrap MessageBoxW.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "crtmbox.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtdll.c ===
/***
*crtdll.c - CRT initialization for a DLL using the MSVCRT* model of C run-time
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains the initialization entry point for the C run-time
*       stub in this DLL.  All C run-time code is located in the C Run-Time
*       Library DLL "MSVCRT*.DLL", except for a little bit of start-up code in
*       the EXE, and this code in each DLL.  This code is necessary to invoke
*       the C++ constructors for the C++ code in this DLL.
*
*       This entry point should either be specified as the DLL initialization
*       entry point, or else it must be called by the DLL initialization entry
*       point of the DLL with the same arguments that the entry point receives.
*
*******************************************************************************/

#ifdef CRTDLL

/*
 * SPECIAL BUILD MACRO! Note that crtexe.c (and crtexew.c) is linked in with
 * the client's code. It does not go into crtdll.dll! Therefore, it must be
 * built under the _DLL switch (like user code) and CRTDLL must be undefined.
 */
#undef  CRTDLL
#ifndef _DLL
#define _DLL
#endif  /* _DLL */

/*
 * We need the manifest information in crtdll.obj so that user dll's which
 * do not include any headers get a manifest
 */
#undef _CRT_NOFORCE_MANIFEST
#undef _VC_NODEFAULTLIB

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <stdlib.h>
#include <windows.h>
#define _DECL_DLLMAIN   /* enable prototypes for DllMain and _CRT_INIT */
#include <process.h>
#include <dbgint.h>
#include <rtcapi.h>
#include <sect_attribs.h>
#include <rterr.h>
#include <locale.h>

#ifdef _M_IX86

/*
 * The local copy of the Pentium FDIV adjustment flag
 *      and the address of the flag in MSVCRT*.DLL.
 */

extern int _adjust_fdiv;

extern int * _imp___adjust_fdiv;

#endif  /* _M_IX86 */


/*
 * routine in DLL to do initialization (in this case, C++ constructors)
 */

extern void __cdecl _initterm(_PVFV *, _PVFV *);
#ifndef _SYSCRT
extern int __cdecl _initterm_e(_PIFV *, _PIFV *);
extern void __cdecl __clean_type_info_names(void);
#endif  /* _SYSCRT */

/*
 * pointers to initialization sections
 */

extern _CRTALLOC(".CRT$XIA") _PIFV __xi_a[];
extern _CRTALLOC(".CRT$XIZ") _PIFV __xi_z[];    /* C initializers */
extern _CRTALLOC(".CRT$XCA") _PVFV __xc_a[];
extern _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[];    /* C++ initializers */

/*
 * Pointer to callback function to initialize any dynamically initialized
 * __declspec(thread) variables.  This relies on a subtle aspect of C.
 * The pointer is defined here uninitialized.  It is defined initialized in
 * tlsdyn.c.  If user code uses dynamically initialized __declspec(thread)
 * variables, then compiler-injected dependencies cause tlsdyn.obj to be
 * linked.  In that case, the non-zero definition of __dyn_tls_init_callback
 * in tlsdyn.obj will take precedence, and the startup code will execute the
 * callback.  This use of multiple definitions is only legal in C, not C++.
 */

const PIMAGE_TLS_CALLBACK __dyn_tls_init_callback;

/*
 * flag set iff _CRTDLL_INIT was called with DLL_PROCESS_ATTACH
 */
static int __proc_attached = 0;


/*
 * Pointers to beginning and end of the table of function pointers manipulated
 * by _onexit()/atexit().  The atexit/_onexit code is shared for both EXE's and
 * DLL's but different behavior is required.  These values are initialized to
 * 0 by default and will be set to point to a malloc-ed memory block to mark
 * this module as an DLL.
 * NOTE - the pointers are stored encoded.
 */

extern _PVFV *__onexitbegin;
extern _PVFV *__onexitend;


/*
 * User routine DllMain is called on all notifications
 */

extern BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        ) ;

/*
 * _pRawDllMain MUST be an extern const variable, which will be aliased to
 * _pDefaultRawDllMain if no real user definition is present, thanks to the
 * alternatename directive.
 */

extern BOOL (WINAPI * const _pRawDllMain)(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI * const _pDefaultRawDllMain)(HANDLE, DWORD, LPVOID) = NULL;
#if defined (_M_IX86)
#pragma comment(linker, "/alternatename:__pRawDllMain=__pDefaultRawDllMain")
#elif defined (_M_IA64) || defined (_M_AMD64)
#pragma comment(linker, "/alternatename:_pRawDllMain=_pDefaultRawDllMain")
#else  /* defined (_M_IA64) || defined (_M_AMD64) */
#error Unsupported platform
#endif  /* defined (_M_IA64) || defined (_M_AMD64) */

static int __cdecl pre_c_init(void);

_CRTALLOC(".CRT$XIAA") static _PIFV pcinit = pre_c_init;

/***
*pre_c_init(void)
*
*Purpose:
*       The code in mainCRTStartup that was executed before executing C
*       initializers was shifted in this function. Also this funciton is the
*       first thing that is executed in c init section.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

static int __cdecl pre_c_init(void)
{
    _PVFV * onexitbegin;

    /*
     * create the onexit table.
     */
    onexitbegin = (_PVFV *)_malloc_crt(32 * sizeof(_PVFV));
    __onexitend = __onexitbegin = (_PVFV *)_encode_pointer(onexitbegin);

    if ( onexitbegin == NULL )
        /*
         * cannot allocate minimal required
         * size. generate failure to load DLL
         */
        return 1;

    *onexitbegin = (_PVFV) NULL;

    /*
     * Run the RTC initialization code for this DLL
     */
#ifdef _RTC
    _RTC_Initialize();
    atexit(_RTC_Terminate);
#endif  /* _RTC */
#ifndef _SYSCRT
        /*
     * Register __clean_type_info_names so that we clean up all the
     * type_info.names that are allocated
         */
    atexit(__clean_type_info_names);
#endif  /* _SYSCRT */

    return 0;
}

/***
*BOOL WINAPI _CRT_INIT(hDllHandle, dwReason, lpreserved) - C++ DLL
*       initialization.
*BOOL WINAPI _DllMainCRTStartup(hDllHandle, dwReason, lpreserved) - C++ DLL
*       initialization.
*
*Purpose:
*       This is the entry point for DLL's linked with the C/C++ run-time libs.
*       This routine does the C runtime initialization for a DLL linked with
*       MSVCRT.LIB (whose C run-time code is thus in MSVCRT*.DLL.)
*       It will call the user notification routine DllMain on all 4 types of
*       DLL notifications.  The return code from this routine is the return
*       code from the user notification routine.
*
*       On DLL_PROCESS_ATTACH, the C++ constructors for the DLL will be called.
*
*       On DLL_PROCESS_DETACH, the C++ destructors and _onexit/atexit routines
*       will be called.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

BOOL WINAPI _CRT_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        /*
         * If this is a process detach notification, check that there has
         * been a prior (successful) process attachment.
         */
        if ( dwReason == DLL_PROCESS_DETACH ) {
            if ( __proc_attached > 0 )
                __proc_attached--;
            else
                /*
                 * no prior process attach. just return failure.
                 */
                return FALSE;
        }

#ifdef _M_IX86

        /*
         * Set the local copy of the Pentium FDIV adjustment flag
         */

        _adjust_fdiv = * _imp___adjust_fdiv;

#endif  /* _M_IX86 */

        /*
         * do C++ constructors (initializers) specific to this DLL
         */

        if ( dwReason == DLL_PROCESS_ATTACH ) {
            /*
             * There is a possiblity that the module where this object is
             * linked into is a mixed module. In all the cases we gurantee
             * that native initialization will occur before managed
             * initialization.  Also in anycase this code should never be
             * called when some other code is initializing native code,
             * that's why we exit in that case.
             *
             * The case that is illegal is when managed code is executed for
             * the first time in loader lock. But there can be case when dll is
             * loaded in LoadLibrary and CLR could be already loaded in this
             * case it is perfectly OK to execute .cctor.
             */

            void *lock_free=0;
            void *fiberid=((PNT_TIB)NtCurrentTeb())->StackBase;

            int nested=FALSE;
            while((lock_free=InterlockedCompareExchangePointer((volatile PVOID *)&__native_startup_lock, fiberid, 0))!=0)
            {
                if(lock_free==fiberid)
                {
                    nested=TRUE;
                    break;
                }

                /* some other thread is running native startup/shutdown during a cctor/domain unload.
                    Should only happen if this DLL was built using the Everett-compat loader lock fix in vcclrit.h
                */
                /* wait for the other thread to complete init before we return */
                Sleep(1000);
            }

            if (__native_startup_state != __uninitialized)
            {
                _amsg_exit( _RT_CRT_INIT_CONFLICT);
            }
            else
            {
                /*
                * Set the native startup state to initializing.
                */
                __native_startup_state = __initializing;


                /*
                * Invoke C initializers.
                */

#ifndef _SYSCRT
                if (_initterm_e( __xi_a, __xi_z ) != 0)
                    return FALSE;
#else  /* _SYSCRT */
                _initterm((_PVFV *)(void *)__xi_a, (_PVFV *)(void *)__xi_z);
#endif  /* _SYSCRT */
                /*
                * Invoke C++ constructors
                */
                _initterm(__xc_a,__xc_z);

                /*
                * Set the native initialization state to initialized.
                */
                __native_startup_state = __initialized;
            }
            if(!nested)
            {
                /* For X86, the definition of InterlockedExchangePointer wrongly causes warning C4312 */
#pragma warning(push)
#pragma warning(disable:4312)
                InterlockedExchangePointer((volatile PVOID *)&__native_startup_lock,0);
#pragma warning(pop)
            }

            /*
             * If we have any dynamically initialized __declspec(thread)
             * variables, then invoke their initialization for the thread on
             * which the DLL is being loaded, by calling __dyn_tls_init through
             * a callback defined in tlsdyn.obj.  We can't rely on the OS
             * calling __dyn_tls_init with DLL_PROCESS_ATTACH because, on
             * Win2K3 and before, that call happens before the CRT is
             * initialized.
             */
            if (__dyn_tls_init_callback != NULL &&
                _IsNonwritableInCurrentImage((PBYTE)&__dyn_tls_init_callback))
            {
                __dyn_tls_init_callback(hDllHandle, DLL_THREAD_ATTACH,
                                        lpreserved);
            }

            /* Enable buffer count checking if linking against static lib */
            _CrtSetCheckCount(TRUE);

            /*
             * Increment the process attached flag.
             */
            __proc_attached++;

        }
        else if ( dwReason == DLL_PROCESS_DETACH )
        {

            /*
             * Any basic clean-up code that goes here must be
             * duplicated below in _DllMainCRTStartup for the
             * case where the user's DllMain() routine fails on a
             * Process Attach notification. This does not include
             * calling user C++ destructors, etc.
             */

            /*
             * do _onexit/atexit() terminators
             * (if there are any)
             *
             * These terminators MUST be executed in
             * reverse order (LIFO)!
             *
             * NOTE:
             *  This code assumes that __onexitbegin
             *  points to the first valid onexit()
             *  entry and that __onexitend points
             *  past the last valid entry. If
             *  __onexitbegin == __onexitend, the
             *  table is empty and there are no
             *  routines to call.
             */

            void *lock_free=0;
            void *fiberid=((PNT_TIB)NtCurrentTeb())->StackBase;

            int nested=FALSE;
            while((lock_free=InterlockedCompareExchangePointer((volatile PVOID *)&__native_startup_lock, fiberid, 0))!=0)
            {
                if(lock_free==fiberid)
                {
                    nested=TRUE;
                    break;
                }

                /* some other thread is running native startup/shutdown during a cctor/domain unload.
                    Should only happen if this DLL was built using the Everett-compat loader lock fix in vcclrit.h
                */
                /* wait for the other thread to complete init before we return */
                Sleep(1000);
            }

            if(__native_startup_state!=__initialized)
            {
                /* somehow we are in a very bad state running shutdown when we have not started */
                _amsg_exit( _RT_CRT_INIT_CONFLICT);
            }
            else
            {
                _PVFV * onexitbegin = (_PVFV *)_decode_pointer(__onexitbegin);
                if (onexitbegin)
                {
                    _PVFV * onexitend = (_PVFV *)_decode_pointer(__onexitend);
                    _PVFV function_to_call = NULL;

                    /* save the start and end for later comparison */
                    _PVFV * onexitbegin_saved = onexitbegin;
                    _PVFV * onexitend_saved = onexitend;

                    while (1)
                    {
                        _PVFV * onexitbegin_new = NULL;
                        _PVFV * onexitend_new = NULL;

                        /* find the last valid function pointer to call. */
                        while (--onexitend >= onexitbegin && (*onexitend == NULL || *onexitend == _encoded_null()))
                        {
                            /* keep going backwards. */
                        }

                        if (onexitend < onexitbegin)
                        {
                            /* there are no more valid entries in the list, we are done. */
                            break;
                        }

                        /* cache the function to call. */
                        function_to_call = (_PVFV)_decode_pointer(*onexitend);

                        /* mark the function pointer as visited. */
                        *onexitend = (_PVFV)_encoded_null();

                        /* call the function, which can eventually change __onexitbegin and __onexitend */
                        (*function_to_call)();

                        onexitbegin_new = (_PVFV *)_decode_pointer(__onexitbegin);
                        onexitend_new = (_PVFV *)_decode_pointer(__onexitend);

                        if ( ( onexitbegin_saved != onexitbegin_new ) || ( onexitend_saved != onexitend_new ) )
                        {
                            /* reset only if either start or end has changed */
                            onexitbegin = onexitbegin_saved = onexitbegin_new;
                            onexitend = onexitend_saved = onexitend_new;
                        }
                    }
                    /*
                    * free the block holding onexit table to
                    * avoid memory leaks.  Also zero the ptr
                    * variables so that they are clearly cleaned up.
                    */

                    _free_crt ( onexitbegin ) ;

                    __onexitbegin = __onexitend = (_PVFV *)_encoded_null();
                }
                __native_startup_state = __uninitialized;
                if(!nested)
                {
                        /* For X86, the definition of InterlockedExchangePointer wrongly causes warning C4312 */
#pragma warning(push)
#pragma warning(disable:4312)
                        InterlockedExchangePointer((volatile PVOID *)&__native_startup_lock,0);
#pragma warning(pop)
                }
            }
       }

       return TRUE;
}

static
BOOL __cdecl
__DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        );

BOOL WINAPI
_DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        if (dwReason == DLL_PROCESS_ATTACH)
        {
            /*
            * The /GS security cookie must be initialized before any exception
            * handling targetting the current image is registered.  No function
            * using exception handling can be called in the current image until
            * after __security_init_cookie has been called.
            */
            __security_init_cookie();
        }

        return __DllMainCRTStartup(hDllHandle, dwReason, lpreserved);
}

__declspec(noinline)
BOOL __cdecl
__DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        BOOL retcode = TRUE;

    __try {
         __native_dllmain_reason = dwReason;
        __try{
            /*
             * If this is a process detach notification, check that there has
             * been a prior process attach notification.
             */
            if ( (dwReason == DLL_PROCESS_DETACH) && (__proc_attached == 0) ) {
                retcode = FALSE;
                __leave;
            }

            if ( dwReason == DLL_PROCESS_ATTACH || dwReason == DLL_THREAD_ATTACH ) {
                if ( _pRawDllMain )
                    retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);

                if ( retcode )
                    retcode = _CRT_INIT(hDllHandle, dwReason, lpreserved);

                if ( !retcode )
                    __leave;
            }

            retcode = DllMain(hDllHandle, dwReason, lpreserved);

            if ( (dwReason == DLL_PROCESS_ATTACH) && !retcode ) {
                /*
                 * The user's DllMain routine returned failure.  Unwind the init.
                 */
                DllMain(hDllHandle, DLL_PROCESS_DETACH, lpreserved);
                _CRT_INIT(hDllHandle, DLL_PROCESS_DETACH, lpreserved);
                if ( _pRawDllMain )
                    (*_pRawDllMain)(hDllHandle, DLL_PROCESS_DETACH, lpreserved);
            }

            if ( (dwReason == DLL_PROCESS_DETACH) ||
                 (dwReason == DLL_THREAD_DETACH) ) {
                if ( _CRT_INIT(hDllHandle, dwReason, lpreserved) == FALSE ) {
                    retcode = FALSE ;
                }

                if ( retcode && _pRawDllMain ) {
                    retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);
                }
            }
        } __except ( __CppXcptFilter(GetExceptionCode(), GetExceptionInformation()) ) {
            retcode = FALSE;
        }
    } __finally
    {
        __native_dllmain_reason = __NO_REASON;
    }

        return retcode ;
}

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtassem.h ===
/***
*crtassem.h - Libraries Assembly information
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has information about Libraries Assembly version.
*
*       [Public]
*
****/

#pragma once

#ifndef _VC_ASSEMBLY_PUBLICKEYTOKEN
#define _VC_ASSEMBLY_PUBLICKEYTOKEN "1fc8b3b9a1e18e3b"
#endif  /* _VC_ASSEMBLY_PUBLICKEYTOKEN */

#ifndef _CRT_ASSEMBLY_VERSION
#define _CRT_ASSEMBLY_VERSION "9.0.21022.8"
#endif  /* _CRT_ASSEMBLY_VERSION */

#ifndef __LIBRARIES_ASSEMBLY_NAME_PREFIX
#define __LIBRARIES_ASSEMBLY_NAME_PREFIX "Microsoft.VC90"
#endif  /* __LIBRARIES_ASSEMBLY_NAME_PREFIX */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#include <crtdefs.h>

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

/* Define NULL here since we depend on it and for back-compat
*/
#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else  /* __cplusplus */
#define NULL    ((void *)0)
#endif  /* __cplusplus */
#endif  /* NULL */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

#if !defined (_M_CEE_PURE)
typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);
typedef int (__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t *, int *);
#else  /* !defined (_M_CEE_PURE) */
typedef int (__clrcall * _CRT_REPORT_HOOK)(int, char *, int *);
typedef int (__clrcall * _CRT_REPORT_HOOKW)(int, wchar_t *, int *);
#endif  /* !defined (_M_CEE_PURE) */

#if defined (_M_CEE)
typedef int (__clrcall *_CRT_REPORT_HOOK_M)(int, char *, int *);
typedef int (__clrcall *_CRT_REPORT_HOOKW_M)(int, wchar_t *, int *);
#endif  /* defined (_M_CEE) */

#define _CRT_RPTHOOK_INSTALL  0
#define _CRT_RPTHOOK_REMOVE   1

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

#if !defined (_M_CEE_PURE)
typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);
#else  /* !defined (_M_CEE_PURE) */
typedef int (__clrcall * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);
#endif  /* !defined (_M_CEE_PURE) */
#if defined (_M_CEE)
typedef int (__clrcall * _CRT_ALLOC_HOOK_M)(int, void *, size_t, int, long, const unsigned char *, int);
#endif  /* defined (_M_CEE) */

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

/*
 * Some bit values for _crtDbgFlag which correspond to frequencies for checking
 * the the heap.
 */
#define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
#define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
#define _CRTDBG_CHECK_EVERY_1024_DF 0x04000000  /* check heap every 1024 heap ops */
/*
We do not check the heap by default at this point because the cost was too high
for some applications. You can still turn this feature on manually.
*/
#define _CRTDBG_CHECK_DEFAULT_DF    0

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

#if !defined (_M_CEE_PURE)
typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);
#else  /* !defined (_M_CEE_PURE) */
typedef void (__clrcall * _CRT_DUMP_CLIENT)(void *, size_t);
#endif  /* !defined (_M_CEE_PURE) */
#if defined (_M_CEE)
typedef void (__clrcall * _CRT_DUMP_CLIENT_M)(void *, size_t);
#endif  /* defined (_M_CEE) */

struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[_MAX_BLOCKS];
        size_t lSizes[_MAX_BLOCKS];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/

/* _STATIC_ASSERT is for enforcing boolean/integral conditions at compile time.
   Since it is purely a compile-time mechanism that generates no code, the check
   is left in even if _DEBUG is not defined. */

#ifndef _STATIC_ASSERT
#define _STATIC_ASSERT(expr) typedef char __static_assert_t[ (expr) ]
#endif  /* _STATIC_ASSERT */

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

/*  We allow our basic _ASSERT macros to be overridden by pre-existing definitions.
    This is not the ideal mechanism, but is helpful in some scenarios and helps avoid
    multiple definition problems */

#ifndef _ASSERT
#define _ASSERT(expr) ((void)0)
#endif  /* _ASSERT */

#ifndef _ASSERTE
#define _ASSERTE(expr) ((void)0)
#endif  /* _ASSERTE */

#ifndef _ASSERT_EXPR
#define _ASSERT_EXPR(expr, expr_str) ((void)0)
#endif  /* _ASSERT_EXPR */

#ifndef _ASSERT_BASE
#define _ASSERT_BASE _ASSERT_EXPR
#endif  /* _ASSERT_BASE */

#define _RPT0(rptno, msg)
#define _RPTW0(rptno, msg)

#define _RPT1(rptno, msg, arg1)
#define _RPTW1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)
#define _RPTW2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)
#define _RPTW3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)
#define _RPTW4(rptno, msg, arg1, arg2, arg3, arg4)

#define _RPT5(rptno, msg, arg1, arg2, arg3, arg4, arg5)
#define _RPTW5(rptno, msg, arg1, arg2, arg3, arg4, arg5)


#define _RPTF0(rptno, msg)
#define _RPTFW0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)
#define _RPTFW1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)
#define _RPTFW2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)
#define _RPTFW3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)
#define _RPTFW4(rptno, msg, arg1, arg2, arg3, arg4)

#define _RPTF5(rptno, msg, arg1, arg2, arg3, arg4, arg5)
#define _RPTFW5(rptno, msg, arg1, arg2, arg3, arg4, arg5)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _recalloc_dbg(p, c, s, t, f, l) _recalloc(p, c, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _aligned_msize_dbg(p, a, o)                         _aligned_msize(p, a, o)
#define _aligned_malloc_dbg(s, a, f, l)                     _aligned_malloc(s, a)
#define _aligned_realloc_dbg(p, s, a, f, l)                 _aligned_realloc(p, s, a)
#define _aligned_recalloc_dbg(p, c, s, a, f, l)             _aligned_recalloc(p, c, s, a)
#define _aligned_free_dbg(p)                                            _aligned_free(p)
#define _aligned_offset_malloc_dbg(s, a, o, f, l)           _aligned_offset_malloc(s, a, o)
#define _aligned_offset_realloc_dbg(p, s, a, o, f, l)       _aligned_offset_realloc(p, s, a, o)
#define _aligned_offset_recalloc_dbg(p, c, s, a, o, f, l)   _aligned_offset_recalloc(p, c, s, a, o)

#define _malloca_dbg(s, t, f, l)        _malloca(s)
#define _freea_dbg(p, t)                _freea(p)

#define _strdup_dbg(s, t, f, l)         _strdup(s)
#define _wcsdup_dbg(s, t, f, l)         _wcsdup(s)
#define _mbsdup_dbg(s, t, f, l)         _mbsdup(s)
#define _tempnam_dbg(s1, s2, t, f, l)   _tempnam(s1, s2)
#define _wtempnam_dbg(s1, s2, t, f, l)  _wtempnam(s1, s2)
#define _fullpath_dbg(s1, s2, le, t, f, l)  _fullpath(s1, s2, le)
#define _wfullpath_dbg(s1, s2, le, t, f, l) _wfullpath(s1, s2, le)
#define _getcwd_dbg(s, le, t, f, l)     _getcwd(s, le)
#define _wgetcwd_dbg(s, le, t, f, l)    _wgetcwd(s, le)
#define _getdcwd_dbg(d, s, le, t, f, l)     _getdcwd(d, s, le)
#define _wgetdcwd_dbg(d, s, le, t, f, l)    _wgetdcwd(d, s, le)
#define _getdcwd_lk_dbg(d, s, le, t, f, l)  _getdcwd_nolock(d, s, le)
#define _wgetdcwd_lk_dbg(d, s, le, t, f, l) _wgetdcwd_nolock(d, s, le)
#define _dupenv_s_dbg(ps1, size, s2, t, f, l)  _dupenv_s(ps1, size, s2)
#define _wdupenv_s_dbg(ps1, size, s2, t, f, l) _wdupenv_s(ps1, size, s2)

#define _CrtSetReportHook(f)                ((_CRT_REPORT_HOOK)0)
#define _CrtGetReportHook()                 ((_CRT_REPORT_HOOK)0)
#define _CrtSetReportHook2(t, f)            ((int)0)
#define _CrtSetReportHookW2(t, f)           ((int)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((_HFILE)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((_CRT_ALLOC_HOOK)0)
#define _CrtGetAllocHook()                  ((_CRT_ALLOC_HOOK)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)
#define _CrtReportBlockType(p)              ((int)-1)

#define _CrtSetDumpClient(f)                ((_CRT_DUMP_CLIENT)0)
#define _CrtGetDumpClient()                 ((_CRT_DUMP_CLIENT)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)
#define _CrtSetDebugFillThreshold(t)        ((size_t)0)

#define _CrtSetCheckCount(f)                ((int)0)
#define _CrtGetCheckCount()                 ((int)0)

#else  /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _MRTIMP */

#ifndef _MRTIMP
#ifdef MRTDLL
#define _MRTIMP __declspec(dllexport)
#else  /* MRTDLL */
#define _MRTIMP __declspec(dllimport)
#endif  /* MRTDLL */
#endif  /* _MRTIMP */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef CRTDLL
#define _CRTIMP __declspec(dllexport)
#else  /* CRTDLL */
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else  /* _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

#ifndef _INTERNAL_IFSTRIP_
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP long * __cdecl __p__crtAssertBusy(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#endif  /* _INTERNAL_IFSTRIP_ */
#if !defined (_M_CEE_PURE)
_CRTIMP extern long _crtAssertBusy;
#endif  /* !defined (_M_CEE_PURE) */

#if !defined (_M_CEE_PURE)
_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(
    void
    );
#endif  /* !defined (_M_CEE_PURE) */

/* _CrtSetReportHook[[W]2]:
 * For IJW, we need 2 versions: 1 for clrcall and one for cdecl.
 * For pure and native, we just need clrcall and cdecl, respectively.
 */
#if !defined (_M_CEE_PURE)
_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
    _In_opt_ _CRT_REPORT_HOOK _PFnNewHook
        );

_CRTIMP int __cdecl _CrtSetReportHook2(
        _In_ int _Mode,
        _In_opt_ _CRT_REPORT_HOOK _PFnNewHook
        );

_CRTIMP int __cdecl _CrtSetReportHookW2(
        _In_ int _Mode,
        _In_opt_ _CRT_REPORT_HOOKW _PFnNewHook
        );
#else  /* !defined (_M_CEE_PURE) */
extern "C++"
{
_MRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _In_opt_ _CRT_REPORT_HOOK _PFnNewHook
        );

_MRTIMP int __cdecl _CrtSetReportHook2(
        _In_ int _Mode,
        _In_opt_ _CRT_REPORT_HOOK _PFnNewHook
        );


_MRTIMP int __cdecl _CrtSetReportHookW2(
        _In_ int _Mode,
        _In_opt_ _CRT_REPORT_HOOKW _PFnNewHook
        );
}
#endif  /* !defined (_M_CEE_PURE) */

#if defined (_M_CEE_MIXED)
extern "C++"
{
_MRTIMP _CRT_REPORT_HOOK_M __cdecl _CrtSetReportHook(
        _In_opt_ _CRT_REPORT_HOOK_M _PFnNewHook
        );


_MRTIMP int __cdecl _CrtSetReportHook2(
        _In_ int _Mode,
        _In_opt_ _CRT_REPORT_HOOK_M _PFnNewHook
        );


_MRTIMP int __cdecl _CrtSetReportHookW2(
        _In_ int _Mode,
        _In_opt_ _CRT_REPORT_HOOKW_M _PFnNewHook
        );

/*
This overload allows NULL to be passed unambiguously in the mixed case
*/
_MRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _In_ int _PFnNewHook
        );
}
#endif  /* defined (_M_CEE_MIXED) */


_CRTIMP int __cdecl _CrtSetReportMode(
        _In_ int _ReportType,
        _In_ int _ReportMode
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        _In_ int _ReportType,
        _In_opt_ _HFILE _ReportFile
        );

_CRTIMP int __cdecl _CrtDbgReport(
        _In_ int _ReportType,
        _In_opt_z_ const char * _Filename,
        _In_ int _Linenumber,
        _In_opt_z_ const char * _ModuleName,
        _In_opt_z_ const char * _Format,
        ...);

_CRTIMP size_t __cdecl _CrtSetDebugFillThreshold(
        _In_ size_t _NewDebugFillThreshold
        );

#if !defined (_NATIVE_WCHAR_T_DEFINED) && defined (_M_CEE_PURE)
extern "C++"
#endif  /* !defined (_NATIVE_WCHAR_T_DEFINED) && defined (_M_CEE_PURE) */
_CRTIMP int __cdecl _CrtDbgReportW(
        _In_ int _ReportType,
        _In_opt_z_ const wchar_t * _Filename,
        _In_ int _LineNumber,
        _In_opt_z_ const wchar_t * _ModuleName,
        _In_opt_z_ const wchar_t * _Format,
        ...);

/* Asserts */
/* We use !! below to ensure that any overloaded operators used to evaluate expr do not end up at operator || */
#define _ASSERT_EXPR(expr, msg) \
        (void) ((!!(expr)) || \
                (1 != _CrtDbgReportW(_CRT_ASSERT, _CRT_WIDE(__FILE__), __LINE__, NULL, msg)) || \
                (_CrtDbgBreak(), 0))

#ifndef _ASSERT
#define _ASSERT(expr)   _ASSERT_EXPR((expr), NULL)
#endif  /* _ASSERT */

#ifndef _ASSERTE
#define _ASSERTE(expr)  _ASSERT_EXPR((expr), _CRT_WIDE(#expr))
#endif  /* _ASSERTE */

/*
We retain _ASSERT_BASE solely for backwards compatibility with those who used it even though they
should not have done so since it was not documented.
*/
#ifndef _ASSERT_BASE
#define _ASSERT_BASE _ASSERT_EXPR
#endif  /* _ASSERT_BASE */

/* Reports with no file/line info */

#if _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RPT_BASE(args) \
        (void) ((1 != _CrtDbgReport args) || \
                (_CrtDbgBreak(), 0))

#define _RPT_BASE_W(args) \
        (void) ((1 != _CrtDbgReportW args) || \
                (_CrtDbgBreak(), 0))
#else  /* _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE) */
#define _RPT_BASE(args) \
        do { if ((1 == _CrtDbgReport args)) \
                _CrtDbgBreak(); } while (0)

#define _RPT_BASE_W(args) \
        do { if ((1 == _CrtDbgReportW args)) \
                _CrtDbgBreak(); } while (0)
#endif  /* _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE) */

#define _RPT0(rptno, msg) \
        _RPT_BASE((rptno, NULL, 0, NULL, "%s", msg))

#define _RPTW0(rptno, msg) \
        _RPT_BASE_W((rptno, NULL, 0, NULL, L"%s", msg))

#define _RPT1(rptno, msg, arg1) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1))

#define _RPTW1(rptno, msg, arg1) \
        _RPT_BASE_W((rptno, NULL, 0, NULL, msg, arg1))

#define _RPT2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPTW2(rptno, msg, arg1, arg2) \
        _RPT_BASE_W((rptno, NULL, 0, NULL, msg, arg1, arg2))

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPTW3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE_W((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))

#define _RPTW4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE_W((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))

#define _RPT5(rptno, msg, arg1, arg2, arg3, arg4, arg5) \
        _RPT_BASE((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4, arg5))

#define _RPTW5(rptno, msg, arg1, arg2, arg3, arg4, arg5) \
        _RPT_BASE_W((rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4, arg5))

/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, "%s", msg))

#define _RPTFW0(rptno, msg) \
        _RPT_BASE_W((rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, L"%s", msg))

#define _RPTF1(rptno, msg, arg1) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1))

#define _RPTFW1(rptno, msg, arg1) \
        _RPT_BASE_W((rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, msg, arg1))

#define _RPTF2(rptno, msg, arg1, arg2) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))

#define _RPTFW2(rptno, msg, arg1, arg2) \
        _RPT_BASE_W((rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, msg, arg1, arg2))

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTFW3(rptno, msg, arg1, arg2, arg3) \
        _RPT_BASE_W((rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, msg, arg1, arg2, arg3))

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#define _RPTFW4(rptno, msg, arg1, arg2, arg3, arg4) \
        _RPT_BASE_W((rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, msg, arg1, arg2, arg3, arg4))

#define _RPTF5(rptno, msg, arg1, arg2, arg3, arg4, arg5) \
        _RPT_BASE((rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4, arg5))

#define _RPTFW5(rptno, msg, arg1, arg2, arg3, arg4, arg5) \
        _RPT_BASE_W((rptno, _CRT_WIDE(__FILE__), __LINE__, NULL, msg, arg1, arg2, arg3, arg4, arg5))

#if _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __debugbreak()
#elif defined (_M_IX86) && !defined (_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif defined (_M_IA64) && !defined (_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtDbgBreak() __break(0x80016)
#else  /* defined (_M_IA64) && !defined (_CRT_PORTABLE) */
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif  /* defined (_M_IA64) && !defined (_CRT_PORTABLE) */

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef _CRTDBG_MAP_ALLOC

#define   malloc(s)             _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)          _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)         _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _recalloc(p, c, s)    _recalloc_dbg(p, c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)         _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)               _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)             _msize_dbg(p, _NORMAL_BLOCK)
#define   _aligned_msize(p, a, o)                   _aligned_msize_dbg(p, a, o)
#define   _aligned_malloc(s, a)                     _aligned_malloc_dbg(s, a, __FILE__, __LINE__)
#define   _aligned_realloc(p, s, a)                 _aligned_realloc_dbg(p, s, a, __FILE__, __LINE__)
#define   _aligned_recalloc(p, c, s, a)             _aligned_recalloc_dbg(p, c, s, a, __FILE__, __LINE__)
#define   _aligned_offset_malloc(s, a, o)           _aligned_offset_malloc_dbg(s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_realloc(p, s, a, o)       _aligned_offset_realloc_dbg(p, s, a, o, __FILE__, __LINE__)
#define   _aligned_offset_recalloc(p, c, s, a, o)   _aligned_offset_recalloc_dbg(p, c, s, a, o, __FILE__, __LINE__)
#define   _aligned_free(p)  _aligned_free_dbg(p)

#define   _malloca(s)        _malloca_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _freea(p)          _freea_dbg(p, _NORMAL_BLOCK)

#define   _strdup(s)         _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _wcsdup(s)         _wcsdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _mbsdup(s)         _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _tempnam(s1, s2)   _tempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _wtempnam(s1, s2)  _wtempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _fullpath(s1, s2, le)     _fullpath_dbg(s1, s2, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _wfullpath(s1, s2, le)    _wfullpath_dbg(s1, s2, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _getcwd(s, le)      _getcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _wgetcwd(s, le)     _wgetcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _getdcwd(d, s, le)  _getdcwd_dbg(d, s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _wgetdcwd(d, s, le) _wgetdcwd_dbg(d, s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _getdcwd_nolock(d, s, le)     _getdcwd_lk_dbg(d, s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _wgetdcwd_nolock(d, s, le)    _wgetdcwd_lk_dbg(d, s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _dupenv_s(ps1, size, s2)      _dupenv_s_dbg(ps1, size, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _wdupenv_s(ps1, size, s2)     _wdupenv_s_dbg(ps1, size, s2, _NORMAL_BLOCK, __FILE__, __LINE__)

#if !__STDC__
#define   strdup(s)          _strdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   wcsdup(s)          _wcsdup_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   tempnam(s1, s2)    _tempnam_dbg(s1, s2, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   getcwd(s, le)      _getcwd_dbg(s, le, _NORMAL_BLOCK, __FILE__, __LINE__)
#endif  /* !__STDC__ */


#endif  /* _CRTDBG_MAP_ALLOC */

#ifndef _INTERNAL_IFSTRIP_
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP long * __cdecl __p__crtBreakAlloc(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#endif  /* _INTERNAL_IFSTRIP_ */
#if !defined (_M_CEE_PURE)
_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */
#endif  /* !defined (_M_CEE_PURE) */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        _In_ long _BreakAlloc
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP void * __cdecl _malloc_dbg(
        _In_ size_t _Size,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP void * __cdecl _calloc_dbg(
        _In_ size_t _Count,
        _In_ size_t _Size,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP void * __cdecl _realloc_dbg(
        _In_opt_ void * _Memory,
        _In_ size_t _NewSize,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_x_(_NumOfElements*_SizeOfElements) _CRTIMP void * __cdecl _recalloc_dbg
(
        _In_opt_ void * _Memory,
        _In_ size_t _NumOfElements,
        _In_ size_t _SizeOfElements,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
);

_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP void * __cdecl _expand_dbg(
        _Inout_opt_ void * _Memory,
        _In_ size_t _NewSize,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_CRTIMP void __cdecl _free_dbg(
        _Inout_opt_ void * _Memory,
        _In_ int _BlockType
        );

_CRTIMP size_t __cdecl _msize_dbg (
        _In_ void * _Memory,
        _In_ int _BlockType
        );

_CRTIMP size_t __cdecl _aligned_msize_dbg (
        _In_ void * _Memory,
        _In_ size_t _Alignment,
        _In_ size_t _Offset
        );

_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP void * __cdecl _aligned_malloc_dbg(
        _In_ size_t _Size,
        _In_ size_t _Alignment,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP void * __cdecl _aligned_realloc_dbg(
        _In_opt_ void * _Memory,
        _In_ size_t _NewSize,
        _In_ size_t _Alignment,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_x_(_NumOfElements*_SizeOfElements) _CRTIMP void * __cdecl _aligned_recalloc_dbg
(
        _In_opt_ void * _Memory,
        _In_ size_t _NumOfElements,
        _In_ size_t _SizeOfElements,
        _In_ size_t _Alignment,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
);

_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        _In_ size_t _Size,
        _In_ size_t _Alignment,
        _In_ size_t _Offset,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        _In_opt_ void * _Memory,
        _In_ size_t _NewSize,
        _In_ size_t _Alignment,
        _In_ size_t _Offset,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_x_(_NumOfElements*_SizeOfElements) _CRTIMP void * __cdecl _aligned_offset_recalloc_dbg
(
        _In_opt_ void * _Memory,
        _In_ size_t _NumOfElements,
        _In_ size_t _SizeOfElements,
        _In_ size_t _Alignment,
        _In_ size_t _Offset,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
);

_CRTIMP void __cdecl _aligned_free_dbg(
        _Inout_opt_ void * _Memory
        );

_Check_return_ _Ret_opt_z_ _CRTIMP char * __cdecl _strdup_dbg(
        _In_opt_z_ const char * _Str,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wcsdup_dbg(
        _In_opt_z_ const wchar_t * _Str,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP char * __cdecl _tempnam_dbg(
        _In_opt_z_ const char * _DirName,
        _In_opt_z_ const char * _FilePrefix,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wtempnam_dbg(
        _In_opt_z_ const wchar_t * _DirName,
        _In_opt_z_ const wchar_t * _FilePrefix,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP char * __cdecl _fullpath_dbg(
        _Out_opt_z_cap_(_SizeInBytes) char * _FullPath,
        _In_z_ const char * _Path,
        _In_ size_t _SizeInBytes,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wfullpath_dbg(
        _Out_opt_z_cap_(_SizeInWords) wchar_t * _FullPath,
        _In_z_ const wchar_t * _Path,
        _In_ size_t _SizeInWords,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP char * __cdecl _getcwd_dbg(
        _Out_opt_z_cap_(_SizeInBytes) char * _DstBuf,
        _In_ int _SizeInBytes,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wgetcwd_dbg(
        _Out_opt_z_cap_(_SizeInWords) wchar_t * _DstBuf,
        _In_ int _SizeInWords,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP char * __cdecl _getdcwd_dbg(
        _In_ int _Drive,
        _Out_opt_z_cap_(_SizeInBytes) char * _DstBuf,
        _In_ int _SizeInBytes,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wgetdcwd_dbg(
        _In_ int _Drive,
        _Out_opt_z_cap_(_SizeInWords) wchar_t * _DstBuf,
        _In_ int _SizeInWords,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ char * __cdecl _getdcwd_lk_dbg(
        _In_ int _Drive,
        _Out_opt_z_cap_(_SizeInBytes) char * _DstBuf,
        _In_ int _SizeInBytes,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_z_ wchar_t * __cdecl _wgetdcwd_lk_dbg(
        _In_ int _Drive,
        _Out_opt_z_cap_(_SizeInWords) wchar_t * _DstBuf,
        _In_ int _SizeInWords,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_wat_ _CRTIMP errno_t __cdecl _dupenv_s_dbg(
        _Out_ _Deref_post_opt_z_cap_(*_PBufferSizeInBytes) char ** _PBuffer,
        _Out_opt_ size_t * _PBufferSizeInBytes,
        _In_z_ const char * _VarName,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_wat_ _CRTIMP errno_t __cdecl _wdupenv_s_dbg(
        _Out_ _Deref_post_opt_z_cap_(*_PBufferSizeInWords) wchar_t ** _PBuffer,
        _Out_opt_ size_t * _PBufferSizeInWords,
        _In_z_ const wchar_t * _VarName,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

#define _malloca_dbg(s, t, f, l)    _malloc_dbg(s, t, f, l)
#define _freea_dbg(p, t)            _free_dbg(p, t)

#if defined (__cplusplus) && defined (_CRTDBG_MAP_ALLOC)
namespace std
{
        using ::_calloc_dbg; using ::_free_dbg; using ::_malloc_dbg; using ::_realloc_dbg;
}
#endif  /* defined (__cplusplus) && defined (_CRTDBG_MAP_ALLOC) */

 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/
#if !defined (_M_CEE_PURE)
_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook
(
    void
);
#endif  /* !defined (_M_CEE_PURE) */

/* _CrtSetAllocHook:
 * For IJW, we need 2 versions: 1 for clrcall and one for cdecl.
 * For pure and native, we just need clrcall and cdecl, respectively.
 */
#if !defined (_M_CEE_PURE)
_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook
(
    _In_opt_ _CRT_ALLOC_HOOK _PfnNewHook
);
#else  /* !defined (_M_CEE_PURE) */
extern "C++"
{
_MRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook
(
    _In_opt_ _CRT_ALLOC_HOOK _PfnNewHook
);
}
#endif  /* !defined (_M_CEE_PURE) */

#if defined (_M_CEE_MIXED)
extern "C++"
{
_MRTIMP _CRT_ALLOC_HOOK_M __cdecl _CrtSetAllocHook
(
    _In_opt_ _CRT_ALLOC_HOOK_M _PfnNewHook
);
}

/* If we have both versions, then we need an int overload to disambiguate for the NULL case */
extern "C++"
{
_MRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook
(
    _In_ int _PfnNewHook
);
}
#endif  /* defined (_M_CEE_MIXED) */


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

#ifndef _INTERNAL_IFSTRIP_
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __cdecl __p__crtDbgFlag(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#endif  /* _INTERNAL_IFSTRIP_ */
#if !defined (_M_CEE_PURE)
_CRTIMP extern int _crtDbgFlag;
#endif  /* !defined (_M_CEE_PURE) */

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        _In_ int _NewFlag
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        _In_ void (__cdecl *_PFn)(void *, void *),
        void * _Context
        );

#if defined (_M_CEE)
extern "C++"
{
_MRTIMP void __cdecl _CrtDoForAllClientObjects(
        _In_ void (__clrcall * _PFn)(void *, void *),
        void * _Context
        );
}
#endif  /* defined (_M_CEE) */

_Check_return_ _CRTIMP int __cdecl _CrtIsValidPointer(
        _In_opt_ const void * _Ptr,
        _In_ unsigned int _Bytes,
        _In_ int _ReadWrite
        );

_Check_return_ _CRTIMP int __cdecl _CrtIsValidHeapPointer(
        _In_opt_ const void * _HeapPtr
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        _In_opt_ const void * _Memory,
        _In_ unsigned int _Bytes,
        _Out_opt_ long * _RequestNumber,
        _Out_opt_ char ** _Filename,
        _Out_opt_ int * _LineNumber
        );

_Check_return_ _CRTIMP int __cdecl _CrtReportBlockType(
        _In_opt_ const void * _Memory
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

#if !defined (_M_CEE_PURE)
_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient
(
    void
);
#endif  /* !defined (_M_CEE_PURE) */

/* _CrtSetDumpClient:
 * For IJW, we need 2 versions: 1 for clrcall and one for cdecl.
 * For pure and native, we just need clrcall and cdecl, respectively.
 */
#if !defined (_M_CEE_PURE)
_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient
(
    _In_opt_ _CRT_DUMP_CLIENT _PFnNewDump
);

#else  /* !defined (_M_CEE_PURE) */
extern "C++"
{
_MRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient
(
    _In_opt_ _CRT_DUMP_CLIENT _PFnNewDump
);
}
#endif  /* !defined (_M_CEE_PURE) */

#if defined (_M_CEE_MIXED)
extern "C++"
{
_MRTIMP _CRT_DUMP_CLIENT_M __cdecl _CrtSetDumpClient
(
    _In_opt_ _CRT_DUMP_CLIENT_M _PFnNewDump
);

/* If we have both versions, then we need an int overload to disambiguate for the NULL case */
_MRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient
(
    _In_ int _PFnNewDump
);
}
#endif  /* defined (_M_CEE_MIXED) */

_CRTIMP _CRT_MANAGED_HEAP_DEPRECATE void __cdecl _CrtMemCheckpoint(
        _Out_ _CrtMemState * _State
        );

_CRTIMP _CRT_MANAGED_HEAP_DEPRECATE int __cdecl _CrtMemDifference(
        _Out_ _CrtMemState * _State,
        _In_ const _CrtMemState * _OldState,
        _In_ const _CrtMemState * _NewState
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        _In_opt_ const _CrtMemState * _State
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        _In_ const _CrtMemState * _State
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

_CRTIMP int __cdecl _CrtSetCheckCount(
        _In_ int _CheckCount
        );

_CRTIMP int __cdecl _CrtGetCheckCount(
        void
        );

#endif  /* _DEBUG */

#ifdef __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

extern "C++" {

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/


#pragma warning(suppress: 4985)
_Ret_bytecap_(_Size) void * __CRTDECL operator new[](size_t _Size);

#if !defined (_M_CEE_PURE)
_Ret_bytecap_(_Size) void * __CRTDECL operator new(
        size_t _Size,
        int,
        const char *,
        int
        );

#pragma warning(suppress: 4985)
_Ret_bytecap_(_Size) void * __CRTDECL operator new[](
        size_t _Size,
        int,
        const char *,
        int
        );

#if _MSC_VER >= 1200


void __CRTDECL operator delete[](void *);

inline void __CRTDECL operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
inline void __CRTDECL operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif  /* _MSC_VER >= 1200 */
#endif  /* !defined (_M_CEE_PURE) */
#else  /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/

#pragma warning(suppress: 4985)
_Ret_bytecap_(_Size) void * __CRTDECL operator new[](size_t _Size);

_Ret_bytecap_(_Size) void * __CRTDECL operator new(
        size_t _Size,
        int,
        const char *,
        int
        );

#pragma warning(suppress: 4985)
_Ret_bytecap_(_Size) void * __CRTDECL operator new[](
        size_t _Size,
        int,
        const char *,
        int
        );

#if _MSC_VER >= 1200
void __CRTDECL operator delete[](void *);

inline void __CRTDECL operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }

inline void __CRTDECL operator delete[](void * _P, int, const char *, int)
        { ::operator delete[](_P); }
#endif  /* _MSC_VER >= 1200 */

#if defined (_CRTDBG_MAP_ALLOC) && defined (_CRTDBG_MAP_ALLOC_NEW)
/* We keep these inlines for back compatibility only;
 * the operator new defined in the debug libraries already calls _malloc_dbg,
 * thus enabling the debug heap allocation functionalities.
 *
 * These inlines do not add any information, due that __FILE__ is expanded
 * to "crtdbg.h", which is not very helpful to the user.
 *
 * The user will need to define _CRTDBG_MAP_ALLOC_NEW in addition to
 * _CRTDBG_MAP_ALLOC to enable these inlines.
 */

_Ret_bytecap_(_Size) inline void * __CRTDECL operator new(size_t _Size)
        { return ::operator new(_Size, _NORMAL_BLOCK, __FILE__, __LINE__); }

_Ret_bytecap_(_Size) inline void* __CRTDECL operator new[](size_t _Size)
        { return ::operator new[](_Size, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* defined (_CRTDBG_MAP_ALLOC) && defined (_CRTDBG_MAP_ALLOC_NEW) */

#endif  /* _DEBUG */

}

#endif  /* _MFC_OVERRIDES_NEW */

#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cruntime.h ===
/***
*cruntime.h - definitions specific to the target operating system and hardware
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This header file contains widely used definitions specific to the
*       host operating system and hardware. It is included by every C source
*       and most every other header file.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_CRUNTIME
#define _INC_CRUNTIME

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#if defined (_SYSCRT) && defined (_WIN64)
#define _USE_OLD_STDCPP 1
#endif  /* defined (_SYSCRT) && defined (_WIN64) */

#if !defined (UNALIGNED)
#if defined (_M_IA64) || defined (_M_AMD64)
#define UNALIGNED __unaligned
#else  /* defined (_M_IA64) || defined (_M_AMD64) */
#define UNALIGNED
#endif  /* defined (_M_IA64) || defined (_M_AMD64) */
#endif  /* !defined (UNALIGNED) */

#ifdef _M_IX86
/*
 * 386/486
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#elif defined (_M_IA64) || defined (_M_AMD64)
/*
 * IA64
 */
#define REG1    register
#define REG2    register
#define REG3    register
#define REG4    register
#define REG5    register
#define REG6    register
#define REG7    register
#define REG8    register
#define REG9    register

#else  /* defined (_M_IA64) || defined (_M_AMD64) */

#pragma message ("Machine register set not defined")

/*
 * Unknown machine
 */

#define REG1
#define REG2
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#endif  /* defined (_M_IA64) || defined (_M_AMD64) */

/*
 * Are the macro definitions below still needed in this file?
 */

#endif  /* _INC_CRUNTIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cscanf.c ===
/***
*cscanf.c - Conio version of scanf
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Perform formatted i/o directly to the keyboard.
*
*******************************************************************************/

#define CPRFLAG 1
#include "input.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cscanfs.c ===
/***
*cscanfs.c - Conio version of scanf_s
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This takes a size from the argument list for all string inputs.
*
*******************************************************************************/

#define CPRFLAG 1
#define _SECURE_SCANF 1
#include "input.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ctime.c ===
/***
*ctime.c - convert time argument to a string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _ctime32() - convert time value to string
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <stddef.h>
#include <tchar.h>

/***
*errno_t _tctime32_s(buffer, sizeInChars, time) - converts a time stored as a __time32_t
*to a string
*
*Purpose:
*       Converts a time stored as a __time32_t to a string of the form:
*              Tue May 01 14:25:03 1984
*
*Entry:
*       __time32_t *time - time value in XENIX format
*
*Exit:
*       errno_t = 0 success
*                 buffer contains time converted to a string
*       errno_t = correct error code
*                 buffer null terminated if it is at least 1 character in size
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tctime32_s (
        _TSCHAR * buffer,
        size_t sizeInChars,
        const __time32_t *timp
        )
{
        struct tm tmtemp;
        errno_t e;

        _VALIDATE_RETURN_ERRCODE(
            ( ( buffer != NULL ) && ( sizeInChars > 0 ) ),
            EINVAL
        )

        _RESET_STRING(buffer, sizeInChars);

        _VALIDATE_RETURN_ERRCODE( ( timp != NULL ), EINVAL )
        _VALIDATE_RETURN_ERRCODE_NOEXC( ( *timp >= 0 ), EINVAL )

        e = _localtime32_s(&tmtemp, timp);
        if ( e == 0 )
        {
            e = _tasctime_s(buffer, sizeInChars, &tmtemp);
        }
        return e;
}

/***
*_TSCHAR *_tctime32(time) - converts a time stored as a __time32_t to a string
*
*Purpose:
*       Converts a time stored as a __time32_t to a string of the form:
*              Tue May 01 14:25:03 1984
*
*Entry:
*       __time32_t *time - time value in XENIX format
*
*Exit:
*       returns pointer to static string or NULL if time is before
*       Jan 1 1980.
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tctime32 (
        const __time32_t *timp
        )
{
        struct tm tmtemp;
        errno_t e;

        _VALIDATE_RETURN( ( timp != NULL ), EINVAL, NULL )
        _VALIDATE_RETURN_NOEXC( ( *timp >= 0 ), EINVAL, NULL )

        e = _localtime32_s(&tmtemp, timp);
        if ( e == 0 )
        {
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
            return(_tasctime(&tmtemp));
_END_SECURE_CRT_DEPRECATION_DISABLE
        }
        else
        {
            return(NULL);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ctime.h ===
/***
*ctime.h - constant for dates and times
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Include file used by the c time routines containing definitions of
*       various constants and macros used in determining dates and times.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_CTIME
#define _INC_CTIME

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

/*
 * Constants
 */
#define _DAY_SEC           (24 * 60 * 60)       /* secs in a day */

#define _YEAR_SEC          (365 * _DAY_SEC)     /* secs in a year */

#define _FOUR_YEAR_SEC     (1461 * _DAY_SEC)    /* secs in a 4 year interval */

#define _DEC_SEC           315532800            /* secs in 1970-1979 */

#define _BASE_YEAR         70                   /* 1970 is the base year */

#define _BASE_DOW          4                    /* 01-01-70 was a Thursday */

#define _LEAP_YEAR_ADJUST  17                   /* Leap years 1900 - 1970 */

#ifdef _WIN64
#define _MAX_YEAR          1100                 /* 3000 is the max year */
#else  /* _WIN64 */
#define _MAX_YEAR          138                  /* 2038 is the max year */
#endif  /* _WIN64 */

#define _MAX_LOCAL_TIME    (13 * 60 * 60)      /* max local time adjustment
                                                   GMT +13 hour
                                                   DST -0  hour             */

#define _MIN_LOCAL_TIME    (-12 * 60 * 60)      /* min local time adjustment
                                                   GMT -11 hour
                                                   DST -1  hour             */

#define _MAX_YEAR64        1100                 /* 3000 is the max year */

#define _MAX__TIME32_T     0x7fffd27f           /* number of seconds from
                                                   00:00:00, 01/01/1970 UTC to
                                                   23:59:59, 01/18/2038 UTC */

#define _MAX__TIME64_T     0x793406fffi64       /* number of seconds from
                                                   00:00:00, 01/01/1970 UTC to
                                                   23:59:59. 12/31/3000 UTC */

/*
 * Macro to determine if a given year, expressed as the number of years since
 * 1900, is a leap year.
 */
#define _IS_LEAP_YEAR(y)        (((y % 4 == 0) && (y % 100 != 0)) || \
                                ((y + 1900) % 400 == 0))

/*
 * Number of leap years from 1970 up to, but not including, the specified year
 * (expressed as the number of years since 1900).
 */
#define _ELAPSED_LEAP_YEARS(y)  (((y - 1)/4) - ((y - 1)/100) + ((y + 299)/400) \
                                - _LEAP_YEAR_ADJUST)

#endif  /* _INC_CTIME */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ctime64.c ===
/***
*ctime64.c - convert time argument to a string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains _ctime64() - convert time value to string
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <stddef.h>
#include <tchar.h>

/***
*errno_t _tctime64_s(buffer, sizeInChars, time) - converts a time stored as a __time64_t
*to a string
*
*Purpose:
*       Converts a time stored as a __time64_t to a string of the form:
*              Tue May 01 14:25:03 1984
*
*Entry:
*       __time64_t *time - time value in XENIX format
*
*Exit:
*       errno_t = 0 success
*                 buffer contains time converted to a string
*       errno_t = correct error code
*                 buffer null terminated if it is at least 1 character in size
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tctime64_s (
        _TSCHAR * buffer,
        size_t sizeInChars,
        const __time64_t *timp
        )
{
        struct tm tmtemp;
        errno_t e;

        _VALIDATE_RETURN_ERRCODE(
            ( ( buffer != NULL ) && ( sizeInChars > 0 ) ),
            EINVAL
        )

        _RESET_STRING(buffer, sizeInChars);

        _VALIDATE_RETURN_ERRCODE( ( timp != NULL ), EINVAL )
        _VALIDATE_RETURN_ERRCODE_NOEXC( ( *timp >= 0 ), EINVAL )
        _VALIDATE_RETURN_ERRCODE_NOEXC( ( *timp <= _MAX__TIME64_T ), EINVAL )

        e = _localtime64_s(&tmtemp, timp);
        if ( e == 0 )
        {
            e = _tasctime_s(buffer, sizeInChars, &tmtemp);
        }
        return e;
}

/***
*_TSCHAR *_tctime64(time) - converts a time stored as a __time64_t to a string
*
*Purpose:
*       Converts a time stored as a __time64_t to a string of the form:
*              Tue May 01 14:25:03 1984
*
*Entry:
*       __time64_t *time - time value in internal, 64-bit format
*
*Exit:
*       returns pointer to static string or NULL if an error occurs
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tctime64 (
        const __time64_t *timp
        )
{
        struct tm tmtemp;
        errno_t e;

        _VALIDATE_RETURN( ( timp != NULL ), EINVAL, NULL )
        _VALIDATE_RETURN_NOEXC( ( *timp >= 0 ), EINVAL, NULL )

        e = _localtime64_s(&tmtemp, timp);
        if ( e == 0 )
        {
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
            return _tasctime(&tmtemp);
_END_SECURE_CRT_DEPRECATION_DISABLE
        }
        else
        {
            return(NULL);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cvt.h ===
/***
*cvt.h - definitions used by formatting routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       cvt.h contains definitions used by the formatting routines [efg]cvt and
*       _output and _input.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_CVT
#define _INC_CVT

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define _SHORT  1
#define _LONG   2
#define _USIGN  4
#define _NEAR   8
#define _FAR    16

#define OCTAL   8
#define DECIMAL 10
#define HEX     16

#define MUL10(x)        ( (((x)<<2) + (x))<<1 )
#define ISDIGIT(c)      ( ((c) >= '0') && ((c) <= '9') )

#endif  /* _INC_CVT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cwprintf.c ===
/***
*cwprintf.c - Conio version of wprintf
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Perform formatted i/o directly to the console.
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#define CPRFLAG 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cwprntfp.c ===
/***
*cwprntfp.c - Positional version of cwprintf
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This has format validations & positional parameters as compared to cwprintf
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#define POSITIONAL_PARAMETERS 1
#define CPRFLAG 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cwprntfs.c ===
/***
*cwprntfs.c - Secure version of cwprintf
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This has format validations as compared to cwprintf
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#define FORMAT_VALIDATIONS 1
#define CPRFLAG 1
#include "output.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cwscanf.c ===
/***
*cscanf.c - Conio version of scanf
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Perform formatted i/o directly to the keyboard.
*
*******************************************************************************/

#define CPRFLAG 1
#include "winput.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\days.c ===
/***
*days.c - static arrays with days from beg of year for each month
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       contains static arrays used by gmtime and statconv to determine
*       date and time values.  Shows days from beg of year.
*
*******************************************************************************/

#include <internal.h>

int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
};

int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgdel.cpp ===
/***
*dbgnew.cpp - defines C++ scalar delete routine, debug version
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ scalar delete() routine.
*
*******************************************************************************/

#ifdef _DEBUG

#include <cruntime.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>

/***
*void operator delete() - delete a block in the debug heap
*
*Purpose:
*       Deletes any type of block.
*
*Entry:
*       void *pUserData - pointer to a (user portion) of memory block in the
*                         debug heap
*
*Return:
*       <void>
*
*******************************************************************************/

void operator delete(
        void *pUserData
        )
{
        _CrtMemBlockHeader * pHead;

        RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));

        if (pUserData == NULL)
            return;

        _mlock(_HEAP_LOCK);  /* block other threads */
        __TRY

            /* get a pointer to memory block header */
            pHead = pHdr(pUserData);

             /* verify block type */
            _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead->nBlockUse));

            _free_dbg( pUserData, pHead->nBlockUse );

        __FINALLY
            _munlock(_HEAP_LOCK);  /* release other threads */
        __END_TRY_FINALLY

        return;
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cruntime.inc ===
;***
;cruntime.inc - multi-model assembly macros for interfacing to HLLs
;
;       Copyright (c) Microsoft Corporation.  All rights reserved.
;
;Purpose:
;       This file defines the current memory model being used.
;
;*******************************************************************************

;==============================================================================
;
;Use the following defines to control processor/segment model
;
;   -DI86               8086/8088 processor
;   -DI286              80286 processor
;   -DI386              80386 processor with 32-bit code/data segment
;
;   -Dmem_S             Small memory model   (near code, near data)
;   -Dmem_M             Medium memory model  (far code, near data)
;   -Dmem_C             Compact memory model (near code, fat data)
;   -Dmem_L             Large memory model   (far code, far data)
;
;   -DSS_NEQ_DGROUP     SS and DS point to different segments
;
;   default is -DI86 -Dmem_S
;
;==============================================================================
;
;The following variables are defined by this file:
;   cpu                         86, 286, or 386
;   sizeC                       code distance; 1 = far code, 0 = near code
;   sizeD                       data distance; 1 = far data, 0 = near data
;   mmodel                      english name of the memory model, i.e. "Medium"
;   ISIZE, LSIZE, NSIZE         size of ints, longs, shorts
;   FLTSIZE, DBLSIZE, LDBLSIZE  size of float, double, long double
;   NPSIZE, FPSIZE              size of near/far pointers
;   CPSIZE, DPSIZE              size of code/data pointers
;   ISHIFT, LSHIFT              bits to shift to convert byte to int/long
;
;The following macros allow easy writing of combined 16/32 bit code:
;
; 16/32 bit registers:
;   rax, rbx, rcx, rdx,         expand to native registers (rax = eax or ax)
;   rsi, rdi, rsp, rbp
; 16/32 bit register instructions:
;   JRCXZ                       jump when rcx is zero
;   CBI                         convert byte to int (al to rax)
;   CAXDX                       convert rax to rax:rdx
;   ZXAL, ZXBL, ZXCL, ZXDL      zero extend al,bl,cl,dl to rax,rbx,rcx,rdx
; Pointer instructions:
;   LPDS, LPES                  load data pointer with ES or DS
;   PDS, PES                    segment overrides when pointer loaded as above
;   PCS, PSS                    segment override to get at code/stack segment
;   LFPDS, LFPES                load far pointer with ES or DS
;   FPDS, FPES                  segment overrides when pointer loaded as above
;   CPTR                        data type of code pointer
;   CPDIST                      distance of code (near/far)
;   DNPTR, DFPTR                define near/far pointer
;   DCPTR, DDPTR                define code/data pointer
;   DCPTR?, DDPTR?              define uninitialized code/data pointer
;   CPWORD, DPWORD              data type of code or data pointer
; Numeric type instructions:
;   IWORD, LWORD, SWORD         data type of int, long, short
;   DINT, DLONG, DSHORT         define int, long, short
;   DFLOAT, DDOUBLE, DLDOUBLE   define float, double, long double
; Offsets:
;   codeoffset, dataoffset      offsets from code and data segments
; API calls:
;   APIDIST                     distance of API calls (near/far)
;   APIEXT ApiName              extrn declaration for an API function
;
;The following utility macros are provided:
;   codeseg                     define/declare code segment
;   error <msg>                 stop assembly with message
;   display <msg>               display a message, unless QUIET defined
;   savelist [<reg> ...]        init list of regs to be save by 'proc uses'
;   _if cond <instruction>      assemble instruction only if cond is TRUE
;   _ife cond <instruction>     assemble instruction only if cond is FALSE
;   _ifd symbol <instruction>   assemble instruction only if symbol defined
;   _ifnd symbol <instruction>  assemble instruction only if symbol not defined
;
;   lab  LabelName              assembles to "LabelName:" If DEBUG is defined
;                               LabelName is made public
;
;   JS* (ex. JSE,JSZ,JSB ...)   assemble to "je short","jz short","jb short"
;
;   Cmacro look alikes
;   static* Name, InitialValue, Repeat   defines a static variable of type *
;   global* Name, InitialValue, Repeat   defines a global variable of type *
;   label*  Name, {PUBLIC,PASCAL,C}      defines a label of type *
;
;   PUSH16  SegmentReg          pushes 16 bits in a use32 segment
;   JMPFAR16  label             will do a far 16:16 jmp from a use32 segment
;
;==============================================================================

; error <msg>   -    Output message and generate error

error   MACRO   msg
if2                     ;; only on pass 2 can we generate errors
        %out    **********************************************************
        %out    *** E r r o r  --  msg
        %out    **********************************************************
        .err
endif
        ENDM

; display msg   -    Output message unless QUIET defined

display MACRO   msg
ifndef QUIET            ;; only when quiet flag not set
if1                     ;; and on pass 1, then display message
        %out msg
endif
endif
        ENDM

; One line conditionals:
;   here we create the capability of writing code lines like
;
; _if sizeD   <push ds>   as opposed to    if sizeD
;                                              push  ds
;                                          endif

_if     MACRO   cond,text
    if  cond
        text
    endif
        ENDM

_ife    MACRO   cond,text
    ife cond
        text
    endif
        ENDM

_ifd    MACRO   cond,text
    ifdef   cond
        text
    endif
        ENDM

_ifnd   MACRO   cond,text
    ifndef  cond
        text
    endif
        ENDM

; set windows flag to 0

        ?WIN    equ     0       ; disable windows-specific code

; check for _MT, requires 286 or greater processor

ifdef _MT
ifndef I386
ifndef I286
; _MT implies 286 processor
display <Multi-thread specified - assuming 80286 processor>
I286 equ <>
endif
endif
endif

; Process memory-model arguments

ifdef  mem_M
        ; Medium model
        sizeC   equ     1
        sizeD   equ     0
        mmodel  equ     <Medium>
elseifdef  mem_C
        ; Compact model
        sizeC   equ     0
        sizeD   equ     1
        mmodel  equ     <Compact>
elseifdef  mem_L
        ; Large model
        sizeC   equ     1
        sizeD   equ     1
        mmodel  equ     <Large>
else
        ; Small model - default
        sizeC   equ     0
        sizeD   equ     0
        mmodel  equ     <Small>
endif

; Process processor arguments

ifdef   _WIN32
        display <Processor:             486/586>
        cpu equ 586
        .586
elseifdef       _POSIX_
        display <Processor:             486/586>
        cpu equ 586
        .586
elseifdef   I286
        display <Processor:             80286>
        cpu equ 286
        .286
elseifdef   I386
        display <Processor:             80386>
        cpu equ 386
        .386
else
        display <Processor:             8086/8088>
        cpu equ 86
        .8086
endif

;  386 32-bit checking.  Currently we are only expecting small model
;  32 bit segments, so we make a few checks to be sure nothing is
;  incorrectly being defined.

ifdef I386
    if sizeC or sizeD
        error <Must use Small memory model for 386 version.>
    endif

    ifdef _LOAD_DGROUP
        error <No loading DGROUP in 386 version.>
    endif

    ifdef SS_NEQ_DGROUP
        error <SS always equals DGROUP in 386 version.>
    endif
endif

;  Set memory model

%       display <Memory model:          mmodel>
%       .model  mmodel, C

;
; *** Temporary Workaround ***
; Currently, MASM will not recognize the 'FLAT' keyword unless it previously
; appears in an 'assume' statement.  Presumably, when the '.model FLAT' feature
; is implemented, this will go away.  [Use 'gs:' since we never use that
; segment register.
;

ifdef   I386
        ; ensure that MASM recognizes 'FLAT'
        assume  gs:FLAT
endif


; Define registers:
; Instead of using the "word" registers directly, we will use a set of
; text equates.  This will allow you to use the native word size instead of
; hard coded to 16 bit words.  We also have some instruction equates for
; instruction with the register type hard coded in.

ifdef I386

    rax equ <eax>
    rbx equ <ebx>
    rcx equ <ecx>
    rdx equ <edx>
    rdi equ <edi>
    rsi equ <esi>
    rbp equ <ebp>
    rsp equ <esp>

    JRCXZ equ <jecxz>
    CBI   equ <movsx eax, al>    ; convert byte to int (al to rax)
    CAXDX equ <cdq>              ; convert rax to rdx:rax
    ZXAL  equ <movzx eax, al>    ; zero extend al
    ZXBL  equ <movzx ebx, bl>    ; zero extend bl
    ZXCL  equ <movzx ecx, cl>    ; zero extend cl
    ZXDL  equ <movzx edx, dl>    ; zero extend dl

else

    rax equ <ax>
    rbx equ <bx>
    rcx equ <cx>
    rdx equ <dx>
    rdi equ <di>
    rsi equ <si>
    rbp equ <bp>
    rsp equ <sp>

    JRCXZ equ <jcxz>
    CBI   equ <cbw>              ; convert byte to int (al to rax)
    CAXDX equ <cwd>              ; convert rax to rdx:rax
    ZXAL  equ <xor ah, ah>       ; zero extend al
    ZXBL  equ <xor bh, bh>       ; zero extend bl
    ZXCL  equ <xor ch, ch>       ; zero extend cl
    ZXDL  equ <xor dh, dh>       ; zero extend dl

endif

; The following equates deal with the differences in near versus
; far data pointers, and segment overrides.
;
; Use LPES and PES when loading a default size pointer -- it loads
; a 16-bit pointer register in 286 Small/Medium model,
; a 16-bit pointer register and 16-bit segment register in 8086/286
; Compact/Large model, and a 32-bit pointer register in 386 mode.
;
; Use LFPES and FPES when loading an always far pointer -- it loads a
; 16-bit pointer register and 16-bit segment register in 8086/286,
; all models; a 32-bit pointer register in 386 mode.

if sizeD
    LPES equ <les>
    LPDS equ <lds>
    PDS  equ <ds:>
    PES  equ <es:>
else
    LPES equ <mov>
    LPDS equ <mov>
    PDS  equ <>
    PES  equ <>
endif

ifdef I386
    LFPES equ <mov>
    LFPDS equ <mov>
    FPES equ <>
    FPDS equ <>
else
    LFPES equ <les>
    LFPDS equ <lds>
    FPES equ <es:>
    FPDS equ <ds:>
endif

if sizeC or @WordSize eq 2
    PCS  equ <cs:>              ; large code model or non-386
else
 IF 1   ;*** TEMP 16/32 TESTBED ***
    PCS  equ <cs:>
 ELSE
    PCS  equ <>                 ; 386 small code model
 ENDIF  ;*** END TEMP CODE
endif

ifdef SS_NEQ_DGROUP
    PSS   equ <ss:>             ; SS != DS
else
    PSS   equ <>                ; SS == DS
endif

; Define offset macros:
;   The 32-bit segments will not have 'groups'

ifdef I386
    codeoffset  equ <offset FLAT:>
    dataoffset  equ <offset FLAT:>
else
    codeoffset  equ <offset @code:>
    dataoffset  equ <offset DGROUP:>
endif

; The next set of equates deals with the size of SHORTS, INTS, LONGS, and
; pointers in the 16 and 32 bit versions.

ifdef I386       ;--- 32 bit segment ---

    ; parameters and locals
    IWORD   equ <dword>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dd>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc.
    ISIZE   equ 4
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 4
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 2               ; byte-to-int shift count
    LSHIFT  equ 2               ; byte-to-long shift count

    ; sizes dependent upon memory model.  dq -vs- df is not yet clear
    DNPTR equ <dd>              ; near pointer
    DFPTR equ <dd>              ; far pointer

    DCPTR   equ <dd offset FLAT:>; 32 bit offset only
    DCPTR?  equ <dd>            ; No seg override for uninitialized values
    CPSIZE  equ 4
    CPDIST  equ <near>          ; code pointers are near
    CPTR    equ <near ptr>

    DDPTR   equ <dd offset FLAT:>
    DDPTR?  equ <dd>
    DPSIZE  equ 4

    CPWORD  equ <dword>         ; code pointers are dwords
    DPWORD  equ <dword>         ; data pointers are dwords

    APIDIST equ <near>          ; all API calls are NEAR in the 32 bit model

; macro to declare API functions
EXTAPI  macro   apiname
        extrn pascal apiname:near
endm

else    ;--- 16-bit segment ---

    ; parameters and locals
    IWORD   equ <word>
    LWORD   equ <dword>

    ; static storage
    DINT    equ <dw>
    DLONG   equ <dd>
    DSHORT  equ <dw>

    ; sizes for fixing SP, stepping through tables, etc
    ISIZE   equ 2
    LSIZE   equ 4
    SSIZE   equ 2
    NPSIZE  equ 2
    FPSIZE  equ 4

    ; bit shift count to convert byte cnt/ptr to int/long cnt/ptr
    ISHIFT  equ 1               ; byte-to-int shift count
    LSHIFT  equ 2               ; byte-to-long shift count

    ; sizes dependent upon memory model
    DNPTR equ <dw>              ; near pointer
    DFPTR equ <dd>              ; far pointer

    if sizeC
        DCPTR   equ <dd>       ; 16 bit segment and 16 bit offset
        DCPTR?  equ <dd>
        CPSIZE  equ 4
        CPDIST  equ <far>      ; code pointers are far
        CPTR    equ <far ptr>
        CPWORD  equ <dword>    ; code pointers are dwords
    else
        DCPTR   equ <dw>       ; 16 bit offset only
        DCPTR?  equ <dw>
        CPSIZE  equ 2
        CPDIST  equ <near>     ; code pointers are near
        CPTR    equ <near ptr>
        CPWORD  equ <word>     ; code pointers are words
    endif

    if sizeD
        DDPTR   equ <dd>
        DDPTR?  equ <dd>
        DPSIZE  equ 4
        DPWORD  equ <dword>    ; data pointers are dwords
    else
        DDPTR   equ <dw>
        DDPTR?  equ <dw>
        DPSIZE  equ 2
        DPWORD  equ <word>     ; data pointers are words
    endif

    APIDIST equ <far>           ; API calls are FAR in 16 bit model

; macro to declare API functions
EXTAPI  macro   apiname
        extrn pascal apiname:far
endm

endif   ; --- 16/32 segment ---

; Float/double definitions
; (currently the same for 16- and 32-bit segments)

FLTSIZE  equ    4       ; float
DBLSIZE  equ    8       ; double
LDBLSIZE equ    10      ; long double

DFLOAT   equ    <dd>
DDOUBLE  equ    <dq>
DLDOUBLE equ    <dt>

;
; savelist - Generate a list of regs to be saved by the proc 'uses' option.
;
; Input:
;       reg1, reg2, reg3, reg4 = registers to be saved across function
; Output:
;       reglist = text string of registers that can be passed to the 'uses'
;       option on the 'proc' command.
;

savelist  MACRO   reg1, reg2, reg3, reg4
        local   ws, listsize
        ws      catstr  < >             ; whitespace char

        IFNDEF  I386
         rbx equ <>                     ; 8086/286 don't save rbx
        ENDIF

        IFNB        <reg4>
         reglist     catstr  reg1, ws, reg2, ws, reg3, ws, reg4
        ELSEIFNB    <reg3>
         reglist     catstr  reg1, ws, reg2, ws, reg3, ws
        ELSEIFNB    <reg2>
         reglist     catstr  reg1, ws, reg2, ws,       ws
        ELSEIFNB    <reg1>
         reglist     catstr  reg1, ws,       ws,       ws
        ELSE
         reglist     catstr  <>
        ENDIF

        listsize sizestr reglist        ; size of register list

        IF      listsize LE 3           ; if list is only the 3 ws chars...
         reglist catstr  <>
        ENDIF

        IFNDEF  I386
         rbx equ <bx>                   ; restore rbx
        ENDIF

        ENDM    ; savelist

;
; codeseg - Define/declare the standard code segment. Maps to the proper
; form of the .code directive.
;
; Input:
;
; Output:
;       .code _TEXT     ; for large code models
;       .code           ; for small code models
;       assume  cs:FLAT ; for 386
;       assume  ds:FLAT ; for 386
;       assume  es:FLAT ; for 386
;       assume  ss:FLAT ; for 386
;

codeseg MACRO

if      sizeC
        .code _TEXT
else
        .code
endif

ifdef   I386
        assume  ds:FLAT
        assume  es:FLAT
        assume  ss:FLAT
endif

        ENDM

;*========
;*
;*  Debug lab macro
;*
;*========

lab     macro name
ifdef   DEBUG
    public  pascal name     ;; define label public for Symdeb
endif
name:
        endm


;*========
;*
;*  Conditional jump short macros
;*
;*========


        irp     x,<Z,NZ,E,NE,S,NS,C,NC,P,NP,PE,PO,A,AE,B,BE,NB,G,GE,L,LE>
JS&x    equ   <j&x short>
        endm


;*========
;*
;*  Global data definition macros
;*
;*  Usage:
;*      globalI   Name, InitialValue, Repeat
;*
;*========


MakeGlobal  macro   suffix, DataType        ;; makes all of the global* macros

global&suffix  macro   name, data, rep
public  name
ifb     <rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name    &DataType  _repeat dup( data )
        endm

        endm


    MakeGlobal  T, dt                   ; globalT
    MakeGlobal  Q, dq                   ; globalQ
    MakeGlobal  D, dd                   ; globalD
    MakeGlobal  W, dw                   ; globalW
    MakeGlobal  B, db                   ; globalB

%   MakeGlobal  I, <DINT>               ; globalI

%   MakeGlobal  DP, <DDPTR>             ; globalDP
%   MakeGlobal  CP, <DCPTR>             ; globalCP
%   MakeGlobal  FP, <DFPTR>             ; globalFP
%   MakeGlobal  NP, <DNPTR>             ; globalNP



;*========
;*
;*  Static data definition macros
;*
;*  Usage:
;*      staticI   Name, InitialValue, Repeat
;*
;*========


MakeStatic  macro   suffix, DataType        ;; makes all of the static* macros

static&suffix  macro   name, data, rep

ifdef  DEBUG
    public  pascal name                     ;; make statics public if DEBUG
endif

ifb     <rep>
    _repeat = 1
else
    _repeat = (rep)
endif

name    &DataType  _repeat dup( data )
        endm

        endm


    MakeStatic  T, dt                   ; staticT
    MakeStatic  Q, dq                   ; staticQ
    MakeStatic  D, dd                   ; staticD
    MakeStatic  W, dw                   ; staticW
    MakeStatic  B, db                   ; staticB

%   MakeStatic  I, <DINT>               ; staticI

%   MakeStatic  DP, <DDPTR>             ; staticDP
%   MakeStatic  CP, <DCPTR>             ; staticCP
%   MakeStatic  FP, <DFPTR>             ; staticFP
%   MakeStatic  NP, <DNPTR>             ; staticNP

;*========
;*
;*  Label definition macros
;*
;*========
;*
;*  Label definition macros
;*
;*  Usage:
;*      labelI   Name, {PUBLIC, PASCAL, C}
;*
;*========

__MakePublic    macro   name, option    ;; decides if a label should be
ifidni  <option>, <PUBLIC>              ;; made public
    public  name
elseifidni  <option>, <PASCAL>
    public  pascal name
elseifidni  <option>, <C>
    public  C name
elseifb  <option>
    ifdef  DEBUG
        public  pascal name     ;; make public if DEBUG
    endif
endif
                endm


MakeLabel   macro suffix, LabelType     ;; makes all of the label* macros

%@CatStr(<label>,<suffix>)      macro   name, option
        __MakePublic    <name>,<option>
name    label   &LabelType
        endm

        endm


        MakeLabel   T, tbyte    ; make labelT
        MakeLabel   Q, qword    ; make labelQ
        MakeLabel   D, dword    ; make labelD
        MakeLabel   W, word     ; make labelW
        MakeLabel   B, byte     ; make labelB

        MakeLabel   P, proc     ; make labelP
        MakeLabel   FP, far     ; make labelFP
        MakeLabel   NP, near    ; make labelNP

%       MakeLabel   I, IWORD    ; make labelI


labelDP macro   name, option                ;; labelDP
        __MakePublic    <name>,<option>
ifdef  I386
    if sizeD
        name    label   fword
    else
        name    label   dword
    endif
else    ;not I386
    if sizeD
        name    label   dword
    else
        name    label   word
    endif
endif   ;not I386
        endm

labelCP macro   name, option                ;; labelCP
        __MakePublic    <name>,<option>
ifdef  I386
    if sizeC
        name    label   fword
    else
        name    label   dword
    endif
else    ;not I386
    if sizeC
        name    label   dword
    else
        name    label   word
    endif
endif   ;not I386
        endm


;*
;*  PUSH16 SegReg   - pushes 16 bits in a use32 segment
;*

PUSH16  macro   SegReg

ifdef I386
        nop
        db      66h         ; operand size over-ride
endif   ; I386

        push    SegReg
        endm


;*
;*  JMPFAR16  label - jmps far from a use32 to a use16 segment
;*

JMPFAR16 macro  label

ifndef I386
        error  <JMPFAR16 can only be used in a use32 code segment>
endif   ;I386

        nop
        db      66h         ;; operand size over-ride
        db      0eah        ;; jmp far immediate op code
        dw      offset label
        dw      seg label
        endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtwrn.h ===
/***
*crtwrn.h
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the IDs and messages for warnings
*       in the CRT headers.
*
****/

#pragma once

#ifndef _INC_CRTWRN
#define _INC_CRTWRN

#include <crtdefs.h>

#define __CRT_WARNING( _Number, _Description ) \
    message("" __FILE__ "(" _CRT_STRINGIZE(__LINE__) ") : " \
    "warning CRT" _CRT_STRINGIZE(_Number) ": " _CRT_STRINGIZE(_Description))

#define _CRT_WARNING( _Id ) \
    __CRT_WARNING( _CRTWRN_WNUMBER_##_Id, _CRTWRN_MESSAGE_##_Id )

/*
A warning is a 4-digit ID number (_CRTWRN_WNUMBER_*)
followed by a message (_CRTWRN_MESSAGE_*)
Emit a warning by adding the following code to the header file:
    #pragma _CRT_WARNING( id )
*/

/* NAME */
/* #pragma _CRT_WARNING( NAME ) */
/* #define _CRTWRN_WNUMBER_NAME  9999 */
/* #define _CRTWRN_MESSAGE_NAME  description */

/* _VCCLRIT_DEPRECATED */
/* #pragma _CRT_WARNING( _VCCLRIT_DEPRECATED ) */
#define _CRTWRN_WNUMBER__VCCLRIT_DEPRECATED  1001
#define _CRTWRN_MESSAGE__VCCLRIT_DEPRECATED  _vcclrit.h is deprecated

/* _EXPLICIT_KEYWORD_ */
/* #pragma _CRT_WARNING( _EXPLICIT_KEYWORD ) */
#define _CRTWRN_WNUMBER__EXPLICIT_KEYWORD    1002
#define _CRTWRN_MESSAGE__EXPLICIT_KEYWORD    \
       'explicit' keyword not recognized

/* _CANNOT_USE_32BIT_TIME_T */
/* #pragma _CRT_WARNING( _NO_32BIT_TIME_T ) */
#define _CRTWRN_WNUMBER__NO_32BIT_TIME_T  1003
#define _CRTWRN_MESSAGE__NO_32BIT_TIME_T  _USE_32BIT_TIME_T ignored. \
        You cannot use 32-bit time_t with _WIN64

/* _NO_SPECIAL_TRANSFER */
/* #pragma _CRT_WARNING( _NO_SPECIAL_TRANSFER ) */
#define _CRTWRN_WNUMBER__NO_SPECIAL_TRANSFER  1004
#define _CRTWRN_MESSAGE__NO_SPECIAL_TRANSFER Special transfer of \
        control routines not defined for this platform

/* _NO_ITERATOR_DEBUGGING */
/* #pragma _CRT_WARNING( _NO_ITERATOR_DEBUGGING ) */
#define _CRTWRN_WNUMBER__NO_ITERATOR_DEBUGGING  1005
#define _CRTWRN_MESSAGE__NO_ITERATOR_DEBUGGING Iterator debugging not \
        supported in retail builds.\n  \
        Setting _HAS_ITERA##TOR_DEBUGGING=0

/* _CLR_STATIC_CPPLIB */
/* #pragma _CRT_WARNING( _CLR_AND_STATIC_CPPLIB ) */
#define _CRTWRN_WNUMBER__CLR_AND_STATIC_CPPLIB  1006
#define _CRTWRN_MESSAGE__CLR_AND_STATIC_CPPLIB STATIC CPPLIB is not \
        supported while building with /clr or /clr:pure

#endif  /* _INC_CRTWRN */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgfree.c ===
/***
*dbgfree.c - Debug CRT Heap Function of free()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines debug versions of heap functions free().
*
*******************************************************************************/

#ifdef _DEBUG

#include <windows.h>
#include <winheap.h>
#include <ctype.h>
#include <dbgint.h>
#include <crtdbg.h>
#include <rtcsup.h>
#include <internal.h>
#include <limits.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

#pragma warning(disable:4390)

/***
*void free() - free a block in the debug heap
*
*Purpose:
*       Frees a 'normal' memory block.
*
*Entry:
*       void * pUserData -  pointer to a (user portion) of memory block in the
*                       debug heap
*
*Return:
*       <void>
*
*******************************************************************************/
extern "C" _CRTIMP void __cdecl free(
        void * pUserData
        )
{
        _free_dbg(pUserData, _NORMAL_BLOCK);
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines macros for character classification/conversion.
*       [ANSI/System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_CTYPE
#define _INC_CTYPE

#include <crtdefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef WEOF
#define WEOF (wint_t)(0xFFFF)
#endif  /* WEOF */

#ifndef _CRT_CTYPEDATA_DEFINED
#define _CRT_CTYPEDATA_DEFINED
#ifndef _CTYPE_DISABLE_MACROS
#ifndef _INTERNAL_IFSTRIP_
extern const unsigned short __newctype[];
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const unsigned short ** __cdecl __p__pctype(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#endif  /* _INTERNAL_IFSTRIP_ */

#ifndef __PCTYPE_FUNC
#if defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL)
#define __PCTYPE_FUNC  _pctype
#else  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */
#define __PCTYPE_FUNC   __pctype_func()
#endif  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */
#endif  /* __PCTYPE_FUNC */

_CRTIMP const unsigned short * __cdecl __pctype_func(void);
#if !defined (_M_CEE_PURE)
_CRTIMP extern const unsigned short *_pctype;
#else  /* !defined (_M_CEE_PURE) */
#define _pctype (__pctype_func())
#endif  /* !defined (_M_CEE_PURE) */
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* _CRT_CTYPEDATA_DEFINED */

#ifndef _CRT_WCTYPEDATA_DEFINED
#define _CRT_WCTYPEDATA_DEFINED
#ifndef _CTYPE_DISABLE_MACROS
#if !defined (_M_CEE_PURE)
_CRTIMP extern const unsigned short _wctype[];
#endif  /* !defined (_M_CEE_PURE) */
#ifndef _INTERNAL_IFSTRIP_
extern const unsigned short __newctype[];
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP const wctype_t ** __cdecl __p__pwctype(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#endif  /* _INTERNAL_IFSTRIP_ */

_CRTIMP const wctype_t * __cdecl __pwctype_func(void);
#if !defined (_M_CEE_PURE)
_CRTIMP extern const wctype_t *_pwctype;
#else  /* !defined (_M_CEE_PURE) */
#define _pwctype (__pwctype_func())
#endif  /* !defined (_M_CEE_PURE) */
#endif  /* _CTYPE_DISABLE_MACROS */
#endif  /* _CRT_WCTYPEDATA_DEFINED */

#ifndef _CTYPE_DISABLE_MACROS
#ifndef _INTERNAL_IFSTRIP_
extern const unsigned char __newclmap[];
extern const unsigned char __newcumap[];
#endif  /* _INTERNAL_IFSTRIP_ */
#endif  /* _CTYPE_DISABLE_MACROS */


#ifndef _INTERNAL_IFSTRIP_
extern pthreadlocinfo __ptlocinfo;
extern pthreadmbcinfo __ptmbcinfo;
extern int __globallocalestatus;
extern int __locale_changed;
extern struct threadlocaleinfostruct __initiallocinfo;
extern _locale_tstruct __initiallocalestructinfo;
pthreadlocinfo __cdecl __updatetlocinfo(void);
pthreadmbcinfo __cdecl __updatetmbcinfo(void);
#endif  /* _INTERNAL_IFSTRIP_ */


/* set bit masks for the possible character types */

#define _UPPER          0x1     /* upper case letter */
#define _LOWER          0x2     /* lower case letter */
#define _DIGIT          0x4     /* digit[0-9] */
#define _SPACE          0x8     /* tab, carriage return, newline, */
                                /* vertical tab or form feed */
#define _PUNCT          0x10    /* punctuation character */
#define _CONTROL        0x20    /* control character */
#define _BLANK          0x40    /* space char */
#define _HEX            0x80    /* hexadecimal digit */

#define _LEADBYTE       0x8000                  /* multibyte leadbyte */
#define _ALPHA          (0x0100|_UPPER|_LOWER)  /* alphabetic character */


/* character classification function prototypes */

#ifndef _CTYPE_DEFINED

_Check_return_ _CRTIMP int __cdecl _isctype(_In_ int _C, _In_ int _Type);
_Check_return_ _CRTIMP int __cdecl _isctype_l(_In_ int _C, _In_ int _Type, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl isalpha(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isalpha_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl isupper(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isupper_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl islower(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _islower_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl isdigit(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isdigit_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl isxdigit(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isxdigit_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl isspace(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isspace_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl ispunct(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _ispunct_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl isalnum(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isalnum_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl isprint(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isprint_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl isgraph(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isgraph_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iscntrl(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _iscntrl_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl toupper(_In_ int _C);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl tolower(_In_ int _C);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl _tolower(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _tolower_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRT_JIT_INTRINSIC _CRTIMP int __cdecl _toupper(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _toupper_l(_In_ int _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl __isascii(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl __toascii(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl __iscsymf(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl __iscsym(_In_ int _C);
#define _CTYPE_DEFINED
#endif  /* _CTYPE_DEFINED */

#ifndef _WCTYPE_DEFINED

/* wide function prototypes, also declared in wchar.h  */

/* character classification function prototypes */

_Check_return_ _CRTIMP int __cdecl iswalpha(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswalpha_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswupper(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswupper_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswlower(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswlower_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswdigit(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswxdigit(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswxdigit_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswspace(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswspace_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswpunct(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswpunct_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswalnum(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswalnum_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswprint(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswprint_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswgraph(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswgraph_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswcntrl(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswcntrl_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswascii(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl isleadbyte(_In_ int _C);
_Check_return_ _CRTIMP int __cdecl _isleadbyte_l(_In_ int _C, _In_opt_ _locale_t _Locale);

_Check_return_ _CRTIMP wint_t __cdecl towupper(_In_ wint_t _C);
_Check_return_ _CRTIMP wint_t __cdecl _towupper_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP wint_t __cdecl towlower(_In_ wint_t _C);
_Check_return_ _CRTIMP wint_t __cdecl _towlower_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl iswctype(_In_ wint_t _C, _In_ wctype_t _Type);
_Check_return_ _CRTIMP int __cdecl _iswctype_l(_In_ wint_t _C, _In_ wctype_t _Type, _In_opt_ _locale_t _Locale);

_Check_return_ _CRTIMP int __cdecl __iswcsymf(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswcsymf_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl __iswcsym(_In_ wint_t _C);
_Check_return_ _CRTIMP int __cdecl _iswcsym_l(_In_ wint_t _C, _In_opt_ _locale_t _Locale);

_CRT_OBSOLETE(iswctype) _CRTIMP int __cdecl is_wctype(_In_ wint_t _C, _In_ wctype_t _Type);

#define _WCTYPE_DEFINED
#endif  /* _WCTYPE_DEFINED */

/* the character classification macro definitions */

#ifndef _CTYPE_DISABLE_MACROS

/*
 * Maximum number of bytes in multi-byte character in the current locale
 * (also defined in stdlib.h).
 */
#ifndef MB_CUR_MAX
#ifndef _INTERNAL_IFSTRIP_
#if defined (_DLL) && defined (_M_IX86)
/* Retained for compatibility with VC++ 5.0 and earlier versions */
_CRTIMP int * __cdecl __p___mb_cur_max(void);
#endif  /* defined (_DLL) && defined (_M_IX86) */
#define __MB_CUR_MAX(ptloci) (ptloci)->mb_cur_max
#endif  /* _INTERNAL_IFSTRIP_ */

#if defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL)
#define MB_CUR_MAX __mb_cur_max
#else  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */
#define MB_CUR_MAX ___mb_cur_max_func()
#endif  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */
#if !defined (_M_CEE_PURE)
/* No data exports in pure code */
_CRTIMP extern int __mb_cur_max;
#else  /* !defined (_M_CEE_PURE) */
#define __mb_cur_max (___mb_cur_max_func())
#endif  /* !defined (_M_CEE_PURE) */
_CRTIMP int __cdecl ___mb_cur_max_func(void);
_CRTIMP int __cdecl ___mb_cur_max_l_func(_locale_t);
#endif  /* MB_CUR_MAX */

/* Introduced to detect error when character testing functions are called
 * with illegal input of integer.
 */
#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator(_In_ int _Ch, _In_ int _Mask);
#define __chvalidchk(a,b)       _chvalidator(a,b)
#else  /* _DEBUG */
#define __chvalidchk(a,b)       (__PCTYPE_FUNC[(a)] & (b))
#endif  /* _DEBUG */


#ifndef _INTERNAL_IFSTRIP_
#define __ascii_isalpha(c)      ( __chvalidchk(c, _ALPHA))
#define __ascii_isdigit(c)      ( __chvalidchk(c, _DIGIT))
#define __ascii_tolower(c)      ( (((c) >= 'A') && ((c) <= 'Z')) ? ((c) - 'A' + 'a') : (c) )
#define __ascii_toupper(c)      ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )
#define __ascii_iswalpha(c)     ( ('A' <= (c) && (c) <= 'Z') || ( 'a' <= (c) && (c) <= 'z'))
#define __ascii_iswdigit(c)     ( '0' <= (c) && (c) <= '9')
#define __ascii_towlower(c)     ( (((c) >= L'A') && ((c) <= L'Z')) ? ((c) - L'A' + L'a') : (c) )
#define __ascii_towupper(c)     ( (((c) >= L'a') && ((c) <= L'z')) ? ((c) - L'a' + L'A') : (c) )
#endif  /* _INTERNAL_IFSTRIP_ */

#if defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL)
#ifndef __cplusplus
#define isalpha(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA) : __chvalidchk(_c, _ALPHA))
#define isupper(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_UPPER) : __chvalidchk(_c, _UPPER))
#define islower(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_LOWER) : __chvalidchk(_c, _LOWER))
#define isdigit(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_DIGIT) : __chvalidchk(_c, _DIGIT))
#define isxdigit(_c)    (MB_CUR_MAX > 1 ? _isctype(_c,_HEX)   : __chvalidchk(_c, _HEX))
#define isspace(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_SPACE) : __chvalidchk(_c, _SPACE))
#define ispunct(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT) : __chvalidchk(_c, _PUNCT))
#define isalnum(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_ALPHA|_DIGIT) : __chvalidchk(_c, (_ALPHA|_DIGIT)))
#define isprint(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_BLANK|_PUNCT|_ALPHA|_DIGIT)))
#define isgraph(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_PUNCT|_ALPHA|_DIGIT) : __chvalidchk(_c, (_PUNCT|_ALPHA|_DIGIT)))
#define iscntrl(_c)     (MB_CUR_MAX > 1 ? _isctype(_c,_CONTROL) : __chvalidchk(_c, _CONTROL))
#endif  /* __cplusplus */
#endif  /* defined (_CRT_DISABLE_PERFCRIT_LOCKS) && !defined (_DLL) */

#ifdef _DEBUG
_CRTIMP int __cdecl _chvalidator_l(_In_opt_ _locale_t, _In_ int _Ch, _In_ int _Mask);
#define _chvalidchk_l(_Char, _Flag, _Locale)  _chvalidator_l(_Locale, _Char, _Flag)
#else  /* _DEBUG */
#define _chvalidchk_l(_Char, _Flag, _Locale)  (_Locale==NULL ? __chvalidchk(_Char, _Flag) : ((_locale_t)_Locale)->locinfo->pctype[_Char] & (_Flag))
#endif  /* _DEBUG */

#ifndef _INTERNAL_IFSTRIP_
#define __ascii_isalpha_l(_Char, _Locale)      ( _chvalidchk_l(_Char, _ALPHA, _Locale))
#define __ascii_isdigit_l(_Char, _Locale)      ( _chvalidchk_l(_Char, _DIGIT, _Locale))
#endif  /* _INTERNAL_IFSTRIP_ */

#define _ischartype_l(_Char, _Flag, _Locale)    ( ((_Locale)!=NULL && (((_locale_t)(_Locale))->locinfo->mb_cur_max) > 1) ? _isctype_l(_Char, (_Flag), _Locale) : _chvalidchk_l(_Char,_Flag,_Locale))
#define _isalpha_l(_Char, _Locale)      _ischartype_l(_Char, _ALPHA, _Locale)
#define _isupper_l(_Char, _Locale)      _ischartype_l(_Char, _UPPER, _Locale)
#define _islower_l(_Char, _Locale)      _ischartype_l(_Char, _LOWER, _Locale)
#define _isdigit_l(_Char, _Locale)      _ischartype_l(_Char, _DIGIT, _Locale)
#define _isxdigit_l(_Char, _Locale)     _ischartype_l(_Char, _HEX, _Locale)
#define _isspace_l(_Char, _Locale)      _ischartype_l(_Char, _SPACE, _Locale)
#define _ispunct_l(_Char, _Locale)      _ischartype_l(_Char, _PUNCT, _Locale)
#define _isalnum_l(_Char, _Locale)      _ischartype_l(_Char, _ALPHA|_DIGIT, _Locale)
#define _isprint_l(_Char, _Locale)      _ischartype_l(_Char, _BLANK|_PUNCT|_ALPHA|_DIGIT, _Locale)
#define _isgraph_l(_Char, _Locale)      _ischartype_l(_Char, _PUNCT|_ALPHA|_DIGIT, _Locale)
#define _iscntrl_l(_Char, _Locale)      _ischartype_l(_Char, _CONTROL, _Locale)

#define _tolower(_Char)    ( (_Char)-'A'+'a' )
#define _toupper(_Char)    ( (_Char)-'a'+'A' )

#define __isascii(_Char)   ( (unsigned)(_Char) < 0x80 )
#define __toascii(_Char)   ( (_Char) & 0x7f )

#ifndef _WCTYPE_INLINE_DEFINED

#ifdef _CRTBLD
#ifndef _INTERNAL_IFSTRIP_
#define _CRT_WCTYPE_NOINLINE
#else  /* _INTERNAL_IFSTRIP_ */
#undef _CRT_WCTYPE_NOINLINE
#endif  /* _INTERNAL_IFSTRIP_ */
#endif  /* _CRTBLD */

#if !defined (__cplusplus) || defined (_M_CEE_PURE) || defined (MRTDLL) || defined (_CRT_WCTYPE_NOINLINE)
#define iswalpha(_c)    ( iswctype(_c,_ALPHA) )
#define iswupper(_c)    ( iswctype(_c,_UPPER) )
#define iswlower(_c)    ( iswctype(_c,_LOWER) )
#define iswdigit(_c)    ( iswctype(_c,_DIGIT) )
#define iswxdigit(_c)   ( iswctype(_c,_HEX) )
#define iswspace(_c)    ( iswctype(_c,_SPACE) )
#define iswpunct(_c)    ( iswctype(_c,_PUNCT) )
#define iswalnum(_c)    ( iswctype(_c,_ALPHA|_DIGIT) )
#define iswprint(_c)    ( iswctype(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT) )
#define iswgraph(_c)    ( iswctype(_c,_PUNCT|_ALPHA|_DIGIT) )
#define iswcntrl(_c)    ( iswctype(_c,_CONTROL) )
#define iswascii(_c)    ( (unsigned)(_c) < 0x80 )

#define _iswalpha_l(_c,_p)    ( _iswctype_l(_c,_ALPHA, _p) )
#define _iswupper_l(_c,_p)    ( _iswctype_l(_c,_UPPER, _p) )
#define _iswlower_l(_c,_p)    ( _iswctype_l(_c,_LOWER, _p) )
#define _iswdigit_l(_c,_p)    ( _iswctype_l(_c,_DIGIT, _p) )
#define _iswxdigit_l(_c,_p)   ( _iswctype_l(_c,_HEX, _p) )
#define _iswspace_l(_c,_p)    ( _iswctype_l(_c,_SPACE, _p) )
#define _iswpunct_l(_c,_p)    ( _iswctype_l(_c,_PUNCT, _p) )
#define _iswalnum_l(_c,_p)    ( _iswctype_l(_c,_ALPHA|_DIGIT, _p) )
#define _iswprint_l(_c,_p)    ( _iswctype_l(_c,_BLANK|_PUNCT|_ALPHA|_DIGIT, _p) )
#define _iswgraph_l(_c,_p)    ( _iswctype_l(_c,_PUNCT|_ALPHA|_DIGIT, _p) )
#define _iswcntrl_l(_c,_p)    ( _iswctype_l(_c,_CONTROL, _p) )
#endif  /* !defined (__cplusplus) || defined (_M_CEE_PURE) || defined (MRTDLL) || defined (_CRT_WCTYPE_NOINLINE) */
#define _WCTYPE_INLINE_DEFINED
#endif  /* _WCTYPE_INLINE_DEFINED */

/* MS C version 2.0 extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))
#define __iswcsymf(_c)  (iswalpha(_c) || ((_c) == '_'))
#define __iswcsym(_c)   (iswalnum(_c) || ((_c) == '_'))

#define _iscsymf_l(_c, _p)   (_isalpha_l(_c, _p) || ((_c) == '_'))
#define _iscsym_l(_c, _p)    (_isalnum_l(_c, _p) || ((_c) == '_'))
#define _iswcsymf_l(_c, _p)  (_iswalpha_l(_c, _p) || ((_c) == '_'))
#define _iswcsym_l(_c, _p)   (_iswalnum_l(_c, _p) || ((_c) == '_'))

#endif  /* _CTYPE_DISABLE_MACROS */


#if !__STDC__

/* Non-ANSI names for compatibility */

#ifndef _CTYPE_DEFINED
_Check_return_ _CRT_NONSTDC_DEPRECATE(__isascii) _CRTIMP int __cdecl isascii(_In_ int _C);
_Check_return_ _CRT_NONSTDC_DEPRECATE(__toascii) _CRTIMP int __cdecl toascii(_In_ int _C);
_Check_return_ _CRT_NONSTDC_DEPRECATE(__iscsymf) _CRTIMP int __cdecl iscsymf(_In_ int _C);
_Check_return_ _CRT_NONSTDC_DEPRECATE(__iscsym) _CRTIMP int __cdecl iscsym(_In_ int _C);
#else  /* _CTYPE_DEFINED */
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif  /* _CTYPE_DEFINED */

#endif  /* !__STDC__ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_CTYPE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\crtlib.c ===
/***
*crtlib.c - CRT DLL initialization and termination routine (Win32, Dosx32)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This module contains initialization entry point for the CRT DLL
*       in the Win32 environment. It also contains some of the supporting
*       initialization and termination code.
*
*******************************************************************************/

#if defined (CRTDLL)

#include <cruntime.h>
#include <oscalls.h>
#include <dos.h>
#include <internal.h>
#include <malloc.h>
#include <mbctype.h>
#include <mtdll.h>
#include <process.h>
#include <rterr.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <awint.h>
#include <tchar.h>
#include <time.h>
#include <io.h>
#include <dbgint.h>
#ifdef _SYSCRT
#include <ntverp.h>
#endif  /* _SYSCRT */
#include <setlocal.h>
#include <crtassem.h>

/*
 * This header is included for _getdrives(). This function
 * is used to take dependency on msvcrt.dll
 */
#include <direct.h>

/*
 * flag set iff _CRTDLL_INIT was called with DLL_PROCESS_ATTACH
 */
static int proc_attached = 0;

/*
 * command line, environment, and a few other globals
 */
wchar_t *_wcmdln = NULL;           /* points to wide command line */
char *_acmdln = NULL;              /* points to command line */

char *_aenvptr = NULL;      /* points to environment block */
wchar_t *_wenvptr = NULL;   /* points to wide environment block */

extern int _newmode;    /* declared in <internal.h> */

int __error_mode = _OUT_TO_DEFAULT;

int __app_type = _UNKNOWN_APP;

static void __cdecl inherit(void);  /* local function */

static BOOL __cdecl _check_manifest(HMODULE hDllHandle);  /* local function */

/***
*int __[w]getmainargs - get values for args to main()
*
*Purpose:
*       This function invokes the command line parsing and copies the args
*       to main back through the passsed pointers. The reason for doing
*       this here, rather than having _CRTDLL_INIT do the work and exporting
*       the __argc and __argv, is to support the linked-in option to have
*       wildcard characters in filename arguments expanded.
*
*Entry:
*       int *pargc              - pointer to argc
*       _TCHAR ***pargv         - pointer to argv
*       _TCHAR ***penvp         - pointer to envp
*       int dowildcard          - flag (true means expand wildcards in cmd line)
*       _startupinfo * startinfo- other info to be passed to CRT DLL
*
*Exit:
*       Returns 0 on success, negative if _*setargv returns an error. Values
*       for the arguments to main() are copied through the passed pointers.
*
*******************************************************************************/


_CRTIMP int __cdecl __wgetmainargs (
        int *pargc,
        wchar_t ***pargv,
        wchar_t ***penvp,
        int dowildcard,
        _startupinfo * startinfo)
{
        int ret;


        /* set global new mode flag */
        _newmode = startinfo->newmode;

        if ( dowildcard )
            ret = __wsetargv(); /* do wildcard expansion after parsing args */
        else
            ret = _wsetargv();  /* NO wildcard expansion; just parse args */
        if (ret < 0)
#ifdef _SYSCRT
            ExitProcess(-1);      // Failed to parse the cmdline - bail
#else  /* _SYSCRT */
            return ret;
#endif  /* _SYSCRT */

        *pargc = __argc;
        *pargv = __wargv;

        /*
         * if wide environment does not already exist,
         * create it from multibyte environment
         */
        if (!_wenviron)
        {
            _wenvptr=__crtGetEnvironmentStringsW();

            if (_wsetenvp() < 0)
            {
                __mbtow_environ();
            }
        }

        *penvp = _wenviron;

        return ret;
}



_CRTIMP int __cdecl __getmainargs (
        int *pargc,
        char ***pargv,
        char ***penvp,
        int dowildcard
        ,
        _startupinfo * startinfo
        )
{
        int ret;


        /* set global new mode flag */
        _newmode = startinfo->newmode;

        if ( dowildcard )
            ret = __setargv();  /* do wildcard expansion after parsing args */
        else
            ret = _setargv();   /* NO wildcard expansion; just parse args */
        if (ret < 0)
#ifdef _SYSCRT
            ExitProcess(-1);      // Failed to parse the cmdline - bail
#else  /* _SYSCRT */
            return ret;
#endif  /* _SYSCRT */

        *pargc = __argc;
        *pargv = __argv;
        *penvp = _environ;

        return ret;
}


/***
*BOOL _CRTDLL_INIT(hDllHandle, dwReason, lpreserved) - C DLL initialization.
*
*Purpose:
*       This routine does the C runtime initialization.
*
*Entry:
*
*Exit:
*
*******************************************************************************/

typedef void (__stdcall *NTVERSION_INFO_FCN)(PDWORD, PDWORD, PDWORD);

static
BOOL __cdecl
__CRTDLL_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        );

BOOL WINAPI
_CRTDLL_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        /*
         * The /GS security cookie must be initialized before any exception
         * handling targetting the current image is registered.  No function
         * using exception handling can be called in the current image until
         * after __security_init_cookie has been called.
         */
        __security_init_cookie();
    }

    return __CRTDLL_INIT(hDllHandle, dwReason, lpreserved);
}

__declspec(noinline)
BOOL __cdecl
__CRTDLL_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        if ( dwReason == DLL_PROCESS_ATTACH ) {
            if ( !_heap_init(1) )   /* initialize heap */
                /*
                 * The heap cannot be initialized, return failure to the
                 * loader.
                 */
                return FALSE;

            if(!_mtinit())          /* initialize multi-thread */
            {
                /*
                 * If the DLL load is going to fail, we must clean up
                 * all resources that have already been allocated.
                 */
                _heap_term();       /* heap is now invalid! */

                return FALSE;       /* fail DLL load on failure */
            }

            if (_ioinit() < 0) {    /* inherit file info */
                /* Clean up already-allocated resources */
                /* free TLS index, call _mtdeletelocks() */
                _mtterm();

                _heap_term();       /* heap is now invalid! */

                return FALSE;       /* fail DLL load on failure */
            }

            _aenvptr = (char *)__crtGetEnvironmentStringsA();

            _acmdln = (char *)GetCommandLineA();
            _wcmdln = (wchar_t *)__crtGetCommandLineW();

#ifdef _MBCS
            /*
             * Initialize multibyte ctype table. Always done since it is
             * needed for processing the environment strings.
             */
            __initmbctable();
#endif  /* _MBCS */

            /*
             * For CRT DLL, since we don't know the type (wide or multibyte)
             * of the program, we create only the multibyte type since that
             * is by far the most likely case. Wide environment will be created
             * on demand as usual.
             */

            if (_setenvp() < 0 ||   /* get environ info */
                _cinit(FALSE) != 0)  /* do C data initialize */
            {
                _ioterm();          /* shut down lowio */
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail DLL load on failure */
            }

#if defined (_CRT_CHECK_MANIFEST)
            if (!_check_manifest(hDllHandle))
            {
                __try
                {
                    _NMSG_WRITE(_RT_CHECKMANIFEST);
                }
                __except( EXCEPTION_EXECUTE_HANDLER )
                {
                    OutputDebugString(_GET_RTERRMSG(_RT_CHECKMANIFEST));
                    DebugBreak();
                }

                _ioterm();          /* shut down lowio */
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
                _heap_term();       /* heap is now invalid! */
                return FALSE;
            }
#endif  /* defined (_CRT_CHECK_MANIFEST) */

            /*
             * Increment flag indicating process attach notification
             * has been received.
             */
            proc_attached++;

        }
        else if ( dwReason == DLL_PROCESS_DETACH ) {
            /*
             * if a client process is detaching, make sure minimal
             * runtime termination is performed and clean up our
             * 'locks' (i.e., delete critical sections).
             */
            if ( proc_attached > 0 ) {
                proc_attached--;

                /*
                 * Any basic clean-up done here may also need
                 * to be done below if Process Attach is partly
                 * processed and then a failure is encountered.
                 */

                if ( _C_Termination_Done == FALSE )
                    _cexit();

                __crtdll_callstaticterminators();

#ifdef _DEBUG
                /* Dump all memory leaks */
                if (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
                {
                    _CrtSetDumpClient(NULL);
                    __freeCrtMemory();
                    _CrtDumpMemoryLeaks();
                }
#endif  /* _DEBUG */

                /*
                 * What remains is to clean up the system resources we have
                 * used (handles, critical sections, memory,...,etc.). This
                 * needs to be done if the whole process is NOT terminating.
                 */
                if ( lpreserved == NULL )
                {
                    /*
                     * The process is NOT terminating so we must clean up...
                     */
                    _ioterm();
                    /* free TLS index, call _mtdeletelocks() */
                    _mtterm();

                    /* This should be the last thing the C run-time does */
                    _heap_term();   /* heap is now invalid! */
                }

            }
            else
                /* no prior process attach, just return */
                return FALSE;

        }
        else if ( dwReason == DLL_THREAD_ATTACH )
        {
            _ptiddata ptd;

            /* Initialize FlsGetValue function pointer */
            __set_flsgetvalue();

            if ( (ptd = FLS_GETVALUE(__flsindex)) == NULL)
            {
                if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) != NULL))
                {
                    if (FLS_SETVALUE(__flsindex, (LPVOID)ptd) ) {
                        /*
                        * Initialize of per-thread data
                        */
                        _initptd(ptd, NULL);

                        ptd->_tid = GetCurrentThreadId();
                        ptd->_thandle = (uintptr_t)(-1);
                    } else
                    {
                        _free_crt(ptd);
                        return FALSE;
                    }
                } else
                {
                    return FALSE;
                }
            }
        }
        else if ( dwReason == DLL_THREAD_DETACH )
        {
            _freeptd(NULL);     /* free up per-thread CRT data */
        }


        return TRUE;
}

/* used in _enforce_manifest */
#define _PATH_LEN 8000
#define _WINSXS_FOLDER L"WinSxS\\"
#define _MSCORWKS_DLL_FILENAME L"mscorwks.dll"

#ifdef _DEBUG
#define _MANIFEST_FILENAME _CRT_WIDE(__LIBRARIES_ASSEMBLY_NAME_PREFIX) L".DebugCRT.manifest"
#define _CRT_DLL_FILENAME L"msvcr90d.dll"
#else  /* _DEBUG */
#define _MANIFEST_FILENAME _CRT_WIDE(__LIBRARIES_ASSEMBLY_NAME_PREFIX) L".CRT.manifest"
#define _CRT_DLL_FILENAME L"msvcr90.dll"
#endif  /* _DEBUG */

typedef BOOL (WINAPI * PFN_FINDAC)(DWORD dwFlags, const GUID *lpExtensionGuid,ULONG ulSectionId,LPCWSTR lpStringToFind,PACTCTX_SECTION_KEYED_DATA ReturnedData);
typedef UINT (WINAPI * PFN_GETSYSTEMWINDOWSDIRECTORY)(LPWSTR lpBuffer,  UINT uSize);


static BOOL __cdecl _check_manifest(HMODULE hDllHandle)
{
    /* We check that the dll is loaded through a manifest.
     *
     * We check several conditions and exceptions:
     *
     * (1)  if (pre-fusion OS)
     *          return TRUE; [no need to check]
     *
     * (2)  if dll is being loaded by instrumented-mscoree.dll.
     *          return TRUE;
     *
     * (3)  if (dll is loaded from system32)
     *          return FALSE;
     *
     * (4)  if (!(loaded through a manifest))
     *          return FALSE;
     *
     * (5)  if (loaded from %SystemRoot%\WinSxS)
     *          return TRUE; [loaded from the WinSxS cache]
     *
     * (6)  if (manifest is in the same folder as the dll)
     *          return TRUE;
     *
     * (7)  return FALSE; [loaded with another manifest]
     *
     * In general, when we encounter an error condition or something
     * which blocks us from checking if the dll is loaded through a
     * manifest, we do not return an error, but we let the dll to be
     * loaded. Notice that this is not a security feature: it's an helper
     * which will try (as much as possible) to discourage the practice
     * of not using a manifest to load the crt dll.
     */

    wchar_t moduleFilePath[_PATH_LEN];
    wchar_t systemRoot[MAX_PATH];
    size_t moduleFilePathLen = 0;
    size_t systemRootLen = 0;
    PFN_FINDAC pfnFindActCtxSectionStringW =NULL;

    /* check condition (1) */
    {
        HINSTANCE hKernel32 = GetModuleHandleW(L"kernel32.dll");
        if (hKernel32 == NULL)
        {
            /* unexpected condition, probably some strange loader lock situation */
            return TRUE;
        }

        pfnFindActCtxSectionStringW = (PFN_FINDAC) GetProcAddress(hKernel32, "FindActCtxSectionStringW");

        if (pfnFindActCtxSectionStringW == NULL)
        {
            /* pre-fusion OS, so no more checking.*/
            return TRUE;
        }
    }

    /* being loaded by instrumented-mscoree.dll. (2) */
    if (GetModuleHandleW(L"PGORT90.dll") && GetModuleHandleW(L"MSCoree.dll"))
    {
        // If pogo-instrumented mscoree is loaded, it has
        // a dependency on pgort90.dll. However, the manifest
        // in pgort90.dll is ignored.
        return TRUE;
    }

    /* retrieve moduleFilePath and systemRoot */
    {
        wchar_t tempPath[_PATH_LEN];
        wchar_t *moduleName = NULL;
        DWORD ret = GetModuleFileNameW(hDllHandle, tempPath, _countof(tempPath));
        if (ret == 0 || ret >= _countof(tempPath))
        {
            /* error or filename longer than _PATH_LEN: we just let
             * the user load the dll, without checking the manifest */
            return TRUE;
        }
        ret = GetLongPathNameW(tempPath, moduleFilePath, _countof(moduleFilePath));
        if (ret == 0 || ret >= _countof(moduleFilePath))
        {
            /* error or filename longer than _PATH_LEN: we just let
             * the user load the dll, without checking the manifest */
            return TRUE;
        }

        moduleName = wcsrchr(moduleFilePath, L'\\');
        if (moduleName == NULL)
        {
            /* error: we could not find a backslash in moduleFilePath */
            return TRUE;
        }
        moduleName++;
        *moduleName = 0;
        /* moduleFilePath now contains only the path of the module ending with a backslash */
        moduleFilePathLen = wcslen(moduleFilePath);

        ret = GetSystemDirectoryW(systemRoot, _countof(systemRoot));
        if (ret == 0 || ret >= _countof(systemRoot))
        {
            /* error or path longer than MAX_PATH: we just let
             * the user load the dll, without checking the manifest */
            return TRUE;
        }
        /* add a trailing backslash if not there already */
        systemRootLen = ret;
        if (systemRoot[systemRootLen - 1] != L'\\')
        {
            if (wcsncat_s(systemRoot, _countof(systemRoot), L"\\", _TRUNCATE) != 0)
            {
                /* error or not enough space */
                return TRUE;
            }
        }
        systemRootLen = wcslen(systemRoot);
    }

    /* check condition (3) */
    if (moduleFilePathLen == systemRootLen &&
        _wcsicmp(moduleFilePath, systemRoot) == 0)
    {
        return FALSE; /* dll loaded from system32 */
    }

    /* check condition (4) */
    {
        ACTCTX_SECTION_KEYED_DATA askd = { sizeof(askd) };
        if (!(*pfnFindActCtxSectionStringW)(0, NULL, ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, _CRT_DLL_FILENAME, &askd))
        {
                        /* no activation context used to load CRT DLL, means no manifest present in the process */
                        return FALSE;
                }
    }

    /* check condition (5) */
    {
        /* retrieves the windows folder */
        systemRootLen = GetSystemWindowsDirectoryW(systemRoot, _countof(systemRoot));
        if (systemRootLen == 0 || systemRootLen >= _countof(systemRoot))
        {
            /* error or path longer than MAX_PATH: we just let
             * the user load the dll, without checking the manifest */
            return TRUE;
        }
        /* add a trailing backslash if not there already */
        if (systemRoot[systemRootLen - 1] != L'\\')
        {
            if (wcsncat_s(systemRoot, _countof(systemRoot), L"\\" _WINSXS_FOLDER, _TRUNCATE) != 0)
            {
                /* error or not enough space */
                return TRUE;
            }
        }
        else
        {
            if (wcsncat_s(systemRoot, _countof(systemRoot), _WINSXS_FOLDER, _TRUNCATE) != 0)
            {
                /* error or not enough space */
                return TRUE;
            }
        }
        systemRootLen = wcslen(systemRoot);

        if (_wcsnicmp(systemRoot, moduleFilePath, systemRootLen) == 0)
        {
            /* moduleFileName begins with %SYSTEMROOT%\WinSxS\ */
            return TRUE; /* dll has been loaded from the WinSxS cache */
        }
    }

    /* check condition (6) */
    {
        struct _wfinddata_t findData = { 0 };
        intptr_t findHandle = -1;

        if (wcsncat_s(moduleFilePath, _countof(moduleFilePath), _MANIFEST_FILENAME, _TRUNCATE) != 0)
        {
            /* error or truncation */
            return TRUE;
        }
        findHandle = _wfindfirst(moduleFilePath, &findData);
        if (findHandle != -1)
        {
            _findclose(findHandle);
            return TRUE; /* manifest is in the same folder as the dll */
        }
        /* we could not find the manifest in the same folder as the dll */
        moduleFilePath[moduleFilePathLen] = 0;
        /* restore moduleFilePath so that it contains only the path of the module with final backslash */
    }

    /* case (7): loaded with another manifest */
    return FALSE;
}

/*
 * Earlier the below exports were only for X86, but with invent of /clr:pure,
 * they need to be defined for all the platform.
 */

/*
 * Functions to access user-visible, per-process variables
 */

/*
 * Macro to construct the name of the access function from the variable
 * name.
 */
#define AFNAME(var) __p_ ## var

/*
 * Macro to construct the access function's return value from the variable
 * name.
 */
#define AFRET(var)  &var

/*
 ***
 ***  Template
 ***

_CRTIMP __cdecl
AFNAME() (void)
{
        return AFRET();
}

 ***
 ***
 ***
 */

#ifdef _DEBUG

_CRTIMP long *
AFNAME(_crtAssertBusy) (void)
{
        return AFRET(_crtAssertBusy);
}

_CRTIMP long *
AFNAME(_crtBreakAlloc) (void)
{
        return AFRET(_crtBreakAlloc);
}

_CRTIMP int *
AFNAME(_crtDbgFlag) (void)
{
        return AFRET(_crtDbgFlag);
}

#endif  /* _DEBUG */

_CRTIMP char ** __cdecl
AFNAME(_acmdln) (void)
{
        return AFRET(_acmdln);
}

_CRTIMP wchar_t ** __cdecl
AFNAME(_wcmdln) (void)
{
        return AFRET(_wcmdln);
}

_CRTIMP unsigned int * __cdecl
AFNAME(_amblksiz) (void)
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        return AFRET(_amblksiz);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

_CRTIMP int * __cdecl
AFNAME(__argc) (void)
{
        return AFRET(__argc);
}

_CRTIMP char *** __cdecl
AFNAME(__argv) (void)
{
        return AFRET(__argv);
}

_CRTIMP wchar_t *** __cdecl
AFNAME(__wargv) (void)
{
        return AFRET(__wargv);
}

_CRTIMP int * __cdecl
AFNAME(_commode) (void)
{
        return AFRET(_commode);
}

_CRTIMP int * __cdecl
AFNAME(_daylight) (void)
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        return AFRET(_daylight);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

_CRTIMP long * __cdecl
AFNAME(_dstbias) (void)
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        return AFRET(_dstbias);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

_CRTIMP char *** __cdecl
AFNAME(_environ) (void)
{
        return AFRET(_environ);
}

_CRTIMP wchar_t *** __cdecl
AFNAME(_wenviron) (void)
{
        return AFRET(_wenviron);
}

_CRTIMP int * __cdecl
AFNAME(_fmode) (void)
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        return AFRET(_fmode);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

_CRTIMP char *** __cdecl
AFNAME(__initenv) (void)
{
        return AFRET(__initenv);
}

_CRTIMP wchar_t *** __cdecl
AFNAME(__winitenv) (void)
{
        return AFRET(__winitenv);
}

_CRTIMP FILE *
AFNAME(_iob) (void)
{
        return &_iob[0];
}

_CRTIMP unsigned char * __cdecl
AFNAME(_mbctype) (void)
{
        return &_mbctype[0];
}

_CRTIMP unsigned char * __cdecl
AFNAME(_mbcasemap) (void)
{
        return &_mbcasemap[0];
}

_CRTIMP int * __cdecl
AFNAME(__mb_cur_max) (void)
{
        _ptiddata ptd = _getptd();
        pthreadlocinfo ptloci = ptd->ptlocinfo;

        __UPDATE_LOCALE(ptd, ptloci);
        return AFRET(__MB_CUR_MAX(ptloci));
}

_CRTIMP const unsigned short ** __cdecl
AFNAME(_pctype) (void)
{
        _ptiddata ptd = _getptd();
        pthreadlocinfo ptloci = ptd->ptlocinfo;

        __UPDATE_LOCALE(ptd, ptloci);
        return AFRET(ptloci->pctype);
}

_CRTIMP const unsigned short ** __cdecl
AFNAME(_pwctype) (void)
{
        return AFRET(_pwctype);
}

_CRTIMP char **  __cdecl
AFNAME(_pgmptr) (void)
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        return AFRET(_pgmptr);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

_CRTIMP wchar_t ** __cdecl
AFNAME(_wpgmptr) (void)
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        return AFRET(_wpgmptr);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

_CRTIMP long * __cdecl
AFNAME(_timezone) (void)
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        return AFRET(_timezone);
_END_SECURE_CRT_DEPRECATION_DISABLE
}

_CRTIMP char ** __cdecl
AFNAME(_tzname) (void)
{
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
        return &_tzname[0];
_END_SECURE_CRT_DEPRECATION_DISABLE
}

#endif  /* defined (CRTDLL) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\cwscanfs.c ===
/***
*cwscanfs.c - Conio version of wscanf_s
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       This takes a size from the argument list for all string inputs.
*
*******************************************************************************/

#define CPRFLAG 1
#define _SECURE_SCANF 1
#include "winput.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgmalloc.c ===
/***
*dbgmalloc.c - Debug CRT Heap Function of malloc()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines debug versions of heap function malloc().
*
*******************************************************************************/

#ifdef _DEBUG

#include <windows.h>
#include <winheap.h>
#include <ctype.h>
#include <dbgint.h>
#include <crtdbg.h>
#include <rtcsup.h>
#include <internal.h>
#include <limits.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

#pragma warning(disable:4390)


/***
*void *malloc() - Get a block of memory from the debug heap
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the heap and
*       return a pointer to it.
*
*       Allocates 'normal' memory block.
*
*Entry:
*       size_t          nSize       - size of block requested
*
*Exit:
*       Success:  Pointer to memory block
*       Failure:  NULL (or some error value)
*
*Exceptions:
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl malloc (
        size_t nSize
        )
{
        void *res = _nh_malloc_dbg(nSize, _newmode, _NORMAL_BLOCK, NULL, 0);

        RTCCALLBACK(_RTC_Allocate_hook, (res, nSize, 0));

        return res;
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgnew.cpp ===
/***
*dbgnew.cpp - defines C++ new() routines, debug version
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ new() routines.
*
*******************************************************************************/

#ifdef _DEBUG

#include <cruntime.h>
#include <malloc.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>
#include <new>

/***
*void * operator new() - Get a block of memory from the debug heap
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the heap and
*       return a pointer to it.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          cb          - count of bytes requested
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*
*Exit:
*       Success:  Pointer to memory block
*       Failure:  throws std::bad_alloc
*
*Exceptions:
*       Failure:  throws std::bad_alloc
*
*******************************************************************************/
void *__CRTDECL operator new(
        size_t cb,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
        _THROW1(_STD bad_alloc)
{
    /* _nh_malloc_dbg already calls _heap_alloc_dbg in a loop and calls _callnewh
       if the allocation fails. If _callnewh returns (very likely because no
       new handlers have been installed by the user), _nh_malloc_dbg returns NULL.
     */
    void *res = _nh_malloc_dbg( cb, 1, nBlockUse, szFileName, nLine );

    RTCCALLBACK(_RTC_Allocate_hook, (res, cb, 0));

    /* if the allocation fails, we throw std::bad_alloc */
    if (res == 0)
    {
        static const std::bad_alloc nomem;
        _RAISE(nomem);
    }

    return res;
}

/***
*void * operator new() - Get a block of memory from the debug heap
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the heap and
*       return a pointer to it.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          cb          - count of bytes requested
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*
*Exit:
*       Success:  Pointer to memory block
*       Failure:  NULL (or some error value)
*
*Exceptions:
*
*******************************************************************************/
void *__CRTDECL operator new[](
        size_t cb,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
        _THROW1(_STD bad_alloc)
{
    void *res = operator new(cb, nBlockUse, szFileName, nLine );

    RTCCALLBACK(_RTC_Allocate_hook, (res, cb, 0));

    return res;
}

#else  /* _DEBUG */

#include <new>

/* Implement debug operator new and operator new[] in retail libraries as well,
 * simply calling the retail operator new.
 * These debug versions are declared only in crtdbg.h.
 * Implementing there operators in the CRT libraries makes it easier to override them
 * linking to nothrownew.obj.
 */

void *__CRTDECL operator new(
        size_t cb,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
        _THROW1(_STD bad_alloc)
{
    (nBlockUse);
    (szFileName);
    (nLine);
    return operator new(cb);
}

void *__CRTDECL operator new[](
        size_t cb,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
        _THROW1(_STD bad_alloc)
{
    (nBlockUse);
    (szFileName);
    (nLine);
    return operator new[](cb);
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgrealloc.c ===
/***
*dbgrecalloc.c - Debug CRT Heap Function of recalloc()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines debug versions of heap functions recalloc().
*
*******************************************************************************/

#ifdef _DEBUG

#include <windows.h>
#include <winheap.h>
#include <ctype.h>
#include <dbgint.h>
#include <crtdbg.h>
#include <rtcsup.h>
#include <internal.h>
#include <limits.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

#pragma warning(disable:4390)

/***
*void * realloc() - reallocate a block of memory in the heap
*
*Purpose:
*       Re-allocates a block in the heap to nNewSize bytes. nNewSize may be
*       either greater or less than the original size of the block. The
*       re-allocation may result in moving the block as well as changing
*       the size. If the block is moved, the contents of the original block
*       are copied over.
*
*       Re-allocates 'normal' memory block.
*
*Entry:
*       void *          pUserData   - pointer to previously allocated block
*       size_t          nNewSize    - requested size for the re-allocated block
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl realloc(
        void * pUserData,
        size_t nNewSize
        )
{
        void *res = _realloc_dbg(pUserData, nNewSize, _NORMAL_BLOCK, NULL, 0);

        return res;
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ctype.c ===
/***
*ctype.c - _ctype definition file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       _ctype definition file of character classification data.  This file
*       initializes the array used by the character classification macros
*       in ctype.h.
*
*******************************************************************************/

#include <cruntime.h>
#include <windows.h>
#include <ctype.h>
#include <setlocal.h>
#include <wchar.h>
#include <mtdll.h>

const unsigned short *_pctype = __newctype+128;  /* pointer to table for char's      */
const unsigned short *_pwctype = _wctype+1;    /* pointer to table for wchar_t's   */

_CRTIMP const unsigned short *__cdecl __pwctype_func(void)
{
    return _pwctype;
}

_CRTIMP const unsigned short *__cdecl __pctype_func(void)
{
    /*
     * Note that we don't need _LocaleUpdate in this function.
     * The main reason being, that this is a leaf function in
     * locale usage terms.
     */
    _ptiddata ptd = _getptd();
    pthreadlocinfo ptloci = ptd->ptlocinfo;

    __UPDATE_LOCALE(ptd, ptloci);
    return ptloci->pctype;
}

const unsigned short _wctype[] = {
    0,                              /* -1 EOF   */
    _CONTROL ,                      /* 00 (NUL) */
    _CONTROL ,                      /* 01 (SOH) */
    _CONTROL ,                      /* 02 (STX) */
    _CONTROL ,                      /* 03 (ETX) */
    _CONTROL ,                      /* 04 (EOT) */
    _CONTROL ,                      /* 05 (ENQ) */
    _CONTROL ,                      /* 06 (ACK) */
    _CONTROL ,                      /* 07 (BEL) */
    _CONTROL ,                      /* 08 (BS)  */
    _SPACE | _CONTROL | _BLANK ,    /* 09 (HT)  */
    _SPACE | _CONTROL ,             /* 0A (LF)  */
    _SPACE | _CONTROL ,             /* 0B (VT)  */
    _SPACE | _CONTROL ,             /* 0C (FF)  */
    _SPACE | _CONTROL ,             /* 0D (CR)  */
    _CONTROL ,                      /* 0E (SI)  */
    _CONTROL ,                      /* 0F (SO)  */
    _CONTROL ,                      /* 10 (DLE) */
    _CONTROL ,                      /* 11 (DC1) */
    _CONTROL ,                      /* 12 (DC2) */
    _CONTROL ,                      /* 13 (DC3) */
    _CONTROL ,                      /* 14 (DC4) */
    _CONTROL ,                      /* 15 (NAK) */
    _CONTROL ,                      /* 16 (SYN) */
    _CONTROL ,                      /* 17 (ETB) */
    _CONTROL ,                      /* 18 (CAN) */
    _CONTROL ,                      /* 19 (EM)  */
    _CONTROL ,                      /* 1A (SUB) */
    _CONTROL ,                      /* 1B (ESC) */
    _CONTROL ,                      /* 1C (FS)  */
    _CONTROL ,                      /* 1D (GS)  */
    _CONTROL ,                      /* 1E (RS)  */
    _CONTROL ,                      /* 1F (US)  */
    _SPACE | _BLANK ,               /* 20 SPACE */
    _PUNCT ,                        /* 21 !     */
    _PUNCT ,                        /* 22 "     */
    _PUNCT ,                        /* 23 #     */
    _PUNCT ,                        /* 24 $     */
    _PUNCT ,                        /* 25 %     */
    _PUNCT ,                        /* 26 &     */
    _PUNCT ,                        /* 27 '     */
    _PUNCT ,                        /* 28 (     */
    _PUNCT ,                        /* 29 )     */
    _PUNCT ,                        /* 2A *     */
    _PUNCT ,                        /* 2B +     */
    _PUNCT ,                        /* 2C ,     */
    _PUNCT ,                        /* 2D -     */
    _PUNCT ,                        /* 2E .     */
    _PUNCT ,                        /* 2F /     */
    _DIGIT | _HEX ,                 /* 30 0     */
    _DIGIT | _HEX ,                 /* 31 1     */
    _DIGIT | _HEX ,                 /* 32 2     */
    _DIGIT | _HEX ,                 /* 33 3     */
    _DIGIT | _HEX ,                 /* 34 4     */
    _DIGIT | _HEX ,                 /* 35 5     */
    _DIGIT | _HEX ,                 /* 36 6     */
    _DIGIT | _HEX ,                 /* 37 7     */
    _DIGIT | _HEX ,                 /* 38 8     */
    _DIGIT | _HEX ,                 /* 39 9     */
    _PUNCT ,                        /* 3A :     */
    _PUNCT ,                        /* 3B ;     */
    _PUNCT ,                        /* 3C <     */
    _PUNCT ,                        /* 3D =     */
    _PUNCT ,                        /* 3E >     */
    _PUNCT ,                        /* 3F ?     */
    _PUNCT ,                        /* 40 @     */
    _UPPER | _HEX | C1_ALPHA ,      /* 41 A     */
    _UPPER | _HEX | C1_ALPHA ,      /* 42 B     */
    _UPPER | _HEX | C1_ALPHA ,      /* 43 C     */
    _UPPER | _HEX | C1_ALPHA ,      /* 44 D     */
    _UPPER | _HEX | C1_ALPHA ,      /* 45 E     */
    _UPPER | _HEX | C1_ALPHA ,      /* 46 F     */
    _UPPER | C1_ALPHA ,             /* 47 G     */
    _UPPER | C1_ALPHA ,             /* 48 H     */
    _UPPER | C1_ALPHA ,             /* 49 I     */
    _UPPER | C1_ALPHA ,             /* 4A J     */
    _UPPER | C1_ALPHA ,             /* 4B K     */
    _UPPER | C1_ALPHA ,             /* 4C L     */
    _UPPER | C1_ALPHA ,             /* 4D M     */
    _UPPER | C1_ALPHA ,             /* 4E N     */
    _UPPER | C1_ALPHA ,             /* 4F O     */
    _UPPER | C1_ALPHA ,             /* 50 P     */
    _UPPER | C1_ALPHA ,             /* 51 Q     */
    _UPPER | C1_ALPHA ,             /* 52 R     */
    _UPPER | C1_ALPHA ,             /* 53 S     */
    _UPPER | C1_ALPHA ,             /* 54 T     */
    _UPPER | C1_ALPHA ,             /* 55 U     */
    _UPPER | C1_ALPHA ,             /* 56 V     */
    _UPPER | C1_ALPHA ,             /* 57 W     */
    _UPPER | C1_ALPHA ,             /* 58 X     */
    _UPPER | C1_ALPHA ,             /* 59 Y     */
    _UPPER | C1_ALPHA ,             /* 5A Z     */
    _PUNCT ,                        /* 5B [     */
    _PUNCT ,                        /* 5C \     */
    _PUNCT ,                        /* 5D ]     */
    _PUNCT ,                        /* 5E ^     */
    _PUNCT ,                        /* 5F _     */
    _PUNCT ,                        /* 60 `     */
    _LOWER | _HEX | C1_ALPHA ,      /* 61 a     */
    _LOWER | _HEX | C1_ALPHA ,      /* 62 b     */
    _LOWER | _HEX | C1_ALPHA ,      /* 63 c     */
    _LOWER | _HEX | C1_ALPHA ,      /* 64 d     */
    _LOWER | _HEX | C1_ALPHA ,      /* 65 e     */
    _LOWER | _HEX | C1_ALPHA ,      /* 66 f     */
    _LOWER | C1_ALPHA ,             /* 67 g     */
    _LOWER | C1_ALPHA ,             /* 68 h     */
    _LOWER | C1_ALPHA ,             /* 69 i     */
    _LOWER | C1_ALPHA ,             /* 6A j     */
    _LOWER | C1_ALPHA ,             /* 6B k     */
    _LOWER | C1_ALPHA ,             /* 6C l     */
    _LOWER | C1_ALPHA ,             /* 6D m     */
    _LOWER | C1_ALPHA ,             /* 6E n     */
    _LOWER | C1_ALPHA ,             /* 6F o     */
    _LOWER | C1_ALPHA ,             /* 70 p     */
    _LOWER | C1_ALPHA ,             /* 71 q     */
    _LOWER | C1_ALPHA ,             /* 72 r     */
    _LOWER | C1_ALPHA ,             /* 73 s     */
    _LOWER | C1_ALPHA ,             /* 74 t     */
    _LOWER | C1_ALPHA ,             /* 75 u     */
    _LOWER | C1_ALPHA ,             /* 76 v     */
    _LOWER | C1_ALPHA ,             /* 77 w     */
    _LOWER | C1_ALPHA ,             /* 78 x     */
    _LOWER | C1_ALPHA ,             /* 79 y     */
    _LOWER | C1_ALPHA ,             /* 7A z     */
    _PUNCT ,                        /* 7B {     */
    _PUNCT ,                        /* 7C |     */
    _PUNCT ,                        /* 7D }     */
    _PUNCT ,                        /* 7E ~     */
    _CONTROL ,                      /* 7F (DEL) */
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _CONTROL ,
    _SPACE | _BLANK ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _DIGIT | _PUNCT ,
    _DIGIT | _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _DIGIT | _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _PUNCT ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _PUNCT ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _UPPER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _PUNCT ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _LOWER | C1_ALPHA ,
    _UPPER | C1_ALPHA
};
const unsigned short __newctype[384] = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0,
        0,                      /* -1 EOF   */
        _CONTROL,               /* 00 (NUL) */
        _CONTROL,               /* 01 (SOH) */
        _CONTROL,               /* 02 (STX) */
        _CONTROL,               /* 03 (ETX) */
        _CONTROL,               /* 04 (EOT) */
        _CONTROL,               /* 05 (ENQ) */
        _CONTROL,               /* 06 (ACK) */
        _CONTROL,               /* 07 (BEL) */
        _CONTROL,               /* 08 (BS)  */
        _SPACE+_CONTROL,        /* 09 (HT)  */
        _SPACE+_CONTROL,        /* 0A (LF)  */
        _SPACE+_CONTROL,        /* 0B (VT)  */
        _SPACE+_CONTROL,        /* 0C (FF)  */
        _SPACE+_CONTROL,        /* 0D (CR)  */
        _CONTROL,               /* 0E (SI)  */
        _CONTROL,               /* 0F (SO)  */
        _CONTROL,               /* 10 (DLE) */
        _CONTROL,               /* 11 (DC1) */
        _CONTROL,               /* 12 (DC2) */
        _CONTROL,               /* 13 (DC3) */
        _CONTROL,               /* 14 (DC4) */
        _CONTROL,               /* 15 (NAK) */
        _CONTROL,               /* 16 (SYN) */
        _CONTROL,               /* 17 (ETB) */
        _CONTROL,               /* 18 (CAN) */
        _CONTROL,               /* 19 (EM)  */
        _CONTROL,               /* 1A (SUB) */
        _CONTROL,               /* 1B (ESC) */
        _CONTROL,               /* 1C (FS)  */
        _CONTROL,               /* 1D (GS)  */
        _CONTROL,               /* 1E (RS)  */
        _CONTROL,               /* 1F (US)  */
        _SPACE+_BLANK,          /* 20 SPACE */
        _PUNCT,                 /* 21 !     */
        _PUNCT,                 /* 22 "     */
        _PUNCT,                 /* 23 #     */
        _PUNCT,                 /* 24 $     */
        _PUNCT,                 /* 25 %     */
        _PUNCT,                 /* 26 &     */
        _PUNCT,                 /* 27 '     */
        _PUNCT,                 /* 28 (     */
        _PUNCT,                 /* 29 )     */
        _PUNCT,                 /* 2A *     */
        _PUNCT,                 /* 2B +     */
        _PUNCT,                 /* 2C ,     */
        _PUNCT,                 /* 2D -     */
        _PUNCT,                 /* 2E .     */
        _PUNCT,                 /* 2F /     */
        _DIGIT+_HEX,            /* 30 0     */
        _DIGIT+_HEX,            /* 31 1     */
        _DIGIT+_HEX,            /* 32 2     */
        _DIGIT+_HEX,            /* 33 3     */
        _DIGIT+_HEX,            /* 34 4     */
        _DIGIT+_HEX,            /* 35 5     */
        _DIGIT+_HEX,            /* 36 6     */
        _DIGIT+_HEX,            /* 37 7     */
        _DIGIT+_HEX,            /* 38 8     */
        _DIGIT+_HEX,            /* 39 9     */
        _PUNCT,                 /* 3A :     */
        _PUNCT,                 /* 3B ;     */
        _PUNCT,                 /* 3C <     */
        _PUNCT,                 /* 3D =     */
        _PUNCT,                 /* 3E >     */
        _PUNCT,                 /* 3F ?     */
        _PUNCT,                 /* 40 @     */
        _UPPER+_HEX,            /* 41 A     */
        _UPPER+_HEX,            /* 42 B     */
        _UPPER+_HEX,            /* 43 C     */
        _UPPER+_HEX,            /* 44 D     */
        _UPPER+_HEX,            /* 45 E     */
        _UPPER+_HEX,            /* 46 F     */
        _UPPER,                 /* 47 G     */
        _UPPER,                 /* 48 H     */
        _UPPER,                 /* 49 I     */
        _UPPER,                 /* 4A J     */
        _UPPER,                 /* 4B K     */
        _UPPER,                 /* 4C L     */
        _UPPER,                 /* 4D M     */
        _UPPER,                 /* 4E N     */
        _UPPER,                 /* 4F O     */
        _UPPER,                 /* 50 P     */
        _UPPER,                 /* 51 Q     */
        _UPPER,                 /* 52 R     */
        _UPPER,                 /* 53 S     */
        _UPPER,                 /* 54 T     */
        _UPPER,                 /* 55 U     */
        _UPPER,                 /* 56 V     */
        _UPPER,                 /* 57 W     */
        _UPPER,                 /* 58 X     */
        _UPPER,                 /* 59 Y     */
        _UPPER,                 /* 5A Z     */
        _PUNCT,                 /* 5B [     */
        _PUNCT,                 /* 5C \     */
        _PUNCT,                 /* 5D ]     */
        _PUNCT,                 /* 5E ^     */
        _PUNCT,                 /* 5F _     */
        _PUNCT,                 /* 60 `     */
        _LOWER+_HEX,            /* 61 a     */
        _LOWER+_HEX,            /* 62 b     */
        _LOWER+_HEX,            /* 63 c     */
        _LOWER+_HEX,            /* 64 d     */
        _LOWER+_HEX,            /* 65 e     */
        _LOWER+_HEX,            /* 66 f     */
        _LOWER,                 /* 67 g     */
        _LOWER,                 /* 68 h     */
        _LOWER,                 /* 69 i     */
        _LOWER,                 /* 6A j     */
        _LOWER,                 /* 6B k     */
        _LOWER,                 /* 6C l     */
        _LOWER,                 /* 6D m     */
        _LOWER,                 /* 6E n     */
        _LOWER,                 /* 6F o     */
        _LOWER,                 /* 70 p     */
        _LOWER,                 /* 71 q     */
        _LOWER,                 /* 72 r     */
        _LOWER,                 /* 73 s     */
        _LOWER,                 /* 74 t     */
        _LOWER,                 /* 75 u     */
        _LOWER,                 /* 76 v     */
        _LOWER,                 /* 77 w     */
        _LOWER,                 /* 78 x     */
        _LOWER,                 /* 79 y     */
        _LOWER,                 /* 7A z     */
        _PUNCT,                 /* 7B {     */
        _PUNCT,                 /* 7C |     */
        _PUNCT,                 /* 7D }     */
        _PUNCT,                 /* 7E ~     */
        _CONTROL,               /* 7F (DEL) */
        /* and the rest are 0... */
};

const unsigned char __newclmap[384] = {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
        0x00,   /* 00 (NUL) */
        0x01,   /* 01 (SOH) */
        0x02,   /* 02 (STX) */
        0x03,   /* 03 (ETX) */
        0x04,   /* 04 (EOT) */
        0x05,   /* 05 (ENQ) */
        0x06,   /* 06 (ACK) */
        0x07,   /* 07 (BEL) */
        0x08,   /* 08 (BS)  */
        0x09,   /* 09 (HT)  */
        0x0A,   /* 0A (LF)  */
        0x0B,   /* 0B (VT)  */
        0x0C,   /* 0C (FF)  */
        0x0D,   /* 0D (CR)  */
        0x0E,   /* 0E (SI)  */
        0x0F,   /* 0F (SO)  */
        0x10,   /* 10 (DLE) */
        0x11,   /* 11 (DC1) */
        0x12,   /* 12 (DC2) */
        0x13,   /* 13 (DC3) */
        0x14,   /* 14 (DC4) */
        0x15,   /* 15 (NAK) */
        0x16,   /* 16 (SYN) */
        0x17,   /* 17 (ETB) */
        0x18,   /* 18 (CAN) */
        0x19,   /* 19 (EM)  */
        0x1A,   /* 1A (SUB) */
        0x1B,   /* 1B (ESC) */
        0x1C,   /* 1C (FS)  */
        0x1D,   /* 1D (GS)  */
        0x1E,   /* 1E (RS)  */
        0x1F,   /* 1F (US)  */
        0x20,   /* 20 SPACE */
        0x21,   /* 21 !     */
        0x22,   /* 22 "     */
        0x23,   /* 23 #     */
        0x24,   /* 24 $     */
        0x25,   /* 25 %     */
        0x26,   /* 26 &     */
        0x27,   /* 27 '     */
        0x28,   /* 28 (     */
        0x29,   /* 29 )     */
        0x2A,   /* 2A *     */
        0x2B,   /* 2B +     */
        0x2C,   /* 2C ,     */
        0x2D,   /* 2D -     */
        0x2E,   /* 2E .     */
        0x2F,   /* 2F /     */
        0x30,   /* 30 0     */
        0x31,   /* 31 1     */
        0x32,   /* 32 2     */
        0x33,   /* 33 3     */
        0x34,   /* 34 4     */
        0x35,   /* 35 5     */
        0x36,   /* 36 6     */
        0x37,   /* 37 7     */
        0x38,   /* 38 8     */
        0x39,   /* 39 9     */
        0x3A,   /* 3A :     */
        0x3B,   /* 3B ;     */
        0x3C,   /* 3C <     */
        0x3D,   /* 3D =     */
        0x3E,   /* 3E >     */
        0x3F,   /* 3F ?     */
        0x40,   /* 40 @     */
        0x61,   /* 41 A     */
        0x62,   /* 42 B     */
        0x63,   /* 43 C     */
        0x64,   /* 44 D     */
        0x65,   /* 45 E     */
        0x66,   /* 46 F     */
        0x67,   /* 47 G     */
        0x68,   /* 48 H     */
        0x69,   /* 49 I     */
        0x6A,   /* 4A J     */
        0x6B,   /* 4B K     */
        0x6C,   /* 4C L     */
        0x6D,   /* 4D M     */
        0x6E,   /* 4E N     */
        0x6F,   /* 4F O     */
        0x70,   /* 50 P     */
        0x71,   /* 51 Q     */
        0x72,   /* 52 R     */
        0x73,   /* 53 S     */
        0x74,   /* 54 T     */
        0x75,   /* 55 U     */
        0x76,   /* 56 V     */
        0x77,   /* 57 W     */
        0x78,   /* 58 X     */
        0x79,   /* 59 Y     */
        0x7A,   /* 5A Z     */
        0x5B,   /* 5B [     */
        0x5C,   /* 5C \     */
        0x5D,   /* 5D ]     */
        0x5E,   /* 5E ^     */
        0x5F,   /* 5F _     */
        0x60,   /* 60 `     */
        0x61,   /* 61 a     */
        0x62,   /* 62 b     */
        0x63,   /* 63 c     */
        0x64,   /* 64 d     */
        0x65,   /* 65 e     */
        0x66,   /* 66 f     */
        0x67,   /* 67 g     */
        0x68,   /* 68 h     */
        0x69,   /* 69 i     */
        0x6A,   /* 6A j     */
        0x6B,   /* 6B k     */
        0x6C,   /* 6C l     */
        0x6D,   /* 6D m     */
        0x6E,   /* 6E n     */
        0x6F,   /* 6F o     */
        0x70,   /* 70 p     */
        0x71,   /* 71 q     */
        0x72,   /* 72 r     */
        0x73,   /* 73 s     */
        0x74,   /* 74 t     */
        0x75,   /* 75 u     */
        0x76,   /* 76 v     */
        0x77,   /* 77 w     */
        0x78,   /* 78 x     */
        0x79,   /* 79 y     */
        0x7A,   /* 7A z     */
        0x7B,   /* 7B {     */
        0x7C,   /* 7C |     */
        0x7D,   /* 7D }     */
        0x7E,   /* 7E ~     */
        0x7F,   /* 7F (DEL) */
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};

const unsigned char __newcumap[384] = {
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
        0x00,   /* 00 (NUL) */
        0x01,   /* 01 (SOH) */
        0x02,   /* 02 (STX) */
        0x03,   /* 03 (ETX) */
        0x04,   /* 04 (EOT) */
        0x05,   /* 05 (ENQ) */
        0x06,   /* 06 (ACK) */
        0x07,   /* 07 (BEL) */
        0x08,   /* 08 (BS)  */
        0x09,   /* 09 (HT)  */
        0x0A,   /* 0A (LF)  */
        0x0B,   /* 0B (VT)  */
        0x0C,   /* 0C (FF)  */
        0x0D,   /* 0D (CR)  */
        0x0E,   /* 0E (SI)  */
        0x0F,   /* 0F (SO)  */
        0x10,   /* 10 (DLE) */
        0x11,   /* 11 (DC1) */
        0x12,   /* 12 (DC2) */
        0x13,   /* 13 (DC3) */
        0x14,   /* 14 (DC4) */
        0x15,   /* 15 (NAK) */
        0x16,   /* 16 (SYN) */
        0x17,   /* 17 (ETB) */
        0x18,   /* 18 (CAN) */
        0x19,   /* 19 (EM)  */
        0x1A,   /* 1A (SUB) */
        0x1B,   /* 1B (ESC) */
        0x1C,   /* 1C (FS)  */
        0x1D,   /* 1D (GS)  */
        0x1E,   /* 1E (RS)  */
        0x1F,   /* 1F (US)  */
        0x20,   /* 20 SPACE */
        0x21,   /* 21 !     */
        0x22,   /* 22 "     */
        0x23,   /* 23 #     */
        0x24,   /* 24 $     */
        0x25,   /* 25 %     */
        0x26,   /* 26 &     */
        0x27,   /* 27 '     */
        0x28,   /* 28 (     */
        0x29,   /* 29 )     */
        0x2A,   /* 2A *     */
        0x2B,   /* 2B +     */
        0x2C,   /* 2C ,     */
        0x2D,   /* 2D -     */
        0x2E,   /* 2E .     */
        0x2F,   /* 2F /     */
        0x30,   /* 30 0     */
        0x31,   /* 31 1     */
        0x32,   /* 32 2     */
        0x33,   /* 33 3     */
        0x34,   /* 34 4     */
        0x35,   /* 35 5     */
        0x36,   /* 36 6     */
        0x37,   /* 37 7     */
        0x38,   /* 38 8     */
        0x39,   /* 39 9     */
        0x3A,   /* 3A :     */
        0x3B,   /* 3B ;     */
        0x3C,   /* 3C <     */
        0x3D,   /* 3D =     */
        0x3E,   /* 3E >     */
        0x3F,   /* 3F ?     */
        0x40,   /* 40 @     */
        0x41,   /* 41 A     */
        0x42,   /* 42 B     */
        0x43,   /* 43 C     */
        0x44,   /* 44 D     */
        0x45,   /* 45 E     */
        0x46,   /* 46 F     */
        0x47,   /* 47 G     */
        0x48,   /* 48 H     */
        0x49,   /* 49 I     */
        0x4A,   /* 4A J     */
        0x4B,   /* 4B K     */
        0x4C,   /* 4C L     */
        0x4D,   /* 4D M     */
        0x4E,   /* 4E N     */
        0x4F,   /* 4F O     */
        0x50,   /* 50 P     */
        0x51,   /* 51 Q     */
        0x52,   /* 52 R     */
        0x53,   /* 53 S     */
        0x54,   /* 54 T     */
        0x55,   /* 55 U     */
        0x56,   /* 56 V     */
        0x57,   /* 57 W     */
        0x58,   /* 58 X     */
        0x59,   /* 59 Y     */
        0x5A,   /* 5A Z     */
        0x5B,   /* 5B [     */
        0x5C,   /* 5C \     */
        0x5D,   /* 5D ]     */
        0x5E,   /* 5E ^     */
        0x5F,   /* 5F _     */
        0x60,   /* 60 `     */
        0x41,   /* 61 a     */
        0x42,   /* 62 b     */
        0x43,   /* 63 c     */
        0x44,   /* 64 d     */
        0x45,   /* 65 e     */
        0x46,   /* 66 f     */
        0x47,   /* 67 g     */
        0x48,   /* 68 h     */
        0x49,   /* 69 i     */
        0x4A,   /* 6A j     */
        0x4B,   /* 6B k     */
        0x4C,   /* 6C l     */
        0x4D,   /* 6D m     */
        0x4E,   /* 6E n     */
        0x4F,   /* 6F o     */
        0x50,   /* 70 p     */
        0x51,   /* 71 q     */
        0x52,   /* 72 r     */
        0x53,   /* 73 s     */
        0x54,   /* 74 t     */
        0x55,   /* 75 u     */
        0x56,   /* 76 v     */
        0x57,   /* 77 w     */
        0x58,   /* 78 x     */
        0x59,   /* 79 y     */
        0x5A,   /* 7A z     */
        0x7B,   /* 7B {     */
        0x7C,   /* 7C |     */
        0x7D,   /* 7D }     */
        0x7E,   /* 7E ~     */
        0x7F,   /* 7F (DEL) */
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
        0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgrptw.c ===
/***
*dbgrptw.c - Debug CRT Reporting Functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "dbgrpt.c"

#ifdef _DEBUG

#ifdef __cplusplus

#if defined (_NATIVE_WCHAR_T_DEFINED)

extern "C++"
_CRTIMP int __cdecl _CrtDbgReportW(
        int nRptType,
        const unsigned short * szFile,
        int nLine,
        const unsigned short * szModule,
        const unsigned short * szFormat,
        ...
        )
{
    int retval;
    va_list arglist;

    va_start(arglist,szFormat);

    retval = _CrtDbgReportTV(nRptType, reinterpret_cast<const wchar_t*>(szFile), nLine, reinterpret_cast<const wchar_t*>(szModule), reinterpret_cast<const wchar_t*>(szFormat), arglist);

    va_end(arglist);

    return retval;
}

#endif  /* defined (_NATIVE_WCHAR_T_DEFINED) */

#endif  /* __cplusplus */

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgsec.c ===
/***
*dbgsec.c - Debug CRT Security Check Helper
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines alternative version of _CrtSetCheckCount helper.
*
*******************************************************************************/

#ifdef _DEBUG

/***
*int _CrtSetCheckCount(int fCheckCount)
*       - Redefine import version of _CrtSetCheckCount
*
*Purpose:
*       Deliberately overwrite the default behavior of MSVCRXXD.DLL import
*       version of _CrtSetCheckCount. This file is linked into MSVCMXX.DLL and
*       MSVCPXX.DLL. The purpose is to allow backwards compatibility for apps
*       compiled with older CRT to be able to execute against newer CRT without
*       causing asserts. Without this change, a managed app can load up new
*       MSVCMXXD.DLL which sets the buffer checking flag in MSVCRXXD.DLL, and
*       triggers checkings inside the 'n'versions of the secure CRT.
*
*Entry:
*       int fCheckCount - not used
*
*Exit:
*       return 0
*
*******************************************************************************/

int _CrtSetCheckCount(int fCheckCount)
{
    return 0;
}

#ifdef _M_IX86
int (__cdecl * _imp___CrtSetCheckCount)(int) = &_CrtSetCheckCount;
#else  /* _M_IX86 */
int (__cdecl * __imp__CrtSetCheckCount)(int) = &_CrtSetCheckCount;
#endif  /* _M_IX86 */

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbghook.c ===
/***
*dbghook.c - Debug CRT Hook Functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Allow users to override default alloc hook at link time.
*
*******************************************************************************/

#include <dbgint.h>

#ifdef _DEBUG

#include <internal.h>
#include <limits.h>
#include <mtdll.h>
#include <malloc.h>
#include <stdlib.h>

_CRT_ALLOC_HOOK _pfnAllocHook = _CrtDefaultAllocHook;

/***
*int _CrtDefaultAllocHook() - allow allocation
*
*Purpose:
*       allow allocation
*
*Entry:
*       all parameters ignored
*
*Exit:
*       returns TRUE
*
*Exceptions:
*
*******************************************************************************/
int __cdecl _CrtDefaultAllocHook(
        int nAllocType,
        void * pvData,
        size_t nSize,
        int nBlockUse,
        long lRequest,
        const unsigned char * szFileName,
        int nLine
        )
{
        return 1; /* allow all allocs/reallocs/frees */
}

#endif  /* _DEBUG */

int _debugger_hook_dummy;

#ifdef _M_IA64
#undef _CRT_DEBUGGER_HOOK
#define _CRT_DEBUGGER_HOOK __crt_debugger_hook
#endif  /* _M_IA64 */

__declspec(noinline)
void __cdecl _CRT_DEBUGGER_HOOK(int _Reserved)
{
    /* assign 0 to _debugger_hook_dummy so that the function is not folded in retail */
    (_Reserved);
    _debugger_hook_dummy = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgheap.c ===
/***
*dbgheap.c - Debug CRT Heap Functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines debug versions of heap functions.
*
*******************************************************************************/

#ifdef _DEBUG

#include <windows.h>
#include <winheap.h>
#include <ctype.h>
#include <dbgint.h>
#include <crtdbg.h>
#include <rtcsup.h>
#include <internal.h>
#include <limits.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

#pragma warning(disable:4390)
extern "C" void * __cdecl _heap_alloc_base (size_t size);
extern "C" static void * __cdecl _heap_alloc_dbg_impl(size_t nSize, int nBlockUse, const char * szFileName, int nLine, int * errno_tmp);
/*---------------------------------------------------------------------------
 *
 * Heap management
 *
 --------------------------------------------------------------------------*/

#define IGNORE_REQ  0L              /* Request number for ignore block */
#define IGNORE_LINE 0xFEDCBABC      /* Line number for ignore block */

#define _ALLOCATION_FILE_LINENUM "\nMemory allocated at %hs(%d).\n"

/*
 * Bitfield flag that controls CRT heap behavior --
 * default is to record all allocations (_CRTDBG_ALLOC_MEM_DF)
 * AND check heap consistency on every alloc/dealloc (_CRTDBG_CHECK_ALWAYS_DF)
 */

extern "C" int _crtDbgFlag = _CRTDBG_ALLOC_MEM_DF | _CRTDBG_CHECK_DEFAULT_DF;

/*
 * Size threshold for filling behavior. See _CrtSetDebugFillThreshold.
 */

extern "C" size_t __crtDebugFillThreshold = SIZE_MAX;

extern "C" int __crtDebugCheckCount = FALSE;

/*
 * struct used by _aligned routines as block header.
 */

#define nAlignGapSize sizeof(void *)

typedef struct _AlignMemBlockHdr
{
    void *pHead;
    unsigned char Gap[nAlignGapSize];
} _AlignMemBlockHdr;

#define IS_2_POW_N(x)   (((x)&(x-1)) == 0)

/*
 * Statics governing how often _CrtCheckMemory is called.
 */
static unsigned check_frequency = _CRTDBG_CHECK_DEFAULT_DF >> 16;
static unsigned check_counter;

static long _lRequestCurr = 1;      /* Current request number */

extern "C" _CRTIMP long _crtBreakAlloc = -1L;  /* Break on allocation by request number */

static size_t _lTotalAlloc;         /* Grand total - sum of all allocations */
static size_t _lCurAlloc;           /* Total amount currently allocated */
static size_t _lMaxAlloc;           /* Largest ever allocated at once */

/*
 * The following values are non-zero, constant, odd, large, and atypical
 *      Non-zero values help find bugs assuming zero filled data.
 *      Constant values are good so that memory filling is deterministic
 *          (to help make bugs reproducable).  Of course it is bad if
 *          the constant filling of weird values masks a bug.
 *      Mathematically odd numbers are good for finding bugs assuming a cleared
 *          lower bit.
 *      Large numbers (byte values at least) are less typical, and are good
 *          at finding bad addresses.
 *      Atypical values (i.e. not too often) are good since they typically
 *          cause early detection in code.
 *      For the case of no-man's land and free blocks, if you store to any
 *          of these locations, the memory integrity checker will detect it.
 *
 *      _bAlignLandFill has been changed from 0xBD to 0xED, to ensure that
 *      4 bytes of that (0xEDEDEDED) would give an inaccessible address under 3gb.
 */

static unsigned char _bNoMansLandFill = 0xFD;   /* fill no-man's land with this */
static unsigned char _bAlignLandFill  = 0xED;   /* fill no-man's land for aligned routines */
static unsigned char _bDeadLandFill   = 0xDD;   /* fill free objects with this */
static unsigned char _bCleanLandFill  = 0xCD;   /* fill new objects with this */

static _CrtMemBlockHeader * _pFirstBlock;
static _CrtMemBlockHeader * _pLastBlock;

_CRT_DUMP_CLIENT _pfnDumpClient;

#if _FREE_BLOCK != 0 || _NORMAL_BLOCK != 1 || _CRT_BLOCK != 2 || _IGNORE_BLOCK != 3 || _CLIENT_BLOCK != 4
#error Block numbers have changed !
#endif  /* _FREE_BLOCK != 0 || _NORMAL_BLOCK != 1 || _CRT_BLOCK != 2 || _IGNORE_BLOCK != 3 || _CLIENT_BLOCK != 4 */

static const char * const szBlockUseName[_MAX_BLOCKS] = {
        "Free",
        "Normal",
        "CRT",
        "Ignore",
        "Client",
        };

extern "C" int __cdecl CheckBytes(unsigned char *, unsigned char, size_t);

/***
*void * _malloc_dbg() - Get a block of memory from the debug heap
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the heap and
*       return a pointer to it.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          nSize       - size of block requested
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*
*Exit:
*       Success:  Pointer to memory block
*       Failure:  NULL (or some error value)
*
*Exceptions:
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _malloc_dbg (
        size_t nSize,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
{
        void *res = _nh_malloc_dbg(nSize, _newmode, nBlockUse, szFileName, nLine);
        RTCCALLBACK(_RTC_Allocate_hook, (res, nSize, 0));
        return res;
}

/***
*void * _nh_malloc() - Get a block of memory from the debug heap
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the debug
*       heap and return a pointer to it. Assumes heap already locked.
*
*       If no blocks available, call new handler.
*
*       Allocates 'normal' memory block.
*
*Entry:
*       size_t          nSize       - size of block requested
*       int             nhFlag      - TRUE if new handler function
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" void * __cdecl _nh_malloc (
        size_t nSize,
        int nhFlag
        )
{
        return _nh_malloc_dbg(nSize, nhFlag, _NORMAL_BLOCK, NULL, 0);
}


/***
*void * _nh_malloc_dbg_impl() - Get a block of memory from the debug heap
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the debug
*       heap and return a pointer to it. Assumes heap already locked.
*
*       If no blocks available, call new handler.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          nSize       - size of block requested
*       int             nhFlag      - TRUE if new handler function
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*       int  *          errno_tmp   - pointer of the temporary errno
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" static void * __cdecl _nh_malloc_dbg_impl (
        size_t nSize,
        int nhFlag,
        int nBlockUse,
        const char * szFileName,
        int nLine,
        int * errno_tmp
        )
{
        void * pvBlk;

        for (;;)
        {
            /* do the allocation
             */
            pvBlk = _heap_alloc_dbg_impl(nSize, nBlockUse, szFileName, nLine, errno_tmp);

            if (pvBlk)
            {
                return pvBlk;
            }
            if (nhFlag == 0)
            {
                *errno_tmp = ENOMEM;
                return pvBlk;
            }

            /* call installed new handler */
            if (!_callnewh(nSize))
            {
                *errno_tmp = ENOMEM;
                return NULL;
            }

            /* new handler was successful -- try to allocate again */
        }
}

/***
*void * _nh_malloc_dbg() - Get a block of memory from the debug heap
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the debug
*       heap and return a pointer to it. Assumes heap already locked.
*
*       If no blocks available, call new handler.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          nSize       - size of block requested
*       int             nhFlag      - TRUE if new handler function
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/
extern "C" void * __cdecl _nh_malloc_dbg (
        size_t nSize,
        int nhFlag,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
{
        int errno_tmp = 0;
        void * pvBlk = _nh_malloc_dbg_impl(nSize, nhFlag, nBlockUse, szFileName, nLine, &errno_tmp);

        if ( pvBlk == NULL && errno_tmp != 0 && _errno())
        {
            errno = errno_tmp; // recall, #define errno *_errno()
        }
        return pvBlk;
}

/***
*void * _heap_alloc() - does actual allocation
*
*Purpose:
*       Does heap allocation.
*
*       Allocates 'normal' memory block.
*
*Entry:
*       size_t          nSize       - size of block requested
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" void * __cdecl _heap_alloc(
        size_t nSize
        )
{
        return _heap_alloc_dbg(nSize, _NORMAL_BLOCK, NULL, 0);
}

/***
*void * _heap_alloc_dbg_impl() - does actual allocation
*
*Purpose:
*       Does heap allocation.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          nSize       - size of block requested
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*       int  *          errno_tmp   - pointer of the temporary errno
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" static void * __cdecl _heap_alloc_dbg_impl(
        size_t nSize,
        int nBlockUse,
        const char * szFileName,
        int nLine,
        int * errno_tmp
        )
{
        long lRequest;
        size_t blockSize;
        int fIgnore = FALSE;
        _CrtMemBlockHeader * pHead;
        void *retval=NULL;

        /* lock the heap
         */
        _mlock(_HEAP_LOCK);
        __try {

            /* verify heap before allocation */
            if (check_frequency > 0)
                if (check_counter == (check_frequency - 1))
                {
                    _ASSERTE(_CrtCheckMemory());
                    check_counter = 0;
                }
                else
                    check_counter++;

            lRequest = _lRequestCurr;

            /* break into debugger at specific memory allocation */
            if (_crtBreakAlloc != -1L && lRequest == _crtBreakAlloc)
                _CrtDbgBreak();

            /* forced failure */
            if ((_pfnAllocHook) && !(*_pfnAllocHook)(_HOOK_ALLOC, NULL, nSize, nBlockUse, lRequest, (const unsigned char *)szFileName, nLine))
            {
                if (szFileName)
                    _RPT2(_CRT_WARN, "Client hook allocation failure at file %hs line %d.\n",
                        szFileName, nLine);
                else
                    _RPT0(_CRT_WARN, "Client hook allocation failure.\n");
            }
            else
            {
                /* cannot ignore CRT allocations */
                if (_BLOCK_TYPE(nBlockUse) != _CRT_BLOCK &&
                    !(_crtDbgFlag & _CRTDBG_ALLOC_MEM_DF))
                    fIgnore = TRUE;

                /* Diagnostic memory allocation from this point on */

                if (nSize > (size_t)(_HEAP_MAXREQ - nNoMansLandSize - sizeof(_CrtMemBlockHeader)))
                {
                    _RPT1(_CRT_ERROR, "Invalid allocation size: %Iu bytes.\n", nSize);
                    *errno_tmp = ENOMEM;
                }
                else
                {
                    if (!_BLOCK_TYPE_IS_VALID(nBlockUse))
                    {
                        _RPT0(_CRT_ERROR, "Error: memory allocation: bad memory block type.\n");
                    }

                    blockSize = sizeof(_CrtMemBlockHeader) + nSize + nNoMansLandSize;

#ifndef WINHEAP
                    /* round requested size */
                    blockSize = _ROUND2(blockSize, _GRANULARITY);
#endif  /* WINHEAP */

                    RTCCALLBACK(_RTC_FuncCheckSet_hook,(0));
                    pHead = (_CrtMemBlockHeader *)_heap_alloc_base(blockSize);

                    if (pHead == NULL)
                    {
                        *errno_tmp = ENOMEM;
                        RTCCALLBACK(_RTC_FuncCheckSet_hook,(1));
                    }
                    else
                    {

                        /* commit allocation */
                        ++_lRequestCurr;

                        if (fIgnore)
                        {
                            pHead->pBlockHeaderNext = NULL;
                            pHead->pBlockHeaderPrev = NULL;
                            pHead->szFileName = NULL;
                            pHead->nLine = IGNORE_LINE;
                            pHead->nDataSize = nSize;
                            pHead->nBlockUse = _IGNORE_BLOCK;
                            pHead->lRequest = IGNORE_REQ;
                        }
                        else {
                            /* keep track of total amount of memory allocated */
                            if (SIZE_MAX - _lTotalAlloc > nSize)
                            {
                                _lTotalAlloc += nSize;
                            }
                            else
                            {
                                _lTotalAlloc = SIZE_MAX;
                            }
                            _lCurAlloc += nSize;

                            if (_lCurAlloc > _lMaxAlloc)
                            _lMaxAlloc = _lCurAlloc;

                            if (_pFirstBlock)
                                _pFirstBlock->pBlockHeaderPrev = pHead;
                            else
                                _pLastBlock = pHead;

                            pHead->pBlockHeaderNext = _pFirstBlock;
                            pHead->pBlockHeaderPrev = NULL;
                            pHead->szFileName = (char *)szFileName;
                            pHead->nLine = nLine;
                            pHead->nDataSize = nSize;
                            pHead->nBlockUse = nBlockUse;
                            pHead->lRequest = lRequest;

                            /* link blocks together */
                            _pFirstBlock = pHead;
                        }

                        /* fill in gap before and after real block */
                        memset((void *)pHead->gap, _bNoMansLandFill, nNoMansLandSize);
                        memset((void *)(pbData(pHead) + nSize), _bNoMansLandFill, nNoMansLandSize);

                        /* fill data with silly value (but non-zero) */
                        memset((void *)pbData(pHead), _bCleanLandFill, nSize);

                        RTCCALLBACK(_RTC_FuncCheckSet_hook,(1));

                        retval=(void *)pbData(pHead);
                    }
                }
            }

        }
        __finally {
            /* unlock the heap
             */
            _munlock(_HEAP_LOCK);
        }
        return retval;
}

/***
*void * _heap_alloc_dbg() - does actual allocation
*
*Purpose:
*       Does heap allocation.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          nSize       - size of block requested
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" void * __cdecl _heap_alloc_dbg(
        size_t nSize,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
{
        int errno_tmp = 0;
        void * retval = _heap_alloc_dbg_impl(nSize, nBlockUse, szFileName, nLine, &errno_tmp);

        if ( retval == NULL && errno_tmp != 0 && _errno())
        {
            errno = errno_tmp; // recall, #define errno *_errno()
        }
        return retval;
}

/***
*void * _calloc_dbg_impl() - Get a block of memory from the debug heap, init to 0
*                    - with info
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the debug
*       heap and return a pointer to it.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          nNum        - number of elements in the array
*       size_t          nSize       - size of each element
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*       int  *          errno_tmp   - pointer of the temporary errno
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" void * __cdecl _calloc_dbg_impl(
        size_t nNum,
        size_t nSize,
        int nBlockUse,
        const char * szFileName,
        int nLine,
        int * errno_tmp
        )
{
        void * pvBlk;

        /* ensure that (nSize * nNum) does not overflow */
        if (nNum > 0)
        {
            _VALIDATE_RETURN((_HEAP_MAXREQ / nNum) >= nSize, ENOMEM, NULL);
        }

        nSize *= nNum;

        /*
         * try to malloc the requested space
         */

        pvBlk = _nh_malloc_dbg_impl(nSize, _newmode, nBlockUse, szFileName, nLine, errno_tmp);

        /*
         * If malloc() succeeded, initialize the allocated space to zeros.
         * Note that unlike _calloc_base, exactly nNum bytes are set to zero.
         */

        if ( pvBlk != NULL )
        {
            memset(pvBlk, 0, nSize);
        }

        RTCCALLBACK(_RTC_Allocate_hook, (pvBlk, nSize, 0));

        return(pvBlk);
}

/***
*void * _calloc_dbg() - Get a block of memory from the debug heap, init to 0
*                    - with info
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the debug
*       heap and return a pointer to it.
*
*       Allocates any type of supported memory block.
*
*Entry:
*       size_t          nNum        - number of elements in the array
*       size_t          nSize       - size of each element
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _calloc_dbg(
        size_t nNum,
        size_t nSize,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
{
        int errno_tmp = 0;
        void * pvBlk = _calloc_dbg_impl(nNum, nSize, nBlockUse, szFileName, nLine, &errno_tmp);

        if ( pvBlk == NULL && errno_tmp != 0 && _errno())
        {
            errno = errno_tmp; // recall, #define errno *_errno()
        }
        return pvBlk;
}

/***
*static void * realloc_help() - does all the work for _realloc and _expand
*
*Purpose:
*       Helper function for _realloc and _expand.
*
*Entry:
*       void *          pUserData   - pointer previously allocated block
*       size_t *        pnNewSize   - requested size for the re-allocated block
*                                     changed to actual size during call
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*       int             fRealloc    - TRUE when _realloc, FALSE when _expand
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" static void * __cdecl realloc_help(
        void * pUserData,
        size_t * pnNewSize,
        int nBlockUse,
        const char * szFileName,
        int nLine,
        int fRealloc
        )
{
        long lRequest;
        int fIgnore = FALSE;
        unsigned char *pUserBlock;
        _CrtMemBlockHeader * pOldBlock;
        _CrtMemBlockHeader * pNewBlock;
        size_t nNewSize = *pnNewSize;

        /*
         * ANSI: realloc(NULL, newsize) is equivalent to malloc(newsize)
         */
        if (pUserData == NULL)
        {
            return _malloc_dbg(nNewSize, nBlockUse, szFileName, nLine);
        }

        /*
         * ANSI: realloc(pUserData, 0) is equivalent to free(pUserData)
         * (except that NULL is returned)
         */
        if (fRealloc && nNewSize == 0)
        {
            _free_dbg(pUserData, nBlockUse);
            return NULL;
        }

        /* verify heap before re-allocation */
        if (check_frequency > 0)
            if (check_counter == (check_frequency - 1))
            {
                _ASSERTE(_CrtCheckMemory());
                check_counter = 0;
            }
            else
                check_counter++;

        lRequest = _lRequestCurr;

        if (_crtBreakAlloc != -1L && lRequest == _crtBreakAlloc)
            _CrtDbgBreak(); /* break into debugger at specific memory leak */

        /* forced failure */
        if ((_pfnAllocHook) && !(*_pfnAllocHook)(_HOOK_REALLOC, pUserData, nNewSize, nBlockUse, lRequest, (const unsigned char *)szFileName, nLine))
        {
            if (szFileName)
                _RPT2(_CRT_WARN, "Client hook re-allocation failure at file %hs line %d.\n",
                    szFileName, nLine);
            else
                _RPT0(_CRT_WARN, "Client hook re-allocation failure.\n");

            return NULL;
        }

        /* Diagnostic memory allocation from this point on */

        if (nNewSize > (size_t)(_HEAP_MAXREQ - nNoMansLandSize - sizeof(_CrtMemBlockHeader)))
        {
            if (szFileName)
            {
                _RPT3(_CRT_ERROR,
                    "Invalid allocation size: %Iu bytes.\n" _ALLOCATION_FILE_LINENUM,
                    nNewSize, szFileName, nLine);
            }
            else
            {
                _RPT1(_CRT_ERROR, "Invalid allocation size: %Iu bytes.\n", nNewSize);
            }
            errno = ENOMEM;
            return NULL;
        }

        if (nBlockUse != _NORMAL_BLOCK
            && _BLOCK_TYPE(nBlockUse) != _CLIENT_BLOCK
            && _BLOCK_TYPE(nBlockUse) != _CRT_BLOCK)
        {
            if (szFileName)
            {
                _RPT2(_CRT_ERROR,
                    "Error: memory allocation: bad memory block type.\n" _ALLOCATION_FILE_LINENUM,
                    szFileName, nLine);
            }
            else
            {
                _RPT0(_CRT_ERROR, "Error: memory allocation: bad memory block type.\n");
            }
        } else
        {
            if ( CheckBytes((unsigned char*)((uintptr_t)pUserData & ~(sizeof(uintptr_t) -1)) -nAlignGapSize,_bAlignLandFill, nAlignGapSize))
            {
                // We don't know (yet) where (file, linenum) pUserData was allocated
                _RPT1(_CRT_ERROR, "The Block at 0x%p was allocated by aligned routines, use _aligned_realloc()", pUserData);
                errno = EINVAL;
                return NULL;
            }
        }

        /*
         * If this ASSERT fails, a bad pointer has been passed in. It may be
         * totally bogus, or it may have been allocated from another heap.
         * The pointer MUST come from the 'local' heap.
         */
        _ASSERTE(_CrtIsValidHeapPointer(pUserData));

        /* get a pointer to memory block header */
        pOldBlock = pHdr(pUserData);

        if (pOldBlock->nBlockUse == _IGNORE_BLOCK)
            fIgnore = TRUE;

        if (fIgnore)
        {
            _ASSERTE(pOldBlock->nLine == IGNORE_LINE && pOldBlock->lRequest == IGNORE_REQ);
        }
        else {
            /* Error if freeing incorrect memory type */
            /* CRT blocks can be treated as NORMAL blocks */
            if (_BLOCK_TYPE(pOldBlock->nBlockUse) == _CRT_BLOCK && _BLOCK_TYPE(nBlockUse) == _NORMAL_BLOCK)
                nBlockUse = _CRT_BLOCK;
/* The following assertion was prone to false positives - JWM                      */
/*            _ASSERTE(_BLOCK_TYPE(pOldBlock->nBlockUse)==_BLOCK_TYPE(nBlockUse)); */

            /* checking the size of previous block */
            if (_lTotalAlloc < pOldBlock->nDataSize)
            {
                _RPT1(_CRT_ERROR, "Error: possible heap corruption at or near 0x%p", pUserData);
                errno = EINVAL;
                return NULL;
            }
        }

        /*
         * note that all header values will remain valid
         * and min(nNewSize,nOldSize) bytes of data will also remain valid
         */
        RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));
        RTCCALLBACK(_RTC_FuncCheckSet_hook,(0));

        if (fRealloc)
        {
            if (NULL == (pNewBlock = (_CrtMemBlockHeader *)_realloc_base(pOldBlock,
                sizeof(_CrtMemBlockHeader) + nNewSize + nNoMansLandSize)))
            {
                RTCCALLBACK(_RTC_FuncCheckSet_hook,(1));
                return NULL;
            }
        }
        else {
            if (NULL == (pNewBlock = (_CrtMemBlockHeader *)_expand_base(pOldBlock,
                sizeof(_CrtMemBlockHeader) + nNewSize + nNoMansLandSize)))
            {
                RTCCALLBACK(_RTC_FuncCheckSet_hook,(1));
                return NULL;
            }
#ifdef _WIN64
            /* _WIN64, because of the LFH, doesn't try to resize if the
               block is shrinking. It just returns the original block.
               Make sure our own header tracks that properly. */
            nNewSize = *pnNewSize = (size_t)HeapSize(_crtheap, 0, pNewBlock)
                - sizeof(_CrtMemBlockHeader) - nNoMansLandSize;

#endif  /* _WIN64 */

        }

        /* realloc_base() or expand_base() should keep the same memory content */
        __analysis_assume(pNewBlock->nDataSize == pOldBlock->nDataSize);

        /* commit allocation */
        ++_lRequestCurr;

        if (!fIgnore)
        {
            /* keep track of total amount of memory allocated */
            if (_lTotalAlloc < SIZE_MAX)
            {
                _lTotalAlloc -= pNewBlock->nDataSize;
                if (SIZE_MAX - _lTotalAlloc > nNewSize)
                {
                    _lTotalAlloc += nNewSize;
                }
                else
                {
                    _lTotalAlloc = SIZE_MAX;
                }
            }

            _lCurAlloc -= pNewBlock->nDataSize;
            _lCurAlloc += nNewSize;

            if (_lCurAlloc > _lMaxAlloc)
                _lMaxAlloc = _lCurAlloc;
        }

        // Free this thing from RTC - it will be reallocated a bit later (inside realloc_dbg/expand_dbg)
        RTCCALLBACK(_RTC_Free_hook, (pNewBlock, 0));

        pUserBlock = pbData(pNewBlock);

        /* if the block grew, put in special value */
        if (nNewSize > pNewBlock->nDataSize)
            memset(pUserBlock + pNewBlock->nDataSize, _bCleanLandFill,
                nNewSize - pNewBlock->nDataSize);

        /* fill in gap after real block */
        memset(pUserBlock + nNewSize, _bNoMansLandFill, nNoMansLandSize);

        if (!fIgnore)
        {
            pNewBlock->szFileName = (char *)szFileName;
            pNewBlock->nLine = nLine;
            pNewBlock->lRequest = lRequest;
        }

        pNewBlock->nDataSize = nNewSize;

        _ASSERTE(fRealloc || (!fRealloc && pNewBlock == pOldBlock));

        RTCCALLBACK(_RTC_FuncCheckSet_hook,(1));

        /* if block did not move or ignored, we are done */
        if (pNewBlock == pOldBlock || fIgnore)
            return (void *)pUserBlock;

        /* must remove old memory from dbg heap list */
        /* note that new block header pointers still valid */
        if (pNewBlock->pBlockHeaderNext)
        {
            pNewBlock->pBlockHeaderNext->pBlockHeaderPrev
                = pNewBlock->pBlockHeaderPrev;
        }
        else
        {
            _ASSERTE(_pLastBlock == pOldBlock);
            _pLastBlock = pNewBlock->pBlockHeaderPrev;
        }

        if (pNewBlock->pBlockHeaderPrev)
        {
            pNewBlock->pBlockHeaderPrev->pBlockHeaderNext
                = pNewBlock->pBlockHeaderNext;
        }
        else
        {
            _ASSERTE(_pFirstBlock == pOldBlock);
            _pFirstBlock = pNewBlock->pBlockHeaderNext;
        }

        /* put new memory into list */
        if (_pFirstBlock)
            _pFirstBlock->pBlockHeaderPrev = pNewBlock;
        else
            _pLastBlock = pNewBlock;

        pNewBlock->pBlockHeaderNext = _pFirstBlock;
        pNewBlock->pBlockHeaderPrev = NULL;

        /* link blocks together */
        _pFirstBlock = pNewBlock;

        return (void *)pUserBlock;
}


/***
*void * _recalloc() - reallocate items in the heap
*
*Purpose:
*       Re-allocates and initializes with 0 a block in the heap to nNewSize*count bytes.
*       nNewSize may be either greater or less than the original size of the block.
*       The re-allocation may result in moving the block as well as changing
*       the size. If the block is moved, the contents of the original block
*       are copied over.
*
*       Re-allocates 'normal' memory block.
*
*Entry:
*       void *          pUserData   - pointer to previously allocated block
*       size_t          count       - count of items
*       size_t          nNewSize    - requested size for the items
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _recalloc
(
    void * memblock,
    size_t count,
    size_t size
)
{
    void * res = _recalloc_dbg(memblock, count, size, _NORMAL_BLOCK, NULL, 0);

    return res;
}

/***
*void * _realloc_dbg() - reallocate a block of memory in the heap
*                     - with info
*
*Purpose:
*       Re-allocates a block in the heap to nNewSize bytes. nNewSize may be
*       either greater or less than the original size of the block. The
*       re-allocation may result in moving the block as well as changing
*       the size. If the block is moved, the contents of the original block
*       are copied over.
*
*       Re-allocates any type of supported memory block.
*
*Entry:
*       void *          pUserData   - pointer previously allocated block
*       size_t          nNewSize    - requested size for the re-allocated block
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _realloc_dbg(
        void * pUserData,
        size_t nNewSize,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
{
        void * pvBlk;

        _mlock(_HEAP_LOCK);         /* block other threads */
        __try {

        /* allocate the block
         */
        pvBlk = realloc_help(pUserData,
                             &nNewSize,
                             nBlockUse,
                             szFileName,
                             nLine,
                             TRUE);

        }
        __finally {
            _munlock(_HEAP_LOCK);   /* release other threads */
        }
        if (pvBlk)
        {
            RTCCALLBACK(_RTC_Allocate_hook, (pvBlk, nNewSize, 0));
        }
        return pvBlk;
}

/***
*void * _recalloc_dbg() - reallocate items in the heap with info
*
*Purpose:
*       Re-allocates and initializez with 0 a block in the heap to nNewSize*count bytes.
*       nNewSize may be either greater or less than the original size of the block.
*       The re-allocation may result in moving the block as well as changing
*       the size. If the block is moved, the contents of the original block
*       are copied over.
*
*       Re-allocates any type of supported memory block.
*
*Entry:
*       void *          pUserData   - pointer previously allocated block
*       size_t          count       - count of items
*       size_t          nNewSize    - requested size for the items
*       int             nBlockUse   - block type
*       char *          szFileName  - file name
*       int             nLine       - line number
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _recalloc_dbg
(
    void * memblock,
    size_t count,
    size_t size,
    int nBlockUse,
    const char * szFileName,
    int nLine
)
{
    size_t  size_orig = 0, old_size = 0;
    void * retp = NULL;

    /* ensure that (size * count) does not overflow */
    if (count > 0)
    {
        _VALIDATE_RETURN((_HEAP_MAXREQ / count) >= size, ENOMEM, NULL);
    }
    size_orig = size * count;

    if (memblock != NULL)
    {
        old_size = _msize((void*)memblock);
    }

    retp = _realloc_dbg(memblock, size_orig, nBlockUse, szFileName, nLine);

    if (retp != NULL && old_size < size_orig)
    {
        memset ((char*)retp + old_size, 0, size_orig - old_size);
    }
    return retp;
}


/***
*void * _expand() - expand/contract a block of memory in the heap
*
*Purpose:
*       Resizes a block in the heap to newsize bytes. newsize may be either
*       greater (expansion) or less (contraction) than the original size of
*       the block. The block is NOT moved. In the case of expansion, if the
*       block cannot be expanded to newsize bytes, it is expanded as much as
*       possible.
*
*       Re-allocates 'normal' memory block.
*
*Entry:
*       void * pUserData    - pointer to block in the heap previously allocated
*              by a call to malloc(), realloc() or _expand().
*
*       size_t nNewSize    - requested size for the resized block
*
*Exit:
*       Success:  Pointer to the resized memory block (i.e., pUserData)
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*       If pUserData does not point to a valid allocation block in the heap,
*       _expand() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _expand(
        void * pUserData,
        size_t nNewSize
        )
{
        void *res = _expand_dbg(pUserData, nNewSize, _NORMAL_BLOCK, NULL, 0);

        return res;
}


/***
*void * _expand() - expand/contract a block of memory in the heap
*
*Purpose:
*       Resizes a block in the heap to newsize bytes. newsize may be either
*       greater (expansion) or less (contraction) than the original size of
*       the block. The block is NOT moved. In the case of expansion, if the
*       block cannot be expanded to newsize bytes, it is expanded as much as
*       possible.
*
*       Re-allocates any type of supported memory block.
*
*Entry:
*       void * pUserData   - pointer to block in the heap previously allocated
*              by a call to malloc(), realloc() or _expand().
*
*       size_t nNewSize    - requested size for the resized block
*
*Exit:
*       Success:  Pointer to the resized memory block (i.e., pUserData)
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*       If pUserData does not point to a valid allocation block in the heap,
*       _expand() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _expand_dbg(
        void * pUserData,
        size_t nNewSize,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
{
        void * pvBlk;

        /* validation section */
        _VALIDATE_RETURN(pUserData != NULL, EINVAL, NULL);
        if (nNewSize > (size_t)(_HEAP_MAXREQ - nNoMansLandSize - sizeof(_CrtMemBlockHeader))) {
            errno = ENOMEM;
            return NULL;
        }

        _mlock(_HEAP_LOCK);         /* block other threads */
        __try {

        /* allocate the block
         */
        pvBlk = realloc_help(pUserData,
                             &nNewSize,
                             nBlockUse,
                             szFileName,
                             nLine,
                             FALSE);

        }
        __finally {
            _munlock(_HEAP_LOCK);   /* release other threads */
        }
        if (pvBlk)
        {
            RTCCALLBACK(_RTC_Allocate_hook, (pUserData, nNewSize, 0));
        }
        return pvBlk;
}


extern "C" void __cdecl _free_nolock(
        void * pUserData
        )
{
        _free_dbg_nolock(pUserData, _NORMAL_BLOCK);
}



/***
*void _free_dbg() - free a block in the debug heap
*
*Purpose:
*       Frees any type of supported block.
*
*Entry:
*       void * pUserData    - pointer to a (user portion) of memory block in the
*                             debug heap
*       int nBlockUse       - block type
*
*Return:
*       <void>
*
*******************************************************************************/


extern "C" _CRTIMP void __cdecl _free_dbg(
        void * pUserData,
        int nBlockUse
        )
{
        /* lock the heap
         */
        _mlock(_HEAP_LOCK);

        __try {
            /* allocate the block
             */
            _free_dbg_nolock(pUserData, nBlockUse);
        }
        __finally {
            /* unlock the heap
             */
            _munlock(_HEAP_LOCK);
        }
}

extern "C" void __cdecl _free_dbg_nolock(


        void * pUserData,
        int nBlockUse
        )
{
        _CrtMemBlockHeader * pHead;

        RTCCALLBACK(_RTC_Free_hook, (pUserData, 0));

        /* verify heap before freeing */

        if (check_frequency > 0)
            if (check_counter == (check_frequency - 1))
            {
                _ASSERTE(_CrtCheckMemory());
                check_counter = 0;
            }
            else
                check_counter++;

        if (pUserData == NULL)
            return;

        /* check if the heap was not allocated by _aligned routines */
        if ( nBlockUse == _NORMAL_BLOCK)
        {
            if ( CheckBytes((unsigned char*)((uintptr_t)pUserData & ~(sizeof(uintptr_t) -1)) -nAlignGapSize,_bAlignLandFill, nAlignGapSize))
            {
                // We don't know (yet) where (file, linenum) pUserData was allocated
                _RPT1(_CRT_ERROR, "The Block at 0x%p was allocated by aligned routines, use _aligned_free()", pUserData);
                errno = EINVAL;
                return;
            }
        }

        /* forced failure */
        if ((_pfnAllocHook) && !(*_pfnAllocHook)(_HOOK_FREE, pUserData, 0, nBlockUse, 0L, NULL, 0))
        {
            _RPT0(_CRT_WARN, "Client hook free failure.\n");

            return;
        }

        /*
         * If this ASSERT fails, a bad pointer has been passed in. It may be
         * totally bogus, or it may have been allocated from another heap.
         * The pointer MUST come from the 'local' heap.
         */
        _ASSERTE(_CrtIsValidHeapPointer(pUserData));

        /* get a pointer to memory block header */
        pHead = pHdr(pUserData);

        /* verify block type */
        _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead->nBlockUse));

        /* if we didn't already check entire heap, at least check this object */
        if (!(_crtDbgFlag & _CRTDBG_CHECK_ALWAYS_DF))
        {
            /* check no-mans-land gaps */
            if (!CheckBytes(pHead->gap, _bNoMansLandFill, nNoMansLandSize))
            {
                if (pHead->szFileName)
                {
                    _RPT5(_CRT_ERROR, "HEAP CORRUPTION DETECTED: before %hs block (#%d) at 0x%p.\n"
                        "CRT detected that the application wrote to memory before start of heap buffer.\n"
                        _ALLOCATION_FILE_LINENUM,
                        szBlockUseName[_BLOCK_TYPE(pHead->nBlockUse)],
                        pHead->lRequest,
                        (BYTE *) pbData(pHead),
                        pHead->szFileName,
                        pHead->nLine);
                }
                else
                {
                    _RPT3(_CRT_ERROR, "HEAP CORRUPTION DETECTED: before %hs block (#%d) at 0x%p.\n"
                        "CRT detected that the application wrote to memory before start of heap buffer.\n",
                        szBlockUseName[_BLOCK_TYPE(pHead->nBlockUse)],
                        pHead->lRequest,
                        (BYTE *) pbData(pHead));
                }
            }

            if (!CheckBytes(pbData(pHead) + pHead->nDataSize, _bNoMansLandFill, nNoMansLandSize))
            {
                if (pHead->szFileName)
                {
                    _RPT5(_CRT_ERROR, "HEAP CORRUPTION DETECTED: after %hs block (#%d) at 0x%p.\n"
                        "CRT detected that the application wrote to memory after end of heap buffer.\n"
                        _ALLOCATION_FILE_LINENUM,
                        szBlockUseName[_BLOCK_TYPE(pHead->nBlockUse)],
                        pHead->lRequest,
                        (BYTE *) pbData(pHead),
                        pHead->szFileName,
                        pHead->nLine);
                }
                else
                {
                    _RPT3(_CRT_ERROR, "HEAP CORRUPTION DETECTED: after %hs block (#%d) at 0x%p.\n"
                        "CRT detected that the application wrote to memory after end of heap buffer.\n",
                        szBlockUseName[_BLOCK_TYPE(pHead->nBlockUse)],
                        pHead->lRequest,
                        (BYTE *) pbData(pHead));
                }
            }
        }

        RTCCALLBACK(_RTC_FuncCheckSet_hook,(0));

        if (pHead->nBlockUse == _IGNORE_BLOCK)
        {
            _ASSERTE(pHead->nLine == IGNORE_LINE && pHead->lRequest == IGNORE_REQ);
            /* fill the entire block including header with dead-land-fill */
            memset(pHead, _bDeadLandFill,
                sizeof(_CrtMemBlockHeader) + pHead->nDataSize + nNoMansLandSize);
            _free_base(pHead);
            RTCCALLBACK(_RTC_FuncCheckSet_hook,(1));
            return;
        }

        /* CRT blocks can be freed as NORMAL blocks */
        if (pHead->nBlockUse == _CRT_BLOCK && nBlockUse == _NORMAL_BLOCK)
            nBlockUse = _CRT_BLOCK;

        /* Error if freeing incorrect memory type */
        _ASSERTE(pHead->nBlockUse == nBlockUse);

        /* keep track of total amount of memory allocated */
        _lCurAlloc -= pHead->nDataSize;

        /* optionally reclaim memory */
        if (!(_crtDbgFlag & _CRTDBG_DELAY_FREE_MEM_DF))
        {
            /* remove from the linked list */
            if (pHead->pBlockHeaderNext)
            {
                pHead->pBlockHeaderNext->pBlockHeaderPrev = pHead->pBlockHeaderPrev;
            }
            else
            {
                _ASSERTE(_pLastBlock == pHead);
                _pLastBlock = pHead->pBlockHeaderPrev;
            }

            if (pHead->pBlockHeaderPrev)
            {
                pHead->pBlockHeaderPrev->pBlockHeaderNext = pHead->pBlockHeaderNext;
            }
            else
            {
                _ASSERTE(_pFirstBlock == pHead);
                _pFirstBlock = pHead->pBlockHeaderNext;
            }

            /* fill the entire block including header with dead-land-fill */
            memset(pHead, _bDeadLandFill,
                sizeof(_CrtMemBlockHeader) + pHead->nDataSize + nNoMansLandSize);
            _free_base(pHead);
        }
        else
        {
            pHead->nBlockUse = _FREE_BLOCK;

            /* keep memory around as dead space */
            memset(pbData(pHead), _bDeadLandFill, pHead->nDataSize);
        }
        RTCCALLBACK(_RTC_FuncCheckSet_hook,(1));
}

/***
*size_t _msize() - calculate the size of specified block in the heap
*
*Purpose:
*       Calculates the size of memory block (in the heap) pointed to by
*       pUserData.
*
*       For 'normal' memory block.
*
*Entry:
*       void * pUserData - pointer to a memory block in the heap
*
*Return:
*       size of the block
*
*******************************************************************************/

extern "C" _CRTIMP size_t __cdecl _msize (
        void * pUserData
        )
{
        return _msize_dbg(pUserData, _NORMAL_BLOCK);
}


/***
*size_t _msize_dbg() - calculate the size of specified block in the heap
*
*Purpose:
*       Calculates the size of memory block (in the heap) pointed to by
*       pUserData.
*
*Entry:
*       void * pUserData    - pointer to a (user portion) of memory block in the
*                             debug heap
*       int nBlockUse       - block type
*
*       For any type of supported block.
*
*Return:
*       size of the block
*
*******************************************************************************/

extern "C" _CRTIMP size_t __cdecl _msize_dbg (
        void * pUserData,
        int nBlockUse
        )
{
        size_t nSize;
        _CrtMemBlockHeader * pHead;

        /* validation section */
        _VALIDATE_RETURN(pUserData != NULL, EINVAL, -1);

        /* verify heap before getting size */
        if (check_frequency > 0)
            if (check_counter == (check_frequency - 1))
            {
                _ASSERTE(_CrtCheckMemory());
                check_counter = 0;
            }
            else
                check_counter++;

        _mlock(_HEAP_LOCK);         /* block other threads */
        __try {

        /*
         * If this ASSERT fails, a bad pointer has been passed in. It may be
         * totally bogus, or it may have been allocated from another heap.
         * The pointer MUST come from the 'local' heap.
         */
        _ASSERTE(_CrtIsValidHeapPointer(pUserData));

        /* get a pointer to memory block header */
        pHead = pHdr(pUserData);

         /* verify block type */
        _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead->nBlockUse));

        /* CRT blocks can be treated as NORMAL blocks */
        if (pHead->nBlockUse == _CRT_BLOCK && nBlockUse == _NORMAL_BLOCK)
            nBlockUse = _CRT_BLOCK;

/* The following assertion was prone to false positives - JWM */
/*        if (pHead->nBlockUse != _IGNORE_BLOCK)              */
/*            _ASSERTE(pHead->nBlockUse == nBlockUse);        */

        nSize = pHead->nDataSize;

        }
        __finally {
            _munlock(_HEAP_LOCK);   /* release other threads */
        }

        return nSize;
}

/***
*long _CrtSetBreakAlloc() - set allocation on which to break
*
*Purpose:
*       set allocation on which to break
*
*Entry:
*       long lBreakAlloc
*
*Exit:
*       return previous break number
*
*Exceptions:
*
*******************************************************************************/
extern "C" _CRTIMP long __cdecl _CrtSetBreakAlloc(
        long lNewBreakAlloc
        )
{
        long lOldBreakAlloc = _crtBreakAlloc;
        _crtBreakAlloc = lNewBreakAlloc;
        return lOldBreakAlloc;
}

/***
*void _CrtSetDbgBlockType() - change memory block type
*
*Purpose:
*       change memory block type
*
*Entry:
*       void * pUserData    - pointer to a (user portion) of memory block in the
*                             debug heap
*       int nBlockUse       - block type
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
extern "C" _CRTIMP void __cdecl _CrtSetDbgBlockType(
        void * pUserData,
        int nBlockUse
        )
{
        _CrtMemBlockHeader * pHead;

        _mlock(_HEAP_LOCK);         /* block other threads */
        __try {

        /* If from local heap, then change block type. */
        if (_CrtIsValidHeapPointer(pUserData))
        {
            /* get a pointer to memory block header */
            pHead = pHdr(pUserData);

            /* verify block type */
            _ASSERTE(_BLOCK_TYPE_IS_VALID(pHead->nBlockUse));

            pHead->nBlockUse = nBlockUse;
        }

        }
        __finally {
            _munlock(_HEAP_LOCK);   /* release other threads */
        }

        return;
}

/*---------------------------------------------------------------------------
 *
 * Client-defined allocation hook
 *
 --------------------------------------------------------------------------*/

/***
*_CRT_ALLOC_HOOK _CrtSetAllocHook() - set client allocation hook
*
*Purpose:
*       set client allocation hook
*
*Entry:
*       _CRT_ALLOC_HOOK pfnNewHook - new allocation hook
*
*Exit:
*       return previous hook
*
*Exceptions:
*       None
*
*******************************************************************************/
extern "C" _CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK pfnNewHook
        )
{
        _CRT_ALLOC_HOOK pfnOldHook = _pfnAllocHook;

        _pfnAllocHook = pfnNewHook;
        return pfnOldHook;
}

/***
*_CRT_ALLOC_HOOK _CrtGetAllocHook() - get client allocation hook
*
*Purpose:
*       get client allocation hook
*
*Entry:
*
*Exit:
*       return current hook
*
*Exceptions:
*
*******************************************************************************/
extern "C" _CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook
(
        void
)
{
        return _pfnAllocHook;
}

/*---------------------------------------------------------------------------
 *
 * Memory management
 *
 --------------------------------------------------------------------------*/

/***
*static int CheckBytes() - verify byte range set to proper value
*
*Purpose:
*       verify byte range set to proper value
*
*Entry:
*       unsigned char *pb       - pointer to start of byte range
*       unsigned char bCheck    - value byte range should be set to
*       size_t nSize            - size of byte range to be checked
*
*Return:
*       TRUE - if all bytes in range equal bcheck
*       FALSE otherwise
*
*******************************************************************************/
extern "C" static int __cdecl CheckBytes(
        unsigned char * pb,
        unsigned char bCheck,
        size_t nSize
        )
{
        int bOkay = TRUE;
        while (nSize--)
        {
            if (*pb++ != bCheck)
            {
/* Internal error report is just noise; calling functions all report results - JWM */
/*                _RPT3(_CRT_WARN, "memory check error at 0x%p = 0x%02X, should be 0x%02X.\n", */
/*                    (BYTE *)(pb-1),*(pb-1), bCheck); */
                bOkay = FALSE;
            }
        }
        return bOkay;
}


/***
*int _CrtCheckMemory() - check heap integrity
*
*Purpose:
*       Confirm integrity of debug heap. Call _heapchk to validate underlying
*       heap.
*
*Entry:
*       void
*
*Return:
*       TRUE - if debug and underlying heap appear valid
*       FALSE otherwise
*
*******************************************************************************/
extern "C" _CRTIMP int __cdecl _CrtCheckMemory(
        void
        )
{
        int allOkay;
        int nHeapCheck;
        _CrtMemBlockHeader * pHead;

        if (!(_crtDbgFlag & _CRTDBG_ALLOC_MEM_DF))
            return TRUE;        /* can't do any checking */

        _mlock(_HEAP_LOCK);  /* block other threads */
        __try {

        /* check underlying heap */

        nHeapCheck = _heapchk();
        if (nHeapCheck != _HEAPEMPTY && nHeapCheck != _HEAPOK)
        {
            switch (nHeapCheck)
            {
            case _HEAPBADBEGIN:
                _RPT0(_CRT_WARN, "_heapchk fails with _HEAPBADBEGIN.\n");
                break;
            case _HEAPBADNODE:
                _RPT0(_CRT_WARN, "_heapchk fails with _HEAPBADNODE.\n");
                break;
            case _HEAPEND:
                _RPT0(_CRT_WARN, "_heapchk fails with _HEAPBADEND.\n");
                break;
            case _HEAPBADPTR:
                _RPT0(_CRT_WARN, "_heapchk fails with _HEAPBADPTR.\n");
                break;
            default:
                _RPT0(_CRT_WARN, "_heapchk fails with unknown return value!\n");
                break;
            }
            allOkay = FALSE;
        }
        else
        {
            allOkay = TRUE;

            /* check all allocated blocks */

            for (pHead = _pFirstBlock; pHead != NULL; pHead = pHead->pBlockHeaderNext)
            {
                int okay = TRUE;       /* this block okay ? */
                unsigned char * blockUse;

                if (_BLOCK_TYPE_IS_VALID(pHead->nBlockUse))
                    blockUse = (unsigned char *)szBlockUseName[_BLOCK_TYPE(pHead->nBlockUse)];
                else
                    blockUse = (unsigned char *)"DAMAGED";


                /* check no-mans-land gaps */
                if (!CheckBytes(pHead->gap, _bNoMansLandFill, nNoMansLandSize))
                {
                    if (pHead->szFileName)
                    {
                        _RPT5(_CRT_WARN, "HEAP CORRUPTION DETECTED: before %hs block (#%d) at 0x%p.\n"
                            "CRT detected that the application wrote to memory before start of heap buffer.\n"
                            _ALLOCATION_FILE_LINENUM,
                            blockUse,
                            pHead->lRequest,
                            (BYTE *) pbData(pHead),
                            pHead->szFileName,
                            pHead->nLine);
                    }
                    else
                    {
                        _RPT3(_CRT_WARN, "HEAP CORRUPTION DETECTED: before %hs block (#%d) at 0x%p.\n"
                            "CRT detected that the application wrote to memory before start of heap buffer.\n",
                            blockUse, pHead->lRequest, (BYTE *) pbData(pHead));
                    }
                    okay = FALSE;
                }

                if (!CheckBytes(pbData(pHead) + pHead->nDataSize, _bNoMansLandFill,
                nNoMansLandSize))
                {
                    if (pHead->szFileName)
                    {
                        _RPT5(_CRT_WARN, "HEAP CORRUPTION DETECTED: after %hs block (#%d) at 0x%p.\n"
                            "CRT detected that the application wrote to memory after end of heap buffer.\n"
                            _ALLOCATION_FILE_LINENUM,
                            blockUse,
                            pHead->lRequest,
                            (BYTE *) pbData(pHead),
                            pHead->szFileName,
                            pHead->nLine);
                    }
                    else
                    {
                        _RPT3(_CRT_WARN, "HEAP CORRUPTION DETECTED: after %hs block (#%d) at 0x%p.\n"
                            "CRT detected that the application wrote to memory after end of heap buffer.\n",
                            blockUse, pHead->lRequest, (BYTE *) pbData(pHead));
                    }
                    okay = FALSE;
                }

                /* free blocks should remain undisturbed */
                if (pHead->nBlockUse == _FREE_BLOCK &&
                !CheckBytes(pbData(pHead), _bDeadLandFill, pHead->nDataSize))
                {
                    if (pHead->szFileName)
                    {
                        _RPT3(_CRT_WARN, "HEAP CORRUPTION DETECTED: on top of Free block at 0x%p.\n"
                            "CRT detected that the application wrote to a heap buffer that was freed.\n"
                            _ALLOCATION_FILE_LINENUM,
                            (BYTE *) pbData(pHead),
                            pHead->szFileName,
                            pHead->nLine);
                    }
                    else
                    {
                        _RPT1(_CRT_WARN, "HEAP CORRUPTION DETECTED: on top of Free block at 0x%p.\n"
                            "CRT detected that the application wrote to a heap buffer that was freed.\n",
                            (BYTE *) pbData(pHead));
                    }
                    okay = FALSE;
                }

                if (!okay)
                {
                    /* report some more statistics about the broken object */

                    if (pHead->szFileName)
                    {
                        _RPT5(_CRT_WARN,
                            "%hs located at 0x%p is %Iu bytes long.\n"
                            _ALLOCATION_FILE_LINENUM,
                            blockUse,
                            (BYTE *)pbData(pHead),
                            pHead->nDataSize,
                            pHead->szFileName,
                            pHead->nLine);
                    }
                    else
                    {
                        _RPT3(_CRT_WARN, "%hs located at 0x%p is %Iu bytes long.\n",
                            blockUse, (BYTE *)pbData(pHead), pHead->nDataSize);
                    }

                    allOkay = FALSE;
                }
            }
        }

        }
        __finally {
            _munlock( _HEAP_LOCK );     /* release other threads */
        }

        return allOkay;
}


/***
*int _CrtSetDbgFlag() - get/set the _crtDbgFlag
*
*Purpose:
*       get or set the _crtDbgFlag
*
*Entry:
*       int fNewBits - new Flag or _CRTDBG_REPORT_FLAG
*
*Return:
*       previous flag state
*
*Exceptions:
*       The new flag need to use only _CRTDBG_ALLOC_MEM_DF, _CRTDBG_DELAY_FREE_MEM_DF,
*       _CRTDBG_CHECK_ALWAYS_DF, _CRTDBG_CHECK_CRT_DF and _CRTDBG_LEAK_CHECK_DF. Otherwise
*       errno is set to EINVAL and the flag is not changed.
*
*******************************************************************************/
extern "C" _CRTIMP int __cdecl _CrtSetDbgFlag(
        int fNewBits
        )
{
        int fOldBits= _crtDbgFlag;

        /* Make sure the flag uses only _CRTDBG_ALLOC_MEM_DF, _CRTDBG_DELAY_FREE_MEM_DF,
            * _CRTDBG_CHECK_ALWAYS_DF, _CRTDBG_CHECK_CRT_DF and _CRTDBG_LEAK_CHECK_DF
            */
        _VALIDATE_RETURN(       (fNewBits==_CRTDBG_REPORT_FLAG) ||
                                                        ((fNewBits & 0x0ffff &
                                                                ~(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_DELAY_FREE_MEM_DF |
                                                                _CRTDBG_CHECK_ALWAYS_DF | _CRTDBG_CHECK_CRT_DF |
                                                                _CRTDBG_LEAK_CHECK_DF)
                                                        ) == 0),
            EINVAL,
            _crtDbgFlag);

        _mlock(_HEAP_LOCK);  /* block other threads */
        __try {

                // deliberate reinit here now we own the lock to ensure we pick up the most recent values
        fOldBits = _crtDbgFlag;

        if ( fNewBits != _CRTDBG_REPORT_FLAG )
        {
            if ( fNewBits & _CRTDBG_CHECK_ALWAYS_DF )
                check_frequency = 1;
            else
                check_frequency = (fNewBits >> 16) & 0x0ffff;

            check_counter = 0;
            _crtDbgFlag = fNewBits;
        }

        }
        __finally {
            _munlock( _HEAP_LOCK );
        }
        return fOldBits;
}


/***
*int _CrtDoForAllClientObjects() - call a client-supplied function for all
*                                  client objects in the heap
*
*Purpose:
*       call a client-supplied function for all client objects in the heap
*
*Entry:
*       void (*pfn)(void *, void *) - pointer to client function to call
*       void * pContext - pointer to user supplied context to pass to function
*
*Return:
*    void
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
extern "C" _CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void * pContext
        )
{
        _CrtMemBlockHeader * pHead;

        /* validation section */
        _VALIDATE_RETURN_VOID(pfn != NULL, EINVAL);

        if (!(_crtDbgFlag & _CRTDBG_ALLOC_MEM_DF))
            return;         /* sorry not enabled */

        _mlock(_HEAP_LOCK);  /* block other threads */
        __try {

        for (pHead = _pFirstBlock; pHead != NULL; pHead = pHead->pBlockHeaderNext)
        {
            if (_BLOCK_TYPE(pHead->nBlockUse) == _CLIENT_BLOCK)
                (*pfn)((void *) pbData(pHead), pContext);
        }

        }
        __finally {
            _munlock(_HEAP_LOCK);  /* release other threads */
        }
}


/***
*int _CrtIsValidPointer() - verify memory range is valid for reading/writing
*
*Purpose:
*       verify memory range range is valid for reading/writing
*
*Entry:
*       const void * pv     - start of memory range to test
*       unsigned int nBytes - size of memory range
*       int bReadWrite      - TRUE if read/write, FALSE if read-only
*
*Return:
*       TRUE - if valid address
*       FALSE otherwise
*
*******************************************************************************/
extern "C" _CRTIMP int __cdecl _CrtIsValidPointer(
        const void * pv,
        unsigned int nBytes,
        int bReadWrite
        )
{
        return (pv != NULL);
}

/***
*int _CrtIsValidHeapPointer() - verify pointer is from 'local' heap
*
*Purpose:
*       Verify pointer is not only a valid pointer but also that it is from
*       the 'local' heap. Pointers from another copy of the C runtime (even in the
*       same process) will be caught.
*
*Entry:
*       const void * pUserData     - pointer of interest
*
*Return:
*       TRUE - if valid and from local heap
*       FALSE otherwise
*
*******************************************************************************/
extern "C" _CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void * pUserData
        )
{
#ifndef WINHEAP
        int i;
        void * base;
#else  /* WINHEAP */
#endif  /* WINHEAP */

        if (!pUserData)
            return FALSE;

        if (!_CrtIsValidPointer(pHdr(pUserData), sizeof(_CrtMemBlockHeader), FALSE))
            return FALSE;


#ifdef WINHEAP

#ifndef _WIN64
        if ( __active_heap == __V6_HEAP )
        {
            PHEADER     pHeader;
            if (pHeader = __sbh_find_block(pHdr(pUserData)))
            {
                return __sbh_verify_block(pHeader, pHdr(pUserData));
            }
            else
                return HeapValidate( _crtheap, 0, pHdr(pUserData) );
        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP )
        {
            __old_sbh_region_t * preg;
            __old_sbh_page_t *   ppage;
            __old_page_map_t *   pmap;
            if ( (pmap = __old_sbh_find_block( pHdr(pUserData), &preg, &ppage )) !=
                 NULL )
            {
                if ( *pmap )
                    return TRUE;
                else
                    return FALSE;
            }
            else
                return HeapValidate( _crtheap, 0, pHdr(pUserData) );
        }
#endif  /* CRTDLL */
        else    //  __active_heap == _SYSTEM_HEAP
#endif  /* _WIN64 */
        {
            return HeapValidate( _crtheap, 0, pHdr(pUserData) );
        }

#else  /* WINHEAP */

        /*
         * Go through the heap regions and see if the pointer lies within one
         * of the regions of the local heap.
         *
         * Pointers from non-local heaps cannot be handled. For example, a
         * non-local pointer may come from a DLL that has the CRT linked-in.
         *
         */

        for (i = 0; (base = _heap_regions[i]._regbase) != NULL &&
                i < _HEAP_REGIONMAX; i++)
        {
            if (pUserData >= base && pUserData <
                    (void *)(((char *)base)+_heap_regions[i]._currsize))
                return TRUE;
        }

        return FALSE;

#endif  /* WINHEAP */
}


/***
*int _CrtIsMemoryBlock() - verify memory block is debug heap block
*
*Purpose:
*       verify memory block is debug heap block
*
*Entry:
*       const void *    pUserData       - start of memory block
*       unsigned int    nBytes          - size of memory block
*       long * plRequestNumber          - if !NULL, set to request number
*       char **         pszFileName     - if !NULL, set to file name
*       int *           pnLine          - if !NULL, set to line number
*
*Return:
*       TRUE - if debug memory heap address
*       FALSE otherwise
*
*******************************************************************************/
extern "C" _CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void * pUserData,
        unsigned int nBytes,
        long * plRequestNumber,
        char ** pszFileName,
        int * pnLine
        )
{
        _CrtMemBlockHeader * pHead=NULL;
        int retval=FALSE;

        /* pre-init output info with null values */
        if (plRequestNumber != NULL)
        {
            *plRequestNumber = 0;
        }
        if (pszFileName != NULL)
        {
            *pszFileName = NULL;
        }
        if (pnLine != NULL)
        {
            *pnLine = 0;
        }

        if (!_CrtIsValidHeapPointer(pUserData))
        {
            return FALSE;
        }

        _mlock(_HEAP_LOCK);         /* block other threads */
        __try {

        pHead = pHdr(pUserData);

        if (_BLOCK_TYPE_IS_VALID(pHead->nBlockUse) &&
            _CrtIsValidPointer(pUserData, nBytes, TRUE) &&
            pHead->nDataSize == nBytes &&
            pHead->lRequest <= _lRequestCurr
           )
        {
            if (plRequestNumber != NULL)
                *plRequestNumber = pHead->lRequest;
            if (pszFileName != NULL)
                *pszFileName = pHead->szFileName;
            if (pnLine != NULL)
                *pnLine = pHead->nLine;

            retval = TRUE;
        }
        else
            retval = FALSE;

        }
        __finally {
            _munlock(_HEAP_LOCK);   /* release other threads */
        }

        return retval;
}


/***
*
*Purpose:
*       return memory block type for a debug heap block
*
*Entry:
*       const void * pUserData - start of memory block
*
*Return:
*       Block type if pUserData is a valid debug heap block pointer, else -1.
*
*******************************************************************************/
extern "C" _CRTIMP int _CrtReportBlockType(
        const void * pUserData
        )
{
        _CrtMemBlockHeader * pHead;

        if (!_CrtIsValidHeapPointer(pUserData))
            return -1;

        pHead = pHdr(pUserData);
        return pHead->nBlockUse;
}


/*---------------------------------------------------------------------------
 *
 * Memory state
 *
 --------------------------------------------------------------------------*/


/***
*_CRT_DUMP_CLIENT _CrtSetDumpClient() - set client dump routine
*
*Purpose:
*       set client dump routine
*
*Entry:
*       _CRT_DUMP_CLIENT pfnNewDumpClient - new dump routine
*
*Exit:
*       return previous dump routine
*
*Exceptions:
*
*******************************************************************************/
extern "C" _CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT pfnNewDump
        )
{
        _CRT_DUMP_CLIENT pfnOldDump = _pfnDumpClient;
        _pfnDumpClient = pfnNewDump;
        return pfnOldDump;
}

/***
*_CRT_DUMP_CLIENT _CrtGetDumpClient() - get client dump routine
*
*Purpose:
*       get client dump routine
*
*Entry:
*
*Exit:
*       return current dump routine
*
*Exceptions:
*
*******************************************************************************/
extern "C" _CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient
(
        void
)
{
        return _pfnDumpClient;
}


/***
*_CrtMemState * _CrtMemStateCheckpoint() - checkpoint current memory state
*
*Purpose:
*       checkpoint current memory state
*
*Entry:
*       _CrtMemState * state - state structure to fill in, must be not NULL
*
*Return:
*       current memory state
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
extern "C" _CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState * state
        )
{
        int use;
        _CrtMemBlockHeader * pHead;

        /* validation section */
        _VALIDATE_RETURN_VOID(state != NULL, EINVAL);

        _mlock(_HEAP_LOCK);         /* block other threads */
        __try {

        state->pBlockHeader = _pFirstBlock;
        for (use = 0; use < _MAX_BLOCKS; use++)
            state->lCounts[use] = state->lSizes[use] = 0;

        for (pHead = _pFirstBlock; pHead != NULL; pHead = pHead->pBlockHeaderNext)
        {
            if (_BLOCK_TYPE(pHead->nBlockUse) >= 0 && _BLOCK_TYPE(pHead->nBlockUse) < _MAX_BLOCKS)
            {
                state->lCounts[_BLOCK_TYPE(pHead->nBlockUse)]++;
                state->lSizes[_BLOCK_TYPE(pHead->nBlockUse)] += pHead->nDataSize;
            }
            else
            {
                if (pHead->szFileName)
                {
                    _RPT3(_CRT_WARN,
                        "Bad memory block found at 0x%p.\n"
                        _ALLOCATION_FILE_LINENUM,
                        (BYTE *)pHead,
                        pHead->szFileName,
                        pHead->nLine);
                }
                else
                {
                    _RPT1(_CRT_WARN, "Bad memory block found at 0x%p.\n", (BYTE *)pHead);
                }
            }
        }

        state->lHighWaterCount = _lMaxAlloc;
        state->lTotalCount = _lTotalAlloc;

        }
        __finally {
            _munlock(_HEAP_LOCK);   /* release other threads */
        }
}


/***
*int _CrtMemDifference() - compare two memory states
*
*Purpose:
*       compare two memory states
*
*Entry:
*       _CrtMemState * state - return memory state difference
*       _CrtMemState * oldState - earlier memory state
*       _CrtMemState * newState - later memory state
*
*Return:
*       TRUE if difference
*       FALSE otherwise
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
extern "C" _CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState * state,
        const _CrtMemState * oldState,
        const _CrtMemState * newState
        )
{
        int use;
        int bSignificantDifference = FALSE;

        /* validation section */
        _VALIDATE_RETURN(state != NULL, EINVAL, FALSE);
        _VALIDATE_RETURN(oldState != NULL, EINVAL, FALSE);
        _VALIDATE_RETURN(newState != NULL, EINVAL, FALSE);

        for (use = 0; use < _MAX_BLOCKS; use++)
        {
            state->lSizes[use] = newState->lSizes[use] - oldState->lSizes[use];
            state->lCounts[use] = newState->lCounts[use] - oldState->lCounts[use];

            if (    (state->lSizes[use] != 0 || state->lCounts[use] != 0) &&
                     use != _FREE_BLOCK &&
                    (use != _CRT_BLOCK ||
                    (use == _CRT_BLOCK && (_crtDbgFlag & _CRTDBG_CHECK_CRT_DF)))
                    )
                bSignificantDifference = TRUE;
        }
        state->lHighWaterCount = newState->lHighWaterCount - oldState->lHighWaterCount;
        state->lTotalCount = newState->lTotalCount - oldState->lTotalCount;
        state->pBlockHeader = NULL;

        return bSignificantDifference;
}

#define MAXPRINT 16

extern "C" static void __cdecl _printMemBlockData(
        _locale_t plocinfo,
        _CrtMemBlockHeader * pHead
        )
{
        int i;
        unsigned char ch;
        unsigned char printbuff[MAXPRINT+1];
        unsigned char valbuff[MAXPRINT*3+1];

        _LocaleUpdate _loc_update(plocinfo);
        for (i = 0; i < min((int)pHead->nDataSize, MAXPRINT); i++)
        {
            ch = pbData(pHead)[i];
            printbuff[i] = _isprint_l(ch, _loc_update.GetLocaleT()) ? ch : ' ';
            _ERRCHECK_SPRINTF(sprintf_s((char *)&valbuff[i*3], _countof(valbuff) - (i * 3) , "%.2X ", ch));
        }
        printbuff[i] = '\0';

        _RPT2(_CRT_WARN, " Data: <%s> %s\n", printbuff, valbuff);
}


/***
*void _CrtMemDumpAllObjectsSince() - dump all objects since memory state
*
*Purpose:
*       dump all objects since memory state
*
*Entry:
*       _CrtMemState * state - dump since this state
*
*Return:
*       void
*
*******************************************************************************/
static void __cdecl _CrtMemDumpAllObjectsSince_stat(
        const _CrtMemState * state,
        _locale_t plocinfo
        )
{
        _CrtMemBlockHeader * pHead;
        _CrtMemBlockHeader * pStopBlock = NULL;

        _mlock(_HEAP_LOCK);         /* block other threads */
        __try {

        _RPT0(_CRT_WARN, "Dumping objects ->\n");

        if (state)
            pStopBlock = state->pBlockHeader;

        for (pHead = _pFirstBlock; pHead != NULL && pHead != pStopBlock;
            pHead = pHead->pBlockHeaderNext)
        {
            if (_BLOCK_TYPE(pHead->nBlockUse) == _IGNORE_BLOCK ||
                _BLOCK_TYPE(pHead->nBlockUse) == _FREE_BLOCK ||
                (_BLOCK_TYPE(pHead->nBlockUse) == _CRT_BLOCK &&
               !(_crtDbgFlag & _CRTDBG_CHECK_CRT_DF))
               )
            {
                /* ignore it for dumping */
            }
            else {
                if (pHead->szFileName != NULL)
                {
#pragma warning(push)
#pragma warning(disable: 4996)
                    if (!_CrtIsValidPointer(pHead->szFileName, 1, FALSE) || IsBadReadPtr(pHead->szFileName,1))
#pragma warning(pop)
                                        {
                        _RPT1(_CRT_WARN, "#File Error#(%d) : ", pHead->nLine);
                                        }
                    else
                                        {
                        _RPT2(_CRT_WARN, "%hs(%d) : ", pHead->szFileName, pHead->nLine);
                                        }
                }

                _RPT1(_CRT_WARN, "{%ld} ", pHead->lRequest);

                if (_BLOCK_TYPE(pHead->nBlockUse) == _CLIENT_BLOCK)
                {
                    _RPT3(_CRT_WARN, "client block at 0x%p, subtype %x, %Iu bytes long.\n",
                        (BYTE *)pbData(pHead), _BLOCK_SUBTYPE(pHead->nBlockUse), pHead->nDataSize);

#pragma warning(push)
#pragma warning(disable: 4996)
                    if (_pfnDumpClient && !IsBadReadPtr(pbData(pHead), 1))
#pragma warning(pop)
                        (*_pfnDumpClient)( (void *) pbData(pHead), pHead->nDataSize);
                    else
                        _printMemBlockData(plocinfo, pHead);
                }
                else if (pHead->nBlockUse == _NORMAL_BLOCK)
                {
                    _RPT2(_CRT_WARN, "normal block at 0x%p, %Iu bytes long.\n",
                        (BYTE *)pbData(pHead), pHead->nDataSize);

                    _printMemBlockData(plocinfo, pHead);
                }
                else if (_BLOCK_TYPE(pHead->nBlockUse) == _CRT_BLOCK)
                {
                    _RPT3(_CRT_WARN, "crt block at 0x%p, subtype %x, %Iu bytes long.\n",
                        (BYTE *)pbData(pHead), _BLOCK_SUBTYPE(pHead->nBlockUse), pHead->nDataSize);

                    _printMemBlockData(plocinfo, pHead);
                }
            }
        }
        }
        __finally {
            _munlock(_HEAP_LOCK);   /* release other threads */
        }

        _RPT0(_CRT_WARN, "Object dump complete.\n");
}
extern "C" _CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState * state
        )
{
        _locale_t plocinfo = NULL;
        _LocaleUpdate _loc_update(plocinfo);

        _CrtMemDumpAllObjectsSince_stat(state, _loc_update.GetLocaleT());
}


/***
*void _CrtMemDumpMemoryLeaks() - dump all objects still in heap
*
*Purpose:
*       dump all objects still in heap. used to detect memory leaks over the
*       life of a program
*
*Entry:
*       void
*
*Return:
*       TRUE if memory leaks
*       FALSE otherwise
*
*******************************************************************************/
extern "C" _CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        )
{
        /* only dump leaks when there are in fact leaks */
        _CrtMemState msNow;

        _CrtMemCheckpoint(&msNow);

        if (msNow.lCounts[_CLIENT_BLOCK] != 0 ||
            msNow.lCounts[_NORMAL_BLOCK] != 0 ||
            (_crtDbgFlag & _CRTDBG_CHECK_CRT_DF &&
            msNow.lCounts[_CRT_BLOCK] != 0)
           )
        {
            /* difference detected: dump objects since start. */
            _RPT0(_CRT_WARN, "Detected memory leaks!\n");

            _CrtMemDumpAllObjectsSince(NULL);
            return TRUE;
        }

        return FALSE;   /* no leaked objects */
}


/***
*_CrtMemState * _CrtMemDumpStatistics() - dump memory state
*
*Purpose:
*       dump memory state
*
*Entry:
*       _CrtMemState * state - dump this state
*
*Return:
*       void
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
extern "C" _CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState * state
        )
{
        int use;

        /* validation section */
        _VALIDATE_RETURN_VOID(state != NULL, EINVAL);

        for (use = 0; use < _MAX_BLOCKS; use++)
        {
            _RPT3(_CRT_WARN, "%Id bytes in %Id %hs Blocks.\n",
                state->lSizes[use], state->lCounts[use], szBlockUseName[use]);
        }

        _RPT1(_CRT_WARN, "Largest number used: %Id bytes.\n", state->lHighWaterCount);
        _RPT1(_CRT_WARN, "Total allocations: %Id bytes.\n", state->lTotalCount);
}


/***
* void *_aligned_malloc(size_t size, size_t alignment)
*       - Get a block of aligned memory from the heap.
*
* Purpose:
*       Allocate of block of aligned memory aligned on the alignment of at least
*       size bytes from the heap and return a pointer to it.
*
* Entry:
*       size_t size - size of block requested
*       size_t alignment - alignment of memory
*
* Exit:
*       Sucess: Pointer to memory block
*       Faliure: Null
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _aligned_malloc(
        size_t size,
        size_t align
        )
{
    return _aligned_offset_malloc_dbg(size, align, 0, NULL, 0);
}


/***
* void *_aligned_malloc_dbg(size_t size, size_t alignment,
*                           const char *f_name, int line_n)
*       - Get a block of aligned memory from the heap.
*
* Purpose:
*       Allocate of block of aligned memory aligned on the alignment of at least
*       size bytes from the heap and return a pointer to it.
*
* Entry:
*       size_t size - size of block requested
*       size_t alignment - alignment of memory
*       const char * f_name - file name
*       int line_n - line number
*
* Exit:
*       Sucess: Pointer to memory block
*       Faliure: Null
*
*******************************************************************************/


extern "C" _CRTIMP void * __cdecl _aligned_malloc_dbg(
        size_t size,
        size_t align,
        const char * f_name,
        int line_n
        )
{
    return _aligned_offset_malloc_dbg(size, align, 0, f_name, line_n);
}

/***
*
* void *_aligned_realloc(size_t size, size_t alignment)
*       - Reallocate a block of aligned memory from the heap.
*
* Purpose:
*       Reallocates of block of aligned memory aligned on the alignment of at
*       least size bytes from the heap and return a pointer to it. Size can be
*       either greater or less than the original size of the block.
*       The reallocation may result in moving the block as well as changing the
*       size.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t size - size of block requested
*       size_t alignment - alignment of memory
*
* Exit:
*       Sucess: Pointer to re-allocated memory block
*       Faliure: Null
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _aligned_realloc(
        void * memblock,
        size_t size,
        size_t align
        )
{
    return _aligned_offset_realloc_dbg(memblock, size, align, 0, NULL, 0);
}

/***
*
* void *_aligned_recalloc(size_t size, size_t alignment)
*       - Reallocate items from the heap.
*
* Purpose:
*       Reallocates of block of aligned memory aligned on the alignment of at
*       least size bytes from the heap and return a pointer to it. Size can be
*       either greater or less than the original size of the block.
*       The reallocation may result in moving the block as well as changing the
*       size.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t count - count of items
*       size_t size - size of items
*       size_t alignment - alignment of memory
*
* Exit:
*       Sucess: Pointer to re-allocated memory block
*       Faliure: Null
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _aligned_recalloc(
        void * memblock,
        size_t count,
        size_t size,
        size_t align
        )
{
    return _aligned_offset_recalloc_dbg(memblock, count, size, align, 0, NULL, 0);
}


/***
*
* void *_aligned_realloc_dbg(void * memblock, size_t size, size_t alignment,
*                        const char * f_name, int line_n)
*       - Reallocate a block of aligned memory from the heap.
*
* Purpose:
*       Reallocates of block of aligned memory aligned on the alignment of at
*       least size bytes from the heap and return a pointer to it. Size can be
*       either greater or less than the original size of the block.
*       The reallocation may result in moving the block as well as changing the
*       size.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t size - size of block requested
*       size_t alignment - alignment of memory
*       const char * f_name - file name
*       int - line number
*
* Exit:
*       Sucess: Pointer to re-allocated memory block
*       Faliure: Null
*
*******************************************************************************/


extern "C" _CRTIMP void * __cdecl _aligned_realloc_dbg(
        void *memblock,
        size_t size,
        size_t align,
        const char * f_name,
        int line_n
        )
{
    return _aligned_offset_realloc_dbg(memblock, size, align, 0, f_name, line_n);
}

/***
*
* void *_aligned_recalloc_dbg(void * memblock, size_t count, size_t size, size_t alignment, const char * f_name, int line_n)
*       - Reallocate items from the heap.
*
* Purpose:
*       Reallocates of block of aligned memory aligned on the alignment of at
*       least size bytes from the heap and return a pointer to it. Size can be
*       either greater or less than the original size of the block.
*       The reallocation may result in moving the block as well as changing the
*       size.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t count - count of items
*       size_t size - size of items
*       size_t alignment - alignment of memory
*       const char * f_name - file name
*       int - line number
*
* Exit:
*       Sucess: Pointer to re-allocated memory block
*       Faliure: Null
*
*******************************************************************************/


extern "C" _CRTIMP void * __cdecl _aligned_recalloc_dbg(
        void *memblock,
        size_t count,
        size_t size,
        size_t align,
        const char * f_name,
        int line_n
        )
{
    return _aligned_offset_recalloc_dbg(memblock, count, size, align, 0, f_name, line_n);
}

/***
*
* void *_aligned_offset_malloc(size_t size, size_t alignment, int offset)
*       - Allocates a block of memory from the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       size_t size - size of block of memory
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Sucess: Pointer to the re-allocated memory block
*       Faliure: Null
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _aligned_offset_malloc(
        size_t size,
        size_t align,
        size_t offset
        )
{
    return _aligned_offset_malloc_dbg(size, align, offset, NULL, 0);
}



/***
*
* void *_aligned_offset_malloc_dbg(size_t size, size_t alignment, int offset,
*                              const char * f_name, int line_n)
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       size_t size - size of block of memory
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*       const char * f_name - file name
*       int line_n - line number
*
* Exit:
*       Sucess: Pointer to the re-allocated memory block
*       Faliure: Null
*
*******************************************************************************/


extern "C" _CRTIMP void * __cdecl _aligned_offset_malloc_dbg(
        size_t size,
        size_t align,
        size_t offset,
        const char * f_name,
        int line_n
        )
{
    uintptr_t ptr, r_ptr, t_ptr;
    _AlignMemBlockHdr *pHdr;

    /* validation section */
    _VALIDATE_RETURN(IS_2_POW_N(align), EINVAL, NULL);
    _VALIDATE_RETURN(offset == 0 || offset < size, EINVAL, NULL);

    align = (align > sizeof(uintptr_t) ? align : sizeof(uintptr_t)) -1;

    t_ptr = (0 -offset)&(sizeof(uintptr_t) -1);

    if ((ptr = (uintptr_t) _malloc_dbg(t_ptr + size + align + sizeof(_AlignMemBlockHdr), _NORMAL_BLOCK, f_name, line_n)) == (uintptr_t)NULL)
        return NULL;

    r_ptr =((ptr +align +t_ptr +sizeof(_AlignMemBlockHdr) +offset)&~align)-offset;
    pHdr = (_AlignMemBlockHdr *)(r_ptr - t_ptr) -1;
    memset((void *)pHdr->Gap, _bAlignLandFill, nAlignGapSize);
    pHdr->pHead = (void *)ptr;
    return (void *) r_ptr;
}

/***
*
* void *_aligned_offset_realloc(size_t size, size_t alignment, int offset)
*       - Reallocate a block of memory from the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t size - size of block of memory
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Sucess: Pointer to the re-allocated memory block
*       Faliure: Null
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _aligned_offset_realloc(
        void * memblock,
        size_t size,
        size_t align,
        size_t offset
        )
{
    return _aligned_offset_realloc_dbg(memblock, size, align, offset, NULL, 0);
}

/***
*
* void *_aligned_offset_recalloc(void * memory, size_t size, size_t count, size_t alignment, int offset)
*       - Reallocate items the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t count - count of items
*       size_t size - size of items
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*
* Exit:
*       Sucess: Pointer to the re-allocated memory block
*       Faliure: Null
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _aligned_offset_recalloc(
        void * memblock,
        size_t count,
        size_t size,
        size_t align,
        size_t offset
        )
{
    return _aligned_offset_recalloc_dbg(memblock, count, size, align, offset, NULL, 0);
}



/***
*
* void *_aligned_offset_realloc_dbg(void *memblock, size_t size,
*                                   size_t alignment, int offset,
*                                   const char * f_name, int line_n)
*       - Reallocate a block of memory from the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t size - size of block of memory
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*       const char * f_name - file name
*       int line_n - line number
*
* Exit:
*       Sucess: Pointer to the re-allocated memory block
*       Faliure: Null
*
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _aligned_offset_realloc_dbg(
        void * memblock,
        size_t size,
        size_t align,
        size_t offset,
        const char * f_name,
        int line_n
        )
{
    uintptr_t ptr, r_ptr, t_ptr, mov_sz;
    _AlignMemBlockHdr *pHdr, *s_pHdr;

    if ( memblock == NULL)
    {
        return _aligned_offset_malloc_dbg(size, align, offset, f_name, line_n);
    }
    if ( size == 0)
    {
        _aligned_free_dbg(memblock);
        return NULL;
    }

    s_pHdr = (_AlignMemBlockHdr *)((uintptr_t)memblock & ~(sizeof(uintptr_t) -1)) -1;

    if ( CheckBytes((unsigned char *)memblock -nNoMansLandSize, _bNoMansLandFill, nNoMansLandSize))
    {
        // We don't know where (file, linenum) memblock was allocated
        _RPT1(_CRT_ERROR, "The block at 0x%p was not allocated by _aligned routines, use realloc()", memblock);
        errno = EINVAL;
        return NULL;
    }

    if(!CheckBytes(s_pHdr->Gap, _bAlignLandFill, nAlignGapSize))
    {
        // We don't know where (file, linenum) memblock was allocated
        _RPT1(_CRT_ERROR, "Damage before 0x%p which was allocated by aligned routine\n", memblock);
    }

    /* validation section */
    _VALIDATE_RETURN(IS_2_POW_N(align), EINVAL, NULL);
    _VALIDATE_RETURN(offset == 0 || offset < size, EINVAL, NULL);

    mov_sz = _msize(s_pHdr->pHead) - ((uintptr_t)memblock - (uintptr_t)s_pHdr->pHead);

    align = (align > sizeof(uintptr_t) ? align : sizeof(uintptr_t)) -1;

    t_ptr = (0 -offset)&(sizeof(uintptr_t) -1);

    if ((ptr = (uintptr_t) _malloc_dbg(t_ptr + size + align + sizeof(_AlignMemBlockHdr), _NORMAL_BLOCK, f_name, line_n)) == (uintptr_t)NULL)
        return NULL;

    r_ptr =((ptr +align +t_ptr +sizeof(_AlignMemBlockHdr) +offset)&~align)-offset;
    pHdr = (_AlignMemBlockHdr *)(r_ptr - t_ptr) -1;
    memset((void *)pHdr->Gap, _bAlignLandFill, nAlignGapSize);
    pHdr->pHead = (void *)ptr;

    memcpy((void *)r_ptr, memblock, mov_sz > size ? size : mov_sz);
    _free_dbg(s_pHdr->pHead, _NORMAL_BLOCK);

    return (void *) r_ptr;
}


/***
*
* void *_aligned_offset_recalloc_dbg(void *memblock, size_t count size_t size,
*                                   size_t alignment, int offset,
*                                   const char * f_name, int line_n)
*       - Reallocate items from the heap.
*
* Purpose:
*       Reallocates a block of memory which is shifted by offset from
*       alignment of at least size bytes from the heap and return a pointer
*       to it. Size can be either greater or less than the original size of the
*       block.
*
* Entry:
*       void *memblock - pointer to block in the heap previously allocated by
*               call to _aligned_malloc(), _aligned_offset_malloc(),
*               _aligned_realloc() or _aligned_offset_realloc().
*       size_t count - count of items
*       size_t size - size of items
*       size_t alignment - alignment of memory
*       size_t offset - offset of memory from the alignment
*       const char * f_name - file name
*       int line_n - line number
*
* Exit:
*       Sucess: Pointer to the re-allocated memory block
*       Faliure: Null
*
*
*******************************************************************************/

extern "C" _CRTIMP void * __cdecl _aligned_offset_recalloc_dbg
(
    void * memblock,
    size_t count,
    size_t size,
    size_t align,
    size_t offset,
    const char * f_name,
    int line_n
)
{
    size_t user_size    = 0; /* wanted size, passed to aligned realoc */
    size_t start_fill   = 0; /* location where aligned recalloc starts to fill with 0 */
                             /* filling must start from the end of the previous user block */
                             /* and must stop at the end of the new user block */
    void * retp = NULL;      /* result of aligned recalloc*/

    /* ensure that (size * count) does not overflow */
    if (count > 0)
    {
        _VALIDATE_RETURN((_HEAP_MAXREQ / count) >= size, ENOMEM, NULL);
    }
    user_size = size * count;

    if (memblock != NULL)
    {
        start_fill = _aligned_msize(memblock, align, offset);
    }

    retp = _aligned_offset_realloc_dbg(memblock, user_size, align, offset, f_name, line_n);

    if (retp != NULL)
    {
        if (start_fill < user_size)
        {
            memset ((char*)retp + start_fill, 0, user_size - start_fill);
        }
    }
    return retp;
}

/***
*
* void *_aligned_free(void *memblock)
*       - Free the memory which was allocated using _aligned_malloc or
*       _aligned_offset_memory
*
* Purpose:
*       Frees the algned memory block which was allocated using _aligned_malloc
*       or _aligned_memory.
*
* Entry:
*       void * memblock - pointer to the block of memory
*
*******************************************************************************/

extern "C" _CRTIMP void __cdecl _aligned_free(
        void *memblock
        )
{
    _aligned_free_dbg(memblock);
}


/***
*
* void *_aligned_free_dbg(void *memblock, const char * file_n, int line_n)
*       - Free the memory which was allocated using _aligned_malloc or
*       _aligned_offset_memory
*
* Purpose:
*       Frees the algned memory block which was allocated using _aligned_malloc
*       or _aligned_memory.
*
* Entry:
*       void * memblock - pointer to the block of memory
*
*******************************************************************************/

extern "C" _CRTIMP void __cdecl _aligned_free_dbg(
        void * memblock
        )
{
    _AlignMemBlockHdr *pHdr;

    if ( memblock == NULL)
        return;

    pHdr = (_AlignMemBlockHdr *)((uintptr_t)memblock & ~(sizeof(uintptr_t) -1)) -1;

    if ( CheckBytes((unsigned char *)memblock -nNoMansLandSize, _bNoMansLandFill, nNoMansLandSize))
    {
        // We don't know where (file, linenum) memblock was allocated
        _RPT1(_CRT_ERROR, "The block at 0x%p was not allocated by _aligned routines, use free()", memblock);
        return;
    }

    if(!CheckBytes(pHdr->Gap, _bAlignLandFill, nAlignGapSize))
    {
        // We don't know where (file, linenum) memblock was allocated
        _RPT1(_CRT_ERROR, "Damage before 0x%p which was allocated by aligned routine\n", memblock);
    }
    _free_dbg((void *)pHdr->pHead, _NORMAL_BLOCK);
}

/***
*
* size_t _CrtSetDebugFillThreshold(size_t _NewDebugFillThreshold)
*       - Set the new debug fill threshold used in string filling
*
* Purpose:
*       Set the new debug fill threshold used in string filling.
*       Return the previous value of the threshold.
*       Threshold == 0 means no filling.
*       Threshold == SIZE_MAX means alwyas fill to the maximum.
*       At startup, value is SIZE_MAX.
*
* Entry:
*       void * memblock - pointer to the block of memory
*
*******************************************************************************/

extern "C"
_CRTIMP size_t __cdecl _CrtSetDebugFillThreshold(
        size_t _NewDebugFillThreshold
        )
{
    size_t oldThreshold = __crtDebugFillThreshold;

    __crtDebugFillThreshold = _NewDebugFillThreshold;

    return oldThreshold;
}

/***
*int _CrtSetCheckCount(int fCheckCount)
*       - Control buffer count checks for secure "n" functions
*
*Purpose:
*       set __crtDebugCheckCount to the specified value
*
*Entry:
*       int fCheckCount - new value to be set
*
*Exit:
*       return previous flag value
*
*******************************************************************************/

extern "C"
_CRTIMP int __cdecl _CrtSetCheckCount(
        int fCheckCount
        )
{
    int oldCheckCount = __crtDebugCheckCount;
    return oldCheckCount;
}

/***
*int _CrtGetCheckCount() - get current state of buffer count check
*
*Purpose:
*       get the value of __crtDebugCheckCount
*
*Exit:
*       return current flag value
*
*******************************************************************************/

extern "C"
_CRTIMP int __cdecl _CrtGetCheckCount(
        void
        )
{
    return __crtDebugCheckCount;
}

/***
*
* size_t *_aligned_msize(void *memblock, size_t align, size_t offset)
*
* Purpose:
*       Returns the size of the aligned memory block of it fails if memblock is NULL
*
* Entry:
*       void * memblock - pointer to the aligned block of memory
*
*******************************************************************************/

extern "C" _CRTIMP size_t __cdecl _aligned_msize(
        void *memblock,
        size_t align,
        size_t offset
        )
{
    return _aligned_msize_dbg(memblock, align, offset);
}


/***
*
* size_t *_aligned_msize_dbg(void *memblock, size_t align, size_t offset)
*
* Purpose:
*       Returns the size of the aligned memory block of it fails if memblock is NULL
*
* Entry:
*       void * memblock - pointer to the aligned block of memory
*
*******************************************************************************/

extern "C" _CRTIMP size_t __cdecl _aligned_msize_dbg(
        void * memblock,
        size_t align,
        size_t offset
        )
{
    size_t header_size = 0; /* Size of the header block */
    size_t footer_size = 0; /* Size of the footer block */
    size_t total_size  = 0; /* total size of the allocated block */
    size_t user_size   = 0; /* size of the user block*/
    uintptr_t gap      = 0; /* keep the alignment of the data block */
                            /* after the sizeof(void*) aligned pointer */
                            /* to the beginning of the allocated block */

    /* HEADER SIZE + FOOTER SIZE = GAP + ALIGN + SIZE OF A POINTER*/
    /* HEADER SIZE + USER SIZE + FOOTER SIZE = TOTAL SIZE */
    _VALIDATE_RETURN (memblock != NULL, EINVAL, -1);

    _AlignMemBlockHdr *pHdr = NULL; /* points to the beginning of the allocated block*/
    pHdr = (_AlignMemBlockHdr *)((uintptr_t)memblock & ~(sizeof(uintptr_t) - 1)) -1;
    total_size = _msize(pHdr->pHead);
    header_size = (uintptr_t) memblock - (uintptr_t) pHdr->pHead;
    gap = (0 - offset) & (sizeof(uintptr_t) - 1);
    /* The align cannot be smaller than the sizeof(uintptr_t) */
    align = (align > sizeof(uintptr_t) ? align : sizeof(uintptr_t)) -1;
    footer_size = gap + align + sizeof(_AlignMemBlockHdr) - header_size;
    user_size = total_size - header_size - footer_size;
    return user_size;
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgint.h ===
/***
*dbgint.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_DBGINT
#define _INC_DBGINT

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#include <crtdbg.h>

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef CRTDLL
#define _CRTIMP __declspec(dllexport)
#else  /* CRTDLL */
#ifdef _DLL
#define _CRTIMP __declspec(dllimport)
#else  /* _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* CRTDLL */
#endif  /* _CRTIMP */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* __crt_debugger_hook */
#define _CRT_DEBUGGER_GSFAILURE         1
#define _CRT_DEBUGGER_INVALIDPARAMETER  2

#ifdef _M_IX86
#define _CRT_DEBUGGER_HOOK _crt_debugger_hook
#elif defined (_M_IA64)
#define _CRT_DEBUGGER_HOOK __crt_debugger_hook_ex
_CRTIMP void __cdecl __crt_debugger_hook(int);
#else  /* defined (_M_IA64) */
#define _CRT_DEBUGGER_HOOK __crt_debugger_hook
#endif  /* defined (_M_IA64) */

_CRTIMP void __cdecl _CRT_DEBUGGER_HOOK(int);

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#ifdef __cplusplus

#define _new_crt                        new

#endif  /* __cplusplus */

#define _expand_crt                     _expand
#define _free_crt                       free
#define _msize_crt                      _msize
#define _dupenv_s_crt(ps1, size, s2)    _dupenv_s(ps1, size, s2)
#define _wdupenv_s_crt(ps1, size, s2)   _wdupenv_s(ps1, size, s2)
#if defined (_SYSCRT) || defined (MRTDLL) || defined (_M_CEE_PURE)
#define _malloc_crt                     malloc
#define _calloc_crt                     calloc
#define _realloc_crt                    realloc
#define _recalloc_crt                   _recalloc
#else  /* defined (_SYSCRT) || defined (MRTDLL) || defined (_M_CEE_PURE) */
_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP void * __cdecl _malloc_crt(_In_ size_t _Size);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP void * __cdecl _calloc_crt(_In_ size_t _Count, _In_ size_t _Size);
_Check_return_ _Ret_opt_bytecap_(_NewSize) _CRTIMP void * __cdecl _realloc_crt(_In_opt_ void *_Ptr, _In_ size_t _NewSize);
_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) _CRTIMP void * __cdecl _recalloc_crt(_In_opt_ void *_Ptr, _In_ size_t _Count, _In_ size_t _Size);
#endif  /* defined (_SYSCRT) || defined (MRTDLL) || defined (_M_CEE_PURE) */

#define _malloc_base                    malloc
#define _nh_malloc_base                 _nh_malloc
#define _nh_malloc_dbg(s, n, t, f, l)   _nh_malloc(s, n)
#define _heap_alloc_dbg(s, t, f, l)     _heap_alloc(s)
#define _calloc_base                    calloc
#define _realloc_base                   realloc
#define _recalloc_base                  _recalloc
#define _expand_base                    _expand
#define _free_base                      free
#define _msize_base                     _msize
#define _aligned_msize_base             _aligned_msize
#define _aligned_malloc_base            _aligned_malloc
#define _aligned_realloc_base           _aligned_realloc
#define _aligned_recalloc_base          _aligned_recalloc
#define _aligned_offset_malloc_base     _aligned_offset_malloc
#define _aligned_offset_realloc_base    _aligned_offset_realloc
#define _aligned_offset_recalloc_base   _aligned_offset_recalloc
#define _aligned_free_base              _aligned_free


#define _calloc_dbg_nolock(c, s, t, f, l)       _calloc_nolock(c, s)
#define _realloc_dbg_nolock(p, s, t, f, l)      _realloc_nolock(p, s)
#define _recalloc_dbg_nolock(p, c, s, t, f, l)  _recalloc_nolock(p, c, s)
#define _free_base_nolock                       _free_nolock
#define _free_dbg_nolock(p, t)                  _free_nolock(p)


#else  /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/

#define _THISFILE   __FILE__

#ifdef __cplusplus

#define _new_crt        new(_CRT_BLOCK, _THISFILE, __LINE__)

#endif  /* __cplusplus */

#define _malloc_crt(s)          _malloc_dbg(s, _CRT_BLOCK, _THISFILE, __LINE__)
#define _calloc_crt(c, s)       _calloc_dbg(c, s, _CRT_BLOCK, _THISFILE, __LINE__)
#define _realloc_crt(p, s)      _realloc_dbg(p, s, _CRT_BLOCK, _THISFILE, __LINE__)
#define _recalloc_crt(p, c, s)  _recalloc_dbg(p, c, s, _CRT_BLOCK, _THISFILE, __LINE__)
#define _expand_crt(p, s)       _expand_dbg(p, s, _CRT_BLOCK)
#define _free_crt(p)            _free_dbg(p, _CRT_BLOCK)
#define _msize_crt(p)           _msize_dbg(p, _CRT_BLOCK)
#define _dupenv_s_crt(ps1, size, s2)    _dupenv_s_dbg(ps1, size, s2, _CRT_BLOCK, _THISFILE, __LINE__)
#define _wdupenv_s_crt(ps1, size, s2)   _wdupenv_s_dbg(ps1, size, s2, _CRT_BLOCK, _THISFILE, __LINE__)

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_Check_return_ _Ret_opt_bytecap_(_Size) _CRTIMP void * __cdecl _malloc_base(
        _In_ size_t _Size
        );

_Check_return_ _Ret_opt_bytecap_(_Size) void * __cdecl _nh_malloc_base (
        _In_ size_t _Size,
        _In_ int _NhFlag
        );

_Check_return_ _Ret_opt_bytecap_(_Size) void * __cdecl _nh_malloc_dbg (
        _In_ size_t _Size,
        _In_ int _NhFlag,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_(_Size) void * __cdecl _heap_alloc_dbg(
        _In_ size_t _Size,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) void * __cdecl _calloc_base(
        _In_ size_t _Count,
        _In_ size_t _Size
        );

_Check_return_ _Ret_opt_bytecap_(_NewSize) void * __cdecl _realloc_base(
        _In_opt_ void * _Memory,
        _In_ size_t _NewSize
        );

_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) void * __cdecl _recalloc_base
(
        _In_opt_ void * _Memory,
        _In_ size_t _Count,
        _In_ size_t _Size
);

_Check_return_ _Ret_opt_bytecap_(_NewSize) void * __cdecl _expand_base(
        _In_opt_ void * _Memory,
        _In_ size_t _NewSize
        );

_CRTIMP void __cdecl _free_base(
        _Inout_opt_ void * _Memory
        );

_Check_return_ size_t __cdecl _msize_base (
        _In_ void * _Memory
        );

_Check_return_ size_t __cdecl _aligned_msize_base (
        _In_ void * _Memory,
        _In_ size_t _Alignment,
        _In_ size_t _Offset
        );

void    __cdecl _aligned_free_base(
        _Inout_opt_ void * _Memory
        );

_Check_return_ _Ret_opt_bytecap_(_Size) void *  __cdecl _aligned_malloc_base(
        _In_ size_t _Size,
        _In_ size_t _Alignment
        );

_Check_return_ _Ret_opt_bytecap_(_Size) void *  __cdecl _aligned_offset_malloc_base(
        _In_ size_t _Size,
        _In_ size_t _Alignment,
        _In_ size_t _Offset
        );

_Check_return_ _Ret_opt_bytecap_(_NewSize) void *  __cdecl _aligned_realloc_base(
        _In_opt_ void * _Memory,
        _In_ size_t _NewSize,
        _In_ size_t _Alignment
        );

_Check_return_ _Ret_opt_bytecap_(_Size) void *  __cdecl _aligned_recalloc_base
(
        _In_opt_ void * _Memory,
        _In_ size_t _Count,
        _In_ size_t _Size,
        _In_ size_t _Alignment
);

_Check_return_ _Ret_opt_bytecap_(_NewSize) void *  __cdecl _aligned_offset_realloc_base(
        _In_opt_ void * _Memory,
        _In_ size_t _NewSize,
        _In_ size_t _Alignment,
        _In_ size_t _Offset
        );

_Check_return_ _Ret_opt_bytecap_(_Size) void *  __cdecl _aligned_offset_recalloc_base
(
        _In_opt_ void * _Memory,
        _In_ size_t _Count,
        _In_ size_t _Size,
        _In_ size_t _Alignment,
        _In_ size_t _Offset
);


void __cdecl __freeCrtMemory();

/*
 * Prototypes and macros for multi-thread support
 */


_Check_return_ _Ret_opt_bytecap_x_(_Count*_Size) void * __cdecl _calloc_dbg_nolock(
        _In_ size_t _Count,
        _In_ size_t _Size,
        _In_ int _BlockType,
        _In_opt_z_ char * _Filename,
        _In_ int _LineNumber
        );


_Check_return_ _Ret_opt_bytecap_(_NewSize) void * __cdecl _realloc_dbg_nolock(
        _In_opt_ void * _Memory,
        _In_ size_t _NewSize,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
        );

_Check_return_ _Ret_opt_bytecap_(_Size) void * __cdecl _recalloc_dbg_nolock
(
        _In_opt_ void * _Memory,
        _In_ size_t _Count,
        _In_ size_t _Size,
        _In_ int _BlockType,
        _In_opt_z_ const char * _Filename,
        _In_ int _LineNumber
);

void __cdecl _free_base_nolock(
        _Inout_opt_ void * _Memory
        );

void __cdecl _free_dbg_nolock(
        _Inout_opt_ void *_Memory,
        _In_ int _BlockType
        );

/*
 * For diagnostic purpose, blocks are allocated with extra information and
 * stored in a doubly-linked list.  This makes all blocks registered with
 * how big they are, when they were allocated, and what they are used for.
 */

#define nNoMansLandSize 4

typedef struct _CrtMemBlockHeader
{
        struct _CrtMemBlockHeader * pBlockHeaderNext;
        struct _CrtMemBlockHeader * pBlockHeaderPrev;
        char *                      szFileName;
        int                         nLine;
#ifdef _WIN64
        /* These items are reversed on Win64 to eliminate gaps in the struct
         * and ensure that sizeof(struct)%16 == 0, so 16-byte alignment is
         * maintained in the debug heap.
         */
        int                         nBlockUse;
        size_t                      nDataSize;
#else  /* _WIN64 */
        size_t                      nDataSize;
        int                         nBlockUse;
#endif  /* _WIN64 */
        long                        lRequest;
        unsigned char               gap[nNoMansLandSize];
        /* followed by:
         *  unsigned char           data[nDataSize];
         *  unsigned char           anotherGap[nNoMansLandSize];
         */
} _CrtMemBlockHeader;

#define pbData(pblock) ((unsigned char *)((_CrtMemBlockHeader *)pblock + 1))
#define pHdr(pbData) (((_CrtMemBlockHeader *)pbData)-1)


_CRTIMP void __cdecl _CrtSetDbgBlockType(
        _In_opt_ void * _Memory,
        _In_ int _BlockType
        );

#define _BLOCK_TYPE_IS_VALID(use) (_BLOCK_TYPE(use) == _CLIENT_BLOCK || \
                                              (use) == _NORMAL_BLOCK || \
                                   _BLOCK_TYPE(use) == _CRT_BLOCK    || \
                                              (use) == _IGNORE_BLOCK)

extern _CRT_ALLOC_HOOK _pfnAllocHook; /* defined in dbghook.c */

int __cdecl _CrtDefaultAllocHook(
        int,
        void *,
        size_t,
        int,
        long,
        const unsigned char *,
        int
        );


/*    Adding some defines which are used in dbgrpt.c */

#define DBGRPT_MAX_MSG 4096
#define DBGRPT_TOOLONGMSG "_CrtDbgReport: String too long or IO Error"
#define DBGRPT_INVALIDMSG "_CrtDbgReport: String too long or Invalid characters in String"

typedef struct ReportHookNode {
        struct ReportHookNode *prev;
        struct ReportHookNode *next;
        unsigned refcount;
        _CRT_REPORT_HOOK pfnHookFunc;
} ReportHookNode;

typedef struct ReportHookNodeW {
        struct ReportHookNodeW *prev;
        struct ReportHookNodeW *next;
        unsigned refcount;
        _CRT_REPORT_HOOKW pfnHookFunc;
} ReportHookNodeW;

#endif  /* _DEBUG */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DBGINT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgcalloc.c ===
/***
*dbgcalloc.c - Debug CRT Heap Function of calloc()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines debug versions of heap functions calloc().
*
*******************************************************************************/

#ifdef _DEBUG

#include <windows.h>
#include <winheap.h>
#include <ctype.h>
#include <dbgint.h>
#include <crtdbg.h>
#include <rtcsup.h>
#include <internal.h>
#include <limits.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <locale.h>
#include <mtdll.h>
#include <setlocal.h>

#pragma warning(disable:4390)

/***
*void * calloc() - Get a block of memory from the debug heap, init to 0
*
*Purpose:
*       Allocate of block of memory of at least size bytes from the debug
*       heap and return a pointer to it.
*
*       Allocates 'normal' memory block.
*
*Entry:
*       size_t nNum     - number of elements in the array
*       size_t nSize - size of each element
*
*Exit:
*       Success:  Pointer to (user portion of) memory block
*       Failure:  NULL
*
*Exceptions:
*
*******************************************************************************/
extern "C" _CRTIMP void * __cdecl calloc(
        size_t nNum,
        size_t nSize
        )
{
        void *res = _calloc_dbg(nNum, nSize, _NORMAL_BLOCK, NULL, 0);

        RTCCALLBACK(_RTC_Allocate_hook, (res, nNum * nSize, 0));

        return res;
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\defsects.inc ===
;***
;defsects.inc - defines sections.
;
;   Copyright (c) Microsoft Corporation.  All rights reserved.
;
;Purpose:
;   This file defines sections for the C and C++ libs.
;
;   NOTE:  As needed, special "CRT" sections can be added into the existing
;   init/term tables.  These will be for our use only -- users who put
;   stuff in here do so at their own risk.
;
;******************************************************************************

;*******
;*
;* beginSection - a macro for declaring and beginning a section
;*
;* endSection - a macro for ending a previously declared section
;*
;*******

beginSection    MACRO   SectName
.CRT$&SectName  SEGMENT DWORD PUBLIC 'DATA'
                ENDM

endSection      MACRO   SectName
.CRT$&SectName  ENDS
                ENDM

;  XIA  Begin C Initializer Sections
;  XIC   Microsoft Reserved
;  XIU   User
;  XIZ  End C Initializer Sections
;
;  XCA  Begin C++ Constructor Sections
;  XCC   Compiler (MS)
;  XCL   Library
;  XCU   User
;  XCZ  End C++ Constructor Sections
;
;  XPA  Begin C Pre-Terminator Sections
;  XPU   User
;  XPX   Microsoft Reserved
;  XPZ  End C Pre-Terminator Sections
;
;  XTA  Begin C Pre-Terminator Sections
;  XTU   User
;  XTX   Microsoft Reserved
;  XTZ  End C Pre-Terminator Sections
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\delete.cpp ===
/***
*delete.cpp - defines C++ scalar delete routine, non-debug version
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ delete routine.
*
*******************************************************************************/

#ifndef _DEBUG

#include <cruntime.h>
#include <malloc.h>
#include <new.h>
#include <windows.h>
#include <rtcsup.h>

void operator delete( void * p )
{
    RTCCALLBACK(_RTC_Free_hook, (p, 0));

    free( p );
}

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\delopnt.cpp ===
// delopnt -- operator delete(void *, nothrow_t) REPLACEABLE
#ifdef CRTDLL
#undef CRTDLL
#endif

#ifdef MRTDLL
#undef MRTDLL
#endif

#define _USE_ANSI_CPP // suppress defaultlib directive for Std C++ Lib
#include <new>

void __CRTDECL operator delete(void *ptr,
	const std::nothrow_t&) _THROW0()
	{	// free an allocated object
	operator delete(ptr);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\difftime.c ===
/***
*difftime.c - return difference between two times as a double
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Find difference between two time in seconds.
*
*******************************************************************************/


#include <cruntime.h>
#include <time.h>
#include <internal.h>

/***
*double _difftime32(b, a) - find difference between two times
*
*Purpose:
*       returns difference between two times (b-a)
*
*Entry:
*       __time32_t a, b - times to difference
*
*Exit:
*       returns a double with the time in seconds between two times
*       0 if input is invalid
*
*Exceptions:
*
*******************************************************************************/

double __cdecl _difftime32 (
        __time32_t b,
        __time32_t a
        )
{
        _VALIDATE_RETURN_NOEXC(
            ( ( a >= 0 ) && ( b >= 0 ) ),
            EINVAL,
            0
        )

        return( (double)( b - a ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\difftm64.c ===
/***
*difftm64.c - return difference between two times as a double
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Find difference between two time in seconds.
*
*******************************************************************************/


#include <cruntime.h>
#include <time.h>
#include <internal.h>

/***
*double _difftime64(b, a) - find difference between two times
*
*Purpose:
*       returns difference between two times (b-a)
*
*Entry:
*       __time64_t a, b - times to difference
*
*Exit:
*       returns a double with the time in seconds between two times
*       0 if input is invalid
*
*Exceptions:
*
*******************************************************************************/

double __cdecl _difftime64 (
        __time64_t b,
        __time64_t a
        )
{
        _VALIDATE_RETURN_NOEXC(
            ( ( a >= 0 ) && ( b >= 0 ) ),
            EINVAL,
            0
        )

        return( (double)( b - a ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This include file contains the function declarations for the library
*       functions related to directory handling and creation.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_DIRECT
#define _INC_DIRECT

#include <crtdefs.h>

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* _getdiskfree structure for _getdiskfree() */
#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif  /* _DISKFREE_T_DEFINED */

/* function prototypes */

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_getcwd")
#pragma push_macro("_getdcwd")
#pragma push_macro("_getdcwd_nolock")
#undef _getcwd
#undef _getdcwd
#undef _getdcwd_nolock
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _Ret_opt_z_ _CRTIMP char * __cdecl _getcwd(_Out_opt_cap_(_SizeInBytes) char * _DstBuf, _In_ int _SizeInBytes);
_Check_return_ _Ret_opt_z_ _CRTIMP char * __cdecl _getdcwd(_In_ int _Drive, _Out_opt_cap_(_SizeInBytes) char * _DstBuf, _In_ int _SizeInBytes);
_Check_return_ _Ret_opt_z_ char * __cdecl _getdcwd_nolock(_In_ int _Drive, _Out_opt_cap_(_SizeInBytes) char * _DstBuf, _In_ int _SizeInBytes);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_getcwd")
#pragma pop_macro("_getdcwd")
#pragma pop_macro("_getdcwd_nolock")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP int __cdecl _chdir(_In_z_ const char * _Path);
_Check_return_ _CRTIMP int __cdecl _mkdir(_In_z_ const char * _Path);
_Check_return_ _CRTIMP int __cdecl _rmdir(_In_z_ const char * _Path);

_Check_return_ _CRTIMP int __cdecl _chdrive(_In_ int _Drive);
_Check_return_ _CRTIMP int __cdecl _getdrive(void);
_Check_return_ _CRTIMP unsigned long __cdecl _getdrives(void);

#ifndef _GETDISKFREE_DEFINED
_Check_return_ _CRTIMP unsigned __cdecl _getdiskfree(_In_ unsigned _Drive, _Out_ struct _diskfree_t * _DiskFree);
#define _GETDISKFREE_DEFINED
#endif  /* _GETDISKFREE_DEFINED */


#ifndef _WDIRECT_DEFINED

/* wide function prototypes, also declared in wchar.h  */

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("_wgetcwd")
#pragma push_macro("_wgetdcwd")
#pragma push_macro("_wgetdcwd_nolock")
#undef _wgetcwd
#undef _wgetdcwd
#undef _wgetdcwd_nolock
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wgetcwd(_Out_opt_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ int _SizeInWords);
_Check_return_ _Ret_opt_z_ _CRTIMP wchar_t * __cdecl _wgetdcwd(_In_ int _Drive, _Out_opt_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ int _SizeInWords);
_Check_return_ _Ret_opt_z_ wchar_t * __cdecl _wgetdcwd_nolock(_In_ int _Drive, _Out_opt_cap_(_SizeInWords) wchar_t * _DstBuf, _In_ int _SizeInWords);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("_wgetcwd")
#pragma pop_macro("_wgetdcwd")
#pragma pop_macro("_wgetdcwd_nolock")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRTIMP int __cdecl _wchdir(_In_z_ const wchar_t * _Path);
_Check_return_ _CRTIMP int __cdecl _wmkdir(_In_z_ const wchar_t * _Path);
_Check_return_ _CRTIMP int __cdecl _wrmdir(_In_z_ const wchar_t * _Path);

#define _WDIRECT_DEFINED
#endif  /* _WDIRECT_DEFINED */

#if !__STDC__

/* Non-ANSI names for compatibility */
#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma push_macro("getcwd")
#undef getcwd
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _Ret_opt_z_ _CRT_NONSTDC_DEPRECATE(_getcwd) _CRTIMP char * __cdecl getcwd(_Out_opt_cap_(_SizeInBytes) char * _DstBuf, _In_ int _SizeInBytes);

#if defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC)
#pragma pop_macro("getcwd")
#endif  /* defined (_DEBUG) && defined (_CRTDBG_MAP_ALLOC) */

_Check_return_ _CRT_NONSTDC_DEPRECATE(_chdir) _CRTIMP int __cdecl chdir(_In_z_ const char * _Path);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_mkdir) _CRTIMP int __cdecl mkdir(_In_z_ const char * _Path);
_Check_return_ _CRT_NONSTDC_DEPRECATE(_rmdir) _CRTIMP int __cdecl rmdir(_In_z_ const char * _Path);

#define diskfree_t  _diskfree_t

#endif  /* !__STDC__ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DIRECT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgrpt.c ===
/***
*dbgrpt.c - Debug CRT Reporting Functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#ifdef _DEBUG

#include <internal.h>
#include <mtdll.h>
#include <malloc.h>
#include <mbstring.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <dbgint.h>
#include <signal.h>
#include <string.h>
#include <awint.h>
#include <windows.h>
#include <errno.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/*---------------------------------------------------------------------------
 *
 * Debug Reporting
 *
 --------------------------------------------------------------------------*/

extern _CRT_REPORT_HOOK _pfnReportHook;
extern ReportHookNode *_pReportHookList;
extern ReportHookNodeW *_pReportHookListW;

_CRTIMP int __cdecl _VCrtDbgReportA(
        int nRptType,
        const char * szFile,
        int nLine,
        const char * szModule,
        const char * szFormat,
        va_list arglist
        );

_CRTIMP int __cdecl _VCrtDbgReportW(
        int nRptType,
        const wchar_t * szFile,
        int nLine,
        const wchar_t * szModule,
        const wchar_t * szFormat,
        va_list arglist
        );

static const TCHAR * const _CrtDbgModeMsg[_CRT_ERRCNT] =
    {
        _T("Warning"),
        _T("Error"),
        _T("Assertion Failed")
    };

/***
*_CRT_REPORT_HOOK _CrtSetReportHook2() - configure client report hook in list
*
*Purpose:
*       Install or remove a client report hook from the report list.  Exists
*       separately from _CrtSetReportHook because the older function doesn't
*       work well in an environment where DLLs that are loaded and unloaded
*       dynamically out of LIFO order want to install report hooks.
*       This function exists in 2 forms - ANSI & UNICODE
*
*Entry:
*       int mode - _CRT_RPTHOOK_INSTALL or _CRT_RPTHOOK_REMOVE
*       _CRT_REPORT_HOOK pfnNewHook - report hook to install/remove/query
*
*Exit:
*       Returns -1 if an error was encountered, with EINVAL or ENOMEM set,
*       else returns the reference count of pfnNewHook after the call.
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
_CRTIMP int __cdecl _CrtSetReportHookT2(
        int mode,
        _CRT_REPORT_HOOKT pfnNewHook
        )
{
        ReportHookNodeT *p;
        int ret;

        /* validation section */
        _VALIDATE_RETURN(mode == _CRT_RPTHOOK_INSTALL || mode == _CRT_RPTHOOK_REMOVE, EINVAL, -1);
        _VALIDATE_RETURN(pfnNewHook != NULL, EINVAL, -1);

        _mlock(_DEBUG_LOCK);
        __try
        {

        /* Search for new hook function to see if it's already installed */
        for (p = _pReportHookListT; p != NULL; p = p->next)
            if (p->pfnHookFunc == pfnNewHook)
                break;

        if (mode == _CRT_RPTHOOK_REMOVE)
        {
            /* Remove request - free list node if refcount goes to zero */
            if (p != NULL)
            {
                if ((ret = --p->refcount) == 0)
                {
                    if (p->next)
                        p->next->prev = p->prev;
                    if (p->prev)
                        p->prev->next = p->next;
                    else
                        _pReportHookListT = p->next;
                    _free_crt(p);
                }
            }
            else
            {
                _ASSERTE(("The hook function is not in the list!",0));
                ret = -1;
                errno = EINVAL;
            }
        }
        else
        {
            /* Insert request */
            if (p != NULL)
            {
                /* Hook function already registered, move to head of list */
                ret = ++p->refcount;
                if (p != _pReportHookListT)
                {
                    if (p->next)
                        p->next->prev = p->prev;
                    p->prev->next = p->next;
                    p->prev = NULL;
                    p->next = _pReportHookListT;
                    _pReportHookListT->prev = p;
                    _pReportHookListT = p;
                }
            }
            else
            {
                /* Hook function not already registered, insert new node */
                p = (ReportHookNodeT *)_malloc_crt(sizeof(ReportHookNodeT));
                if (p == NULL)
                {
                    /* malloc fails: we do not assert here */
                    ret = -1;
                    errno = ENOMEM;
                }
                else
                {
                    p->prev = NULL;
                    p->next = _pReportHookListT;
                    if (_pReportHookListT)
                        _pReportHookListT->prev = p;
                    ret = p->refcount = 1;
                    p->pfnHookFunc = pfnNewHook;
                    _pReportHookListT = p;
                }
            }
        }

        }
        __finally {
            _munlock(_DEBUG_LOCK);
        }

        return ret;
}


static TCHAR * dotdotdot = _T("...");
#define MAXLINELEN 64
#define DOTDOTDOTSZ 3

/***
*int _CrtDbgReport() - primary reporting function
*
*Purpose:
*       Display a message window with the following format.
*
*       ================= Microsft Visual C++ Debug Library ================
*
*       {Warning! | Error! | Assertion Failed!}
*
*       Program: c:\test\mytest\foo.exe
*       [Module: c:\test\mytest\bar.dll]
*       [File: c:\test\mytest\bar.c]
*       [Line: 69]
*
*       {<warning or error message> | Expression: <expression>}
*
*       [For information on how your program can cause an assertion
*        failure, see the Visual C++ documentation on asserts]
*
*       (Press Retry to debug the application)
*
*       ===================================================================
*
*Entry:
*       int             nRptType    - report type
*       const TCHAR *    szFile      - file name
*       int             nLine       - line number
*       const TCHAR *    szModule    - module name
*       const TCHAR *    szFormat    - format string
*       ...                         - var args
*
*Exit:
*       if (MessageBox)
*       {
*           Abort -> aborts
*           Retry -> return TRUE
*           Ignore-> return FALSE
*       }
*       else
*           return FALSE
*
*Exceptions:
*       If something goes wrong, we do not assert, but we return -1.
*
*******************************************************************************/
__inline int __cdecl _CrtDbgReportTV(
        int nRptType,
        const TCHAR * szFile,
        int nLine,
        const TCHAR * szModule,
        const TCHAR * szFormat,
        va_list arglist
        )
{
    return _VCrtDbgReportT(nRptType,szFile,nLine,szModule,szFormat,arglist);
}

_CRTIMP int __cdecl _CrtDbgReportT(
        int nRptType,
        const TCHAR * szFile,
        int nLine,
        const TCHAR * szModule,
        const TCHAR * szFormat,
        ...
        )
{
    int retval;
    va_list arglist;

    va_start(arglist,szFormat);

    retval = _CrtDbgReportTV(nRptType, szFile, nLine, szModule, szFormat, arglist);

    va_end(arglist);

    return retval;
}

/***
*int __crtMessageWindow() - report to a message window
*
*Purpose:
*       put report into message window, allow user to choose action to take
*
*Entry:
*       int             nRptType      - report type
*       const TCHAR *    szFile        - file name
*       const TCHAR *    szLine        - line number
*       const TCHAR *    szModule      - module name
*       const TCHAR *    szUserMessage - user message
*
*Exit:
*       if (MessageBox)
*       {
*           Abort -> aborts
*           Retry -> return TRUE
*           Ignore-> return FALSE
*       }
*       else
*           return FALSE
*
*Exceptions:
*       If something goes wrong, we do not assert, but we simply return -1,
*       which will trigger the debugger automatically (the same as the user
*       pressing the Retry button).
*
*******************************************************************************/

int __cdecl __crtMessageWindow(
        int nRptType,
        const TCHAR * szFile,
        const TCHAR * szLine,
        const TCHAR * szModule,
        const TCHAR * szUserMessage
        )
{
        int nCode;
        TCHAR *szShortProgName;
        const TCHAR *szShortModuleName = NULL ;
        TCHAR szExeName[MAX_PATH + 1];
        TCHAR szOutMessage[DBGRPT_MAX_MSG];
        int szlen = 0;

        if (szUserMessage == NULL)
            return 1;

        /* Shorten program name */
        szExeName[MAX_PATH] = _T('\0');
        if (!GetModuleFileName(NULL, szExeName, MAX_PATH))
            _ERRCHECK(_tcscpy_s(szExeName, MAX_PATH, _T("<program name unknown>")));

        szShortProgName = szExeName;

        if (_tcslen(szShortProgName) > MAXLINELEN)
        {
                szShortProgName += _tcslen(szShortProgName) - MAXLINELEN;

                /* Only replace first (sizeof(TCHAR) * DOTDOTDOTSZ) bytes to ellipsis */
                _ERRCHECK(memcpy_s(szShortProgName, sizeof(TCHAR) * (MAX_PATH - (szShortProgName - szExeName)), dotdotdot, sizeof(TCHAR) * DOTDOTDOTSZ));
        }

        /* Shorten module name */
        if (szModule && _tcslen(szModule) > MAXLINELEN)
        {
            szShortModuleName = szModule + _tcslen(szModule) - MAXLINELEN + 3;
        }

        _ERRCHECK_SPRINTF(szlen = _sntprintf_s(szOutMessage, DBGRPT_MAX_MSG, DBGRPT_MAX_MSG - 1,
            _T("Debug %s!\n\nProgram: %s%s%s%s%s%s%s%s%s%s%s%s")
            _T("\n\n(Press Retry to debug the application)"),
            _CrtDbgModeMsg[nRptType],
            szShortProgName,
            szModule ? _T("\nModule: ") : _T(""),
            szShortModuleName ? _T("...") : _T(""),
            szShortModuleName ? szShortModuleName : (szModule ? szModule : _T("")),
            szFile ? _T("\nFile: ") : _T(""),
            szFile ? szFile : _T(""),
            szLine ? _T("\nLine: ") : _T(""),
            szLine ? szLine : _T(""),
            szUserMessage[0] ? _T("\n\n") : _T(""),
            szUserMessage[0] && _CRT_ASSERT == nRptType ? _T("Expression: ") : _T(""),
            szUserMessage[0] ? szUserMessage : _T(""),
            _CRT_ASSERT == nRptType ?
            _T("\n\nFor information on how your program can cause an assertion")
            _T("\nfailure, see the Visual C++ documentation on asserts.")
            : _T("")));
        if (szlen < 0)
#ifdef _UNICODE
            _ERRCHECK(wcscpy_s(szOutMessage, DBGRPT_MAX_MSG, _CRT_WIDE(DBGRPT_TOOLONGMSG)));
#else  /* _UNICODE */
            _ERRCHECK(strcpy_s(szOutMessage, DBGRPT_MAX_MSG, DBGRPT_TOOLONGMSG));
#endif  /* _UNICODE */

        /* Report the warning/error */
        nCode = __crtMessageBox(szOutMessage,
                             _T("Microsoft Visual C++ Debug Library"),
                             MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

        /* Abort: abort the program */
        if (IDABORT == nCode)
        {
            /* note that it is better NOT to call abort() here, because the
             * default implementation of abort() will call Watson
             */

            /* raise abort signal */
            raise(SIGABRT);

            /* We usually won't get here, but it's possible that
               SIGABRT was ignored.  So exit the program anyway. */
            _exit(3);
        }

        /* Retry: return 1 to call the debugger */
        if (IDRETRY == nCode)
            return 1;

        /* Ignore: continue execution */
        return 0;
}

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dbgrptt.c ===
/***
*dbgrptt.c - Debug CRT Reporting Functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#ifdef _DEBUG

#include <internal.h>
#include <mtdll.h>
#include <malloc.h>
#include <mbstring.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <dbgint.h>
#include <signal.h>
#include <string.h>
#include <awint.h>
#include <windows.h>
#include <errno.h>


int __cdecl __crtMessageWindowA(
    int nRptType,
    const char * szFile,
    const char * szLine,
    const char * szModule,
    const char * szUserMessage
    );

int __cdecl __crtMessageWindowW(
    int nRptType,
    const wchar_t * szFile,
    const wchar_t * szLine,
    const wchar_t * szModule,
    const wchar_t * szUserMessage
    );

_CRT_REPORT_HOOK _pfnReportHook;

ReportHookNode *_pReportHookList;
ReportHookNodeW *_pReportHookListW;

_CRTIMP long _crtAssertBusy = -1;

int _CrtDbgMode[_CRT_ERRCNT] = {
    _CRTDBG_MODE_DEBUG,
    _CRTDBG_MODE_WNDW,
    _CRTDBG_MODE_WNDW
};

_HFILE _CrtDbgFile[_CRT_ERRCNT] = { _CRTDBG_INVALID_HFILE,
                                    _CRTDBG_INVALID_HFILE,
                                    _CRTDBG_INVALID_HFILE
};

#define _CrtInterlockedIncrement InterlockedIncrement
#define _CrtInterlockedDecrement InterlockedDecrement

/***
 *void _CrtDebugBreak - call OS-specific debug function
 *
 *Purpose:
 *       call OS-specific debug function
 *
 *Entry:
 *
 *Exit:
 *
 *Exceptions:
 *
 *******************************************************************************/

#undef _CrtDbgBreak

/* These methods don't need a separate
   wchar version. Hence they need to be compiled only once from
   the original file */

_CRTIMP void _cdecl _CrtDbgBreak(
    void
    )
{
    DebugBreak();
}

/***
 *int _CrtSetReportMode - set the reporting mode for a given report type
 *
 *Purpose:
 *       set the reporting mode for a given report type
 *
 *Entry:
 *       int nRptType    - the report type
 *       int fMode       - new mode for given report type
 *
 *Exit:
 *       previous mode for given report type
 *
 *Exceptions:
 *       Input parameters are validated. Refer to the validation section of the function.
 *
 *******************************************************************************/
_CRTIMP int __cdecl _CrtSetReportMode(
    int nRptType,
    int fMode
    )
{
    int oldMode;

    /* validation section */
    _VALIDATE_RETURN(nRptType >= 0 && nRptType < _CRT_ERRCNT, EINVAL, -1);
    _VALIDATE_RETURN(
        fMode == _CRTDBG_REPORT_MODE ||
        (fMode & ~(_CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_WNDW)) == 0,
        EINVAL,
        -1);

    if (fMode == _CRTDBG_REPORT_MODE)
        return _CrtDbgMode[nRptType];

    oldMode = _CrtDbgMode[nRptType];

    _CrtDbgMode[nRptType] = fMode;

    return oldMode;
}

/***
 *int _CrtSetReportFile - set the reporting file for a given report type
 *
 *Purpose:
 *       set the reporting file for a given report type
 *
 *Entry:
 *       int nRptType    - the report type
 *       _HFILE hFile    - new file for given report type
 *
 *Exit:
 *       previous file for given report type
 *
 *Exceptions:
 *       Input parameters are validated. Refer to the validation section of the function.
 *
 *******************************************************************************/
_CRTIMP _HFILE __cdecl _CrtSetReportFile(
    int nRptType,
    _HFILE hFile
    )
{
    _HFILE oldFile;

    /* validation section */
    _VALIDATE_RETURN(nRptType >= 0 && nRptType < _CRT_ERRCNT, EINVAL, _CRTDBG_HFILE_ERROR);

    if (hFile == _CRTDBG_REPORT_FILE)
        return _CrtDbgFile[nRptType];

    oldFile = _CrtDbgFile[nRptType];

    if (_CRTDBG_FILE_STDOUT == hFile)
        _CrtDbgFile[nRptType] = GetStdHandle(STD_OUTPUT_HANDLE);
    else if (_CRTDBG_FILE_STDERR == hFile)
        _CrtDbgFile[nRptType] = GetStdHandle(STD_ERROR_HANDLE);
    else
        _CrtDbgFile[nRptType] = hFile;

    return oldFile;
}

/***
 *_CRT_REPORT_HOOK _CrtSetReportHook() - set client report hook
 *
 *Purpose:
 *       set client report hook. This function is provided only in ANSI
 *       for backward compatibility. No Unicode Version of this function exists
 *
 *Entry:
 *       _CRT_REPORT_HOOK pfnNewHook - new report hook
 *
 *Exit:
 *       return previous hook
 *
 *Exceptions:
 *
 *******************************************************************************/

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(_CRT_REPORT_HOOK pfnNewHook)
{
    _CRT_REPORT_HOOK pfnOldHook = _pfnReportHook;
    _pfnReportHook = pfnNewHook;
    return pfnOldHook;
}

/***
 *_CRT_REPORT_HOOK _CrtGetReportHook() - get client report hook
 *
 *Purpose:
 *       get client report hook.
 *
 *Entry:
 *
 *Exit:
 *       return current hook
 *
 *Exceptions:
 *
 *******************************************************************************/

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void)
{
    return _pfnReportHook;
}

#define ASSERTINTRO1 "Assertion failed: "
#define ASSERTINTRO2 "Assertion failed!"

/***
 *int _VCrtDbgReportA() - _CrtDbgReport calls into this function
 *
 *Purpose:
 *       See remarks for _CrtDbgReport.
 *
 *Entry:
 *       int             nRptType    - report type
 *       const char *    szFile      - file name
 *       int             nLine       - line number
 *       const char *    szModule    - module name
 *       const char *    szFormat    - format string
 *       va_list         arglist      - var args arglist
 *
 *Exit:
 *       See remarks for _CrtDbgReport
 *
 *Exceptions:
 *
 *******************************************************************************/

#pragma warning(push)
#pragma warning(disable:6262)
// prefast (6262): This func uses lots of stack because we want to tolerate very large reports, and we can't use malloc here.
_CRTIMP int __cdecl _VCrtDbgReportA
(
    int nRptType,
    const char * szFile,
    int nLine,
    const char * szModule,
    const char * szFormat,
    va_list arglist
    )
{
    int retval=0;
    int handled=FALSE;
    char szLineMessage[DBGRPT_MAX_MSG] = {0};
    char szOutMessage[DBGRPT_MAX_MSG] = {0};
    wchar_t szOutMessage2[DBGRPT_MAX_MSG] = {0};
    char szUserMessage[DBGRPT_MAX_MSG] = {0};

    if (nRptType < 0 || nRptType >= _CRT_ERRCNT)
        return -1;

    /*
     * handle the (hopefully rare) case of
     *
     * 1) ASSERT while already dealing with an ASSERT
     *      or
     * 2) two threads asserting at the same time
     */

    __try
    {

        if (_CRT_ASSERT == nRptType && _CrtInterlockedIncrement(&_crtAssertBusy) > 0)
        {
            /* use only 'safe' functions -- must not assert in here! */

            _ERRCHECK(_itoa_s(nLine, szLineMessage, DBGRPT_MAX_MSG, 10));

            OutputDebugStringA("Second Chance Assertion Failed: File ");
            OutputDebugStringA(szFile ? szFile : "<file unknown>");
            OutputDebugStringA(", Line ");
            OutputDebugStringA(szLineMessage);
            OutputDebugStringA("\n");

            _CrtDbgBreak();
            retval=-1;
        }
        else
        {

            // Leave space for ASSERTINTRO1 and "\r\n"
            if (szFormat)
            {
                int szlen = 0;
                _ERRCHECK_SPRINTF(szlen = _vsnprintf_s(szUserMessage, DBGRPT_MAX_MSG,
                                                       DBGRPT_MAX_MSG - 2- max(sizeof(ASSERTINTRO1),sizeof(ASSERTINTRO2)),
                                                       szFormat, arglist));
                if (szlen < 0)
                {
                    _ERRCHECK(strcpy_s(szUserMessage, DBGRPT_MAX_MSG, DBGRPT_TOOLONGMSG));
                }
            }

            if (_CRT_ASSERT == nRptType)
                _ERRCHECK(strcpy_s(szLineMessage, DBGRPT_MAX_MSG, szFormat ? ASSERTINTRO1 : ASSERTINTRO2));

            _ERRCHECK(strcat_s(szLineMessage, DBGRPT_MAX_MSG, szUserMessage));

            if (_CRT_ASSERT == nRptType)
            {
                if (_CrtDbgMode[nRptType] & _CRTDBG_MODE_FILE)
                    _ERRCHECK(strcat_s(szLineMessage, DBGRPT_MAX_MSG, "\r"));
                _ERRCHECK(strcat_s(szLineMessage, DBGRPT_MAX_MSG, "\n"));
            }

            if (szFile)
            {
                int szlen = 0;
                _ERRCHECK_SPRINTF(szlen = _snprintf_s(szOutMessage, DBGRPT_MAX_MSG, DBGRPT_MAX_MSG - 1, "%s(%d) : %s",
                                                      szFile, nLine, szLineMessage));
                if (szlen < 0)
                {
                    _ERRCHECK(strcpy_s(szOutMessage, DBGRPT_MAX_MSG, DBGRPT_TOOLONGMSG));
                }
            }
            else
                _ERRCHECK(strcpy_s(szOutMessage, DBGRPT_MAX_MSG, szLineMessage));

            {
                size_t ret = 0;
                errno_t e = 0;
                _ERRCHECK_EINVAL_ERANGE(e = mbstowcs_s(&ret, szOutMessage2, DBGRPT_MAX_MSG, szOutMessage, _TRUNCATE));
                if(e != 0)
                    _ERRCHECK(wcscpy_s(szOutMessage2, DBGRPT_MAX_MSG, _CRT_WIDE(DBGRPT_INVALIDMSG)));

            }

            /* User hook may handle report.
               We have to check the ANSI Hook2 List & then the UNICODE Hook2 List.
               Then we have check any ANSI individual Hook set through
               SetReportHook */

            if (_pReportHookList || _pReportHookListW)
            {
                ReportHookNode *pnode=NULL;
                ReportHookNodeW *pnodeW=NULL;

                _mlock(_DEBUG_LOCK);
                __try
                {
                    for (pnode = _pReportHookList; pnode; pnode = pnode->next)
                    {
                        int hook_retval=0;
                        if ((*pnode->pfnHookFunc)(nRptType, szOutMessage, &hook_retval))
                        {
                            handled=TRUE;
                            retval=hook_retval;
                            break;
                        }
                    }

                    if(!handled)
                    {
                        for (pnodeW = _pReportHookListW; pnodeW; pnodeW = pnodeW->next)
                        {
                            int hook_retval=0;
                            if ((*pnodeW->pfnHookFunc)(nRptType, szOutMessage2, &hook_retval))
                            {
                                handled=TRUE;
                                retval=hook_retval;
                                break;
                            }
                        }
                    }
                }
                __finally
                {
                    _munlock(_DEBUG_LOCK);
                }
            }
            if(!handled)
            {
                if(_pfnReportHook)
                {
                    int hook_retval=0;
                    if(((*_pfnReportHook)(nRptType, szOutMessage, &hook_retval)))
                    {
                        handled=TRUE;
                        retval=hook_retval;
                    }
                }

                if (!handled)
                {
                    if (_CrtDbgMode[nRptType] & _CRTDBG_MODE_FILE)
                    {
                        if (_CrtDbgFile[nRptType] != _CRTDBG_INVALID_HFILE)
                        {
                            DWORD written;
                            WriteFile(_CrtDbgFile[nRptType], szOutMessage, (unsigned long)strlen(szOutMessage), &written, NULL);
                        }
                    }

                    if (_CrtDbgMode[nRptType] & _CRTDBG_MODE_DEBUG)
                    {
                        OutputDebugStringA(szOutMessage);
                    }

                    if (_CrtDbgMode[nRptType] & _CRTDBG_MODE_WNDW)
                    {
                        szLineMessage[0] = 0;
                        if (nLine)
                        {
                            _ERRCHECK(_itoa_s(nLine, szLineMessage, DBGRPT_MAX_MSG, 10));
                        }
                        retval = __crtMessageWindowA(nRptType, szFile, (nLine ? szLineMessage : NULL), szModule, szUserMessage);
                    }
                }
            }
        }
    }
    __finally
    {
        if (_CRT_ASSERT == nRptType)
        {
            _CrtInterlockedDecrement(&_crtAssertBusy);
        }
    }

    return retval;
}
#pragma warning(pop)

/***
 *int _VCrtDbgReportW() - _CrtDbgReportW calls into this function
 *
 *Purpose:
 *       See remarks for _CrtDbgReport.
 *
 *Entry:
 *       int             nRptType    - report type
 *       const wchar_t * szFile      - file name
 *       int             nLine       - line number
 *       const wchar_t * szModule    - module name
 *       const wchar_t * szFormat    - format string
 *       va_list         arglist      - var args arglist
 *
 *Exit:
 *       See remarks for _CrtDbgReport
 *
 *Exceptions:
 *
 *******************************************************************************/

#pragma warning(push)
#pragma warning(disable:6262)
// prefast(6262): This func uses lots of stack because we want to tolerate very large reports, and we can't use malloc here.
_CRTIMP int __cdecl _VCrtDbgReportW
(
    int nRptType,
    const wchar_t * szFile,
    int nLine,
    const wchar_t * szModule,
    const wchar_t * szFormat,
    va_list arglist
    )
{
    int retval=0;
    int handled=FALSE;
    wchar_t szLineMessage[DBGRPT_MAX_MSG] = {0};
    wchar_t szOutMessage[DBGRPT_MAX_MSG] = {0};
    char szOutMessage2[DBGRPT_MAX_MSG] = {0};
    wchar_t szUserMessage[DBGRPT_MAX_MSG] = {0};

    if (nRptType < 0 || nRptType >= _CRT_ERRCNT)
        return -1;

    /*
     * handle the (hopefully rare) case of
     *
     * 1) ASSERT while already dealing with an ASSERT
     *      or
     * 2) two threads asserting at the same time
     */

    __try
    {
        if (_CRT_ASSERT == nRptType && _CrtInterlockedIncrement(&_crtAssertBusy) > 0)
        {
            /* use only 'safe' functions -- must not assert in here! */

            _ERRCHECK(_itow_s(nLine, szLineMessage, DBGRPT_MAX_MSG, 10));

            OutputDebugStringW(L"Second Chance Assertion Failed: File ");
            OutputDebugStringW(szFile ? szFile : L"<file unknown>");
            OutputDebugStringW(L", Line ");
            OutputDebugStringW(szLineMessage);
            OutputDebugStringW(L"\n");

            _CrtDbgBreak();
            retval=-1;
        }
        else
        {

            // Leave space for ASSERTINTRO1 and "\r\n"
            if (szFormat)
            {
                int szlen;
                _ERRCHECK_SPRINTF(szlen = _vsnwprintf_s(szUserMessage, DBGRPT_MAX_MSG,
                                                        DBGRPT_MAX_MSG - 2 -
                                                        (max(sizeof(_CRT_WIDE(ASSERTINTRO1)),sizeof(_CRT_WIDE(ASSERTINTRO2)))/sizeof(wchar_t)),
                                                        szFormat,
                                                        arglist));
                if (szlen < 0)
                {
                    _ERRCHECK(wcscpy_s(szUserMessage, DBGRPT_MAX_MSG, _CRT_WIDE(DBGRPT_TOOLONGMSG)));
                }
            }

            if (_CRT_ASSERT == nRptType)
                _ERRCHECK(wcscpy_s(szLineMessage, DBGRPT_MAX_MSG, szFormat ? _CRT_WIDE(ASSERTINTRO1) : _CRT_WIDE(ASSERTINTRO2)));

            _ERRCHECK(wcscat_s(szLineMessage, DBGRPT_MAX_MSG, szUserMessage));

            if (_CRT_ASSERT == nRptType)
            {
                if (_CrtDbgMode[nRptType] & _CRTDBG_MODE_FILE)
                    _ERRCHECK(wcscat_s(szLineMessage, DBGRPT_MAX_MSG, L"\r"));
                {
                    _ERRCHECK(wcscat_s(szLineMessage, DBGRPT_MAX_MSG, L"\n"));
                }
            }

            if (szFile)
            {
                int szlen = 0;
                _ERRCHECK_SPRINTF(szlen = _snwprintf_s(szOutMessage, DBGRPT_MAX_MSG, DBGRPT_MAX_MSG, L"%s(%d) : %s",
                                                       szFile, nLine, szLineMessage));
                if (szlen < 0)
                    _ERRCHECK(wcscpy_s(szOutMessage, DBGRPT_MAX_MSG, _CRT_WIDE(DBGRPT_TOOLONGMSG)));
            }
            else
            {
                _ERRCHECK(wcscpy_s(szOutMessage, DBGRPT_MAX_MSG, szLineMessage));
            }

            /* scope */
            {
                errno_t e = 0;
                e = _ERRCHECK_EINVAL_ERANGE(wcstombs_s(NULL, szOutMessage2, DBGRPT_MAX_MSG, szOutMessage, _TRUNCATE));
                if(e != 0)
                    _ERRCHECK(strcpy_s(szOutMessage2, DBGRPT_MAX_MSG, DBGRPT_INVALIDMSG));
            }

            /* User hook may handle report.
               We have to check the ANSI Hook2 List & then the UNICODE Hook2 List.
               Then we have check any ANSI individual Hook set through
               SetReportHook */

            if (_pReportHookList || _pReportHookListW)
            {
                ReportHookNode *pnode=NULL;
                ReportHookNodeW *pnodeW=NULL;

                _mlock(_DEBUG_LOCK);
                __try
                {
                    for (pnode = _pReportHookList; pnode; pnode = pnode->next)
                    {
                        int hook_retval=0;
                        if ((*pnode->pfnHookFunc)(nRptType, szOutMessage2, &hook_retval))
                        {
                            retval=hook_retval;
                            handled=TRUE;
                            break;
                        }
                    }

                    if(!handled)
                    {
                        for (pnodeW = _pReportHookListW; pnodeW; pnodeW = pnodeW->next)
                        {
                            int hook_retval=0;
                            if ((*pnodeW->pfnHookFunc)(nRptType, szOutMessage, &hook_retval))
                            {
                                retval=hook_retval;
                                handled=TRUE;
                                break;
                            }
                        }
                    }
                }
                __finally
                {
                    _munlock(_DEBUG_LOCK);
                }
            }
            if(!handled)
            {
                if(_pfnReportHook)
                {
                    int hook_retval=0;
                    if(((*_pfnReportHook)(nRptType, szOutMessage2, &hook_retval)))
                    {
                        retval=hook_retval;
                        handled=TRUE;
                    }
                }

                if (!handled)
                {
                    if (_CrtDbgMode[nRptType] & _CRTDBG_MODE_FILE)
                    {
                        if (_CrtDbgFile[nRptType] != _CRTDBG_INVALID_HFILE)
                        {
                            /* Use WriteConsole for Consoles, WriteFile otherwise */
                            DWORD written;
                            switch(GetFileType(_CrtDbgFile[nRptType]))
                            {
                            case FILE_TYPE_CHAR:
                                if(WriteConsoleW(_CrtDbgFile[nRptType], szOutMessage, (unsigned long)wcslen(szOutMessage), &written, NULL))
                                    break;

                                /* If WriteConsole fails & LastError is ERROR_INVALID_VALUE,
                                   then the console is redirected */
                                if(GetLastError() != ERROR_INVALID_HANDLE)
                                    break;

                            default:
                            {
                                char szaOutMessage[DBGRPT_MAX_MSG];
                                size_t ret = 0;
                                errno_t e = _ERRCHECK_EINVAL_ERANGE(wcstombs_s(&ret, szaOutMessage, DBGRPT_MAX_MSG, szOutMessage, _TRUNCATE));

                                if(e != 0 && e != STRUNCATE)
                                {
                                    WriteFile(_CrtDbgFile[nRptType], szOutMessage, (unsigned long)wcslen(szOutMessage) * 2, &written, NULL);
                                }
                                else
                                {
                                    /* ret counts for the null terminator as well */
                                    if (ret > 0)
                                    {
                                        --ret;
                                    }
                                    WriteFile(_CrtDbgFile[nRptType], szaOutMessage, (unsigned long)ret, &written, NULL);
                                }
                            }
                            }
                        }
                    }

                    if (_CrtDbgMode[nRptType] & _CRTDBG_MODE_DEBUG)
                    {
                        OutputDebugStringW(szOutMessage);
                    }

                    if (_CrtDbgMode[nRptType] & _CRTDBG_MODE_WNDW)
                    {
                        szLineMessage[0] = 0;
                        if (nLine)
                        {
                            _ERRCHECK(_itow_s(nLine, szLineMessage, DBGRPT_MAX_MSG, 10));
                        }
                        retval = __crtMessageWindowW(nRptType, szFile, (nLine ? szLineMessage : NULL), szModule, szUserMessage);
                    }
                }
            }
        }

    }
    __finally
    {
        if (_CRT_ASSERT == nRptType)
        {
            _CrtInterlockedDecrement(&_crtAssertBusy);
        }
    }

    return retval;
}
#pragma warning(pop)

#endif  /* _DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\div.c ===
/***
*div.c - contains the div routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Performs a signed divide and returns quotient
*       and remainder.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>

/***
*div_t div(int numer, int denom) - do signed divide
*
*Purpose:
*       This routine does an divide and returns the results.
*
*Entry:
*       int numer - Numerator passed in on stack
*       int denom - Denominator passed in on stack
*
*Exit:
*       returns quotient and remainder in structure
*
*Exceptions:
*       No validation is done on [denom]* thus, if [denom] is 0,
*       this routine will trap.
*
*******************************************************************************/

div_t __cdecl div (
        int numer,
        int denom
        )
{
        div_t result;

        result.quot = numer / denom;
        result.rem = numer % denom;

        return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dllargv.c ===
/***
*dllargv.c - Dummy _setargv() routine for use with C Run-Time as a DLL (CRTDLL)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object goes into CRTDLL.LIB, which is linked with user programs
*       to use CRTDLL.DLL for C run-time library functions.  If the user
*       program links explicitly with SETARGV.OBJ, this object will not be
*       linked in, and the _setargv() that does get called with set the flag
*       that will enable wildcard expansion.  If SETARGV.OBJ is not linked
*       into the EXE, this object will get called by the CRT start-up stub
*       and the flag to enable wildcard expansion will not be set.
*
*******************************************************************************/


#if defined (CRTDLL) || defined (MRTDLL)

#ifdef CRTDLL
#undef CRTDLL
#endif  /* CRTDLL */

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <cruntime.h>
#include <internal.h>

/***
*_setargv - dummy version for CRTDLL.DLL model only
*
*Purpose:
*       This routine gets called by the C Run-Time start-up code in CRTEXE.C
*       which gets linked into an EXE file linked with CRTDLL.LIB.  It does
*       nothing, but if the user links the EXE with SETARGV.OBJ, this routine
*       will not get called but instead __setargv() will be called.  (In the
*       CRTDLL model, it will set the variable that is passed to _GetMainArgs
*       and enable wildcard expansion in the command line arguments.)
*
*Entry:
*
*Exit:
*       Always return 0 (full version in DLL code returns -1 on error)
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
int __CRTDECL _wsetargv ( void )
#else  /* WPRFLAG */
int __CRTDECL _setargv ( void )
#endif  /* WPRFLAG */
{
        return 0;
}

#endif  /* defined (CRTDLL) || defined (MRTDLL) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\defaultmerr.cpp ===
/***
*crtexe.c - Initialization for console EXE using CRT DLL
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps linking to the CRT DLL.
*       It calls the user's main routine [w]main() or [w]WinMain after
*       performing C Run-Time Library initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrtexe.c   the startup routine for console apps with wide chars
*       crtexew.c   the startup routine for Windows apps
*       wcrtexew.c  the startup routine for Windows apps with wide chars
*
*******************************************************************************/

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>

extern "C"
{
int __defaultmatherr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\delaopnt.cpp ===
// delaopnt -- operator delete[](void *, nothrow_t) REPLACEABLE
#ifdef CRTDLL
#undef CRTDLL
#endif

#ifdef MRTDLL
#undef MRTDLL
#endif

#define _USE_ANSI_CPP // suppress defaultlib directive for Std C++ Lib
#include <new>

extern void __CRTDECL operator delete[](void *ptr) _THROW0();

void __CRTDECL operator delete[](void *ptr,
	const std::nothrow_t&) _THROW0()
	{	// free an allocated object
	operator delete[](ptr);
	}

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V3.10:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the structs and unions used for the direct DOS interface
*       routines; includes macros to access the segment and offset
*       values of far pointers, so that they may be used by the routines; and
*       provides function prototypes for direct DOS interface functions.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_DOS
#define _INC_DOS

#include <crtdefs.h>

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifndef _DISKFREE_T_DEFINED
/* _getdiskfree structure (duplicated in DIRECT.H) */
struct _diskfree_t {
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
        };

#define _DISKFREE_T_DEFINED
#endif  /* _DISKFREE_T_DEFINED */

/* File attribute constants */

#define _A_NORMAL       0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY       0x01    /* Read only file */
#define _A_HIDDEN       0x02    /* Hidden file */
#define _A_SYSTEM       0x04    /* System file */
#define _A_SUBDIR       0x10    /* Subdirectory */
#define _A_ARCH         0x20    /* Archive file */

/* Function prototypes */
#ifndef _GETDISKFREE_DEFINED
_Check_return_ _CRTIMP unsigned __cdecl _getdiskfree(_In_ unsigned _Drive, _Out_ struct _diskfree_t * _DiskFree);
#define _GETDISKFREE_DEFINED
#endif  /* _GETDISKFREE_DEFINED */

#ifdef _M_IX86
void __cdecl _disable(void);
void __cdecl _enable(void);
#endif  /* _M_IX86 */

#if !__STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t  _diskfree_t
#endif  /* !__STDC__ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_DOS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dospawn.c ===
/***
*dospawn.c - spawn a child process
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _dospawn - spawn a child process
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <internal.h>
#include <msdos.h>
#include <process.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <tchar.h>
#include <dbgint.h>
#include <limits.h>

#ifndef WPRFLAG
int _p_overlay = 2;
#endif  /* WPRFLAG */

/***
*int _dospawn(mode, name, cmdblk, envblk) - spawn a child process
*
*Purpose:
*       Spawns a child process
*
*Entry:
*       int mode     - _P_WAIT, _P_NOWAIT, _P_NOWAITO, _P_OVERLAY, or _P_DETACH
*       _TSCHAR *name   - name of program to execute
*       _TSCHAR *cmdblk - parameter block
*       _TSCHAR *envblk - environment block
*
*Exit:
*       _P_OVERLAY: -1 = error, otherwise doesn't return
*       _P_WAIT:    termination code << 8 + result code
*       _P_DETACH: -1 = error, 0 = success
*       others:    PID of process
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
intptr_t __cdecl _wdospawn (
#else  /* WPRFLAG */
intptr_t __cdecl _dospawn (
#endif  /* WPRFLAG */
        int mode,
        const _TSCHAR *name,
        _TSCHAR *cmdblk,
        _TSCHAR *envblk
        )
{
        char syncexec, asyncresult, background;
        LPTSTR CommandLine;
        STARTUPINFO StartupInfo;
        PROCESS_INFORMATION ProcessInformation;
        BOOL CreateProcessStatus;
        ULONG dosretval;                /* OS return value */
        DWORD exitcode;
        intptr_t retval;
        DWORD fdwCreate = 0;            /* flags for CreateProcess */
        int i;
        ioinfo *pio;
        char *posfile;
        UNALIGNED intptr_t *posfhnd;
        int nh;                         /* number of file handles to be
                                           passed to the child */

        /* translate input mode value to individual flags */
        syncexec = asyncresult = background = 0;
        switch (mode) {
        case _P_WAIT:    syncexec=1;    break;  /* synchronous execution */
        case 2: /* _P_OVERLAY */
        case _P_NOWAITO: break;                 /* asynchronous execution */
        case _P_NOWAIT:  asyncresult=1; break;  /* asynch + remember result */
        case _P_DETACH:  background=1;  break;  /* detached in null scrn grp */
        default:
            _doserrno = 0;              /* not a Dos error */
            _VALIDATE_RETURN(("invalid mode", 0), EINVAL, -1);
        }

        /*
         * Loop over null separate arguments, and replace null separators
         * with spaces to turn it back into a single null terminated
         * command line.
         */
        CommandLine = cmdblk;
        while (*cmdblk) {
            while (*cmdblk) {
                cmdblk++;
            }

            /*
             * If not last argument, turn null separator into a space.
             */
            if (cmdblk[1] != _T('\0')) {
                *cmdblk++ = _T(' ');
            }
        }

        memset(&StartupInfo,0,sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);

        for ( nh = _nhandle ;
              nh && !_osfile(nh - 1) ;
              nh-- ) ;

        if (nh < 0 ||
            nh >= ((USHRT_MAX - sizeof(int)) / (sizeof(char) + sizeof(intptr_t))))
        {
            errno = ENOMEM;
            return -1;
        }

        StartupInfo.cbReserved2 =
            (unsigned short)(sizeof(int) + (nh * (sizeof(char) + sizeof(intptr_t))));

        StartupInfo.lpReserved2 = _calloc_crt( StartupInfo.cbReserved2, 1 );

        if (!StartupInfo.lpReserved2)
        {
            errno = ENOMEM;
            return -1;
        }

        *((UNALIGNED int *)(StartupInfo.lpReserved2)) = nh;

        posfile = (char *)(StartupInfo.lpReserved2 + sizeof(int));
        posfhnd = (UNALIGNED intptr_t *)(StartupInfo.lpReserved2 +
            sizeof(int) + (nh * sizeof(char)));

        for ( i = 0;
#pragma warning(suppress: 22009) /* Here prefast is very confused by this nh */
              i < nh ;
              i++, posfile++, posfhnd++ )
        {
            pio = _pioinfo(i);
            if ( (pio->osfile & FNOINHERIT) == 0 ) {
                *posfile = pio->osfile;
                *posfhnd = pio->osfhnd;
            }
            else {
                *posfile = 0;
                *posfhnd = (intptr_t)INVALID_HANDLE_VALUE;
            }
        }

        /*
         * if the child process is detached, it cannot access the console, so
         * we must nuke the information passed for the first three handles.
         */
        if ( background ) {

            for ( i = 0,
                  posfile = (char *)(StartupInfo.lpReserved2 + sizeof( int )),
                  posfhnd = (UNALIGNED intptr_t *)(StartupInfo.lpReserved2 + sizeof( int )
                            + (nh * sizeof( char ))) ;
                  i < __min( nh, 3 ) ;
                  i++, posfile++, posfhnd++ )
            {
                *posfile = 0;
                *posfhnd = (intptr_t)INVALID_HANDLE_VALUE;
            }

            fdwCreate |= DETACHED_PROCESS;
        }

        /*
         * errno is set to something non-zero if there are some
         * errors in the spawning
         */
        _doserrno = 0;

#ifdef WPRFLAG
        /* indicate to CreateProcess that environment block is wide */
        fdwCreate |= CREATE_UNICODE_ENVIRONMENT;
#endif  /* WPRFLAG */

        CreateProcessStatus = CreateProcess( (LPTSTR)name,
                                             CommandLine,
                                             NULL,
                                             NULL,
                                             TRUE,
                                             fdwCreate,
                                             envblk,
                                             NULL,
                                             &StartupInfo,
                                             &ProcessInformation
                                           );

        dosretval = GetLastError();
        _free_crt( StartupInfo.lpReserved2 );

        if (!CreateProcessStatus) {
            _dosmaperr(dosretval);
            return -1;
        }

        if (mode == 2 /* _P_OVERLAY */) {
            /* destroy ourselves */
            _exit(0);
        }
        else if (mode == _P_WAIT) {
            WaitForSingleObject(ProcessInformation.hProcess, (DWORD)(-1L));

            /* return termination code and exit code -- note we return
               the full exit code */
            GetExitCodeProcess(ProcessInformation.hProcess, &exitcode);

            retval = (intptr_t)(int)exitcode;

            CloseHandle(ProcessInformation.hProcess);
        }
        else if (mode == _P_DETACH) {
            /* like totally detached asynchronous spawn, dude,
               close process handle, return 0 for success */
            CloseHandle(ProcessInformation.hProcess);
            retval = (intptr_t)0;
        }
        else {
            /* asynchronous spawn -- return PID */
            retval = (intptr_t)ProcessInformation.hProcess;
        }

        CloseHandle(ProcessInformation.hThread);
        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\drivfree.c ===
/***
*drivfree.c - Get the size of a disk
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has _getdiskfree()
*
*******************************************************************************/

#include <cruntime.h>
#include <direct.h>
#include <oscalls.h>
#include <internal.h>

/***
*int _getdiskfree(drivenum, diskfree)  - get size of a specified disk
*
*Purpose:
*       Gets the size of the current or specified disk drive
*
*Entry:
*       int drivenum - 0 for current drive, or drive 1-26
*
*Exit:
*       returns 0 if succeeds
*       returns system error code on error.
*
*Exceptions:
*
*******************************************************************************/

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif  /* _WIN32 */

unsigned __cdecl _getdiskfree (
    unsigned uDrive,
    struct _diskfree_t * pdf
)
{
    char   Root[4];
    char * pRoot;

    _VALIDATE_RETURN((pdf != NULL), EINVAL, ERROR_INVALID_PARAMETER);
    _VALIDATE_RETURN(( uDrive <= 26 ), EINVAL, ERROR_INVALID_PARAMETER);
    memset( pdf, 0, sizeof( struct _diskfree_t ) );

    if ( uDrive == 0 ) {
        pRoot = NULL;
    }
    else {
        pRoot = &Root[0];
        Root[0] = (char)uDrive + (char)('A' - 1);
        Root[1] = ':';
        Root[2] = '\\';
        Root[3] = '\0';
    }


    if ( !GetDiskFreeSpace( pRoot,
        (LPDWORD)&(pdf->sectors_per_cluster),
        (LPDWORD)&(pdf->bytes_per_sector),
        (LPDWORD)&(pdf->avail_clusters),
        (LPDWORD)&(pdf->total_clusters)) )
    {
        int err = GetLastError();
        errno = _get_errno_from_oserr(err);

        return ( err );
    }

    return ( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\delete2.cpp ===
/***
*delete2.cpp - defines C++ vector delete routine
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ delete routine.
*
*******************************************************************************/

#include <cruntime.h>
#include <malloc.h>
#include <new.h>
#include <windows.h>
#include <rtcsup.h>

void operator delete[]( void * p )
{
    RTCCALLBACK(_RTC_Free_hook, (p, 0))

    operator delete(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dtoxtime.c ===
/***
*dtoxtime.c - convert OS local time to __time32_t
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __loctotime32_t() - convert OS local time to internal format
*       (__time32_t).
*
*******************************************************************************/


#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <internal.h>

/***
*__time32_t __loctotime32_t(yr, mo, dy, hr, mn, sc, dstflag) - converts OS local
*       time to internal time format (i.e., a __time32_t value)
*
*Purpose:
*       Converts a local time value, obtained in a broken down format from
*       the host OS, to __time32_t format (i.e., the number elapsed seconds since
*       01-01-70, 00:00:00, UTC).
*
*Entry:
*       int yr, mo, dy -    date
*       int hr, mn, sc -    time
*       int dstflag    -    1 if Daylight Time, 0 if Standard Time, -1 if
*                           not specified.
*
*Exit:
*       Returns calendar time value.
*
*Exceptions:
*
*******************************************************************************/

__time32_t __cdecl __loctotime32_t (
        int yr,         /* 0 based */
        int mo,         /* 1 based */
        int dy,         /* 1 based */
        int hr,
        int mn,
        int sc,
        int dstflag )
{
        int tmpdays;
        __time32_t tmptim;
        struct tm tb;
        int daylight = 0;
        long dstbias = 0;
        long timezone = 0;

        /*
         * Do a range check on the year and convert it to a delta
         * off of 1900.
         */

        _VALIDATE_RETURN_NOEXC(
            ( ( ( yr - 1900 ) >= _BASE_YEAR ) && ( ( yr - 1900 ) <= _MAX_YEAR ) ),
            EINVAL,
            ( ( __time32_t )( -1 ) )
        )
        yr -= 1900;

        _VALIDATE_RETURN_NOEXC(
            ( ( mo >= 1 ) && ( mo <= 12 ) ),
            EINVAL,
            ( ( __time32_t )( -1 ) )
        )
        _VALIDATE_RETURN_NOEXC(
            ( ( hr >= 0 ) && ( hr <= 23 ) ),
            EINVAL,
            ( ( __time32_t )( -1 ) )
        )
        _VALIDATE_RETURN_NOEXC(
            ( ( mn >= 0 ) && ( mn <= 59 ) ),
            EINVAL,
            ( ( __time32_t )( -1 ) )
        )
        _VALIDATE_RETURN_NOEXC(
            ( ( sc >= 0 ) && ( sc <= 59 ) ),
            EINVAL,
            ( ( __time32_t )( -1 ) )
        )
        _VALIDATE_RETURN_NOEXC(
            ( ( dy >= 1 ) && (
                (
                    (_days[mo] - _days[mo - 1]) >= dy) ||               // Make sure that the # of days is in valid range for the month
                    (_IS_LEAP_YEAR(yr) && mo == 2 && dy <= 29)  // Special case for Feb in a leap year
                )
            ),
            EINVAL,
            ( ( __time32_t )( -1 ) )
        )

        /*
         * Compute the number of elapsed days in the current year. Note the
         * test for a leap year would fail in the year 2100, if this was in
         * range (which it isn't).
         */
        tmpdays = dy + _days[mo - 1];
        if ( _IS_LEAP_YEAR(yr) && (mo > 2) )
            tmpdays++;

        /*
         * Compute the number of elapsed seconds since the Epoch. Note the
         * computation of elapsed leap years would break down after 2100
         * if such values were in range (fortunately, they aren't).
         */
        tmptim = /* 365 days for each year */
                 (((__time32_t)yr - _BASE_YEAR) * 365

                 /* one day for each elapsed leap year */
                 + (__time32_t)_ELAPSED_LEAP_YEARS(yr)

                 /* number of elapsed days in yr */
                 + tmpdays)

                 /* convert to hours and add in hr */
                 * 24 + hr;

        tmptim = /* convert to minutes and add in mn */
                 (tmptim * 60 + mn)

                 /* convert to seconds and add in sec */
                 * 60 + sc;

        /*
         * Account for time zone.
         */
        __tzset();

        _ERRCHECK(_get_daylight(&daylight));
        _ERRCHECK(_get_dstbias(&dstbias));
        _ERRCHECK(_get_timezone(&timezone));

        tmptim += timezone;

        /*
         * Fill in enough fields of tb for _isindst(), then call it to
         * determine DST.
         */
        tb.tm_yday = tmpdays;
        tb.tm_year = yr;
        tb.tm_mon  = mo - 1;
        tb.tm_hour = hr;
        tb.tm_min  = mn;
        tb.tm_sec  = sc;
        if ( (dstflag == 1) || ((dstflag == -1) && daylight &&
                                _isindst(&tb)) )
            tmptim += dstbias;
        return(tmptim);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dllmain.c ===
/***
*dllmain.c - Dummy DllMain for user DLLs that have no notification handler
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object goes into LIBC.LIB and LIBCMT.LIB and MSVCRT.LIB for use
*       when linking a DLL with one of the three models of C run-time library.
*       If the user does not provide a DllMain notification routine, this
*       dummy handler will be linked in.  It always returns TRUE (success).
*
******************************************************************************/

#include <oscalls.h>
#define _DECL_DLLMAIN   /* include prototype of _pRawDllMain */
#include <process.h>

/***
*DllMain - dummy version DLLs linked with all 3 C Run-Time Library models
*
*Purpose:
*       The routine DllMain is always called by _DllMainCrtStartup.  If
*       the user does not provide a routine named DllMain, this one will
*       get linked in so that _DllMainCRTStartup has something to call.
*
*       For the LIBC.LIB and MSVCRT.LIB models, the CRTL does not need
*       per-thread notifications so if the user is ignoring them (default
*       DllMain and _pRawDllMain == NULL), just turn them off.  (WIN32-only)
*
*Entry:
*
*Exit:
*
*Exceptions:
*
******************************************************************************/

BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
#if defined (CRTDLL)
        if ( dwReason == DLL_PROCESS_ATTACH && ! _pRawDllMain )
                DisableThreadLibraryCalls(hDllHandle);
#endif  /* defined (CRTDLL) */
        return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\drivemap.c ===
/***
*drivemap.c - _getdrives
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getdrives()
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <direct.h>

#if !defined (_WIN32)
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif  /* !defined (_WIN32) */

/***
*void _getdrivemap(void) - Get bit map of all available drives
*
*Purpose:
*
*Entry:
*
*Exit:
*       drive map with drive A in bit 0, B in 1, etc.
*
*Exceptions:
*
*******************************************************************************/

unsigned long __cdecl _getdrives()
{
    return (GetLogicalDrives());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\drive.c ===
/***
*drive.c - get and change current drive
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file has the _getdrive() and _chdrive() functions
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <mtdll.h>
#include <internal.h>
#include <msdos.h>
#include <errno.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <dbgint.h>


/***
*int _getdrive() - get current drive (1=A:, 2=B:, etc.)
*
*Purpose:
*       Returns the current disk drive
*
*Entry:
*       No parameters.
*
*Exit:
*       returns 1 for A:, 2 for B:, 3 for C:, etc.
*       returns 0 if current drive cannot be determined.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getdrive (
        void
        )
{
        ULONG drivenum=0;
        UCHAR curdirstr[_MAX_PATH+1];
        UCHAR *cdirstr = curdirstr;
        int memfree=0,r=0;

        r = GetCurrentDirectory(MAX_PATH+1,(LPTSTR)cdirstr);
        if (r> MAX_PATH) {
            if ((cdirstr= (UCHAR *)_calloc_crt((r+1),sizeof(UCHAR))) == NULL) {
                errno = ENOMEM;
                r = 0;
            } else {
                memfree = 1;
            }
            if (r)
            {
                r = GetCurrentDirectory(r+1,(LPTSTR)cdirstr);
            }
        }
        drivenum = 0;
        if (r)
        {
                if (cdirstr[1] == ':')
                {
                        drivenum = toupper(cdirstr[0]) - 64;
                }
        }
        else
        {
            errno=ENOMEM;
        }

        if (memfree)
        {
            _free_crt(cdirstr);
        }
        return drivenum;
}


/***
*int _chdrive(int drive) - set the current drive (1=A:, 2=B:, etc.)
*
*Purpose:
*       Allows the user to change the current disk drive
*
*Entry:
*       drive - the number of drive which should become the current drive
*
*Exit:
*       returns 0 if successful, else -1
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _chdrive (
        int drive
        )
{
        int retval;
        char  newdrive[3];

        if (drive < 1 || drive > 26) {
            _doserrno = ERROR_INVALID_DRIVE;
            _VALIDATE_RETURN(("Invalid Drive Index",0), EACCES, -1);
        }

        _mlock( _ENV_LOCK );
        __try {

        newdrive[0] = (char)('A' + (char)drive - (char)1);
        newdrive[1] = ':';
        newdrive[2] = '\0';

        /*
         * Set new drive. If current directory on new drive exists, it
         * will become the cwd. Otherwise defaults to root directory.
         */

        if ( SetCurrentDirectory((LPSTR)newdrive) )
            retval = 0;
        else {
            _dosmaperr(GetLastError());
            retval = -1;
        }

        }
        __finally {
            _munlock( _ENV_LOCK );
        }

        return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dllcrt0.c ===
/***
*dllcrt0.c - C runtime initialization routine for a DLL with linked-in C R-T
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This the startup routine for a DLL which is linked with its own
*       C run-time code.  It is similar to the routine _mainCRTStartup()
*       in the file CRT0.C, except that there is no main() in a DLL.
*
*******************************************************************************/

#ifndef CRTDLL

#include <cruntime.h>
#include <dos.h>
#include <internal.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <rterr.h>
#include <oscalls.h>
#define _DECL_DLLMAIN   /* enable prototypes for DllMain and _CRT_INIT */
#include <process.h>
#include <awint.h>
#include <tchar.h>
#include <dbgint.h>
#include <rtcapi.h>
#include <locale.h>

/*
 * flag set iff _CRTDLL_INIT was called with DLL_PROCESS_ATTACH
 */
static int __proc_attached = 0;

/*
 * command line, environment, and a few other globals
 */
char *_acmdln;              /* points to command line */

char *_aenvptr = NULL;      /* points to environment block */
wchar_t *_wenvptr = NULL;   /* points to wide environment block */

/*
 * _error_mode and _apptype, together, determine how error messages are
 * written out.
 */
int __error_mode = _OUT_TO_DEFAULT;
int __app_type = _UNKNOWN_APP;

/*
 * User routine DllMain is called on all notifications
 */
extern BOOL WINAPI DllMain(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        ) ;

/*
 * _pRawDllMain MUST be an extern const variable, which will be aliased to
 * _pDefaultRawDllMain if no real user definition is present, thanks to the
 * alternatename directive.
 */

extern BOOL (WINAPI * const _pRawDllMain)(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI * const _pDefaultRawDllMain)(HANDLE, DWORD, LPVOID) = NULL;
#if defined (_M_IX86)
#pragma comment(linker, "/alternatename:__pRawDllMain=__pDefaultRawDllMain")
#elif defined (_M_IA64) || defined (_M_AMD64)
#pragma comment(linker, "/alternatename:_pRawDllMain=_pDefaultRawDllMain")
#else  /* defined (_M_IA64) || defined (_M_AMD64) */
#error Unsupported platform
#endif  /* defined (_M_IA64) || defined (_M_AMD64) */

/***
*BOOL WINAPI _CRT_INIT(hDllHandle, dwReason, lpreserved) -
*       C Run-Time initialization for a DLL linked with a C run-time library.
*
*Purpose:
*       This routine does the C run-time initialization or termination.
*       For the multi-threaded run-time library, it also cleans up the
*       multi-threading locks on DLL termination.
*
*Entry:
*
*Exit:
*
*NOTES:
*       This routine must be the entry point for the DLL.
*
*******************************************************************************/

BOOL WINAPI _CRT_INIT(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        /*
         * Start-up code only gets executed when the process is initialized
         */

        if ( dwReason == DLL_PROCESS_ATTACH )
        {
            if ( !_heap_init(1) )   /* initialize heap */
                return FALSE;       /* fail to load DLL */

            if(!_mtinit())          /* initialize multi-thread */
            {
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }

            /*
             * Initialize the Runtime Checks stuff
             */
#ifdef _RTC
            _RTC_Initialize();
#endif  /* _RTC */
            _acmdln = (char *)GetCommandLineA();
            _aenvptr = (char *)__crtGetEnvironmentStringsA();

            if (_ioinit() < 0) {    /* initialize lowio */
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }

            if (_setargv() < 0 ||   /* get cmd line info */
                _setenvp() < 0 ||   /* get environ info */
                _cinit(FALSE) != 0) /* do C data initialize, but don't init floating point */
            {
                _ioterm();          /* shut down lowio */
                _mtterm();          /* free TLS index, call _mtdeletelocks() */
                _heap_term();       /* heap is now invalid! */
                return FALSE;       /* fail to load DLL */
            }

            /* Enable buffer count checking if linking against static lib */
            _CrtSetCheckCount(TRUE);

            /*
             * increment flag to indicate process attach notification
             * has been received
             */
            __proc_attached++;
        }

        else if ( dwReason == DLL_PROCESS_DETACH )
        {
            if ( __proc_attached > 0 )
            {
                __proc_attached--;

                /*
                 * Any basic clean-up code that goes here must be duplicated
                 * below in _DllMainCRTStartup for the case where the user's
                 * DllMain() routine fails on a Process Attach notification.
                 * This does not include calling user C++ destructors, etc.
                 */

                if ( _C_Termination_Done == FALSE )
                    _cexit();

#ifdef _DEBUG
                /* Dump all memory leaks */
                if (_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
                    _CrtDumpMemoryLeaks();
#endif  /* _DEBUG */
                /*
                 * What remains is to clean up the system resources we have
                 * used (handles, critical sections, memory,...,etc.). This
                 * needs to be done if the whole process is NOT terminating.
                 */

#ifndef _DEBUG
                if ( lpreserved == NULL )
                {
#endif  /* _DEBUG */
                    /*
                     * The process is NOT terminating so we must clean up...
                     */
                    /* Shut down lowio */
                    _ioterm();

                    _mtterm();

                    /* This should be the last thing the C run-time does */
                    _heap_term();   /* heap is now invalid! */
#ifndef _DEBUG
                }
#endif  /* _DEBUG */
            }
            else
                /* no prior process attach, just return */
                return FALSE;
        }
        else if ( dwReason == DLL_THREAD_ATTACH )
        {
            _ptiddata ptd;

            /* Initialize FlsGetValue function pointer */
            __set_flsgetvalue();

            if ( ((ptd = _calloc_crt(1, sizeof(struct _tiddata))) != NULL))
            {
                if (FLS_SETVALUE(__flsindex, (LPVOID)ptd) ) {
                    /*
                     * Initialize of per-thread data
                     */
                    _initptd(ptd, NULL);

                    ptd->_tid = GetCurrentThreadId();
                    ptd->_thandle = (uintptr_t)(-1);
                } else
                {
                    _free_crt(ptd);
                    return FALSE;
                }
            } else
            {
                return FALSE;
            }
        }
        else if ( dwReason == DLL_THREAD_DETACH )
        {
            _freeptd(NULL);         /* free up per-thread CRT data */
        }

        return TRUE ;
}

/***
*BOOL WINAPI _DllMainCRTStartup(hDllHandle, dwReason, lpreserved) -
*       C Run-Time initialization for a DLL linked with a C run-time library.
*
*Purpose:
*       This routine does the C run-time initialization or termination
*       and then calls the user code notification handler "DllMain".
*       For the multi-threaded run-time library, it also cleans up the
*       multi-threading locks on DLL termination.
*
*Entry:
*
*Exit:
*
*NOTES:
*       This routine is the preferred entry point. _CRT_INIT may also be
*       used, or the user may supply his/her own entry and call _CRT_INIT
*       from within it, but this is not the preferred method.
*
*******************************************************************************/

static
BOOL __cdecl
__DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        );

BOOL WINAPI
_DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        if (dwReason == DLL_PROCESS_ATTACH)
        {
        /*
         * The /GS security cookie must be initialized before any exception
         * handling targetting the current image is registered.  No function
         * using exception handling can be called in the current image until
         * after __security_init_cookie has been called.
         */
            __security_init_cookie();
        }

        return __DllMainCRTStartup(hDllHandle, dwReason, lpreserved);
}

__declspec(noinline)
BOOL __cdecl
__DllMainCRTStartup(
        HANDLE  hDllHandle,
        DWORD   dwReason,
        LPVOID  lpreserved
        )
{
        BOOL retcode = TRUE;

        /*
         * If this is a process detach notification, check that there has
         * has been a prior process attach notification.
         */
        if ( (dwReason == DLL_PROCESS_DETACH) && (__proc_attached == 0) )
            /*
             * no prior process attach notification. just return
             * without doing anything.
             */
            return FALSE;

        __try {
            if ( dwReason == DLL_PROCESS_ATTACH || dwReason == DLL_THREAD_ATTACH )
            {
                if ( _pRawDllMain )
                    retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);

                if ( retcode )
                    retcode = _CRT_INIT(hDllHandle, dwReason, lpreserved);

                if ( !retcode )
                    return FALSE;
            }

            retcode = DllMain(hDllHandle, dwReason, lpreserved);

            if ( (dwReason == DLL_PROCESS_ATTACH) && !retcode )
            {
                /*
                 * The user's DllMain routine returned failure, the C runtime
                 * needs to be cleaned up. Do this by calling _CRT_INIT again,
                 * this time imitating DLL_PROCESS_DETACH. Note this will also
                 * clear the __proc_attached flag so the cleanup will not be
                 * repeated upon receiving the real process detach notification.
                 */
                DllMain(hDllHandle, DLL_PROCESS_DETACH, lpreserved);
                _CRT_INIT(hDllHandle, DLL_PROCESS_DETACH, lpreserved);
                if (_pRawDllMain)
                {
                    (*_pRawDllMain)(hDllHandle, DLL_PROCESS_DETACH, lpreserved);
                }
            }

            if ( (dwReason == DLL_PROCESS_DETACH) ||
                 (dwReason == DLL_THREAD_DETACH) )
            {
                if ( _CRT_INIT(hDllHandle, dwReason, lpreserved) == FALSE )
                    retcode = FALSE ;

                if ( retcode && _pRawDllMain )
                    retcode = (*_pRawDllMain)(hDllHandle, dwReason, lpreserved);
            }
        } __except ( __CppXcptFilter(GetExceptionCode(), GetExceptionInformation()) ) {
            return FALSE;
        }

        return retcode ;
}

#endif  /* CRTDLL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dosmap.c ===
/***
*dosmap.c - Maps OS errors to errno values
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       _dosmaperr: Maps OS errors to errno values
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <mtdll.h>

/* This is the error table that defines the mapping between OS error
   codes and errno values */

struct errentry {
        unsigned long oscode;           /* OS return value */
        int errnocode;  /* System V error code */
};

static struct errentry errtable[] = {
        {  ERROR_INVALID_FUNCTION,       EINVAL    },  /* 1 */
        {  ERROR_FILE_NOT_FOUND,         ENOENT    },  /* 2 */
        {  ERROR_PATH_NOT_FOUND,         ENOENT    },  /* 3 */
        {  ERROR_TOO_MANY_OPEN_FILES,    EMFILE    },  /* 4 */
        {  ERROR_ACCESS_DENIED,          EACCES    },  /* 5 */
        {  ERROR_INVALID_HANDLE,         EBADF     },  /* 6 */
        {  ERROR_ARENA_TRASHED,          ENOMEM    },  /* 7 */
        {  ERROR_NOT_ENOUGH_MEMORY,      ENOMEM    },  /* 8 */
        {  ERROR_INVALID_BLOCK,          ENOMEM    },  /* 9 */
        {  ERROR_BAD_ENVIRONMENT,        E2BIG     },  /* 10 */
        {  ERROR_BAD_FORMAT,             ENOEXEC   },  /* 11 */
        {  ERROR_INVALID_ACCESS,         EINVAL    },  /* 12 */
        {  ERROR_INVALID_DATA,           EINVAL    },  /* 13 */
        {  ERROR_INVALID_DRIVE,          ENOENT    },  /* 15 */
        {  ERROR_CURRENT_DIRECTORY,      EACCES    },  /* 16 */
        {  ERROR_NOT_SAME_DEVICE,        EXDEV     },  /* 17 */
        {  ERROR_NO_MORE_FILES,          ENOENT    },  /* 18 */
        {  ERROR_LOCK_VIOLATION,         EACCES    },  /* 33 */
        {  ERROR_BAD_NETPATH,            ENOENT    },  /* 53 */
        {  ERROR_NETWORK_ACCESS_DENIED,  EACCES    },  /* 65 */
        {  ERROR_BAD_NET_NAME,           ENOENT    },  /* 67 */
        {  ERROR_FILE_EXISTS,            EEXIST    },  /* 80 */
        {  ERROR_CANNOT_MAKE,            EACCES    },  /* 82 */
        {  ERROR_FAIL_I24,               EACCES    },  /* 83 */
        {  ERROR_INVALID_PARAMETER,      EINVAL    },  /* 87 */
        {  ERROR_NO_PROC_SLOTS,          EAGAIN    },  /* 89 */
        {  ERROR_DRIVE_LOCKED,           EACCES    },  /* 108 */
        {  ERROR_BROKEN_PIPE,            EPIPE     },  /* 109 */
        {  ERROR_DISK_FULL,              ENOSPC    },  /* 112 */
        {  ERROR_INVALID_TARGET_HANDLE,  EBADF     },  /* 114 */
        {  ERROR_INVALID_HANDLE,         EINVAL    },  /* 124 */
        {  ERROR_WAIT_NO_CHILDREN,       ECHILD    },  /* 128 */
        {  ERROR_CHILD_NOT_COMPLETE,     ECHILD    },  /* 129 */
        {  ERROR_DIRECT_ACCESS_HANDLE,   EBADF     },  /* 130 */
        {  ERROR_NEGATIVE_SEEK,          EINVAL    },  /* 131 */
        {  ERROR_SEEK_ON_DEVICE,         EACCES    },  /* 132 */
        {  ERROR_DIR_NOT_EMPTY,          ENOTEMPTY },  /* 145 */
        {  ERROR_NOT_LOCKED,             EACCES    },  /* 158 */
        {  ERROR_BAD_PATHNAME,           ENOENT    },  /* 161 */
        {  ERROR_MAX_THRDS_REACHED,      EAGAIN    },  /* 164 */
        {  ERROR_LOCK_FAILED,            EACCES    },  /* 167 */
        {  ERROR_ALREADY_EXISTS,         EEXIST    },  /* 183 */
        {  ERROR_FILENAME_EXCED_RANGE,   ENOENT    },  /* 206 */
        {  ERROR_NESTING_NOT_ALLOWED,    EAGAIN    },  /* 215 */
        {  ERROR_NOT_ENOUGH_QUOTA,       ENOMEM    }    /* 1816 */
};

/* size of the table */
#define ERRTABLESIZE (sizeof(errtable)/sizeof(errtable[0]))

/* The following two constants must be the minimum and maximum
   values in the (contiguous) range of Exec Failure errors. */
#define MIN_EXEC_ERROR ERROR_INVALID_STARTING_CODESEG
#define MAX_EXEC_ERROR ERROR_INFLOOP_IN_RELOC_CHAIN

/* These are the low and high value in the range of errors that are
   access violations */
#define MIN_EACCES_RANGE ERROR_WRITE_PROTECT
#define MAX_EACCES_RANGE ERROR_SHARING_BUFFER_EXCEEDED


/***
*void _dosmaperr(oserrno) - Map function number
*
*Purpose:
*       This function takes an OS error number, and maps it to the
*       corresponding errno value (based on UNIX System V values). The
*       OS error number is stored in _doserrno (and the mapped value is
*       stored in errno)
*
*Entry:
*       ULONG oserrno = OS error value
*
*Exit:
*       sets _doserrno and errno.
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP void __cdecl _dosmaperr (
        unsigned long oserrno
        )
{
    _doserrno = oserrno;        /* set _doserrno */

    errno = _get_errno_from_oserr(oserrno);
}

int __cdecl _get_errno_from_oserr(
        unsigned long oserrno
        )
{
        int i;

        /* check the table for the OS error code */
        for (i = 0; i < ERRTABLESIZE; ++i) {
                if (oserrno == errtable[i].oscode) {
                        return  errtable[i].errnocode;
                }
        }

        /* The error code wasn't in the table.  We check for a range of */
        /* EACCES errors or exec failure errors (ENOEXEC).  Otherwise   */
        /* EINVAL is returned.                                          */

        if (oserrno >= MIN_EACCES_RANGE && oserrno <= MAX_EACCES_RANGE)
                return EACCES;
        else if (oserrno >= MIN_EXEC_ERROR && oserrno <= MAX_EXEC_ERROR)
                return ENOEXEC;
        else
                return EINVAL;
}

/***
*errno_t _set_errno() - set errno
*
*Purpose:
*       Set the value of errno
*
*Entry:
*       int value
*
*Exit:
*       The error code
*
*Exceptions:
*
*******************************************************************************/
errno_t _set_errno(int value)
{
    _ptiddata ptd = _getptd_noexit();
    if (!ptd)
    {
        return ENOMEM;
    }
    else
    {
        errno = value;
        return 0;
    }
}

/***
*errno_t _get_errno() - get errno
*
*Purpose:
*       Get the value of errno
*
*Entry:
*       int *pValue - pointer where to store the value
*
*Exit:
*       The error code
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
errno_t _get_errno(int *pValue)
{
    /* validation section */
    _VALIDATE_RETURN_NOERRNO(pValue != NULL, EINVAL);

    /* Unlike most of our globals, this one is guaranteed to give some answer */

    *pValue = errno;
    return 0;
}

/***
*errno_t _set_doserrno() - set _doserrno
*
*Purpose:
*       Set the value of _doserrno
*
*Entry:
*       unsigned long value
*
*Exit:
*       The error code
*
*Exceptions:
*
*******************************************************************************/
errno_t _set_doserrno(unsigned long value)
{
    _ptiddata ptd = _getptd_noexit();
    if (!ptd)
    {
        return ENOMEM;
    }
    else
    {
        _doserrno = value;
        return 0;
    }
}

/***
*errno_t _get_doserrno() - get _doserrno
*
*Purpose:
*       Get the value of _doserrno
*
*Entry:
*       unsigned long *pValue - pointer where to store the value
*
*Exit:
*       The error code
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/
errno_t _get_doserrno(unsigned long *pValue)
{
    /* validation section */
    _VALIDATE_RETURN_NOERRNO(pValue != NULL, EINVAL);

    /* Unlike most of our globals, this one is guaranteed to give some answer */

    *pValue = _doserrno;
    return 0;
}


/***
*int * _errno()                 - return pointer to thread's errno
*unsigned long * __doserrno()   - return pointer to thread's _doserrno
*
*Purpose:
*       _errno() returns a pointer to the _terrno field in the current
*       thread's _tiddata structure.
*       __doserrno returns a pointer to the _tdoserrno field in the current
*       thread's _tiddata structure
*
*Entry:
*       None.
*
*Exit:
*       See above.
*
*Exceptions:
*
*******************************************************************************/

static int ErrnoNoMem = ENOMEM;
static unsigned long DoserrorNoMem = ERROR_NOT_ENOUGH_MEMORY;

int * __cdecl _errno(
        void
        )
{
    _ptiddata ptd = _getptd_noexit();
    if (!ptd) {
        return &ErrnoNoMem;
    } else {
        return ( &ptd->_terrno );
    }

}

unsigned long * __cdecl __doserrno(
        void
        )
{
    _ptiddata ptd = _getptd_noexit();
    if (!ptd) {
        return &DoserrorNoMem;
    } else {
        return ( &ptd->_tdoserrno );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dup2.c ===
/***
*dup2.c - Duplicate file handles
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _dup2() - duplicate file handles
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <oscalls.h>
#include <msdos.h>
#include <mtdll.h>
#include <errno.h>
#include <stdlib.h>
#include <internal.h>
#include <malloc.h>
#include <dbgint.h>

static int __cdecl extend_ioinfo_arrays(int);

static int __cdecl _dup2_nolock(int, int);

/***
*int _dup2(fh1, fh2) - force handle 2 to refer to handle 1
*
*Purpose:
*       Forces file handle 2 to refer to the same file as file
*       handle 1.  If file handle 2 referred to an open file, that file
*       is closed.
*
*       Multi-thread: We must hold 2 lowio locks at the same time
*       to ensure multi-thread integrity.  In order to prevent deadlock,
*       we always get the lower file handle lock first.  Order of unlocking
*       does not matter.  If you modify this routine, make sure you don't
*       cause any deadlocks! Scary stuff, kids!!
*
*Entry:
*       int fh1 - file handle to duplicate
*       int fh2 - file handle to assign to file handle 1
*
*Exit:
*       returns 0 if successful, -1 (and sets errno) if fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _dup2 (
        int fh1,
        int fh2
        )
{
        int retcode;

        /* validate file handles */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh1, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh1 >= 0 && (unsigned)fh1 < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh1) & FOPEN), EBADF, -1);
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh2, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN(((unsigned)fh2 < _NHANDLE_), EBADF, -1);

        /*
         * Make sure there is an ioinfo struct corresponding to fh2.
         */
        if ( (fh2 >= _nhandle) && (extend_ioinfo_arrays(fh2) != 0) ) {
                errno = ENOMEM;
                return -1;
        }


        /* get the two file handle locks; in order to prevent deadlock,
           get the lowest handle lock first. */
        if ( fh1 < fh2 ) {
                _lock_fh(fh1);
                _lock_fh(fh2);
        }
        else if ( fh1 > fh2 ) {
                _lock_fh(fh2);
                _lock_fh(fh1);
        }

        __try {
                retcode = _dup2_nolock(fh1, fh2);
        }
        __finally {
                _unlock_fh(fh1);
                _unlock_fh(fh2);
        }

        return retcode;

}

static int __cdecl _dup2_nolock (
        int fh1,
        int fh2
        )
{

        ULONG dosretval;                /* o.s. return code */
        intptr_t new_osfhandle;

        /*
         * Re-test and take care of case of unopened source handle. This is
         * necessary only in the multi-thread case where the file have been
         * closed by another thread before the lock was asserted, but after
         * the initial test above.
         */
        if ( !(_osfile(fh1) & FOPEN) ) {
                /*
                 * Source handle isn't open, bail out with an error.
                 * Note that the DuplicateHandle API will not detect this
                 * error since it implies that _osfhnd(fh1) ==
                 * INVALID_HANDLE_VALUE, and this is a legal HANDLE value
                 * (it's the HANDLE for the current process).
                 */
                errno = EBADF;
                _doserrno = 0;  /* not an OS error */
                _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                return -1;
        }


        /*
         * Take of the case of equal handles.
         */
        if ( fh1 == fh2 )
                /*
                 * Since fh1 is known to be open, return 0 indicating success.
                 * This is in conformance with the POSIX specification for
                 * dup2.
                 */
                return 0;

        /*
         * if fh2 is open, close it.
         */
        if ( _osfile(fh2) & FOPEN )
                /*
                 * close the handle. ignore the possibility of an error - an
                 * error simply means that an OS handle value may remain bound
                 * for the duration of the process.  Use _close_nolock as we
                 * already own lock
                 */
                (void) _close_nolock(fh2);


        /* Duplicate source file onto target file */

        if ( !(DuplicateHandle(GetCurrentProcess(),
                               (HANDLE)_get_osfhandle(fh1),
                               GetCurrentProcess(),
                               (PHANDLE)&new_osfhandle,
                               0L,
                               TRUE,
                               DUPLICATE_SAME_ACCESS)) )
        {

                dosretval = GetLastError();
        }
        else {
                _set_osfhnd(fh2, new_osfhandle);
                dosretval = 0;
        }

        if (dosretval) {
                _dosmaperr(dosretval);
                return -1;
        }

        /* copy the _osfile information, with the FNOINHERIT bit cleared */
        _osfile(fh2) = _osfile(fh1) & ~FNOINHERIT;
        _textmode(fh2) = _textmode(fh1);
        _tm_unicode(fh2) = _tm_unicode(fh1);

        return 0;
}


/***
*static int extend_ioinfo_arrays( int fh ) - extend ioinfo arrays to fh
*
*Purpose:
*       Allocate and initialize arrays of ioinfo structs,filling in
*       __pioinfo[],until there is an ioinfo struct corresponding to fh.
*
*       Note: It is assumed the fh < _NHANDLE_!
*
*Entry:
*       int fh  - C file handle corresponding to ioinfo
*
*Exit:
*       returns 0 if successful, -1
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl extend_ioinfo_arrays(
        int fh
        )
{
        ioinfo *pio;
        int i;

        /*
         * Walk __pioinfo[], allocating an array of ioinfo structs for each
         * empty entry, until there is an ioinfo struct corresponding to fh.
         */
        for ( i = 0 ; fh >= _nhandle ; i++ ) {

            if ( __pioinfo[i] == NULL ) {

                if ( (pio = _calloc_crt( IOINFO_ARRAY_ELTS, sizeof(ioinfo) ))
                     != NULL )
                {
                    __pioinfo[i] = pio;
                    _nhandle += IOINFO_ARRAY_ELTS;

                    for ( ; pio < __pioinfo[i] + IOINFO_ARRAY_ELTS ; pio++ ) {
                        pio->osfile = 0;
                        pio->osfhnd = (intptr_t)INVALID_HANDLE_VALUE;
                        pio->pipech = 10;
                        pio->lockinitflag = 0;
                    }
                }
                else {
                    /*
                     * Couldn't allocate another array, return failure.
                     */
                    return -1;
                }
            }
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\eh.h ===
/***
*eh.h - User include file for exception handling.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       User include file for exception handling.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#include <crtdefs.h>

#ifndef _INC_EH
#define _INC_EH
#ifndef RC_INVOKED
#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */
#ifdef _MSC_VER
/* Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifndef __cplusplus
#error "eh.h is only for C++!"
#endif  /* __cplusplus */

/* terminate_handler is the standard name; terminate_function is supported for historical reasons */
#ifndef _M_CEE_PURE
typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *unexpected_handler)();
#else  /* _M_CEE_PURE */
typedef void (__clrcall *terminate_function)();
typedef void (__clrcall *terminate_handler)();
typedef void (__clrcall *unexpected_function)();
typedef void (__clrcall *unexpected_handler)();
#endif  /* _M_CEE_PURE */

#ifdef _M_CEE
typedef void (__clrcall *__terminate_function_m)();
typedef void (__clrcall *__terminate_handler_m)();
typedef void (__clrcall *__unexpected_function_m)();
typedef void (__clrcall *__unexpected_handler_m)();
#endif  /* _M_CEE */

struct _EXCEPTION_POINTERS;
#ifndef _M_CEE_PURE
typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);
#endif  /* _M_CEE_PURE */

_CRTIMP __declspec(noreturn) void __cdecl terminate(void);
_CRTIMP void __cdecl unexpected(void);

_CRTIMP int __cdecl _is_exception_typeof(_In_ const type_info &_Type, _In_ struct _EXCEPTION_POINTERS * _ExceptionPtr);

#ifndef _M_CEE_PURE
/* only __clrcall versions provided by the MRT exist in pure */
_CRTIMP terminate_function __cdecl set_terminate(_In_opt_ terminate_function _NewPtFunc);
extern "C" _CRTIMP terminate_function __cdecl _get_terminate(void);
_CRTIMP unexpected_function __cdecl set_unexpected(_In_opt_ unexpected_function _NewPtFunc);
extern "C" _CRTIMP unexpected_function __cdecl _get_unexpected(void);
#endif  /* _M_CEE_PURE */

#ifndef _M_CEE_PURE
/* set_se_translator cannot be a managed implementation, and so cannot be called from _M_CEE_PURE code */
_CRTIMP _se_translator_function __cdecl _set_se_translator(_In_opt_ _se_translator_function _NewPtFunc);
#endif  /* _M_CEE_PURE */
_CRTIMP bool __cdecl __uncaught_exception();

/*
 * These overload helps in resolving NULL
 */
#ifdef _M_CEE_MIXED
_CRTIMP terminate_function __cdecl set_terminate(_In_ int _Zero);
_CRTIMP unexpected_function __cdecl set_unexpected(_In_ int _Zero);
#endif  /* _M_CEE_MIXED */

#ifdef _M_CEE
_MRTIMP __terminate_function_m __cdecl set_terminate(_In_opt_ __terminate_function_m _NewPtFunc);
_MRTIMP __unexpected_function_m __cdecl set_unexpected(_In_opt_ __unexpected_function_m _NewPtFunc);
#endif  /* _M_CEE */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* RC_INVOKED */
#endif  /* _INC_EH */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dll_argv.c ===
/***
*dll_argv.c - __setargv() routine for use with C Run-Time as a DLL (CRTDLL)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This object is part of the start-up code for EXE's linked with
*       CRTDLL.LIB/MSVCRT.LIB.  This object will be linked into the user
*       EXE if and only if the user explicitly links with SETARGV.OBJ.
*       The code in this object sets the flag that is passed to the
*       C Run-Time DLL to enable wildcard expansion of the argv[] vector.
*
*******************************************************************************/


#if defined (CRTDLL) || defined (MRTDLL)

#ifdef CRTDLL
#undef CRTDLL
#endif  /* CRTDLL */

#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#include <cruntime.h>
#include <internal.h>

/***
*__setargv - dummy version (for wildcard expansion) for CRTDLL.DLL model only
*
*Purpose:
*       If the EXE that is linked with CRTDLL.LIB is linked explicitly with
*       SETARGV.OBJ, the call to _setargv() in the C Run-Time start-up code
*       (above) will call this routine, instead of calling a dummy version of
*       _setargv() which will do nothing.  This will set to one the static
*       variable which is passed to __getmainargs(), thus enabling wildcard
*       expansion of the command line arguments.
*
*       In the statically-linked C Run-Time models, _setargv() and __setargv()
*       are the actual routines that do the work, but this code exists in
*       CRTDLL.DLL and so some tricks have to be played to make the same
*       SETARGV.OBJ work for EXE's linked with both LIBC.LIB and CRTDLL.LIB.
*
*Entry:
*       The static variable _dowildcard is zero (presumably).
*
*Exit:
*       The static variable _dowildcard is set to one, meaning that the
*       routine __getmainargs() in CRTDLL.DLL *will* do wildcard expansion on
*       the command line arguments.  (The default behavior is that it won't.)
*       Always return 0 (full version in DLL code returns -1 on error)
*
*Exceptions:
*
*******************************************************************************/

extern int _dowildcard; /* should be in <internal.h> */

#ifdef WPRFLAG
int __CRTDECL __wsetargv ( void )
#else  /* WPRFLAG */
int __CRTDECL __setargv ( void )
#endif  /* WPRFLAG */
{
        _dowildcard = 1;
        return 0;
}

#endif  /* defined (CRTDLL) || defined (MRTDLL) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\errmsg.h ===
/***
*errmsg.h - defines error message numbers
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the constants for error message numbers.
*       Same as errmsg.inc
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_ERRMSG

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define STCKOVR 0
#define NULLERR 1
#define NOFP    2
#define DIVZR   3
#define BADVERS 4
#define NOMEM   5
#define BADFORM 6
#define BADENV  7
#define NOARGV  8
#define NOENVP  9
#define ABNORM  10
#define UNKNOWN 11

#define CRT_NERR 11

#define _INC_ERRMSG
#endif  /* _INC_ERRMSG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dup.c ===
/***
*dup.c - duplicate file handles
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _dup() - duplicate file handles
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <mtdll.h>
#include <io.h>
#include <msdos.h>
#include <internal.h>
#include <stdlib.h>

static int __cdecl _dup_nolock(int);

/***
*int _dup(fh) - duplicate a file handle
*
*Purpose:
*       Assigns another file handle to the file associated with the
*       handle fh.  The next available file handle is assigned.
*
*       Multi-thread: Be sure not to hold two file handle locks
*       at the same time!
*
*Entry:
*       int fh - file handle to duplicate
*
*Exit:
*       returns new file handle if successful
*       returns -1 (and sets errno) if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _dup (
        int fh
        )
{
        int newfh =-1;                      /* variable for new file handle */

        /* validate file handle */
        _CHECK_FH_CLEAR_OSSERR_RETURN( fh, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fh >= 0 && (unsigned)fh < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fh) & FOPEN), EBADF, -1);



        _lock_fh(fh);                   /* lock file handle */
        __TRY
                if ( _osfile(fh) & FOPEN )
                        newfh = _dup_nolock(fh);
                else {
                        errno = EBADF;
                        _doserrno = 0;
                        newfh = -1;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        __FINALLY
                _unlock_fh(fh);
        __END_TRY_FINALLY

        return newfh;
}

static int __cdecl _dup_nolock(
        int fh
        )
{
        int newfh;                      /* variable for new file handle */
        ULONG dosretval;                /* o.s. return value */
        char fileinfo;                  /* _osfile info for file */
        intptr_t new_osfhandle;
        int success = FALSE;

        fileinfo = _osfile(fh);         /* get file info for file */

        if ( !(_osfile(fh) & FOPEN) )
                return -1;


        /* create duplicate handle */

        if ( (newfh = _alloc_osfhnd()) == -1 )
        {
                errno = EMFILE;         /* too many files error */
                _doserrno = 0L;         /* not an OS error */
                return -1;              /* return error to caller */
        }
        __TRY

            /*
             * duplicate the file handle
             */
            if ( !(DuplicateHandle(GetCurrentProcess(),
                                   (HANDLE)_get_osfhandle(fh),
                                   GetCurrentProcess(),
                                   (PHANDLE)&new_osfhandle,
                                   0L,
                                   TRUE,
                                   DUPLICATE_SAME_ACCESS)) )
            {
                    dosretval = GetLastError();
            }
            else {
                    _set_osfhnd(newfh, new_osfhandle);
                    dosretval = 0;
            }

            if (dosretval)
                        {
                    /* o.s. error -- map errpr and release handle */
                    _dosmaperr(dosretval);
            }
            else
            {
                    /*
                     * copy the _osfile value, with the FNOINHERIT bit cleared
                     */
                    _osfile(newfh) = fileinfo & ~FNOINHERIT;
                    _textmode(newfh) = _textmode(fh);
                    _tm_unicode(newfh) = _tm_unicode(fh);
                    success = TRUE;
            }

        __FINALLY
            if (!success)
            {
                _osfile(newfh) &= ~FOPEN;
            }
            _unlock_fh(newfh);
        __END_TRY_FINALLY

            return success ? newfh : -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\excpt.h ===
/***
*excpt.h - defines exception values, types and routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the definitions and prototypes for the compiler-
*       dependent intrinsics, support functions and keywords which implement
*       the structured exception handling extensions.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_EXCPT
#define _INC_EXCPT

#include <crtdefs.h>

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/*
 * Exception disposition return values.
 */
typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;


/*
 * Prototype for SEH support function.
 */

#ifdef _M_IX86

/*
 * Declarations to keep MS C 8 (386/486) compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
    _In_ struct _EXCEPTION_RECORD *_ExceptionRecord,
    _In_ void * _EstablisherFrame,
    _Inout_ struct _CONTEXT *_ContextRecord,
    _Inout_ void * _DispatcherContext
    );

#elif defined (_M_IA64)

/*
 * Declarations to keep IA64 compiler happy
 */
typedef struct _EXCEPTION_POINTERS *Exception_info_ptr;
struct _EXCEPTION_RECORD;
struct _CONTEXT;
struct _DISPATCHER_CONTEXT;


_CRTIMP EXCEPTION_DISPOSITION __cdecl __C_specific_handler (
    _In_ struct _EXCEPTION_RECORD *_ExceptionRecord,
    _In_ unsigned __int64 _MemoryStackFp,
    _In_ unsigned __int64 _BackingStoreFp,
    _Inout_ struct _CONTEXT *_ContextRecord,
    _Inout_ struct _DISPATCHER_CONTEXT *_DispatcherContext,
    _In_ unsigned __int64 _GlobalPointer
    );

#elif defined (_M_AMD64)

/*
 * Declarations to keep AMD64 compiler happy
 */
struct _EXCEPTION_RECORD;
struct _CONTEXT;

#endif  /* defined (_M_AMD64) */


/*
 * Keywords and intrinsics for SEH
 */

#ifdef _MSC_VER

#define GetExceptionCode            _exception_code
#define exception_code              _exception_code
#define GetExceptionInformation     (struct _EXCEPTION_POINTERS *)_exception_info
#define exception_info              (struct _EXCEPTION_POINTERS *)_exception_info
#define AbnormalTermination         _abnormal_termination
#define abnormal_termination        _abnormal_termination

unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);

#endif  /* _MSC_VER */


/*
 * Legal values for expression in except().
 */

#define EXCEPTION_EXECUTE_HANDLER       1
#define EXCEPTION_CONTINUE_SEARCH       0
#define EXCEPTION_CONTINUE_EXECUTION    -1


#ifndef _INTERNAL_IFSTRIP_
/*
 * for convenience, define a type name for a pointer to signal-handler
 */

typedef void (__cdecl * _PHNDLR)(int);

/*
 * Exception-action table used by the C runtime to identify and dispose of
 * exceptions corresponding to C runtime errors or C signals.
 */
struct _XCPT_ACTION {

    /*
     * exception code or number. defined by the host OS.
     */
    unsigned long XcptNum;

    /*
     * signal code or number. defined by the C runtime.
     */
    int SigNum;

    /*
     * exception action code. either a special code or the address of
     * a handler function. always determines how the exception filter
     * should dispose of the exception.
     */
    _PHNDLR XcptAction;
};

extern const struct _XCPT_ACTION _XcptActTab[];

/*
 * number of entries in the exception-action table
 */
extern int _XcptActTabCount;

/*
 * size of exception-action table (in bytes)
 */
extern int _XcptActTabSize;

/*
 * index of the first floating point exception entry
 */
extern int _First_FPE_Indx;

/*
 * number of FPE entries
 */
extern int _Num_FPE;

/*
 * return values and prototype for the exception filter function used in the
 * C startup
 */
int __cdecl __CppXcptFilter(_In_ unsigned long _ExceptionNum, _In_ struct _EXCEPTION_POINTERS * _ExceptionPtr);
int __cdecl _XcptFilter(_In_ unsigned long _ExceptionNum, _In_ struct _EXCEPTION_POINTERS * _ExceptionPtr);

#endif  /* _INTERNAL_IFSTRIP_ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_EXCPT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dtoxtm64.c ===
/***
*dtoxtm64.c - convert OS local time to __time64_t
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __loctotime64_t() - convert OS local time to internal format
*       (__time64_t).
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <internal.h>

/***
*__time64_t __loctotime64_t(yr, mo, dy, hr, mn, sc, dstflag) - converts OS
*       local time to internal time format (i.e., a __time64_t value)
*
*Purpose:
*       Converts a local time value, obtained in a broken down format from
*       the host OS, to __time64_t format (i.e., the number elapsed seconds
*       since 01-01-70, 00:00:00, UTC).
*
*Entry:
*       int yr, mo, dy -    date
*       int hr, mn, sc -    time
*       int dstflag    -    1 if Daylight Time, 0 if Standard Time, -1 if
*                           not specified.
*
*Exit:
*       Returns calendar time value.
*
*Exceptions:
*
*******************************************************************************/

__time64_t __cdecl __loctotime64_t (
        int yr,         /* 0 based */
        int mo,         /* 1 based */
        int dy,         /* 1 based */
        int hr,
        int mn,
        int sc,
        int dstflag )
{
        int tmpdays;
        __time64_t tmptim;
        struct tm tb;
        int daylight = 0;
        long dstbias = 0;
        long timezone = 0;

        /*
         * Do a range check on the year and convert it to a delta
         * off of 1900.
         */

        _VALIDATE_RETURN_NOEXC(
            (
                ( ( long )( yr - 1900 ) >= _BASE_YEAR ) &&
                ( ( long )( yr - 1900 ) <= _MAX_YEAR64 )
            ),
            EINVAL,
            ( ( __time64_t )( -1 ) )
        )
        yr -= 1900;

        _VALIDATE_RETURN_NOEXC(
            ( ( mo >= 1 ) && ( mo <= 12 ) ),
            EINVAL,
            ( ( __time64_t )( -1 ) )
        )
        _VALIDATE_RETURN_NOEXC(
            ( ( hr >= 0 ) && ( hr <= 23 ) ),
            EINVAL,
            ( ( __time64_t )( -1 ) )
        )
        _VALIDATE_RETURN_NOEXC(
            ( ( mn >= 0 ) && ( mn <= 59 ) ),
            EINVAL,
            ( ( __time64_t )( -1 ) )
        )
        _VALIDATE_RETURN_NOEXC(
            ( ( sc >= 0 ) && ( sc <= 59 ) ),
            EINVAL,
            ( ( __time64_t )( -1 ) )
        )
        _VALIDATE_RETURN_NOEXC(
            ( ( dy >= 1 ) && (
                (
                    (_days[mo] - _days[mo - 1]) >= dy) ||               // Make sure that the # of days is in valid range for the month
                    (_IS_LEAP_YEAR(yr) && mo == 2 && dy <= 29)  // Special case for Feb in a leap year
                )
            ),
            EINVAL,
            ( ( __time64_t )( -1 ) )
        )

        /*
         * Compute the number of elapsed days in the current year.
         */
        tmpdays = dy + _days[mo - 1];
        if ( _IS_LEAP_YEAR(yr) && (mo > 2) )
            tmpdays++;

        /*
         * Compute the number of elapsed seconds since the Epoch. Note the
         * computation of elapsed leap years would break down after 2100
         * if such values were in range (fortunately, they aren't).
         */
        tmptim = /* 365 days for each year */
                 (((__time64_t)yr - _BASE_YEAR) * 365

                 /* one day for each elapsed leap year */
                 + (__time64_t)_ELAPSED_LEAP_YEARS(yr)

                 /* number of elapsed days in yr */
                 + tmpdays)

                 /* convert to hours and add in hr */
                 * 24 + hr;

        tmptim = /* convert to minutes and add in mn */
                 (tmptim * 60 + mn)

                 /* convert to seconds and add in sec */
                 * 60 + sc;
        /*
         * Account for time zone.
         */
        __tzset();

        _ERRCHECK(_get_daylight(&daylight));
        _ERRCHECK(_get_dstbias(&dstbias));
        _ERRCHECK(_get_timezone(&timezone));

        tmptim += timezone;

        /*
         * Fill in enough fields of tb for _isindst(), then call it to
         * determine DST.
         */
        tb.tm_yday = tmpdays;
        tb.tm_year = yr;
        tb.tm_mon  = mo - 1;
        tb.tm_hour = hr;
        tb.tm_min  = mn;
        tb.tm_sec  = sc;
        if ( (dstflag == 1) || ((dstflag == -1) && daylight &&
                                _isindst(&tb)) )
            tmptim += dstbias;
        return(tmptim);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\execle.c ===
/***
*execle.c - execute a file with arg list and environment
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execle() - execute a file
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execle(filename, arglist) - execute a file
*
*Purpose:
*       Execute the given file (overlays the calling process).
*       We must dig the environment vector out of the stack and pass it
*       and address of argument vector to execve.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list followed by environment
*       should be called like _execle(path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       destroys calling process (hopefully)
*       if fails, returns -1.
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecle (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef _M_IX86

        REG1 const _TSCHAR **e_search = &arglist;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        while (*e_search++)
                ;

        return(_texecve(filename,&arglist,(_TSCHAR **)*e_search));

#else  /* _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else  /* WPRFLAG */
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif  /* WPRFLAG */
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _texecve(filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\emmintrin.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 * emmintrin.h
 *
 * Principal header file for Willamette New Instruction intrinsics
 *
 * The intrinsics package can be used in 2 ways, based whether or not
 * _EMM_FUNCTIONALITY is defined; if it is, the C implementation
 * will be used (the "functional intrinsics").
 */

#pragma once
#ifndef __midl
#ifndef _INCLUDED_EMM
#define _INCLUDED_EMM

#if defined (_M_CEE_PURE)
        #error ERROR: EMM intrinsics not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

/*
 * the __m128 & __m64 types are required for the intrinsics
 */
#include <crtdefs.h>
#include <xmmintrin.h>

typedef union __declspec(intrin_type) _CRT_ALIGN(16) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) _CRT_ALIGN(16) __m128d {
    double              m128d_f64[2];
} __m128d;

/*
 * Macro function for shuffle
 */
#define _MM_SHUFFLE2(x,y) (((x)<<1) | (y))

/*****************************************************/
/*     INTRINSICS FUNCTION PROTOTYPES START HERE     */
/*****************************************************/

#if defined __cplusplus
extern "C" { /* Begin "C" */
  /* Intrinsics use C name-mangling. */
#endif  /* defined __cplusplus */

/*
 * DP, arithmetic
 */

extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);

/*
 * DP, logicals
 */

extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);

/*
 * DP, comparisons
 */

extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);

/*
 * DP, converts
 */

extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);

extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);

/*
 * DP, misc
 */

extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);

/*
 * DP, loads
 */

extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);

/*
 * DP, sets
 */

extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);

/*
 * DP, stores
 */

extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);

/*
 * Integer, arithmetic
 */

extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_add_si64(__m64 _A, __m64 _B);
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);
extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);

/*
 * Integer, logicals
 */

extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);

/*
 * Integer, shifts
 */

extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);

/*
 * Integer, comparisons
 */

extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);

/*
 * Integer, converts
 */

extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);

/*
 * Integer, misc
 */

extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);

/*
 * Integer, loads
 */

extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);

/*
 * Integer, sets
 */

extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_set1_epi64(__m64 _Q);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);
extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);

/*
 * Integer, stores
 */

extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);

/*
 * Integer, moves
 */

extern __m128i _mm_move_epi64(__m128i _Q);
extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);

/*
 * Cacheability support
 */

extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);

/*
 * New convert to float
 */

extern double _mm_cvtsd_f64(__m128d _A);

/*
 * Support for casting between various SP, DP, INT vector types.
 * Note that these do no conversion of values, they just change
 * the type.
 */

extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);

/*
 * Support for 64-bit extension intrinsics
 */

#if defined (_M_AMD64)
extern __int64 _mm_cvtsd_si64(__m128d);
extern __int64 _mm_cvttsd_si64(__m128d);
extern __m128d _mm_cvtsi64_sd(__m128d, __int64);
extern __m128i _mm_cvtsi64_si128(__int64);
extern __int64 _mm_cvtsi128_si64(__m128i);
/* Alternate intrinsic name definitions */
#define _mm_stream_si64 _mm_stream_si64x
#endif  /* defined (_M_AMD64) */

#if defined __cplusplus
}; /* End "C" */
#endif  /* defined __cplusplus */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* _INCLUDED_EMM */
#endif  /* __midl */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\errmode.c ===
/***
*errmode.c - modify __error_mode and __app_type
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _set_error_mode() and __set_app_type(), the routines used
*       to modify __error_mode and __app_type variables. Together, these
*       two variables determine how/where the C runtime writes error
*       messages.
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdlib.h>

/***
*int _set_error_mode(int modeval) - interface to change __error_mode
*
*Purpose:
*       Control the error (output) sink by setting the value of __error_mode.
*       Explicit controls are to direct output t o standard error (FILE * or
*       C handle or NT HANDLE) or to use the MessageBox API. This routine is
*       exposed and documented for the users.
*
*Entry:
*       int modeval =   _OUT_TO_DEFAULT, error sink is determined by __app_type
*                       _OUT_TO_STDERR,  error sink is standard error
*                       _OUT_TO_MSGBOX,  error sink is a message box
*                       _REPORT_ERRMODE, report the current __error_mode value
*
*Exit:
*       Returns old setting or -1 if an error occurs.
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP int __cdecl _set_error_mode (
        int em
        )
{
        int retval=0;

        switch (em) {
            case _OUT_TO_DEFAULT:
            case _OUT_TO_STDERR:
            case _OUT_TO_MSGBOX:
                retval = __error_mode;
                __error_mode = em;
                break;
            case _REPORT_ERRMODE:
                retval = __error_mode;
                break;
            default:
                _VALIDATE_RETURN(("Invalid error_mode", 0), EINVAL, -1);
        }

        return retval;
}

/***
*void __set_app_type(int apptype) - interface to change __app_type
*
*Purpose:
*       Set, or change, the value of __app_type.
*
*       Set the default debug lib report destination for console apps.
*
*       This function is for INTERNAL USE ONLY.
*
*Entry:
*       int modeval =   _UNKNOWN_APP,   unknown
*                       _CONSOLE_APP,   console, or command line, application
*                       _GUI_APP,       GUI, or Windows, application
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP void __cdecl __set_app_type (
        int at
        )
{
        __app_type = at;
}

/***
*int __get_app_type() - interface to retreive __app_type
*
*Purpose:
*       Get, the value of __app_type.
*
*       Get the default debug lib report destination for console apps.
*
*       This function is for INTERNAL USE ONLY.
*
*Exit:
*       int retval  =   _UNKNOWN_APP,   unknown
*                       _CONSOLE_APP,   console, or command line, application
*                       _GUI_APP,       GUI, or Windows, application
*
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP int __cdecl __get_app_type ()
{
    return __app_type;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\dvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Willamette New Instruction intrinsics.
 *
 *      File name : dvec.h  class definitions
 *
 *      Concept: A C++ abstraction of Willamette new intructions designed to improve
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *      Facilitates an easy transition to compiler intrinsics
 *      or assembly language.
 *
 */

#ifndef _DVEC_H_INCLUDED
#define _DVEC_H_INCLUDED
#ifndef RC_INVOKED

#if !defined __cplusplus
        #error ERROR: This file is only supported in C++ compilations!
#endif  /* !defined __cplusplus */

#if defined (_M_CEE_PURE)
        #error ERROR: This file is not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

#include <emmintrin.h> /* Willamette New Instructions Intrinsics include file */
#include <assert.h>
#include <fvec.h>
#include <crtdefs.h>

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined (_ENABLE_VEC_DEBUG)
        #include <iostream>
#endif  /* defined (_ENABLE_VEC_DEBUG) */

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */

#define EXPLICIT explicit

/* EMM Functionality Intrinsics */

class I8vec16;                  /* 16 elements, each element a signed or unsigned char data type */
class Is8vec16;                 /* 16 elements, each element a signed char data type */
class Iu8vec16;                 /* 16 elements, each element an unsigned char data type */
class I16vec8;                  /* 8 elements, each element a signed or unsigned short */
class Is16vec8;                 /* 8 elements, each element a signed short */
class Iu16vec8;                 /* 8 elements, each element an unsigned short */
class I32vec4;                  /* 4 elements, each element a signed or unsigned long */
class Is32vec4;                 /* 4 elements, each element a signed long */
class Iu32vec4;                 /* 4 elements, each element a unsigned long */
class I64vec2;                  /* 2 element, each a __m64 data type */
class I128vec1;                 /* 1 element, a __m128i data type */

#define _MM_16UB(element,vector) (*((unsigned char*)&##vector + ##element))
#define _MM_16B(element,vector) (*((signed char*)&##vector + ##element))

#define _MM_8UW(element,vector) (*((unsigned short*)&##vector + ##element))
#define _MM_8W(element,vector) (*((short*)&##vector + ##element))

#define _MM_4UDW(element,vector) (*((unsigned int*)&##vector + ##element))
#define _MM_4DW(element,vector) (*((int*)&##vector + ##element))

#define _MM_2QW(element,vector) (*((__int64*)&##vector + ##element))


/* We need a m128i constant, keeping performance in mind*/

#pragma warning(push)
#pragma warning(disable : 4640)
inline const __m128i get_mask128()
{
        static const __m128i mask128 = _mm_set1_epi64(M64(0xffffffffffffffffi64));
        return mask128;
}
#pragma warning(pop)


/* M128 Class:
 * 1 element, a __m128i data type
 * Contructors & Logical Operations
 */

class M128
{
protected:
                __m128i vec;

public:
        M128()                                                                  { }
        M128(__m128i mm)                                                { vec = mm; }

        operator __m128i() const                                        { return vec; }

        /* Logical Operations */
        M128& operator&=(const M128 &a)                                 { return *this = (M128) _mm_and_si128(vec,a); }
        M128& operator|=(const M128 &a)                                 { return *this = (M128) _mm_or_si128(vec,a); }
        M128& operator^=(const M128 &a)                                 { return *this = (M128) _mm_xor_si128(vec,a); }

};

inline M128 operator&(const M128 &a, const M128 &b)     { return _mm_and_si128(a,b); }
inline M128 operator|(const M128 &a, const M128 &b)     { return _mm_or_si128(a,b); }
inline M128 operator^(const M128 &a, const M128 &b)     { return _mm_xor_si128(a,b); }
inline M128 andnot(const M128 &a, const M128 &b)        { return _mm_andnot_si128(a,b); }

/* I128vec1 Class:
 * 1 element, a __m128i data type
 * Contains Operations which can operate on any __m6128i data type
 */

class I128vec1 : public M128
{
public:
        I128vec1()                                                              { }
        I128vec1(__m128i mm) : M128(mm)                         { }

        I128vec1& operator= (const M128 &a) { return *this = (I128vec1) a; }
        I128vec1& operator&=(const M128 &a) { return *this = (I128vec1) _mm_and_si128(vec,a); }
        I128vec1& operator|=(const M128 &a) { return *this = (I128vec1) _mm_or_si128(vec,a); }
        I128vec1& operator^=(const M128 &a) { return *this = (I128vec1) _mm_xor_si128(vec,a); }

};

/* I64vec2 Class:
 * 2 elements, each element signed or unsigned 64-bit integer
 */
class I64vec2 : public M128
{
public:
        I64vec2() { }
        I64vec2(__m128i mm) : M128(mm) { }

        I64vec2(__m64 q1, __m64 q0)
        {
                _MM_2QW(0,vec) = *(__int64*)&q0;
                _MM_2QW(1,vec) = *(__int64*)&q1;
        }

        /* Assignment Operator */
        I64vec2& operator= (const M128 &a) { return *this = (I64vec2) a; }

        /* Logical Assignment Operators */
        I64vec2& operator&=(const M128 &a) { return *this = (I64vec2) _mm_and_si128(vec,a); }
        I64vec2& operator|=(const M128 &a) { return *this = (I64vec2) _mm_or_si128(vec,a); }
        I64vec2& operator^=(const M128 &a) { return *this = (I64vec2) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        I64vec2& operator +=(const I64vec2 &a)                  { return *this = (I64vec2) _mm_add_epi64(vec,a); }
        I64vec2& operator -=(const I64vec2 &a)                  { return *this = (I64vec2) _mm_sub_epi64(vec,a); }

        /* Shift Logical Operators */
        I64vec2 operator<<(const I64vec2 &a)                    { return _mm_sll_epi64(vec,a); }
        I64vec2 operator<<(int count)                                   { return _mm_slli_epi64(vec,count); }
        I64vec2& operator<<=(const I64vec2 &a)                  { return *this = (I64vec2) _mm_sll_epi64(vec,a); }
        I64vec2& operator<<=(int count)                                 { return *this = (I64vec2) _mm_slli_epi64(vec,count); }
        I64vec2 operator>>(const I64vec2 &a)                    { return _mm_srl_epi64(vec,a); }
        I64vec2 operator>>(int count)                                   { return _mm_srli_epi64(vec,count); }
        I64vec2& operator>>=(const I64vec2 &a)                  { return *this = (I64vec2) _mm_srl_epi64(vec,a); }
        I64vec2& operator>>=(int count)                                 { return *this = (I64vec2) _mm_srli_epi64(vec,count); }

        /* Element Access for Debug, No data modified */
        const __int64& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 2);       /* Only 2 elements to access */
                return _MM_2QW(i,vec);
        }

        /* Element Access and Assignment for Debug */
        __int64& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 2);       /* Only 2 elements to access */
                return _MM_2QW(i,vec);
        }


};

/* Unpacks */
inline I64vec2 unpack_low(const I64vec2 &a, const I64vec2 &b)   {return _mm_unpacklo_epi64(a,b); }
inline I64vec2 unpack_high(const I64vec2 &a, const I64vec2 &b)  {return _mm_unpackhi_epi64(a,b); }

/* I32vec4 Class:
 * 4 elements, each element either a signed or unsigned int
 */
class I32vec4 : public M128
{
public:
        I32vec4() { }
        I32vec4(__m128i mm) : M128(mm) { }

        /* Assignment Operator */
        I32vec4& operator= (const M128 &a)                              { return *this = (I32vec4) a; }

        /* Logicals Operators */
        I32vec4& operator&=(const M128 &a)                              { return *this = (I32vec4) _mm_and_si128(vec,a); }
        I32vec4& operator|=(const M128 &a)                              { return *this = (I32vec4) _mm_or_si128(vec,a); }
        I32vec4& operator^=(const M128 &a)                              { return *this = (I32vec4) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        I32vec4& operator +=(const I32vec4 &a)                  { return *this = (I32vec4)_mm_add_epi32(vec,a); }
        I32vec4& operator -=(const I32vec4 &a)                  { return *this = (I32vec4)_mm_sub_epi32(vec,a); }

        /* Shift Logical Operators */
        I32vec4 operator<<(const I32vec4 &a)                    { return _mm_sll_epi32(vec,a); }
        I32vec4 operator<<(int count)                                   { return _mm_slli_epi32(vec,count); }
        I32vec4& operator<<=(const I32vec4 &a)                  { return *this = (I32vec4)_mm_sll_epi32(vec,a); }
        I32vec4& operator<<=(int count)                                 { return *this = (I32vec4)_mm_slli_epi32(vec,count); }

};

inline I32vec4 cmpeq(const I32vec4 &a, const I32vec4 &b)            { return _mm_cmpeq_epi32(a,b); }
inline I32vec4 cmpneq(const I32vec4 &a, const I32vec4 &b)           { return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline I32vec4 unpack_low(const I32vec4 &a, const I32vec4 &b)   { return _mm_unpacklo_epi32(a,b); }
inline I32vec4 unpack_high(const I32vec4 &a, const I32vec4 &b)  { return _mm_unpackhi_epi32(a,b); }

/* Is32vec4 Class:
 * 4 elements, each element signed integer
 */
class Is32vec4 : public I32vec4
{
public:
        Is32vec4() { }
        Is32vec4(__m128i mm) : I32vec4(mm) { }
        Is32vec4(int i3, int i2, int i1, int i0)
        {
                _MM_4DW(0,vec) = i0;
                _MM_4DW(1,vec) = i1;
                _MM_4DW(2,vec) = i2;
                _MM_4DW(3,vec) = i3;
        }

        /* Assignment Operator */
        Is32vec4& operator= (const M128 &a)             { return *this = (Is32vec4) a; }

        /* Logical Operators */
        Is32vec4& operator&=(const M128 &a)             { return *this = (Is32vec4) _mm_and_si128(vec,a); }
        Is32vec4& operator|=(const M128 &a)             { return *this = (Is32vec4) _mm_or_si128(vec,a); }
        Is32vec4& operator^=(const M128 &a)             { return *this = (Is32vec4) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Is32vec4& operator +=(const I32vec4 &a) { return *this = (Is32vec4)_mm_add_epi32(vec,a); }
        Is32vec4& operator -=(const I32vec4 &a) { return *this = (Is32vec4)_mm_sub_epi32(vec,a); }

        /* Shift Logical Operators */
        Is32vec4 operator<<(const M128 &a)              { return _mm_sll_epi32(vec,a); }
        Is32vec4 operator<<(int count)                  { return _mm_slli_epi32(vec,count); }
        Is32vec4& operator<<=(const M128 &a)    { return *this = (Is32vec4)_mm_sll_epi32(vec,a); }
        Is32vec4& operator<<=(int count)                { return *this = (Is32vec4)_mm_slli_epi32(vec,count); }
        /* Shift Arithmetic Operations */
        Is32vec4 operator>>(const M128 &a)              { return _mm_sra_epi32(vec,a); }
        Is32vec4 operator>>(int count)                  { return _mm_srai_epi32(vec,count); }
        Is32vec4& operator>>=(const M128 &a)    { return *this = (Is32vec4) _mm_sra_epi32(vec,a); }
        Is32vec4& operator>>=(int count)                { return *this = (Is32vec4) _mm_srai_epi32(vec,count); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator<< (std::ostream &os, const Is32vec4 &a)
        {
                os << "[3]:" << _MM_4DW(3,a)
                        << " [2]:" << _MM_4DW(2,a)
                        << " [1]:" << _MM_4DW(1,a)
                        << " [0]:" << _MM_4DW(0,a);
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const int& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 4);       /* Only 4 elements to access */
                return _MM_4DW(i,vec);
        }

        /* Element Access for Debug */
        int& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 4);       /* Only 4 elements to access */
                return _MM_4DW(i,vec);
        }
};

/* Compares */
inline Is32vec4 cmpeq(const Is32vec4 &a, const Is32vec4 &b)             { return _mm_cmpeq_epi32(a,b); }
inline Is32vec4 cmpneq(const Is32vec4 &a, const Is32vec4 &b)                    { return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }
inline Is32vec4 cmpgt(const Is32vec4 &a, const Is32vec4 &b)                             { return _mm_cmpgt_epi32(a,b); }
inline Is32vec4 cmplt(const Is32vec4 &a, const Is32vec4 &b)                             { return _mm_cmpgt_epi32(b,a); }

/* Unpacks */
inline Is32vec4 unpack_low(const Is32vec4 &a, const Is32vec4 &b)                { return _mm_unpacklo_epi32(a,b); }
inline Is32vec4 unpack_high(const Is32vec4 &a, const Is32vec4 &b)               { return _mm_unpackhi_epi32(a,b); }



/* Iu32vec4 Class:
 * 4 elements, each element unsigned int
 */
class Iu32vec4 : public I32vec4
{
public:
        Iu32vec4() { }
        Iu32vec4(__m128i mm) : I32vec4(mm) { }
        Iu32vec4(unsigned int ui3, unsigned int ui2, unsigned int ui1, unsigned int ui0)
        {
                _MM_4UDW(0,vec) = ui0;
                _MM_4UDW(1,vec) = ui1;
                _MM_4UDW(2,vec) = ui2;
                _MM_4UDW(3,vec) = ui3;
        }

        /* Assignment Operator */
        Iu32vec4& operator= (const M128 &a)             { return *this = (Iu32vec4) a; }

        /* Logical Assignment Operators */
        Iu32vec4& operator&=(const M128 &a)             { return *this = (Iu32vec4) _mm_and_si128(vec,a); }
        Iu32vec4& operator|=(const M128 &a)             { return *this = (Iu32vec4) _mm_or_si128(vec,a); }
        Iu32vec4& operator^=(const M128 &a)             { return *this = (Iu32vec4) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Iu32vec4& operator +=(const I32vec4 &a) { return *this = (Iu32vec4)_mm_add_epi32(vec,a); }
        Iu32vec4& operator -=(const I32vec4 &a) { return *this = (Iu32vec4)_mm_sub_epi32(vec,a); }

        /* Shift Logical Operators */
        Iu32vec4 operator<<(const M128 &a)                              { return _mm_sll_epi32(vec,a); }
        Iu32vec4 operator<<(int count)                                  { return _mm_slli_epi32(vec,count); }
        Iu32vec4& operator<<=(const M128 &a)                    { return *this = (Iu32vec4)_mm_sll_epi32(vec,a); }
        Iu32vec4& operator<<=(int count)                                { return *this = (Iu32vec4)_mm_slli_epi32(vec,count); }
        Iu32vec4 operator>>(const M128 &a)                              { return _mm_srl_epi32(vec,a); }
        Iu32vec4 operator>>(int count)                                  { return _mm_srli_epi32(vec,count); }
        Iu32vec4& operator>>=(const M128 &a)                    { return *this = (Iu32vec4) _mm_srl_epi32(vec,a); }
        Iu32vec4& operator>>=(int count)                                { return *this = (Iu32vec4) _mm_srli_epi32(vec,count); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator<< (std::ostream &os, const Iu32vec4 &a)
        {
                os << "[3]:" << _MM_4UDW(3,a)
                        << " [2]:" << _MM_4UDW(2,a)
                        << " [1]:" << _MM_4UDW(1,a)
                        << " [0]:" << _MM_4UDW(0,a);
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const unsigned int& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 4);       /* Only 4 elements to access */
                return _MM_4UDW(i,vec);
        }

        /* Element Access and Assignment for Debug */
        unsigned int& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 4);       /* Only 4 elements to access */
                return _MM_4UDW(i,vec);
        }
};

inline I64vec2 operator*(const Iu32vec4 &a, const Iu32vec4 &b) { return _mm_mul_epu32(a,b); }
inline Iu32vec4 cmpeq(const Iu32vec4 &a, const Iu32vec4 &b)     { return _mm_cmpeq_epi32(a,b); }
inline Iu32vec4 cmpneq(const Iu32vec4 &a, const Iu32vec4 &b)    { return _mm_andnot_si128(_mm_cmpeq_epi32(a,b), get_mask128()); }

inline Iu32vec4 unpack_low(const Iu32vec4 &a, const Iu32vec4 &b)        { return _mm_unpacklo_epi32(a,b); }
inline Iu32vec4 unpack_high(const Iu32vec4 &a, const Iu32vec4 &b)       { return _mm_unpackhi_epi32(a,b); }

/* I16vec8 Class:
 * 8 elements, each element either unsigned or signed short
 */
class I16vec8 : public M128
{
public:
        I16vec8() { }
        I16vec8(__m128i mm) : M128(mm) { }

        /* Assignment Operator */
        I16vec8& operator= (const M128 &a)              { return *this = (I16vec8) a; }

        /* Logical Assignment Operators */
        I16vec8& operator&=(const M128 &a)              { return *this = (I16vec8) _mm_and_si128(vec,a); }
        I16vec8& operator|=(const M128 &a)              { return *this = (I16vec8) _mm_or_si128(vec,a); }
        I16vec8& operator^=(const M128 &a)              { return *this = (I16vec8) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        I16vec8& operator +=(const I16vec8 &a)  { return *this = (I16vec8) _mm_add_epi16(vec,a); }
        I16vec8& operator -=(const I16vec8 &a)  { return *this = (I16vec8) _mm_sub_epi16(vec,a); }
        I16vec8& operator *=(const I16vec8 &a)  { return *this = (I16vec8) _mm_mullo_epi16(vec,a); }

        /* Shift Logical Operators */
        I16vec8 operator<<(const M128 &a)                               { return _mm_sll_epi16(vec,a); }
        I16vec8 operator<<(int count)                           { return _mm_slli_epi16(vec,count); }
        I16vec8& operator<<=(const M128 &a)                             { return *this = (I16vec8)_mm_sll_epi16(vec,a); }
        I16vec8& operator<<=(int count)                                 { return *this = (I16vec8)_mm_slli_epi16(vec,count); }

};


inline I16vec8 operator*(const I16vec8 &a, const I16vec8 &b)    { return _mm_mullo_epi16(a,b); }

inline I16vec8 cmpeq(const I16vec8 &a, const I16vec8 &b)                { return _mm_cmpeq_epi16(a,b); }
inline I16vec8 cmpneq(const I16vec8 &a, const I16vec8 &b)               { return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline I16vec8 unpack_low(const I16vec8 &a, const I16vec8 &b)   { return _mm_unpacklo_epi16(a,b); }
inline I16vec8 unpack_high(const I16vec8 &a, const I16vec8 &b)  { return _mm_unpackhi_epi16(a,b); }

/* Is16vec8 Class:
 * 8 elements, each element signed short
 */
class Is16vec8 : public I16vec8
{
public:
        Is16vec8() { }
        Is16vec8(__m128i mm) : I16vec8(mm) { }
        Is16vec8(signed short s7,signed short s6,signed short s5,signed short s4,signed short s3,signed short s2,signed short s1,signed short s0)
         {
                _MM_8W(0,vec) = s0;
                _MM_8W(1,vec) = s1;
                _MM_8W(2,vec) = s2;
                _MM_8W(3,vec) = s3;
                _MM_8W(4,vec) = s4;
                _MM_8W(5,vec) = s5;
                _MM_8W(6,vec) = s6;
                _MM_8W(7,vec) = s7;
        }

        /* Assignment Operator */
        Is16vec8& operator= (const M128 &a)             { return *this = (Is16vec8) a; }

        /* Logical Assignment Operators */
        Is16vec8& operator&=(const M128 &a)             { return *this = (Is16vec8) _mm_and_si128(vec,a); }
        Is16vec8& operator|=(const M128 &a)             { return *this = (Is16vec8) _mm_or_si128(vec,a); }
        Is16vec8& operator^=(const M128 &a)             { return *this = (Is16vec8) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Is16vec8& operator +=(const I16vec8 &a) { return *this = (Is16vec8) _mm_add_epi16(vec,a); }
        Is16vec8& operator -=(const I16vec8 &a) { return *this = (Is16vec8) _mm_sub_epi16(vec,a); }
        Is16vec8& operator *=(const I16vec8 &a) { return *this = (Is16vec8) _mm_mullo_epi16(vec,a); }

        /* Shift Logical Operators */
        Is16vec8 operator<<(const M128 &a)                              { return _mm_sll_epi16(vec,a); }
        Is16vec8 operator<<(int count)                          { return _mm_slli_epi16(vec,count); }
        Is16vec8& operator<<=(const M128 &a)                    { return *this = (Is16vec8)_mm_sll_epi16(vec,a); }
        Is16vec8& operator<<=(int count)                                { return *this = (Is16vec8)_mm_slli_epi16(vec,count); }
        /* Shift Arithmetic Operators */
        Is16vec8 operator>>(const M128 &a)                              { return _mm_sra_epi16(vec,a); }
        Is16vec8 operator>>(int count)                          { return _mm_srai_epi16(vec,count); }
        Is16vec8& operator>>=(const M128 &a)                    { return *this = (Is16vec8)_mm_sra_epi16(vec,a); }
        Is16vec8& operator>>=(int count)                                { return *this = (Is16vec8)_mm_srai_epi16(vec,count); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator<< (std::ostream &os, const Is16vec8 &a)
        {
                os << "[7]:" << _MM_8W(7,a)
                        << " [6]:" << _MM_8W(6,a)
                        << " [5]:" << _MM_8W(5,a)
                        << " [4]:" << _MM_8W(4,a)
                        << " [3]:" << _MM_8W(3,a)
                        << " [2]:" << _MM_8W(2,a)
                        << " [1]:" << _MM_8W(1,a)
                        << " [0]:" << _MM_8W(0,a);
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const signed short& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 8);       /* Only 8 elements to access */
                return _MM_8W(i,vec);
        }

        /* Element Access and Assignment for Debug */
        signed short& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 8);       /* Only 8 elements to access */
                return _MM_8W(i,vec);
        }
};

inline Is16vec8 operator*(const Is16vec8 &a, const Is16vec8 &b) { return _mm_mullo_epi16(a,b); }


/* Additional Is16vec8 functions: compares, unpacks, sat add/sub */
inline Is16vec8 cmpeq(const Is16vec8 &a, const Is16vec8 &b)     { return _mm_cmpeq_epi16(a,b); }
inline Is16vec8 cmpneq(const Is16vec8 &a, const Is16vec8 &b)    { return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }
inline Is16vec8 cmpgt(const Is16vec8 &a, const Is16vec8 &b)             { return _mm_cmpgt_epi16(a,b); }
inline Is16vec8 cmplt(const Is16vec8 &a, const Is16vec8 &b)             { return _mm_cmpgt_epi16(b,a); }

inline Is16vec8 unpack_low(const Is16vec8 &a, const Is16vec8 &b)        { return _mm_unpacklo_epi16(a,b); }
inline Is16vec8 unpack_high(const Is16vec8 &a, const Is16vec8 &b)       { return _mm_unpackhi_epi16(a,b); }

inline Is16vec8 mul_high(const Is16vec8 &a, const Is16vec8 &b)  { return _mm_mulhi_epi16(a,b); }
inline Is32vec4 mul_add(const Is16vec8 &a, const Is16vec8 &b)   { return _mm_madd_epi16(a,b);}

inline Is16vec8 sat_add(const Is16vec8 &a, const Is16vec8 &b)   { return _mm_adds_epi16(a,b); }
inline Is16vec8 sat_sub(const Is16vec8 &a, const Is16vec8 &b)   { return _mm_subs_epi16(a,b); }

inline Is16vec8 simd_max(const Is16vec8 &a, const Is16vec8 &b)  { return _mm_max_epi16(a,b); }
inline Is16vec8 simd_min(const Is16vec8 &a, const Is16vec8 &b)  { return _mm_min_epi16(a,b); }


/* Iu16vec8 Class:
 * 8 elements, each element unsigned short
 */
class Iu16vec8 : public I16vec8
{
public:
        Iu16vec8() { }
        Iu16vec8(__m128i mm) : I16vec8(mm) { }
        Iu16vec8(unsigned short s7,unsigned short s6,unsigned short s5,unsigned short s4, unsigned short s3,unsigned short s2,unsigned short s1,unsigned short s0)
        {
                _MM_8UW(0,vec) = s0;
                _MM_8UW(1,vec) = s1;
                _MM_8UW(2,vec) = s2;
                _MM_8UW(3,vec) = s3;
                _MM_8UW(4,vec) = s4;
                _MM_8UW(5,vec) = s5;
                _MM_8UW(6,vec) = s6;
                _MM_8UW(7,vec) = s7;
        }

        /* Assignment Operator */
        Iu16vec8& operator= (const M128 &a)             { return *this = (Iu16vec8) a; }
        /* Logical Assignment Operators */
        Iu16vec8& operator&=(const M128 &a)             { return *this = (Iu16vec8) _mm_and_si128(vec,a); }
        Iu16vec8& operator|=(const M128 &a)             { return *this = (Iu16vec8) _mm_or_si128(vec,a); }
        Iu16vec8& operator^=(const M128 &a)             { return *this = (Iu16vec8) _mm_xor_si128(vec,a); }
        /* Addition & Subtraction Assignment Operators */
        Iu16vec8& operator +=(const I16vec8 &a) { return *this = (Iu16vec8) _mm_add_epi16(vec,a); }
        Iu16vec8& operator -=(const I16vec8 &a) { return *this = (Iu16vec8) _mm_sub_epi16(vec,a); }
        Iu16vec8& operator *=(const I16vec8 &a) { return *this = (Iu16vec8) _mm_mullo_epi16(vec,a); }

        /* Shift Logical Operators */
        Iu16vec8 operator<<(const M128 &a)                              { return _mm_sll_epi16(vec,a); }
        Iu16vec8 operator<<(int count)                                  { return _mm_slli_epi16(vec,count); }
        Iu16vec8& operator<<=(const M128 &a)                    { return *this = (Iu16vec8)_mm_sll_epi16(vec,a); }
        Iu16vec8& operator<<=(int count)                                { return *this = (Iu16vec8)_mm_slli_epi16(vec,count); }
        Iu16vec8 operator>>(const M128 &a)                              { return _mm_srl_epi16(vec,a); }
        Iu16vec8 operator>>(int count)                                  { return _mm_srli_epi16(vec,count); }
        Iu16vec8& operator>>=(const M128 &a)                    { return *this = (Iu16vec8) _mm_srl_epi16(vec,a); }
        Iu16vec8& operator>>=(int count)                                { return *this = (Iu16vec8) _mm_srli_epi16(vec,count); }


#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator << (std::ostream &os, const Iu16vec8 &a)
        {
                 os << "[7]:"  << unsigned short(_MM_8UW(7,a))
                        << " [6]:" << unsigned short(_MM_8UW(6,a))
                        << " [5]:" << unsigned short(_MM_8UW(5,a))
                        << " [4]:" << unsigned short(_MM_8UW(4,a))
                        << " [3]:" << unsigned short(_MM_8UW(3,a))
                        << " [2]:" << unsigned short(_MM_8UW(2,a))
                        << " [1]:" << unsigned short(_MM_8UW(1,a))
                        << " [0]:" << unsigned short(_MM_8UW(0,a));
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const unsigned short& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 8);       /* Only 8 elements to access */
                return _MM_8UW(i,vec);
        }

        /* Element Access for Debug */
        unsigned short& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 8);       /* Only 8 elements to access */
                return _MM_8UW(i,vec);
        }
};

inline Iu16vec8 operator*(const Iu16vec8 &a, const Iu16vec8 &b) { return _mm_mullo_epi16(a,b); }

/* Additional Iu16vec8 functions: cmpeq,cmpneq, unpacks, sat add/sub */
inline Iu16vec8 cmpeq(const Iu16vec8 &a, const Iu16vec8 &b)     { return _mm_cmpeq_epi16(a,b); }
inline Iu16vec8 cmpneq(const Iu16vec8 &a, const Iu16vec8 &b)    { return _mm_andnot_si128(_mm_cmpeq_epi16(a,b), get_mask128()); }

inline Iu16vec8 unpack_low(const Iu16vec8 &a, const Iu16vec8 &b)        { return _mm_unpacklo_epi16(a,b); }
inline Iu16vec8 unpack_high(const Iu16vec8 &a, const Iu16vec8 &b) { return _mm_unpackhi_epi16(a,b); }

inline Iu16vec8 sat_add(const Iu16vec8 &a, const Iu16vec8 &b)   { return _mm_adds_epu16(a,b); }
inline Iu16vec8 sat_sub(const Iu16vec8 &a, const Iu16vec8 &b)   { return _mm_subs_epu16(a,b); }

inline Iu16vec8 simd_avg(const Iu16vec8 &a, const Iu16vec8 &b)  { return _mm_avg_epu16(a,b); }
inline I16vec8 mul_high(const Iu16vec8 &a, const Iu16vec8 &b)   { return _mm_mulhi_epu16(a,b); }

/* I8vec16 Class:
 * 16 elements, each element either unsigned or signed char
 */
class I8vec16 : public M128
{
public:
        I8vec16() { }
        I8vec16(__m128i mm) : M128(mm) { }

        /* Assignment Operator */
        I8vec16& operator= (const M128 &a)              { return *this = (I8vec16) a; }

        /* Logical Assignment Operators */
        I8vec16& operator&=(const M128 &a)              { return *this = (I8vec16) _mm_and_si128(vec,a); }
        I8vec16& operator|=(const M128 &a)              { return *this = (I8vec16) _mm_or_si128(vec,a); }
        I8vec16& operator^=(const M128 &a)              { return *this = (I8vec16) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        I8vec16& operator +=(const I8vec16 &a)  { return *this = (I8vec16) _mm_add_epi8(vec,a); }
        I8vec16& operator -=(const I8vec16 &a)  { return *this = (I8vec16) _mm_sub_epi8(vec,a); }

};

inline I8vec16 cmpeq(const I8vec16 &a, const I8vec16 &b)                { return _mm_cmpeq_epi8(a,b); }
inline I8vec16 cmpneq(const I8vec16 &a, const I8vec16 &b)               { return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline I8vec16 unpack_low(const I8vec16 &a, const I8vec16 &b)   { return _mm_unpacklo_epi8(a,b); }
inline I8vec16 unpack_high(const I8vec16 &a, const I8vec16 &b)  { return _mm_unpackhi_epi8(a,b); }

/* Is8vec16 Class:
 * 16 elements, each element a signed char
 */
class Is8vec16 : public I8vec16
{
public:
        Is8vec16() { }
        Is8vec16(__m128i mm) : I8vec16(mm) { }

        /* Assignment Operator */
        Is8vec16& operator= (const M128 &a)             { return *this = (Is8vec16) a; }

        /* Logical Assignment Operators */
        Is8vec16& operator&=(const M128 &a)             { return *this = (Is8vec16) _mm_and_si128(vec,a); }
        Is8vec16& operator|=(const M128 &a)             { return *this = (Is8vec16) _mm_or_si128(vec,a); }
        Is8vec16& operator^=(const M128 &a)             { return *this = (Is8vec16) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Is8vec16& operator +=(const I8vec16 &a) { return *this = (Is8vec16) _mm_add_epi8(vec,a); }
        Is8vec16& operator -=(const I8vec16 &a) { return *this = (Is8vec16) _mm_sub_epi8(vec,a); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator << (std::ostream &os, const Is8vec16 &a)
        {
                 os << "[15]:"  << short(_MM_16B(15,a))
                        << " [14]:" << short(_MM_16B(14,a))
                        << " [13]:" << short(_MM_16B(13,a))
                        << " [12]:" << short(_MM_16B(12,a))
                        << " [11]:" << short(_MM_16B(11,a))
                        << " [10]:" << short(_MM_16B(10,a))
                        << " [9]:" << short(_MM_16B(9,a))
                        << " [8]:" << short(_MM_16B(8,a))
                      << " [7]:" << short(_MM_16B(7,a))
                        << " [6]:" << short(_MM_16B(6,a))
                        << " [5]:" << short(_MM_16B(5,a))
                        << " [4]:" << short(_MM_16B(4,a))
                        << " [3]:" << short(_MM_16B(3,a))
                        << " [2]:" << short(_MM_16B(2,a))
                        << " [1]:" << short(_MM_16B(1,a))
                        << " [0]:" << short(_MM_16B(0,a));
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const signed char& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 16);      /* Only 16 elements to access */
                return _MM_16B(i,vec);
        }

        /* Element Access for Debug */
        signed char& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 16);      /* Only 16 elements to access */
                return _MM_16B(i,vec);
        }

};

inline Is8vec16 cmpeq(const Is8vec16 &a, const Is8vec16 &b)     { return _mm_cmpeq_epi8(a,b); }
inline Is8vec16 cmpneq(const Is8vec16 &a, const Is8vec16 &b)    { return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }
inline Is8vec16 cmpgt(const Is8vec16 &a, const Is8vec16 &b)     { return _mm_cmpgt_epi8(a,b); }
inline Is8vec16 cmplt(const Is8vec16 &a, const Is8vec16 &b)     { return _mm_cmplt_epi8(a,b); }

inline Is8vec16 unpack_low(const Is8vec16 &a, const Is8vec16 &b)        { return _mm_unpacklo_epi8(a,b); }
inline Is8vec16 unpack_high(const Is8vec16 &a, const Is8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Is8vec16 sat_add(const Is8vec16 &a, const Is8vec16 &b)   { return _mm_adds_epi8(a,b); }
inline Is8vec16 sat_sub(const Is8vec16 &a, const Is8vec16 &b)   { return _mm_subs_epi8(a,b); }

/* Iu8vec16 Class:
 * 16 elements, each element a unsigned char
 */
class Iu8vec16 : public I8vec16
{
public:
        Iu8vec16() { }
        Iu8vec16(__m128i mm) : I8vec16(mm) { }

        /* Assignment Operator */
        Iu8vec16& operator= (const M128 &a)             { return *this = (Iu8vec16) a; }

        /* Logical Assignment Operators */
        Iu8vec16& operator&=(const M128 &a)             { return *this = (Iu8vec16) _mm_and_si128(vec,a); }
        Iu8vec16& operator|=(const M128 &a)             { return *this = (Iu8vec16) _mm_or_si128(vec,a); }
        Iu8vec16& operator^=(const M128 &a)             { return *this = (Iu8vec16) _mm_xor_si128(vec,a); }

        /* Addition & Subtraction Assignment Operators */
        Iu8vec16& operator +=(const I8vec16 &a) { return *this = (Iu8vec16) _mm_add_epi8(vec,a); }
        Iu8vec16& operator -=(const I8vec16 &a) { return *this = (Iu8vec16) _mm_sub_epi8(vec,a); }

#if defined (_ENABLE_VEC_DEBUG)
        /* Output for Debug */
        friend std::ostream& operator << (std::ostream &os, const Iu8vec16 &a)
        {
                 os << "[15]:"  << unsigned short(_MM_16UB(15,a))
                        << " [14]:" << unsigned short(_MM_16UB(14,a))
                        << " [13]:" << unsigned short(_MM_16UB(13,a))
                        << " [12]:" << unsigned short(_MM_16UB(12,a))
                        << " [11]:" << unsigned short(_MM_16UB(11,a))
                        << " [10]:" << unsigned short(_MM_16UB(10,a))
                        << " [9]:" << unsigned short(_MM_16UB(9,a))
                        << " [8]:" << unsigned short(_MM_16UB(8,a))
                      << " [7]:" << unsigned short(_MM_16UB(7,a))
                        << " [6]:" << unsigned short(_MM_16UB(6,a))
                        << " [5]:" << unsigned short(_MM_16UB(5,a))
                        << " [4]:" << unsigned short(_MM_16UB(4,a))
                        << " [3]:" << unsigned short(_MM_16UB(3,a))
                        << " [2]:" << unsigned short(_MM_16UB(2,a))
                        << " [1]:" << unsigned short(_MM_16UB(1,a))
                        << " [0]:" << unsigned short(_MM_16UB(0,a));
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

        /* Element Access for Debug, No data modified */
        const unsigned char& operator[](int i)const
        {
                assert(static_cast<unsigned int>(i) < 16);      /* Only 16 elements to access */
                return _MM_16UB(i,vec);
        }

        /* Element Access for Debug */
        unsigned char& operator[](int i)
        {
                assert(static_cast<unsigned int>(i) < 16);      /* Only 16 elements to access */
                return _MM_16UB(i,vec);
        }

};

inline Iu8vec16 cmpeq(const Iu8vec16 &a, const Iu8vec16 &b)     { return _mm_cmpeq_epi8(a,b); }
inline Iu8vec16 cmpneq(const Iu8vec16 &a, const Iu8vec16 &b)    { return _mm_andnot_si128(_mm_cmpeq_epi8(a,b), get_mask128()); }

inline Iu8vec16 unpack_low(const Iu8vec16 &a, const Iu8vec16 &b)        { return _mm_unpacklo_epi8(a,b); }
inline Iu8vec16 unpack_high(const Iu8vec16 &a, const Iu8vec16 &b) { return _mm_unpackhi_epi8(a,b); }

inline Iu8vec16 sat_add(const Iu8vec16 &a, const Iu8vec16 &b)   { return _mm_adds_epu8(a,b); }
inline Iu8vec16 sat_sub(const Iu8vec16 &a, const Iu8vec16 &b)   { return _mm_subs_epu8(a,b); }

inline I64vec2 sum_abs(const Iu8vec16 &a, const Iu8vec16 &b)    { return _mm_sad_epu8(a,b); }

inline Iu8vec16 simd_avg(const Iu8vec16 &a, const Iu8vec16 &b)  { return _mm_avg_epu8(a,b); }
inline Iu8vec16 simd_max(const Iu8vec16 &a, const Iu8vec16 &b)  { return _mm_max_epu8(a,b); }
inline Iu8vec16 simd_min(const Iu8vec16 &a, const Iu8vec16 &b)  { return _mm_min_epu8(a,b); }

/* Pack & Saturates */

inline Is16vec8 pack_sat(const Is32vec4 &a, const Is32vec4 &b)  { return _mm_packs_epi32(a,b); }
inline Is8vec16 pack_sat(const Is16vec8 &a, const Is16vec8 &b)  { return _mm_packs_epi16(a,b); }
inline Iu8vec16 packu_sat(const Is16vec8 &a, const Is16vec8 &b) { return _mm_packus_epi16(a,b);}

/********************************* Logicals ****************************************/
#define IVEC128_LOGICALS(vect,element) \
inline I##vect##vec##element operator& (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_and_si128( a,b); } \
inline I##vect##vec##element operator| (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_or_si128( a,b); } \
inline I##vect##vec##element operator^ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_xor_si128( a,b); } \
inline I##vect##vec##element andnot (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_andnot_si128( a,b); }

IVEC128_LOGICALS(8,16)
IVEC128_LOGICALS(u8,16)
IVEC128_LOGICALS(s8,16)
IVEC128_LOGICALS(16,8)
IVEC128_LOGICALS(u16,8)
IVEC128_LOGICALS(s16,8)
IVEC128_LOGICALS(32,4)
IVEC128_LOGICALS(u32,4)
IVEC128_LOGICALS(s32,4)
IVEC128_LOGICALS(64,2)
IVEC128_LOGICALS(128,1)
#undef IVEC128_LOGICALS

/********************************* Add & Sub ****************************************/
#define IVEC128_ADD_SUB(vect,element,opsize) \
inline I##vect##vec##element operator+ (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_add_##opsize( a,b); } \
inline I##vect##vec##element operator- (const I##vect##vec##element &a, const I##vect##vec##element &b) \
{ return _mm_sub_##opsize( a,b); }

IVEC128_ADD_SUB(8,16, epi8)
IVEC128_ADD_SUB(u8,16, epi8)
IVEC128_ADD_SUB(s8,16, epi8)
IVEC128_ADD_SUB(16,8, epi16)
IVEC128_ADD_SUB(u16,8, epi16)
IVEC128_ADD_SUB(s16,8, epi16)
IVEC128_ADD_SUB(32,4, epi32)
IVEC128_ADD_SUB(u32,4, epi32)
IVEC128_ADD_SUB(s32,4, epi32)
IVEC128_ADD_SUB(64,2, epi64)
#undef IVEC128_ADD_SUB

/********************************* Conditional Select ****************************************/
/*      version of: retval = (a OP b)? c : d;                                                                                                    *
 *      Where OP is one of the possible comparision operators.                                                                   *
 *      Example: r = select_eq(a,b,c,d);                                                                                                                 *
 *      if "member at position x of the vector a" == "member at position x of vector b"                  *
 *      assign the corresponding member in r from c, else assign from d.                                                         *
 ********************************* Conditional Select ****************************************/

#define IVEC128_SELECT(vect12,vect34,element,selop,arg1,arg2) \
        inline I##vect34##vec##element select_##selop (const I##vect12##vec##element &a, const I##vect12##vec##element &b, const I##vect34##vec##element &c, const I##vect34##vec##element &d)     \
{                                                                                                                               \
        I##vect12##vec##element mask = cmp##selop(a,b);                                         \
        return( I##vect34##vec##element ((mask & arg1 ) | I##vect12##vec##element ((_mm_andnot_si128(mask, arg2 )))));  \
}
IVEC128_SELECT(8,s8,16,eq,c,d)
IVEC128_SELECT(8,u8,16,eq,c,d)
IVEC128_SELECT(8,8,16,eq,c,d)
IVEC128_SELECT(8,s8,16,neq,c,d)
IVEC128_SELECT(8,u8,16,neq,c,d)
IVEC128_SELECT(8,8,16,neq,c,d)

IVEC128_SELECT(16,s16,8,eq,c,d)
IVEC128_SELECT(16,u16,8,eq,c,d)
IVEC128_SELECT(16,16,8,eq,c,d)
IVEC128_SELECT(16,s16,8,neq,c,d)
IVEC128_SELECT(16,u16,8,neq,c,d)
IVEC128_SELECT(16,16,8,neq,c,d)

IVEC128_SELECT(32,s32,4,eq,c,d)
IVEC128_SELECT(32,u32,4,eq,c,d)
IVEC128_SELECT(32,32,4,eq,c,d)
IVEC128_SELECT(32,s32,4,neq,c,d)
IVEC128_SELECT(32,u32,4,neq,c,d)
IVEC128_SELECT(32,32,4,neq,c,d)

IVEC128_SELECT(s8,s8,16,gt,c,d)
IVEC128_SELECT(s8,u8,16,gt,c,d)
IVEC128_SELECT(s8,8,16,gt,c,d)
IVEC128_SELECT(s8,s8,16,lt,c,d)
IVEC128_SELECT(s8,u8,16,lt,c,d)
IVEC128_SELECT(s8,8,16,lt,c,d)

IVEC128_SELECT(s16,s16,8,gt,c,d)
IVEC128_SELECT(s16,u16,8,gt,c,d)
IVEC128_SELECT(s16,16,8,gt,c,d)
IVEC128_SELECT(s16,s16,8,lt,c,d)
IVEC128_SELECT(s16,u16,8,lt,c,d)
IVEC128_SELECT(s16,16,8,lt,c,d)


#undef IVEC128_SELECT


class F64vec2
{
protected:
         __m128d vec;
public:

        /* Constructors: __m128d, 2 doubles */
        F64vec2() {}

        /* initialize 2 DP FP with __m128d data type */
        F64vec2(__m128d m)                                      { vec = m;}

        /* initialize 2 DP FPs with 2 doubles */
        F64vec2(double d1, double d0)                           { vec= _mm_set_pd(d1,d0); }

        /* Explicitly initialize each of 2 DP FPs with same double */
        EXPLICIT F64vec2(double d)      { vec = _mm_set1_pd(d); }

        /* Conversion functions */
        operator  __m128d() const       { return vec; }         /* Convert to __m128d */

        /* Logical Operators */
        friend F64vec2 operator &(const F64vec2 &a, const F64vec2 &b) { return _mm_and_pd(a,b); }
        friend F64vec2 operator |(const F64vec2 &a, const F64vec2 &b) { return _mm_or_pd(a,b); }
        friend F64vec2 operator ^(const F64vec2 &a, const F64vec2 &b) { return _mm_xor_pd(a,b); }

        /* Arithmetic Operators */
        friend F64vec2 operator +(const F64vec2 &a, const F64vec2 &b) { return _mm_add_pd(a,b); }
        friend F64vec2 operator -(const F64vec2 &a, const F64vec2 &b) { return _mm_sub_pd(a,b); }
        friend F64vec2 operator *(const F64vec2 &a, const F64vec2 &b) { return _mm_mul_pd(a,b); }
        friend F64vec2 operator /(const F64vec2 &a, const F64vec2 &b) { return _mm_div_pd(a,b); }

        F64vec2& operator +=(F64vec2 &a) { return *this = _mm_add_pd(vec,a); }
        F64vec2& operator -=(F64vec2 &a) { return *this = _mm_sub_pd(vec,a); }
        F64vec2& operator *=(F64vec2 &a) { return *this = _mm_mul_pd(vec,a); }
        F64vec2& operator /=(F64vec2 &a) { return *this = _mm_div_pd(vec,a); }
        F64vec2& operator &=(F64vec2 &a) { return *this = _mm_and_pd(vec,a); }
        F64vec2& operator |=(F64vec2 &a) { return *this = _mm_or_pd(vec,a); }
        F64vec2& operator ^=(F64vec2 &a) { return *this = _mm_xor_pd(vec,a); }

        /* Horizontal Add */
        friend double add_horizontal(F64vec2 &a)
        {
                F64vec2 ftemp = _mm_add_sd(a,_mm_shuffle_pd(a, a, 1));
                return ftemp[0];
        }

        /* And Not */
        friend F64vec2 andnot(const F64vec2 &a, const F64vec2 &b) { return _mm_andnot_pd(a,b); }

        /* Square Root */
        friend F64vec2 sqrt(const F64vec2 &a)           { return _mm_sqrt_pd(a); }

        /* Compares: Mask is returned  */
        /* Macros expand to all compare intrinsics.  Example:
                        friend F64vec2 cmpeq(const F64vec2 &a, const F64vec2 &b)
                        { return _mm_cmpeq_ps(a,b);} */
        #define F64vec2_COMP(op) \
        friend F64vec2 cmp##op (const F64vec2 &a, const F64vec2 &b) { return _mm_cmp##op##_pd(a,b); }
                F64vec2_COMP(eq)                                        /* expanded to cmpeq(a,b) */
                F64vec2_COMP(lt)                                        /* expanded to cmplt(a,b) */
                F64vec2_COMP(le)                                        /* expanded to cmple(a,b) */
                F64vec2_COMP(gt)                                        /* expanded to cmpgt(a,b) */
                F64vec2_COMP(ge)                                        /* expanded to cmpge(a,b) */
                F64vec2_COMP(ngt)                                       /* expanded to cmpngt(a,b) */
                F64vec2_COMP(nge)                                       /* expanded to cmpnge(a,b) */
                F64vec2_COMP(neq)                                       /* expanded to cmpneq(a,b) */
                F64vec2_COMP(nlt)                                       /* expanded to cmpnlt(a,b) */
                F64vec2_COMP(nle)                                       /* expanded to cmpnle(a,b) */
        #undef F64vec2_COMP

        /* Min and Max */
        friend F64vec2 simd_min(const F64vec2 &a, const F64vec2 &b) { return _mm_min_pd(a,b); }
        friend F64vec2 simd_max(const F64vec2 &a, const F64vec2 &b) { return _mm_max_pd(a,b); }

        /* Compare lower DP FP values */
        #define F64vec2_COMI(op) \
        friend int comi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_comi##op##_sd(a,b); }
                F64vec2_COMI(eq)                                        /* expanded to comieq(a,b) */
                F64vec2_COMI(lt)                                        /* expanded to comilt(a,b) */
                F64vec2_COMI(le)                                        /* expanded to comile(a,b) */
                F64vec2_COMI(gt)                                        /* expanded to comigt(a,b) */
                F64vec2_COMI(ge)                                        /* expanded to comige(a,b) */
                F64vec2_COMI(neq)                                       /* expanded to comineq(a,b) */
        #undef F64vec2_COMI

        /* Compare lower DP FP values */
        #define F64vec2_UCOMI(op) \
        friend int ucomi##op (const F64vec2 &a, const F64vec2 &b) { return _mm_ucomi##op##_sd(a,b); }
                F64vec2_UCOMI(eq)                                       /* expanded to ucomieq(a,b) */
                F64vec2_UCOMI(lt)                                       /* expanded to ucomilt(a,b) */
                F64vec2_UCOMI(le)                                       /* expanded to ucomile(a,b) */
                F64vec2_UCOMI(gt)                                       /* expanded to ucomigt(a,b) */
                F64vec2_UCOMI(ge)                                       /* expanded to ucomige(a,b) */
                F64vec2_UCOMI(neq)                                      /* expanded to ucomineq(a,b) */
        #undef F64vec2_UCOMI

        /* Debug Features */
#if defined (_ENABLE_VEC_DEBUG)
        /* Output */
        friend std::ostream & operator<<(std::ostream & os, const F64vec2 &a)
        {
        /* To use: cout << "Elements of F64vec2 fvec are: " << fvec; */
          double *dp = (double*)&a;
                os <<   " [1]:" << *(dp+1)
                        << " [0]:" << *dp;
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */
        /* Element Access Only, no modifications to elements*/
        const double& operator[](int i) const
        {
                /* Assert enabled only during debug /DDEBUG */
                assert((0 <= i) && (i <= 1));                   /* User should only access elements 0-1 */
                double *dp = (double*)&vec;
                return *(dp+i);
        }
        /* Element Access and Modification*/
        double& operator[](int i)
        {
                /* Assert enabled only during debug /DDEBUG */
                assert((0 <= i) && (i <= 1));                   /* User should only access elements 0-1 */
                double *dp = (double*)&vec;
                return *(dp+i);
        }
};

                                                /* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F64vec2 unpack_low(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpacklo_pd(a, b); }

/* Interleave high order data elements of a and b into target */
inline F64vec2 unpack_high(const F64vec2 &a, const F64vec2 &b)
{ return _mm_unpackhi_pd(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F64vec2 &a)
{ return _mm_movemask_pd(a);}

                                                /* Data Motion Functions */

/* Load Unaligned loadu_pd: Unaligned */
inline void loadu(F64vec2 &a, double *p)
{ a = _mm_loadu_pd(p); }

/* Store Temporal storeu_pd: Unaligned */
inline void storeu(double *p, const F64vec2 &a)
{ _mm_storeu_pd(p, a); }

                                                /* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(double *p, F64vec2 &a)
{ _mm_stream_pd(p,a);}

#define F64vec2_SELECT(op) \
inline F64vec2 select_##op (const F64vec2 &a, const F64vec2 &b, const F64vec2 &c, const F64vec2 &d)        \
{                                                                                                                               \
        F64vec2 mask = _mm_cmp##op##_pd(a,b);                                           \
        return( (mask & c) | F64vec2((_mm_andnot_pd(mask,d)))); \
}
F64vec2_SELECT(eq)              /* generates select_eq(a,b) */
F64vec2_SELECT(lt)              /* generates select_lt(a,b) */
F64vec2_SELECT(le)              /* generates select_le(a,b) */
F64vec2_SELECT(gt)              /* generates select_gt(a,b) */
F64vec2_SELECT(ge)              /* generates select_ge(a,b) */
F64vec2_SELECT(neq)             /* generates select_neq(a,b) */
F64vec2_SELECT(nlt)             /* generates select_nlt(a,b) */
F64vec2_SELECT(nle)             /* generates select_nle(a,b) */
#undef F64vec2_SELECT

/* Convert the lower DP FP value of a to a 32 bit signed integer using Truncate*/
inline int F64vec2ToInt(const F64vec2 &a)
{

        return _mm_cvttsd_si32(a);

}

/* Convert the 4 SP FP values of a to DP FP values */
inline F64vec2 F32vec4ToF64vec2(const F32vec4 &a)
{
        return _mm_cvtps_pd(a);
}

/* Convert the 2 DP FP values of a to SP FP values */
inline F32vec4 F64vec2ToF32vec4(const F64vec2 &a)
{
        return _mm_cvtpd_ps(a);
}

/* Convert the signed int in b to a DP FP value.  Upper DP FP value in a passed through */
inline F64vec2 IntToF64vec2(const F64vec2 &a, int b)
{
        return _mm_cvtsi32_sd(a,b);
}

#pragma pack(pop) /* 16-B aligned */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* RC_INVOKED */
#endif  /* _DVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\execlpe.c ===
/***
*execlpe.c - execute a file with environ, search along path
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execlpe() - execute a file with environ and search along PATH
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execlpe(filename, arglist) - execute a file with environ
*
*Purpose:
*       Executes the given file with the parameters and the environment
*       which is passed after the parameters.  Searches along the PATH
*       for the file (done by execvp).
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list (environment is at the end)
*       call as _execlpe(path, arg0, arg1, ..., argn, NULL, envp);
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texeclpe (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef _M_IX86

        REG1 const _TSCHAR **argp;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        argp = &arglist;
        while (*argp++)
                ;

        return(_texecvpe(filename,&arglist,(_TSCHAR **)*argp));

#else  /* _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        _TSCHAR ** envp;
        intptr_t result;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else  /* WPRFLAG */
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif  /* WPRFLAG */
        envp = va_arg(vargs, _TSCHAR **);
        va_end(vargs);

        result = _texecvpe(filename,argv,envp);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\except.inc ===
;***
;except.inc - definitions for exception handling
;
;       Copyright (c) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Structure and constant definitions used by exception handling code.
;
;*******************************************************************************

; structure used by SEH support function and intrinsics. the information
; passed by the OS exception dispatcher is repackaged in this form by the
; runtime (_except_handler()).

__EXCEPTION_INFO_PTRS struc
        preport                 dd      ?
        pcontext                dd      ?
__EXCEPTION_INFO_PTRS ends


; exception registration record structure.

__EXCEPTIONREGISTRATIONRECORD struc
        prev_structure          dd      ?
        ExceptionHandler        dd      ?
        ExceptionFilter         dd      ?
        FilterFrame             dd      ?
        PExceptionInfoPtrs      dd      ?
__EXCEPTIONREGISTRATIONRECORD ends

; size of exception registration record in double words

DWORDS_IN_XREGREC       equ     5


; exception report record

__EXCEPTIONREPORTRECORD struc
        ExceptionNum            dd      ?
        fHandlerFlags           dd      ?
        ExceptionReportRecord   dd      ?
        ExceptionAddress        dd      ?
        cParameters             dd      ?
        ExceptionInfo           dd      4 dup (?)
__EXCEPTIONREPORTRECORD ends


; setjmp/longjmp buffer (i.e., structure underlying jmp_buf array)

_JMP_BUF        struc
        ebpsave                 dd      ?
        ebxsave                 dd      ?
        edisave                 dd      ?
        esisave                 dd      ?
        espsave                 dd      ?
        retsave                 dd      ?
        xcptsave                dd      ?
_JMP_BUF        ends


; exceptions corresponding to C runtime errors (these are explicitly
; referenced in the startup code)

_XCPT_UNABLE_TO_GROW_STACK      equ             080010001h
_XCPT_INTEGER_DIVIDE_BY_ZERO    equ             0C000009Bh
_XCPT_NONCONTINUABLE_EXCEPTION  equ             0C0000024h
_XCPT_INVALID_DISPOSITION       equ             0C0000025h
_XCPT_SIGABRT                   equ             020000001h


; unwind settings in fHandlerFlags

_EH_UNWINDING   equ     2
_EH_EXIT_UNWIND equ     4
UNWIND          equ     _EH_UNWINDING OR _EH_EXIT_UNWIND


; return values (to the exception dispatcher)

IFDEF   _WIN32

_XCPT_CONTINUE_SEARCH           equ     000000001h
_XCPT_CONTINUE_EXECUTION        equ     000000000h

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\execve.c ===
/***
*execve.c - execute a file with a given environment
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execve() - execute a file
*
*******************************************************************************/

#define EXECVE

#include "spawnve.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\eof.c ===
/***
*eof.c - test a handle for end of file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _eof() - determine if a file is at eof
*
*******************************************************************************/

#include <cruntime.h>
#include <io.h>
#include <errno.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <internal.h>
#include <msdos.h>
#include <mtdll.h>

/***
*int _eof(filedes) - test a file for eof
*
*Purpose:
*       see if the file length is the same as the present position. if so, return
*       1. if not, return 0. if an error occurs, return -1
*
*Entry:
*       int filedes - handle of file to test
*
*Exit:
*       returns 1 if at eof
*       returns 0 if not at eof
*       returns -1 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _eof (
        int filedes
        )
{
        __int64 here;
        __int64 end;
        int retval;

        _CHECK_FH_CLEAR_OSSERR_RETURN( filedes, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(filedes) & FOPEN), EBADF, -1);


        /* Lock the file */
        _lock_fh(filedes);
        __try {
                if ( _osfile(filedes) & FOPEN ) {


        /* See if the current position equals the end of the file. */

        if ( ((here = _lseeki64_nolock(filedes, 0i64, SEEK_CUR)) == -1i64) ||
             ((end = _lseeki64_nolock(filedes, 0i64, SEEK_END)) == -1i64) )
                retval = -1;
        else if ( here == end )
                retval = 1;
        else {
                _lseeki64_nolock(filedes, here, SEEK_SET);
                retval = 0;
        }


                }
                else {
                        errno = EBADF;
                        _doserrno = 0;
                        retval = -1;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                /* Unlock the file */
                _unlock_fh(filedes);
        }


        /* Done */
        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\execvp.c ===
/***
*execvp.c - execute a file and search along PATH
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execvp() - execute a file and search along PATH
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

/***
*int _execvp(filename, argvector) - execute file; search along PATH
*
*Purpose:
*       Execute the given file with given path and current environ.
*       try to execute the file. start with the name itself (directory '.'),
*       and if that doesn't work start prepending pathnames from the
*       environment until one works or we run out. if the file is a pathname,
*       don't go to the environment to get alternate paths. if errno comes
*       back ENOEXEC, try it as a shell command file with up to MAXARGS-2
*       arguments from the original vector. if a needed text file is busy,
*       wait a little while and try again before despairing completely
*       Actually calls _execvpe() to do all the work.
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecvp (
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argvector
        )
{
        return _texecvpe( filename, argvector, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\exedefad.cpp ===
/***
*exedefad.cpp - routine for loading module in default appdomain.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file provides at_exit support for clrcall functions. Here you will
*       find implementation for both managed process exit and appdomain exit.
*
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the system-wide error numbers (set by
*       system calls).  Conforms to the XENIX standard.  Extended
*       for compatibility with Uniforum standard.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_ERRNO
#define _INC_ERRNO

#include <crtdefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* declare reference to errno */

#ifndef _CRT_ERRNO_DEFINED
#define _CRT_ERRNO_DEFINED
_CRTIMP extern int * __cdecl _errno(void);
#define errno   (*_errno())

errno_t __cdecl _set_errno(_In_ int _Value);
errno_t __cdecl _get_errno(_Out_ int * _Value);
#endif  /* _CRT_ERRNO_DEFINED */

/* Error Codes */

#define EPERM           1
#define ENOENT          2
#define ESRCH           3
#define EINTR           4
#define EIO             5
#define ENXIO           6
#define E2BIG           7
#define ENOEXEC         8
#define EBADF           9
#define ECHILD          10
#define EAGAIN          11
#define ENOMEM          12
#define EACCES          13
#define EFAULT          14
#define EBUSY           16
#define EEXIST          17
#define EXDEV           18
#define ENODEV          19
#define ENOTDIR         20
#define EISDIR          21
#define ENFILE          23
#define EMFILE          24
#define ENOTTY          25
#define EFBIG           27
#define ENOSPC          28
#define ESPIPE          29
#define EROFS           30
#define EMLINK          31
#define EPIPE           32
#define EDOM            33
#define EDEADLK         36
#define ENAMETOOLONG    38
#define ENOLCK          39
#define ENOSYS          40
#define ENOTEMPTY       41

/* Error codes used in the Secure CRT functions */

#ifndef RC_INVOKED
#if !defined (_SECURECRT_ERRCODE_VALUES_DEFINED)
#define _SECURECRT_ERRCODE_VALUES_DEFINED
#define EINVAL          22
#define ERANGE          34
#define EILSEQ          42
#define STRUNCATE       80
#endif  /* !defined (_SECURECRT_ERRCODE_VALUES_DEFINED) */
#endif  /* RC_INVOKED */


/*
 * Support EDEADLOCK for compatibiity with older MS-C versions.
 */
#define EDEADLOCK       EDEADLK

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_ERRNO */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\exsup.inc ===
;***
;exsup.inc
;
;       Copyright (C) Microsoft Corporation. All rights reserved.
;
;Purpose:
;       Common data structures & definitions for exsup.asm and other
;       Structured Exception Handling support modules.
;
;******************************************************************************


;handler dispositions
DISPOSITION_DISMISS             equ     0
DISPOSITION_CONTINUE_SEARCH     equ     1
DISPOSITION_NESTED_EXCEPTION    equ     2
DISPOSITION_COLLIDED_UNWIND     equ     3

;filter return codes
FILTER_ACCEPT           equ     1
FILTER_DISMISS          equ     -1
FILTER_CONTINUE_SEARCH  equ     0

;handler flags settings..
EXCEPTION_UNWINDING     equ     2
EXCEPTION_EXIT_UNWIND   equ     4
EXCEPTION_UNWIND_CONTEXT equ    EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND
EXCEPTION_STACK_INVALID equ     8

TRYLEVEL_NONE           equ     -1
TRYLEVEL_INVALID        equ     -2

;callback interface codes (mimimal required set)
CB_GET_MAX_CODE         equ     0
CB_DO_LOCAL_UNWIND      equ     1
CB_GET_FRAME_EBP        equ     2
CB_GET_SCOPE_INDEX      equ     3
CB_GET_SCOPE_DATA       equ     4
MAX_CALLBACK_CODE       equ     4

;typedef struct _EXCEPTION_REGISTRATION PEXCEPTION_REGISTRATION;
;struct _EXCEPTION_REGISTRATION{
;     struct _EXCEPTION_REGISTRATION *prev;
;     void (*handler)(PEXCEPTION_RECORD, PEXCEPTION_REGISTRATION, PCONTEXT, PEXCEPTION_RECORD);
;     struct scopetable_entry *scopetable;
;     int trylevel;
;     int _ebp;
;     PEXCEPTION_POINTERS xpointers;
;};
_EXCEPTION_REGISTRATION struc
    prev                dd      ?
    handler             dd      ?
_EXCEPTION_REGISTRATION ends

;setjmp/longjmp buffer
_JMP_BUF struc
    saved_ebp           dd      ?
    saved_ebx           dd      ?
    saved_edi           dd      ?
    saved_esi           dd      ?
    saved_esp           dd      ?
    saved_return        dd      ?
    saved_xregistration dd      ?
    saved_trylevel      dd      ?
    ; following only found in C9.0 or later jmp_buf
    version_cookie      dd      ?
    unwind_func         dd      ?
    unwind_data         dd      6 dup(?)
_JMP_BUF ends

; Cookie placed in the jmp_buf to identify the new, longer form
JMPBUF_COOKIE   equ     'VC20'

; Offset of TryLevel in a C8.0 SEH registration node
C8_TRYLEVEL     equ     12

; NLG struct (debugging info)
;
; struct {
;    unsigned long   dwSig;
;    unsigned long   uoffDestination;
;    unsigned long   dwCode;
;    unsigned long   uoffFramePointer;
; } _NLG_Destination = {EH_MAGIC_NUMBER1,0,0,0};

MAGIC_NUMBER1           equ     019930520h

_NLG_INFO struc
    dwSig                       dd      MAGIC_NUMBER1
    uoffDestination     dd      0
    dwCode                      dd      0
    uoffFramePointer    dd      0
_NLG_INFO ends
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fclose.c ===
/***
*fclose.c - close a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fclose() - close an open file
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <string.h>
#include <io.h>
#include <stdlib.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>


/***
*int fclose(stream) - close a stream
*
*Purpose:
*       Flushes and closes a stream and frees any buffer associated
*       with that stream, unless it was set with setbuf.
*
*Entry:
*       FILE *stream - stream to close
*
*Exit:
*       returns 0 if OK, EOF if fails (can't _flush, not a FILE, not open, etc.)
*       closes the file -- affecting FILE structure
*
*Exceptions:
*
*******************************************************************************/


int __cdecl fclose (
        FILE *stream
        )
{
        int result = EOF;

        _VALIDATE_RETURN((stream != NULL), EINVAL, EOF);

        /* If stream is a string, simply clear flag and return EOF */
        if (stream->_flag & _IOSTRG)
                stream->_flag = 0;  /* IS THIS REALLY NEEDED ??? */

        /* Stream is a real file. */
        else {
                _lock_str(stream);
                __try {
                        result = _fclose_nolock(stream);
                }
                __finally {
                        _unlock_str(stream);
                }
        }

        return(result);
}

/***
*int _fclose_nolock() - close a stream (lock already held)
*
*Purpose:
*       Core fclose() routine; assumes caller has stream lock held.
*
*       [See fclose() above for more information.]
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fclose_nolock (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int result = EOF;

        _VALIDATE_RETURN((str != NULL), EINVAL, EOF);

        /* Init near stream pointer */
        stream = str;


        if (inuse(stream)) {

                /* Stream is in use:
                       (1) flush stream
                       (2) free the buffer
                       (3) close the file
                       (4) delete the file if temporary
                */

                result = _flush(stream);
                _freebuf(stream);

                if (_close(_fileno(stream)) < 0)
                        result = EOF;

                else if ( stream->_tmpfname != NULL ) {
                        /*
                         * temporary file (i.e., one created by tmpfile()
                         * call). delete, if necessary (don't have to on
                         * Windows NT because it was done by the system when
                         * the handle was closed). also, free up the heap
                         * block holding the pathname.
                         */

                        _free_crt(stream->_tmpfname);
                stream->_tmpfname = NULL;
                }

        }

        stream->_flag = 0;
        return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines constants for the file control options used
*       by the _open() function.
*       [System V]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#include <crtdefs.h>

#ifndef _INC_FCNTL
#define _INC_FCNTL

#ifndef _CRTBLD
/* This version of the header files is NOT for user programs.
 * It is intended for use when building the C runtimes ONLY.
 * The version intended for public use will not have this message.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#define _O_RDONLY       0x0000  /* open for reading only */
#define _O_WRONLY       0x0001  /* open for writing only */
#define _O_RDWR         0x0002  /* open for reading and writing */
#define _O_APPEND       0x0008  /* writes done at eof */

#define _O_CREAT        0x0100  /* create and open file */
#define _O_TRUNC        0x0200  /* open and truncate */
#define _O_EXCL         0x0400  /* open only if file doesn't already exist */

/* O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT         0x4000  /* file mode is text (translated) */
#define _O_BINARY       0x8000  /* file mode is binary (untranslated) */
#define _O_WTEXT        0x10000 /* file mode is UTF16 (translated) */
#define _O_U16TEXT      0x20000 /* file mode is UTF16 no BOM (translated) */
#define _O_U8TEXT       0x40000 /* file mode is UTF8  no BOM (translated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

/* Temporary file bit - file is deleted when last handle is closed */

#define _O_TEMPORARY    0x0040  /* temporary file bit */

/* temporary access hint */

#define _O_SHORT_LIVED  0x1000  /* temporary storage file, try not to flush */

/* sequential/random access hints */

#define _O_SEQUENTIAL   0x0020  /* file access is primarily sequential */
#define _O_RANDOM       0x0010  /* file access is primarily random */

#if !__STDC__
/* Non-ANSI names for compatibility */
#define O_RDONLY        _O_RDONLY
#define O_WRONLY        _O_WRONLY
#define O_RDWR          _O_RDWR
#define O_APPEND        _O_APPEND
#define O_CREAT         _O_CREAT
#define O_TRUNC         _O_TRUNC
#define O_EXCL          _O_EXCL
#define O_TEXT          _O_TEXT
#define O_BINARY        _O_BINARY
#define O_RAW           _O_BINARY
#define O_TEMPORARY     _O_TEMPORARY
#define O_NOINHERIT     _O_NOINHERIT
#define O_SEQUENTIAL    _O_SEQUENTIAL
#define O_RANDOM        _O_RANDOM
#endif  /* !__STDC__ */

#endif  /* _INC_FCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fdopen.c ===
/***
*fdopen.c - open a file descriptor as stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fdopen() - opens a file descriptor as a stream, thus allowing
*       buffering, etc.
*
*******************************************************************************/

#include <cruntime.h>
#include <msdos.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>
#include <errno.h>

/***
*FILE *_fdopen(filedes, mode) - open a file descriptor as a stream
*
*Purpose:
*       associates a stream with a file handle, thus allowing buffering, etc.
*       The mode must be specified and must be compatible with the mode
*       the file was opened with in the low level open.
*
*Entry:
*       int filedes - handle referring to open file
*       _TSCHAR *mode - file mode to use ("r", "w", "a", etc.)
*
*Exit:
*       returns stream pointer and sets FILE struct fields if successful
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfdopen (
        int filedes,
        REG2 const _TSCHAR *mode
        )
{
        REG1 FILE *stream;
        int whileflag, tbflag, cnflag;
        int fileflag;

        _VALIDATE_RETURN(mode != NULL, EINVAL, NULL);


        _CHECK_FH_RETURN( filedes, EBADF, NULL );
        _VALIDATE_RETURN((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF, NULL);
        _VALIDATE_RETURN((_osfile(filedes) & FOPEN), EBADF, NULL);


        /* Skip leading spaces */
        while (*mode == _T(' '))
        {
            ++mode;
        }

        /* First character must be 'r', 'w', or 'a'. */
        switch (*mode) {
            case _T('r'):
                fileflag = _IOREAD;
                break;
            case _T('w'):
            case _T('a'):
                fileflag = _IOWRT;
                break;
            default:
                _VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
        }

        /* There can be up to three more optional characters:
           (1) A single '+' character,
           (2) One of 'b' and 't' and
           (3) One of 'c' and 'n'.

           Note that currently, the 't' and 'b' flags are syntax checked
           but ignored.  'c' and 'n', however, are correctly supported.
        */

        whileflag=1;
        tbflag=cnflag=0;
        fileflag |= _commode;

        while(*++mode && whileflag)
            switch(*mode) {

                case _T(' '):
                    /* skip spaces */
                    break;

                case _T('+'):
                    if (fileflag & _IORW)
                        whileflag=0;
                    else {
                        fileflag |= _IORW;
                        fileflag &= ~(_IOREAD | _IOWRT);
                    }
                    break;

                case _T('b'):
                case _T('t'):
                    if (tbflag)
                        whileflag=0;
                    else
                        tbflag=1;
                    break;

                case _T('c'):
                    if (cnflag)
                        whileflag = 0;
                    else {
                        cnflag = 1;
                        fileflag |= _IOCOMMIT;
                    }
                    break;

                case _T('n'):
                    if (cnflag)
                        whileflag = 0;
                    else {
                        cnflag = 1;
                        fileflag &= ~_IOCOMMIT;
                    }
                    break;

                default:
                    _VALIDATE_RETURN(("Invalid file open mode",0), EINVAL, NULL);
            }

        /* Skip trailing spaces */
        while (*mode == _T(' '))
        {
            ++mode;
        }

        _VALIDATE_RETURN( (*mode == _T('\0')), EINVAL, NULL);

        /* Find a free stream; stream is returned 'locked'. */

        if ((stream = _getstream()) == NULL) {
            errno = EMFILE;
            return(NULL);
        }

        __try {

#ifndef CRTDLL
        _cflush++;  /* force library pre-termination procedure */
#endif  /* CRTDLL */

        stream->_flag = fileflag;
        stream->_file = filedes;

        }
        __finally {
            _unlock_str(stream);
        }

        return(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\feoferr.c ===
/***
*feoferr.c - defines feof() and ferror()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines feof() (test for end-of-file on a stream) and ferror() (test
*       for error on a stream).
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <internal.h>

/* remove macro definitions for feof() and ferror()
 */
#undef  feof
#undef  ferror

/***
*int feof(stream) - test for end-of-file on stream
*
*Purpose:
*       Tests whether or not the given stream is at end-of-file. Normally
*       feof() is a macro, but it must also be available as a true function
*       for ANSI.
*
*Entry:
*       FILE *stream - stream to test
*
*Exit:
*       returns nonzero (_IOEOF to be more precise) if and only if the stream
*       is at end-of-file
*
*Exceptions:
*
*******************************************************************************/

int __cdecl feof (
        FILE *stream
        )
{
        _VALIDATE_RETURN((stream != NULL),EINVAL, 0);
        return( ((stream)->_flag & _IOEOF) );
}


/***
*int ferror(stream) - test error indicator on stream
*
*Purpose:
*       Tests the error indicator for the given stream. Normally, feof() is
*       a macro, but it must also be available as a true function for ANSI.
*
*Entry:
*       FILE *stream - stream to test
*
*Exit:
*       returns nonzero (_IOERR to be more precise) if and only if the error
*       indicator for the stream is set.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl ferror (
        FILE *stream
        )
{
        _VALIDATE_RETURN((stream != NULL),EINVAL, 0);
        return( ((stream)->_flag & _IOERR) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fgetc.c ===
/***
*fgetc.c - get a character from a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgetc() and getc() - read  a character from a stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fgetc(stream), getc(stream) - read a character from a stream
*
*Purpose:
*       reads a character from the given stream
*
*Entry:
*       FILE *stream - stream to read character from
*
*Exit:
*       returns the character read
*       returns EOF if at end of file or error occurred
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fgetc (
        REG1 FILE *stream
        )
{
        int retval=0;

        _VALIDATE_RETURN( (stream != NULL), EINVAL, EOF);

        _lock_str(stream);
        __try {
        _VALIDATE_STREAM_ANSI_SETRET(stream, EINVAL, retval, EOF);

                if(retval==0)
                {
                        retval = _getc_nolock(stream);
                }

        }
        __finally {
            _unlock_str(stream);
        }

        return(retval);
}

#undef getc

int __cdecl getc (
        FILE *stream
        )
{
        int retval=0;

        _VALIDATE_RETURN( (stream != NULL), EINVAL, EOF);

        _lock_str(stream);
        __try {

        _VALIDATE_STREAM_ANSI_SETRET(stream, EINVAL, retval, EOF);
                if(retval==0)
                {
                        retval = _getc_nolock(stream);
                }

        }
        __finally {
            _unlock_str(stream);
        }

        return(retval);
}

_CRTIMP int (__cdecl _getc_nolock)(
        FILE *stream
        )
{
    return _getc_nolock(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\execl.c ===
/***
*execl.c - execute a file with a list of arguments
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execl() - execute a file with a list of arguments
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execl(filename, arglist) - execute a file with arg list
*
*Purpose:
*       Transform the argument list so it is a vector, then pass its address
*       to execve.  Use a pointer to the default environment vector.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - list of arguments
*       call as _execl(path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       destroys the calling process, hopefully
*       returns -1 if fails
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecl (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef _M_IX86

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        return(_texecve(filename,&arglist,NULL));

#else  /* _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else  /* WPRFLAG */
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif  /* WPRFLAG */
        va_end(vargs);

        result = _texecve(filename,argv,NULL);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fgetchar.c ===
/***
*fgetchar.c - get a character from stdin
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fgetchar() and getchar() - read a character from stdin
*       defines _fgetwchar() and getwchar() - read a wide character from stdin
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/***
*int _fgetchar(), getchar() - read a character from stdin
*
*Purpose:
*       Reads the next character from stdin.  Function version of
*       getchar() macro.
*
*Entry:
*       None.
*
*Exit:
*       Returns character read or EOF if at end-of-file or an error occured,
*       in which case the appropriate flag is set in the FILE structure.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fgetchar (
        void
        )
{
        return(getc(stdin));
}

#undef getchar

int __cdecl getchar (
        void
        )
{
        return _fgetchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fgetpos.c ===
/***
*fgetpos.c - Contains the fgetpos runtime
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Get file position (in an internal format).
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <internal.h>

/***
*int fgetpos(stream,pos) - Get file position (internal format)
*
*Purpose:
*       Fgetpos gets the current file position for the file identified by
*       [stream].  The file position is returned in the object pointed to
*       by [pos] and is in internal format; that is, the user is not supposed
*       to interpret the value but simply use it in the fsetpos call.  Our
*       implementation simply uses fseek/ftell.
*
*Entry:
*       FILE *stream = pointer to a file stream value
*       fpos_t *pos = pointer to a file position value
*
*Exit:
*       Successful fgetpos call returns 0.
*       Unsuccessful fgetpos call returns non-zero (!0) value and sets
*       ERRNO (this is done by ftell and passed back by fgetpos).
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl fgetpos (
        FILE *stream,
        fpos_t *pos
        )
{

        _VALIDATE_RETURN((stream != NULL), EINVAL, -1);
        _VALIDATE_RETURN((pos != NULL), EINVAL, -1);

        if ( (*pos = _ftelli64(stream)) != -1i64 )
                return(0);
        else
                return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fgets.c ===
/***
*fgets.c - get string from a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgets() - read a string from a file
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

/***
*char *fgets(string, count, stream) - input string from a stream
*
*Purpose:
*       get a string, up to count-1 chars or '\n', whichever comes first,
*       append '\0' and put the whole thing into string. the '\n' IS included
*       in the string. if count<=1 no input is requested. if EOF is found
*       immediately, return NULL. if EOF found after chars read, let EOF
*       finish the string as '\n' would.
*
*Entry:
*       char *string - pointer to place to store string
*       int count - max characters to place at string (include \0)
*       FILE *stream - stream to read from
*
*Exit:
*       returns string with text read from file in it.
*       if count <= 0 return NULL
*       if count == 1 put null string in string
*       returns NULL if error or end-of-file found immediately
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _fgetts (
        _TSCHAR *string,
        int count,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 _TSCHAR *pointer = string;
        _TSCHAR *retval = string;
        int ch;

        _VALIDATE_RETURN(( string != NULL ) || ( count == 0 ), EINVAL, NULL);
        _VALIDATE_RETURN(( count >= 0 ), EINVAL, NULL);
        _VALIDATE_RETURN(( str != NULL ), EINVAL, NULL);

                if (count == 0)
                {
                        return NULL;
                }

        /* The C Standard states the input buffer should remain
        unchanged if EOF is encountered immediately. Hence we
        do not blank out the input buffer here */

        /* Init stream pointer */
        stream = str;

        _lock_str(stream);
        __try {

#ifndef _UNICODE
        _VALIDATE_STREAM_ANSI_SETRET(stream, EINVAL, retval, NULL);
#endif  /* _UNICODE */
        if(retval!=NULL)
                {
                        while (--count)
                        {
                                        if ((ch = _fgettc_nolock(stream)) == _TEOF)
                                        {
                                                        if (pointer == string) {
                                                                        retval=NULL;
                                                                        goto done;
                                                        }

                                                        break;
                                        }

                                        if ((*pointer++ = (_TSCHAR)ch) == _T('\n'))
                                                        break;
                        }
                *pointer = _T('\0');
                }


/* Common return */
done:

        ; }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\execlp.c ===
/***
*execlp.c - execute a file (search along PATH)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execlp() - execute a file and search along PATH
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <process.h>
#include <stdarg.h>
#include <internal.h>
#include <malloc.h>
#include <tchar.h>
#include <dbgint.h>

/***
*int _execlp(filename, arglist) - execute a file, search along PATH
*
*Purpose:
*       Execute the given file with the given arguments; search along PATH
*       for the file. We pass the arguments to execvp where several paths
*       will be tried until one works.
*
*Entry:
*       _TSCHAR *filename - file to execute
*       _TSCHAR *arglist  - argument list
*       call as _execlp(path, arg0, arg1, ..., argn, NULL);
*
*Exit:
*       destroys calling process (hopefully)
*       returns -1 if fails.
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texeclp (
        const _TSCHAR *filename,
        const _TSCHAR *arglist,
        ...
        )
{
#ifdef _M_IX86

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        return(_texecvp(filename,&arglist));

#else  /* _M_IX86 */

        va_list vargs;
        _TSCHAR * argbuf[64];
        _TSCHAR ** argv;
        intptr_t result;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(arglist != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*arglist != _T('\0'), EINVAL, -1);

        va_start(vargs, arglist);
#ifdef WPRFLAG
        argv = _wcapture_argv(&vargs, arglist, argbuf, 64);
#else  /* WPRFLAG */
        argv = _capture_argv(&vargs, arglist, argbuf, 64);
#endif  /* WPRFLAG */
        va_end(vargs);

        result = _texecvp(filename,argbuf);
        if (argv && argv != argbuf)
            _free_crt(argv);
        return result;

#endif  /* _M_IX86 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\execv.c ===
/***
*execv.c - execute a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execv() - execute a file
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>
#include <dbgint.h>
#include <internal.h>

/***
*int _execv(filename, argvector) - execute a file
*
*Purpose:
*       Executes a file with given arguments.  Passes arguments to _execve and
*       uses pointer to the default environment.
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments.
*
*Exit:
*       destroys calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecv (
        const _TSCHAR *filename,
        const _TSCHAR * const *argvector
        )
{
        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(argvector != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*argvector != NULL, EINVAL, -1);
        _VALIDATE_RETURN(**argvector != _T('\0'), EINVAL, -1);

        return(_texecve(filename,argvector,NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fgetwc.c ===
/***
*fgetwc.c - get a wide character from a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgetwc() - read a wide character from a stream
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <wchar.h>
#include <tchar.h>
#include <setlocal.h>


/***
*wint_t fgetwc(stream) - read a wide character from a stream
*
*Purpose:
*       reads a wide character from the given stream
*
*Entry:
*       FILE *stream - stream to read wide character from
*
*Exit:
*       returns the wide character read
*       returns WEOF if at end of file or error occurred
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl fgetwc (
        REG1 FILE *stream
        )
{
        wint_t retval;

        _VALIDATE_RETURN( (stream != NULL), EINVAL, WEOF);

        _lock_str(stream);
        __try {

        retval = _getwc_nolock(stream);

        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


#include <fgetwc_nolock.inl>

#undef getwc

wint_t __cdecl getwc (
        FILE *stream
        )
{
        return fgetwc(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fgetwchr.c ===
/***
*fgetwchr.c - get a wide character from stdin
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fgetwchar() and getwchar() - read a wide character from stdin
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <tchar.h>

/***
*wint_t _fgetwchar(), getwchar() - read a wide character from stdin
*
*Purpose:
*       Reads the next wide character from stdin.  Function version of
*       getwchar() macro.
*
*Entry:
*       None.
*
*Exit:
*       Returns wide character read or WEOF if at end-of-file or an error occured,
*       in which case the appropriate flag is set in the FILE structure.
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _fgetwchar (
        void
        )
{
        return(getwc(stdin));
}

#undef getwchar

wint_t __cdecl getwchar (
        void
        )
{
        return(_fgetwchar());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fgetwc_nolock.inl ===
/***
*fgetwc_nolock.inl - get a wide character from a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgetwc_nolock() - read a wide character from a stream
*
*******************************************************************************/

/***
*_getwc_nolock() -  getwc() core routine (locked version)
*
*Purpose:
*       Core getwc() routine; assumes stream is already locked.
*
*       [See getwc() above for more info.]
*
*Entry: [See getwc()]
*
*Exit:  [See getwc()]
*
*Exceptions:
*
*******************************************************************************/


wint_t __cdecl _fgetwc_nolock (
        REG1 FILE *stream
        )
{



        if(!(stream->_flag & _IOSTRG) && _textmode_safe(_fileno(stream)) != __IOINFO_TM_ANSI)
        {
            /* This is for files open with "u" - Unicode Mode. We need to read
            2 chars instead of 1. This is required even for UTF8, because read
            converts UTF8 to a regular Wide Char */

            int ch;
            wchar_t wch;

            char * p = (char *)&wch;

            ch = _getc_nolock(stream);
            if(ch == EOF)
                return WEOF;

            *p = (char)ch;
            ++p;

            ch = _getc_nolock(stream);
            if(ch == EOF)
                return WEOF;

            *p = (char)ch;

            return wch;

        }

        if (!(stream->_flag & _IOSTRG) && (_osfile_safe(_fileno(stream)) &
              FTEXT))
        {
                int size = 1;
                int ch;
                char mbc[4];
                wchar_t wch;

                /* text (multi-byte) mode */
                if ((ch = _getc_nolock(stream)) == EOF)
                        return WEOF;

                mbc[0] = (char)ch;

                if (isleadbyte((unsigned char)mbc[0]))
                {
                        if ((ch = _getc_nolock(stream)) == EOF)
                        {
                                ungetc(mbc[0], stream);
                                return WEOF;
                        }
                        mbc[1] = (char)ch;
                        size = 2;
                }
                if (mbtowc(&wch, mbc, size) == -1)
                {
                        /*
                         * Conversion failed! Set errno and return
                         * failure.
                         */
                        errno = EILSEQ;
                        return WEOF;
                }
                return wch;
        }
        /* binary (Unicode) mode */
        if ((stream->_cnt -= sizeof(wchar_t)) >= 0)
                return *((wchar_t *)(stream->_ptr))++;
        else
                return (wint_t) _filwbuf(stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\expand.c ===
/***
*expand.c - Win32 expand heap routine
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#ifdef WINHEAP

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>
#include <windows.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>
#include <internal.h>

// Check if the low fragmentation heap is enabled
static BOOL _is_LFH_enabled ()
{
    LONG heaptype = -1;

#ifdef _M_IX86
    // HeapQueryInformation is not available on Windows 2000, but...

    static BOOL bInitialized = FALSE;
    typedef BOOL (WINAPI *PFN_HeapQueryInformation) (HANDLE, HEAP_INFORMATION_CLASS, PVOID, SIZE_T, PSIZE_T);
    static PFN_HeapQueryInformation pfnHeapQueryInformation = NULL;

    if (!bInitialized)
    {
        HMODULE hKernel32;
        if (hKernel32 = GetModuleHandleW(L"kernel32.dll"))
        {
            pfnHeapQueryInformation = (PFN_HeapQueryInformation)_encode_pointer(GetProcAddress(hKernel32, "HeapQueryInformation"));
        }
        bInitialized = TRUE;
    }

    return ((pfnHeapQueryInformation != _encoded_null()) &&
           ((PFN_HeapQueryInformation)_decode_pointer(pfnHeapQueryInformation))(_crtheap, HeapCompatibilityInformation, &heaptype, sizeof(heaptype), NULL) &&
           (heaptype == 2));
#else  /* _M_IX86 */
    // ... HeapQueryInformation is always available on Win64.
    return ((HeapQueryInformation(_crtheap, HeapCompatibilityInformation, &heaptype, sizeof(heaptype), NULL)) && (heaptype == 2));
#endif  /* _M_IX86 */
}

/***
*void *_expand(void *pblck, size_t newsize) - expand/contract a block of memory
*       in the heap
*
*Purpose:
*       Resizes a block in the heap to newsize bytes. newsize may be either
*       greater (expansion) or less (contraction) than the original size of
*       the block. The block is NOT moved.
*
*       NOTES:
*
*       (1) In this implementation, if the block cannot be grown to the
*       desired size, the resulting block will NOT be grown to the max
*       possible size.  (That is, either it works or it doesn't.)
*
*       (2) Unlike other implementations, you can NOT pass a previously
*       freed block to this routine and expect it to work.
*
*Entry:
*       void *pblck - pointer to block in the heap previously allocated
*                 by a call to malloc(), realloc() or _expand().
*
*       size_t newsize  - requested size for the resized block
*
*Exit:
*       Success:  Pointer to the resized memory block (i.e., pblck)
*       Failure:  NULL, errno is set
*
*Uses:
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*       If pblck does not point to a valid allocation block in the heap,
*       _expand() will behave unpredictably and probably corrupt the heap.
*
*******************************************************************************/

void * __cdecl _expand_base (void * pBlock, size_t newsize)
{
        void *      pvReturn;


        /* validation section */
        _VALIDATE_RETURN(pBlock != NULL, EINVAL, NULL);
        if (newsize > _HEAP_MAXREQ) {
            errno = ENOMEM;
            return NULL;
        }

#ifndef _WIN64
        if ( __active_heap == __V6_HEAP )
        {
            PHEADER     pHeader;

            _mlock( _HEAP_LOCK );
            __try {

            //  if allocation block lies within the small-block heap,
            //  try to resize it there
            if ((pHeader = __sbh_find_block(pBlock)) != NULL)
            {
                pvReturn = NULL;
                if ( (newsize <= __sbh_threshold) &&
                     __sbh_resize_block(pHeader, pBlock, (int)newsize) )
                    pvReturn = pBlock;
            }

            }
            __finally {
                _munlock( _HEAP_LOCK );
            }

            if ( pHeader == NULL )
            {
                //  force nonzero size and round up to next paragraph
                if (newsize == 0)
                    newsize = 1;
                newsize = (newsize + BYTES_PER_PARA - 1) & ~(BYTES_PER_PARA - 1);

                pvReturn = HeapReAlloc(_crtheap, HEAP_REALLOC_IN_PLACE_ONLY,
                                       pBlock, newsize);

                if (pvReturn == NULL)
                {
                    errno = _get_errno_from_oserr(GetLastError());
                }
            }
        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP )
        {
            __old_sbh_region_t *preg;
            __old_sbh_page_t *  ppage;
            __old_page_map_t *  pmap;

            //  force nonzero size and round up to next paragraph
            if (newsize == 0)
                newsize = 1;
            newsize = (newsize + _OLD_PARASIZE - 1) & ~(_OLD_PARASIZE - 1);
            _mlock(_HEAP_LOCK);
            __try {
            pmap = __old_sbh_find_block(pBlock, &preg, &ppage);

            //  allocation block lies within the small-block heap, try to resize
            //  it there.
            if ( pmap != NULL )
            {
                //  *pBlock lies within the small-block heap, try to resize it
                //  there
                pvReturn = NULL;
                if ( (newsize <= __old_sbh_threshold) &&
                     __old_sbh_resize_block(preg, ppage, pmap,
                                            newsize >> _OLD_PARASHIFT) )
                    pvReturn = pBlock;

                RTCCALLBACK(_RTC_Free_hook, (pBlock, 0));
                RTCCALLBACK(_RTC_Allocate_hook, (pvReturn, newsize, 0));
            }

            }
            __finally {
                _munlock(_HEAP_LOCK);
            }

            if (pmap != NULL)
                return pvReturn;

            if ( pmap == NULL )
            {
                pvReturn = HeapReAlloc(_crtheap, HEAP_REALLOC_IN_PLACE_ONLY,
                                       pBlock, newsize);

                if (pvReturn == NULL)
                {
                    errno = _get_errno_from_oserr(GetLastError());
                }
            }
        }
#endif  /* CRTDLL */
        else    // __active_heap == __SYSTEM_HEAP
#endif  /* _WIN64 */
        {
            //  force nonzero size
            size_t oldsize = (size_t)-1;

            if (newsize == 0)
            {
                newsize = 1;
            }

            oldsize = (size_t)HeapSize(_crtheap, 0, pBlock);

            pvReturn = HeapReAlloc(_crtheap, HEAP_REALLOC_IN_PLACE_ONLY, pBlock, newsize);

            if (pvReturn == NULL)
            {
                /* If the failure is caused by the use of the LFH, just return the original block. */
                if (oldsize <= 0x4000 /* LFH can only allocate blocks up to 16 KB. */
                        && newsize <= oldsize && _is_LFH_enabled())
                    pvReturn = pBlock;
                else
                    errno = _get_errno_from_oserr(GetLastError());
            }
        }

        if (pvReturn)
        {
            RTCCALLBACK(_RTC_Free_hook, (pBlock, 0));
            RTCCALLBACK(_RTC_Allocate_hook, (pvReturn, newsize, 0));
        }

        return pvReturn;
}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fgetws.c ===
/***
*fgetws.c - get wide string from a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fgetws() - read a wide string from a file
*
*******************************************************************************/


/***
*wchar_t *fgetws(string, count, stream) - input string from a stream
*
*Purpose:
*       get a string, up to count-1 wide chars or L'\n', whichever comes first,
*       append L'\0' and put the whole thing into string. the L'\n' IS included
*       in the string. if count<=1 no input is requested. if WEOF is found
*       immediately, return NULL. if WEOF found after chars read, let WEOF
*       finish the string as L'\n' would.
*
*Entry:
*       wchar_t *string - pointer to place to store string
*       int count - max characters to place at string (include \0)
*       FILE *stream - stream to read from
*
*Exit:
*       returns wide string with text read from file in it.
*       if count <= 0 return NULL
*       if count == 1 put null string in string
*       returns NULL if error or end-of-file found immediately
*
*Exceptions:
*
*******************************************************************************/

#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "fgets.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fileno.c ===
/***
*fileno.c - defines _fileno()
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines fileno() - return the file handle for the specified stream
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <stdio.h>

/* remove macro definition for fileno()
 */
#undef  _fileno

/***
*int _fileno(stream) - return the file handle for stream
*
*Purpose:
*       Returns the file handle for the given stream is. Normally fileno()
*       is a macro, but it is also available as a true function (for
*       consistency with ANSI, though it is not required).
*
*Entry:
*       FILE *stream - stream to fetch handle for
*
*Exit:
*       returns the file handle for the given stream
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fileno (
        FILE *stream
        )
{
        _VALIDATE_RETURN((stream != NULL), EINVAL, -1);
        return( stream->_file );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\findaddr.c ===
/***
*findaddr.c - Find a heap entry
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _heap_findaddr routine
*
*******************************************************************************/

#ifndef WINHEAP

#include <cruntime.h>
#include <heap.h>
#include <stddef.h>

#define TRUE    1

/***
*int _heap_findaddr() - Find a heap entry
*
*Purpose:
*       Given an address, find the corresponding heap entry.
*
*Entry:
*       void * address = address to look for
*       PBLKDESC * ppdesc = pointer to pointer to heap descriptor to be
*               filled in by this routine.
*
*Exit:
*
*       _HEAPFIND_EXACT  =  0 = exact fit, pdesc holds heap descriptor address
*       _HEAPFIND_WITHIN =  1 = not exact fit, pdesc holds previous heap
*                               descriptor address
*
*       _HEAPFIND_BEFORE = -1 = address is before the heap (pdesc NOT filled in)
*       _HEAPFIND_AFTER  = -2 = address is after the heap (pdesc NOT filled in)
*       _HEAPFIND_EMPTY  = -3 = no memory in heap (pdesc NOT filled in)
*
*       [If return is negative, supplied pdesc is NOT filled in.]
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int  __cdecl _heap_findaddr (
        void * address,
        _PBLKDESC * ppdesc
        )
{
        REG1 _PBLKDESC pcurr;

        /*
         * See if heap there's anything in the heap
         */

        if (_heap_desc.pfirstdesc == &_heap_desc.sentinel)
                return(_HEAPFIND_EMPTY);

        /*
         * See if entry is in the heap or not
         */

        if (_ADDRESS(_heap_desc.pfirstdesc) > address)
                return(_HEAPFIND_BEFORE);

        if (_ADDRESS(&_heap_desc.sentinel) <= address)
                return(_HEAPFIND_AFTER);

        /*
         * Find the entry
         */

        for (pcurr = _heap_desc.pfirstdesc; TRUE; pcurr = pcurr->pnextdesc) {

                if ( _ADDRESS(pcurr->pnextdesc) > address ) {

                        /* Address is contained in this entry */
                        *ppdesc = pcurr;

                        /* Check for an exact fit */
                        if ( _ADDRESS(pcurr) == address)
                                return(_HEAPFIND_EXACT);
                        else
                                return(_HEAPFIND_WITHIN);
                }
        }

}

#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fflush.c ===
/***
*fflush.c - flush a stream buffer
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fflush() - flush the buffer on a stream
*               _flushall() - flush all stream buffers
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <io.h>
#include <mtdll.h>
#include <internal.h>


/* Values passed to flsall() to distinguish between _flushall() and
 * fflush(NULL) behavior
 */
#define FLUSHALL        1
#define FFLUSHNULL      0

/* Core routine for fflush(NULL) and flushall()
 */
static int __cdecl flsall(int);


/***
*int fflush(stream) - flush the buffer on a stream
*
*Purpose:
*       if file open for writing and buffered, flush the buffer. if problems
*       flushing the buffer, set the stream flag to error
*       Always flushes the stdio stream and forces a commit to disk if file
*       was opened in commit mode.
*
*Entry:
*       FILE *stream - stream to flush
*
*Exit:
*       returns 0 if flushed successfully, or no buffer to flush
*       returns EOF and sets file error flag if fails.
*       FILE struct entries affected: _ptr, _cnt, _flag.
*
*Exceptions:
*
*******************************************************************************/


int __cdecl fflush (
        REG1 FILE *stream
        )
{
        int rc;

        /* if stream is NULL, flush all streams
         */
        if ( stream == NULL )
                return(flsall(FFLUSHNULL));

        _lock_str(stream);

        __try {
                rc = _fflush_nolock(stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(rc);
}


/***
*_fflush_nolock() - Flush the buffer on a stream (stream is already locked)
*
*Purpose:
*       Core flush routine; assumes stream lock is held by caller.
*
*       [See fflush() above for more information.]
*
*Entry:
*       [See fflush()]
*Exit:
*       [See fflush()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fflush_nolock (
        REG1 FILE *str
        )
{

        /* if stream is NULL, flush all streams
         */
        if ( str == NULL )
                return(flsall(FFLUSHNULL));


        if (_flush(str) != 0) {
                /* _flush failed, don't attempt to commit */
                return(EOF);
        }

        /* lowio commit to ensure data is written to disk */
        if (str->_flag & _IOCOMMIT) {
                return (_commit(_fileno(str)) ? EOF : 0);
        }
        return 0;
}


/***
*int _flush(stream) - flush the buffer on a single stream
*
*Purpose:
*       If file open for writing and buffered, flush the buffer.  If
*       problems flushing the buffer, set the stream flag to error.
*       Multi-thread version assumes stream lock is held by caller.
*
*Entry:
*       FILE* stream - stream to flush
*
*Exit:
*       Returns 0 if flushed successfully, or if no buffer to flush.,
*       Returns EOF and sets file error flag if fails.
*       File struct entries affected: _ptr, _cnt, _flag.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flush (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int rc = 0; /* assume good return */
        REG3 int nchar;

        /* Init pointer to stream */
        stream = str;


        if ((stream->_flag & (_IOREAD | _IOWRT)) == _IOWRT && bigbuf(stream)
                && (nchar = (int)(stream->_ptr - stream->_base)) > 0)
        {
                if ( _write(_fileno(stream), stream->_base, nchar) == nchar ) {
                        /* if this is a read/write file, clear _IOWRT so that
                         * next operation can be a read
                         */
                        if ( _IORW & stream->_flag )
                                stream->_flag &= ~_IOWRT;
                }
                else {
                        stream->_flag |= _IOERR;
                        rc = EOF;
                }
        }

        stream->_ptr = stream->_base;
        stream->_cnt = 0;

        return(rc);
}


/***
*int _flushall() - flush all output buffers
*
*Purpose:
*       flushes all the output buffers to the file, clears all input buffers.
*
*Entry:
*       None.
*
*Exit:
*       returns number of open streams
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _flushall (
        void
        )
{
        return(flsall(FLUSHALL));
}


/***
*static int flsall(flushflag) - flush all output buffers
*
*Purpose:
*       Flushes all the output buffers to the file and, if FLUSHALL is passed,
*       clears all input buffers. Core routine for both fflush(NULL) and
*       flushall().
*
*       MTHREAD Note: All the locking/unlocking required for both fflush(NULL)
*       and flushall() is performed in this routine.
*
*Entry:
*       int flushflag - flag indicating the exact semantics, there are two
*                       legal values: FLUSHALL and FFLUSHNULL
*
*Exit:
*       if flushflag == FFLUSHNULL then flsbuf returns:
                0, if successful
*               EOF, if an error occurs while flushing one of the streams
*
*       if flushflag == FLUSHALL then flsbuf returns the number of streams
*       successfully flushed
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl flsall (
        int flushflag
        )
{
        REG1 int i;
        int count = 0;
        int err = 0;

        _mlock(_IOB_SCAN_LOCK);
        __try {

        for ( i = 0 ; i < _nstream ; i++ ) {

                if ( (__piob[i] != NULL) && (inuse((FILE *)__piob[i])) ) {

                        /*
                         * lock the stream. this is not done until testing
                         * the stream is in use to avoid unnecessarily creating
                         * a lock for every stream. the price is having to
                         * retest the stream after the lock has been asserted.
                         */
                        _lock_str2(i, __piob[i]);

                        __try {
                                /*
                                 * if the stream is STILL in use (it may have been
                                 * closed before the lock was asserted), see about
                                 * flushing it.
                                 */
                                if ( inuse((FILE *)__piob[i]) ) {

                        if ( flushflag == FLUSHALL ) {
                                /*
                                 * FLUSHALL functionality: fflush the read or
                                 * write stream and, if successful, update the
                                 * count of flushed streams
                                 */
                                if ( _fflush_nolock(__piob[i]) != EOF )
                                        /* update count of successfully flushed
                                         * streams
                                         */
                                        count++;
                        }
                        else if ( (flushflag == FFLUSHNULL) &&
                                  (((FILE *)__piob[i])->_flag & _IOWRT) ) {
                                /*
                                 * FFLUSHNULL functionality: fflush the write
                                 * stream and kept track of the error, if one
                                 * occurs
                                 */
                                if ( _fflush_nolock(__piob[i]) == EOF )
                                        err = EOF;
                        }

                                }
                        }
                        __finally {
                                _unlock_str2(i, __piob[i]);
                        }
                }
        }

        }
        __finally {
                _munlock(_IOB_SCAN_LOCK);
        }

        if ( flushflag == FLUSHALL )
                return(count);
        else
                return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\findf64.c ===
/***
*findf64.c - C find file functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _findfirst64() and _findnext64(), OR
*       defines _findfirst64i32() and _findnext64i32() depending
*       on the state of _USE_INT64 flag
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <io.h>
#include <time.h>
#include <ctime.h>
#include <string.h>
#include <stdlib.h>
#include <internal.h>
#include <tchar.h>

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif  /* _WIN32 */

#ifndef _USE_INT64
#define _USE_INT64 1
#endif  /* _USE_INT64 */

__time64_t __cdecl __time64_t_from_ft(FILETIME * pft);

/***
*long _findfirst(wildspec, finddata) - Find first matching file
*
*Purpose:
*       Finds the first file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       char * wild - file spec optionally containing wild cards
*
*       struct _finddata64_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       Unique handle identifying the group of files matching the spec
*
*       Error return:
*       Returns -1 and errno is set to error value
*
*Exceptions:
*       None.
*
*******************************************************************************/

#if _USE_INT64

intptr_t __cdecl _tfindfirst64(
        const _TSCHAR * szWild,
        struct _tfinddata64_t * pfd
        )

#else  /* _USE_INT64 */

intptr_t __cdecl _tfindfirst64i32(
        const _TSCHAR * szWild,
        struct _tfinddata64i32_t * pfd
        )

#endif  /* _USE_INT64 */

{
        WIN32_FIND_DATA wfd;
        HANDLE          hFile;
        DWORD           err;

        _VALIDATE_RETURN( (pfd != NULL), EINVAL, -1);

        /* We assert to make sure the underlying Win32 struct WIN32_FIND_DATA's
        cFileName member doesn't have an array size greater than ours */

        _VALIDATE_RETURN( (sizeof(pfd->name) <= sizeof(wfd.cFileName)), ENOMEM, -1);
        _VALIDATE_RETURN( (szWild != NULL), EINVAL, -1);

        if ((hFile = FindFirstFile(szWild, &wfd)) == INVALID_HANDLE_VALUE) {
            err = GetLastError();
            switch (err) {
                case ERROR_NO_MORE_FILES:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    errno = ENOENT;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                    errno = ENOMEM;
                    break;

                default:
                    errno = EINVAL;
                    break;
            }
            return (-1);
        }

        pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                            ? 0 : wfd.dwFileAttributes;
        pfd->time_create  = __time64_t_from_ft(&wfd.ftCreationTime);
        pfd->time_access  = __time64_t_from_ft(&wfd.ftLastAccessTime);
        pfd->time_write   = __time64_t_from_ft(&wfd.ftLastWriteTime);
#if _USE_INT64
        pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                            (__int64)(wfd.nFileSizeLow);
#else  /* _USE_INT64 */
    pfd->size         = wfd.nFileSizeLow;
#endif  /* _USE_INT64 */

        _ERRCHECK(_tcscpy_s(pfd->name, _countof(pfd->name), wfd.cFileName));

        return ((intptr_t)hFile);
}

/***
*int _findnext(hfind, finddata) - Find next matching file
*
*Purpose:
*       Finds the next file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       hfind - handle from _findfirst
*
*       struct _finddata64_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       0 if file found
*       -1 if error or file not found
*       errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

#if _USE_INT64

int __cdecl _tfindnext64(intptr_t hFile, struct _tfinddata64_t * pfd)

#else  /* _USE_INT64 */

int __cdecl _tfindnext64i32(intptr_t hFile, struct _tfinddata64i32_t * pfd)

#endif  /* _USE_INT64 */

{
        WIN32_FIND_DATA wfd;
        DWORD           err;

        _VALIDATE_RETURN( ((HANDLE)hFile != INVALID_HANDLE_VALUE), EINVAL, -1);
        _VALIDATE_RETURN( (pfd != NULL), EINVAL, -1);
        _VALIDATE_RETURN( (sizeof(pfd->name) <= sizeof(wfd.cFileName)), ENOMEM, -1);

        if (!FindNextFile((HANDLE)hFile, &wfd)) {
            err = GetLastError();
            switch (err) {
                case ERROR_NO_MORE_FILES:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    errno = ENOENT;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                    errno = ENOMEM;
                    break;

                default:
                    errno = EINVAL;
                    break;
            }
            return (-1);
        }

        pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                            ? 0 : wfd.dwFileAttributes;
        pfd->time_create  = __time64_t_from_ft(&wfd.ftCreationTime);
        pfd->time_access  = __time64_t_from_ft(&wfd.ftLastAccessTime);
        pfd->time_write   = __time64_t_from_ft(&wfd.ftLastWriteTime);
#if _USE_INT64
        pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                            (__int64)(wfd.nFileSizeLow);
#else  /* _USE_INT64 */
        pfd->size         = wfd.nFileSizeLow;
#endif  /* _USE_INT64 */

        _ERRCHECK(_tcscpy_s(pfd->name, _countof(pfd->name), wfd.cFileName));

        return (0);
}

#if !defined (_UNICODE) && !_USE_INT64

/***
*time64_t __time64_t_from_ft(ft) - convert Win32 file time to Xenix time
*
*Purpose:
*       converts a Win32 file time value to Xenix time_t
*
*       Note: We cannot directly use the ft value. In Win32, the file times
*       returned by the API are ambiguous. In Windows NT, they are UTC. In
*       Win32S, and probably also Win32C, they are local time values. Thus,
*       the value in ft must be converted to a local time value (by an API)
*       before we can use it.
*
*Entry:
*       int yr, mo, dy -        date
*       int hr, mn, sc -        time
*
*Exit:
*       returns Xenix time value
*
*Exceptions:
*
*******************************************************************************/

__time64_t __cdecl __time64_t_from_ft(FILETIME * pft)
{
        SYSTEMTIME st;
        FILETIME lft;

        /* 0 FILETIME returns a -1 time_t */

        if (!pft->dwLowDateTime && !pft->dwHighDateTime) {
            return ((__time64_t)-1);
        }

        /*
         * Convert to a broken down local time value
         */
        if ( !FileTimeToLocalFileTime(pft, &lft) ||
             !FileTimeToSystemTime(&lft, &st) )
        {
            return ((__time64_t)-1);
        }

        return ( __loctotime64_t(st.wYear,
                                 st.wMonth,
                                 st.wDay,
                                 st.wHour,
                                 st.wMinute,
                                 st.wSecond,
                                 -1) );
}

#endif  /* !defined (_UNICODE) && !_USE_INT64 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\findfi64.c ===
/***
*findfi64.c - C find file functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _findfirsti64() and _findnexti64().
*
*******************************************************************************/

#define _USE_INT64  1

#include "findfile.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\execvpe.c ===
/***
*execvpe.c - execute a file with given environ; search along PATH
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _execvpe() - execute a file with given environ
*
*******************************************************************************/

#include <cruntime.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <process.h>
#include <mbstring.h>
#include <tchar.h>
#include <dbgint.h>
#include <internal.h>

#define SLASHCHAR _T('\\')
#define XSLASHCHAR _T('/')

#define SLASH _T("\\")
#define DELIMITER _T(";")

#ifdef _MBCS
/* note, the macro below assumes p is to pointer to a single-byte character
 * or the 1st byte of a double-byte character, in a string.
 */
#define ISPSLASH(p)     ( ((p) == _mbschr((p), SLASHCHAR)) || ((p) == \
_mbschr((p), XSLASHCHAR)) )
#else  /* _MBCS */
#define ISSLASH(c)      ( ((c) == SLASHCHAR) || ((c) == XSLASHCHAR) )
#endif  /* _MBCS */


/***
*int _execvpe(filename, argvector, envvector) - execute a file
*
*Purpose:
*       Executes a file with given arguments and environment.
*       try to execute the file. start with the name itself (directory '.'),
*       and if that doesn't work start prepending pathnames from the
*       environment until one works or we run out. if the file is a pathname,
*       don't go to the environment to get alternate paths. If a needed text
*       file is busy, wait a little while and try again before despairing
*       completely
*
*Entry:
*       _TSCHAR *filename        - file to execute
*       _TSCHAR **argvector - vector of arguments
*       _TSCHAR **envvector - vector of environment variables
*
*Exit:
*       destroys the calling process (hopefully)
*       if fails, returns -1
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _texecvpe (
        REG3 const _TSCHAR *filename,
        const _TSCHAR * const *argvector,
        const _TSCHAR * const *envptr
        )
{
        _TSCHAR *envbuf = NULL;
        REG1 _TSCHAR *env;
        _TSCHAR *bbuf = NULL;
        REG2 _TSCHAR *buf;
        _TSCHAR *pfin;

        /* validation section */
        _VALIDATE_RETURN(filename != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*filename != _T('\0'), EINVAL, -1);
        _VALIDATE_RETURN(argvector != NULL, EINVAL, -1);
        _VALIDATE_RETURN(*argvector != NULL, EINVAL, -1);
        _VALIDATE_RETURN(**argvector != _T('\0'), EINVAL, -1);

        /* it is ok to reset errno here, because if exec succeeds, we'll lose errno,
         * and if exec fails, errno will be set to something != 0
         */
        errno = 0;

        _texecve(filename,argvector,envptr);

        if ( (errno != ENOENT)
        || (_tcschr(filename, SLASHCHAR) != NULL)
        || (_tcschr(filename, XSLASHCHAR) != NULL)
        || *filename && *(filename+1) == _T(':')
        || (_ERRCHECK_EINVAL(_tdupenv_s_crt(&envbuf, NULL, _T("PATH"))) != 0)
        || envbuf == NULL
        )
                goto reterror;

        /* allocate a buffer to hold alternate pathnames for the executable
         */
        if ( (buf = bbuf = _calloc_crt(_MAX_PATH, sizeof(_TSCHAR))) == NULL )
            goto reterror;

        env = envbuf;
        do {
            /* copy a component into bbuf[], taking care not to overflow it
                */
            while ( (*env) && (*env != _T(';')) && (buf < (bbuf + (_MAX_PATH-2))) )
            {
                if(_istleadbyte(*env))
                {
                    if(env[1]==_T('\0') || buf+1>=(bbuf + (_MAX_PATH-2)))
                    {
                        /* dump if leadbyte followed by 0, or if leadbyte would be last item in buffer */
                        break;
                    }
                    /* copy leadbyte char; already checked for space for two */
                    *buf++ = *env++;
                }
                *buf++ = *env++;
            }

            *buf = _T('\0');
            if (buf > bbuf)
            {
                pfin = --buf;
            }
            else
            {
                pfin = buf;
            }
            buf = bbuf;

#ifdef _MBCS
            if (*pfin == SLASHCHAR) {
                    if (pfin != _mbsrchr(buf,SLASHCHAR))
                            /* *pfin is the second byte of a double-byte
                                * character
                                */
                            _ERRCHECK(strcat_s( buf, _MAX_PATH, SLASH ));
            }
            else if (*pfin != XSLASHCHAR)
                    _ERRCHECK(strcat_s(buf, _MAX_PATH, SLASH));
#else  /* _MBCS */
            if (*pfin != SLASHCHAR && *pfin != XSLASHCHAR)
                    _ERRCHECK(_tcscat_s(buf, _MAX_PATH, SLASH));
#endif  /* _MBCS */

            /* check that the final path will be of legal size. if so,
                * build it. otherwise, return to the caller (return value
                * and errno rename set from initial call to _execve()).
                */
            if ( (_tcslen(buf) + _tcslen(filename)) < _MAX_PATH )
                    _ERRCHECK(_tcscat_s(buf, _MAX_PATH, filename));
            else
                    break;

            /* it is ok to reset errno here, because if exec succeeds, we'll lose errno,
             * and if exec fails, errno will be set to something != 0
             */
            errno = 0;

            _texecve(buf, argvector, envptr);

            if ( (errno != ENOENT)
#ifdef _MBCS
            && (!ISPSLASH(buf) || !ISPSLASH(buf+1)) )
#else  /* _MBCS */
            && (!ISSLASH(*buf) || !ISSLASH(*(buf+1))) )
#endif  /* _MBCS */
                    break;

        } while ( *env && env++ );

reterror:
        if (bbuf != NULL)
                _free_crt(bbuf);
        if (envbuf != NULL)
                _free_crt(envbuf);

        return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\findfile.c ===
/***
*findfile.c - C find file functions
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _findfirst(), _findnext(), and _findclose().
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <errno.h>
#include <io.h>
#include <time.h>
#include <ctime.h>
#include <string.h>
#include <stdlib.h>
#include <internal.h>
#include <tchar.h>

#ifndef _WIN32
#error ERROR - ONLY WIN32 TARGET SUPPORTED!
#endif  /* _WIN32 */

__time32_t __cdecl __timet_from_ft(FILETIME * pft);

/***
*intptr_t _findfirst32(wildspec, finddata) - Find first matching file
*
*Purpose:
*       Finds the first file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       char * wild - file spec optionally containing wild cards
*
*       struct _finddata_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       Unique handle identifying the group of files matching the spec
*
*       Error return:
*       Returns -1 and errno is set to error value
*
*Exceptions:
*       None.
*
*******************************************************************************/

#ifdef _USE_INT64

intptr_t __cdecl _tfindfirst32i64(
        const _TSCHAR * szWild,
        struct _tfinddata32i64_t * pfd
        )

#else  /* _USE_INT64 */

intptr_t __cdecl _tfindfirst32(
        const _TSCHAR * szWild,
        struct _tfinddata32_t * pfd
        )

#endif  /* _USE_INT64 */

{
    WIN32_FIND_DATA wfd;
    HANDLE          hFile;
    DWORD           err;

    _VALIDATE_RETURN( (pfd != NULL), EINVAL, -1);

    /* We assert to make sure the underlying Win32 struct WIN32_FIND_DATA's
    cFileName member doesn't have an array size greater than ours */

    _VALIDATE_RETURN( (sizeof(pfd->name) <= sizeof(wfd.cFileName)), ENOMEM, -1);
    _VALIDATE_RETURN( (szWild != NULL) , EINVAL, -1);

    if ((hFile = FindFirstFile(szWild, &wfd)) == INVALID_HANDLE_VALUE) {
        err = GetLastError();
        switch (err) {
            case ERROR_NO_MORE_FILES:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                errno = ENOENT;
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                errno = ENOMEM;
                break;

            default:
                errno = EINVAL;
                break;
        }
        return (-1);
    }

    pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                      ? 0 : wfd.dwFileAttributes;
    pfd->time_create  = __timet_from_ft(&wfd.ftCreationTime);
    pfd->time_access  = __timet_from_ft(&wfd.ftLastAccessTime);
    pfd->time_write   = __timet_from_ft(&wfd.ftLastWriteTime);

#ifdef _USE_INT64
    pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(wfd.nFileSizeLow);
#else  /* _USE_INT64 */
    pfd->size         = wfd.nFileSizeLow;
#endif  /* _USE_INT64 */

    _ERRCHECK(_tcscpy_s(pfd->name, _countof(pfd->name), wfd.cFileName));

    return ((intptr_t)hFile);
}

/***
*int _findnext(hfind, finddata) - Find next matching file
*
*Purpose:
*       Finds the next file matching a given wild card filespec and
*       returns data about the file.
*
*Entry:
*       hfind - handle from _findfirst
*
*       struct _finddata_t * finddata - structure to receive file data
*
*Exit:
*       Good return:
*       0 if file found
*       -1 if error or file not found
*       errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

#ifdef _USE_INT64

int __cdecl _tfindnext32i64(intptr_t hFile, struct _tfinddata32i64_t * pfd)

#else  /* _USE_INT64 */

int __cdecl _tfindnext32(intptr_t hFile, struct _tfinddata32_t * pfd)

#endif  /* _USE_INT64 */

{
    WIN32_FIND_DATA wfd;
    DWORD           err;

    _VALIDATE_RETURN( ((HANDLE)hFile != INVALID_HANDLE_VALUE), EINVAL, -1);
    _VALIDATE_RETURN( (pfd != NULL), EINVAL, -1);
    _VALIDATE_RETURN( (sizeof(pfd->name) <= sizeof(wfd.cFileName)), ENOMEM, -1);

    if (!FindNextFile((HANDLE)hFile, &wfd)) {
        err = GetLastError();
        switch (err) {
            case ERROR_NO_MORE_FILES:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                errno = ENOENT;
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                errno = ENOMEM;
                break;

            default:
                errno = EINVAL;
                break;
        }
        return (-1);
    }

    pfd->attrib       = (wfd.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)
                      ? 0 : wfd.dwFileAttributes;
    pfd->time_create  = __timet_from_ft(&wfd.ftCreationTime);
    pfd->time_access  = __timet_from_ft(&wfd.ftLastAccessTime);
    pfd->time_write   = __timet_from_ft(&wfd.ftLastWriteTime);

#ifdef _USE_INT64
    pfd->size         = ((__int64)(wfd.nFileSizeHigh)) * (0x100000000i64) +
                        (__int64)(wfd.nFileSizeLow);
#else  /* _USE_INT64 */
    pfd->size         = wfd.nFileSizeLow;
#endif  /* _USE_INT64 */

    _ERRCHECK(_tcscpy_s(pfd->name, _countof(pfd->name), wfd.cFileName));

    return (0);
}

#if !defined (_UNICODE) && !defined (_USE_INT64)

/***
*int _findclose(hfind) - Release resources of find
*
*Purpose:
*       Releases resources of a group of files found by _findfirst and
*       _findnext
*
*Entry:
*       hfind - handle from _findfirst
*
*Exit:
*       Good return:
*       0 if success
*       -1 if fail, errno set
*
*Exceptions:
*       None.
*
*******************************************************************************/

int __cdecl _findclose(intptr_t hFile)
{
    if (!FindClose((HANDLE)hFile)) {
        errno = EINVAL;
        return (-1);
    }
    return (0);
}


/***
*__time32_t _fttotimet(ft) - convert Win32 file time to Xenix time
*
*Purpose:
*       converts a Win32 file time value to Xenix time_t
*
*       Note: We cannot directly use the ft value. In Win32, the file times
*       returned by the API are ambiguous. In Windows NT, they are UTC. In
*       Win32S, and probably also Win32C, they are local time values. Thus,
*       the value in ft must be converted to a local time value (by an API)
*       before we can use it.
*
*Entry:
*       int yr, mo, dy -        date
*       int hr, mn, sc -        time
*
*Exit:
*       returns Xenix time value
*
*Exceptions:
*
*******************************************************************************/

__time32_t __cdecl __timet_from_ft(FILETIME * pft)
{
    SYSTEMTIME st;
    FILETIME lft;

    /* 0 FILETIME returns a -1 time_t */

    if (!pft->dwLowDateTime && !pft->dwHighDateTime) {
        return (-1L);
    }

    /*
     * Convert to a broken down local time value
     */
    if ( !FileTimeToLocalFileTime(pft, &lft) ||
         !FileTimeToSystemTime(&lft, &st) )
    {
        return (-1L);
    }

    return ( __loctotime32_t(st.wYear,
                             st.wMonth,
                             st.wDay,
                             st.wHour,
                             st.wMinute,
                             st.wSecond,
                             0) );
}

#endif  /* !defined (_UNICODE) && !defined (_USE_INT64) */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fiopen.cpp ===
// fiopen -- _Fiopen(const char */const wchar_t *, ios_base::openmode)
#include <fstream>
#include <internal.h>
#include <windows.h>

 #if _FN_WIDE
_STD_BEGIN

_CRTIMP2_PURE FILE *__CLRCALL_PURE_OR_CDECL _Fiopen(const char *filename,
	ios_base::openmode mode, int prot)
	{	// open wide-named file with byte name
	wchar_t wc_name[FILENAME_MAX];


	if (mbstowcs_s(NULL, wc_name, FILENAME_MAX, filename, FILENAME_MAX - 1) != 0)
		return (0);
	return _Fiopen(wc_name, mode, prot);
	}

_CRTIMP2_PURE FILE *__CLRCALL_PURE_OR_CDECL _Xfsopen(_In_z_ const wchar_t *filename, _In_z_ const wchar_t *mode, _In_ int prot)
	{
	return _wfsopen(filename, mode, prot);
	}

  #ifndef _SYSCH
   #define _SYSCH(x)	L ## x
typedef wchar_t _Sysch_t;
  #endif /* _SYSCH */

 #else /* _FN_WIDE */
  #define _Xfsopen	_fsopen

  #ifndef _SYSCH
   #define _SYSCH(x)	x
_C_STD_BEGIN
typedef char _Sysch_t;
_C_STD_END
  #endif /* _SYSCH */

_STD_BEGIN

_CRTIMP2_PURE FILE *__CLRCALL_PURE_OR_CDECL _Fiopen(const wchar_t *filename,
	ios_base::openmode mode, int prot)
	{	// open byte-named file with wide name
	char c_name[FILENAME_MAX];

	if (wcstombs_s(NULL, c_name, FILENAME_MAX, filename, FILENAME_MAX - 1) != 0)
		return (0);
	return _Fiopen(c_name, mode, prot);
	}

 #endif /* _FN_WIDE */

_CRTIMP2_PURE FILE *__CLRCALL_PURE_OR_CDECL _Fiopen(const _Sysch_t *filename,
	ios_base::openmode mode, int prot)
	{	// open a file with native name
	static const _Sysch_t *mods[] =
		{	// fopen mode strings corresponding to valid[i]
		_SYSCH("r"), _SYSCH("w"), _SYSCH("w"), _SYSCH("a"),
		_SYSCH("rb"), _SYSCH("wb"), _SYSCH("wb"), _SYSCH("ab"),
		_SYSCH("r+"), _SYSCH("w+"), _SYSCH("a+"),
		_SYSCH("r+b"), _SYSCH("w+b"), _SYSCH("a+b"),
		0};

	static const int valid[] =
		{	// valid combinations of open flags
		ios_base::in,
		ios_base::out,
		ios_base::out | ios_base::trunc,
		ios_base::out | ios_base::app,
		ios_base::in | ios_base::binary,
		ios_base::out | ios_base::binary,
		ios_base::out | ios_base::trunc | ios_base::binary,
		ios_base::out | ios_base::app | ios_base::binary,
		ios_base::in | ios_base::out,
		ios_base::in | ios_base::out | ios_base::trunc,
		ios_base::in | ios_base::out | ios_base::app,
		ios_base::in | ios_base::out | ios_base::binary,
		ios_base::in | ios_base::out | ios_base::trunc
			| ios_base::binary,
		ios_base::in | ios_base::out | ios_base::app
			| ios_base::binary,
		0};

	FILE *fp = 0;
	int n;
	ios_base::openmode atendflag = mode & ios_base::ate;
	ios_base::openmode norepflag = mode & ios_base::_Noreplace;

	if (mode & ios_base::_Nocreate)
		mode |= ios_base::in;	// file must exist
	if (mode & ios_base::app)
		mode |= ios_base::out;	// extension -- app implies out

	mode &= ~(ios_base::ate | ios_base::_Nocreate | ios_base::_Noreplace);
	for (n = 0; valid[n] != 0 && valid[n] != mode; ++n)
		;	// look for a valid mode

	if (valid[n] == 0)
		return (0);	// no valid mode
	else if (norepflag && mode & (ios_base::out || ios_base::app)
		&& (fp = _Xfsopen(filename, _SYSCH("r"), prot)) != 0)
		{	// file must not exist, close and fail
		fclose(fp);
		return (0);
		}
	else if (fp != 0 && fclose(fp) != 0)
		return (0);	// can't close after test open
	else if ((fp = _Xfsopen(filename, mods[n], prot)) == 0)
		return (0);	// open failed

	if (!atendflag || fseek(fp, 0, SEEK_END) == 0)
		return (fp);	// no need to seek to end, or seek succeeded

	fclose(fp);	// can't position at end
	return (0);
		}

 #ifdef _NATIVE_WCHAR_T_DEFINED
_CRTIMP2_PURE _Filet *__CLRCALL_PURE_OR_CDECL _Fiopen(const unsigned short *_Filename,
	ios_base::openmode _Mode, int _Prot)
	{	// open file with wide name
	return (_Fiopen((wchar_t*)(_Filename), _Mode, _Prot));
	}
 #endif

_STD_END

/*
 * Copyright (c) 1992-2007 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fleni64.c ===
/***
*fleni64.c - find length of a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _filelengthi64() - find the length of a file
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <errno.h>
#include <io.h>
#include <internal.h>
#include <msdos.h>
#include <mtdll.h>
#include <stddef.h>
#include <stdlib.h>

/***
*__int64 _filelengthi64(filedes) - find length of a file
*
*Purpose:
*       Returns the length in bytes of the specified file.
*
*Entry:
*       int filedes - handle referring to file to find length of
*
*Exit:
*       returns length of file in bytes
*       returns -1i64 if fails
*
*Exceptions:
*
*******************************************************************************/

__int64 __cdecl _filelengthi64 (
        int filedes
        )
{
        __int64 length;
        __int64 here;

        _CHECK_FH_CLEAR_OSSERR_RETURN( filedes, EBADF, -1i64 );
        _VALIDATE_CLEAR_OSSERR_RETURN((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF, -1i64);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(filedes) & FOPEN), EBADF, -1i64);

        _lock_fh(filedes);
        __try {
                if ( _osfile(filedes) & FOPEN ) {

        /* Seek to end (and back) to get the file length. */

        if ( (here = _lseeki64_nolock( filedes, 0i64, SEEK_CUR )) == -1i64 )
            length = -1i64;     /* return error */
        else {
            length = _lseeki64_nolock( filedes, 0i64, SEEK_END );
            if ( here != length )
                _lseeki64_nolock( filedes, here, SEEK_SET );
        }

                }
                else {
                        errno = EBADF;
                        _doserrno = 0L;
                        length = -1i64;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                _unlock_fh(filedes);
        }

        return( length );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fcvt.c ===
/***
*fcvt.c - convert floating point value to string
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Converts a floating point value to a string.
*
*******************************************************************************/

#include <cruntime.h>
#include <fltintrn.h>
#include <cvt.h>
#include <mtdll.h>
#include <stdlib.h>
#include <dbgint.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <setlocal.h>

/*
 * The static character array buf[_CVTBUFSIZE] is used by the _fpcvt routine
 * (the workhorse for _ecvt and _fcvt) for storage of its output.  The routine
 * gcvt expects the user to have set up their own storage.  _CVTBUFSIZE is set
 * large enough to accomodate the largest double precision number plus 40
 * decimal places (even though you only have 16 digits of accuracy in a
 * double precision IEEE number, the user may ask for more to effect 0
 * padding; but there has to be a limit somewhere).
 */

/*
 * define a maximum size for the conversion buffer.  It should be at least
 * as long as the number of digits in the largest double precision value
 * (?.?e308 in IEEE arithmetic).  We will use the same size buffer as is
 * used in the printf support routine (_output)
 */

static errno_t __cdecl _fpcvt(char*, size_t, STRFLT, int, int *, int *);


/***
*errocde _fcvt_s(result, sizeInChars, value, ndec, decpr, sign) - convert floating point to char string
*
*Purpose:
*   _fcvt like _ecvt converts the value to a null terminated
*   string of ASCII digits, and returns a pointer to the
*   result.  The routine prepares data for Fortran F-format
*   output with the number of digits following the decimal
*   point specified by ndec.  The position of the decimal
*   point relative to the beginning of the string is returned
*   indirectly through decpt.  The correct digit for Fortran
*   F-format is rounded.
*   NOTE - to avoid the possibility of generating floating
*   point instructions in this code we fool the compiler
*   about the type of the 'value' parameter using a struct.
*   This is OK since all we do is pass it off as a
*   parameter.
*
*Entry:
*   char * result - pointer to the string that will receive the output
*   size_t sizeInChars - size of the output string
*   double value - number to be converted
*   int ndec - number of digits after decimal point
*
*Exit:
*   returns errno_t != 0 if something went wrong (check the validation section below).
*   char * result - the output is written into the given result string
*   int *decpt - pointer to int with pos. of dec. point
*   int *sign - pointer to int with sign (0 = pos, non-0 = neg)
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

errno_t __cdecl _fcvt_s (
    char *result,
    size_t sizeInChars,
    double value,
    int ndec,
    int *decpt,
    int *sign
    )
{

    REG1 STRFLT pflt;
    _CRT_DOUBLE *pdvalue = (_CRT_DOUBLE *)&value;
    REG4 int digits = 0;

    struct _strflt strfltstruct;
    char resultstring[22 /* MAX_MAN_DIGITS+1 */];

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(result != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(sizeInChars > 0, EINVAL);
    _RESET_STRING(result, sizeInChars);
    _VALIDATE_RETURN_ERRCODE(decpt != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(sign != NULL, EINVAL);

    /* ok to take address of stack struct here; fltout2 knows to use ss */
    pflt = _fltout2( *pdvalue, &strfltstruct, resultstring, _countof(resultstring) );

    digits = pflt->decpt + ndec;

    /* if we detect overflow then set number of digits to the largest possible */
    if (ndec > 0 && pflt->decpt > 0 && digits < ndec)
    {
        digits = INT_MAX;
    }

    return( _fpcvt( result, sizeInChars, pflt, digits, decpt, sign ) );
}

/***
*char *_fcvt(value, ndec, decpr, sign) - convert floating point to char string
*
*Purpose:
*   _fcvt like _ecvt converts the value to a null terminated
*   string of ASCII digits, and returns a pointer to the
*   result.  The routine prepares data for Fortran F-format
*   output with the number of digits following the decimal
*   point specified by ndec.  The position of the decimal
*   point relative to the beginning of the string is returned
*   indirectly through decpt.  The correct digit for Fortran
*   F-format is rounded.
*   NOTE - to avoid the possibility of generating floating
*   point instructions in this code we fool the compiler
*   about the type of the 'value' parameter using a struct.
*   This is OK since all we do is pass it off as a
*   parameter.
*
*Entry:
*   double value - number to be converted
*   int ndec - number of digits after decimal point
*
*Exit:
*   returns pointer to the character string representation of value.
*   also, the output is written into the static char array buf.
*   int *decpt - pointer to int with pos. of dec. point
*   int *sign - pointer to int with sign (0 = pos, non-0 = neg)
*
*Exceptions:
*   Input parameters are validated like in _fcvt_s. Returns NULL if something goes wrong.
*   The function is deprecated, unless the user defines _DO_NOT_DEPRECATE_UNSAFE_FUNCTIONS.
*
*******************************************************************************/

char * __cdecl _fcvt (
    double value,
    int ndec,
    int *decpt,
    int *sign
    )
{
    errno_t e = 0;
    REG1 STRFLT pflt;
    _CRT_DOUBLE *pdvalue = (_CRT_DOUBLE *)&value;


    /* use a per-thread buffer */
    char *buf;
    _ptiddata ptd;
    struct _strflt strfltstruct;
    char resultstring[22 /* MAX_MAN_DIGITS+1 */];

    ptd = _getptd_noexit();
    if (!ptd)
        return NULL;
    if ( ptd->_cvtbuf == NULL )
        if ( (ptd->_cvtbuf = (char *)_malloc_crt(_CVTBUFSIZE)) == NULL )
            return(NULL);
    buf = ptd->_cvtbuf;

    /* ok to take address of stack struct here; fltout2 knows to use ss */
    pflt = _fltout2( *pdvalue, &strfltstruct, resultstring, _countof(resultstring) );

    /* make sure we don't overflow the buffer size.  If the user asks for
     * more digits than the buffer can handle, truncate it to the maximum
     * size allowed in the buffer.
     */
    ndec = min(ndec, _CVTBUFSIZE - 2 - pflt->decpt);

    e = _fcvt_s( buf, _CVTBUFSIZE, value, ndec, decpt, sign );
    if ( e != 0 )
    {
        return NULL;
    }
    return buf;
}


/***
*char *_ecvt_s(result, sizeInChars, value, ndigit, decpt, sign) - convert floating point to string
*
*Purpose:
*   _ecvt converts value to a null terminated string of
*   ASCII digits, and returns a pointer to the result.
*   The position of the decimal point relative to the
*   begining of the string is stored indirectly through
*   decpt, where negative means to the left of the returned
*   digits.  If the sign of the result is negative, the
*   word pointed to by sign is non zero, otherwise it is
*   zero.  The low order digit is rounded.
*
*Entry:
*   char * result - pointer to the string that will receive the output
*   size_t sizeInChars - size of the output string
*   double value - number to be converted
*   int ndec - number of digits after decimal point
*
*Exit:
*   returns errno_t != 0 if something went wrong (check the validation section below).
*   char * result - the output is written into the given result string
*   int *decpt - pointer to int with pos. of dec. point
*   int *sign - pointer to int with sign (0 = pos, non-0 = neg)
*
*Exceptions:
*   Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

errno_t __cdecl _ecvt_s (
    char *result,
    size_t sizeInChars,
    double value,
    int ndigit,
    int *decpt,
    int *sign
    )
{
    _CRT_DOUBLE *pdvalue = (_CRT_DOUBLE *)&value;
    REG1 STRFLT pflt;

    struct _strflt strfltstruct;        /* temporary buffers */
    char resultstring[22 /* MAX_MAN_DIGITS+1 */];

    errno_t e;

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(result != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(sizeInChars > 0, EINVAL);
    _RESET_STRING(result, sizeInChars);
    _VALIDATE_RETURN_ERRCODE(decpt != NULL, EINVAL);
    _VALIDATE_RETURN_ERRCODE(sign != NULL, EINVAL);

    /* ok to take address of stack struct here; fltout2 knows to use ss */
    pflt = _fltout2( *pdvalue, &strfltstruct, resultstring, _countof(resultstring) );

    e = _fpcvt( result, sizeInChars, pflt, ndigit, decpt, sign );

    /* make sure we don't overflow the buffer size.  If the user asks for
     * more digits than the buffer can handle, truncate it to the maximum
     * size allowed in the buffer.  The maximum size is sizeInChars - 2
     * since we use one character for overflow and one for the terminating
     * null character.
     */
    if (ndigit > (int)(sizeInChars - 2))
    {
        ndigit = (int)(sizeInChars - 2);
    }

    /* _fptostr() occasionally returns an extra character in the buffer ... */
    if (ndigit >= 0 && result[ndigit])
        result[ndigit] = '\0';

    return e;
}

/***
*char *_ecvt(value, ndigit, decpt, sign) - convert floating point to string
*
*Purpose:
*   _ecvt converts value to a null terminated string of
*   ASCII digits, and returns a pointer to the result.
*   The position of the decimal point relative to the
*   begining of the string is stored indirectly through
*   decpt, where negative means to the left of the returned
*   digits.  If the sign of the result is negative, the
*   word pointed to by sign is non zero, otherwise it is
*   zero.  The low order digit is rounded.
*
*Entry:
*   double value - number to be converted
*   int ndigit - number of digits after decimal point
*
*Exit:
*   returns pointer to the character representation of value.
*   also the output is written into the statuc char array buf.
*   int *decpt - pointer to int with position of decimal point
*   int *sign - pointer to int with sign in it (0 = pos, non-0 = neg)
*
*Exceptions:
*   Input parameters are validated like in _ecvt_s. Returns NULL if something goes wrong.
*   The function is deprecated, unless the user defines _DO_NOT_DEPRECATE_UNSAFE_FUNCTIONS.
*
*******************************************************************************/

char * __cdecl _ecvt (
    double value,
    int ndigit,
    int *decpt,
    int *sign
    )
{
    errno_t e = 0;

    /* use a per-thread buffer */

    char *buf;

    _ptiddata ptd;

    ptd = _getptd_noexit();
    if (!ptd)
        return NULL;
    if ( ptd->_cvtbuf == NULL )
        if ( (ptd->_cvtbuf = (char *)_malloc_crt(_CVTBUFSIZE)) == NULL )
            return(NULL);
    buf = ptd->_cvtbuf;


    /* make sure we don't overflow the buffer size.  If the user asks for
     * more digits than the buffer can handle, truncate it to the maximum
     * size allowed in the buffer.  The maximum size is _CVTBUFSIZE - 2
     * since we use one character for overflow and one for the terminating
     * null character.
     */
    ndigit = min(ndigit, _CVTBUFSIZE - 2);

    e = _ecvt_s( buf, _CVTBUFSIZE, value, ndigit, decpt, sign );
    if ( e != 0 )
    {
        return NULL;
    }
    return buf;
}


/***
*char *_fpcvt() - gets final string and sets decpt and sign [STATIC]
*
*Purpose:
*   This is a small common routine used by [ef]cvt[_s].  It calls fptostr
*   to get the final string and sets the decpt and sign indicators.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static errno_t __cdecl _fpcvt (
    char *result,
    size_t sizeInChars,
    REG2 STRFLT pflt,
    REG3 int digits,
    int *decpt,
    int *sign
    )
{
    errno_t e = 0;

    /* make sure we don't overflow the buffer size.  If the user asks for
     * more digits than the buffer can handle, truncate it to the maximum
     * size allowed in the buffer.  The maximum size is sizeInChars - 2
     * since we use one character for overflow and one for the terminating
     * null character.
     */
    _VALIDATE_RETURN_ERRCODE(sizeInChars >= (size_t)((digits > 0 ? digits : 0) + 2), ERANGE);

    e = _fptostr(
        result,
        sizeInChars,
        (digits > (int)(sizeInChars - 2)) ? (int)(sizeInChars - 2) : digits,
        pflt);
    if (e != 0)
    {
        errno = e;
        return e;
    }

    /* set the sign flag and decimal point position */
    *sign = (pflt->sign == '-') ? 1 : 0;
    *decpt = pflt->decpt;

    return 0;
}

/* back-compat functions for non-locale users */
FLT __cdecl _fltinf(const char *str, int len, int scale, int decpt)
{
    _LocaleUpdate _loc_update(NULL);

        return _fltinf_l(str, len, scale, decpt, _loc_update.GetLocaleT());
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fopen.c ===
/***
*fopen.c - open a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fopen() and _fsopen() - open a file as a stream and open a file
*       with a specified sharing mode as a stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <share.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <file2.h>
#include <tchar.h>
#include <errno.h>

/***
*FILE *_fsopen(file, mode, shflag) - open a file
*
*Purpose:
*       Opens the file specified as a stream.  mode determines file mode:
*       "r": read       "w": write      "a": append
*       "r+": read/write                "w+": open empty for read/write
*       "a+": read/append
*       Append "t" or "b" for text and binary mode. shflag determines the
*       sharing mode. Values are the same as for sopen().
*
*Entry:
*       char *file - file name to open
*       char *mode - mode of file access
*
*Exit:
*       returns pointer to stream
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfsopen (
        const _TSCHAR *file,
        const _TSCHAR *mode
        ,int shflag
        )
{
        REG1 FILE *stream=NULL;
        REG2 FILE *retval=NULL;

        _VALIDATE_RETURN((file != NULL), EINVAL, NULL);
        _VALIDATE_RETURN((mode != NULL), EINVAL, NULL);
        _VALIDATE_RETURN((*mode != _T('\0')), EINVAL, NULL);

        /* Get a free stream */
        /* [NOTE: _getstream() returns a locked stream.] */

        if ((stream = _getstream()) == NULL)
        {
                errno = EMFILE;
                return(NULL);
        }

        __try {
        /* We deliberately don't hard-validate for emptry strings here. All other invalid
        path strings are treated as runtime errors by the inner code in _open and openfile.
        This is also the appropriate treatment here. Since fopen is the primary access point
        for file strings it might be subjected to direct user input and thus must be robust to
        that rather than aborting. The CRT and OS do not provide any other path validator (because
        WIN32 doesn't allow such things to exist in full generality).
        */
        if(*file==_T('\0'))
        {
            errno=EINVAL;
            return NULL;
        }

        /* open the stream */
#ifdef _UNICODE
        retval = _wopenfile(file,mode,shflag,stream);
#else  /* _UNICODE */
        retval = _openfile(file,mode,shflag,stream);
#endif  /* _UNICODE */

        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*FILE *fopen(file, mode) - open a file
*
*Purpose:
*       Opens the file specified as a stream.  mode determines file mode:
*       "r": read       "w": write      "a": append
*       "r+": read/write                "w+": open empty for read/write
*       "a+": read/append
*       Append "t" or "b" for text and binary mode
*
*Entry:
*       char *file - file name to open
*       char *mode - mode of file access
*
*Exit:
*       returns pointer to stream
*       returns NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfopen (
        const _TSCHAR *file,
        const _TSCHAR *mode
        )
{
        return( _tfsopen(file, mode, _SH_DENYNO) );
}

/***
*errno_t _tfopen_s(pfile, file, mode) - open a file
*
*Purpose:
*       Opens the file specified as a stream.  mode determines file mode:
*       "r": read       "w": write      "a": append
*       "r+": read/write                "w+": open empty for read/write
*       "a+": read/append
*       Append "t" or "b" for text and binary mode
*       This is the secure version fopen - it opens the file in _SH_DENYRW
*       share mode.
*
*Entry:
*       FILE **pfile - Pointer to return the FILE handle into.
*       char *file - file name to open
*       char *mode - mode of file access
*
*Exit:
*       returns 0 on success & sets pfile
*       returns errno_t on failure.
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tfopen_s (
        FILE ** pfile,
        const _TSCHAR *file,
        const _TSCHAR *mode
        )
{
        _VALIDATE_RETURN_ERRCODE((pfile != NULL), EINVAL);
        *pfile = _tfsopen(file, mode, _SH_SECURE);

        if(*pfile != NULL)
            return 0;

        return errno;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fileinfo.c ===
/***
*fileinfo.c
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\file2.h ===
/***
*file2.h - auxiliary file structure used internally by file run-time routines
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the auxiliary file structure used internally by
*       the file run time routines.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_FILE2
#define _INC_FILE2

#ifndef _CRTBLD
/*
 * This is an internal C runtime header file. It is used when building
 * the C runtimes only. It is not to be used as a public header file.
 */
#error ERROR: Use of C runtime library internal header file.
#endif  /* _CRTBLD */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/* Additional _iobuf[]._flag values
 *
 *  _IOSETVBUF - Indicates file was buffered via a setvbuf (or setbuf call).
 *               Currently used ONLY in _filbuf.c, _getbuf.c, fseek.c and
 *               setvbuf.c, to disable buffer resizing on "random access"
 *               files if the buffer was user-installed.
 *
 *  _IOLOCKED  - Indicate that the stream is locked.
 *
 */

#define _IOYOURBUF      0x0100
#define _IOSETVBUF      0x0400
#define _IOFEOF         0x0800
#define _IOFLRTN        0x1000
#define _IOCTRLZ        0x2000
#define _IOCOMMIT       0x4000
#define _IOLOCKED       0x8000

/* General use macros */

#define inuse(s)        ((s)->_flag & (_IOREAD|_IOWRT|_IORW))
#define mbuf(s)         ((s)->_flag & _IOMYBUF)
#define nbuf(s)         ((s)->_flag & _IONBF)
#define ybuf(s)         ((s)->_flag & _IOYOURBUF)
#define bigbuf(s)       ((s)->_flag & (_IOMYBUF|_IOYOURBUF))
#define anybuf(s)       ((s)->_flag & (_IOMYBUF|_IONBF|_IOYOURBUF))
#define str_locked(s)   ((s)->_flag & (_IOLOCKED))

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_FILE2 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\findfi32.c ===
/***
*fndfi32.c - C find file functions (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _findfirst64i32() and _findnext64i32().
*
*******************************************************************************/

#define _USE_INT64 0

#include "findf64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fprintf.c ===
/***
*fprintf.c - print formatted data to stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fprintf() - print formatted data to stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <stddef.h>

/***
*int fprintf(stream, format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on the given using the format string to
*       format data and getting as many arguments as called for
*       _output does the real work here
*
*Entry:
*       FILE *stream - stream to print on
*       char *format - format string to control data format/number of arguments
*       followed by arguments to print, number and type controlled by
*       format string
*
*Exit:
*       returns number of characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fprintf (
        FILE *str,
        const char *format,
        ...
        )
/*
 * 'F'ile (stream) 'PRINT', 'F'ormatted
 */
{
        va_list(arglist);
        REG1 FILE *stream;
        REG2 int buffing;
        int retval=0;

        _VALIDATE_RETURN( (str != NULL), EINVAL, -1);
        _VALIDATE_RETURN( (format != NULL), EINVAL, -1);

        va_start(arglist, format);

        /* Init stream pointer */
        stream = str;

        _lock_str(stream);
        __try {

        _VALIDATE_STREAM_ANSI_SETRET(stream, EINVAL, retval, -1);
                if(retval==0)
                {
                        buffing = _stbuf(stream);
                        retval = _output_l(stream,format,NULL,arglist);
                        _ftbuf(buffing, stream);
                }

        }
        __finally {
            _unlock_str(stream);
        }

        return(retval);
}

int __cdecl _fprintf_l (
        FILE *str,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vfprintf_l(str, format, plocinfo, arglist);
}

int __cdecl _fprintf_s_l (
        FILE *str,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vfprintf_s_l(str, format, plocinfo, arglist);
}

int __cdecl fprintf_s (
        FILE *str,
        const char *format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, format);

    return _vfprintf_s_l(str, format, NULL, arglist);
}

int __cdecl _fprintf_p_l (
        FILE *str,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vfprintf_p_l(str, format, plocinfo, arglist);
}

int __cdecl _fprintf_p (
        FILE *str,
        const char *format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, format);

    return _vfprintf_p_l(str, format, NULL, arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fputchar.c ===
/***
*fputchar.c - write a character to stdout
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fputchar(), putchar() - write a character to stdout, function version
*       defines _fputwchar(), putwchar() - write a wide character to stdout, function version
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>

/***
*int _fputchar(ch), putchar() - put a character to stdout
*
*Purpose:
*       Puts the given characters to stdout.  Function version of macro
*       putchar().
*
*Entry:
*       int ch - character to output
*
*Exit:
*       returns character written if successful
*       returns EOF if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fputchar (
        REG1 int ch
        )
{
        return(putc(ch, stdout));
}

#undef putchar

int __cdecl putchar (
        int ch
        )
{
        return _fputchar(ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fputc.c ===
/***
*fputc.c - write a character to an output stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputc() - writes a character to a stream
*       defines fputwc() - writes a wide character to a stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fputc(ch, stream) - write a character to a stream
*
*Purpose:
*       Writes a character to a stream.  Function version of putc().
*
*Entry:
*       int ch - character to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the character if successful
*       returns EOF if fails
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputc (
        int ch,
        FILE *str
        )
{
        int retval=0;

        _VALIDATE_RETURN((str != NULL), EINVAL, EOF);

        _lock_str(str);
        __try {

        _VALIDATE_STREAM_ANSI_SETRET(str, EINVAL, retval, EOF);
                if(retval==0)
                {
                        retval = _putc_nolock(ch,str);
                }

        }
        __finally {
            _unlock_str(str);
        }

        return(retval);
}

#undef putc

int __cdecl putc (
        int ch,
        FILE *str
        )
{
        int retval=0;

        _VALIDATE_RETURN((str != NULL), EINVAL, EOF);

        _lock_str(str);
        __try {

        _VALIDATE_STREAM_ANSI_SETRET(("Invalid ANSI I/O on unicode stream", str), EINVAL, retval, EOF);
                if(retval==0)
                {
                        retval = _putc_nolock(ch,str);
                }

        }
        __finally {
            _unlock_str(str);
        }

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fputs.c ===
/***
*fputs.c - write a string to a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputs() - writes a string to a stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <string.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fputs(string, stream) - write a string to a file
*
*Purpose:
*       Output the given string to the stream, don't write the '\0' or
*       supply a '\n'.  Uses _stbuf and _ftbuf for efficiency reasons.
*
*Entry:
*       char *string - string to write
*       FILE *stream - stream to write to.
*
*Exit:
*       Good return   = 0
*       Error return  = EOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputs (
        const char *string,
        FILE *stream
        )
{
        REG2 int buffing;
        REG1 size_t length;
        REG3 size_t ndone;

        _VALIDATE_RETURN((string != NULL), EINVAL, EOF);
        _VALIDATE_RETURN((stream != NULL), EINVAL, EOF);
        _VALIDATE_STREAM_ANSI_RETURN(stream, EINVAL, EOF);

        length = strlen(string);

        _lock_str(stream);
        __try {

        buffing = _stbuf(stream);
        ndone = _fwrite_nolock(string,1,length,stream);
        _ftbuf(buffing, stream);

        }
        __finally {
            _unlock_str(stream);
        }

        return(ndone == length ? 0 : EOF);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fputwc.c ===
/***
*fputwc.c - write a wide character to an output stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputwc() - writes a wide character to a stream
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <wchar.h>
#include <tchar.h>
#include <setlocal.h>


/***
*wint_t fputwc(ch, stream) - write a wide character to a stream
*
*Purpose:
*       Writes a wide character to a stream.  Function version of putwc().
*
*Entry:
*       wchar_t ch - wide character to write
*       FILE *stream - stream to write to
*
*Exit:
*       returns the wide character if successful
*       returns WEOF if fails
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl fputwc (
        wchar_t ch,
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 wint_t retval;

        _VALIDATE_RETURN((str != NULL), EINVAL, WEOF);

        /* Init stream pointer */
        stream = str;

        _lock_str(stream);
        __try {

        retval = _fputwc_nolock(ch,stream);

        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}

/***
*_fputwc_nolock() -  putwc() core routine (locked version)
*
*Purpose:
*       Core putwc() routine; assumes stream is already locked.
*
*       [See putwc() above for more info.]
*
*Entry: [See putwc()]
*
*Exit:  [See putwc()]
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _fputwc_nolock (
        wchar_t ch,
        FILE *str
        )
{


        if (!(str->_flag & _IOSTRG))
        {
            if (_textmode_safe(_fileno(str)) == __IOINFO_TM_UTF16LE
                    || _textmode_safe(_fileno(str)) == __IOINFO_TM_UTF8)
            {
                /* binary (Unicode) mode */
                if ( (str->_cnt -= sizeof(wchar_t)) >= 0 ) {
                    return (wint_t) (0xffff & (*((wchar_t *)(str->_ptr))++ = (wchar_t)ch));
                } else {
                    return (wint_t) _flswbuf(ch, str);
                }
            }
            else if ((_osfile_safe(_fileno(str)) & FTEXT))
            {
                int size, i;
                char mbc[MB_LEN_MAX];

                /* text (multi-byte) mode */
                if (wctomb_s(&size, mbc, MB_LEN_MAX, ch) != 0)
                {
                        /*
                         * Conversion failed; errno is set by wctomb_s;
                         * we return WEOF to indicate failure.
                         */
                        return WEOF;
                }
                for ( i = 0; i < size; i++)
                {
                        if (_putc_nolock(mbc[i], str) == EOF)
                                return WEOF;
                }
                return (wint_t)(0xffff & ch);
            }
        }
        /* binary (Unicode) mode */
        if ( (str->_cnt -= sizeof(wchar_t)) >= 0 )
                return (wint_t) (0xffff & (*((wchar_t *)(str->_ptr))++ = (wchar_t)ch));
        else
                return (wint_t) _flswbuf(ch, str);
}

#undef putwc

wint_t __cdecl putwc (
        wchar_t ch,
        FILE *str
        )
{
        return fputwc(ch, str);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fputwchr.c ===
/***
*fputwchr.c - write a wide character to stdout
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fputwchar(), putwchar() - write a wide character to stdout,
*       function version
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <tchar.h>

/***
*wint_t _fputwchar(ch), putwchar() - put a wide character to stdout
*
*Purpose:
*       Puts the given wide character to stdout.  Function version of macro
*       putwchar().
*
*Entry:
*       wchar_t ch - character to output
*
*Exit:
*       returns character written if successful
*       returns WEOF if fails
*
*Exceptions:
*
*******************************************************************************/

wint_t __cdecl _fputwchar (
        REG1 wchar_t ch
        )
{
        return(putwc(ch, stdout));
}

#undef putwchar

wint_t __cdecl putwchar (
        REG1 wchar_t ch
        )
{
        return(_fputwchar(ch));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\flength.c ===
/***
*flength.c - find length of a file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _filelength() - find the length of a file
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <errno.h>
#include <io.h>
#include <internal.h>
#include <msdos.h>
#include <mtdll.h>
#include <stddef.h>
#include <stdlib.h>

/***
*long _filelength(filedes) - find length of a file
*
*Purpose:
*       Returns the length in bytes of the specified file.
*
*Entry:
*       int filedes - handle referring to file to find length of
*
*Exit:
*       returns length of file in bytes
*       returns -1L if fails
*
*Exceptions:
*
*******************************************************************************/

long __cdecl _filelength (
        int filedes
        )
{
        long length;
        long here;

        _CHECK_FH_CLEAR_OSSERR_RETURN( filedes, EBADF, -1L );
        _VALIDATE_CLEAR_OSSERR_RETURN((filedes >= 0 && (unsigned)filedes < (unsigned)_nhandle), EBADF, -1L);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(filedes) & FOPEN), EBADF, -1L);

        _lock_fh(filedes);
        __try {
                if ( _osfile(filedes) & FOPEN ) {

        /* Seek to end to get length of file. */
        if ( (here = _lseek_nolock(filedes, 0L, SEEK_CUR)) == -1L )
                length = -1L;   /* return error */
        else {
                length = _lseek_nolock(filedes, 0L, SEEK_END);
                if ( here != length )
                        _lseek_nolock(filedes, here, SEEK_SET);
        }

                }
                else {
                        errno = EBADF;
                        _doserrno = 0L;
                        length = -1L;
                        _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                }
        }
        __finally {
                _unlock_fh(filedes);
        }

        return(length);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fputws.c ===
/***
*fputws.c - write a string to a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fputws() - writes a string to a stream
*
*******************************************************************************/


#include <file2.h>
#include <internal.h>
#include <stdio.h>
#include <mtdll.h>
#include <tchar.h>
#include <wchar.h>
#include <dbgint.h>

/***
*int fputws(string, stream) - write a string to a file
*
*Purpose:
*       Output the given string to the stream, don't write the L'\0' or
*       supply a L'\n'. Uses _stbuf and _ftbuf for efficiency reasons.
*
*Entry:
*       wchar_t *string - string to write
*       FILE *stream - stream to write to.
*
*Exit:
*       Good return   = 0
*       Error return  = WEOF
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fputws (
        const wchar_t *string,
        FILE *stream
        )
{
        size_t length;
        int retval = 0;

        _VALIDATE_RETURN((string != NULL), EINVAL, WEOF);
        _VALIDATE_RETURN((stream != NULL), EINVAL, WEOF);

        length = wcslen(string);

        _lock_str(stream);
        __try {

        while (length--)
        {
            if (_putwc_nolock(*string++, stream) == WEOF)
            {
                retval = -1;
                break;
            }
        }

        }
        __finally {
            _unlock_str(stream);
        }

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fltintrn.h ===
/***
*fltintrn.h - contains declarations of internal floating point types,
*             routines and variables
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Declares floating point types, routines and variables used
*       internally by the C run-time.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_FLTINTRN
#define _INC_FLTINTRN

#include <crtdefs.h>

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/*
 * For MS C for the x86 family, disable the annoying "long double is the
 * same precision as double" warning
 */

#ifdef _M_IX86
#pragma warning(disable:4069)
#endif  /* _M_IX86 */

/*
 * structs used to fool the compiler into not generating floating point
 * instructions when copying and pushing [long] double values
 */


#ifndef _CRT_DOUBLE_DEC

#ifndef _LDSUPPORT

#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()

#define _PTR_LD(x) ((unsigned char  *)(&(x)->ld))

#else  /* _LDSUPPORT */

typedef long double _LDOUBLE;

#define _PTR_LD(x) ((unsigned char  *)(x))

#endif  /* _LDSUPPORT */

typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;

typedef struct {
        /*
         * Assume there is a long double type
         */
        long double x;
} _LONGDOUBLE;

#define _CRT_DOUBLE_COMPONENTS_MANTISSA_BITS 52
#define _CRT_DOUBLE_COMPONENTS_EXPONENT_BITS 11
#define _CRT_DOUBLE_COMPONENTS_SIGN_BITS 1

typedef union {
    double d;
    struct {
        unsigned __int64 mantissa: _CRT_DOUBLE_COMPONENTS_MANTISSA_BITS;    /* 52 */
        unsigned __int64 exponent: _CRT_DOUBLE_COMPONENTS_EXPONENT_BITS;    /* 11 */
        unsigned __int64 sign: _CRT_DOUBLE_COMPONENTS_SIGN_BITS;            /*  1 */
    };
} _CRT_DOUBLE_COMPONENTS;

#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()

#define _CRT_DOUBLE_DEC
#endif  /* _CRT_DOUBLE_DEC */

/*
 * return values for conversion routines
 * (12-byte to long double, double, or float)
 */

typedef enum {
    INTRNCVT_OK,
    INTRNCVT_OVERFLOW,
    INTRNCVT_UNDERFLOW
} INTRNCVT_STATUS;

/*
 * return values for strgtold12 routine
 */

#define SLD_UNDERFLOW 1
#define SLD_OVERFLOW 2
#define SLD_NODIGITS 4

/*
 * debias values
 */

#define BIAS_64 1023

/*
 * typedef for _fltout
 */

typedef struct _strflt
{
        int sign;             /* zero if positive otherwise negative */
        int decpt;            /* exponent of floating point number */
        int flag;             /* zero if okay otherwise IEEE overflow */
        char *mantissa;       /* pointer to mantissa in string form */
}
        *STRFLT;


/*
 * typedef for _fltin
 */

typedef struct _flt
{
        int flags;
        int nbytes;          /* number of characters read */
        long lval;
        double dval;         /* the returned floating point number */
}
        *FLT;


/* floating point conversion routines, keep in sync with mrt32\include\convert.h */

errno_t _cftoe(_In_ double * _Value, _Out_z_bytecap_(3 + _Dec + 5 + 1) char * _Buf, _In_ size_t _SizeInBytes, _In_ int _Dec, _In_ int _Caps);
errno_t _cftoa(_In_ double * _Value, _Out_z_bytecap_(1 + 4 + _Dec + 6) char * _Buf, _In_ size_t _SizeInBytes, _In_ int _Dec, _In_ int _Caps);
errno_t _cftof(_In_ double * _Value, _Out_z_bytecap_(_SizeInBytes) char * _Buf, _In_ size_t _SizeInBytes, _In_ int _Dec);
errno_t __cdecl _fptostr(_Out_z_bytecap_(_SizeInBytes) char * _Buf, _In_ size_t _SizeInBytes, _In_ int _Digits, _Inout_ STRFLT _PtFlt);
_Check_return_ _CRTIMP int __cdecl _atodbl(_Out_ _CRT_DOUBLE * _Result, _In_z_ char * _Str);
_Check_return_ _CRTIMP int __cdecl _atoldbl(_Out_ _LDOUBLE * _Result, _In_z_ char * _Str);
_Check_return_ _CRTIMP int __cdecl _atoflt(_Out_ _CRT_FLOAT * _Result, _In_z_ char * _Str);
_Check_return_ _CRTIMP int __cdecl _atodbl_l(_Out_ _CRT_DOUBLE * _Result, _In_z_ char * _Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _atoldbl_l(_Out_ _LDOUBLE * _Result, _In_z_ char * _Str, _In_opt_ _locale_t _Locale);
_Check_return_ _CRTIMP int __cdecl _atoflt_l(_Out_ _CRT_FLOAT * _Result, _In_z_ char * _Str,_In_opt_ _locale_t _Locale);


STRFLT  __cdecl _fltout2( _In_ _CRT_DOUBLE _Dbl, _Out_ STRFLT _Flt, _Out_z_bytecap_(_SizeInBytes) char * _ResultStr, _In_ size_t _SizeInBytes);
FLT     __cdecl _fltin2( _Out_ FLT _Flt, _In_z_ const char * _Str, _In_ int _LenIgnore, _In_ int _ScaleIgnore, _In_ int _RadixIgnore, _In_ _locale_t _Locale );
FLT     __cdecl _wfltin2( _Out_ FLT _Fit, _In_z_ const wchar_t * _Str, _In_ int _LenIgnore, _In_ int _ScaleIgnore, _In_ int _RadixIgnore, _In_ _locale_t _Locale );

INTRNCVT_STATUS _ld12tod(_In_ _LDBL12 *_Ifp, _Out_ _CRT_DOUBLE *_D);
INTRNCVT_STATUS _ld12tof(_In_ _LDBL12 *_Ifp, _Out_ _CRT_FLOAT *_F);
INTRNCVT_STATUS _ld12told(_In_ _LDBL12 *_Ifp, _Out_ _LDOUBLE *_Ld);

/*
 * floating point helper routines
 *
 * In the non-CRTDLL builds, these prototypes are immediately replaced by
 * macros which replace them with calls through elements of the _cfltcvt_tab
 * array, so we only pull them into a static-link build if floating point
 * code is needed.
 */

errno_t __cdecl _cfltcvt(double *arg, char *buffer, size_t sizeInBytes,
                         int format, int precision,
                         int caps);
errno_t __cdecl _cfltcvt_l(double *arg, char *buffer, size_t sizeInBytes,
                         int format, int precision,
                         int caps, _locale_t plocinfo);

void __cdecl _cropzeros(char *_Buf);
void __cdecl _cropzeros_l(char *_Buf, _locale_t _Locale);
void __cdecl _fassign(int flag, char  *argument, char *number);
void __cdecl _fassign_l(int flag, char  *argument, char *number, _locale_t);
void __cdecl _forcdecpt(char *_Buf);
void __cdecl _forcdecpt_l(char *_Buf, _locale_t _Locale);
int __cdecl _positive(double *arg);

/*
 * table of pointers to floating point helper routines
 *
 * We can't specify the prototypes for the entries of the table accurately,
 * since different functions in the table have different arglists.
 * So we declare the functions to take and return void (which is the
 * correct prototype for _fptrap(), which is what the entries are all
 * initialized to if no floating point is loaded) and cast appropriately
 * on every usage.
 */

#ifndef CRTDLL

typedef void (* PFV)(void);
extern PFV _cfltcvt_tab[10];
#define _CFLTCVT_TAB(i)       (_decode_pointer(_cfltcvt_tab[i]))

typedef void (* PF0)(double*, char*, size_t, int, int, int);
#define _cfltcvt(a,b,c,d,e,f) (*((PF0)_CFLTCVT_TAB(0)))(a,b,c,d,e,f)

typedef void (* PF1)(char*);
#define _cropzeros(a)         (*((PF1)_CFLTCVT_TAB(1)))(a)

typedef void (* PF2)(int, char*, char*);
#define _fassign(a,b,c)       (*((PF2)_CFLTCVT_TAB(2)))(a,b,c)

typedef void (* PF3)(char*);
#define _forcdecpt(a)         (*((PF3)_CFLTCVT_TAB(3)))(a)

typedef int (* PF4)(double*);
#define _positive(a)          (*((PF4)_CFLTCVT_TAB(4)))(a)

typedef void (* PF5)(_LONGDOUBLE*, char*, size_t, int, int, int);
#define _cldcvt(a,b,c,d,e,f)  (*((PF5)_CFLTCVT_TAB(5)))(a,b,c,d,e,f)

typedef void (* PF6)(double*, char*, size_t, int, int, int, _locale_t);
#define _cfltcvt_l(a,b,c,d,e,f,g) (*((PF6)_CFLTCVT_TAB(6)))(a,b,c,d,e,f,g)

typedef void (* PF7)(int, char*, char*, _locale_t);
#define _fassign_l(a,b,c,d)       (*((PF7)_CFLTCVT_TAB(7)))(a,b,c,d)

typedef void (* PF8)(char*, _locale_t);
#define _cropzeros_l(a,b)         (*((PF8)_CFLTCVT_TAB(8)))(a,b)

typedef void (* PF9)(char*, _locale_t);
#define _forcdecpt_l(a,b)         (*((PF9)_CFLTCVT_TAB(9)))(a,b)

#endif  /* CRTDLL */

unsigned int __strgtold12_l
(
    _Out_ _LDBL12 *pld12,
    _Pre_notnull_ _Post_z_ const char * *p_end_ptr,
    _In_z_ const char * str,
    _In_ int mult12,
    _In_ int scale,
    _In_ int decpt,
    _In_ int implicit_E,
#ifdef _SAFECRT_IMPL
    _In_ char dec_point
#else  /* _SAFECRT_IMPL */
    _In_ _locale_t _Locale
#endif  /* _SAFECRT_IMPL */
);

unsigned int __strgtold12
(
    _Out_ _LDBL12 *pld12,
    _Pre_notnull_ _Post_z_ const char * *p_end_ptr,
    _In_z_ const char * str,
    _In_ int mult12,
    _In_ int scale,
    _In_ int decpt,
    _In_ int implicit_E
);

unsigned int __wstrgtold12_l
(
    _Out_ _LDBL12 *pld12,
    _Pre_notnull_ _Post_z_ const wchar_t * *p_end_ptr,
    _In_z_ const wchar_t * str,
    _In_ int mult12,
    _In_ int scale,
    _In_ int decpt,
    _In_ int implicit_E,
    _In_ _locale_t _Locale
);

unsigned int __wstrgtold12
(
    _Out_ _LDBL12 *pld12,
    _Pre_notnull_ _Post_z_ const wchar_t * *p_end_ptr,
    _In_z_ const wchar_t * str,
    _In_ int mult12,
    _In_ int scale,
    _In_ int decpt,
    _In_ int implicit_E
);

unsigned __STRINGTOLD
(
        _Out_ _LDOUBLE *pld,
        _Pre_notnull_ _Post_z_ const char  * *p_end_ptr,
        _In_z_ const char  *str,
        _In_ int mult12
);

unsigned __STRINGTOLD_L
(
        _Out_ _LDOUBLE *pld,
        _Pre_notnull_ _Post_z_ const char  * *p_end_ptr,
        _In_z_ const char  *str,
        _In_ int mult12,
    _In_ _locale_t _Locale
);

unsigned __WSTRINGTOLD
(
        _Out_ _LDOUBLE *pld,
    _Pre_notnull_ _Post_z_ const wchar_t  * *p_end_ptr,
    _In_z_ const wchar_t  *str,
    _In_ int mult12
);

unsigned __WSTRINGTOLD_L
(
        _Out_ _LDOUBLE *pld,
    _Pre_notnull_ _Post_z_ const wchar_t  * *p_end_ptr,
    _In_z_ const wchar_t  *str,
    _In_ int mult12,
    _In_ _locale_t _Locale
);

FLT __cdecl _fltinf_l
(
        _In_count_(len) const char *str,
        _In_ int len,
        _In_ int scale,
        _In_ int decpt,
        _In_ _locale_t _Locale
);

#ifdef _M_IX86
#pragma warning(default:4069)
#endif  /* _M_IX86 */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* _INC_FLTINTRN */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fpieee.h ===
/***
*fpieee.h - Definitions for floating point IEEE exception handling
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains constant and type definitions for handling
*       floating point exceptions [ANSI/IEEE std. 754]
*
*       [Public]
*
****/

#pragma once
#ifndef __midl
#ifndef _INC_FPIEEE
#define _INC_FPIEEE

#if defined (_M_CEE_PURE)
   #error ERROR: This file is not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

#include <crtdefs.h>

#ifndef __assembler

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,_CRT_PACKING)

/* Disable C4324: structure was padded due to __declspec(align()) */
#pragma warning(push)
#pragma warning(disable: 4324)
#endif  /* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/*
 * Define floating point IEEE compare result values.
 */

typedef enum {
    _FpCompareEqual,
    _FpCompareGreater,
    _FpCompareLess,
    _FpCompareUnordered
} _FPIEEE_COMPARE_RESULT;

/*
 * Define floating point format and result precision values.
 */

typedef enum {
    _FpFormatFp32,
    _FpFormatFp64,
    _FpFormatFp80,
    _FpFormatFp128,
    _FpFormatI16,
    _FpFormatI32,
    _FpFormatI64,
    _FpFormatU16,
    _FpFormatU32,
    _FpFormatU64,
    _FpFormatBcd80,
    _FpFormatCompare,
    _FpFormatString,
#if defined (_M_IA64)
    _FpFormatFp82
#endif  /* defined (_M_IA64) */
} _FPIEEE_FORMAT;

/*
 * Define operation code values.
 */

typedef enum {
    _FpCodeUnspecified,
    _FpCodeAdd,
    _FpCodeSubtract,
    _FpCodeMultiply,
    _FpCodeDivide,
    _FpCodeSquareRoot,
    _FpCodeRemainder,
    _FpCodeCompare,
    _FpCodeConvert,
    _FpCodeRound,
    _FpCodeTruncate,
    _FpCodeFloor,
    _FpCodeCeil,
    _FpCodeAcos,
    _FpCodeAsin,
    _FpCodeAtan,
    _FpCodeAtan2,
    _FpCodeCabs,
    _FpCodeCos,
    _FpCodeCosh,
    _FpCodeExp,
    _FpCodeFabs,
    _FpCodeFmod,
    _FpCodeFrexp,
    _FpCodeHypot,
    _FpCodeLdexp,
    _FpCodeLog,
    _FpCodeLog10,
    _FpCodeModf,
    _FpCodePow,
    _FpCodeSin,
    _FpCodeSinh,
    _FpCodeTan,
    _FpCodeTanh,
    _FpCodeY0,
    _FpCodeY1,
    _FpCodeYn,
    _FpCodeLogb,
    _FpCodeNextafter,
    _FpCodeNegate,
    _FpCodeFmin,         /* XMMI */
    _FpCodeFmax,         /* XMMI */
    _FpCodeConvertTrunc, /* XMMI */
    _XMMIAddps,          /* XMMI */
    _XMMIAddss,
    _XMMISubps,
    _XMMISubss,
    _XMMIMulps,
    _XMMIMulss,
    _XMMIDivps,
    _XMMIDivss,
    _XMMISqrtps,
    _XMMISqrtss,
    _XMMIMaxps,
    _XMMIMaxss,
    _XMMIMinps,
    _XMMIMinss,
    _XMMICmpps,
    _XMMICmpss,
    _XMMIComiss,
    _XMMIUComiss,
    _XMMICvtpi2ps,
    _XMMICvtsi2ss,
    _XMMICvtps2pi,
    _XMMICvtss2si,
    _XMMICvttps2pi,
    _XMMICvttss2si,
    _XMMIAddsubps,       /* XMMI for PNI */
    _XMMIHaddps,         /* XMMI for PNI */
    _XMMIHsubps,         /* XMMI for PNI */
    _XMMIRoundps,        /* 66 0F 3A 08  */
    _XMMIRoundss,        /* 66 0F 3A 0A  */
    _XMMIDpps,           /* 66 0F 3A 40  */
    _XMMI2Addpd,         /* XMMI2 */
    _XMMI2Addsd,
    _XMMI2Subpd,
    _XMMI2Subsd,
    _XMMI2Mulpd,
    _XMMI2Mulsd,
    _XMMI2Divpd,
    _XMMI2Divsd,
    _XMMI2Sqrtpd,
    _XMMI2Sqrtsd,
    _XMMI2Maxpd,
    _XMMI2Maxsd,
    _XMMI2Minpd,
    _XMMI2Minsd,
    _XMMI2Cmppd,
    _XMMI2Cmpsd,
    _XMMI2Comisd,
    _XMMI2UComisd,
    _XMMI2Cvtpd2pi,   /* 66 2D */
    _XMMI2Cvtsd2si,   /* F2 */
    _XMMI2Cvttpd2pi,  /* 66 2C */
    _XMMI2Cvttsd2si,  /* F2 */
    _XMMI2Cvtps2pd,   /* 0F 5A */
    _XMMI2Cvtss2sd,   /* F3 */
    _XMMI2Cvtpd2ps,   /* 66 */
    _XMMI2Cvtsd2ss,   /* F2 */
    _XMMI2Cvtdq2ps,   /* 0F 5B */
    _XMMI2Cvttps2dq,  /* F3 */
    _XMMI2Cvtps2dq,   /* 66 */
    _XMMI2Cvttpd2dq,  /* 66 0F E6 */
    _XMMI2Cvtpd2dq,   /* F2 */
    _XMMI2Addsubpd,   /* 66 0F D0 */
    _XMMI2Haddpd,     /* 66 0F 7C */
    _XMMI2Hsubpd,     /* 66 0F 7D */
    _XMMI2Roundpd,    /* 66 0F 3A 09 */
    _XMMI2Roundsd,    /* 66 0F 3A 0B */
    _XMMI2Dppd,       /* 66 0F 3A 41 */
#if defined (_M_IA64)
    _FpCodeFma,
    _FpCodeFmaSingle,
    _FpCodeFmaDouble,
    _FpCodeFms,
    _FpCodeFmsSingle,
    _FpCodeFmsDouble,
    _FpCodeFnma,
    _FpCodeFnmaSingle,
    _FpCodeFnmaDouble,
    _FpCodeFamin,
    _FpCodeFamax
#endif  /* defined (_M_IA64) */
} _FP_OPERATION_CODE;

#endif  /* __assembler */
#ifndef _INTERNAL_IFSTRIP_
#ifndef __assembler

#define OP_UNSPEC    _FpCodeUnspecified
#define OP_ADD       _FpCodeAdd
#define OP_SUB       _FpCodeSubtract
#define OP_MUL       _FpCodeMultiply
#define OP_DIV       _FpCodeDivide
#define OP_REM       _FpCodeRemainder
#define OP_COMP      _FpCodeCompare
#define OP_CVT       _FpCodeConvert
#define OP_RND       _FpCodeRound
#define OP_TRUNC     _FpCodeTruncate

#define OP_EXP       _FpCodeExp

#define OP_POW       _FpCodePow
#define OP_LOG       _FpCodeLog
#define OP_LOG10     _FpCodeLog10
#define OP_SINH      _FpCodeSinh
#define OP_COSH      _FpCodeCosh
#define OP_TANH      _FpCodeTanh
#define OP_ASIN      _FpCodeAsin
#define OP_ACOS      _FpCodeAcos
#define OP_ATAN      _FpCodeAtan
#define OP_ATAN2     _FpCodeAtan2
#define OP_SQRT      _FpCodeSquareRoot
#define OP_SIN       _FpCodeSin
#define OP_COS       _FpCodeCos
#define OP_TAN       _FpCodeTan
#define OP_CEIL      _FpCodeCeil
#define OP_FLOOR     _FpCodeFloor
#define OP_ABS       _FpCodeFabs
#define OP_MODF      _FpCodeModf
#define OP_LDEXP     _FpCodeLdexp
#define OP_CABS      _FpCodeCabs
#define OP_HYPOT     _FpCodeHypot
#define OP_FMOD      _FpCodeFmod
#define OP_FREXP     _FpCodeFrexp
#define OP_Y0        _FpCodeY0
#define OP_Y1        _FpCodeY1
#define OP_YN        _FpCodeYn

#define OP_LOGB       _FpCodeLogb
#define OP_NEXTAFTER  _FpCodeNextafter

/* XMMI */
#define OP_ADDPS     _XMMIAddps
#define OP_ADDSS     _XMMIAddss
#define OP_SUBPS     _XMMISubps
#define OP_SUBSS     _XMMISubss
#define OP_MULPS     _XMMIMulps
#define OP_MULSS     _XMMIMulss
#define OP_DIVPS     _XMMIDivps
#define OP_DIVSS     _XMMIDivss
#define OP_SQRTPS    _XMMISqrtps
#define OP_SQRTSS    _XMMISqrtss
#define OP_MAXPS     _XMMIMaxps
#define OP_MAXSS     _XMMIMaxss
#define OP_MINPS     _XMMIMinps
#define OP_MINSS     _XMMIMinss
#define OP_CMPPS     _XMMICmpps
#define OP_CMPSS     _XMMICmpss
#define OP_COMISS    _XMMIComiss
#define OP_UCOMISS   _XMMIUComiss
#define OP_CVTPI2PS  _XMMICvtpi2ps
#define OP_CVTSI2SS  _XMMICvtsi2ss
#define OP_CVTPS2PI  _XMMICvtps2pi
#define OP_CVTSS2SI  _XMMICvtss2si
#define OP_CVTTPS2PI _XMMICvttps2pi
#define OP_CVTTSS2SI _XMMICvttss2si
#define OP_ADDSUBPS  _XMMIAddsubps
#define OP_HADDPS    _XMMIHaddps
#define OP_HSUBPS    _XMMIHsubps
#define OP_ROUNDPS   _XMMIRoundps
#define OP_ROUNDSS   _XMMIRoundss
#define OP_DPPS      _XMMIDpps
/* XMMI */

/* XMMI2 */
#define OP_ADDPD     _XMMI2Addpd         /* XMMI2 */
#define OP_ADDSD     _XMMI2Addsd
#define OP_SUBPD     _XMMI2Subpd
#define OP_SUBSD     _XMMI2Subsd
#define OP_MULPD     _XMMI2Mulpd
#define OP_MULSD     _XMMI2Mulsd
#define OP_DIVPD     _XMMI2Divpd
#define OP_DIVSD     _XMMI2Divsd
#define OP_SQRTPD    _XMMI2Sqrtpd
#define OP_SQRTSD    _XMMI2Sqrtsd
#define OP_MAXPD     _XMMI2Maxpd
#define OP_MAXSD     _XMMI2Maxsd
#define OP_MINPD     _XMMI2Minpd
#define OP_MINSD     _XMMI2Minsd
#define OP_CMPPD     _XMMI2Cmppd
#define OP_CMPSD     _XMMI2Cmpsd
#define OP_COMISD    _XMMI2Comisd
#define OP_UCOMISD   _XMMI2UComisd
#define OP_CVTPD2PI  _XMMI2Cvtpd2pi   /* 66 2D */
#define OP_CVTSD2SI  _XMMI2Cvtsd2si   /* F2 */
#define OP_CVTTPD2PI _XMMI2Cvttpd2pi  /* 66 2C */
#define OP_CVTTSD2SI _XMMI2Cvttsd2si  /* F2 */
#define OP_CVTPS2PD  _XMMI2Cvtps2pd   /* 0F 5A */
#define OP_CVTSS2SD  _XMMI2Cvtss2sd   /* F3 */
#define OP_CVTPD2PS  _XMMI2Cvtpd2ps   /* 66 */
#define OP_CVTSD2SS  _XMMI2Cvtsd2ss   /* F2 */
#define OP_CVTDQ2PS  _XMMI2Cvtdq2ps   /* 0F 5B */
#define OP_CVTTPS2DQ _XMMI2Cvttps2dq  /* F3 */
#define OP_CVTPS2DQ  _XMMI2Cvtps2dq   /* 66 */
#define OP_CVTTPD2DQ _XMMI2Cvttpd2dq  /* 66 0F E6 */
#define OP_CVTPD2DQ  _XMMI2Cvtpd2dq   /* F2 */
#define OP_ADDSUBPD  _XMMI2Addsubpd   /* 66 0F D0 */
#define OP_HADDPD    _XMMI2Haddpd     /* 66 0F 7C */
#define OP_HSUBPD    _XMMI2Hsubpd     /* 66 0F 7D */
#define OP_ROUNDPD   _XMMI2Roundpd    /* 66 0F 3A 09 */
#define OP_ROUNDSD   _XMMI2Roundsd    /* 66 0F 3A 0B */
#define OP_DPPD      _XMMI2Dppd       /* 66 0F 3A 41  */
/* XMMI2 */

#else  /* __assembler */

/* This must be the same as the enumerator _FP_OPERATION_CODE ! */
#define OP_UNSPEC    0
#define OP_ADD       1
#define OP_SUB       2
#define OP_MUL       3
#define OP_DIV       4
#define OP_SQRT      5
#define OP_REM       6
#define OP_COMP      7
#define OP_CVT       8
#define OP_RND       9
#define OP_TRUNC     10
#define OP_FLOOR     11
#define OP_CEIL      12
#define OP_ACOS      13
#define OP_ASIN      14
#define OP_ATAN      15
#define OP_ATAN2     16
#define OP_CABS      17
#define OP_COS       18
#define OP_COSH      19
#define OP_EXP       20
#define OP_ABS       21         /* same as OP_FABS */
#define OP_FABS      21         /* same as OP_ABS  */
#define OP_FMOD      22
#define OP_FREXP     23
#define OP_HYPOT     24
#define OP_LDEXP     25
#define OP_LOG       26
#define OP_LOG10     27
#define OP_MODF      28
#define OP_POW       29
#define OP_SIN       30
#define OP_SINH      31
#define OP_TAN       32
#define OP_TANH      33
#define OP_Y0        34
#define OP_Y1        35
#define OP_YN        36
#define OP_LOGB       37
#define OP_NEXTAFTER  38
#define OP_NEG       39

#endif  /* __assembler */
#endif  /* _INTERNAL_IFSTRIP_ */

/*
 * Define rounding modes.
 */

#ifndef __assembler

typedef enum {
    _FpRoundNearest,
    _FpRoundMinusInfinity,
    _FpRoundPlusInfinity,
    _FpRoundChopped
} _FPIEEE_ROUNDING_MODE;

typedef enum {
    _FpPrecisionFull,
    _FpPrecision53,
    _FpPrecision24,
#if defined (_M_IA64)
    _FpPrecision64,
    _FpPrecision113
#endif  /* defined (_M_IA64) */
} _FPIEEE_PRECISION;


/*
 * Define floating point context record
 */

typedef float           _FP32;
typedef double          _FP64;
typedef short           _I16;
typedef int             _I32;
typedef unsigned short  _U16;
typedef unsigned int    _U32;
typedef __int64         _Q64;

#ifndef _INTERNAL_IFSTRIP_
typedef struct {
    unsigned long W[4];
} _U32ARRAY;
#endif  /* _INTERNAL_IFSTRIP_ */

typedef struct
#if defined (_M_IA64)
    _CRT_ALIGN(16)
#endif  /* defined (_M_IA64) */
{
    unsigned short W[5];
} _FP80;

typedef struct _CRT_ALIGN(16)
{
    unsigned long W[4];
} _FP128;

typedef struct _CRT_ALIGN(8)
{
    unsigned long W[2];
} _I64;

typedef struct _CRT_ALIGN(8)
{
    unsigned long W[2];
} _U64;

typedef struct
#if defined (_M_IA64)
    _CRT_ALIGN(16)
#endif  /* defined (_M_IA64) */
{
    unsigned short W[5];
} _BCD80;

typedef struct _CRT_ALIGN(16)
{
    _Q64 W[2];
} _FPQ64;

typedef struct {
    union {
        _FP32        Fp32Value;
        _FP64        Fp64Value;
        _FP80        Fp80Value;
        _FP128       Fp128Value;
        _I16         I16Value;
        _I32         I32Value;
        _I64         I64Value;
        _U16         U16Value;
        _U32         U32Value;
        _U64         U64Value;
        _BCD80       Bcd80Value;
        char         *StringValue;
        int          CompareValue;
#ifndef _INTERNAL_IFSTRIP_
        _U32ARRAY    U32ArrayValue;
#endif  /* _INTERNAL_IFSTRIP_ */
        _Q64         Q64Value;
        _FPQ64       Fpq64Value;
    } Value;

    unsigned int OperandValid : 1;
    unsigned int Format : 4;

} _FPIEEE_VALUE;


typedef struct {
    unsigned int Inexact : 1;
    unsigned int Underflow : 1;
    unsigned int Overflow : 1;
    unsigned int ZeroDivide : 1;
    unsigned int InvalidOperation : 1;
} _FPIEEE_EXCEPTION_FLAGS;


typedef struct {
    unsigned int RoundingMode : 2;
    unsigned int Precision : 3;
    unsigned int Operation :12;
    _FPIEEE_EXCEPTION_FLAGS Cause;
    _FPIEEE_EXCEPTION_FLAGS Enable;
    _FPIEEE_EXCEPTION_FLAGS Status;
    _FPIEEE_VALUE Operand1;
    _FPIEEE_VALUE Operand2;
    _FPIEEE_VALUE Result;
#if defined (_M_IA64)
    _FPIEEE_VALUE Operand3;
#endif  /* defined (_M_IA64) */
} _FPIEEE_RECORD, *_PFPIEEE_RECORD;


struct _EXCEPTION_POINTERS;

/*
 * Floating point IEEE exception filter routine
 */

_CRTIMP int __cdecl _fpieee_flt(
        _In_ unsigned long _ExceptionCode,
        _In_ struct _EXCEPTION_POINTERS * _PtExceptionPtr,
        _In_ int (__cdecl * _Handler)(_FPIEEE_RECORD *)
        );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if _MSC_VER >= 1400 && defined(__cplusplus) && defined(_M_CEE)
_MRTIMP int __cdecl _fpieee_flt(
        _In_ unsigned long _ExceptionCode,
        _In_ struct _EXCEPTION_POINTERS * _PtExceptionPtr,
        _In_ int (__clrcall * _Handler)(_FPIEEE_RECORD *)
        );
#endif  /* _MSC_VER >= 1400 && defined(__cplusplus) && defined(_M_CEE) */

#ifdef _MSC_VER
#pragma warning(pop)
#pragma pack(pop)
#endif  /* _MSC_VER */
#endif  /* __assembler */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* _INC_FPIEEE */
#endif  /* __midl */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\float.h ===
/***
*float.h - constants for floating point values
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains defines for a number of implementation dependent
*       values which are commonly used by sophisticated numerical (floating
*       point) programs.
*       [ANSI]
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_FLOAT
#define _INC_FLOAT

#include <crtdefs.h>
#include <crtwrn.h>

/* Define _CRT_MANAGED_FP_DEPRECATE */
#ifndef _CRT_MANAGED_FP_DEPRECATE
#ifdef _CRT_MANAGED_FP_NO_DEPRECATE
#define _CRT_MANAGED_FP_DEPRECATE
#else  /* _CRT_MANAGED_FP_NO_DEPRECATE */
#if defined (_M_CEE)
#define _CRT_MANAGED_FP_DEPRECATE _CRT_DEPRECATE_TEXT("Direct floating point control is not supported or reliable from within managed code. ")
#else  /* defined (_M_CEE) */
#define _CRT_MANAGED_FP_DEPRECATE
#endif  /* defined (_M_CEE) */
#endif  /* _CRT_MANAGED_FP_NO_DEPRECATE */
#endif  /* _CRT_MANAGED_FP_DEPRECATE */

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define DBL_DIG         15                      /* # of decimal digits of precision */
#define DBL_EPSILON     2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53                      /* # of bits in mantissa */
#define DBL_MAX         1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308                     /* max decimal exponent */
#define DBL_MAX_EXP     1024                    /* max binary exponent */
#define DBL_MIN         2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)                  /* min decimal exponent */
#define DBL_MIN_EXP     (-1021)                 /* min binary exponent */
#define _DBL_RADIX      2                       /* exponent radix */
#define _DBL_ROUNDS     1                       /* addition rounding: near */

#define FLT_DIG         6                       /* # of decimal digits of precision */
#define FLT_EPSILON     1.192092896e-07F        /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD       0
#define FLT_MANT_DIG    24                      /* # of bits in mantissa */
#define FLT_MAX         3.402823466e+38F        /* max value */
#define FLT_MAX_10_EXP  38                      /* max decimal exponent */
#define FLT_MAX_EXP     128                     /* max binary exponent */
#define FLT_MIN         1.175494351e-38F        /* min positive value */
#define FLT_MIN_10_EXP  (-37)                   /* min decimal exponent */
#define FLT_MIN_EXP     (-125)                  /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX       2                       /* exponent radix */
#define FLT_ROUNDS      1                       /* addition rounding: near */

#define LDBL_DIG        DBL_DIG                 /* # of decimal digits of precision */
#define LDBL_EPSILON    DBL_EPSILON             /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   DBL_MANT_DIG            /* # of bits in mantissa */
#define LDBL_MAX        DBL_MAX                 /* max value */
#define LDBL_MAX_10_EXP DBL_MAX_10_EXP          /* max decimal exponent */
#define LDBL_MAX_EXP    DBL_MAX_EXP             /* max binary exponent */
#define LDBL_MIN        DBL_MIN                 /* min positive value */
#define LDBL_MIN_10_EXP DBL_MIN_10_EXP          /* min decimal exponent */
#define LDBL_MIN_EXP    DBL_MIN_EXP             /* min binary exponent */
#define _LDBL_RADIX     DBL_RADIX               /* exponent radix */
#define _LDBL_ROUNDS    DBL_ROUNDS              /* addition rounding: near */

/* Function prototypes */

/* Reading or writing the floating point control/status words is not supported in managed code */

_CRT_MANAGED_FP_DEPRECATE _CRTIMP unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable: 4141)
_CRT_MANAGED_FP_DEPRECATE _CRT_INSECURE_DEPRECATE(_controlfp_s) _CRTIMP unsigned int __cdecl _controlfp(_In_ unsigned int _NewValue,_In_ unsigned int _Mask);
#pragma warning(pop)
_CRT_MANAGED_FP_DEPRECATE _CRTIMP void __cdecl _set_controlfp(_In_ unsigned int _NewValue, _In_ unsigned int _Mask);
_CRT_MANAGED_FP_DEPRECATE _CRTIMP errno_t __cdecl _controlfp_s(_Out_opt_ unsigned int *_CurrentState, _In_ unsigned int _NewValue, _In_ unsigned int _Mask);
_CRT_MANAGED_FP_DEPRECATE _CRTIMP unsigned int __cdecl _statusfp(void);
_CRT_MANAGED_FP_DEPRECATE _CRTIMP void __cdecl _fpreset(void);

#if defined (_M_IX86)
_CRT_MANAGED_FP_DEPRECATE _CRTIMP void __cdecl _statusfp2(_Out_opt_ unsigned int *_X86_status, _Out_opt_ unsigned int *_SSE2_status);
#endif  /* defined (_M_IX86) */

#define _clear87        _clearfp
#define _status87       _statusfp

/*
 * Abstract User Status Word bit definitions
 */

#define _SW_INEXACT     0x00000001              /* inexact (precision) */
#define _SW_UNDERFLOW   0x00000002              /* underflow */
#define _SW_OVERFLOW    0x00000004              /* overflow */
#define _SW_ZERODIVIDE  0x00000008              /* zero divide */
#define _SW_INVALID     0x00000010              /* invalid */
#define _SW_DENORMAL    0x00080000              /* denormal status bit */

/*
 * New Control Bit that specifies the ambiguity in control word.
 */
#define _EM_AMBIGUIOUS  0x80000000                              /* for backwards compatibility old spelling */
#define _EM_AMBIGUOUS   0x80000000

/*
 * Abstract User Control Word Mask and bit definitions
 */
#define _MCW_EM         0x0008001f              /* interrupt Exception Masks */
#define _EM_INEXACT     0x00000001              /*   inexact (precision) */
#define _EM_UNDERFLOW   0x00000002              /*   underflow */
#define _EM_OVERFLOW    0x00000004              /*   overflow */
#define _EM_ZERODIVIDE  0x00000008              /*   zero divide */
#define _EM_INVALID     0x00000010              /*   invalid */
#define _EM_DENORMAL    0x00080000              /* denormal exception mask (_control87 only) */

#define _MCW_RC         0x00000300              /* Rounding Control */
#define _RC_NEAR        0x00000000              /*   near */
#define _RC_DOWN        0x00000100              /*   down */
#define _RC_UP          0x00000200              /*   up */
#define _RC_CHOP        0x00000300              /*   chop */

/*
 * i386 specific definitions
 */
#define _MCW_PC         0x00030000              /* Precision Control */
#define _PC_64          0x00000000              /*    64 bits */
#define _PC_53          0x00010000              /*    53 bits */
#define _PC_24          0x00020000              /*    24 bits */

#define _MCW_IC         0x00040000              /* Infinity Control */
#define _IC_AFFINE      0x00040000              /*   affine */
#define _IC_PROJECTIVE  0x00000000              /*   projective */

/*
 * RISC specific definitions
 */

#define _MCW_DN         0x03000000              /* Denormal Control */
#define _DN_SAVE        0x00000000              /*   save denormal results and operands */
#define _DN_FLUSH       0x01000000              /*   flush denormal results and operands to zero */
#define _DN_FLUSH_OPERANDS_SAVE_RESULTS 0x02000000  /*   flush operands to zero and save results */
#define _DN_SAVE_OPERANDS_FLUSH_RESULTS 0x03000000  /*   save operands and flush results to zero */

/* initial Control Word value */

#if defined (_M_IX86)

#define _CW_DEFAULT ( _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif defined (_M_IA64)

#define _CW_DEFAULT ( _RC_NEAR + _PC_64 + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#elif defined (_M_AMD64)

#define _CW_DEFAULT ( _RC_NEAR + _EM_INVALID + _EM_ZERODIVIDE + _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL)

#endif  /* defined (_M_AMD64) */

_CRT_MANAGED_FP_DEPRECATE _CRTIMP unsigned int __cdecl _control87(_In_ unsigned int _NewValue,_In_ unsigned int _Mask);
#if defined (_M_IX86)
_CRT_MANAGED_FP_DEPRECATE _CRTIMP int __cdecl __control87_2(_In_ unsigned int _NewValue, _In_ unsigned int _Mask,
                                  _Out_opt_ unsigned int* _X86_cw, _Out_opt_ unsigned int* _Sse2_cw);
#endif  /* defined (_M_IX86) */

/* Global variable holding floating point error code */

_Check_return_ _CRTIMP extern int * __cdecl __fpecode(void);
#define _fpecode        (*__fpecode())

/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED          0x0040  /* unemulated instruction */
#define _SW_SQRTNEG             0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW       0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW      0x0400  /* FP stack underflow */

/*  Floating point error signals and return codes */

#define _FPE_INVALID            0x81
#define _FPE_DENORMAL           0x82
#define _FPE_ZERODIVIDE         0x83
#define _FPE_OVERFLOW           0x84
#define _FPE_UNDERFLOW          0x85
#define _FPE_INEXACT            0x86

#define _FPE_UNEMULATED         0x87
#define _FPE_SQRTNEG            0x88
#define _FPE_STACKOVERFLOW      0x8a
#define _FPE_STACKUNDERFLOW     0x8b

#define _FPE_EXPLICITGEN        0x8c    /* raise( SIGFPE ); */


/* IEEE recommended functions */

#ifndef _SIGN_DEFINED
_Check_return_ _CRTIMP double __cdecl _copysign (_In_ double _Number, _In_ double _Sign);
_Check_return_ _CRTIMP double __cdecl _chgsign (_In_ double _X);
#define _SIGN_DEFINED
#endif  /* _SIGN_DEFINED */
_Check_return_ _CRTIMP double __cdecl _scalb(_In_ double _X, _In_ long _Y);
_Check_return_ _CRTIMP double __cdecl _logb(_In_ double _X);
_Check_return_ _CRTIMP double __cdecl _nextafter(_In_ double _X, _In_ double _Y);
_Check_return_ _CRTIMP int    __cdecl _finite(_In_ double _X);
_Check_return_ _CRTIMP int    __cdecl _isnan(_In_ double _X);
_Check_return_ _CRTIMP int    __cdecl _fpclass(_In_ double _X);

#ifdef _M_AMD64
_Check_return_ _CRTIMP float __cdecl _scalbf(_In_ float _X, _In_ long _Y);
#endif  /* _M_AMD64 */

#define _FPCLASS_SNAN   0x0001  /* signaling NaN */
#define _FPCLASS_QNAN   0x0002  /* quiet NaN */
#define _FPCLASS_NINF   0x0004  /* negative infinity */
#define _FPCLASS_NN     0x0008  /* negative normal */
#define _FPCLASS_ND     0x0010  /* negative denormal */
#define _FPCLASS_NZ     0x0020  /* -0 */
#define _FPCLASS_PZ     0x0040  /* +0 */
#define _FPCLASS_PD     0x0080  /* positive denormal */
#define _FPCLASS_PN     0x0100  /* positive normal */
#define _FPCLASS_PINF   0x0200  /* positive infinity */


#if !__STDC__

/* Non-ANSI names for compatibility */

#define clear87         _clear87
#define status87        _status87
#define control87       _control87

_CRT_MANAGED_FP_DEPRECATE _CRTIMP void __cdecl fpreset(void);

#define DBL_RADIX               _DBL_RADIX
#define DBL_ROUNDS              _DBL_ROUNDS

#define LDBL_RADIX              _LDBL_RADIX
#define LDBL_ROUNDS             _LDBL_ROUNDS

#define EM_AMBIGUIOUS           _EM_AMBIGUOUS           /* for backwards compatibility old spelling */
#define EM_AMBIGUOUS            _EM_AMBIGUOUS

#define MCW_EM                  _MCW_EM
#define EM_INVALID              _EM_INVALID
#define EM_DENORMAL             _EM_DENORMAL
#define EM_ZERODIVIDE           _EM_ZERODIVIDE
#define EM_OVERFLOW             _EM_OVERFLOW
#define EM_UNDERFLOW            _EM_UNDERFLOW
#define EM_INEXACT              _EM_INEXACT

#define MCW_IC                  _MCW_IC
#define IC_AFFINE               _IC_AFFINE
#define IC_PROJECTIVE           _IC_PROJECTIVE

#define MCW_RC                  _MCW_RC
#define RC_CHOP                 _RC_CHOP
#define RC_UP                   _RC_UP
#define RC_DOWN                 _RC_DOWN
#define RC_NEAR                 _RC_NEAR

#define MCW_PC                  _MCW_PC
#define PC_24                   _PC_24
#define PC_53                   _PC_53
#define PC_64                   _PC_64

#define CW_DEFAULT              _CW_DEFAULT

#define SW_INVALID              _SW_INVALID
#define SW_DENORMAL             _SW_DENORMAL
#define SW_ZERODIVIDE           _SW_ZERODIVIDE
#define SW_OVERFLOW             _SW_OVERFLOW
#define SW_UNDERFLOW            _SW_UNDERFLOW
#define SW_INEXACT              _SW_INEXACT

#define SW_UNEMULATED           _SW_UNEMULATED
#define SW_SQRTNEG              _SW_SQRTNEG
#define SW_STACKOVERFLOW        _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW       _SW_STACKUNDERFLOW

#define FPE_INVALID             _FPE_INVALID
#define FPE_DENORMAL            _FPE_DENORMAL
#define FPE_ZERODIVIDE          _FPE_ZERODIVIDE
#define FPE_OVERFLOW            _FPE_OVERFLOW
#define FPE_UNDERFLOW           _FPE_UNDERFLOW
#define FPE_INEXACT             _FPE_INEXACT

#define FPE_UNEMULATED          _FPE_UNEMULATED
#define FPE_SQRTNEG             _FPE_SQRTNEG
#define FPE_STACKOVERFLOW       _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW      _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN         _FPE_EXPLICITGEN

#endif  /* !__STDC__ */

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_FLOAT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fp10.c ===
/***
* fp10.c - Set default FP precision to 64 bits (10-byte 'long double')
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*******************************************************************************/
#include <float.h>
#include <internal.h>

void  _setdefaultprecision(void);

/*
 * Routine to set default FP precision to 64 bits, used to override
 * standard 53-bit precision version in fpinit.c.
 */

void _setdefaultprecision()
{
#ifndef _M_AMD64
    _ERRCHECK(_controlfp_s(NULL, _PC_64, _MCW_PC));
#endif  /* _M_AMD64 */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\freopen.c ===
/***
*freopen.c - close a stream and assign it to a new file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines freopen() - close and reopen file, typically used to redirect
*       stdin/out/err/prn/aux.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <share.h>
#include <dbgint.h>
#include <internal.h>
#include <mtdll.h>
#include <tchar.h>

errno_t __cdecl _tfreopen_helper (
        FILE ** pfile,
        const _TSCHAR *filename,
        const _TSCHAR *mode,
        FILE *str,
        int shflag
        )
{
        REG1 FILE *stream;

        _VALIDATE_RETURN_ERRCODE( (pfile != NULL), EINVAL);
        *pfile = NULL;
        _VALIDATE_RETURN_ERRCODE( (filename != NULL), EINVAL);
        _VALIDATE_RETURN_ERRCODE( (mode != NULL), EINVAL);
        _VALIDATE_RETURN_ERRCODE( (str != NULL), EINVAL);

        /* We deliberately don't hard-validate for emptry strings here. All other invalid
        path strings are treated as runtime errors by the inner code in _open and openfile.
        This is also the appropriate treatment here. Since fopen is the primary access point
        for file strings it might be subjected to direct user input and thus must be robust to
        that rather than aborting. The CRT and OS do not provide any other path validator (because
        WIN32 doesn't allow such things to exist in full generality).
        */
        if(*filename==_T('\0'))
        {
            errno=EINVAL;
            return errno;
        }

        /* Init stream pointer */
        stream = str;

        _lock_str(stream);
        __try {

        /* If the stream is in use, try to close it. Ignore possible
         * error (ANSI 4.9.5.4). */
        if ( inuse(stream) )
        {
            _fclose_nolock(stream);
        }

        stream->_ptr = stream->_base = NULL;
        stream->_cnt = stream->_flag = 0;
#ifdef _UNICODE
        *pfile = _wopenfile(filename,mode,shflag,stream);
#else  /* _UNICODE */
        *pfile = _openfile(filename,mode,shflag,stream);
#endif  /* _UNICODE */

        }
        __finally {
                _unlock_str(stream);
        }

        if(*pfile)
            return 0;

        return errno;
}

/***
*FILE *freopen(filename, mode, stream) - reopen stream as new file
*
*Purpose:
*       Closes the file associated with stream and assigns stream to a new
*       file with current mode.  Usually used to redirect a standard file
*       handle.
*
*Entry:
*       char *filename - new file to open
*       char *mode - new file mode, as in fopen()
*       FILE *stream - stream to close and reassign
*
*Exit:
*       returns stream if successful
*       return NULL if fails
*
*Exceptions:
*
*******************************************************************************/

FILE * __cdecl _tfreopen (
        const _TSCHAR *filename,
        const _TSCHAR *mode,
        FILE *str
        )
{
    FILE * fp = NULL;

    _tfreopen_helper(&fp,filename,mode,str,_SH_DENYNO);

    return fp;
}

/***
*errno_t freopen(pfile,filename, mode, stream) - reopen stream as new file
*
*Purpose:
*       Closes the file associated with stream and assigns stream to a new
*       file with current mode.  Usually used to redirect a standard file
*       handle.This is the secure version fopen - it opens the file
*       in _SH_DENYRW share mode.

*
*Entry:
*       FILE **pfile - Pointer to return the FILE handle into.
*       char *filename - new file to open
*       char *mode - new file mode, as in fopen()
*       FILE *stream - stream to close and reassign
*
*Exit:
*       returns 0 on success & sets pfile
*       returns errno_t on failure.
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tfreopen_s (
        FILE ** pfile,
        const _TSCHAR *filename,
        const _TSCHAR *mode,
        FILE *str
        )
{
    return _tfreopen_helper(pfile,filename,mode,str,_SH_SECURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\freea.c ===
/***
*free.c - free an entry in the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the following functions:
*           freea()     - free a memory block in the heap
*           This has been moved to inline, but we need this for backwards bin compat
*
*******************************************************************************/

#define _CRT_NOFREEA
#include <malloc.h>
#include <stdlib.h>

/***
*void _freea(pblock) -
*
*Purpose:
*       Frees only block allocated on the heap, and not the ones
*       allocated on the stack.
*       See the implementation of _malloca
*
*******************************************************************************/

void __cdecl _freea(void *ptr)
{
    if (ptr != NULL)
    {
        ptr = (char*)ptr - _ALLOCA_S_MARKER_SIZE;
        if (*((unsigned int*)ptr) == _ALLOCA_S_HEAP_MARKER)
        {
            free(ptr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\free.c ===
/***
*free.c - free an entry in the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the following functions:
*           free()     - free a memory block in the heap
*
*******************************************************************************/

#ifdef WINHEAP

#include <cruntime.h>
#include <malloc.h>
#include <winheap.h>
#include <windows.h>
#include <internal.h>
#include <mtdll.h>
#include <dbgint.h>
#include <rtcsup.h>

/***
*void free(pblock) - free a block in the heap
*
*Purpose:
*       Free a memory block in the heap.
*
*       Special ANSI Requirements:
*
*       (1) free(NULL) is benign.
*
*Entry:
*       void *pblock - pointer to a memory block in the heap
*
*Return:
*       <void>
*
*******************************************************************************/

void __cdecl _free_base (void * pBlock)
{

        int retval = 0;


        if (pBlock == NULL)
            return;

        RTCCALLBACK(_RTC_Free_hook, (pBlock, 0));

#ifndef _WIN64
        if ( __active_heap == __V6_HEAP )
        {
            PHEADER     pHeader;

            _mlock( _HEAP_LOCK );
            __try {

            if ((pHeader = __sbh_find_block(pBlock)) != NULL)
                __sbh_free_block(pHeader, pBlock);

            }
            __finally {
                _munlock( _HEAP_LOCK );
            }

            if (pHeader == NULL)
            {
                retval = HeapFree(_crtheap, 0, pBlock);
                if (retval == 0)
                {
                    errno = _get_errno_from_oserr(GetLastError());
                }
            }

        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP )
        {
            __old_sbh_region_t *preg;
            __old_sbh_page_t *  ppage;
            __old_page_map_t *  pmap;
            _mlock(_HEAP_LOCK );
            __try {

            if ( (pmap = __old_sbh_find_block(pBlock, &preg, &ppage)) != NULL )
                __old_sbh_free_block(preg, ppage, pmap);

            }
            __finally {
                _munlock(_HEAP_LOCK );
            }

            if (pmap == NULL)
            {
                retval = HeapFree(_crtheap, 0, pBlock);
                if (retval == 0)
                {
                    errno = _get_errno_from_oserr(GetLastError());
                }

            }
        }
#endif  /* CRTDLL */
        else    //  __active_heap == __SYSTEM_HEAP
#endif  /* _WIN64 */
        {
            retval = HeapFree(_crtheap, 0, pBlock);
            if (retval == 0)
            {
                errno = _get_errno_from_oserr(GetLastError());
            }
        }
}

#else  /* WINHEAP */


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdlib.h>
#include <dbgint.h>

/***
*void free(pblock) - free a block in the heap
*
*Purpose:
*       Free a memory block in the heap.
*
*       Special Notes For Multi-thread: The non-multi-thread version is renamed
*       to _free_nolock(). The multi-thread free() simply locks the heap, calls
*       _free_nolock(), then unlocks the heap and returns.
*
*Entry:
*       void *pblock - pointer to a memory block in the heap
*
*Return:
*       <void>
*
*******************************************************************************/


void __cdecl _free_base (
        void *pblock
        )
{
       /* lock the heap
        */
        _mlock(_HEAP_LOCK);

        /* free the block
         */
        _free_base_nolock(pblock);

        /* unlock the heap
         */
        _munlock(_HEAP_LOCK);
}


/***
*void _free_nolock(pblock) - non-locking form of free
*
*Purpose:
*       Same as free() except that no locking is performed
*
*Entry:
*       See free
*
*Return:
*
*******************************************************************************/

void __cdecl _free_base_nolock (


        REG1 void *pblock
        )
{
        REG2 _PBLKDESC pdesc;


        /*
         * If the pointer is NULL, just return [ANSI].
         */

        if (pblock == NULL)
            return;

        /*
         * Point to block header and get the pointer back to the heap desc.
         */

        pblock = (char *)pblock - _HDRSIZE;
        pdesc = *(_PBLKDESC*)pblock;

        /*
         * Validate the back pointer.
         */

        if (_ADDRESS(pdesc) != pblock)
            _heap_abort();

        /*
         * Pointer is ok.  Mark block free.
         */

        _SET_FREE(pdesc);

        /*
         * Check for special conditions under which the rover is reset.
         */
        if ( (_heap_resetsize != 0xffffffff) &&
             (_heap_desc.proverdesc->pblock > pdesc->pblock) &&
             (_BLKSIZE(pdesc) >= _heap_resetsize) )
        {
            _heap_desc.proverdesc = pdesc;
        }
        else if ( _heap_desc.proverdesc == pdesc->pnextdesc )
        {
            _heap_desc.proverdesc = pdesc;
        }
}

#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fseek.c ===
/***
*fseek.c - reposition file pointer on a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fseek() - move the file pointer to new place in file
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <msdos.h>
#include <errno.h>
#include <malloc.h>
#include <io.h>
#include <stddef.h>
#include <internal.h>
#include <mtdll.h>

/***
*int fseek(stream, offset, whence) - reposition file pointer
*
*Purpose:
*
*       Reposition file pointer to the desired location.  The new location
*       is calculated as follows:
*                                { whence=0, beginning of file }
*               <offset> bytes + { whence=1, current position  }
*                                { whence=2, end of file       }
*
*       Be careful to coordinate with buffering.
*
*                       - - - - - - - - - - - - -
*
*       [NOTE: We used to bend over backwards to try and preserve the current
*       buffer and maintain disk block alignment.  This ended up making our
*       code big and slow and complicated, and slowed us down quite a bit.
*       Some of the things pertinent to the old implimentation:
*
*       (1) Read-only: We only did the special code path if the file was
*       opened read-only (_IOREAD).  If the file was writable, we didn't
*       try to optimize.
*
*       (2) Buffering:  We'd assign a buffer, if necessary, since the
*       later code might need it (i.e., call _getbuf).
*
*       (3) Ungetc: Fseek had to be careful NOT to save the buffer if
*       an ungetc had ever been done on the buffer (flag _IOUNGETC).
*
*       (4) Control ^Z: Fseek had to deal with ^Z after reading a
*       new buffer's worth of data (flag _IOCTRLZ).
*
*       (5) Seek-to-end-and-back: To determine if the new seek was within
*       the current buffer, we had to 'normalize' the desired location.
*       This means that we sometimes had to seek to the end of the file
*       and back to determine what the 0-relative offset was.  Two extra
*       lseek() calls hurt performance.
*
*       (6) CR/LF accounting - When trying to seek within a buffer that
*       is in text mode, we had to go account for CR/LF expansion.  This
*       required us to look at every character up to the new offset and
*       see if it was '\n' or not.  In addition, we had to check the
*       FCRLF flag to see if the new buffer started with '\n'.
*
*       Again, all of these notes are for the OLD implimentation just to
*       remind folks of some of the issues involving seeking within a buffer
*       and maintaining buffer alignment.  As an aside, I think this may have
*       been a big win in the 'old days' on floppy-based systems but on newer
*       fast hard disks, the extra code/complexity overwhelmed any gain.
*
*                       - - - - - - - - - - - - -
*
*Entry:
*       FILE *stream - file to reposition file pointer on
*       long offset - offset to seek to
*       int whence - origin offset is measured from (0=beg, 1=current pos,
*                    2=end)
*
*Exit:
*       returns 0 if succeeds
*       returns -1 and sets errno if fails
*       fields of FILE struct will be changed
*
*Exceptions:
*
*******************************************************************************/


int __cdecl fseek (
        FILE *stream,
        long offset,
        int whence
        )
{
        int retval;

        _VALIDATE_RETURN( (stream != NULL), EINVAL, -1);
        _VALIDATE_RETURN( ((whence == SEEK_SET) || (whence == SEEK_CUR) || (whence == SEEK_END)), EINVAL, -1);

        _lock_str(stream);

        __try {
                retval = _fseek_nolock (stream, offset, whence);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_fseek_nolock() - Core fseek() routine (stream is locked)
*
*Purpose:
*       Core fseek() routine; assumes that caller has the stream locked.
*
*       [See fseek() for more info.]
*
*Entry: [See fseek()]
*
*Exit:  [See fseek()]
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fseek_nolock (


        FILE *str,
        long offset,
        int whence
        )
{


        REG1 FILE *stream;


        /* Init stream pointer */
        stream = str;

        if ( !inuse(stream)) {
                errno=EINVAL;
                return(-1);
        }

        /* Clear EOF flag */

        stream->_flag &= ~_IOEOF;

        /* If seeking relative to current location, then convert to
           a seek relative to beginning of file.  This accounts for
           buffering, etc. by letting fseek() tell us where we are. */

        if (whence == SEEK_CUR) {
                offset += _ftell_nolock(stream);
                whence = SEEK_SET;
        }

        /* Flush buffer as necessary */

        _flush(stream);

        /* If file opened for read/write, clear flags since we don't know
           what the user is going to do next. If the file was opened for
           read access only, decrease _bufsiz so that the next _filbuf
           won't cost quite so much */

        if (stream->_flag & _IORW)
                stream->_flag &= ~(_IOWRT|_IOREAD);
        else if ( (stream->_flag & _IOREAD) && (stream->_flag & _IOMYBUF) &&
                  !(stream->_flag & _IOSETVBUF) )
                stream->_bufsiz = _SMALL_BUFSIZ;

        /* Seek to the desired locale and return. */

        return(_lseek(_fileno(stream), offset, whence) == -1L ? -1 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fsetpos.c ===
/***
*fsetpos.c - Contains fsetpos runtime
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Fsetpos sets the file position using an internal value returned by an
*       earlier fgetpos call.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <internal.h>

/***
*int fsetpos(stream,pos) - Set file positioning
*
*Purpose:
*       Fsetpos sets the file position for the file indicated by [stream] to
*       the position indicated by [pos].  The [pos] value is defined to be in
*       an internal format (not to be interpreted by the user) and has been
*       generated by an earlier fgetpos call.
*
*Entry:
*       FILE *stream = pointer to a file stream value
*       fpos_t *pos = pointer to a file positioning value
*
*Exit:
*       Successful call returns 0.
*       Unsuccessful call returns non-zero (!0).
*
*Exceptions:
*       None.
*******************************************************************************/

int __cdecl fsetpos (
        FILE *stream,
        const fpos_t *pos
        )
{
        _VALIDATE_RETURN( (stream != NULL), EINVAL, -1);
        _VALIDATE_RETURN( (pos != NULL), EINVAL, -1);

        return( _fseeki64(stream, *pos, SEEK_SET) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fstati64.c ===
/***
*fstati64.c - return file status info
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fstati64() - return file status info
*
*******************************************************************************/

#define _USE_INT64  1

#include "fstat.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ftell.c ===
/***
*ftell.c - get current file position
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines ftell() - find current current position of file pointer
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <errno.h>
#include <msdos.h>
#include <stddef.h>
#include <io.h>
#include <internal.h>
#include <mtdll.h>

/***
*long ftell(stream) - query stream file pointer
*
*Purpose:
*       Find out what stream's position is. coordinate with buffering; adjust
*       backward for read-ahead and forward for write-behind. This is NOT
*       equivalent to fseek(stream,0L,1), because fseek will remove an ungetc,
*       may flush buffers, etc.
*
*Entry:
*       FILE *stream - stream to query for position
*
*Exit:
*       return present file position if succeeds
*       returns -1L and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/


long __cdecl ftell (
        FILE *stream
        )
{
        long retval;

        _VALIDATE_RETURN( (stream != NULL), EINVAL, (-1L) );

        _lock_str(stream);

        __try {
                retval = _ftell_nolock (stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_ftell_nolock() - Ftell() core routine (assumes stream is locked).
*
*Purpose:
*       Core ftell() routine; assumes caller has aquired stream lock).
*
*       [See ftell() above for more info.]
*
*Entry: [See ftell()]
*
*Exit:  [See ftell()]
*
*Exceptions:
*
*******************************************************************************/

long __cdecl _ftell_nolock (


        FILE *str
        )
{
        REG1 FILE *stream;
        unsigned int offset;
        long filepos;
        REG2 char *p;
        char *max;
        int fd;
        unsigned int rdcnt;

        _VALIDATE_RETURN( (str != NULL), EINVAL, (-1L) );

        /* Init stream pointer and file descriptor */
        stream = str;
        fd = _fileno(stream);

        if (stream->_cnt < 0)
            stream->_cnt = 0;

        if ((filepos = _lseek(fd, 0L, SEEK_CUR)) < 0L)
            return(-1L);

        if (!bigbuf(stream))            /* _IONBF or no buffering designated */
            return(filepos - stream->_cnt);

        offset = (unsigned)(stream->_ptr - stream->_base);

        if (stream->_flag & (_IOWRT|_IOREAD)) {
            if (_osfile(fd) & FTEXT)
                for (p = stream->_base; p < stream->_ptr; p++)
                    if (*p == '\n')  /* adjust for '\r' */
                        offset++;
        }
        else if (!(stream->_flag & _IORW)) {
            errno=EINVAL;
            return(-1L);
        }

        if (filepos == 0L)
            return((long)offset);

        if (stream->_flag & _IOREAD)    /* go to preceding sector */

            if (stream->_cnt == 0)  /* filepos holds correct location */
                offset = 0;

            else {

                /* Subtract out the number of unread bytes left in the buffer.
                   [We can't simply use _iob[]._bufsiz because the last read
                   may have hit EOF and, thus, the buffer was not completely
                   filled.] */

                rdcnt = stream->_cnt + (unsigned)(stream->_ptr - stream->_base);

                /* If text mode, adjust for the cr/lf substitution. If binary
                   mode, we're outta here. */
                if (_osfile(fd) & FTEXT) {
                    /* (1) If we're not at eof, simply copy _bufsiz onto rdcnt
                       to get the # of untranslated chars read. (2) If we're at
                       eof, we must look through the buffer expanding the '\n'
                       chars one at a time. */

                    /* [NOTE: Performance issue -- it is faster to do the two
                       _lseek() calls than to blindly go through and expand the
                       '\n' chars regardless of whether we're at eof or not.] */

                    if (_lseek(fd, 0L, SEEK_END) == filepos) {

                        max = stream->_base + rdcnt;
                        for (p = stream->_base; p < max; p++)
                            if (*p == '\n')
                                /* adjust for '\r' */
                                rdcnt++;

                        /* If last byte was ^Z, the lowio read didn't tell us
                           about it. Check flag and bump count, if necessary. */

                        if (stream->_flag & _IOCTRLZ)
                            ++rdcnt;
                    }

                    else {

                        if (_lseek(fd, filepos, SEEK_SET) < 0)
                            return (-1);

                        /* We want to set rdcnt to the number of bytes
                           originally read into the stream buffer (before
                           crlf->lf translation). In most cases, this will
                           just be _bufsiz. However, the buffer size may have
                           been changed, due to fseek optimization, at the
                           END of the last _filbuf call. */

                        if ( (rdcnt <= _SMALL_BUFSIZ) &&
                             (stream->_flag & _IOMYBUF) &&
                             !(stream->_flag & _IOSETVBUF) )
                        {
                            /* The translated contents of the buffer is small
                               and we are not at eof. The buffer size must have
                               been set to _SMALL_BUFSIZ during the last
                               _filbuf call. */

                            rdcnt = _SMALL_BUFSIZ;
                        }
                        else
                            rdcnt = stream->_bufsiz;

                        /* If first byte in untranslated buffer was a '\n',
                           assume it was preceeded by a '\r' which was
                           discarded by the previous read operation and count
                           the '\n'. */
                        if  (_osfile(fd) & FCRLF)
                            ++rdcnt;
                    }

                } /* end if FTEXT */

                filepos -= (long)rdcnt;

            } /* end else stream->_cnt != 0 */

        return(filepos + (long)offset);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ftime.c ===
/***
*ftime.c - return system time
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Returns the system date/time in a structure form.
*
*******************************************************************************/


#include <cruntime.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <msdos.h>
#include <dos.h>
#include <stdlib.h>
#include <windows.h>
#include <internal.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;

/*
 * Cache for the minutes count for with DST status was last assessed
 */
static __time32_t elapsed_minutes_cache = 0;

/*
 * Three values of dstflag_cache
 */
#define DAYLIGHT_TIME   1
#define STANDARD_TIME   0
#define UNKNOWN_TIME    -1

/*
 * Cache for the last determined DST status
 */
static int dstflag_cache = UNKNOWN_TIME;

/***
*void _ftime32(timeptr) - return DOS time in a structure
*
*Purpose:
*       returns the current DOS time in a struct timeb structure
*
*Entry:
*       struct __timeb32 *timeptr - structure to fill in with time
*
*Exit:
*       no return value -- fills in structure
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP errno_t __cdecl _ftime32_s (
        struct __timeb32 *tp
        )
{
        FT nt_time;
        __time32_t t;
        TIME_ZONE_INFORMATION tzinfo;
        DWORD tzstate;
        long timezone = 0;

        _VALIDATE_RETURN_ERRCODE( ( tp != NULL ), EINVAL );

        __tzset();

        _ERRCHECK(_get_timezone(&timezone));
        tp->timezone = (short)(timezone / 60);

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        /*
         * Obtain the current DST status. Note the status is cached and only
         * updated once per minute, if necessary.
         */
        if ( (t = (__time32_t)(nt_time.ft_scalar / 600000000i64))
             != elapsed_minutes_cache )
        {
            if ( (tzstate = GetTimeZoneInformation( &tzinfo )) != 0xFFFFFFFF )
            {
                /*
                 * Must be very careful in determining whether or not DST is
                 * really in effect.
                 */
                if ( (tzstate == TIME_ZONE_ID_DAYLIGHT) &&
                     (tzinfo.DaylightDate.wMonth != 0) &&
                     (tzinfo.DaylightBias != 0) )
                    dstflag_cache = DAYLIGHT_TIME;
                else
                    /*
                     * When in doubt, assume standard time
                     */
                    dstflag_cache = STANDARD_TIME;
            }
            else
                dstflag_cache = UNKNOWN_TIME;

            elapsed_minutes_cache = t;
        }

        tp->dstflag = (short)dstflag_cache;

        tp->millitm = (unsigned short)((nt_time.ft_scalar / 10000i64) %
                      1000i64);

        tp->time = (__time32_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);

        return 0;
}

_CRTIMP void __cdecl _ftime32 (
        struct __timeb32 *tp
        )
{
    _ftime32_s(tp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fstat.c ===
/***
*fstat.c - return file status info
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fstat32() - return file status info
*
*******************************************************************************/

#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdlib.h>
#include <msdos.h>
#include <io.h>
#include <internal.h>
#include <stddef.h>
#include <oscalls.h>
#include <stdio.h>
#include <mtdll.h>
#include <time.h>

#define IO_DEVNBR   0x3f

/***
*int _fstat32(fildes, buf) - fills supplied buffer with status info
*
*Purpose:
*       Fills the supplied buffer with status information on the
*       file represented by the specified file designator.
*       WARNING: the dev/rdev fields are zero for files.  This is
*       incompatible with DOS 3 version of this routine.
*
*       Note: We cannot directly use the file time stamps returned in the
*       BY_HANDLE_FILE_INFORMATION structure. The values are supposedly in
*       system time and system time is ambiguously defined (it is UTC for
*       Windows NT, local time for Win32S and probably local time for
*       Win32C). Therefore, these values must be converted to local time
*       before than can be used.
*
*Entry:
*       int fildes   - file descriptor
*       struct stat *buf - buffer to store result in
*
*Exit:
*       fills in buffer pointed to by buf
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

#ifdef _USE_INT64

int __cdecl _fstat32i64 (
        int fildes,
        struct _stat32i64 *buf
        )

#else  /* _USE_INT64 */

int __cdecl _fstat32 (
        int fildes,
        struct _stat32 *buf
        )

#endif  /* _USE_INT64 */
{
        int isdev;          /* 0 for a file, 1 for a device */
        int retval = 0;     /* assume good return */
        BY_HANDLE_FILE_INFORMATION bhfi;
        FILETIME LocalFTime;
        SYSTEMTIME SystemTime;

        _VALIDATE_CLEAR_OSSERR_RETURN( (buf != NULL), EINVAL, -1 );
        memset(buf, 0, sizeof(*buf));

        _CHECK_FH_CLEAR_OSSERR_RETURN( fildes, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fildes >= 0 && (unsigned)fildes < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fildes) & FOPEN), EBADF, -1);

        /* Lock the file */
        _lock_fh(fildes);
        __try {
            if ( !(_osfile(fildes) & FOPEN) ) {
                errno = EBADF;
                retval = -1;
                _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                goto done;
            }

        /* Find out what kind of handle underlies filedes
         */
        isdev = GetFileType((HANDLE)_osfhnd(fildes)) & ~FILE_TYPE_REMOTE;

        if ( isdev != FILE_TYPE_DISK ) {

            /* not a disk file. probably a device or pipe
             */
            if ( (isdev == FILE_TYPE_CHAR) || (isdev == FILE_TYPE_PIPE) ) {
                /* treat pipes and devices similarly. no further info is
                 * available from any API, so set the fields as reasonably
                 * as possible and return.
                 */
                if ( isdev == FILE_TYPE_CHAR )
                    buf->st_mode = _S_IFCHR;
                else
                    buf->st_mode = _S_IFIFO;

                buf->st_rdev = buf->st_dev = (_dev_t)fildes;
                buf->st_nlink = 1;
                buf->st_uid = buf->st_gid = buf->st_ino = 0;
                buf->st_atime = buf->st_mtime = buf->st_ctime = 0;
                if ( isdev == FILE_TYPE_CHAR ) {
#ifdef _USE_INT64
                    buf->st_size = 0i64;
#else  /* _USE_INT64 */
                    buf->st_size = 0;
#endif  /* _USE_INT64 */
                }
                else {
                    unsigned long ulAvail;
                    int rc;
                    rc = PeekNamedPipe((HANDLE)_osfhnd(fildes),
                                       NULL,
                                       0,
                                       NULL,
                                       &ulAvail,
                                       NULL);

                    if (rc) {
                        buf->st_size = (_off_t)ulAvail;
                    }
                    else {
                        buf->st_size = (_off_t)0;
                    }
                }

                goto done;
            }
            else if ( isdev == FILE_TYPE_UNKNOWN ) {
                errno = EBADF;
                retval = -1;
                goto done;      /* join common return code */
            }
            else {
                /* according to the documentation, this cannot happen, but
                 * play it safe anyway.
                 */
                _dosmaperr(GetLastError());
                retval = -1;
                goto done;
            }
        }


        /* set the common fields
         */
        buf->st_ino = buf->st_uid = buf->st_gid = buf->st_mode = 0;
        buf->st_nlink = 1;

        /* use the file handle to get all the info about the file
         */
        if ( !GetFileInformationByHandle((HANDLE)_osfhnd(fildes), &bhfi) ) {
            _dosmaperr(GetLastError());
            retval = -1;
            goto done;
        }

        if ( bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY )
            buf->st_mode |= (_S_IREAD + (_S_IREAD >> 3) + (_S_IREAD >> 6));
        else
            buf->st_mode |= ((_S_IREAD|_S_IWRITE) + ((_S_IREAD|_S_IWRITE) >> 3)
              + ((_S_IREAD|_S_IWRITE) >> 6));

        /* set file date fields
         */
        if ( bhfi.ftLastWriteTime.dwLowDateTime ||
             bhfi.ftLastWriteTime.dwHighDateTime )
        {

            if ( !FileTimeToLocalFileTime( &(bhfi.ftLastWriteTime), &LocalFTime )
                 || !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                retval = -1;
                goto done;
            }

            buf->st_mtime = __loctotime32_t(SystemTime.wYear,
                                            SystemTime.wMonth,
                                            SystemTime.wDay,
                                            SystemTime.wHour,
                                            SystemTime.wMinute,
                                            SystemTime.wSecond,
                                            -1);
        } else
            buf->st_mtime = 0 ;

        if ( bhfi.ftLastAccessTime.dwLowDateTime ||
             bhfi.ftLastAccessTime.dwHighDateTime )
        {

            if ( !FileTimeToLocalFileTime( &(bhfi.ftLastAccessTime),
                                           &LocalFTime ) ||
                 !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                retval = -1;
                goto done;
            }

            buf->st_atime = __loctotime32_t(SystemTime.wYear,
                                            SystemTime.wMonth,
                                            SystemTime.wDay,
                                            SystemTime.wHour,
                                            SystemTime.wMinute,
                                            SystemTime.wSecond,
                                            -1);
        }
        else
            buf->st_atime = buf->st_mtime;

        if ( bhfi.ftCreationTime.dwLowDateTime ||
             bhfi.ftCreationTime.dwHighDateTime )
        {

            if ( !FileTimeToLocalFileTime( &(bhfi.ftCreationTime),
                                           &LocalFTime ) ||
                 !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                retval = -1;
                goto done;
            }

            buf->st_ctime = __loctotime32_t(SystemTime.wYear,
                                            SystemTime.wMonth,
                                            SystemTime.wDay,
                                            SystemTime.wHour,
                                            SystemTime.wMinute,
                                            SystemTime.wSecond,
                                            -1);
        }
        else
            buf->st_ctime = buf->st_mtime;

#ifdef _USE_INT64
        buf->st_size = ((__int64)(bhfi.nFileSizeHigh)) * (0x100000000i64) +
                       (__int64)(bhfi.nFileSizeLow);
#else  /* _USE_INT64 */
        buf->st_size = bhfi.nFileSizeLow;
#endif  /* _USE_INT64 */

        buf->st_mode |= _S_IFREG;

        /* On DOS, this field contains the drive number, but
         * the drive number is not available on this platform.
         * Also, for UNC network names, there is no drive number.
         */
        buf->st_rdev = buf->st_dev = 0;

/* Common return code */

done:
        ; }
        __finally {
            _unlock_fh(fildes);
        }

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fstati32.c ===
/***
*fstati32.c - return file status info
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fstat64i32() - return file status info
*
*******************************************************************************/

#define _USE_INT64  0

#include "fstat64.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fscanf.c ===
/***
*fscanf.c - read formatted data from stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fscanf() - reads formatted data from stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int vfscanf(stream, format, ...) - read formatted data from stream
*
*Purpose:
*       This is a helper function to be called from fscanf & fscanf_s
*
*Entry:
*       INPUTFN inputfn - fscanf & fscanf_s pass either _input or _input_s
*                   which is then used to do the real work.
*       FILE *stream    - stream to read data from
*       char *format    - format string
*       va_list arglist - arglist of output pointers
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vfscanf (
        INPUTFN inputfn,
        FILE *stream,
        const char *format,
        _locale_t plocinfo,
        va_list arglist
        )
/*
 * 'F'ile (stream) 'SCAN', 'F'ormatted
 */
{
        int retval=0;

        _VALIDATE_RETURN((stream != NULL), EINVAL, EOF);
        _VALIDATE_RETURN((format != NULL), EINVAL, EOF);

        _lock_str(stream);
        __try {
        _VALIDATE_STREAM_ANSI_SETRET(stream, EINVAL, retval, EOF);

                if(retval==0)
                {
                        retval = (inputfn(stream, format, plocinfo, arglist));
                }

        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}

/***
*int fscanf(stream, format, ...) - read formatted data from stream
*
*Purpose:
*       Reads formatted data from stream into arguments.  _input does the real
*       work here.
*
*Entry:
*       FILE *stream - stream to read data from
*       char *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fscanf (
        FILE *stream,
        const char *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return vfscanf(_input_l, stream, format, NULL, arglist);
}

int __cdecl _fscanf_l (
        FILE *stream,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return vfscanf(_input_l, stream, format, plocinfo, arglist);
}

/***
*int fscanf_s(stream, format, ...)
*
*   Same as fscanf above except that it calls _input_s to do the real work.
*   _input_s has a size check for array parameters.
*
*******************************************************************************/

int __cdecl fscanf_s (
        FILE *stream,
        const char *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return vfscanf(_input_s_l, stream, format, NULL, arglist);
}

int __cdecl _fscanf_s_l (
        FILE *stream,
        const char *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return vfscanf(_input_s_l, stream, format, plocinfo, arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fstat64.c ===
/***
*fstat64.c - return file status info
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fstat64() - return file status info
*
*******************************************************************************/


#include <cruntime.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdlib.h>
#include <msdos.h>
#include <io.h>
#include <internal.h>
#include <stddef.h>
#include <oscalls.h>
#include <stdio.h>
#include <mtdll.h>
#include <time.h>

#ifndef _USE_INT64
#define _USE_INT64 1
#endif  /* _USE_INT64 */

#define IO_DEVNBR   0x3f

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64


/***
*int _fstat64(fildes, buf) - fills supplied buffer with status info
*
*Purpose:
*       Fills the supplied buffer with status information on the
*       file represented by the specified file designator.
*       WARNING: the dev/rdev fields are zero for files.  This is
*       incompatible with DOS 3 version of this routine.
*
*       Note: Unlike fstat, _fstat64 uses the UTC time values returned in the
*       BY_HANDLE_FILE_INFORMATION struct. This means the time values will
*       always be correct on NTFS, but may be wrong on FAT file systems for
*       file times whose DST state is different from the current DST state
*       (this an NT bug).
*
*Entry:
*       int fildes   - file descriptor
*       struct _stat64 *buf - buffer to store result in
*
*Exit:
*       fills in buffer pointed to by buf
*       returns 0 if successful
*       returns -1 and sets errno if unsuccessful
*
*Exceptions:
*
*******************************************************************************/

#if _USE_INT64

int __cdecl _fstat64 (
        int fildes,
        struct _stat64 *buf
        )

#else  /* _USE_INT64 */

int __cdecl _fstat64i32 (
        int fildes,
        struct _stat64i32 *buf
        )

#endif  /* _USE_INT64 */

{
        int isdev;          /* 0 for a file, 1 for a device */
        int retval = 0;     /* assume good return */
        BY_HANDLE_FILE_INFORMATION bhfi;
        FILETIME LocalFTime;
        SYSTEMTIME SystemTime;

        _VALIDATE_CLEAR_OSSERR_RETURN( (buf != NULL), EINVAL, -1 );
        memset(buf, 0, sizeof(*buf));

        _CHECK_FH_CLEAR_OSSERR_RETURN( fildes, EBADF, -1 );
        _VALIDATE_CLEAR_OSSERR_RETURN((fildes >= 0 && (unsigned)fildes < (unsigned)_nhandle), EBADF, -1);
        _VALIDATE_CLEAR_OSSERR_RETURN((_osfile(fildes) & FOPEN), EBADF, -1);


        /* Lock the file */
        _lock_fh(fildes);
        __try {
            if ( !(_osfile(fildes) & FOPEN) ) {
                errno = EBADF;
                retval = -1;
                _ASSERTE(("Invalid file descriptor. File possibly closed by a different thread",0));
                goto done;
            }

        /* Find out what kind of handle underlies filedes
         */
        isdev = GetFileType((HANDLE)_osfhnd(fildes)) & ~FILE_TYPE_REMOTE;

        if ( isdev != FILE_TYPE_DISK ) {

            /* not a disk file. probably a device or pipe
             */
            if ( (isdev == FILE_TYPE_CHAR) || (isdev == FILE_TYPE_PIPE) ) {
                /* treat pipes and devices similarly. no further info is
                 * available from any API, so set the fields as reasonably
                 * as possible and return.
                 */
                if ( isdev == FILE_TYPE_CHAR )
                    buf->st_mode = _S_IFCHR;
                else
                    buf->st_mode = _S_IFIFO;

                buf->st_rdev = buf->st_dev = (_dev_t)fildes;
                buf->st_nlink = 1;
                buf->st_uid = buf->st_gid = buf->st_ino = 0;
                buf->st_atime = buf->st_mtime = buf->st_ctime = 0;
                if ( isdev == FILE_TYPE_CHAR ) {
#if _USE_INT64
                    buf->st_size = 0i64;
#else  /* _USE_INT64 */
                    buf->st_size = 0;
#endif  /* _USE_INT64 */
                }
                else {
                    unsigned long ulAvail;
                    int rc;
                    rc = PeekNamedPipe((HANDLE)_osfhnd(fildes),
                                       NULL,
                                       0,
                                       NULL,
                                       &ulAvail,
                                       NULL);

                    if (rc) {
                        buf->st_size = (_off_t)ulAvail;
                    }
                    else {
                        buf->st_size = (_off_t)0;
                    }
                }

                goto done;
            }
            else if ( isdev == FILE_TYPE_UNKNOWN ) {
                errno = EBADF;
                retval = -1;
                goto done;      /* join common return code */
            }
            else {
                /* according to the documentation, this cannot happen, but
                 * play it safe anyway.
                 */
                _dosmaperr(GetLastError());
                retval = -1;
                goto done;
            }
        }


        /* set the common fields
         */
        buf->st_ino = buf->st_uid = buf->st_gid = buf->st_mode = 0;
        buf->st_nlink = 1;

        /* use the file handle to get all the info about the file
         */
        if ( !GetFileInformationByHandle((HANDLE)_osfhnd(fildes), &bhfi) ) {
            _dosmaperr(GetLastError());
            retval = -1;
            goto done;
        }

        if ( bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY )
            buf->st_mode |= (_S_IREAD + (_S_IREAD >> 3) + (_S_IREAD >> 6));
        else
            buf->st_mode |= ((_S_IREAD|_S_IWRITE) + ((_S_IREAD|_S_IWRITE) >> 3)
              + ((_S_IREAD|_S_IWRITE) >> 6));

        /* set file date fields
         */
        if ( bhfi.ftLastWriteTime.dwLowDateTime ||
             bhfi.ftLastWriteTime.dwHighDateTime )
        {

            if ( !FileTimeToLocalFileTime( &(bhfi.ftLastWriteTime), &LocalFTime )
                 || !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                retval = -1;
                goto done;
            }

            buf->st_mtime = __loctotime64_t(SystemTime.wYear,
                                            SystemTime.wMonth,
                                            SystemTime.wDay,
                                            SystemTime.wHour,
                                            SystemTime.wMinute,
                                            SystemTime.wSecond,
                                            -1);
        } else
            buf->st_mtime = 0;

        if ( bhfi.ftLastAccessTime.dwLowDateTime ||
             bhfi.ftLastAccessTime.dwHighDateTime )
        {

            if ( !FileTimeToLocalFileTime( &(bhfi.ftLastAccessTime),
                                           &LocalFTime ) ||
                 !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                retval = -1;
                goto done;
            }

            buf->st_atime = __loctotime64_t(SystemTime.wYear,
                                          SystemTime.wMonth,
                                          SystemTime.wDay,
                                          SystemTime.wHour,
                                          SystemTime.wMinute,
                                          SystemTime.wSecond,
                                          -1);
        }
        else
            buf->st_atime = buf->st_mtime;

        if ( bhfi.ftCreationTime.dwLowDateTime ||
             bhfi.ftCreationTime.dwHighDateTime )
        {

            if ( !FileTimeToLocalFileTime( &(bhfi.ftCreationTime),
                                           &LocalFTime ) ||
                 !FileTimeToSystemTime( &LocalFTime, &SystemTime ) )
            {
                retval = -1;
                goto done;
            }

            buf->st_ctime = __loctotime64_t(SystemTime.wYear,
                                          SystemTime.wMonth,
                                          SystemTime.wDay,
                                          SystemTime.wHour,
                                          SystemTime.wMinute,
                                          SystemTime.wSecond,
                                          -1);
        }
        else
            buf->st_ctime = buf->st_mtime;

#if _USE_INT64
        buf->st_size = ((__int64)(bhfi.nFileSizeHigh)) * (0x100000000i64) +
                       (__int64)(bhfi.nFileSizeLow);
#else  /* _USE_INT64 */
        buf->st_size = bhfi.nFileSizeLow;
#endif  /* _USE_INT64 */

        buf->st_mode |= _S_IFREG;

        /* On DOS, this field contains the drive number, but
         * the drive number is not available on this platform.
         * Also, for UNC network names, there is no drive number.
         */
        buf->st_rdev = buf->st_dev = 0;

/* Common return code */

done:
        ; }
        __finally {
            _unlock_fh(fildes);
        }

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fread.c ===
/***
*fread.c - read from a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Read from the specified stream into the user's buffer.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <mtdll.h>
#include <io.h>
#include <string.h>
#include <limits.h>
#include <internal.h>
#include <file2.h>
#include <dbgint.h>

/***
*size_t fread_s(void *buffer, size_t bufferSize, size_t elementSize, size_t count, FILE *stream) -
*       read from specified stream into the specified buffer.
*
*size_t fread(void *buffer, size_t elementSize, size_t count, FILE *stream) -
*       read from specified stream into the specified buffer.
*
*Purpose:
*       Read 'count' items of size 'elementSize' from the specified stream into
*       the specified buffer. Return when 'count' items have been read in
*       or no more items can be read from the stream.
*
*Entry:
*       buffer  - pointer to user's buffer
*       bufferSize - size of the destination buffer (in bytes)
*       elementSize - size of the item to read in (in bytes)
*       count   - number of items to read
*       stream  - stream to read from
*
*Exit:
*       Returns the number of (whole) items that were read into the buffer.
*       This may be less than 'count' if an error or eof occurred. In this
*       case, ferror() or feof() should be used to distinguish between the
*       two conditions.
*
*Notes:
*       fread will attempt to buffer the stream (side effect of the _filbuf
*       call) if necessary.
*
*       No more than 0xFFFE bytes may be read in at a time by a call to
*       read(). Further, read() does not handle huge buffers. Therefore,
*       in large data models, the read request is broken down into chunks
*       that do not violate these considerations. Each of these chunks is
*       processed much like an fread() call in a small data model (by a
*       call to _nfread()).
*
*       MTHREAD/DLL - Handled in three layers. fread() handles the locking
*       and DS saving/loading/restoring (if required) and calls _fread_nolock()
*       to do the work. _fread_nolock() is the same as the single-thread,
*       large data model version of fread(). It breaks up the read request
*       into digestible chunks and calls _nfread() to do the actual work.
*
*       386/MTHREAD/DLL - Handled in just the two layers since it is small
*       data model. The outer layer, fread(), takes care of the stream locking
*       and calls _fread_nolock() to do the actual work. _fread_nolock() is the same
*       as the single-thread version of fread().
*
*******************************************************************************/

#ifdef _DEBUG
#define _BUFFER_FILL_PATTERN _SECURECRT_FILL_BUFFER_PATTERN
#else  /* _DEBUG */
#define _BUFFER_FILL_PATTERN 0
#endif  /* _DEBUG */

/* define locking/unlocking version */
size_t __cdecl fread_s(
    void *buffer,
    size_t bufferSize,
    size_t elementSize,
    size_t count,
    FILE *stream
)
{
    size_t retval = 0;

    if (elementSize == 0 || count == 0)
    {
        return 0;
    }


    // only checking for stream == NULL here for _lock_str()
    // the rest of the validation is in _fread_nolock_s()
    if (stream == NULL )
    {
        if (bufferSize != SIZE_MAX)
        {
            memset(buffer, _BUFFER_FILL_PATTERN, bufferSize);
        }

        _VALIDATE_RETURN((stream != NULL), EINVAL, 0);
    }

    _lock_str(stream);
    __try
    {
        /* do the read; _fread_nolock_s will make sure we do not buffer overrun */
        retval = _fread_nolock_s(buffer, bufferSize, elementSize, count, stream);
    }
    __finally
    {
        _unlock_str(stream);
    }

    return retval;
}

/* define the normal version */
size_t __cdecl _fread_nolock_s(
    void *buffer,
    size_t bufferSize,
    size_t elementSize,
    size_t num,
    FILE *stream
)
{
    char *data;                     /* point inside the destination buffer to where we need to copy the read chars */
    size_t dataSize;                /* space left in the destionation buffer (in bytes) */
    size_t total;                   /* total bytes to read */
    size_t count;                   /* num bytes left to read */
    unsigned streambufsize;         /* size of stream buffer */
    unsigned nbytes;                /* how much to read now */
    unsigned nread;                 /* how much we did read */
    int c;                          /* a temp char */

    /* initialize local vars */
    data = buffer;
    dataSize = bufferSize;

    if (elementSize == 0 || num == 0)
    {
        return 0;
    }

    /* validation */
    _VALIDATE_RETURN((buffer != NULL), EINVAL, 0);
    if (stream == NULL || num > (SIZE_MAX / elementSize))
    {
        if (bufferSize != SIZE_MAX)
        {
            memset(buffer, _BUFFER_FILL_PATTERN, bufferSize);
        }

        _VALIDATE_RETURN((stream != NULL), EINVAL, 0);
        _VALIDATE_RETURN(num <= (SIZE_MAX / elementSize), EINVAL, 0);
    }


    count = total = elementSize * num;

    if (anybuf(stream))
    {
        /* already has buffer, use its size */
        streambufsize = stream->_bufsiz;
    }
    else
    {
        /* assume will get _INTERNAL_BUFSIZ buffer */
        streambufsize = _INTERNAL_BUFSIZ;
    }

    /* here is the main loop -- we go through here until we're done */
    while (count != 0) {
        /* if the buffer exists and has characters, copy them to user
            buffer */
        if (anybuf(stream) && stream->_cnt != 0)
        {
            if(stream->_cnt < 0)
            {
                _ASSERTE(("Inconsistent Stream Count. Flush between consecutive read and write", stream->_cnt >= 0));
                stream->_flag |= _IOERR;
                return (total - count) / elementSize;
            }

            /* how much do we want? */
            nbytes = (count < (size_t)stream->_cnt) ? (unsigned)count : stream->_cnt;
            if (nbytes > dataSize)
            {
                if (bufferSize != SIZE_MAX)
                {
                    memset(buffer, _BUFFER_FILL_PATTERN, bufferSize);
                }
                _VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
            }
            memcpy_s(data, dataSize, stream->_ptr, nbytes);

            /* update stream and amt of data read */
            count -= nbytes;
            stream->_cnt -= nbytes;
            stream->_ptr += nbytes;
            data += nbytes;
            dataSize -= nbytes;
        }
        else if (count >= streambufsize)
        {
            /* If we have more than streambufsize chars to read, get data
                by calling read with an integral number of bufsiz
                blocks.  Note that if the stream is text mode, read
                will return less chars than we ordered. */

            if (streambufsize)
            {
                /* In 64bit apps size_t is bigger than unsigned
                 * (which is 32bit even in 64 bit machines), so
                 * we need to split the read into INT_MAX chunks
                 * since _read() only support up to _signed_ int
                 * (even though the in parameter is unsigned).
                 */
                if (count > INT_MAX)
                {
                    /* calc chars to read -- the largest multiple of streambufsize
                     * smaller then INT_MAX
                     */
                    nbytes = (unsigned)(INT_MAX - INT_MAX % streambufsize);
                }
                else
                {
                    /* calc chars to read -- (count/streambufsize) * streambufsize */
                    nbytes = (unsigned)(count - count % streambufsize);
                }
            }
            else
            {
                nbytes = (count > INT_MAX)?(unsigned)INT_MAX: (unsigned)count;
            }

            if (nbytes > dataSize)
            {
                if (bufferSize != SIZE_MAX)
                {
                    memset(buffer, _BUFFER_FILL_PATTERN, bufferSize);
                }
                _VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
            }

            nread = _read(_fileno(stream), data, nbytes);
            if (nread == 0) {
                    /* end of file -- out of here */
                    stream->_flag |= _IOEOF;
                    return (total - count) / elementSize;
            }
            else if (nread == (unsigned)-1) {
                    /* error -- out of here */
                    stream->_flag |= _IOERR;
                    return (total - count) / elementSize;
            }

            /* update count and data to reflect read */
            count -= nread;
            data += nread;
            dataSize -= nread;
        }
        else
        {
            /* less than streambufsize chars to read, so call _filbuf to
                fill buffer */
            if ((c = _filbuf(stream)) == EOF) {
                    /* error or eof, stream flags set by _filbuf */
                    return (total - count) / elementSize;
            }

            /* _filbuf returned a char -- store it */
            if (dataSize == 0)
            {
                if (bufferSize != SIZE_MAX)
                {
                    memset(buffer, _BUFFER_FILL_PATTERN, bufferSize);
                }
                _VALIDATE_RETURN(("buffer too small", 0), ERANGE, 0)
            }
            *data++ = (char) c;
            --count;
            --dataSize;

            /* update buffer size */
            streambufsize = stream->_bufsiz;
        }
    }

    /* we finished successfully, so just return num */
    return num;
}

size_t __cdecl fread(
    void *buffer,
    size_t elementSize,
    size_t count,
    FILE *stream
)
{
    /* assumes there is enough space in the destination buffer */
    return fread_s(buffer, SIZE_MAX, elementSize, count, stream);
}

size_t __cdecl _fread_nolock(
    void *buffer,
    size_t elementSize,
    size_t count,
    FILE *stream
)
{
    /* assumes there is enough space in the destination buffer */
    return _fread_nolock_s(buffer, SIZE_MAX, elementSize, count, stream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fseeki64.c ===
/***
*fseeki64.c - reposition file pointer on a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _fseeki64() - move the file pointer to new place in file
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <msdos.h>
#include <errno.h>
#include <malloc.h>
#include <io.h>
#include <stddef.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _fseeki64(stream, offset, whence) - reposition file pointer
*
*Purpose:
*
*       Reposition file pointer to the desired location.  The new location
*       is calculated as follows:
*                                { whence=0, beginning of file }
*               <offset> bytes + { whence=1, current position  }
*                                { whence=2, end of file       }
*
*       Be careful to coordinate with buffering.
*
*Entry:
*       FILE *stream  - file to reposition file pointer on
*       _int64 offset - offset to seek to
*       int whence    - origin offset is measured from (0=beg, 1=current pos,
*                       2=end)
*
*Exit:
*       returns 0 if succeeds
*       returns -1 and sets errno if fails
*       fields of FILE struct will be changed
*
*Exceptions:
*
*******************************************************************************/


int __cdecl _fseeki64 (
        FILE *stream,
        __int64 offset,
        int whence
        )
{
        int retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
                retval = _fseeki64_nolock (stream, offset, whence);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_fseeki64_nolock() - Core _fseeki64() routine (stream is locked)
*
*Purpose:
*       Core _fseeki64() routine; assumes that caller has the stream locked.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _fseeki64_nolock (


        FILE *str,
        __int64 offset,
        int whence
        )
{


        REG1 FILE *stream;

        _ASSERTE(str != NULL);

        /* Init stream pointer */
        stream = str;

        if ( !inuse(stream) || ((whence != SEEK_SET) && (whence != SEEK_CUR) &&
            (whence != SEEK_END)) ) {
                errno=EINVAL;
                return(-1);
        }

        /* Clear EOF flag */

        stream->_flag &= ~_IOEOF;

        /* If seeking relative to current location, then convert to
           a seek relative to beginning of file.  This accounts for
           buffering, etc. by letting fseek() tell us where we are. */

        if (whence == SEEK_CUR) {
                offset += _ftelli64_nolock(stream);
                whence = SEEK_SET;
        }

        /* Flush buffer as necessary */

        _flush(stream);

        /* If file opened for read/write, clear flags since we don't know
           what the user is going to do next. If the file was opened for
           read access only, decrease _bufsiz so that the next _filbuf
           won't cost quite so much */

        if (stream->_flag & _IORW)
                stream->_flag &= ~(_IOWRT|_IOREAD);
        else if ( (stream->_flag & _IOREAD) && (stream->_flag & _IOMYBUF) &&
                  !(stream->_flag & _IOSETVBUF) )
                stream->_bufsiz = _SMALL_BUFSIZ;

        /* Seek to the desired locale and return. */

        return(_lseeki64(_fileno(stream), offset, whence) == -1i64 ? -1 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fullpath.c ===
/***
*fullpath.c -
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose: contains the function _fullpath which makes an absolute path out
*       of a relative path. i.e.  ..\pop\..\main.c => c:\src\main.c if the
*       current directory is c:\src\src
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <direct.h>
#include <errno.h>
#include <stdlib.h>
#include <internal.h>
#include <tchar.h>
#include <windows.h>


/***
*_TSCHAR *_fullpath( _TSCHAR *buf, const _TSCHAR *path, maxlen );
*
*Purpose:
*
*       _fullpath - combines the current directory with path to form
*       an absolute path. i.e. _fullpath takes care of .\ and ..\
*       in the path.
*
*       The result is placed in buf. If the length of the result
*       is greater than maxlen NULL is returned, otherwise
*       the address of buf is returned.
*
*       If buf is NULL then a buffer is malloc'ed and maxlen is
*       ignored. If there are no errors then the address of this
*       buffer is returned.
*
*       If path specifies a drive, the curent directory of this
*       drive is combined with path. If the drive is not valid
*       and _fullpath needs the current directory of this drive
*       then NULL is returned.  If the current directory of this
*       non existant drive is not needed then a proper value is
*       returned.
*       For example:  path = "z:\\pop" does not need z:'s current
*       directory but path = "z:pop" does.
*
*
*
*Entry:
*       _TSCHAR *buf  - pointer to a buffer maintained by the user;
*       _TSCHAR *path - path to "add" to the current directory
*       int maxlen - length of the buffer pointed to by buf
*
*Exit:
*       Returns pointer to the buffer containing the absolute path
*       (same as buf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/

#ifdef _DEBUG

_TSCHAR * __cdecl _tfullpath (
        _TSCHAR *UserBuf,
        const _TSCHAR *path,
        size_t maxlen
        )
{
    return _tfullpath_dbg(UserBuf, path, maxlen, _NORMAL_BLOCK, NULL, 0);
}

_TSCHAR * __cdecl _tfullpath_dbg (
        _TSCHAR *UserBuf,
        const _TSCHAR *path,
        size_t maxlen,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )

#else  /* _DEBUG */

_TSCHAR * __cdecl _tfullpath (
        _TSCHAR *UserBuf,
        const _TSCHAR *path,
        size_t maxlen
        )

#endif  /* _DEBUG */
{
        _TSCHAR *buf;
        _TSCHAR *pfname;
        unsigned long count;

        if ( !path || !*path )  /* no work to do */
            return( _tgetcwd( UserBuf, (int)maxlen ) );

        /* allocate buffer if necessary */

        if ( !UserBuf ) {

            count = GetFullPathName(path,0,NULL,NULL);

            if(count == 0) {
                _dosmaperr( GetLastError() );
                return( NULL );
            }

            maxlen = __max(maxlen, count);

            // overflow check

            if (maxlen > SIZE_MAX / sizeof(_TSCHAR)) {
               errno = EINVAL;
               return( NULL );
            }

#ifdef _DEBUG
            if ( !(buf = _calloc_dbg(maxlen, sizeof(_TSCHAR), nBlockUse, szFileName, nLine)) ) {
#else  /* _DEBUG */
            if ( !(buf = calloc(maxlen, sizeof(_TSCHAR))) ) {
#endif  /* _DEBUG */
                errno = ENOMEM;
                return( NULL );
            }
        }
        else
        {
            _VALIDATE_RETURN( (maxlen > 0), EINVAL, NULL);
            buf = UserBuf;
        }


        count = GetFullPathName ( path,
                                  (int)maxlen,
                                  buf,
                                  &pfname );

        if ( count >= maxlen ) {
            if ( !UserBuf )
                free(buf);
            errno = ERANGE;
            return( NULL );
        }
        else if ( count == 0 ) {
            if ( !UserBuf )
                free(buf);
            _dosmaperr( GetLastError() );
            return( NULL );
        }

        return( buf );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fwprintf.c ===
/***
*fwprintf.c - print formatted data to stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fwprintf() - print formatted data to stream
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>
#include <stddef.h>

/***
*int fwprintf(stream, format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data on the given using the format string to
*       format data and getting as many arguments as called for
*       _output does the real work here
*
*Entry:
*       FILE *stream - stream to print on
*       wchar_t *format - format string to control data format/number of arguments
*       followed by arguments to print, number and type controlled by
*       format string
*
*Exit:
*       returns number of wide characters printed
*
*Exceptions:
*
*******************************************************************************/

int __cdecl fwprintf (
        FILE *str,
        const wchar_t *format,
        ...
        )
/*
 * 'F'ile (stream) 'W'char_t 'PRINT', 'F'ormatted
 */
{
        va_list(arglist);
        REG1 FILE *stream;
        REG2 int buffing;
        int retval;

        _VALIDATE_RETURN( (str != NULL), EINVAL, -1);
        _VALIDATE_RETURN( (format != NULL), EINVAL, -1);

        va_start(arglist, format);

        /* Init stream pointer */
        stream = str;

        _lock_str(stream);
        __try {

        buffing = _stbuf(stream);
        retval = _woutput_l(stream,format,NULL,arglist);
        _ftbuf(buffing, stream);

        }
        __finally {
            _unlock_str(stream);
        }

        return(retval);
}

int __cdecl _fwprintf_l (
        FILE *str,
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vfwprintf_l(str, format, plocinfo, arglist);
}

int __cdecl _fwprintf_s_l (
        FILE *str,
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vfwprintf_s_l(str, format, plocinfo, arglist);
}

int __cdecl fwprintf_s (
        FILE *str,
        const wchar_t *format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, format);

    return _vfwprintf_s_l(str, format, NULL, arglist);
}

int __cdecl _fwprintf_p_l (
        FILE *str,
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _vfwprintf_p_l(str, format, plocinfo, arglist);
}

int __cdecl _fwprintf_p (
        FILE *str,
        const wchar_t *format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, format);

    return _vfwprintf_p_l(str, format, NULL, arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ftime64.c ===
/***
*ftime64.c - return system time
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Returns the system date/time in a structure form.
*
*******************************************************************************/


#include <cruntime.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <msdos.h>
#include <dos.h>
#include <stdlib.h>
#include <windows.h>
#include <internal.h>

/*
 * Number of 100 nanosecond units from 1/1/1601 to 1/1/1970
 */
#define EPOCH_BIAS  116444736000000000i64

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
        unsigned __int64 ft_scalar;
        FILETIME ft_struct;
        } FT;

/*
 * Cache for the minutes count for with DST status was last assessed
 */
static __time64_t elapsed_minutes_cache;

/*
 * Three values of dstflag_cache
 */
#define DAYLIGHT_TIME   1
#define STANDARD_TIME   0
#define UNKNOWN_TIME    -1

/*
 * Cache for the last determined DST status
 */
static int dstflag_cache = UNKNOWN_TIME;

/***
*void _ftime64(timeptr) - return DOS time in a structure
*
*Purpose:
*       returns the current DOS time in a struct timeb structure
*
*Entry:
*       struct __timeb64 *timeptr - structure to fill in with time
*
*Exit:
*       no return value -- fills in structure
*
*Exceptions:
*
*******************************************************************************/

_CRTIMP errno_t __cdecl _ftime64_s (
        struct __timeb64 *tp
        )
{
        FT nt_time;
        __time64_t t;
        TIME_ZONE_INFORMATION tzinfo;
        DWORD tzstate;
        long timezone = 0;

        _VALIDATE_RETURN_ERRCODE( ( tp != NULL ), EINVAL )

        __tzset();

        _ERRCHECK(_get_timezone(&timezone));
        tp->timezone = (short)(timezone / 60);

        GetSystemTimeAsFileTime( &(nt_time.ft_struct) );

        /*
         * Obtain the current DST status. Note the status is cached and only
         * updated once per minute, if necessary.
         */
        if ( (t = (__time64_t)(nt_time.ft_scalar / 600000000i64))
             != elapsed_minutes_cache )
        {
            if ( (tzstate = GetTimeZoneInformation( &tzinfo )) != 0xFFFFFFFF )
            {
                /*
                 * Must be very careful in determining whether or not DST is
                 * really in effect.
                 */
                if ( (tzstate == TIME_ZONE_ID_DAYLIGHT) &&
                     (tzinfo.DaylightDate.wMonth != 0) &&
                     (tzinfo.DaylightBias != 0) )
                    dstflag_cache = DAYLIGHT_TIME;
                else
                    /*
                     * When in doubt, assume standard time
                     */
                    dstflag_cache = STANDARD_TIME;
            }
            else
                dstflag_cache = UNKNOWN_TIME;

            elapsed_minutes_cache = t;
        }

        tp->dstflag = (short)dstflag_cache;

        tp->millitm = (unsigned short)((nt_time.ft_scalar / 10000i64) %
                      1000i64);

        tp->time = (__time64_t)((nt_time.ft_scalar - EPOCH_BIAS) / 10000000i64);

        return 0;
}

_CRTIMP void __cdecl _ftime64 (
        struct __timeb64 *tp
        )
{
    _ftime64_s(tp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\ftelli64.c ===
/***
*ftelli64.c - get current file position
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _ftelli64() - find current current position of file pointer
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <file2.h>
#include <dbgint.h>
#include <errno.h>
#include <msdos.h>
#include <stddef.h>
#include <io.h>
#include <internal.h>
#include <mtdll.h>

/***
*__int64 _ftelli64(stream) - query stream file pointer
*
*Purpose:
*       Find out what stream's position is. coordinate with buffering; adjust
*       backward for read-ahead and forward for write-behind. This is NOT
*       equivalent to fseek(stream,0L,1), because fseek will remove an ungetc,
*       may flush buffers, etc.
*
*Entry:
*       FILE *stream - stream to query for position
*
*Exit:
*       return present file position if succeeds
*       returns -1i64 and sets errno if fails
*
*Exceptions:
*
*******************************************************************************/


__int64 __cdecl _ftelli64 (
        FILE *stream
        )
{
        __int64 retval;

        _ASSERTE(stream != NULL);

        _lock_str(stream);

        __try {
               retval = _ftelli64_nolock (stream);
        }
        __finally {
                _unlock_str(stream);
        }

        return(retval);
}


/***
*_ftelli64_nolock() - _ftelli64() core routine (assumes stream is locked).
*
*Purpose:
*       Core _ftelli64() routine (assumes caller has aquired stream lock).
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

__int64 __cdecl _ftelli64_nolock (


        FILE *str
        )
{
        REG1 FILE *stream;
        size_t offset;
        __int64 filepos;
        REG2 char *p;
        char *max;
        int fd;
        size_t rdcnt;
        char tmode;

        _ASSERTE(str != NULL);

        /* Init stream pointer and file descriptor */
        stream = str;
        fd = _fileno(stream);

        if (stream->_cnt < 0)
                stream->_cnt = 0;

        if ((filepos = _lseeki64(fd, 0i64, SEEK_CUR)) < 0L)
                return(-1i64);

        /* _lseek164 validates fd, so it's now ok to retrieve the textmode */
        tmode = _textmode(fd);

        if (!bigbuf(stream))            /* _IONBF or no buffering designated */
                return(filepos - stream->_cnt);

        offset = (size_t)(stream->_ptr - stream->_base);

        if (stream->_flag & (_IOWRT|_IOREAD)) {
                if (tmode == __IOINFO_TM_UTF8 && _utf8translations(fd))
                {
                    size_t curpos = (size_t)(stream->_ptr - stream->_base) / sizeof(wchar_t);

                    if (stream->_cnt == 0)
                        return filepos;
                    else {
                        DWORD bytes_read;
                        char buf[_INTERNAL_BUFSIZ];

                        __int64 basepos = _lseeki64(fd, _startpos(fd), SEEK_SET);

                        if (basepos != _startpos(fd))
                            return (-1);
                        if ( !ReadFile( (HANDLE)_osfhnd(fd), buf, _INTERNAL_BUFSIZ, &bytes_read, NULL ) )
                            return (-1);
                        if (_lseeki64(fd, filepos, SEEK_SET) < 0)
                            return -1;
                        if (curpos > bytes_read)
                            return (-1);

                        p = buf;
                        while (curpos-- && (p < buf + bytes_read) )
                        {
                            if (*p == CR) {
                                /* *p is CR, so must check next char for LF */
                                if (p < (char *)buf + bytes_read - 1) {
                                    if (*(p+1) == LF) {
                                        p ++;
                                    }
                                }
                            }
                            else {
                                p += _utf8_no_of_trailbytes(*p);
                            }
                            p++;
                        }
                        return basepos + (size_t)(p - buf);
                    }
                }
                if (_osfile(fd) & FTEXT)
                        for (p = stream->_base; p < stream->_ptr; p++)
                                if (*p == '\n')  /* adjust for '\r' */
                                        offset++;
        }
        else if (!(stream->_flag & _IORW)) {
                errno=EINVAL;
                return(-1i64);
        }

        if (filepos == 0i64)
                return((__int64)offset);

        if (stream->_flag & _IOREAD)    /* go to preceding sector */

                if (stream->_cnt == 0)  /* filepos holds correct location */
                        offset = 0;

                else {

                        /* Subtract out the number of unread bytes left in the
                           buffer. [We can't simply use _iob[]._bufsiz because
                           the last read may have hit EOF and, thus, the buffer
                           was not completely filled.] */

                        rdcnt = stream->_cnt + (size_t)(stream->_ptr - stream->_base);

                        /* If text mode, adjust for the cr/lf substitution. If
                           binary mode, we're outta here. */
                        if (_osfile(fd) & FTEXT) {
                                /* (1) If we're not at eof, simply copy _bufsiz
                                   onto rdcnt to get the # of untranslated
                                   chars read. (2) If we're at eof, we must
                                   look through the buffer expanding the '\n'
                                   chars one at a time. */

                                /* [NOTE: Performance issue -- it is faster to
                                   do the two _lseek() calls than to blindly go
                                   through and expand the '\n' chars regardless
                                   of whether we're at eof or not.] */

                                if (_lseeki64(fd, 0i64, SEEK_END) == filepos) {

                                        max = stream->_base + rdcnt;
                                        for (p = stream->_base; p < max; p++)
                                                if (*p == '\n')
                                                        /* adjust for '\r' */
                                                        rdcnt++;

                                        /* If last byte was ^Z, the lowio read
                                           didn't tell us about it.  Check flag
                                           and bump count, if necessary. */

                                        if (stream->_flag & _IOCTRLZ)
                                                ++rdcnt;
                                }

                                else {

                                        if (_lseeki64(fd, filepos, SEEK_SET) < 0)
                                            return (-1);

                                        /* We want to set rdcnt to the number
                                           of bytes originally read into the
                                           stream buffer (before crlf->lf
                                           translation). In most cases, this
                                           will just be _bufsiz. However, the
                                           buffer size may have been changed,
                                           due to fseek optimization, at the
                                           END of the last _filbuf call. */

                                        if ( (rdcnt <= _SMALL_BUFSIZ) &&
                                             (stream->_flag & _IOMYBUF) &&
                                             !(stream->_flag & _IOSETVBUF) )
                                        {
                                                /* The translated contents of
                                                   the buffer is small and we
                                                   are not at eof. The buffer
                                                   size must have been set to
                                                   _SMALL_BUFSIZ during the
                                                   last _filbuf call. */

                                                rdcnt = _SMALL_BUFSIZ;
                                        }
                                        else
                                                rdcnt = stream->_bufsiz;


                                        /* If first byte in untranslated buffer
                                           was a '\n', assume it was preceeded
                                           by a '\r' which was discarded by the
                                           previous read operation and count
                                           the '\n'. */
                                        if  (_osfile(fd) & FCRLF)
                                                ++rdcnt;
                                }

                        } /* end if FTEXT */

                        if (tmode == __IOINFO_TM_UTF8)
                            rdcnt /= sizeof(wchar_t);

                        filepos -= (__int64)rdcnt;

                } /* end else stream->_cnt != 0 */

        if (tmode == __IOINFO_TM_UTF8)
            offset /= sizeof(wchar_t);
        return(filepos + (__int64)offset);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fvec.h ===
/**
*** Copyright (C) 1985-1999 Intel Corporation.  All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
***
**/

/*
 *  Definition of a C++ class interface to Streaming SIMD Extension intrinsics.
 *
 *
 *      File name : fvec.h  Fvec class definitions
 *
 *      Concept: A C++ abstraction of Streaming SIMD Extensions designed to improve
 *
 *  programmer productivity.  Speed and accuracy are sacrificed for utility.
 *
 *      Facilitates an easy transition to compiler intrinsics
 *
 *      or assembly language.
 *
 *      F32vec4:        4 packed single precision
 *                              32-bit floating point numbers
*/

#ifndef _FVEC_H_INCLUDED
#define _FVEC_H_INCLUDED
#ifndef RC_INVOKED

#if !defined __cplusplus
        #error ERROR: This file is only supported in C++ compilations!
#endif  /* !defined __cplusplus */

#if defined (_M_CEE_PURE)
        #error ERROR: This file is not supported in the pure mode!
#else  /* defined (_M_CEE_PURE) */

#include <xmmintrin.h> /* Streaming SIMD Extensions Intrinsics include file */
#include <assert.h>
#include <ivec.h>
#include <crtdefs.h>

/* Define _ENABLE_VEC_DEBUG to enable std::ostream inserters for debug output */
#if defined (_ENABLE_VEC_DEBUG)
        #include <iostream>
#endif  /* defined (_ENABLE_VEC_DEBUG) */

#ifdef _MSC_VER
#pragma pack(push,_CRT_PACKING)
#endif  /* _MSC_VER */

#pragma pack(push,16) /* Must ensure class & union 16-B aligned */

#define EXPLICIT explicit

class F32vec4
{
protected:
         __m128 vec;
public:

        /* Constructors: __m128, 4 floats, 1 float */
        F32vec4() {}

        /* initialize 4 SP FP with __m128 data type */
        F32vec4(__m128 m)                                       { vec = m;}

        /* initialize 4 SP FPs with 4 floats */
        F32vec4(float f3, float f2, float f1, float f0)         { vec= _mm_set_ps(f3,f2,f1,f0); }

        /* Explicitly initialize each of 4 SP FPs with same float */
        EXPLICIT F32vec4(float f)       { vec = _mm_set_ps1(f); }

        /* Explicitly initialize each of 4 SP FPs with same double */
        EXPLICIT F32vec4(double d)      { vec = _mm_set_ps1((float) d); }

        /* Assignment operations */

        F32vec4& operator =(float f) { vec = _mm_set_ps1(f); return *this; }

        F32vec4& operator =(double d) { vec = _mm_set_ps1((float) d); return *this; }

        /* Conversion functions */
        operator  __m128() const        { return vec; }         /* Convert to __m128 */

        /* Logical Operators */
        friend F32vec4 operator &(const F32vec4 &a, const F32vec4 &b) { return _mm_and_ps(a,b); }
        friend F32vec4 operator |(const F32vec4 &a, const F32vec4 &b) { return _mm_or_ps(a,b); }
        friend F32vec4 operator ^(const F32vec4 &a, const F32vec4 &b) { return _mm_xor_ps(a,b); }

        /* Arithmetic Operators */
        friend F32vec4 operator +(const F32vec4 &a, const F32vec4 &b) { return _mm_add_ps(a,b); }
        friend F32vec4 operator -(const F32vec4 &a, const F32vec4 &b) { return _mm_sub_ps(a,b); }
        friend F32vec4 operator *(const F32vec4 &a, const F32vec4 &b) { return _mm_mul_ps(a,b); }
        friend F32vec4 operator /(const F32vec4 &a, const F32vec4 &b) { return _mm_div_ps(a,b); }

        F32vec4& operator =(const F32vec4 &a) { vec = a.vec; return *this; }
        F32vec4& operator =(const __m128 &avec) { vec = avec; return *this; }
        F32vec4& operator +=(F32vec4 &a) { return *this = _mm_add_ps(vec,a); }
        F32vec4& operator -=(F32vec4 &a) { return *this = _mm_sub_ps(vec,a); }
        F32vec4& operator *=(F32vec4 &a) { return *this = _mm_mul_ps(vec,a); }
        F32vec4& operator /=(F32vec4 &a) { return *this = _mm_div_ps(vec,a); }
        F32vec4& operator &=(F32vec4 &a) { return *this = _mm_and_ps(vec,a); }
        F32vec4& operator |=(F32vec4 &a) { return *this = _mm_or_ps(vec,a); }
        F32vec4& operator ^=(F32vec4 &a) { return *this = _mm_xor_ps(vec,a); }

        /* Horizontal Add */
        friend float add_horizontal(F32vec4 &a)
        {
                F32vec4 ftemp = _mm_add_ss(a,_mm_add_ss(_mm_shuffle_ps(a, a, 1),_mm_add_ss(_mm_shuffle_ps(a, a, 2),_mm_shuffle_ps(a, a, 3))));
                return ftemp[0];
        }

        /* Square Root */
        friend F32vec4 sqrt(const F32vec4 &a)           { return _mm_sqrt_ps(a); }
        /* Reciprocal */
        friend F32vec4 rcp(const F32vec4 &a)            { return _mm_rcp_ps(a); }
        /* Reciprocal Square Root */
        friend F32vec4 rsqrt(const F32vec4 &a)          { return _mm_rsqrt_ps(a); }

        /* NewtonRaphson Reciprocal
           [2 * rcpps(x) - (x * rcpps(x) * rcpps(x))] */
        friend F32vec4 rcp_nr(const F32vec4 &a)
        {
                F32vec4 Ra0 = _mm_rcp_ps(a);
                return _mm_sub_ps(_mm_add_ps(Ra0, Ra0), _mm_mul_ps(_mm_mul_ps(Ra0, a), Ra0));
        }

        /*      NewtonRaphson Reciprocal Square Root
                0.5 * rsqrtps * (3 - x * rsqrtps(x) * rsqrtps(x)) */
#pragma warning(push)
#pragma warning(disable : 4640)
        friend F32vec4 rsqrt_nr(const F32vec4 &a)
        {
                static const F32vec4 fvecf0pt5(0.5f);
                static const F32vec4 fvecf3pt0(3.0f);
                F32vec4 Ra0 = _mm_rsqrt_ps(a);
                return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);
        }
#pragma warning(pop)

        /* Compares: Mask is returned  */
        /* Macros expand to all compare intrinsics.  Example:
        friend F32vec4 cmpeq(const F32vec4 &a, const F32vec4 &b)
        { return _mm_cmpeq_ps(a,b);} */
        #define Fvec32s4_COMP(op) \
        friend F32vec4 cmp##op (const F32vec4 &a, const F32vec4 &b) { return _mm_cmp##op##_ps(a,b); }
                Fvec32s4_COMP(eq)                                       /* expanded to cmpeq(a,b) */
                Fvec32s4_COMP(lt)                                       /* expanded to cmplt(a,b) */
                Fvec32s4_COMP(le)                                       /* expanded to cmple(a,b) */
                Fvec32s4_COMP(gt)                                       /* expanded to cmpgt(a,b) */
                Fvec32s4_COMP(ge)                                       /* expanded to cmpge(a,b) */
                Fvec32s4_COMP(neq)                                      /* expanded to cmpneq(a,b) */
                Fvec32s4_COMP(nlt)                                      /* expanded to cmpnlt(a,b) */
                Fvec32s4_COMP(nle)                                      /* expanded to cmpnle(a,b) */
                Fvec32s4_COMP(ngt)                                      /* expanded to cmpngt(a,b) */
                Fvec32s4_COMP(nge)                                      /* expanded to cmpnge(a,b) */
        #undef Fvec32s4_COMP

        /* Min and Max */
        friend F32vec4 simd_min(const F32vec4 &a, const F32vec4 &b) { return _mm_min_ps(a,b); }
        friend F32vec4 simd_max(const F32vec4 &a, const F32vec4 &b) { return _mm_max_ps(a,b); }

        /* Debug Features */
#if defined (_ENABLE_VEC_DEBUG)
        /* Output */
        friend std::ostream & operator<<(std::ostream & os, const F32vec4 &a)
        {
        /* To use: cout << "Elements of F32vec4 fvec are: " << fvec; */
          float *fp = (float*)&a;
                os << "[3]:" << *(fp+3)
                        << " [2]:" << *(fp+2)
                        << " [1]:" << *(fp+1)
                        << " [0]:" << *fp;
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */
        /* Element Access Only, no modifications to elements*/
        const float& operator[](int i) const
        {
                /* Assert enabled only during debug /DDEBUG */
                assert((0 <= i) && (i <= 3));                   /* User should only access elements 0-3 */
                float *fp = (float*)&vec;
                return *(fp+i);
        }
        /* Element Access and Modification*/
        float& operator[](int i)
        {
                /* Assert enabled only during debug /DDEBUG */
                assert((0 <= i) && (i <= 3));                   /* User should only access elements 0-3 */
                float *fp = (float*)&vec;
                return *(fp+i);
        }
};

                                                /* Miscellaneous */

/* Interleave low order data elements of a and b into destination */
inline F32vec4 unpack_low(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpacklo_ps(a, b); }

/* Interleave high order data elements of a and b into target */
inline F32vec4 unpack_high(const F32vec4 &a, const F32vec4 &b)
{ return _mm_unpackhi_ps(a, b); }

/* Move Mask to Integer returns 4 bit mask formed of most significant bits of a */
inline int move_mask(const F32vec4 &a)
{ return _mm_movemask_ps(a);}

                                                /* Data Motion Functions */

/* Load Unaligned loadu_ps: Unaligned */
inline void loadu(F32vec4 &a, float *p)
{ a = _mm_loadu_ps(p); }

/* Store Temporal storeu_ps: Unaligned */
inline void storeu(float *p, const F32vec4 &a)
{ _mm_storeu_ps(p, a); }

                                                /* Cacheability Support */

/* Non-Temporal Store */
inline void store_nta(float *p, F32vec4 &a)
{ _mm_stream_ps(p,a);}

                                                /* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec4 select_eq(const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d)
{
        F32vec4 mask = _mm_cmpeq_ps(a,b);
        return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s4_SELECT(op) \
inline F32vec4 select_##op (const F32vec4 &a, const F32vec4 &b, const F32vec4 &c, const F32vec4 &d)        \
{                                                                                                                               \
        F32vec4 mask = _mm_cmp##op##_ps(a,b);                                           \
        return( (mask & c) | F32vec4((_mm_andnot_ps(mask,d)))); \
}
Fvec32s4_SELECT(eq)                     /* generates select_eq(a,b) */
Fvec32s4_SELECT(lt)                     /* generates select_lt(a,b) */
Fvec32s4_SELECT(le)                     /* generates select_le(a,b) */
Fvec32s4_SELECT(gt)                     /* generates select_gt(a,b) */
Fvec32s4_SELECT(ge)                     /* generates select_ge(a,b) */
Fvec32s4_SELECT(neq)            /* generates select_neq(a,b) */
Fvec32s4_SELECT(nlt)            /* generates select_nlt(a,b) */
Fvec32s4_SELECT(nle)            /* generates select_nle(a,b) */
Fvec32s4_SELECT(ngt)            /* generates select_ngt(a,b) */
Fvec32s4_SELECT(nge)            /* generates select_nge(a,b) */
#undef Fvec32s4_SELECT


/* Streaming SIMD Extensions Integer Intrinsics */

/* Max and Min */
inline Is16vec4 simd_max(const Is16vec4 &a, const Is16vec4 &b)          { return _m_pmaxsw(a,b);}
inline Is16vec4 simd_min(const Is16vec4 &a, const Is16vec4 &b)          { return _m_pminsw(a,b);}
inline Iu8vec8 simd_max(const Iu8vec8 &a, const Iu8vec8 &b)                     { return _m_pmaxub(a,b);}
inline Iu8vec8 simd_min(const Iu8vec8 &a, const Iu8vec8 &b)                     { return _m_pminub(a,b);}

/* Average */
inline Iu16vec4 simd_avg(const Iu16vec4 &a, const Iu16vec4 &b)          { return _m_pavgw(a,b); }
inline Iu8vec8 simd_avg(const Iu8vec8 &a, const Iu8vec8 &b)                     { return _m_pavgb(a,b); }

/* Move ByteMask To Int: returns mask formed from most sig bits of each vec of a */
inline int move_mask(const I8vec8 &a)                                                           { return _m_pmovmskb(a);}

/* Packed Multiply High Unsigned */
inline Iu16vec4 mul_high(const Iu16vec4 &a, const Iu16vec4 &b)          { return _m_pmulhuw(a,b); }

/* Byte Mask Write: Write bytes if most significant bit in each corresponding byte is set */
inline void mask_move(const I8vec8 &a, const I8vec8 &b, char *addr)     { _m_maskmovq(a, b, addr); }

/* Data Motion: Store Non Temporal */
inline void store_nta(__m64 *p, M64 &a) { _mm_stream_pi(p,a); }

/* Conversions between ivec <-> fvec */

/* Convert first element of F32vec4 to int with truncation */
inline int F32vec4ToInt(const F32vec4 &a)
{

        return _mm_cvtt_ss2si(a);

}

/* Convert two lower SP FP values of a to Is32vec2 with truncation */
inline Is32vec2 F32vec4ToIs32vec2 (const F32vec4 &a)
{

        __m64 result;
        result = _mm_cvtt_ps2pi(a);
        return Is32vec2(result);

}

/* Convert the 32-bit int i to an SP FP value; the upper three SP FP values are passed through from a. */
inline F32vec4 IntToF32vec4(const F32vec4 &a, int i)
{

        __m128 result;
        result = _mm_cvt_si2ss(a,i);
        return F32vec4(result);

}

/* Convert the two 32-bit integer values in b to two SP FP values; the upper two SP FP values are passed from a. */
inline F32vec4 Is32vec2ToF32vec4(const F32vec4 &a, const Is32vec2 &b)
{

        __m128 result;
        result = _mm_cvt_pi2ps(a,b);
        return F32vec4(result);
}

class F32vec1
{
protected:
         __m128 vec;
public:

        /* Constructors: 1 float */
        F32vec1() {}

        F32vec1(int i)          { vec = _mm_cvt_si2ss(vec,i);};

        /* Initialize each of 4 SP FPs with same float */
        EXPLICIT F32vec1(float f)       { vec = _mm_set_ss(f); }

        /* Initialize each of 4 SP FPs with same float */
        EXPLICIT F32vec1(double d)      { vec = _mm_set_ss((float) d); }

        /* initialize with __m128 data type */
        F32vec1(__m128 m)       { vec = m; }

        /* Conversion functions */
        operator  __m128() const        { return vec; }         /* Convert to float */

        /* Logical Operators */
        friend F32vec1 operator &(const F32vec1 &a, const F32vec1 &b) { return _mm_and_ps(a,b); }
        friend F32vec1 operator |(const F32vec1 &a, const F32vec1 &b) { return _mm_or_ps(a,b); }
        friend F32vec1 operator ^(const F32vec1 &a, const F32vec1 &b) { return _mm_xor_ps(a,b); }

        /* Arithmetic Operators */
        friend F32vec1 operator +(const F32vec1 &a, const F32vec1 &b) { return _mm_add_ss(a,b); }
        friend F32vec1 operator -(const F32vec1 &a, const F32vec1 &b) { return _mm_sub_ss(a,b); }
        friend F32vec1 operator *(const F32vec1 &a, const F32vec1 &b) { return _mm_mul_ss(a,b); }
        friend F32vec1 operator /(const F32vec1 &a, const F32vec1 &b) { return _mm_div_ss(a,b); }

        F32vec1& operator +=(F32vec1 &a) { return *this = _mm_add_ss(vec,a); }
        F32vec1& operator -=(F32vec1 &a) { return *this = _mm_sub_ss(vec,a); }
        F32vec1& operator *=(F32vec1 &a) { return *this = _mm_mul_ss(vec,a); }
        F32vec1& operator /=(F32vec1 &a) { return *this = _mm_div_ss(vec,a); }
        F32vec1& operator &=(F32vec1 &a) { return *this = _mm_and_ps(vec,a); }
        F32vec1& operator |=(F32vec1 &a) { return *this = _mm_or_ps(vec,a); }
        F32vec1& operator ^=(F32vec1 &a) { return *this = _mm_xor_ps(vec,a); }


        /* Square Root */
        friend F32vec1 sqrt(const F32vec1 &a)           { return _mm_sqrt_ss(a); }
        /* Reciprocal */
        friend F32vec1 rcp(const F32vec1 &a)            { return _mm_rcp_ss(a); }
        /* Reciprocal Square Root */
        friend F32vec1 rsqrt(const F32vec1 &a)          { return _mm_rsqrt_ss(a); }

        /* NewtonRaphson Reciprocal
           [2 * rcpss(x) - (x * rcpss(x) * rcpss(x))] */
        friend F32vec1 rcp_nr(const F32vec1 &a)
        {
                F32vec1 Ra0 = _mm_rcp_ss(a);
                return _mm_sub_ss(_mm_add_ss(Ra0, Ra0), _mm_mul_ss(_mm_mul_ss(Ra0, a), Ra0));
        }

        /*      NewtonRaphson Reciprocal Square Root
                0.5 * rsqrtss * (3 - x * rsqrtss(x) * rsqrtss(x)) */
#pragma warning(push)
#pragma warning(disable : 4640)
        friend F32vec1 rsqrt_nr(const F32vec1 &a)
        {
                static const F32vec1 fvecf0pt5(0.5f);
                static const F32vec1 fvecf3pt0(3.0f);
                F32vec1 Ra0 = _mm_rsqrt_ss(a);
                return (fvecf0pt5 * Ra0) * (fvecf3pt0 - (a * Ra0) * Ra0);
        }
#pragma warning(pop)

        /* Compares: Mask is returned  */
        /* Macros expand to all compare intrinsics.  Example:
        friend F32vec1 cmpeq(const F32vec1 &a, const F32vec1 &b)
        { return _mm_cmpeq_ss(a,b);} */
        #define Fvec32s1_COMP(op) \
        friend F32vec1 cmp##op (const F32vec1 &a, const F32vec1 &b) { return _mm_cmp##op##_ss(a,b); }
                Fvec32s1_COMP(eq)                                       /* expanded to cmpeq(a,b) */
                Fvec32s1_COMP(lt)                                       /* expanded to cmplt(a,b) */
                Fvec32s1_COMP(le)                                       /* expanded to cmple(a,b) */
                Fvec32s1_COMP(gt)                                       /* expanded to cmpgt(a,b) */
                Fvec32s1_COMP(ge)                                       /* expanded to cmpge(a,b) */
                Fvec32s1_COMP(neq)                                      /* expanded to cmpneq(a,b) */
                Fvec32s1_COMP(nlt)                                      /* expanded to cmpnlt(a,b) */
                Fvec32s1_COMP(nle)                                      /* expanded to cmpnle(a,b) */
                Fvec32s1_COMP(ngt)                                      /* expanded to cmpngt(a,b) */
                Fvec32s1_COMP(nge)                                      /* expanded to cmpnge(a,b) */
        #undef Fvec32s1_COMP

        /* Min and Max */
        friend F32vec1 simd_min(const F32vec1 &a, const F32vec1 &b) { return _mm_min_ss(a,b); }
        friend F32vec1 simd_max(const F32vec1 &a, const F32vec1 &b) { return _mm_max_ss(a,b); }

        /* Debug Features */
#if defined (_ENABLE_VEC_DEBUG)
        /* Output */
        friend std::ostream & operator<<(std::ostream & os, const F32vec1 &a)
        {
        /* To use: cout << "Elements of F32vec1 fvec are: " << fvec; */
          float *fp = (float*)&a;
                os << "float:" << *fp;
                return os;
        }
#endif  /* defined (_ENABLE_VEC_DEBUG) */

};

                                                /* Conditional Selects:*/
/*(a OP b)? c : d; where OP is any compare operator
Macros expand to conditional selects which use all compare intrinsics.
Example:
friend F32vec1 select_eq(const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d)
{
        F32vec1 mask = _mm_cmpeq_ss(a,b);
        return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));
}
*/

#define Fvec32s1_SELECT(op) \
inline F32vec1 select_##op (const F32vec1 &a, const F32vec1 &b, const F32vec1 &c, const F32vec1 &d)        \
{                                                                                                          \
        F32vec1 mask = _mm_cmp##op##_ss(a,b);                                                              \
        return( (mask & c) | F32vec1((_mm_andnot_ps(mask,d))));                                            \
}
Fvec32s1_SELECT(eq)                     /* generates select_eq(a,b) */
Fvec32s1_SELECT(lt)                     /* generates select_lt(a,b) */
Fvec32s1_SELECT(le)                     /* generates select_le(a,b) */
Fvec32s1_SELECT(gt)                     /* generates select_gt(a,b) */
Fvec32s1_SELECT(ge)                     /* generates select_ge(a,b) */
Fvec32s1_SELECT(neq)            /* generates select_neq(a,b) */
Fvec32s1_SELECT(nlt)            /* generates select_nlt(a,b) */
Fvec32s1_SELECT(nle)            /* generates select_nle(a,b) */
Fvec32s1_SELECT(ngt)            /* generates select_ngt(a,b) */
Fvec32s1_SELECT(nge)            /* generates select_nge(a,b) */
#undef Fvec32s1_SELECT

/* Conversions between ivec <-> fvec */

/* Convert F32vec1 to int */
inline int F32vec1ToInt(const F32vec1 &a)
{
        return _mm_cvtt_ss2si(a);
}



#pragma pack(pop) /* 16-B aligned */

#ifdef _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif  /* defined (_M_CEE_PURE) */

#endif  /* RC_INVOKED */
#endif  /* _FVEC_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\generics.h ===
// generics STL.net header
#ifndef _CLI_GENERICS_
 #define _CLI_GENERICS_

#define _STLCLR_FIELD_ACCESS    internal

namespace Microsoft {
        namespace VisualC {
                namespace StlClr {

        namespace Generic {
//
// GENERIC INTERFACES
//

//
// GENERIC INTERFACE CLASS IBidirectionalContainer
//
generic<typename TValue>
        public interface class IBidirectionalContainer
        {       // interface for a bidirectional container
        unsigned long get_generation();
        };

//
// GENERIC INTERFACE CLASS IRandomAccessContainer
//
generic<typename TValue>
        public interface class IRandomAccessContainer
        {       // interface for a random-access container
        typedef int size_type;
//      typedef int difference_type;
        typedef TValue value_type;
        typedef value_type% reference;
//      typedef value_type% const_reference;

        bool valid_bias(size_type);
        reference at_bias(size_type);
        };

//
// GENERIC INTERFACE CLASS INode
//
generic<typename TValue>
        public interface class INode
        {       // interface for a node
        typedef INode<TValue> _Mynode_it;
        typedef IBidirectionalContainer<TValue> _Mycont_it;

        _Mycont_it^ container();
        bool is_head();
        _Mynode_it^ next_node();
        _Mynode_it^ prev_node();

        property TValue% _Value;
        };

//
// GENERIC INTERFACE CLASS IBaseIterator
//
generic<typename TValue>
        public interface class IBaseIterator
        :       public System::ICloneable
        {       // interface for base of all iterators, generic
        int get_bias();
        System::Object^ get_node();

        bool valid();
        System::Object^ container();
        void next();
        };

//
// GENERIC INTERFACE CLASS IInputIterator
//
generic<typename TValue>
        public interface class IInputIterator
        :       public IBaseIterator<TValue>
        {       // interface for an input iterator, generic
        typedef IInputIterator<TValue> _Mytype_t;
        typedef TValue value_type;

        bool equal_to(IInputIterator<TValue>^);
        value_type% get_cref();
        };

//
// GENERIC INTERFACE CLASS IOutputIterator
//
generic<typename TValue>
        public interface class IOutputIterator
        :       public IBaseIterator<TValue>
        {       // interface for an output iterator, generic
        typedef TValue value_type;

        value_type% get_ref();
        };

//
// GENERIC INTERFACE CLASS IForwardIterator
//
generic<typename TValue>
        public interface class IForwardIterator
        :       public IInputIterator<TValue>,
                public IOutputIterator<TValue>
        {       // interface for a forward iterator, generic
        };

//
// GENERIC INTERFACE CLASS IBidirectionalIterator
//
generic<typename TValue>
        public interface class IBidirectionalIterator
        :       public IForwardIterator<TValue>
        {       // interface for a bidirectional iterator, generic
        void prev();
        };

//
// GENERIC INTERFACE CLASS IRandomAccessIterator
//
generic<typename TValue>
        public interface class IRandomAccessIterator
        :       public IBidirectionalIterator<TValue>
        {       // interface for a random-access iterator, generic
        typedef IRandomAccessIterator<TValue> _Mytype_t;
        typedef int difference_type;

        difference_type move(difference_type _Offset);
        difference_type distance(IRandomAccessIterator<TValue>^ _Right);
        bool less_than(IRandomAccessIterator<TValue>^ _Right);
        };

//
// GENERIC ITERATOR CLASSES
//

//
// GENERIC REF CLASS ReverseBidirectionalIterator
//
generic<typename TValue>
        public ref class ReverseBidirectionalIterator
        :       public Generic::IBidirectionalIterator<TValue>
        {       // mutable reverse bidirectional iterator, generic
public:
        // types
        typedef ReverseBidirectionalIterator<TValue> _Mytype_t;
        typedef Generic::IBidirectionalIterator<TValue> _Myiter_t;

        typedef TValue value_type;
        typedef int difference_type;
        typedef value_type% pointer;
        typedef value_type% reference;
        typedef value_type% const_reference;

        // basics
        ReverseBidirectionalIterator()
                :       _Myiter(nullptr)
                {       // construct default
                }

        ReverseBidirectionalIterator(ReverseBidirectionalIterator% _Right)
                :       _Myiter((_Myiter_t^)_Right._Myiter->Clone())
                {       // construct by copying an iterator
                }

        ReverseBidirectionalIterator% operator=(
                ReverseBidirectionalIterator% _Right)
                {       // assign an iterator
                if ((Object^)this != %_Right)
                        _Myiter = (_Myiter_t^)_Right._Myiter->Clone();
                return (*this);
                }

        operator _Myiter_t^()
                {       // convert to interface
                return (this);
                }

        // constructors and special member functions
        ReverseBidirectionalIterator(_Myiter_t^ _Iter)
                :       _Myiter((_Myiter_t^)_Iter->Clone())
                {       // construct from wrapped iterator
                }

        _Myiter_t^ base()
                {       // get underlying base iterator
                return (_Myiter);
                }

        // member functions
        virtual System::Object^ Clone()
                {       // return a copy
                return (gcnew ReverseBidirectionalIterator(
                        (_Myiter_t^)_Myiter->Clone()));
                }

        virtual int get_bias()
                {       // get offset from wrapped iterator
                return (0);
                }

        virtual System::Object^ get_node()
                {       // get node from wrapped iterator
                return (_Myiter->get_node());
                }

        virtual bool valid()
                {       // test if wrapped iterator valid
                return (_Myiter->valid());
                }

        virtual System::Object^ container()
                {       // return container for wrapped iterator
                return (_Myiter->container());
                }

        virtual void next()
                {       // decrement wrapped iterator
                _Myiter->prev();
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1011")]
        virtual bool equal_to(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() == _Right->get_bias()
                        && get_node() == _Right->get_node());
                }

        bool equal_to(ReverseBidirectionalIterator% _Right)
                {       // test if wrapped iterators are equal, class specific
                return (_Myiter->equal_to(_Right._Myiter));
                }

        virtual const_reference get_cref()
                {       // return const reference from wrapped iterator
                _Myiter->prev();
                const_reference _Ref = _Myiter->get_cref();
                _Myiter->next();
                return (_Ref);
                }

        virtual reference get_ref()
                {       // return reference from wrapped iterator
                _Myiter->prev();
                reference _Ref = _Myiter->get_ref();
                _Myiter->next();
                return (_Ref);
                }

        virtual void prev()
                {       // increment wrapped iterator
                _Myiter->next();
                }

//      difference_type move(difference_type _Offset);
//      difference_type distance(
//              Generic::IRandomAccessIterator<TValue>^ _Right);
//      difference_type distance(ReverseBidirectionalIterator^ _Right);
//      bool less_than(Generic::IRandomAccessIterator<TValue>^ _Right);
//      bool less_than(ReverseBidirectionalIterator^ _Right);

        // operators
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static reference operator->(ReverseBidirectionalIterator% _Left)
                {       // return pointer to class object
                return (_Left.get_ref());
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static reference operator*(ReverseBidirectionalIterator% _Left)
                {       // return reference to designated element
                return (_Left.get_ref());
                }

        ReverseBidirectionalIterator operator++()
                {       // return incremented
                next();
                return (*this);
                }

        ReverseBidirectionalIterator operator++(int)
                {       // return incremented
                ReverseBidirectionalIterator _Iter = *this;

                ++*this;
                return (_Iter);
                }

        bool operator==(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator==(_Mytype_t% _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator!=(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        bool operator!=(_Mytype_t% _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        ReverseBidirectionalIterator operator--()
                {       // return decremented
                prev();
                return (*this);
                }

        ReverseBidirectionalIterator operator--(int)
                {       // return decremented
                ReverseBidirectionalIterator _Iter = *this;

                --*this;
                return (_Iter);
                }

//      ReverseBidirectionalIterator^ operator+(difference_type _Right);
//      static ReverseBidirectionalIterator^
//              operator+(difference_type _Left, ReverseBidirectionalIterator _Right);
//      ReverseBidirectionalIterator^ operator-(difference_type _Right);
//      difference_type operator-(ReverseBidirectionalIterator^ _Right);
//      bool operator<(ReverseBidirectionalIterator^ _Right);
//      bool operator>=(ReverseBidirectionalIterator^ _Right);
//      bool operator>(ReverseBidirectionalIterator^ _Right);
//      bool operator<=(ReverseBidirectionalIterator^ _Right);

_STLCLR_FIELD_ACCESS:
        _Myiter_t^ _Myiter;     // wrapped iterator
        };

//
// GENERIC REF CLASS ConstReverseBidirectionalIterator
//
generic<typename TValue>
        public ref class ConstReverseBidirectionalIterator
        :       public Generic::IBidirectionalIterator<TValue>
        {       // nonmutable reverse bidirectional iterator, generic
public:
        // types
        typedef ConstReverseBidirectionalIterator<TValue> _Mytype_t;
        typedef Generic::IBidirectionalIterator<TValue> _Myiter_t;

        typedef TValue value_type;
        typedef int difference_type;
        typedef value_type% pointer;
        typedef value_type% reference;
        typedef value_type% const_reference;

        // basics
        ConstReverseBidirectionalIterator()
                :       _Myiter(nullptr)
                {       // construct default
                }

        ConstReverseBidirectionalIterator(
                ConstReverseBidirectionalIterator% _Right)
                :       _Myiter((_Myiter_t^)_Right._Myiter->Clone())
                {       // construct by copying an iterator
                }

        ConstReverseBidirectionalIterator% operator=(
                ConstReverseBidirectionalIterator% _Right)
                {       // assign an iterator
                if ((Object^)this != %_Right)
                        _Myiter = (_Myiter_t^)_Right._Myiter->Clone();
                return (*this);
                }

        operator _Myiter_t^()
                {       // convert to interface
                return (this);
                }

        // constructors and special member functions
        ConstReverseBidirectionalIterator(_Myiter_t^ _Iter)
                :       _Myiter((_Myiter_t^)_Iter->Clone())
                {       // construct from wrapped iterator
                }

        ConstReverseBidirectionalIterator(
                ReverseBidirectionalIterator<TValue>% _Iter)
                :       _Myiter((_Myiter_t^)_Iter.base()->Clone())
                {       // construct from mutable iterator
                }

        ConstReverseBidirectionalIterator%
                operator=(ReverseBidirectionalIterator<TValue>% _Right)
                {       // assign from mutable iterator
                _Myiter = (_Myiter_t^)_Right.base()->Clone();
                return (*this);
                }

        _Myiter_t^ base()
                {       // get underlying base iterator
                return (_Myiter);
                }

        // member functions
        virtual System::Object^ Clone()
                {       // return a copy
                return (gcnew ConstReverseBidirectionalIterator(
                        (_Myiter_t^)_Myiter->Clone()));
                }

        virtual int get_bias()
                {       // get offset from wrapped iterator
                return (0);
                }

        virtual System::Object^ get_node()
                {       // get node from wrapped iterator
                return (_Myiter->get_node());
                }

        virtual bool valid()
                {       // test if wrapped iterator valid
                return (_Myiter->valid());
                }

        virtual System::Object^ container()
                {       // return container for wrapped iterator
                return (_Myiter->container());
                }

        virtual void next()
                {       // decrement wrapped iterator
                _Myiter->prev();
                }

        virtual bool equal_to(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() == _Right->get_bias()
                        && get_node() == _Right->get_node());
                }

        bool equal_to(ConstReverseBidirectionalIterator% _Right)
                {       // test if wrapped iterators are equal, class specific
                return (_Myiter->equal_to(_Right._Myiter));
                }

        virtual const_reference get_cref()
                {       // return const reference from wrapped iterator
                _Myiter->prev();
                const_reference _Ref = _Myiter->get_cref();
                _Myiter->next();
                return (_Ref);
                }

        virtual reference get_ref()
                {       // return reference from wrapped iterator
#pragma warning(push)
#pragma warning(disable: 4715)
                throw gcnew System::InvalidOperationException();
#pragma warning(pop)
                }

        virtual void prev()
                {       // increment wrapped iterator
                _Myiter->next();
                }

//      difference_type move(difference_type _Offset);
//      difference_type distance(
//              Generic::IRandomAccessIterator<TValue>^ _Right);
//      difference_type distance(ConstReverseBidirectionalIterator^ _Right);
//      bool less_than(Generic::IRandomAccessIterator<TValue>^ _Right);
//      bool less_than(ConstReverseBidirectionalIterator^ _Right);

        // operators
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static const_reference operator->(
                ConstReverseBidirectionalIterator% _Left)
                {       // return pointer to class object
                return (_Left.get_cref());
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static const_reference operator*(
                ConstReverseBidirectionalIterator% _Left)
                {       // return const reference to designated element
                return (_Left.get_cref());
                }

        ConstReverseBidirectionalIterator operator++()
                {       // return incremented
                next();
                return (*this);
                }

        ConstReverseBidirectionalIterator operator++(int)
                {       // return incremented
                ConstReverseBidirectionalIterator _Iter = *this;

                ++*this;
                return (_Iter);
                }

        bool operator==(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator==(_Mytype_t% _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator!=(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        bool operator!=(_Mytype_t% _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        ConstReverseBidirectionalIterator operator--()
                {       // return decremented
                prev();
                return (*this);
                }

        ConstReverseBidirectionalIterator operator--(int)
                {       // return decremented
                ConstReverseBidirectionalIterator _Iter = *this;

                --*this;
                return (_Iter);
                }

//      ConstReverseBidirectionalIterator^ operator+(difference_type _Right);
//      static ConstReverseBidirectionalIterator^
//              operator+(difference_type _Left,
//                      ConstReverseBidirectionalIterator _Right);
//      ConstReverseBidirectionalIterator^ operator-(difference_type _Right);
//      difference_type operator-(ConstReverseBidirectionalIterator^ _Right);
//      bool operator<(ConstReverseBidirectionalIterator^ _Right);
//      bool operator>=(ConstReverseBidirectionalIterator^ _Right);
//      bool operator>(ConstReverseBidirectionalIterator^ _Right);
//      bool operator<=(ConstReverseBidirectionalIterator^ _Right);

_STLCLR_FIELD_ACCESS:
        _Myiter_t^ _Myiter;     // wrapped iterator
        };

//
// GENERIC REF CLASS ReverseRandomAccessIterator
//
generic<typename TValue>
        public ref class ReverseRandomAccessIterator
        :       public Generic::IRandomAccessIterator<TValue>
        {       // mutable reverse random_access iterator, generic
public:
        // types
        typedef ReverseRandomAccessIterator<TValue> _Mytype_t;
        typedef Generic::IRandomAccessIterator<TValue> _Myiter_t;

        typedef TValue value_type;
        typedef int difference_type;
        typedef value_type% pointer;
        typedef value_type% reference;
        typedef value_type% const_reference;

        // basics
        ReverseRandomAccessIterator()
                :       _Myiter(nullptr)
                {       // construct default
                }

        ReverseRandomAccessIterator(ReverseRandomAccessIterator% _Right)
                :       _Myiter((_Myiter_t^)_Right._Myiter->Clone())
                {       // construct by copying an iterator
                }

        ReverseRandomAccessIterator% operator=(
                ReverseRandomAccessIterator% _Right)
                {       // assign an iterator
                if ((Object^)this != %_Right)
                        _Myiter = (_Myiter_t^)_Right._Myiter->Clone();
                return (*this);
                }

        operator _Myiter_t^()
                {       // convert to interface
                return (this);
                }

        // constructors and special member functions
        ReverseRandomAccessIterator(_Myiter_t^ _Iter)
                :       _Myiter((_Myiter_t^)_Iter->Clone())
                {       // construct from wrapped iterator
                }

        _Myiter_t^ base()
                {       // get underlying base iterator
                return (_Myiter);
                }

        // member functions
        virtual System::Object^ Clone()
                {       // return a copy
                return (gcnew ReverseRandomAccessIterator(
                        (_Myiter_t^)_Myiter->Clone()));
                }

        virtual int get_bias()
                {       // get offset from wrapped iterator
                return (_Myiter->get_bias());
                }

        virtual System::Object^ get_node()
                {       // get node from wrapped iterator
                return (nullptr);
                }

        virtual bool valid()
                {       // test if wrapped iterator valid
                return (_Myiter->valid());
                }

        virtual System::Object^ container()
                {       // return container for wrapped iterator
                return (_Myiter->container());
                }

        virtual void next()
                {       // decrement wrapped iterator
                _Myiter->prev();
                }

        virtual bool equal_to(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() == _Right->get_bias()
                        && get_node() == _Right->get_node());
                }

        bool equal_to(ReverseRandomAccessIterator% _Right)
                {       // test if wrapped iterators are equal, class specific
                return (_Myiter->equal_to(_Right._Myiter));
                }

        virtual const_reference get_cref()
                {       // return const reference from wrapped iterator
                _Myiter->prev();
                const_reference _Ref = _Myiter->get_cref();
                _Myiter->next();
                return (_Ref);
                }

        virtual reference get_ref()
                {       // return reference from wrapped iterator
                _Myiter->prev();
                reference _Ref = _Myiter->get_ref();
                _Myiter->next();
                return (_Ref);
                }

        virtual void prev()
                {       // increment wrapped iterator
                _Myiter->next();
                }

        virtual difference_type move(difference_type _Offset)
                {       // incremented by integer
                return (_Myiter->move(-_Offset));       // can overflow
                }

        virtual difference_type distance(
                Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // return difference of two iterators
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (_Right->get_bias() - get_bias());
                }

        difference_type distance(ReverseRandomAccessIterator% _Right)
                {       // return difference of two iterators, class specific
                return (_Myiter->distance(_Right._Myiter));
                }

        virtual bool less_than(Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // test if *this < _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (!(get_bias() < _Right->get_bias()));
                }

        bool less_than(ReverseRandomAccessIterator% _Right)
                {       // test if *this < _Right, class specific
                return (!_Myiter->less_than(_Right));
                }

        // operators
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static reference operator->(ReverseRandomAccessIterator% _Left)
                {       // return pointer to class object
                return (_Left.get_ref());
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static reference operator*(ReverseRandomAccessIterator% _Left)
                {       // return reference to designated element
                return (_Left.get_ref());
                }

        ReverseRandomAccessIterator operator++()
                {       // return incremented
                next();
                return (*this);
                }

        ReverseRandomAccessIterator operator++(int)
                {       // return incremented
                ReverseRandomAccessIterator _Iter = *this;

                ++*this;
                return (_Iter);
                }

//      bool operator==(Generic::IInputIterator<TValue>^ _Right);

        bool operator==(_Mytype_t% _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

//      bool operator!=(Generic::IInputIterator<TValue>^ _Right);

        bool operator!=(_Mytype_t% _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        ReverseRandomAccessIterator operator--()
                {       // return decremented
                prev();
                return (*this);
                }

        ReverseRandomAccessIterator operator--(int)
                {       // return decremented
                ReverseRandomAccessIterator _Iter = *this;

                --*this;
                return (_Iter);
                }

        ReverseRandomAccessIterator operator+(difference_type _Right)
                {       // return incremented by integer
                ReverseRandomAccessIterator _Iter = *this;

                _Iter.move(_Right);
                return (_Iter);
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static ReverseRandomAccessIterator operator+(difference_type _Left,
                ReverseRandomAccessIterator% _Right)
                {       // return incremented by integer
                ReverseRandomAccessIterator _Iter = _Right;

                _Iter.move(_Left);
                return (_Iter);
                }

        ReverseRandomAccessIterator operator-(difference_type _Right)
                {       // return decremented by integer
                ReverseRandomAccessIterator _Iter = *this;

                _Iter.move(-_Right);    // can overflow
                return (_Iter);
                }

        difference_type operator-(
                Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // return difference of two iterators
                return (distance(_Right));
                }

//      bool operator<(Generic::IRandomAccessIterator<TValue>^ _Right);

        bool operator<(_Mytype_t% _Right)
                {       // test if *this < _Right
                return (less_than(_Right));
                }

//      bool operator>=(Generic::IRandomAccessIterator<TValue>^ _Right);

        bool operator>=(_Mytype_t% _Right)
                {       // test if *this >= _Right
                return (!(*this < _Right));
                }

//      bool operator>(Generic::IRandomAccessIterator<TValue>^ _Right);

        bool operator>(_Mytype_t% _Right)
                {       // test if *this > _Right
                return (_Right < *this);
                }

//      bool operator<=(Generic::IRandomAccessIterator<TValue>^ _Right);

        bool operator<=(_Mytype_t% _Right)
                {       // test if *this <= _Right
                return (!(_Right < *this));
                }

        property value_type default[difference_type]
                {       // get or set subscripted element
                value_type get(difference_type _Pos)
                        {       // get _Pos element
                        ReverseRandomAccessIterator _Where = *this + _Pos;

                        return (_Where.get_ref());
                        }

                void set(difference_type _Pos, value_type _Val)
                        {       // set _Pos element
                        ReverseRandomAccessIterator _Where = *this + _Pos;

                        _Where.get_ref() = _Val;
                        }
                };

_STLCLR_FIELD_ACCESS:
        _Myiter_t^ _Myiter;     // wrapped iterator
        };

//
// GENERIC REF CLASS ConstReverseRandomAccessIterator
//
generic<typename TValue>
        public ref class ConstReverseRandomAccessIterator
        :       public Generic::IRandomAccessIterator<TValue>
        {       // nonmutable reverse random_access iterator, generic
public:
        // types
        typedef ConstReverseRandomAccessIterator<TValue> _Mytype_t;
        typedef Generic::IRandomAccessIterator<TValue> _Myiter_t;

        typedef TValue value_type;
        typedef int difference_type;
        typedef value_type% pointer;
        typedef value_type% reference;
        typedef value_type% const_reference;

        // basics
        ConstReverseRandomAccessIterator()
                :       _Myiter(nullptr)
                {       // construct default
                }

        ConstReverseRandomAccessIterator(
                ConstReverseRandomAccessIterator% _Right)
                :       _Myiter((_Myiter_t^)_Right._Myiter->Clone())
                {       // construct by copying an iterator
                }

        ConstReverseRandomAccessIterator% operator=(
                ConstReverseRandomAccessIterator% _Right)
                {       // assign an iterator
                if ((Object^)this != %_Right)
                        _Myiter = (_Myiter_t^)_Right._Myiter->Clone();
                return (*this);
                }

        operator _Myiter_t^()
                {       // convert to interface
                return (this);
                }

        // constructors and special member functions
        ConstReverseRandomAccessIterator(_Myiter_t^ _Iter)
                :       _Myiter((_Myiter_t^)_Iter->Clone())
                {       // construct from wrapped iterator
                }

        ConstReverseRandomAccessIterator(
                ReverseRandomAccessIterator<TValue>% _Iter)
                :       _Myiter((_Myiter_t^)_Iter.base()->Clone())
                {       // construct from mutable iterator
                }

        ConstReverseRandomAccessIterator% operator=(
                ReverseRandomAccessIterator<TValue>% _Right)
                {       // assign from mutable iterator
                _Myiter = (_Myiter_t^)_Right.base()->Clone();
                return (*this);
                }

        _Myiter_t^ base()
                {       // get underlying base iterator
                return (_Myiter);
                }

        // member functions
        virtual System::Object^ Clone()
                {       // return a copy
                return (gcnew ConstReverseRandomAccessIterator(
                        (_Myiter_t^)_Myiter->Clone()));
                }

        virtual int get_bias()
                {       // get offset from wrapped iterator
                return (_Myiter->get_bias());
                }

        virtual System::Object^ get_node()
                {       // get node from wrapped iterator
                return (nullptr);
                }

        virtual bool valid()
                {       // test if wrapped iterator valid
                return (_Myiter->valid());
                }

        virtual System::Object^ container()
                {       // return container for wrapped iterator
                return (_Myiter->container());
                }

        virtual void next()
                {       // decrement wrapped iterator
                _Myiter->prev();
                }

        virtual bool equal_to(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() == _Right->get_bias()
                        && get_node() == _Right->get_node());
                }

        bool equal_to(ConstReverseRandomAccessIterator% _Right)
                {       // test if wrapped iterators are equal, class specific
                return (_Myiter->equal_to(_Right._Myiter));
                }

        virtual const_reference get_cref()
                {       // return const reference from wrapped iterator
                _Myiter->prev();
                const_reference _Ref = _Myiter->get_cref();
                _Myiter->next();
                return (_Ref);
                }

        virtual reference get_ref()
                {       // return reference from wrapped iterator
#pragma warning(push)
#pragma warning(disable: 4715)
                throw gcnew System::InvalidOperationException();
#pragma warning(pop)
                }

        virtual void prev()
                {       // increment wrapped iterator
                _Myiter->next();
                }

        virtual difference_type move(difference_type _Offset)
                {       // incremented by integer
                return (_Myiter->move(-_Offset));       // can overflow
                }

        virtual difference_type distance(
                Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // return difference of two iterators
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (_Right->get_bias() - get_bias());
                }

        difference_type distance(ConstReverseRandomAccessIterator% _Right)
                {       // return difference of two iterators, class specific
                return (_Myiter->distance(_Right._Myiter));
                }

        virtual bool less_than(Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // test if *this < _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (!(get_bias() < _Right->get_bias()));
                }

        bool less_than(ConstReverseRandomAccessIterator% _Right)
                {       // test if *this < _Right, class specific
                return (!_Myiter->less_than(_Right));
                }

        // operators
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static const_reference operator->(
                ConstReverseRandomAccessIterator% _Left)
                {       // return pointer to class object
                return (_Left.get_cref());
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static const_reference operator*(
                ConstReverseRandomAccessIterator% _Left)
                {       // return const reference to designated element
                return (_Left.get_cref());
                }

        ConstReverseRandomAccessIterator operator++()
                {       // return incremented
                next();
                return (*this);
                }

        ConstReverseRandomAccessIterator operator++(int)
                {       // return incremented
                ConstReverseRandomAccessIterator _Iter = *this;

                ++*this;
                return (_Iter);
                }

//      bool operator==(Generic::IInputIterator<TValue>^ _Right);

        bool operator==(_Mytype_t% _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

//      bool operator!=(Generic::IInputIterator<TValue>^ _Right);

        bool operator!=(_Mytype_t% _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        ConstReverseRandomAccessIterator operator--()
                {       // return decremented
                prev();
                return (*this);
                }

        ConstReverseRandomAccessIterator operator--(int)
                {       // return decremented
                ConstReverseRandomAccessIterator _Iter = *this;

                --*this;
                return (_Iter);
                }

        ConstReverseRandomAccessIterator operator+(difference_type _Right)
                {       // return incremented by integer
                ConstReverseRandomAccessIterator _Iter = *this;

                _Iter.move(_Right);
                return (_Iter);
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static ConstReverseRandomAccessIterator operator+(difference_type _Left,
                ConstReverseRandomAccessIterator% _Right)
                {       // return incremented by integer
                ConstReverseRandomAccessIterator _Iter = _Right;

                _Iter.move(_Left);
                return (_Iter);
                }

        ConstReverseRandomAccessIterator operator-(difference_type _Right)
                {       // return decremented by integer
                ConstReverseRandomAccessIterator _Iter = *this;

                _Iter.move(-_Right);    // can overflow
                return (_Iter);
                }

        difference_type operator-(
                Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // return difference of two iterators
                return (distance(_Right));
                }

//      bool operator<(Generic::IRandomAccessIterator<TValue>^ _Right);

        bool operator<(_Mytype_t% _Right)
                {       // test if *this < _Right
                return (less_than(_Right));
                }

//      bool operator>=(Generic::IRandomAccessIterator<TValue>^ _Right);

        bool operator>=(_Mytype_t% _Right)
                {       // test if *this >= _Right
                return (!(*this < _Right));
                }

//      bool operator>(Generic::IRandomAccessIterator<TValue>^ _Right);

        bool operator>(_Mytype_t% _Right)
                {       // test if *this > _Right
                return (_Right < *this);
                }

//      bool operator<=(Generic::IRandomAccessIterator<TValue>^ _Right);

        bool operator<=(_Mytype_t% _Right)
                {       // test if *this <= _Right
                return (!(_Right < *this));
                }

        property const_reference default[difference_type]
                {       // get subscripted element
                const_reference get(difference_type _Pos)
                        {       // get _Pos element
                        ConstReverseRandomAccessIterator _Where = *this + _Pos;

                        return (_Where.get_cref());
                        }
                };

_STLCLR_FIELD_ACCESS:
        _Myiter_t^ _Myiter;     // wrapped iterator
        };

//
// GENERIC REF CLASS ContainerBidirectionalIterator
//
generic<typename TValue>
        public ref class ContainerBidirectionalIterator
        :       public Generic::IBidirectionalIterator<TValue>
        {       // iterator for mutable bidirectional container
public:
        // types
        typedef ContainerBidirectionalIterator<TValue> _Mytype_t;
        typedef Generic::IBidirectionalIterator<TValue> _Myiter_t;
        typedef Generic::IBidirectionalContainer<TValue> TCont;
        typedef INode<TValue> _Mynode_it;

        typedef TValue value_type;
        typedef int difference_type;
        typedef value_type% pointer;
        typedef value_type% reference;
        typedef value_type% const_reference;

        // basics
        ContainerBidirectionalIterator()
                :       _Mynode(nullptr)
                {       // construct default
                }

        ContainerBidirectionalIterator(ContainerBidirectionalIterator% _Right)
                :       _Mynode(_Right._Mynode)
                {       // construct by copying an iterator
                }

        ContainerBidirectionalIterator% operator=(
                ContainerBidirectionalIterator% _Right)
                {       // assign an iterator
                _Mynode = _Right._Mynode;
                return (*this);
                }

        operator _Myiter_t^()
                {       // convert to interface
                return (this);
                }

        // constructors
        ContainerBidirectionalIterator(_Mynode_it^ _Node)
                :       _Mynode(_Node)
                {       // construct from node
                }

        // member functions
        virtual System::Object^ Clone()
                {       // return a copy
                return (gcnew ContainerBidirectionalIterator(_Mynode));
                }

        virtual int get_bias()
                {       // get offset from wrapped iterator
                return (0);
                }

        virtual System::Object^ get_node()
                {       // get node from wrapped iterator
                return (_Mynode);
                }

        virtual bool valid()
                {       // test if iterator valid
                return (_Mynode != nullptr && _Mynode->container() != nullptr);
                }

        virtual System::Object^ container()
                {       // return owning container
                return (_Mynode == nullptr ? nullptr : _Mynode->container());
                }

        virtual void next()
                {       // increment
                _Mynode = _Mynode->next_node();
                }

        virtual bool equal_to(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() == _Right->get_bias()
                        && get_node() == _Right->get_node());
                }

        bool equal_to(ContainerBidirectionalIterator% _Right)
                {       // test if *this == _Right, class specific
                if (container() == nullptr
                        || container() != _Right.container())
                        throw gcnew System::ArgumentException();
                return (_Mynode == _Right._Mynode);
                }

        virtual const_reference get_cref()
                {       // return const reference to designated element
                return (_Mynode->_Value);
                }

        virtual reference get_ref()
                {       // return reference to designated element
                return (_Mynode->_Value);
                }

        virtual void prev()
                {       // decrement
                _Mynode = _Mynode->prev_node();
                }

//      difference_type move(difference_type _Offset);
//      difference_type distance(
//              Generic::IRandomAccessIterator<TValue>^ _Right);
//      bool less_than(Generic::IRandomAccessIterator<TValue>^ _Right);

        // operators
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static reference operator->(ContainerBidirectionalIterator% _Left)
                {       // return pointer to class object
                return (_Left.get_ref());
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static reference operator*(ContainerBidirectionalIterator% _Left)
                {       // return reference to designated element
                return (_Left.get_ref());
                }

        ContainerBidirectionalIterator operator++()
                {       // return incremented
                next();
                return (*this);
                }

        ContainerBidirectionalIterator operator++(int)
                {       // return incremented
                ContainerBidirectionalIterator _Iter = *this;

                ++*this;
                return (_Iter);
                }

        bool operator==(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator==(_Mytype_t% _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator!=(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        bool operator!=(_Mytype_t% _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        ContainerBidirectionalIterator operator--()
                {       // return decremented
                prev();
                return (*this);
                }

        ContainerBidirectionalIterator operator--(int)
                {       // return decremented
                ContainerBidirectionalIterator _Iter = *this;

                --*this;
                return (_Iter);
                }

//      ContainerBidirectionalIterator^ operator+(difference_type _Right);
//      static ContainerBidirectionalIterator^ operator+(
//              difference_type _Left, ContainerBidirectionalIterator _Right);
//      ContainerBidirectionalIterator^ operator-(difference_type _Right);
//      difference_type operator-(ContainerBidirectionalIterator^ _Right);
//      bool operator<(ContainerBidirectionalIterator^ _Right);
//      bool operator>=(ContainerBidirectionalIterator^ _Right);
//      bool operator>(ContainerBidirectionalIterator^ _Right);
//      bool operator<=(ContainerBidirectionalIterator^ _Right);

_STLCLR_FIELD_ACCESS:
        // data members
        _Mynode_it^ _Mynode;    // node into list
        };

//
// GENERIC REF CLASS ConstContainerBidirectionalIterator
//
generic<typename TValue>
        public ref class ConstContainerBidirectionalIterator
        :       public Generic::IBidirectionalIterator<TValue>
        {       // iterator for nonmutable bidirectional container
public:
        // types
        typedef ConstContainerBidirectionalIterator<TValue> _Mytype_t;
        typedef Generic::IBidirectionalIterator<TValue> _Myiter_t;
        typedef Generic::IBidirectionalContainer<TValue> TCont;
        typedef INode<TValue> _Mynode_it;

        typedef TValue value_type;
        typedef int difference_type;
        typedef value_type% pointer;
        typedef value_type% reference;
        typedef value_type% const_reference;

        // basics
        ConstContainerBidirectionalIterator()
                :       _Mynode(nullptr)
                {       // construct default
                }

        ConstContainerBidirectionalIterator(
                ConstContainerBidirectionalIterator% _Right)
                :       _Mynode(_Right._Mynode)
                {       // construct by copying an iterator
                }

        ConstContainerBidirectionalIterator% operator=(
                ConstContainerBidirectionalIterator% _Right)
                {       // assign an iterator
                _Mynode = _Right._Mynode;
                return (*this);
                }

        operator _Myiter_t^()
                {       // convert to interface
                return (this);
                }

        // constructors and special members
        ConstContainerBidirectionalIterator(_Mynode_it^ _Node)
                :       _Mynode(_Node)
                {       // construct from node
                }

        ConstContainerBidirectionalIterator(
                Generic::ContainerBidirectionalIterator<TValue>% _Right)
                :       _Mynode((_Mynode_it^)_Right.get_node())
                {       // construct from mutable iterator
                }

        ConstContainerBidirectionalIterator% operator=(
                Generic::ContainerBidirectionalIterator<TValue>% _Right)
                {       // assign from mutable iterator
                _Mynode = (_Mynode_it^)_Right.get_node();
                return (*this);
                }

        // member functions
        virtual System::Object^ Clone()
                {       // return a copy
                return (gcnew ConstContainerBidirectionalIterator(_Mynode));
                }

        virtual int get_bias()
                {       // get offset from wrapped iterator
                return (0);
                }

        virtual System::Object^ get_node()
                {       // get node from wrapped iterator
                return (_Mynode);
                }

        virtual bool valid()
                {       // test if iterator valid
                return (container() != nullptr);
                }

        virtual System::Object^ container()
                {       // return owning container
                return (_Mynode == nullptr ? nullptr : _Mynode->container());
                }

        virtual void next()
                {       // increment
                _Mynode = _Mynode->next_node();
                }

        virtual bool equal_to(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() == _Right->get_bias()
                        && get_node() == _Right->get_node());
                }

        bool equal_to(ConstContainerBidirectionalIterator% _Right)
                {       // test if *this == _Right, class specific
                if (container() == nullptr
                        || container() != _Right.container())
                        throw gcnew System::ArgumentException();
                return (_Mynode == _Right._Mynode);
                }

        virtual const_reference get_cref()
                {       // return const reference to designated element
                return (_Mynode->_Value);
                }

        virtual reference get_ref()
                {       // return reference to designated element
#pragma warning(push)
#pragma warning(disable: 4715)
                throw gcnew System::InvalidOperationException();
#pragma warning(pop)
                }

        virtual void prev()
                {       // decrement
                _Mynode = _Mynode->prev_node();
                }

//      difference_type move(difference_type _Offset);
//      difference_type distance(
//              Generic::IRandomAccessIterator<TValue>^ _Right);
//      bool less_than(Generic::IRandomAccessIterator<TValue>^ _Right);

        // operators
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static const_reference operator->(
                ConstContainerBidirectionalIterator% _Left)
                {       // return pointer to class object
                return (_Left.get_cref());
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static const_reference operator*(
                ConstContainerBidirectionalIterator% _Left)
                {       // return const reference to designated element
                return (_Left.get_cref());
                }

        ConstContainerBidirectionalIterator operator++()
                {       // return incremented
                next();
                return (*this);
                }

        ConstContainerBidirectionalIterator operator++(int)
                {       // return incremented
                ConstContainerBidirectionalIterator _Iter = *this;

                ++*this;
                return (_Iter);
                }

        bool operator==(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator==(_Mytype_t% _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator!=(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        bool operator!=(_Mytype_t% _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        ConstContainerBidirectionalIterator operator--()
                {       // return decremented
                prev();
                return (*this);
                }

        ConstContainerBidirectionalIterator operator--(int)
                {       // return decremented
                ConstContainerBidirectionalIterator _Iter = *this;

                --*this;
                return (_Iter);
                }

//      ConstContainerBidirectionalIterator^ operator+(difference_type _Right);
//      static ConstContainerBidirectionalIterator^ operator+(
//              difference_type _Left, ConstContainerBidirectionalIterator _Right);
//      ConstContainerBidirectionalIterator^ operator-(difference_type _Right);
//      difference_type operator-(ConstContainerBidirectionalIterator^ _Right);
//      bool operator<(ConstContainerBidirectionalIterator^ _Right);
//      bool operator>=(ConstContainerBidirectionalIterator^ _Right);
//      bool operator>(ConstContainerBidirectionalIterator^ _Right);
//      bool operator<=(ConstContainerBidirectionalIterator^ _Right);

_STLCLR_FIELD_ACCESS:
        // data members
        _Mynode_it^ _Mynode;    // node into list
        };

//
// GENERIC REF CLASS ContainerRandomAccessIterator
//
generic<typename TValue>
        public ref class ContainerRandomAccessIterator
        :       public Generic::IRandomAccessIterator<TValue>
        {       // iterator for mutable random-access container
public:
        // types
        typedef ContainerRandomAccessIterator<TValue> _Mytype_t;
        typedef Generic::IRandomAccessIterator<TValue> _Myiter_t;
        typedef Generic::IRandomAccessContainer<TValue> TCont;

        typedef TValue value_type;
        typedef int difference_type;
        typedef value_type% pointer;
        typedef value_type% reference;
        typedef value_type% const_reference;

        // basics
        ContainerRandomAccessIterator()
                :       _Mycont(nullptr), _Myoffset(0)
                {       // construct default
                }

        ContainerRandomAccessIterator(ContainerRandomAccessIterator% _Right)
                :       _Mycont(_Right._Mycont), _Myoffset(_Right._Myoffset)
                {       // construct by copying an iterator
                }

        ContainerRandomAccessIterator% operator=(
                ContainerRandomAccessIterator% _Right)
                {       // assign an iterator
                _Mycont = _Right._Mycont;
                _Myoffset = _Right._Myoffset;
                return (*this);
                }

        operator _Myiter_t^()
                {       // convert to interface
                return (this);
                }

        // constructors
        ContainerRandomAccessIterator(TCont^ _Cont, int _Offset)
                :       _Mycont(_Cont), _Myoffset(_Offset)
                {       // construct from container pointer and offset
                }

        // member functions
        virtual System::Object^ Clone()
                {       // return a copy
                return (gcnew ContainerRandomAccessIterator(_Mycont, _Myoffset));
                }

        virtual int get_bias()
                {       // get offset from wrapped iterator
                return (_Myoffset);
                }

        virtual System::Object^ get_node()
                {       // get node from wrapped iterator
                return (nullptr);
                }

        virtual bool valid()
                {       // test if iterator valid
                return (container() != nullptr
                        && _Mycont->valid_bias(_Myoffset));
                }

        virtual System::Object^ container()
                {       // return owning container
                return (_Mycont);
                }

        virtual void next()
                {       // increment
                if (!_Mycont->valid_bias(_Myoffset + 1))
                        throw gcnew System::InvalidOperationException();
                ++_Myoffset;
                }

        virtual bool equal_to(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() == _Right->get_bias()
                        && get_node() == _Right->get_node());
                }

        bool equal_to(ContainerRandomAccessIterator% _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right._Mycont)
                        throw gcnew System::ArgumentException();
                return (_Myoffset == _Right._Myoffset);
                }

        virtual const_reference get_cref()
                {       // return const reference to designated element
                return (_Mycont->at_bias(_Myoffset));
                }

        virtual reference get_ref()
                {       // return reference to designated element
                return (_Mycont->at_bias(_Myoffset));
                }

        virtual void prev()
                {       // decrement
                if (!_Mycont->valid_bias(_Myoffset - 1))
                        throw gcnew System::InvalidOperationException();
                --_Myoffset;
                }

        virtual difference_type move(difference_type _Offset)
                {       // incremented by integer
                difference_type _Newoffset = _Myoffset + _Offset;       // can overflow

                if (!_Mycont->valid_bias(_Newoffset))
                        throw gcnew System::InvalidOperationException();
                _Myoffset = _Newoffset;
                return (_Myoffset);
                }

        virtual difference_type distance(
                Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // return difference of two iterators
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() - _Right->get_bias());
                }

        difference_type distance(
                _Mytype_t% _Right)
                {       // return difference of two iterators
                if (container() == nullptr
                        || container() != _Right.container())
                        throw gcnew System::ArgumentException();
                return (get_bias() - _Right.get_bias());
                }

        virtual bool less_than(Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // test if *this < _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() < _Right->get_bias());
                }

        bool less_than(_Mytype_t% _Right)
                {       // test if *this < _Right
                if (container() == nullptr
                        || container() != _Right.container())
                        throw gcnew System::ArgumentException();
                return (get_bias() < _Right.get_bias());
                }

        // operators
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static reference operator->(ContainerRandomAccessIterator% _Left)
                {       // return pointer to class object
                return (_Left.get_ref());
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static reference operator*(ContainerRandomAccessIterator% _Left)
                {       // return reference to designated element
                return (_Left.get_ref());
                }

        ContainerRandomAccessIterator operator++()
                {       // return incremented
                next();
                return (*this);
                }

        ContainerRandomAccessIterator operator++(int)
                {       // return incremented
                ContainerRandomAccessIterator _Iter = *this;

                ++*this;
                return (_Iter);
                }

        bool operator==(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator==(_Mytype_t% _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator!=(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        bool operator!=(_Mytype_t% _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        ContainerRandomAccessIterator operator--()
                {       // return decremented
                prev();
                return (*this);
                }

        ContainerRandomAccessIterator operator--(int)
                {       // return decremented
                ContainerRandomAccessIterator _Iter = *this;

                --*this;
                return (_Iter);
                }

        ContainerRandomAccessIterator operator+(difference_type _Right)
                {       // return incremented by integer
                ContainerRandomAccessIterator _Iter = *this;

                _Iter.move(_Right);
                return (_Iter);
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static ContainerRandomAccessIterator operator+(difference_type _Left,
                ContainerRandomAccessIterator% _Right)
                {       // return incremented by integer
                ContainerRandomAccessIterator _Iter = _Right;

                _Iter.move(_Left);
                return (_Iter);
                }

        ContainerRandomAccessIterator operator-(difference_type _Right)
                {       // return decremented by integer
                ContainerRandomAccessIterator _Iter = *this;

                _Iter.move(-_Right);    // can overflow
                return (_Iter);
                }

        difference_type operator-(
                Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // return difference of two iterators
                return (distance(_Right));
                }

        bool operator<(Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // test if *this < _Right
                return (less_than(_Right));
                }

        bool operator<(_Mytype_t% _Right)
                {       // test if *this < _Right
                return (less_than(_Right));
                }

        bool operator>=(Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // test if *this >= _Right
                return (!(*this < _Right));
                }

        bool operator>=(_Mytype_t% _Right)
                {       // test if *this >= _Right
                return (!(*this < _Right));
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static bool operator>(Generic::IRandomAccessIterator<TValue>^ _Left,
                _Mytype_t% _Right)
                {       // test if _Left > _Right
                return (_Right < _Left);
                }

        bool operator>(_Mytype_t%_Right)
                {       // test if *this > _Right
                return (_Right < *this);
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static bool operator<=(Generic::IRandomAccessIterator<TValue>^ _Left,
                _Mytype_t% _Right)
                {       // test if _Left <= _Right
                return (!(_Right < _Left));
                }

        bool operator<=(_Mytype_t%_Right)
                {       // test if *this <= _Right
                return (!(_Right < *this));
                }

        property value_type default[difference_type]
                {       // get or set subscripted element
                value_type get(difference_type _Pos)
                        {       // get _Pos element
                        ContainerRandomAccessIterator _Where = *this + _Pos;

                        return (*_Where);
                        }

                void set(difference_type _Pos, value_type _Val)
                        {       // set _Pos element
                        ContainerRandomAccessIterator _Where = *this + _Pos;

                        *_Where = _Val;
                        }
                };

_STLCLR_FIELD_ACCESS:
        // data members
        TCont^ _Mycont; // owning container
        difference_type _Myoffset;      // offset into container
        };

//
// GENERIC REF CLASS ConstContainerRandomAccessIterator
//
generic<typename TValue>
        public ref class ConstContainerRandomAccessIterator
        :       public Generic::IRandomAccessIterator<TValue>
        {       // iterator for nonmutable random-access container
public:
        // types
        typedef ConstContainerRandomAccessIterator<TValue> _Mytype_t;
        typedef Generic::IRandomAccessIterator<TValue> _Myiter_t;
        typedef Generic::IRandomAccessContainer<TValue> TCont;

        typedef TValue value_type;
        typedef int difference_type;
        typedef value_type% pointer;
        typedef value_type% reference;
        typedef value_type% const_reference;

        // basics
        ConstContainerRandomAccessIterator()
                :       _Mycont(nullptr), _Myoffset(0)
                {       // construct default
                }

        ConstContainerRandomAccessIterator(
                ConstContainerRandomAccessIterator% _Right)
                :       _Mycont(_Right._Mycont), _Myoffset(_Right._Myoffset)
                {       // construct by copying an iterator
                }

        ConstContainerRandomAccessIterator% operator=(
                ConstContainerRandomAccessIterator% _Right)
                {       // assign an iterator
                _Mycont = _Right._Mycont;
                _Myoffset = _Right._Myoffset;
                return (*this);
                }

        operator _Myiter_t^()
                {       // convert to interface
                return (this);
                }

        // constructors and special members
        ConstContainerRandomAccessIterator(TCont^ _Cont, int _Offset)
                :       _Mycont(_Cont), _Myoffset(_Offset)
                {       // construct from container pointer and offset
                }

        ConstContainerRandomAccessIterator(
                Generic::ContainerRandomAccessIterator<TValue>% _Right)
                :       _Mycont((TCont^)_Right.container()),
                                _Myoffset(_Right.get_bias())
                {       // construct from mutable iterator
                }

        ConstContainerRandomAccessIterator% operator=(
                Generic::ContainerRandomAccessIterator<TValue>% _Right)
                {       // assign from mutable iterator
                _Mycont = (TCont^)_Right.container();
                _Myoffset = _Right.get_bias();
                return (*this);
                }

        // member functions
        virtual System::Object^ Clone()
                {       // return a copy
                return (gcnew ConstContainerRandomAccessIterator(_Mycont, _Myoffset));
                }

        virtual int get_bias()
                {       // get offset from wrapped iterator
                return (_Myoffset);
                }

        virtual System::Object^ get_node()
                {       // get node from wrapped iterator
                return (nullptr);
                }

        virtual bool valid()
                {       // test if iterator valid
                return (container() != nullptr
                        && _Mycont->valid_bias(_Myoffset));
                }

        virtual System::Object^ container()
                {       // return owning container
                return (_Mycont);
                }

        virtual void next()
                {       // increment
                if (!_Mycont->valid_bias(_Myoffset + 1))
                        throw gcnew System::InvalidOperationException();
                ++_Myoffset;
                }

        virtual bool equal_to(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() == _Right->get_bias()
                        && get_node() == _Right->get_node());
                }

        bool equal_to(ConstContainerRandomAccessIterator% _Right)
                {       // test if *this == _Right
                if (container() == nullptr
                        || container() != _Right._Mycont)
                        throw gcnew System::ArgumentException();
                return (_Myoffset == _Right._Myoffset);
                }

        virtual const_reference get_cref()
                {       // return const reference to designated element
                return (_Mycont->at_bias(_Myoffset));
                }

        virtual reference get_ref()
                {       // return reference to designated element
#pragma warning(push)
#pragma warning(disable: 4715)
                throw gcnew System::InvalidOperationException();
#pragma warning(pop)
                }

        virtual void prev()
                {       // decrement
                if (!_Mycont->valid_bias(_Myoffset - 1))
                        throw gcnew System::InvalidOperationException();
                --_Myoffset;
                }

        virtual difference_type move(difference_type _Offset)
                {       // incremented by integer
                difference_type _Newoffset = _Myoffset + _Offset;       // can overflow

                if (!_Mycont->valid_bias(_Newoffset))
                        throw gcnew System::InvalidOperationException();
                _Myoffset = _Newoffset;
                return (_Myoffset);
                }

        virtual difference_type distance(
                Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // return difference of two iterators
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() - _Right->get_bias());
                }

        difference_type distance(
                _Mytype_t% _Right)
                {       // return difference of two iterators
                if (container() == nullptr
                        || container() != _Right.container())
                        throw gcnew System::ArgumentException();
                return (get_bias() - _Right.get_bias());
                }

        virtual bool less_than(Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // test if *this < _Right
                if (container() == nullptr
                        || container() != _Right->container())
                        throw gcnew System::ArgumentException();
                return (get_bias() < _Right->get_bias());
                }

        bool less_than(_Mytype_t% _Right)
                {       // test if *this < _Right
                if (container() == nullptr
                        || container() != _Right.container())
                        throw gcnew System::ArgumentException();
                return (get_bias() < _Right.get_bias());
                }

        // operators
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static const_reference operator->(
                ConstContainerRandomAccessIterator% _Left)
                {       // return pointer to class object
                return (_Left.get_cref());
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static const_reference operator*(
                ConstContainerRandomAccessIterator% _Left)
                {       // return const reference to designated element
                return (_Left.get_cref());
                }

        ConstContainerRandomAccessIterator operator++()
                {       // return incremented
                next();
                return (*this);
                }

        ConstContainerRandomAccessIterator operator++(int)
                {       // return incremented
                ConstContainerRandomAccessIterator _Iter = *this;

                ++*this;
                return (_Iter);
                }

        bool operator==(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator==(_Mytype_t% _Right)
                {       // test if *this == _Right
                return (equal_to(_Right));
                }

        bool operator!=(Generic::IInputIterator<TValue>^ _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        bool operator!=(_Mytype_t% _Right)
                {       // test if *this != _Right
                return (!(*this == _Right));
                }

        ConstContainerRandomAccessIterator operator--()
                {       // return decremented
                prev();
                return (*this);
                }

        ConstContainerRandomAccessIterator operator--(int)
                {       // return decremented
                ConstContainerRandomAccessIterator _Iter = *this;

                --*this;
                return (_Iter);
                }

        ConstContainerRandomAccessIterator operator+(difference_type _Right)
                {       // return incremented by integer
                ConstContainerRandomAccessIterator _Iter = *this;

                _Iter.move(_Right);
                return (_Iter);
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static ConstContainerRandomAccessIterator operator+(
                difference_type _Left, ConstContainerRandomAccessIterator _Right)
                {       // return incremented by integer
                ConstContainerRandomAccessIterator _Iter = _Right;

                _Iter.move(_Left);
                return (_Iter);
                }

        ConstContainerRandomAccessIterator operator-(difference_type _Right)
                {       // return decremented by integer
                ConstContainerRandomAccessIterator _Iter = *this;

                _Iter.move(-_Right);    // can overflow
                return (_Iter);
                }

        difference_type operator-(
                Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // return difference of two iterators
                return (distance(_Right));
                }

        bool operator<(Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // test if *this < _Right
                return (less_than(_Right));
                }

        bool operator<(_Mytype_t% _Right)
                {       // test if *this < _Right
                return (less_than(_Right));
                }

        bool operator>=(Generic::IRandomAccessIterator<TValue>^ _Right)
                {       // test if *this >= _Right
                return (!(*this < _Right));
                }

        bool operator>=(_Mytype_t% _Right)
                {       // test if *this >= _Right
                return (!(*this < _Right));
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static bool operator>(Generic::IRandomAccessIterator<TValue>^ _Left,
                _Mytype_t% _Right)
                {       // test if _Left > _Right
                return (_Right < _Left);
                }

        bool operator>(_Mytype_t%_Right)
                {       // test if *this > _Right
                return (_Right < *this);
                }

        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1000")]
        static bool operator<=(Generic::IRandomAccessIterator<TValue>^ _Left,
                _Mytype_t% _Right)
                {       // test if _Left <= _Right
                return (!(_Right < _Left));
                }

        bool operator<=(_Mytype_t%_Right)
                {       // test if *this <= _Right
                return (!(_Right < *this));
                }

        property const_reference default[difference_type]
                {       // get subscripted element
                const_reference get(difference_type _Pos)
                        {       // get _Pos element
                        ConstContainerRandomAccessIterator _Where = *this + _Pos;

                        return (*_Where);
                        }
                };

_STLCLR_FIELD_ACCESS:
        // data members
        TCont^ _Mycont; // owning container
        difference_type _Myoffset;      // offset into container
        };
        }       // namespace Generic

                // GENERICS FOR deque //
//
// GENERIC INTERFACE CLASS IDeque
//
generic<typename TValue>
        public interface class IDeque
        :       public Generic::IRandomAccessContainer<TValue>,
                        System::ICloneable,
                        System::Collections::ICollection,
                        System::Collections::IEnumerable
        {       // interface for a deque
        typedef IDeque<TValue> _Mycont_it;
        typedef System::Collections::IEnumerable _Myenum_it;

        typedef Generic::ContainerRandomAccessIterator<TValue>
                iterator;
        typedef Generic::ReverseRandomAccessIterator<TValue>
                reverse_iterator;

        typedef int size_type;
        typedef TValue value_type;
        typedef value_type% reference;

        // accessors
        reference at(size_type _Pos);
        property value_type front_item;
        property value_type back_item;
        reference front();
        reference back();

        property value_type default[size_type]
                {       // subscript
                value_type get(size_type _Pos);
                void set(size_type _Pos, value_type _Val);
                }

        // iterator generators
        iterator begin();
        iterator end();
        reverse_iterator rbegin();
        reverse_iterator rend();

        // size controllers
//      void reserve(size_type _Capacity);
//      size_type capacity();
        void resize(size_type _Newsize);
        void resize(size_type _Newsize, value_type _Val);
        size_type size();
        bool empty();

        // mutators
        void push_front(value_type _Val);
        void pop_front();
        void push_back(value_type _Val);
        void pop_back();

        void assign(size_type _Count, value_type _Val);
        void assign(Generic::IInputIterator<TValue>^ _First,
                Generic::IInputIterator<TValue>^ _Last);
        void assign(_Myenum_it^ _Right);

        iterator insert(iterator _Where, value_type _Val);
        void insert(iterator _Where,
                size_type _Count, value_type _Val);
        void insert(iterator _Where,
                Generic::IInputIterator<TValue>^ _First,
                Generic::IInputIterator<TValue>^ _Last);
        void insert(iterator _Where_iter,
                _Myenum_it^ _Right);

        iterator erase(iterator _Where);
        iterator erase(iterator _First_iter, iterator _Last_iter);
        void clear();

        void swap(_Mycont_it^);

//_STLCLR_FIELD_ACCESS:
//
        size_type begin_bias();
        size_type end_bias();
//      reference at_bias(size_type);
//      bool valid_bias(size_type);
        unsigned long get_generation();
        };

//
// GENERIC REF CLASS DequeEnumeratorBase
//
generic<typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1038")]
        public ref class DequeEnumeratorBase
        :       public System::Collections::IEnumerator
        {       // enumerator for a deque
public:
        typedef DequeEnumeratorBase<TValue> _Mytype_t;
        typedef IDeque<TValue> _Mycont_it;
        typedef int difference_type;
        typedef TValue value_type;

        DequeEnumeratorBase(_Mycont_it^ _Cont, difference_type _First)
                :       _Mycont(_Cont), _Myfirst(_First), _Is_reset(true)
                {       // construct from container and bias
                _Mygen = _Mycont->get_generation();
                }

        virtual bool MoveNext()
                {       // move to next element and test if done
                _Validate();

                if (_Is_reset)
                        {       // starting, point to front and clear flag
                        _Is_reset = false;
                        _Mybias = _Myfirst;
                        }
                else if ((unsigned int)_Mybias - _Mycont->begin_bias()
                        < (unsigned int)_Mycont->size())
                        ++_Mybias;
                return ((unsigned int)_Mybias - _Mycont->begin_bias()
                        < (unsigned int)_Mycont->size());
                }

        property System::Object^ Current
                {       // get or set next element
                virtual System::Object^ get()
                        {       // get next element
                        return (_Getval());
                        }

                virtual void set(System::Object^)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset()
                {       // restart enumerator
                _Validate();

                _Is_reset = true;
                }

_STLCLR_FIELD_ACCESS:
        value_type _Getval()
                {       // get next element
                _Validate();

                if (_Is_reset)
                        throw gcnew System::InvalidOperationException();
                return (_Mycont->at_bias(_Mybias));
                }

        void _Validate()
                {       // test if container has been modified
                if (_Mycont->get_generation() != _Mygen)
                        throw gcnew System::InvalidOperationException();
                }

        bool _Is_reset; // true when starting/reset
        difference_type _Myfirst;       // initial bias
        difference_type _Mybias;        // current bias
        _Mycont_it^ _Mycont;    // owning container
        unsigned long _Mygen;   // container generation
        };

//
// GENERIC REF CLASS DequeEnumerator
//
generic<typename TValue>
        public ref class DequeEnumerator
        :       public DequeEnumeratorBase<TValue>,
                        System::Collections::Generic::IEnumerator<TValue>
        {       // enumerator for a deque
public:
        typedef DequeEnumerator<TValue> _Mytype_t;
        typedef DequeEnumeratorBase<TValue> _Mybase_t;
        typedef int difference_type;
        typedef TValue value_type;

        DequeEnumerator(_Mycont_it^ _Cont, difference_type _First)
                :       _Mybase_t(_Cont, _First)
                {       // construct from container and bias
                }

        ~DequeEnumerator()
                {       // destroy the object
                }

        virtual bool MoveNext() override
                {       // move to next element and test if done
                return (_Mybase_t::MoveNext());
                }

        property value_type Current
                {       // get or set next element
                virtual value_type get() new
                        {       // get next element
                        return (_Mybase_t::_Getval());
                        }

                virtual void set(value_type)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset() override
                {       // restart enumerator
                _Mybase_t::Reset();
                }
        };

                // GENERICS FOR functional //
//
// GENERIC DELEGATE UnaryDelegate
//
generic<typename TArg,
        typename TResult>
        public delegate TResult UnaryDelegate(TArg);

//
// GENERIC DELEGATE BinaryDelegate
//
generic<typename TArg1,
        typename TArg2,
        typename TResult>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1005")]
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Naming", "CA1708")]
        public delegate TResult BinaryDelegate(TArg1, TArg2);

                // GENERICS FOR list //
//
// GENERIC INTERFACE CLASS IList
//
generic<typename TValue>
        public interface class IList
        :       public Generic::IBidirectionalContainer<TValue>,
                        System::ICloneable,
                        System::Collections::ICollection,
                        System::Collections::IEnumerable
        {       // interface for a list
        typedef IList<TValue> _Mycont_it;
        typedef System::Collections::IEnumerable _Myenum_it;

        typedef Generic::ContainerBidirectionalIterator<TValue>
                iterator;
        typedef Generic::ReverseBidirectionalIterator<TValue>
                reverse_iterator;

        typedef int size_type;
        typedef TValue value_type;
        typedef value_type% reference;

        typedef BinaryDelegate<value_type, value_type, bool> _Valcomp_dt;
        typedef UnaryDelegate<value_type, bool> _Valtest_dt;

        // accessors
        property value_type front_item;
        property value_type back_item;
        reference front();
        reference back();

        // iterator generators
        iterator begin();
        iterator end();
        reverse_iterator rbegin();
        reverse_iterator rend();

        // size controllers
//      void reserve(size_type _Capacity);
//      size_type capacity();
        void resize(size_type _Newsize);
        void resize(size_type _Newsize, value_type _Val);
        size_type size();
        bool empty();

        // mutators
        void push_front(value_type _Val);
        void pop_front();
        void push_back(value_type _Val);
        void pop_back();

        void assign(size_type _Count, value_type _Val);
        void assign(Generic::IInputIterator<TValue>^ _First,
                Generic::IInputIterator<TValue>^ _Last);
        void assign(_Myenum_it^ _Right);

        iterator insert(iterator _Where, value_type _Val);
        void insert(iterator _Where,
                size_type _Count, value_type _Val);
        void insert(iterator _Where,
                Generic::IInputIterator<TValue>^ _First,
                Generic::IInputIterator<TValue>^ _Last);
        void insert(iterator _Where_iter,
                _Myenum_it^ _Right);

        iterator erase(iterator _Where);
        iterator erase(iterator _First_iter, iterator _Last_iter);
        void clear();

        void swap(_Mycont_it^ _Right);

        // special functions
        void splice(iterator _Where, _Mycont_it^ _Right);
        void splice(iterator _Where, _Mycont_it^ _Right,
                iterator _First);
        void splice(iterator _Where, _Mycont_it^ _Right,
                iterator _First, iterator _Last);

        void remove(value_type _Val);
        void remove_if(_Valtest_dt^ _Pred);
        void unique(_Valcomp_dt^ _Pred);
        void merge(_Mycont_it^ _Right, _Valcomp_dt^ _Pred);
        void sort(_Valcomp_dt^ _Pred);
        void reverse();

//_STLCLR_FIELD_ACCESS:
//      unsigned long get_generation();
        };

//
// GENERIC REF CLASS ListEnumeratorBase
//
generic<typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1038")]
        public ref class ListEnumeratorBase
        :       public System::Collections::IEnumerator
        {       // enumerator for a list
public:
        typedef ListEnumeratorBase<TValue> _Mytype_t;
        typedef Generic::INode<TValue> _Mynode_it;

        typedef TValue value_type;

        ListEnumeratorBase(_Mynode_it^ _First)
                :       _Myfirst(_First), _Is_reset(true)
                {       // construct from initial list node
                _Mygen = _Myfirst->container()->get_generation();
                }

        virtual bool MoveNext()
                {       // move to next element and test if done
                _Validate();

                if (_Is_reset)
                        {       // starting, point to front and clear flag
                        _Is_reset = false;
                        _Mynode = _Myfirst;
                        }
                else if (!_Mynode->is_head())
                        _Mynode = _Mynode->next_node();
                return (!_Mynode->is_head());
                }

        property System::Object^ Current
                {       // get or set next element
                virtual System::Object^ get()
                        {       // get next element
                        return (_Getval());
                        }

                virtual void set(System::Object^)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset()
                {       // restart enumerator
                _Validate();

                _Is_reset = true;
                }

_STLCLR_FIELD_ACCESS:
        value_type _Getval()
                {       // get next element
                _Validate();

                if (_Is_reset || _Mynode->is_head())
                        throw gcnew System::InvalidOperationException();
                return (_Mynode->_Value);
                }

        void _Validate()
                {       // test if container has been modified
                if (_Myfirst->container()->get_generation() != _Mygen)
                        throw gcnew System::InvalidOperationException();
                }

        bool _Is_reset; // true when starting/reset
        _Mynode_it^ _Myfirst;   // initial node
        _Mynode_it^ _Mynode;    // current node
        unsigned long _Mygen;   // container generation
        };

//
// GENERIC REF CLASS ListEnumerator
//
generic<typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1038")]
        public ref class ListEnumerator
        :       public ListEnumeratorBase<TValue>,
                        System::Collections::Generic::IEnumerator<TValue>
        {       // enumerator for a list
public:
        typedef ListEnumerator<TValue> _Mytype_t;
        typedef ListEnumeratorBase<TValue> _Mybase_t;
        typedef Generic::INode<TValue> _Mynode_it;

        ListEnumerator(_Mynode_it^ _First)
                :       _Mybase_t(_First)
                {       // construct from initial list node
                }

        ~ListEnumerator()
                {       // destroy the object
                }

        virtual bool MoveNext() override
                {       // move to next element and test if done
                return (_Mybase_t::MoveNext());
                }

        property value_type Current
                {       // get or set next element
                virtual value_type get() new
                        {       // get next element
                        return (_Mybase_t::_Getval());
                        }

                virtual void set(value_type)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset() override
                {       // restart enumerator
                _Mybase_t::Reset();
                }
        };

                // GENERICS FOR queue //
//
// GENERIC INTERFACE CLASS IQueue
//
generic<typename TValue,
        typename TCont>
        public interface class IQueue
        :       public System::ICloneable
        {       // interface for a queue
        typedef IQueue<TValue, TCont> _Mycont_it;
        typedef cli::array<TValue> _Myarray_t;

        typedef int size_type;
        typedef TValue value_type;
        typedef value_type% reference;

        // accessors
        reference front();
        reference back();
        TCont get_container();

        // size controllers
        size_type size();
        bool empty();

        // mutators
        void push(value_type _Val);
        void pop();
        void assign(_Mycont_it^ _Right);
        };

//
// GENERIC INTERFACE CLASS IPriorityQueue
//
generic<typename TValue,
        typename TCont>
        public interface class IPriorityQueue
        :       public System::ICloneable
        {       // interface for a priority_queue
        typedef IPriorityQueue<TValue, TCont> _Mycont_it;
        typedef cli::array<TValue> _Myarray_t;

        typedef int size_type;
        typedef TValue value_type;
        typedef value_type% reference;

        typedef BinaryDelegate<TValue, TValue, bool> value_compare;

        // accessors
        property value_type top_item;
        reference top();
        TCont get_container();
        value_compare^ value_comp();

        // size controllers
        size_type size();
        bool empty();

        // mutators
        void push(value_type _Val);
        void pop();
        void assign(_Mycont_it^ _Right);
        };

                // GENERICS FOR stack //
//
// GENERIC INTERFACE CLASS IStack
//
generic<typename TValue,
        typename TCont>
        public interface class IStack
        :       public System::ICloneable
        {       // interface for a stack
        typedef IStack<TValue, TCont> _Mycont_it;
        typedef cli::array<TValue> _Myarray_t;

        typedef int size_type;
        typedef TValue value_type;
        typedef value_type% reference;

        // accessors
        property value_type top_item;
        reference top();
        TCont get_container();

        // size controllers
        size_type size();
        bool empty();

        // mutators
        void push(value_type _Val);
        void pop();
        void assign(_Mycont_it^ _Right);
        };

                // GENERICS FOR utility //
//
// GENERIC REF CLASS GenericPair
//
generic<typename TValue1,
        typename TValue2>
        public ref class GenericPair
        {       // store a pair of refs
public:
        typedef GenericPair<TValue1, TValue2> _Mytype_t;
        typedef System::Collections::Generic::KeyValuePair<TValue1, TValue2>
                _Mykvpair_t;
        typedef TValue1 first_type;
        typedef TValue2 second_type;

        // basics
        GenericPair()
                {       // default constructor
                }

        GenericPair(GenericPair% _Right)
                :       first(_Right.first), second(_Right.second)
                {       // construct by copying _Right
                }

        GenericPair(_Mykvpair_t% _Right)
                :       first(_Right.Key), second(_Right.Value)
                {       // construct by copying _Right
                }

        GenericPair% operator=(GenericPair% _Right)
                {       // assign
                first = _Right.first;
                second = _Right.second;
                return (*this);
                }

        // constructors
        GenericPair(TValue1 _Val1)
                :       first(_Val1)
                {       // construct from first value only
                }

        GenericPair(TValue1 _Val1, TValue2 _Val2)
                :       first(_Val1), second(_Val2)
                {       // construct from specified values
                }

        // mutators
        void swap(GenericPair% _Right)
                {       // exchange contents with _Right
                if ((Object^)this != %_Right)
                        {       // worth swapping, do it
                        TValue1 _Tfirst = first;
                        TValue2 _Tsecond = second;

                        first = _Right.first;
                        _Right.first = _Tfirst;

                        second = _Right.second;
                        _Right.second = _Tsecond;
                        }
                }

        // comparisons
        virtual bool Equals(System::Object^ _Right_arg) override
                {       // test for equality
                _Mytype_t^ _Right = (_Mytype_t^)_Right_arg;
                return (first->Equals(_Right->first)
                        && second->Equals(_Right->second));
                }

public:
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1051")]
        TValue1 first;  // first stored value
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1051")]
        TValue2 second; // second stored value
        };

                // GENERICS FOR vector //
//
// GENERIC INTERFACE CLASS IVector
//
generic<typename TValue>
        public interface class IVector
        :       public Generic::IRandomAccessContainer<TValue>,
                        System::ICloneable,
                        System::Collections::ICollection,
                        System::Collections::IEnumerable
        {       // interface for a vector
        typedef IVector<TValue> _Mycont_it;
        typedef System::Collections::IEnumerable _Myenum_it;

        typedef Generic::ContainerRandomAccessIterator<TValue>
                iterator;
        typedef Generic::ReverseRandomAccessIterator<TValue>
                reverse_iterator;

        typedef int size_type;
        typedef TValue value_type;
        typedef value_type% reference;

        // accessors
        reference at(size_type _Pos);
        property value_type front_item;
        property value_type back_item;
        reference front();
        reference back();

        property value_type default[size_type]
                {       // subscript
                value_type get(size_type _Pos);
                void set(size_type _Pos, value_type _Val);
                }

        // iterator generators
        iterator begin();
        iterator end();
        reverse_iterator rbegin();
        reverse_iterator rend();

        // size controllers
        void reserve(size_type _Capacity);
        size_type capacity();
        void resize(size_type _Newsize);
        void resize(size_type _Newsize, value_type _Val);
        size_type size();
        bool empty();

        // mutators
//      void push_front(value_type _Val);
//      void pop_front();
        void push_back(value_type _Val);
        void pop_back();

        void assign(size_type _Count, value_type _Val);
        void assign(Generic::IInputIterator<TValue>^ _First,
                Generic::IInputIterator<TValue>^ _Last);
        void assign(_Myenum_it^ _Right);

        iterator insert(iterator _Where, value_type _Val);
        void insert(iterator _Where,
                size_type _Count, value_type _Val);
        void insert(iterator _Where,
                Generic::IInputIterator<TValue>^ _First,
                Generic::IInputIterator<TValue>^ _Last);
        void insert(iterator _Where_iter,
                _Myenum_it^ _Right);

        iterator erase(iterator _Where);
        iterator erase(iterator _First_iter, iterator _Last_iter);
        void clear();

        void swap(_Mycont_it^);

//_STLCLR_FIELD_ACCESS:
//
//      reference at_bias(size_type);
//      bool valid_bias(size_type);
        unsigned long get_generation();
        };

//
// GENERIC REF CLASS VectorEnumeratorBase
//
generic<typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1038")]
        public ref class VectorEnumeratorBase
        :       public System::Collections::IEnumerator
        {       // enumerator for a vector
public:
        typedef VectorEnumeratorBase<TValue> _Mytype_t;
        typedef IVector<TValue> _Mycont_it;

        typedef int difference_type;
        typedef TValue value_type;

        VectorEnumeratorBase(_Mycont_it^ _Cont, difference_type _First)
                :       _Mycont(_Cont), _Myfirst(_First), _Is_reset(true)
                {       // construct from container and bias
                _Mygen = _Mycont->get_generation();
                }

        virtual bool MoveNext()
                {       // move to next element and test if done
                _Validate();

                if (_Is_reset)
                        {       // starting, point to front and clear flag
                        _Is_reset = false;
                        _Mybias = _Myfirst;
                        }
                else if (_Mybias < _Mycont->size())
                        ++_Mybias;
                return (_Mybias < _Mycont->size());
                }

        property System::Object^ Current
                {       // get or set next element
                virtual System::Object^ get()
                        {       // get next element
                        return (_Getval());
                        }

                virtual void set(System::Object^)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset()
                {       // restart enumerator
                _Validate();

                _Is_reset = true;
                }

_STLCLR_FIELD_ACCESS:
        value_type _Getval()
                {       // get next element
                _Validate();

                if (_Is_reset)
                        throw gcnew System::InvalidOperationException();
                return (_Mycont->at_bias(_Mybias));
                }

        void _Validate()
                {       // test if container has been modified
                if (_Mycont->get_generation() != _Mygen)
                        throw gcnew System::InvalidOperationException();
                }


        bool _Is_reset; // true when starting/reset
        difference_type _Myfirst;       // initial bias
        difference_type _Mybias;        // current bias
        _Mycont_it^ _Mycont;    // owning container
        unsigned long _Mygen;   // container generation
        };

//
// GENERIC REF CLASS VectorEnumerator
//
generic<typename TValue>
        public ref class VectorEnumerator
        :       public VectorEnumeratorBase<TValue>,
                        System::Collections::Generic::IEnumerator<TValue>
        {       // enumerator for a vector
public:
        typedef VectorEnumerator<TValue> _Mytype_t;
        typedef VectorEnumeratorBase<TValue> _Mybase_t;

        typedef int difference_type;
        typedef TValue value_type;

        VectorEnumerator(_Mycont_it^ _Cont, difference_type _First)
                :       _Mybase_t(_Cont, _First)
                {       // construct from container and bias
                }

        ~VectorEnumerator()
                {       // destroy the object
                }

        virtual bool MoveNext() override
                {       // move to next element and test if done
                return (_Mybase_t::MoveNext());
                }

        property value_type Current
                {       // get or set next element
                virtual value_type get() new
                        {       // get next element
                        return (_Mybase_t::_Getval());
                        }

                virtual void set(value_type)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset() override
                {       // restart enumerator
                _Mybase_t::Reset();
                }
        };

                // GENERICS FOR xhash //
//
// GENERIC INTERFACE CLASS IHash
//
generic<typename TKey,
        typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1005")]
        public interface class IHash
        :       public Generic::IBidirectionalContainer<TValue>,
                        System::ICloneable,
                        System::Collections::ICollection,
                        System::Collections::IEnumerable
        {       // interface for a hash
        typedef IHash<TKey, TValue> _Mycont_it;
        typedef Generic::INode<TValue> _Mynode_it;
        typedef System::Collections::IEnumerable _Myenum_it;

        typedef Generic::ContainerBidirectionalIterator<TValue>
                iterator;
        typedef Generic::ReverseBidirectionalIterator<TValue>
                reverse_iterator;

        typedef int size_type;
        typedef TKey key_type;
        typedef TValue value_type;
        typedef value_type% reference;

        typedef GenericPair<iterator^, bool> pair_iter_bool;
        typedef GenericPair<iterator^, iterator^> pair_iter_iter;

        typedef BinaryDelegate<TKey, TKey, bool> key_compare;
        typedef BinaryDelegate<TValue, TValue, bool> value_compare;
        typedef UnaryDelegate<key_type, int> hasher;

        // accessors
//      property value_type front_item;
//      property value_type back_item;
//      reference front();
//      reference back();

        // converters
        key_compare^ key_comp();
        value_compare^ value_comp();

        // iterator generators
        iterator begin();
        iterator end();
        reverse_iterator rbegin();
        reverse_iterator rend();

        // size controllers
//      void reserve(size_type);
//      size_type capacity();
//      void resize(size_type _Newsize);
//      void resize(size_type _Newsize, value_type _Val);
        size_type size();
        bool empty();

        // hash controllers
        hasher^ hash_delegate();
        int bucket_count();
        float load_factor();
        float max_load_factor();
        void max_load_factor(float _Newmax);
        void rehash(int _Buckets);

        // mutators
//      void push_front(value_type _Val);
//      void pop_front();
//      void push_back(value_type _Val);
//      void pop_back();

//      void assign(size_type _Count, value_type _Val);
//      void assign(Generic::IInputIterator<TValue>^ _First,
//              Generic::IInputIterator<TValue>^ _Last);
//      void assign(_Myenum_it^ _Right);

        pair_iter_bool insert(value_type _Val);
        iterator insert(iterator _Where, value_type _Val);
//      void insert(iterator _Where,
//              size_type _Count, value_type _Val);
//      void insert(iterator _Where,
//              Generic::IInputIterator<TValue>^ _First,
//              Generic::IInputIterator<TValue>^ _Last);
//      void insert(iterator _Where_iter,
//              _Myenum_it^ _Right);
        void insert(
                Generic::IInputIterator<TValue>^ _First,
                Generic::IInputIterator<TValue>^ _Last);
        void insert(_Myenum_it^ _Right);

        iterator erase(iterator _Where);
        iterator erase(iterator _First_iter, iterator _Last_iter);
        size_type erase(key_type _Keyval);
        void clear();

        void swap(_Mycont_it^ _Right);

        // searches
        iterator find(key_type _Keyval);
        size_type count(key_type _Keyval);
        iterator lower_bound(key_type _Keyval);
        iterator upper_bound(key_type _Keyval);
        pair_iter_iter equal_range(key_type _Keyval);

//_STLCLR_FIELD_ACCESS:
//
//      unsigned long get_generation();
        };

//
// GENERIC REF CLASS HashEnumeratorBase
//
generic<typename TKey,
        typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1038")]
        public ref class HashEnumeratorBase
        :       public System::Collections::IEnumerator
        {       // enumerator for a hash
public:
        typedef HashEnumeratorBase<TKey, TValue> _Mytype_t;
        typedef Generic::INode<TValue> _Mynode_it;
        typedef TValue value_type;

        HashEnumeratorBase(_Mynode_it^ _First)
                :       _Myfirst(_First), _Is_reset(true)
                {       // construct from initial hash node
                _Mygen = _Myfirst->container()->get_generation();
                }

        virtual bool MoveNext()
                {       // move to next element and test if done
                _Validate();

                if (_Is_reset)
                        {       // starting, point to front and clear flag
                        _Is_reset = false;
                        _Mynode = _Myfirst;
                        }
                else if (!_Mynode->is_head())
                        _Mynode = _Mynode->next_node();
                return (!_Mynode->is_head());
                }

        property System::Object^ Current
                {       // get or set next element
                virtual System::Object^ get()
                        {       // get next element
                        return (_Getval());
                        }

                virtual void set(System::Object^)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset()
                {       // restart enumerator
                _Validate();

                _Is_reset = true;
                }

_STLCLR_FIELD_ACCESS:
        value_type _Getval()
                {       // get next element
                _Validate();

                if (_Is_reset || _Mynode->is_head())
                        throw gcnew System::InvalidOperationException();
                return (_Mynode->_Value);
                }

        void _Validate()
                {       // test if container has been modified
                if (_Myfirst->container()->get_generation() != _Mygen)
                        throw gcnew System::InvalidOperationException();
                }

        bool _Is_reset; // true when starting/reset
        _Mynode_it^ _Myfirst;   // initial node
        _Mynode_it^ _Mynode;    // current node
        unsigned long _Mygen;   // container generation
        };

//
// GENERIC REF CLASS HashEnumerator
//
generic<typename TKey,
        typename TValue>
        public ref class HashEnumerator
        :       public HashEnumeratorBase<TKey, TValue>,
                        System::Collections::Generic::IEnumerator<TValue>
        {       // typed enumerator for a hash
public:
        typedef HashEnumerator<TKey, TValue> _Mytype_t;
        typedef HashEnumeratorBase<TKey, TValue> _Mybase_t;
        typedef Generic::INode<TValue> _Mynode_it;

        HashEnumerator(_Mynode_it^ _First)
                :       _Mybase_t(_First)
                {       // construct from initial hash node
                }

        ~HashEnumerator()
                {       // destroy the object
                }

        virtual bool MoveNext() override
                {       // move to next element and test if done
                return (_Mybase_t::MoveNext());
                }

        property value_type Current
                {       // get or set next element
                virtual value_type get() new
                        {       // get next element
                        return (_Mybase_t::_Getval());
                        }

                virtual void set(value_type)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset() override
                {       // restart enumerator
                _Mybase_t::Reset();
                }
        };

                // GENERICS FOR xtree //
//
// GENERIC INTERFACE CLASS ITree
//
generic<typename TKey,
        typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1005")]
        public interface class ITree
        :       public Generic::IBidirectionalContainer<TValue>,
                        System::ICloneable,
                        System::Collections::ICollection,
                        System::Collections::IEnumerable
        {       // interface for a tree
        typedef ITree<TKey, TValue> _Mycont_it;
        typedef System::Collections::Generic::IEnumerable<TValue> _Myenum_it;

        typedef Generic::ContainerBidirectionalIterator<TValue>
                iterator;
        typedef Generic::ReverseBidirectionalIterator<TValue>
                reverse_iterator;

        typedef int size_type;
        typedef TKey key_type;
        typedef TValue value_type;
        typedef value_type% reference;

        typedef GenericPair<iterator^, bool> pair_iter_bool;
        typedef GenericPair<iterator^, iterator^> pair_iter_iter;

        typedef BinaryDelegate<TKey, TKey, bool> key_compare;
        typedef BinaryDelegate<TValue, TValue, bool> value_compare;

        // accessors
//      property value_type front_item;
//      property value_type back_item;
//      reference front();
//      reference back();

        // converters
        key_compare^ key_comp();
        value_compare^ value_comp();

        // iterator generators
        iterator begin();
        iterator end();
        reverse_iterator rbegin();
        reverse_iterator rend();

        // size controllers
//      void reserve(size_type);
//      size_type capacity();
//      void resize(size_type _Newsize);
//      void resize(size_type _Newsize, value_type _Val);
        size_type size();
        bool empty();

        // mutators
//      void push_front(value_type _Val);
//      void pop_front();
//      void push_back(value_type _Val);
//      void pop_back();

//      void assign(size_type _Count, value_type _Val);
//      void assign(Generic::IInputIterator<TValue>^ _First,
//              Generic::IInputIterator<TValue>^ _Last);
//      void assign(_Myenum_it^ _Right);

        pair_iter_bool insert(value_type _Val);
        iterator insert(iterator _Where, value_type _Val);
//      void insert(iterator _Where,
//              size_type _Count, value_type _Val);
//      void insert(iterator _Where,
//              Generic::IInputIterator<TValue>^ _First,
//              Generic::IInputIterator<TValue>^ _Last);
//      void insert(iterator _Where_iter,
//              _Myenum_it^ _Right);
        void insert(
                Generic::IInputIterator<TValue>^ _First,
                Generic::IInputIterator<TValue>^ _Last);
        void insert(_Myenum_it^ _Right);

        iterator erase(iterator _Where);
        iterator erase(iterator _First_iter, iterator _Last_iter);
        size_type erase(key_type _Keyval);
        void clear();

        void swap(_Mycont_it^ _Right);

        // searches
        iterator find(key_type _Keyval);
        size_type count(key_type _Keyval);
        iterator lower_bound(key_type _Keyval);
        iterator upper_bound(key_type _Keyval);
        pair_iter_iter equal_range(key_type _Keyval);

//_STLCLR_FIELD_ACCESS:
//
//      unsigned long get_generation();
        };

//
// GENERIC REF CLASS TreeEnumeratorBase
//
generic<typename TKey,
        typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1038")]
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1005")]
        public ref class TreeEnumeratorBase
        :       public System::Collections::IEnumerator
        {       // enumerator for a tree
public:
        typedef TreeEnumeratorBase<TKey, TValue> _Mytype_t;
        typedef Generic::INode<TValue> _Mynode_it;
        typedef TValue value_type;

        TreeEnumeratorBase(_Mynode_it^ _First)
                :       _Myfirst(_First), _Is_reset(true)
                {       // construct from initial tree node
                _Mygen = _Myfirst->container()->get_generation();
                }

        virtual bool MoveNext()
                {       // move to next element and test if done
                _Validate();

                if (_Is_reset)
                        {       // starting, point to front and clear flag
                        _Is_reset = false;
                        _Mynode = _Myfirst;
                        }
                else if (!_Mynode->is_head())
                        _Mynode = _Mynode->next_node();
                return (!_Mynode->is_head());
                }

        property System::Object^ Current
                {       // get or set next element
                virtual System::Object^ get()
                        {       // get next element
                        return (_Getval());
                        }

                virtual void set(System::Object^)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset()
                {       // restart enumerator
                _Validate();

                _Is_reset = true;
                }

_STLCLR_FIELD_ACCESS:
        value_type _Getval()
                {       // get next element
                _Validate();

                if (_Is_reset || _Mynode->is_head())
                        throw gcnew System::InvalidOperationException();
                return (_Mynode->_Value);
                }

        void _Validate()
                {       // test if container has been modified
                if (_Myfirst->container()->get_generation() != _Mygen)
                        throw gcnew System::InvalidOperationException();
                }

        bool _Is_reset; // true when starting/reset
        _Mynode_it^ _Myfirst;   // initial node
        _Mynode_it^ _Mynode;    // current node
        unsigned long _Mygen;   // container generation
        };

//
// GENERIC REF CLASS TreeEnumerator
//
generic<typename TKey,
        typename TValue>
        [System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.Design", "CA1005")]
        public ref class TreeEnumerator
        :       public TreeEnumeratorBase<TKey, TValue>,
                        System::Collections::Generic::IEnumerator<TValue>
        {       // typed enumerator for a tree
public:
        typedef TreeEnumerator<TKey, TValue> _Mytype_t;
        typedef TreeEnumeratorBase<TKey, TValue> _Mybase_t;
        typedef Generic::INode<TValue> _Mynode_it;

        TreeEnumerator(_Mynode_it^ _First)
                :       _Mybase_t(_First)
                {       // construct from initial tree node
                }

        ~TreeEnumerator()
                {       // destroy the object
                }

        virtual bool MoveNext() override
                {       // move to next element and test if done
                return (_Mybase_t::MoveNext());
                }

        property value_type Current
                {       // get or set next element
                virtual value_type get() new
                        {       // get next element
                        return (_Mybase_t::_Getval());
                        }

                virtual void set(value_type)
                        {       // set next element
                        throw gcnew System::InvalidOperationException();
                        }
                };

        virtual void Reset() override
                {       // restart enumerator
                _Mybase_t::Reset();
                }
        };
                }       // namespace StlClr
        }       // namespace VisualC
}       // namespace Microsoft
#endif  /* _CLI_GENERICS_ */

/*
 * Copyright (c) 2004-2007 by Dinkumware, Ltd.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V5.03:0009 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\generics.cpp ===
#include "generics.h"

#using <mscorlib.dll>
#using <System.dll>

using namespace System::Reflection;
using namespace System::Security::Permissions;

[assembly: AssemblyTitle("Microsoft.VisualC.STLCLR")];
[assembly: AssemblyDescription("STLCLR cross assembly library")];
[assembly: AssemblyConfiguration("")];
[assembly: AssemblyCompany("Microsoft")];
[assembly: AssemblyProduct("STLCLR")];
[assembly: AssemblyCopyright("")];
[assembly: AssemblyTrademark("")];
[assembly: AssemblyCulture("")];
[assembly: AssemblyVersion("1.0.0.0")];
[assembly: AssemblyDelaySign(true)];
[assembly: AssemblyKeyName("")];

[assembly: PermissionSet(SecurityAction::RequestOptional,
        Name = "Nothing")];
[assembly: System::CLSCompliant(true)];
[assembly: System::Runtime::InteropServices::ComVisible(false)];

[module:
        System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.MSInternal",
        "CA904",
        Scope = "namespace",
        Target = "Microsoft.VisualC.StlClr")];
[module:
        System::Diagnostics::CodeAnalysis::SuppressMessage("Microsoft.MSInternal",
        "CA904",
        Scope = "namespace",
        Target = "Microsoft.VisualC.StlClr.Generic")];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fwrite.c ===
/***
*fwrite.c - read from a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Write to the specified stream from the user's buffer.
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <mtdll.h>
#include <io.h>
#include <string.h>
#include <file2.h>
#include <internal.h>
#include <dbgint.h>

/***
*size_t fwrite(void *buffer, size_t size, size_t count, FILE *stream) -
*       write to the specified stream from the specified buffer.
*
*Purpose:
*       Write 'count' items of size 'size' to the specified stream from
*       the specified buffer. Return when 'count' items have been written
*       or no more items can be written to the stream.
*
*Entry:
*       buffer  - pointer to user's buffer
*       size    - size of the item to write
*       count   - number of items to write
*       stream  - stream to write to
*
*Exit:
*       Returns the number of (whole) items that were written to the stream.
*       This may be less than 'count' if an error or eof occurred. In this
*       case, ferror() or feof() should be used to distinguish between the
*       two conditions.
*
*Notes:
*       fwrite will attempt to buffer the stream (side effect of the _flsbuf
*       call) if necessary.
*
*       No more than 0xFFFE bytes may be written out at a time by a call to
*       write(). Further, write() does not handle huge buffers. Therefore,
*       in large data models, the write request is broken down into chunks
*       that do not violate these considerations. Each of these chunks is
*       processed much like an fwrite() call in a small data model (by a
*       call to _nfwrite()).
*
*       This code depends on _iob[] being a near array.
*
*       MTHREAD/DLL - Handled in just two layers since it is small data
*       model. The outer layer, fwrite(), handles stream locking/unlocking
*       and calls _fwrite_nolock() to do the work. _fwrite_nolock() is the same as
*       the single-thread, small data model version of fwrite().
*
*******************************************************************************/


/* define locking/unlocking version */
size_t __cdecl fwrite (
        const void *buffer,
        size_t size,
        size_t count,
        FILE *stream
        )
{
        size_t retval;

        if(size ==0 || count == 0)
            return 0;

        // just checking for stream != NULL here
        // rest of the validation is in _fwrite_nolock()
        _VALIDATE_RETURN( (stream != NULL) ,EINVAL, 0);

        _lock_str(stream);                      /* lock stream */

        __try {
                /* do the read */
                retval = _fwrite_nolock(buffer, size, count, stream);
        }
        __finally {
                _unlock_str(stream);            /* unlock stream */
        }

        return retval;
}

/* define the normal version */
size_t __cdecl _fwrite_nolock (
        const void *buffer,
        size_t size,
        size_t num,
        FILE *stream
        )
{
        const char *data;               /* point to where data comes from next */
        size_t total;                   /* total bytes to write */
        size_t count;                   /* num bytes left to write */
        unsigned bufsize;               /* size of stream buffer */
        unsigned nbytes;                /* number of bytes to write now */
        unsigned nactuallywritten;      /* number of bytes actually written by write() call*/
        unsigned nwritten;              /* number of bytes we consider written */
        int c;                          /* a temp char */

        /* initialize local vars */
        if (size ==0 || num ==0)
            return 0;

        _VALIDATE_RETURN( (stream != NULL) ,EINVAL, 0);
        _VALIDATE_RETURN( (buffer != NULL) ,EINVAL, 0);
        _VALIDATE_RETURN(num <= (SIZE_MAX / size), EINVAL, 0);

        data = buffer;
        count = total = size * num;

        if (anybuf(stream))
                /* already has buffer, use its size */
                bufsize = stream->_bufsiz;
        else
                /* assume will get _INTERNAL_BUFSIZ buffer */
                bufsize = _INTERNAL_BUFSIZ;

        /* here is the main loop -- we go through here until we're done */
        while (count != 0) {
                /* if the buffer is big and has room, copy data to buffer */
                if (bigbuf(stream) && stream->_cnt != 0) {
                         if(stream->_cnt < 0) {
                            _ASSERTE(("Inconsistent Stream Count. Flush between consecutive read and write", stream->_cnt >= 0));
                            stream->_flag |= _IOERR;
                            return (total - count) / size;
                        }

                        /* how much do we want? */
                        nbytes = (count < (unsigned)stream->_cnt) ? (unsigned)count : stream->_cnt;
                        memcpy(stream->_ptr, data, nbytes);

                        /* update stream and amt of data written */
                        count -= nbytes;
                        stream->_cnt -= nbytes;
                        stream->_ptr += nbytes;
                        data += nbytes;
                }
                else if (count >= bufsize) {
                        /* If we have more than bufsize chars to write, write
                           data by calling write with an integral number of
                           bufsiz blocks.  If we reach here and we have a big
                           buffer, it must be full so _flush it. */

                        if (bigbuf(stream)) {
                                if (_flush(stream)) {
                                        /* error, stream flags set -- we're out
                                           of here */
                                        return (total - count) / size;
                                }
                        }

                        /* calc chars to read -- (count/bufsize) * bufsize */
                        nbytes = ( bufsize ? (unsigned)(count - count % bufsize) :
                                   (unsigned)count );

                        nactuallywritten = _write(_fileno(stream), data, nbytes);
                        if (nactuallywritten == (unsigned)EOF) {
                                /* error -- out of here */
                                stream->_flag |= _IOERR;
                                return (total - count) / size;
                        }

                        /* VSWhidbey#326224 - _write can return more bytes than we requested due unicode
                           involved conversions in text files.
                           But we do not care about how many bytes were written as long as the number is
                           at least as big as we wanted.
                        */
                        nwritten = (nactuallywritten > nbytes ? nbytes : nactuallywritten);

                        /* update count and data to reflect write */

                        count -= nwritten;
                        data += nwritten;

                        if (nactuallywritten < nbytes) {
                                /* error -- out of here */
                                stream->_flag |= _IOERR;
                                return (total - count) / size;
                        }
                }
                else {
                        /* buffer full and not enough chars to do direct write,
                           so do a _flsbuf. */
                        c = *data;  /* _flsbuf write one char, this is it */
                        if (_flsbuf(c, stream) == EOF) {
                                /* error or eof, stream flags set by _flsbuf */
                                return (total - count) / size;
                        }

                        /* _flsbuf wrote a char -- update count */
                        ++data;
                        --count;

                        /* update buffer size */
                        bufsize = stream->_bufsiz > 0 ? stream->_bufsiz : 1;
                }
        }

        /* we finished successfully, so just return num */
        return num;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\gcvt.c ===
/***
*gcvt.c - convert floating point number to character string
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Converts floating point number into character string representation.
*
*******************************************************************************/

#include <cruntime.h>
#include <fltintrn.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <locale.h>
#include <stdlib.h>
#include <mtdll.h>
#include <setlocal.h>

/***
*errno_t _gcvt_s(buffer, sizeInChars, value, ndec) - convert floating point value to char
*       string
*
*Purpose:
*       _gcvt_s converts the value to a null terminated ASCII string
*       buffer.  It attempts to produce ndigit significant digits
*       in Fortran F format if possible, ortherwise E format,
*       ready for printing.  Trailing zeros may be suppressed.
*       NOTE - to avoid the possibility of generating floating
*       point instructions in this code we fool the compiler
*       about the type of the 'value' parameter using a struct.
*       This is OK since all we do is pass it off as a
*       parameter.
*
*Entry:
*       value - double - number to be converted
*       ndec - int - number of significant digits
*       buf - char * - buffer to place result
*       sizeInChars - size_t - destination buffer size
*
*Exit:
*       Return errno_t != 0 if something went wrong (check the validation section below).
*       Result is written into buffer. If the bugger is too small, we return an error
*       (this is part of the validation section, too).
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

extern "C" errno_t __cdecl _gcvt_s (
        char *buf,
        size_t sizeInChars,
        double value,
        int ndec
        )
{
        STRFLT string;
        int    magnitude;
        _CRT_DOUBLE *pdvalue = (_CRT_DOUBLE *)&value;

        REG1 char *str;
        REG2 char *stop;
        errno_t e;
    _locale_t plocinfo = NULL;
    _LocaleUpdate _loc_update(plocinfo);

        struct _strflt strfltstruct;    /* temporary buffers */
        char   resultstring[22 /* MAX_MAN_DIGITS+1 */];


        /* validation section */
        _VALIDATE_RETURN_ERRCODE(buf != NULL, EINVAL);
        _VALIDATE_RETURN_ERRCODE(sizeInChars > 0, EINVAL);
        _RESET_STRING(buf, sizeInChars);
        _VALIDATE_RETURN_ERRCODE((size_t)ndec < sizeInChars, ERANGE);
        /* _cftoe and _cftof (used below) are more strict in validating sizeInChars */

        /* get the magnitude of the number */

        string = _fltout2( *pdvalue, &strfltstruct, resultstring, _countof(resultstring) );

        magnitude = string->decpt - 1;

        /* output the result according to the Fortran G format as outlined in
           Fortran language specification */

        if ( magnitude < -1  ||  magnitude > ndec-1 )
                /* then  Ew.d  d = ndec */
                e = _cftoe( &value, buf, sizeInChars, ndec-1, 0);
        else
                /* Fw.d  where d = ndec-string->decpt */
                e = _cftof( &value, buf, sizeInChars, ndec-string->decpt );

        if (e == 0)
        {
                /* remove the trailing zeroes before the exponent; we don't need to check for sizeInChars */
                str = buf;
                while (*str && *str != *__LCONV(_loc_update.GetLocaleT()->locinfo)->decimal_point)
                        str++;

                if (*str++)
                {
                        while (*str && *str != 'e')
                                str++;

                        stop = str--;

                        while (*str == '0')
                                str--;

                        while (*++str = *stop++)
                                ;
                }
        }
        else
        {
                errno = e;
        }

        return e;
}

/***
*char * _gcvt(value, ndec, buffer) - convert floating point value to char
*       string
*
*Purpose:
*       _gcvt converts the value to a null terminated ASCII string
*       buf.  It attempts to produce ndigit significant digits
*       in Fortran F format if possible, ortherwise E format,
*       ready for printing.  Trailing zeros may be suppressed.
*       No error checking or overflow protection is provided.
*       NOTE - to avoid the possibility of generating floating
*       point instructions in this code we fool the compiler
*       about the type of the 'value' parameter using a struct.
*       This is OK since all we do is pass it off as a
*       parameter.
*
*Entry:
*       value - double - number to be converted
*       ndec - int - number of significant digits
*       buf - char * - buffer to place result
*
*Exit:
*       result is written into buffer; it will be overwritten if it has
*       not been made big enough.
*
*Exceptions:
*       Input parameters are validated like in _gcvt_s. Returns NULL if something goes wrong,
*       and errno is set. The destination buffer size is assumed to be large enough, and
*       no error checking or overflow protection is provided.
*
*******************************************************************************/

char * __cdecl _gcvt (
        double value,
        int ndec,
        char *buf
        )
{
        errno_t e = _gcvt_s(buf, (size_t)-1, value, ndec);
        if (e != 0)
        {
                return NULL;
        }
        return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\fwscanf.c ===
/***
*fwscanf.c - read formatted data from stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines fwscanf() - reads formatted data from stream
*
*******************************************************************************/


#include <cruntime.h>
#include <stdio.h>
#include <wchar.h>
#include <dbgint.h>
#include <stdarg.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int vfwscanf(stream, format, ...) - read formatted data from stream
*
*Purpose:
*       This is a helper function to be called from fwscanf & fwscanf_s
*
*Entry:
*       WINPUTFN winputfn - fwscanf & fwscanf_s pass either _winput or
*       _winput_s which is then used to do the real work.
*       FILE *stream - stream to read data from
*       wchar_t *format - format string
*       va_list arglist - arglist of output pointers
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/

int __cdecl vfwscanf (
        WINPUTFN winputfn,
        FILE *stream,
        const wchar_t *format,
        _locale_t plocinfo,
        va_list arglist
        )
/*
 * 'F'ile (stream) 'W'char_t 'SCAN', 'F'ormatted
 */
{
        int retval;

        _VALIDATE_RETURN((stream != NULL), EINVAL, EOF);
        _VALIDATE_RETURN((format != NULL), EINVAL, EOF);

        _lock_str(stream);
        __try {

        retval = (winputfn(stream, format, plocinfo, arglist));

        }
        __finally {
            _unlock_str(stream);
        }

        return(retval);
}

/***
*int fwscanf(stream, format, ...) - read formatted data from stream
*
*Purpose:
*       Reads formatted data from stream into arguments.  _input does the real
*       work here.
*
*Entry:
*       FILE *stream - stream to read data from
*       wchar_t *format - format string
*       followed by list of pointers to storage for the data read.  The number
*       and type are controlled by the format string.
*
*Exit:
*       returns number of fields read and assigned
*
*Exceptions:
*
*******************************************************************************/
int __cdecl fwscanf (
        FILE *stream,
        const wchar_t *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return vfwscanf(_winput_l, stream, format, NULL, arglist);
}

int __cdecl _fwscanf_l (
        FILE *stream,
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return vfwscanf(_winput_l, stream, format, plocinfo, arglist);
}

/***
*int fwscanf_s(stream, format, ...)
*
*   Same as fwscanf above except that it calls _winput_s to do the real work.
*   _winput_s has a size check for array parameters.
*
*Exceptions:
*
*******************************************************************************/
int __cdecl fwscanf_s (
        FILE *stream,
        const wchar_t *format,
        ...
        )
{
        va_list arglist;
        va_start(arglist, format);
        return vfwscanf(_winput_s_l, stream, format, NULL, arglist);
}

int __cdecl _fwscanf_s_l (
        FILE *stream,
        const wchar_t *format,
        _locale_t plocinfo,
        ...
        )
{
        va_list arglist;
        va_start(arglist, plocinfo);
        return vfwscanf(_winput_s_l, stream, format, plocinfo, arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getpid.c ===
/***
*getpid.c - get current process id
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines _getpid() - get current process id
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>

/***
*int _getpid() - get current process id
*
*Purpose:
*       Returns the current process id for the calling process.
*
*Entry:
*       None.
*
*Exit:
*       Returns the current process id.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getpid (
        void
        )
{
        return GetCurrentProcessId();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getproc.c ===
/***
*getproc.c - Get the address of a procedure in a DLL.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getdllprocadd() - gets a procedure address by name or
*       ordinal
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>

#define _CRT_ENABLE_OBSOLETE_LOADLIBRARY_FUNCTIONS

#include <process.h>

/***
*int (*)() _getdllprocaddr(handle, name, ordinal) - Get the address of a
*       DLL procedure specified by name or ordinal
*
*Purpose:
*
*Entry:
*       int handle - a DLL handle from _loaddll
*       char * name - Name of the procedure, or NULL to get by ordinal
*       int ordinal - Ordinal of the procedure, or -1 to get by name
*
*
*Exit:
*       returns a pointer to the procedure if found
*       returns NULL if not found
*
*Exceptions:
*
*******************************************************************************/

int (__cdecl * __cdecl _getdllprocaddr(
        intptr_t hMod,
        char * szProcName,
        intptr_t iOrdinal))(void)
{
        typedef int (__cdecl * PFN)(void);

        if (szProcName == NULL) {
            if (iOrdinal <= 65535) {
                return ((PFN)GetProcAddress((HANDLE)hMod, (LPSTR)iOrdinal));
            }
        }
        else {
            if (iOrdinal == (intptr_t)(-1)) {
                return ((PFN)GetProcAddress((HANDLE)hMod, szProcName));
            }
        }

        return (NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\gets.c ===
/***
*gets.c - read a line from stdin
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines gets() and getws() - read a line from stdin into buffer
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <internal_securecrt.h>
#include <mtdll.h>
#include <tchar.h>
#include <limits.h>

#ifdef _UNICODE
#define _getchar_helper _getwchar_nolock
#else  /* _UNICODE */
#define _getchar_helper _getchar_nolock
#endif  /* _UNICODE */

_TCHAR * __cdecl _getts_helper (
    _TCHAR *string,
    size_t bufferSize,
    int earlyOutIfEOFIsFirstChar
)
{
    int ch = 0;
    _TCHAR *pointer = string;
    _TCHAR *retval = string;

    _VALIDATE_RETURN( (string != NULL), EINVAL, NULL);
    _VALIDATE_RETURN( (bufferSize > 0), EINVAL, NULL);

    /* The C Standard states the input buffer should remain
    unchanged if EOF is encountered immediately. Hence we
    do not blank out the input buffer here */

    _lock_str2(0, stdin);
    __try {

#ifndef _UNICODE
    _VALIDATE_STREAM_ANSI_SETRET(stdin, EINVAL, retval, NULL);
    if (retval == NULL)
    {
        goto done;
    }
#endif  /* _UNICODE */

    /* special case: check if the first char is EOF and treat it differently if the user requested so */
    ch = _getchar_helper();
    if (ch == _TEOF)
    {
        retval = NULL;
        if (earlyOutIfEOFIsFirstChar)
            goto done;
    }

    if (bufferSize == (size_t)-1)
    {
        /* insecure case: no buffer size check, no debug filling */
        while (ch != _T('\n') && ch != _TEOF)
        {
            *pointer++ = (_TCHAR)ch;
            ch = _getchar_helper();
        }
        *pointer = 0;
    }
    else
    {
        /* secure case, check buffer size; if buffer overflow, keep on reading until /n or EOF */
        size_t available = bufferSize;
        while (ch != _T('\n') && ch != _TEOF)
        {
            if (available > 0)
            {
                --available;
                *pointer++ = (_TCHAR)ch;
            }
            ch = _getchar_helper();
        }
        if (available == 0)
        {
            _RESET_STRING(string, bufferSize);
            _RETURN_BUFFER_TOO_SMALL_ERROR(string, bufferSize, NULL);
        }
        *pointer = 0;
        _FILL_STRING(string, bufferSize, bufferSize - available + 1);
    }

    /* Common return */
done: ;

    }
    __finally
    {
        _unlock_str2(0, stdin);
    }

    return retval;
}

/***
*errno_t gets_s(string, sz) - read a line from stdin
*
*Purpose:
*
*
*Entry:
*       char *string      - place to store read string.
*       size_t bufferSize - length of dest buffer
*
*Exit:
*       returns string, filled in with the line of input
*       null string if \n found immediately or if EOF found immediately
*Exceptions:
*
*******************************************************************************/

_TCHAR * __cdecl _getts_s (
    _TCHAR *string,
    size_t bufferSize
)
{
    return _getts_helper(string, bufferSize, 0 /* treat first EOF as \n */);
}

/***
*char *gets(string) - read a line from stdin
*
*Purpose:
*       Gets a string from stdin terminated by '\n' or EOF; don't include '\n';
*       append '\0'.
*
*Entry:
*       char *string - place to store read string, assumes enough room.
*
*Exit:
*       returns string, filled in with the line of input
*       null string if \n found immediately
*       NULL if EOF found immediately
*
*Exceptions:
*
*******************************************************************************/

_TCHAR * __cdecl _getts (
    _TCHAR *string
)
{
    return _getts_helper(string, (size_t)-1, 1 /* early out if EOF is first char read */);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getw.c ===
/***
*getw.c - read a binary word from a stream
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _getw() - gets a binary integer from a stream
*
*******************************************************************************/

#include <cruntime.h>
#include <stdio.h>
#include <dbgint.h>
#include <file2.h>
#include <internal.h>
#include <mtdll.h>

/***
*int _getw(stream) - read an int from a stream
*
*Purpose:
*       get n bytes (n=sizeof(int)); OR them together in proper order; high
*       byte first. check for EOF between getc's.
*       this routine should be machine independent.
*
*Entry:
*       FILE *stream - stream to read integer from
*
*Exit:
*       returns the int read from the stream
*       returns EOF if fails (but this is a legit int value, so
*       should test feof() or ferror().
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _getw (
        FILE *str
        )
{
        REG1 FILE *stream;
        REG2 int bytecount = sizeof(int);
        int word;
        char *byteptr = (char *)&word;
        int retval;

        _VALIDATE_RETURN((str != NULL), EINVAL, EOF);

        /* Init stream pointer */
        stream = str;

        _lock_str(stream);
        __try {

        while (bytecount--)
            *byteptr++ = (char)_getc_nolock(stream);
        retval = ((feof(stream) || ferror(stream)) ? EOF : word);

        }
        __finally {
            _unlock_str(stream);
        }

        return(retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getcwd.c ===
/***
*getcwd.c - get current working directory
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*       contains functions _getcwd, _getdcwd and _getcdrv for getting the
*       current working directory.  getcwd gets the c.w.d. for the default disk
*       drive, whereas _getdcwd allows one to get the c.w.d. for whatever disk
*       drive is specified. _getcdrv gets the current drive.
*
*******************************************************************************/

#include <cruntime.h>
#include <mtdll.h>
#include <msdos.h>
#include <errno.h>
#include <malloc.h>
#include <oscalls.h>
#include <stdlib.h>
#include <internal.h>
#include <direct.h>
#include <tchar.h>

#ifdef WPRFLAG
#define _tgetdcwd_nolock _wgetdcwd_nolock
#define _tgetdcwd_lk_dbg _wgetdcwd_lk_dbg
#else  /* WPRFLAG */
#define _tgetdcwd_nolock _getdcwd_nolock
#define _tgetdcwd_lk_dbg _getdcwd_lk_dbg
#endif  /* WPRFLAG */

/***
*_TSCHAR *_getcwd(pnbuf, maxlen) - get current working directory of default drive
*
*Purpose:
*       _getcwd gets the current working directory for the user,
*       placing it in the buffer pointed to by pnbuf.  It returns
*       the length of the string put in the buffer.  If the length
*       of the string exceeds the length of the buffer, maxlen,
*       then NULL is returned.  If pnbuf = NULL, maxlen is ignored.
*       An entry point "_getdcwd()" is defined with takes the above
*       parameters, plus a drive number.  "_getcwd()" is implemented
*       as a call to "_getcwd()" with the default drive (0).
*
*       If pnbuf = NULL, maxlen is ignored, and a buffer is automatically
*       allocated using malloc() -- a pointer to which is returned by
*       _getcwd().
*
*       side effects: no global data is used or affected
*
*Entry:
*       _TSCHAR *pnbuf = pointer to a buffer maintained by the user;
*       int maxlen = length of the buffer pointed to by pnbuf;
*
*Exit:
*       Returns pointer to the buffer containing the c.w.d. name
*       (same as pnbuf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tgetcwd (
        _TSCHAR *pnbuf,
        int maxlen
        )
{
    _TSCHAR *retval;

    _mlock( _ENV_LOCK );
    __try {

        retval = _tgetdcwd_nolock(0, pnbuf, maxlen);

    }
    _finally {
        _munlock( _ENV_LOCK );
    }

    return retval;
}

#ifdef _DEBUG

_TSCHAR * __cdecl _tgetcwd_dbg (
        _TSCHAR *pnbuf,
        int maxlen,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
{
    _TSCHAR *retval;

    _mlock( _ENV_LOCK );
    __try {

    retval = _tgetdcwd_lk_dbg(0, pnbuf, maxlen, nBlockUse, szFileName, nLine);

    }
    _finally {
        _munlock( _ENV_LOCK );
    }

    return retval;
}

#endif  /* _DEBUG */


/***
*_TSCHAR *_getdcwd(drive, pnbuf, maxlen) - get c.w.d. for given drive
*
*Purpose:
*       _getdcwd gets the current working directory for the user,
*       placing it in the buffer pointed to by pnbuf.  It returns
*       the length of the string put in the buffer.  If the length
*       of the string exceeds the length of the buffer, maxlen,
*       then NULL is returned.  If pnbuf = NULL, maxlen is ignored,
*       and a buffer is automatically allocated using malloc() --
*       a pointer to which is returned by _getdcwd().
*
*       side effects: no global data is used or affected
*
*Entry:
*       int drive   - number of the drive being inquired about
*                     0 = default, 1 = 'a:', 2 = 'b:', etc.
*       _TSCHAR *pnbuf - pointer to a buffer maintained by the user;
*       int maxlen  - length of the buffer pointed to by pnbuf;
*
*Exit:
*       Returns pointer to the buffer containing the c.w.d. name
*       (same as pnbuf if non-NULL; otherwise, malloc is
*       used to allocate a buffer)
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tgetdcwd (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )
{
    _TSCHAR *retval;

    _mlock( _ENV_LOCK );
    __try {

        retval = _tgetdcwd_nolock(drive, pnbuf, maxlen);

    }
    _finally {
        _munlock( _ENV_LOCK );
    }

    return retval;
}

#ifdef _DEBUG

_TSCHAR * __cdecl _tgetdcwd_dbg (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
{
    _TSCHAR *retval;

    _mlock( _ENV_LOCK );
    __try {

        retval = _tgetdcwd_lk_dbg(drive, pnbuf, maxlen, nBlockUse, szFileName, nLine);

    }
    _finally {
        _munlock( _ENV_LOCK );
    }

    return retval;
}

#endif  /* _DEBUG */

#ifdef _DEBUG

_TSCHAR * __cdecl _tgetdcwd_nolock (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )
{
    return _tgetdcwd_lk_dbg(drive, pnbuf, maxlen, _NORMAL_BLOCK, NULL, 0);
}

_TSCHAR * __cdecl _tgetdcwd_lk_dbg (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )

#else  /* _DEBUG */

_TSCHAR * __cdecl _tgetdcwd_nolock (
        int drive,
        _TSCHAR *pnbuf,
        int maxlen
        )

#endif  /* _DEBUG */
{
    _TSCHAR *p;
    _TSCHAR drvstr[4];
    int ret, count;
    _TSCHAR *pname; /* only used as argument to GetFullPathName */

    if ( drive != 0 ) {
        /*
         * Not the default drive - make sure it's valid.
         */
        if ( !_validdrive(drive) ) {
            _doserrno = ERROR_INVALID_DRIVE;
            _VALIDATE_RETURN(("Invalid Drive",0), EACCES, NULL);
        }
    } else {
        /* Get the drive index of the default drive */
        drive = _getdrive();

    }

    /* If pnbuf is NULL, we pass 0 in both the 2nd & 3rd parameter
    to find required length to allocate */

    if(pnbuf)
    {
        _VALIDATE_RETURN( (maxlen > 0), EINVAL, NULL);
        count = maxlen;
        pnbuf[0] = 0;
    }
    else
        count = 0;

    /*
     * Get the current directory string on that drive and its length
     */
    if(drive!=0)
    {
        drvstr[0] = _T('A') - 1 + drive;
        drvstr[1] = _T(':');
        drvstr[2] = _T('.');
        drvstr[3] = _T('\0');
    }
    else
    {
        drvstr[0] = _T('.');
        drvstr[1] = _T('\0');
    }

    ret = GetFullPathName( drvstr, count, pnbuf, &pname );

    if(ret == 0) {
        _dosmaperr( GetLastError() );
        return NULL;
    }

    if( pnbuf != NULL ) {
        if(ret < count) {
            /* GetFullPathName always returns a value less than that
            passed in if successful i.e. we got the required dir */
            return pnbuf;
        }

        errno = ERANGE;
        *pnbuf = 0;
        return NULL;
    }

    /* The code comes here only if pnbuf was NULL
    Allocate the required memory & call GetFullPathName again*/

    maxlen = __max(ret, maxlen) ;
#ifdef _DEBUG
    if( (p = (_TSCHAR *)_calloc_dbg( maxlen, sizeof(_TSCHAR), nBlockUse, szFileName, nLine)) == NULL) {
#else  /* _DEBUG */
    if( (p = (_TSCHAR *)calloc( maxlen, sizeof(_TSCHAR))) == NULL) {
#endif  /* _DEBUG */
        errno = ENOMEM;
        _doserrno = E_nomem;
        return NULL;
    }


    ret = GetFullPathName( drvstr, maxlen, p, &pname );

    if(ret == 0 || ret >= maxlen) {
        _dosmaperr( GetLastError() );
        return NULL;
    }

    return p;

}

#ifndef WPRFLAG

/***
*int _validdrive( unsigned drive ) -
*
*Purpose: returns non zero if drive is a valid drive number.
*
*Entry: drive = 0 => default drive, 1 => a:, 2 => b: ...
*
*Exit:  0 => drive does not exist.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _validdrive (
    unsigned drive
    )
{
        unsigned retcode;
        char drvstr[4];

        if ( drive == 0 )
            return 1;

        drvstr[0] = 'A' + drive - 1;
        drvstr[1] = ':';
        drvstr[2] = '\\';
        drvstr[3] = '\0';

        if ( ((retcode = GetDriveType( drvstr )) == DRIVE_UNKNOWN) ||
             (retcode == DRIVE_NO_ROOT_DIR) )
            return 0;

        return 1;
}

#endif  /* WPRFLAG */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getws.c ===
/***
*getws.c - read a line from stdin (wchar_t version)
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines getws() - read a line from stdin into buffer
*
*******************************************************************************/


#ifndef _UNICODE
#define _UNICODE 1
#endif  /* _UNICODE */

#ifndef UNICODE
#define UNICODE 1
#endif  /* UNICODE */

#include "gets.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getch.c ===
/***
*getch.c - contains _getch(), _getche(), _ungetch() and kbhit for Win32
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the "direct console" functions listed above.
*
*       NOTE: The real-mode DOS versions of these functions read from
*       standard input and are therefore redirected when standard input
*       is redirected. However, these versions ALWAYS read from the console,
*       even when standard input is redirected.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <conio.h>
#include <internal.h>
#include <mtdll.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgint.h>
#include <malloc.h>

typedef struct {
        unsigned char LeadChar;
        unsigned char SecondChar;
        } CharPair;

typedef struct {
        unsigned short ScanCode;
        CharPair RegChars;
        CharPair ShiftChars;
        CharPair CtrlChars;
        CharPair AltChars;
        } EnhKeyVals;

typedef struct {
        CharPair RegChars;
        CharPair ShiftChars;
        CharPair CtrlChars;
        CharPair AltChars;
        } NormKeyVals;

/*
 * Table of key values for enhanced keys
 */
const static EnhKeyVals EnhancedKeys[] = {
        { 28, {  13,   0 }, {  13,   0 }, {  10,   0 }, {   0, 166 } },
        { 53, {  47,   0 }, {  63,   0 }, {   0, 149 }, {   0, 164 } },
        { 71, { 224,  71 }, { 224,  71 }, { 224, 119 }, {   0, 151 } },
        { 72, { 224,  72 }, { 224,  72 }, { 224, 141 }, {   0, 152 } },
        { 73, { 224,  73 }, { 224,  73 }, { 224, 134 }, {   0, 153 } },
        { 75, { 224,  75 }, { 224,  75 }, { 224, 115 }, {   0, 155 } },
        { 77, { 224,  77 }, { 224,  77 }, { 224, 116 }, {   0, 157 } },
        { 79, { 224,  79 }, { 224,  79 }, { 224, 117 }, {   0, 159 } },
        { 80, { 224,  80 }, { 224,  80 }, { 224, 145 }, {   0, 160 } },
        { 81, { 224,  81 }, { 224,  81 }, { 224, 118 }, {   0, 161 } },
        { 82, { 224,  82 }, { 224,  82 }, { 224, 146 }, {   0, 162 } },
        { 83, { 224,  83 }, { 224,  83 }, { 224, 147 }, {   0, 163 } }
        };

/*
 * macro for the number of elements of in EnhancedKeys[]
 */
#define NUM_EKA_ELTS    ( sizeof( EnhancedKeys ) / sizeof( EnhKeyVals ) )

/*
 * Table of key values for normal keys. Note that the table is padded so
 * that the key scan code serves as an index into the table.
 */
const static NormKeyVals NormalKeys[] = {

        /* padding */
        { /*  0 */ {   0,   0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },

        { /*  1 */ {  27,   0 }, {  27,   0 }, {  27,   0 }, {   0,   1 } },
        { /*  2 */ {  49,   0 }, {  33,   0 }, {   0,   0 }, {   0, 120 } },
        { /*  3 */ {  50,   0 }, {  64,   0 }, {   0,   3 }, {   0, 121 } },
        { /*  4 */ {  51,   0 }, {  35,   0 }, {   0,   0 }, {   0, 122 } },
        { /*  5 */ {  52,   0 }, {  36,   0 }, {   0,   0 }, {   0, 123 } },
        { /*  6 */ {  53,   0 }, {  37,   0 }, {   0,   0 }, {   0, 124 } },
        { /*  7 */ {  54,   0 }, {  94,   0 }, {  30,   0 }, {   0, 125 } },
        { /*  8 */ {  55,   0 }, {  38,   0 }, {   0,   0 }, {   0, 126 } },
        { /*  9 */ {  56,   0 }, {  42,   0 }, {   0,   0 }, {   0, 127 } },
        { /* 10 */ {  57,   0 }, {  40,   0 }, {   0,   0 }, {   0, 128 } },
        { /* 11 */ {  48,   0 }, {  41,   0 }, {   0,   0 }, {   0, 129 } },
        { /* 12 */ {  45,   0 }, {  95,   0 }, {  31,   0 }, {   0, 130 } },
        { /* 13 */ {  61,   0 }, {  43,   0 }, {   0,   0 }, {   0, 131 } },
        { /* 14 */ {   8,   0 }, {   8,   0 }, { 127,   0 }, {   0,  14 } },
        { /* 15 */ {   9,   0 }, {   0,  15 }, {   0, 148 }, {   0,  15 } },
        { /* 16 */ { 113,   0 }, {  81,   0 }, {  17,   0 }, {   0,  16 } },
        { /* 17 */ { 119,   0 }, {  87,   0 }, {  23,   0 }, {   0,  17 } },
        { /* 18 */ { 101,   0 }, {  69,   0 }, {   5,   0 }, {   0,  18 } },
        { /* 19 */ { 114,   0 }, {  82,   0 }, {  18,   0 }, {   0,  19 } },
        { /* 20 */ { 116,   0 }, {  84,   0 }, {  20,   0 }, {   0,  20 } },
        { /* 21 */ { 121,   0 }, {  89,   0 }, {  25,   0 }, {   0,  21 } },
        { /* 22 */ { 117,   0 }, {  85,   0 }, {  21,   0 }, {   0,  22 } },
        { /* 23 */ { 105,   0 }, {  73,   0 }, {   9,   0 }, {   0,  23 } },
        { /* 24 */ { 111,   0 }, {  79,   0 }, {  15,   0 }, {   0,  24 } },
        { /* 25 */ { 112,   0 }, {  80,   0 }, {  16,   0 }, {   0,  25 } },
        { /* 26 */ {  91,   0 }, { 123,   0 }, {  27,   0 }, {   0,  26 } },
        { /* 27 */ {  93,   0 }, { 125,   0 }, {  29,   0 }, {   0,  27 } },
        { /* 28 */ {  13,   0 }, {  13,   0 }, {  10,   0 }, {   0,  28 } },

        /* padding */
        { /* 29 */ {   0,   0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },

        { /* 30 */ {  97,   0 }, {  65,   0 }, {   1,   0 }, {   0,  30 } },
        { /* 31 */ { 115,   0 }, {  83,   0 }, {  19,   0 }, {   0,  31 } },
        { /* 32 */ { 100,   0 }, {  68,   0 }, {   4,   0 }, {   0,  32 } },
        { /* 33 */ { 102,   0 }, {  70,   0 }, {   6,   0 }, {   0,  33 } },
        { /* 34 */ { 103,   0 }, {  71,   0 }, {   7,   0 }, {   0,  34 } },
        { /* 35 */ { 104,   0 }, {  72,   0 }, {   8,   0 }, {   0,  35 } },
        { /* 36 */ { 106,   0 }, {  74,   0 }, {  10,   0 }, {   0,  36 } },
        { /* 37 */ { 107,   0 }, {  75,   0 }, {  11,   0 }, {   0,  37 } },
        { /* 38 */ { 108,   0 }, {  76,   0 }, {  12,   0 }, {   0,  38 } },
        { /* 39 */ {  59,   0 }, {  58,   0 }, {   0,   0 }, {   0,  39 } },
        { /* 40 */ {  39,   0 }, {  34,   0 }, {   0,   0 }, {   0,  40 } },
        { /* 41 */ {  96,   0 }, { 126,   0 }, {   0,   0 }, {   0,  41 } },

        /* padding */
        { /* 42 */ {    0,  0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },

        { /* 43 */ {  92,   0 }, { 124,   0 }, {  28,   0 }, {   0,   0 } },
        { /* 44 */ { 122,   0 }, {  90,   0 }, {  26,   0 }, {   0,  44 } },
        { /* 45 */ { 120,   0 }, {  88,   0 }, {  24,   0 }, {   0,  45 } },
        { /* 46 */ {  99,   0 }, {  67,   0 }, {   3,   0 }, {   0,  46 } },
        { /* 47 */ { 118,   0 }, {  86,   0 }, {  22,   0 }, {   0,  47 } },
        { /* 48 */ {  98,   0 }, {  66,   0 }, {   2,   0 }, {   0,  48 } },
        { /* 49 */ { 110,   0 }, {  78,   0 }, {  14,   0 }, {   0,  49 } },
        { /* 50 */ { 109,   0 }, {  77,   0 }, {  13,   0 }, {   0,  50 } },
        { /* 51 */ {  44,   0 }, {  60,   0 }, {   0,   0 }, {   0,  51 } },
        { /* 52 */ {  46,   0 }, {  62,   0 }, {   0,   0 }, {   0,  52 } },
        { /* 53 */ {  47,   0 }, {  63,   0 }, {   0,   0 }, {   0,  53 } },

        /* padding */
        { /* 54 */ {   0,   0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },

        { /* 55 */ {  42,   0 }, {   0,   0 }, { 114,   0 }, {   0,   0 } },

        /* padding */
        { /* 56 */ {   0,   0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },

        { /* 57 */ {  32,   0 }, {  32,   0 }, {  32,   0 }, {  32,   0 } },

        /* padding */
        { /* 58 */ {   0,   0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },

        { /* 59 */ {   0,  59 }, {   0,  84 }, {   0,  94 }, {   0, 104 } },
        { /* 60 */ {   0,  60 }, {   0,  85 }, {   0,  95 }, {   0, 105 } },
        { /* 61 */ {   0,  61 }, {   0,  86 }, {   0,  96 }, {   0, 106 } },
        { /* 62 */ {   0,  62 }, {   0,  87 }, {   0,  97 }, {   0, 107 } },
        { /* 63 */ {   0,  63 }, {   0,  88 }, {   0,  98 }, {   0, 108 } },
        { /* 64 */ {   0,  64 }, {   0,  89 }, {   0,  99 }, {   0, 109 } },
        { /* 65 */ {   0,  65 }, {   0,  90 }, {   0, 100 }, {   0, 110 } },
        { /* 66 */ {   0,  66 }, {   0,  91 }, {   0, 101 }, {   0, 111 } },
        { /* 67 */ {   0,  67 }, {   0,  92 }, {   0, 102 }, {   0, 112 } },
        { /* 68 */ {   0,  68 }, {   0,  93 }, {   0, 103 }, {   0, 113 } },

        /* padding */
        { /* 69 */ {    0,  0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },
        { /* 70 */ {    0,  0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },

        { /* 71 */ {   0,  71 }, {  55,   0 }, {   0, 119 }, {   0,   0 } },
        { /* 72 */ {   0,  72 }, {  56,   0 }, {   0, 141 }, {   0,   0 } },
        { /* 73 */ {   0,  73 }, {  57,   0 }, {   0, 132 }, {   0,   0 } },
        { /* 74 */ {   0,   0 }, {  45,   0 }, {   0,   0 }, {   0,   0 } },
        { /* 75 */ {   0,  75 }, {  52,   0 }, {   0, 115 }, {   0,   0 } },
        { /* 76 */ {   0,   0 }, {  53,   0 }, {   0,   0 }, {   0,   0 } },
        { /* 77 */ {   0,  77 }, {  54,   0 }, {   0, 116 }, {   0,   0 } },
        { /* 78 */ {   0,   0 }, {  43,   0 }, {   0,   0 }, {   0,   0 } },
        { /* 79 */ {   0,  79 }, {  49,   0 }, {   0, 117 }, {   0,   0 } },
        { /* 80 */ {   0,  80 }, {  50,   0 }, {   0, 145 }, {   0,   0 } },
        { /* 81 */ {   0,  81 }, {  51,   0 }, {   0, 118 }, {   0,   0 } },
        { /* 82 */ {   0,  82 }, {  48,   0 }, {   0, 146 }, {   0,   0 } },
        { /* 83 */ {   0,  83 }, {  46,   0 }, {   0, 147 }, {   0,   0 } },

        /* padding */
        { /* 84 */ {   0,   0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },
        { /* 85 */ {   0,   0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },
        { /* 86 */ {   0,   0 }, {   0,   0 }, {   0,   0 }, {   0,   0 } },

        { /* 87 */ { 224, 133 }, { 224, 135 }, { 224, 137 }, { 224, 139 } },
        { /* 88 */ { 224, 134 }, { 224, 136 }, { 224, 138 }, { 224, 140 } }

};


/*
 * This is the one character push-back buffer used by _getch(), _getche()
 * and _ungetch().
 */
static int chbuf = EOF;


/*
 * Declaration for console handle
 */
extern intptr_t _coninpfh;

/*
 * Function that looks up the extended key code for a given event.
 */
const CharPair * __cdecl _getextendedkeycode(KEY_EVENT_RECORD *);


/***
*int _getch(), _getche() - read one char. from console (without and with echo)
*
*Purpose:
*       If the "_ungetch()" push-back buffer is not empty (empty==-1) Then
*           Mark it empty (-1) and RETURN the value that was in it
*       Read a character using ReadConsole in RAW mode
*       Return the Character Code
*       _getche(): Same as _getch() except that the character value returned
*       is echoed (via "_putch()")
*
*Entry:
*       None, reads from console.
*
*Exit:
*       If an error is returned from the API
*           Then EOF
*       Otherwise
*            next byte from console
*       Static variable "chbuf" may be altered
*
*Exceptions:
*
*******************************************************************************/


int __cdecl _getch (
        void
        )
{
        int ch;

        _mlock(_CONIO_LOCK);            /* secure the console lock */
        __TRY
            ch = _getch_nolock();               /* input the character */
        __FINALLY
            _munlock(_CONIO_LOCK);          /* release the console lock */
        __END_TRY_FINALLY

        return ch;
}

int __cdecl _getche (
        void
        )
{
        int ch;

        _mlock(_CONIO_LOCK);            /* secure the console lock */
        __TRY
            ch = _getche_nolock();              /* input and echo the character */
        __FINALLY
            _munlock(_CONIO_LOCK);          /* unlock the console */
        __END_TRY_FINALLY

        return ch;
}



int __cdecl _getch_nolock (
        void
        )
{
        INPUT_RECORD ConInpRec;
        DWORD NumRead;
        const CharPair *pCP;
        int ch = 0;                     /* single character buffer */
        DWORD oldstate;

        /*
         * check pushback buffer (chbuf) a for character
         */
        if ( chbuf != EOF ) {
            /*
             * something there, clear buffer and return the character.
             */
            ch = (unsigned char)(chbuf & 0xFF);
            chbuf = EOF;
            return ch;
        }

        /*
         * _coninpfh, the handle to the console input, is created the first
         * time that either _getch() or _cgets() or _kbhit() is called.
         */

        if ( _coninpfh == -2 )
            __initconin();

        if (_coninpfh == -1)
            return EOF;

        /*
         * Switch to raw mode (no line input, no echo input)
         */
        GetConsoleMode( (HANDLE)_coninpfh, &oldstate );
        SetConsoleMode( (HANDLE)_coninpfh, 0L );

        for ( ; ; ) {

            /*
             * Get a console input event.
             */
            if ( !ReadConsoleInput( (HANDLE)_coninpfh,
                                    &ConInpRec,
                                    1L,
                                    &NumRead )
                 || (NumRead == 0L) )
            {
                ch = EOF;
                break;
            }

            /*
             * Look for, and decipher, key events.
             */
            if ( (ConInpRec.EventType == KEY_EVENT) &&
                 ConInpRec.Event.KeyEvent.bKeyDown ) {
                /*
                 * Easy case: if uChar.AsciiChar is non-zero, just stuff it
                 * into ch and quit.
                 */

                if ( ch = (unsigned char)ConInpRec.Event.KeyEvent.uChar.AsciiChar )
                    break;

                /*
                 * Hard case: either an extended code or an event which should
                 * not be recognized. let _getextendedkeycode() do the work...
                 */
                if ( pCP = _getextendedkeycode( &(ConInpRec.Event.KeyEvent) ) ) {
                    ch = pCP->LeadChar;
                    chbuf = pCP->SecondChar;
                    break;
                }
            }
        }


        /*
         * Restore previous console mode.
         */
        SetConsoleMode( (HANDLE)_coninpfh, oldstate );

        return ch;
}


/*
 * getche is just getch followed by a putch if no error occurred
 */

int __cdecl _getche_nolock (
        void
        )
{
        int ch;                 /* character read */

        /*
         * check pushback buffer (chbuf) a for character. if found, return
         * it without echoing.
         */
        if ( chbuf != EOF ) {
            /*
             * something there, clear buffer and return the character.
             */
            ch = (unsigned char)(chbuf & 0xFF);
            chbuf = EOF;
            return ch;
        }

        ch = _getch_nolock();       /* read character */

        if (ch != EOF) {
                if (_putch_nolock(ch) != EOF) {
                        return ch;      /* if no error, return char */
                }
        }
        return EOF;                     /* get or put failed, return EOF */
}


/***
*int _kbhit() - return flag if a keystroke is already waiting to be read
*
*Purpose:
*       If the "_ungetch()" push-back buffer is not empty (empty==-1) Then
*           Return TRUE
*       Otherwise get the Keyboard Status (via DOSQUERYFHSTATE)
*
*Entry:
*       None, tests console.
*
*Exit:
*            returns 0 if no key waiting
*                = !0 if key waiting
*
*Exceptions:
*
*******************************************************************************/


int __cdecl _kbhit_nolock(void);

int __cdecl _kbhit (
        void
        )
{
        int retval;

        _mlock(_CONIO_LOCK);            /* secure the console lock */
        __TRY
            retval = _kbhit_nolock();           /* determine if a key is waiting */
        __FINALLY
            _munlock(_CONIO_LOCK);          /* release the console lock */
        __END_TRY_FINALLY

        return retval;
}

int __cdecl _kbhit_nolock (

        void
        )
{
        DWORD NumPending;
        DWORD NumPeeked;
        int ret = FALSE;
        PINPUT_RECORD pIRBuf=NULL;

        /*
         * if a character has been pushed back, return TRUE
         */
        if ( chbuf != -1 )
            return TRUE;

        /*
         * _coninpfh, the handle to the console input, is created the first
         * time that either _getch() or _cgets() or _kbhit() is called.
         */

        if ( _coninpfh == -2 )
            __initconin();

        /*
         * Peek all pending console events
         */
        if ( (_coninpfh == -1) ||

             !GetNumberOfConsoleInputEvents((HANDLE)_coninpfh, &NumPending) ||

             (NumPending == 0))
        {
            return FALSE;
        }

        pIRBuf=(PINPUT_RECORD)_calloca(NumPending, sizeof(INPUT_RECORD));
        if ( pIRBuf == NULL )
        {
            return FALSE;
        }

        if ( PeekConsoleInput( (HANDLE)_coninpfh,
                               pIRBuf,
                               NumPending,
                               &NumPeeked ) &&

             (NumPeeked != 0L) &&

             (NumPeeked <= NumPending) )
        {

            /*
             * Scan all of the peeked events to determine if any is a key event
             * which should be recognized.
             */
            PINPUT_RECORD pIR;
            for ( pIR = pIRBuf ; NumPeeked > 0 ; NumPeeked--, pIR++ ) {

                if ( (pIR->EventType == KEY_EVENT) &&

                     (pIR->Event.KeyEvent.bKeyDown) &&

                     ( pIR->Event.KeyEvent.uChar.AsciiChar ||
                       _getextendedkeycode( &(pIR->Event.KeyEvent) ) ) )
                {
                    /*
                     * Key event corresponding to an ASCII character or an
                     * extended code. In either case, success!
                     */
                    ret = TRUE;
                }
            }
        }

        _freea( pIRBuf );

        return ret;
}


/***
*int _ungetch(c) - push back one character for "_getch()" or "_getche()"
*
*Purpose:
*       If the Push-back buffer "chbuf" is -1 Then
*           Set "chbuf" to the argument and return the argument
*       Else
*           Return EOF to indicate an error
*
*Entry:
*       int c - Character to be pushed back
*
*Exit:
*       If successful
*           returns character that was pushed back
*       Else if error
*           returns EOF
*
*Exceptions:
*
*******************************************************************************/


int __cdecl _ungetch (
        int c
        )
{
        int retval;

        _mlock(_CONIO_LOCK);            /* lock the console */
        __TRY
            retval = _ungetch_nolock(c);        /* pushback character */
        __FINALLY
            _munlock(_CONIO_LOCK);          /* unlock the console */
        __END_TRY_FINALLY

        return retval;
}
int __cdecl _ungetch_nolock (

        int c
        )
{
        /*
         * Fail if the char is EOF or the pushback buffer is non-empty
         */
        if ( (c == EOF) || (chbuf != EOF) )
            return EOF;

        chbuf = (c & 0xFF);
        return chbuf;
}




/***
* static CharPair * _getextendedkeycode(pKE) - return extended code (if any)
*       for key event.
*
*Purpose:
*       Core function for _getch (and getche) and essential to _kbhit. This
*       is the function that determines whether or not a key event NOT
*       accompanied by an ASCII character has an extended code and returns
*       that code.
*
*Entry:
*       None, tests console.
*
*Exit:
*       if successful, returns a pointer to a CharPair value holding the lead
*       and second characters of the extended code.
*
*       if unsuccesful, returns NULL
*
*Exceptions:
*
*******************************************************************************/


const CharPair * __cdecl _getextendedkeycode (
        KEY_EVENT_RECORD *pKE
        )
{
        DWORD CKS;              /* hold dwControlKeyState value */
        const CharPair *pCP;    /* pointer to CharPair containing extended
                                   code */
        int i;

        if ( (CKS = pKE->dwControlKeyState) & ENHANCED_KEY ) {

            /*
             * Find the appropriate entry in EnhancedKeys[]
             */
            for ( pCP = NULL, i = 0 ; i < NUM_EKA_ELTS ; i++ ) {

                if ( EnhancedKeys[i].ScanCode == pKE->wVirtualScanCode ) {

                    if ( CKS & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED) )

                        pCP = &(EnhancedKeys[i].AltChars);

                    else if ( CKS & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED) )

                        pCP = &(EnhancedKeys[i].CtrlChars);

                    else if ( CKS & SHIFT_PRESSED)

                        pCP = &(EnhancedKeys[i].ShiftChars);

                    else

                        pCP = &(EnhancedKeys[i].RegChars);

                    break;

                }
            }

        }

        else {

            /*
             * Regular key or a keyboard event which shouldn't be recognized.
             * Determine which by getting the proper field of the proper
             * entry in NormalKeys[], and examining the extended code.
             */
            if ( CKS & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED) )

                pCP = &(NormalKeys[pKE->wVirtualScanCode].AltChars);

            else if ( CKS & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED) )

                pCP = &(NormalKeys[pKE->wVirtualScanCode].CtrlChars);

            else if ( CKS & SHIFT_PRESSED)

                pCP = &(NormalKeys[pKE->wVirtualScanCode].ShiftChars);

            else

                pCP = &(NormalKeys[pKE->wVirtualScanCode].RegChars);

            if ( ((pCP->LeadChar != 0) && (pCP->LeadChar != 224)) ||
                 (pCP->SecondChar == 0) )
                /*
                 * Must be a keyboard event which should not be recognized
                 * (e.g., shift key was pressed)
                 */
                pCP = NULL;

        }

        return(pCP);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\glstatus.c ===
/***
*glstatus.c - sets the __globallocalestatus flag
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Sets the __globallocalestatus flag to disable per thread locale
*
*******************************************************************************/

#include <locale.h>
#include <setlocal.h>

int __globallocalestatus = (~_GLOBAL_LOCALE_BIT);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\gmtime.c ===
/***
*gmtime.c - breaks down a time value into GMT date/time info
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _gmtime32() - breaks the clock value down into GMT time/date
*       information; returns pointer to structure with the data.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <stddef.h>
#include <memory.h>
#include <internal.h>
#include <mtdll.h>
#include <malloc.h>
#include <stddef.h>
#include <dbgint.h>


/***
*errno_t _gmtime32_s(ptm, timp) - convert *timp to a structure (UTC)
*
*Purpose:
*       Converts the calendar time value, in 32 bit internal format, to
*       broken-down time (tm structure) with the corresponding UTC time.
*
*Entry:
*       const time_t *timp - pointer to time_t value to convert
*
*Exit:
*       errno_t = 0 success
*                 tm members filled-in
*       errno_t = non zero
*                 tm members initialized to -1 if ptm != NULL
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _gmtime32_s (
        struct tm *ptm,
        const __time32_t *timp
        )
{
        __time32_t caltim;/* = *timp; *//* calendar time to convert */
        int islpyr = 0;                 /* is-current-year-a-leap-year flag */
        REG1 int tmptim;
        REG3 int *mdays;                /* pointer to days or lpdays */
        struct tm *ptb = ptm;

        _VALIDATE_RETURN_ERRCODE( ( ptm != NULL ), EINVAL )
        memset( ptm, 0xff, sizeof( struct tm ) );

        _VALIDATE_RETURN_ERRCODE( ( timp != NULL ), EINVAL )

        caltim = *timp;
        _VALIDATE_RETURN_ERRCODE_NOEXC( ( caltim >=  _MIN_LOCAL_TIME ), EINVAL )

        /*
         * Determine years since 1970. First, identify the four-year interval
         * since this makes handling leap-years easy (note that 2000 IS a
         * leap year and 2100 is out-of-range).
         */
        tmptim = (int)(caltim / _FOUR_YEAR_SEC);
        caltim -= ((__time32_t)tmptim * _FOUR_YEAR_SEC);

        /*
         * Determine which year of the interval
         */
        tmptim = (tmptim * 4) + 70;         /* 1970, 1974, 1978,...,etc. */

        if ( caltim >= _YEAR_SEC ) {

            tmptim++;                       /* 1971, 1975, 1979,...,etc. */
            caltim -= _YEAR_SEC;

            if ( caltim >= _YEAR_SEC ) {

                tmptim++;                   /* 1972, 1976, 1980,...,etc. */
                caltim -= _YEAR_SEC;

                /*
                 * Note, it takes 366 days-worth of seconds to get past a leap
                 * year.
                 */
                if ( caltim >= (_YEAR_SEC + _DAY_SEC) ) {

                        tmptim++;           /* 1973, 1977, 1981,...,etc. */
                        caltim -= (_YEAR_SEC + _DAY_SEC);
                }
                else {
                        /*
                         * In a leap year after all, set the flag.
                         */
                        islpyr++;
                }
            }
        }

        /*
         * tmptim now holds the value for tm_year. caltim now holds the
         * number of elapsed seconds since the beginning of that year.
         */
        ptb->tm_year = tmptim;

        /*
         * Determine days since January 1 (0 - 365). This is the tm_yday value.
         * Leave caltim with number of elapsed seconds in that day.
         */
        ptb->tm_yday = (int)(caltim / _DAY_SEC);
        caltim -= (__time32_t)(ptb->tm_yday) * _DAY_SEC;

        /*
         * Determine months since January (0 - 11) and day of month (1 - 31)
         */
        if ( islpyr )
            mdays = _lpdays;
        else
            mdays = _days;


        for ( tmptim = 1 ; mdays[tmptim] < ptb->tm_yday ; tmptim++ ) ;

        ptb->tm_mon = --tmptim;

        ptb->tm_mday = ptb->tm_yday - mdays[tmptim];

        /*
         * Determine days since Sunday (0 - 6)
         */
        ptb->tm_wday = ((int)(*timp / _DAY_SEC) + _BASE_DOW) % 7;

        /*
         *  Determine hours since midnight (0 - 23), minutes after the hour
         *  (0 - 59), and seconds after the minute (0 - 59).
         */
        ptb->tm_hour = (int)(caltim / 3600);
        caltim -= (__time32_t)ptb->tm_hour * 3600L;

        ptb->tm_min = (int)(caltim / 60);
        ptb->tm_sec = (int)(caltim - (ptb->tm_min) * 60);

        ptb->tm_isdst = 0;
        return 0;

}


/***
*struct tm *__getgmtimebuf() - get the static/allocated buffer used by gmtime
*
*Purpose:
*       get the buffer used by gmtime
*
*Entry:
*
*Exit:
*       returns pointer to tm structure or NULL when allocation fails
*
*Exceptions:
*
*******************************************************************************/
struct tm * __cdecl __getgmtimebuf ()
{

        REG2 struct tm *ptb = NULL;            /* will point to gmtime buffer */
        _ptiddata ptd = _getptd_noexit();
        if (!ptd) {
            errno = ENOMEM;
            return (NULL);
        }

        /* Use per thread buffer area (malloc space, if necessary) */

        if ( (ptd->_gmtimebuf != NULL) || ((ptd->_gmtimebuf =
            _malloc_crt(sizeof(struct tm))) != NULL) )
                ptb = ptd->_gmtimebuf;
        else
        {
            errno = ENOMEM;
            return NULL;
        }
        return ptb;
}

/***
*struct tm *_gmtime32(timp) - convert *timp to a structure (UTC)
*
*Purpose:
*       Converts the calendar time value, in 32-bit internal format, to
*       broken-down time (tm structure) with the corresponding UTC time.
*
*Entry:
*       const __time32_t *timp - pointer to time_t value to convert
*
*Exit:
*       returns pointer to filled-in tm structure.
*       returns NULL if *timp < 0L
*
*Exceptions:
*
*******************************************************************************/

struct tm * __cdecl _gmtime32 (
        const __time32_t *timp
        )
{
        errno_t e;
        struct tm *ptm = __getgmtimebuf();                 /* will point to gmtime buffer */
        if ( ptm == NULL )
        {
            return NULL;
        }

        e = _gmtime32_s( ptm, timp );
        if ( e != 0 )
        {
            return NULL;
        }
        return ptm;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\gmtime64.c ===
/***
*gmtime64.c - breaks down a time value into GMT date/time info
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _gmtime64() - breaks the clock value down into GMT time/date
*       information; returns pointer to structure with the data.
*
*******************************************************************************/

#include <cruntime.h>
#include <time.h>
#include <ctime.h>
#include <stddef.h>
#include <memory.h>
#include <internal.h>
#include <mtdll.h>
#include <malloc.h>
#include <stddef.h>
#include <dbgint.h>


/***
*errno_t _gmtime64_s(ptm, timp) - convert *timp to a structure (UTC)
*
*Purpose:
*       Converts the calendar time value, in 64 bit internal format, to
*       broken-down time (tm structure) with the corresponding UTC time.
*
*Entry:
*       const time_t *timp - pointer to time_t value to convert
*
*Exit:
*       errno_t = 0 success
*                 tm members filled-in
*       errno_t = non zero
*                 tm members initialized to -1 if ptm != NULL
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _gmtime64_s (
        struct tm *ptm,
        const __time64_t *timp
        )
{
        __time64_t caltim;/* = *timp; *//* calendar time to convert */
        int islpyr = 0;                 /* is-current-year-a-leap-year flag */
        int tmptim;
        int *mdays;                     /* pointer to days or lpdays */
        struct tm *ptb = ptm;

        _VALIDATE_RETURN_ERRCODE( ( ptm != NULL ), EINVAL )

        memset( ptm, 0xff, sizeof( struct tm ) );

        _VALIDATE_RETURN_ERRCODE( ( timp != NULL ), EINVAL )
        caltim = *timp;

        _VALIDATE_RETURN_ERRCODE_NOEXC( ( caltim >= _MIN_LOCAL_TIME ), EINVAL )
        _VALIDATE_RETURN_ERRCODE_NOEXC( ( caltim <= _MAX__TIME64_T + _MAX_LOCAL_TIME ), EINVAL)

        /*
         * Determine the years since 1900. Start by ignoring leap years.
         */
        tmptim = (int)(caltim / _YEAR_SEC) + 70;
        caltim -= ((__time64_t)(tmptim - 70) * _YEAR_SEC);

        /*
         * Correct for elapsed leap years
         */
        caltim -= ((__time64_t)_ELAPSED_LEAP_YEARS(tmptim) * _DAY_SEC);

        /*
         * If we have underflowed the __time64_t range (i.e., if caltim < 0),
         * back up one year, adjusting the correction if necessary.
         */
        if ( caltim < 0 ) {
            caltim += (__time64_t)_YEAR_SEC;
            tmptim--;
            if ( _IS_LEAP_YEAR(tmptim) ) {
                caltim += _DAY_SEC;
                islpyr++;
            }
        }
        else
            if ( _IS_LEAP_YEAR(tmptim) )
                islpyr++;

        /*
         * tmptim now holds the value for tm_year. caltim now holds the
         * number of elapsed seconds since the beginning of that year.
         */
        ptb->tm_year = tmptim;

        /*
         * Determine days since January 1 (0 - 365). This is the tm_yday value.
         * Leave caltim with number of elapsed seconds in that day.
         */
        ptb->tm_yday = (int)(caltim / _DAY_SEC);
        caltim -= (__time64_t)(ptb->tm_yday) * _DAY_SEC;

        /*
         * Determine months since January (0 - 11) and day of month (1 - 31)
         */
        if ( islpyr )
            mdays = _lpdays;
        else
            mdays = _days;


        for ( tmptim = 1 ; mdays[tmptim] < ptb->tm_yday ; tmptim++ ) ;

        ptb->tm_mon = --tmptim;

        ptb->tm_mday = ptb->tm_yday - mdays[tmptim];

        /*
         * Determine days since Sunday (0 - 6)
         */
        ptb->tm_wday = ((int)(*timp / _DAY_SEC) + _BASE_DOW) % 7;

        /*
         *  Determine hours since midnight (0 - 23), minutes after the hour
         *  (0 - 59), and seconds after the minute (0 - 59).
         */
        ptb->tm_hour = (int)(caltim / 3600);
        caltim -= (__time64_t)ptb->tm_hour * 3600L;

        ptb->tm_min = (int)(caltim / 60);
        ptb->tm_sec = (int)(caltim - (ptb->tm_min) * 60);

        ptb->tm_isdst = 0;
        return 0;

}


/***
*struct tm *_gmtime64(timp) - convert *timp to a structure (UTC)
*
*Purpose:
*       Converts the calendar time value, in internal 64-bit format to
*       broken-down time (tm structure) with the corresponding UTC time.
*
*Entry:
*       const __time64_t *timp - pointer to time_t value to convert
*
*Exit:
*       returns pointer to filled-in tm structure.
*       returns NULL if *timp < 0
*
*Exceptions:
*
*******************************************************************************/

struct tm * __cdecl _gmtime64 (
        const __time64_t *timp
        )
{
        errno_t e;
        struct tm *ptm = __getgmtimebuf();                 /* will point to gmtime buffer */
        if ( ptm == NULL )
        {
            return NULL;
        }

        e = _gmtime64_s( ptm, timp );
        if ( e != 0 )
        {
            return NULL;
        }
        return ptm;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\gs_cookie.c ===
/***
*gs_cookie.c - defines buffer overrun security cookie
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines per-module global variable __security_cookie, which is used
*       by the /GS compile switch to detect local buffer variable overrun
*       bugs/attacks.
*
*       When compiling /GS, the compiler injects code to detect when a local
*       array variable has been overwritten, potentially overwriting the
*       return address (on machines like x86 where the return address is on
*       the stack).  A local variable is allocated directly before the return
*       address and initialized on entering the function.  When exiting the
*       function, the compiler inserts code to verify that the local variable
*       has not been modified.  If it has, then an error reporting routine
*       is called.
*
*******************************************************************************/

#include <windows.h>

/*
 * Default value used for the global /GS security cookie, defined here and
 * in gs_support.c (since standalone SDK build can't use CRT's internal.h).
 */

#ifdef _WIN64
#define DEFAULT_SECURITY_COOKIE 0x00002B992DDFA232
#else  /* _WIN64 */
#define DEFAULT_SECURITY_COOKIE 0xBB40E64E
#endif  /* _WIN64 */

/*
 * The global security cookie.  This name is known to the compiler.
 * Initialize to a garbage non-zero value just in case we have a buffer overrun
 * in any code that gets run before __security_init_cookie() has a chance to
 * initialize the cookie to the final value.
 */

DECLSPEC_SELECTANY UINT_PTR __security_cookie = DEFAULT_SECURITY_COOKIE;

DECLSPEC_SELECTANY UINT_PTR __security_cookie_complement = ~(DEFAULT_SECURITY_COOKIE);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\handler.cpp ===
/***
*handler.cpp - defines C++ setHandler routine
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines C++ setHandler routine.
*
*******************************************************************************/

#include <stddef.h>
#include <internal.h>
#include <cruntime.h>
#include <mtdll.h>
#include <process.h>
#include <new.h>
#include <dbgint.h>

/* pointer to old-style C++ new handler */
_PNH _pnhHeap;

/***
*_initp_heap_handler()
*
*Purpose:
*
*******************************************************************************/

extern "C"
void __cdecl _initp_heap_handler(void *enull)
{
        _pnhHeap = (_PNH) enull;
}


/***
*_PNH _set_new_handler(_PNH pnh) - set the new handler
*
*Purpose:
*       _set_new_handler is different from the ANSI C++ working standard definition
*       of set_new_handler.  Therefore it has a leading underscore in its name.
*
*Entry:
*       Pointer to the new handler to be installed.
*
*Return:
*       Previous new handler
*
*******************************************************************************/
_PNH __cdecl _set_new_handler(
        _PNH pnh
        )
{
        _PNH pnhOld;

        /* lock the heap */
        _mlock(_HEAP_LOCK);

        pnhOld = (_PNH) _decode_pointer(_pnhHeap);
        _pnhHeap = (_PNH) _encode_pointer(pnh);

        /* unlock the heap */
        _munlock(_HEAP_LOCK);

        return(pnhOld);
}


/***
*_PNH _set_new_handler(int) - set the new handler
*
*Purpose:
*       Overload of _set_new_handler to be used when caller
*       wants to pass NULL or 0.
*
*Entry:
*       NULL or 0.
*
*Return:
*       Previous new handler
*
*******************************************************************************/
_CRTIMP _PNH __cdecl _set_new_handler(
        int pnh
        )
{
        _ASSERTE(pnh == 0);

        return _set_new_handler(static_cast<_PNH>(NULL));
}

/***
*_PNH _query_new_handler(void) - query value of new handler
*
*Purpose:
*       Obtain current new handler value.
*
*Entry:
*       None
*
*       WARNING: This function is OBSOLETE. Use _query_new_ansi_handler instead.
*
*Return:
*       Currently installed new handler
*
*******************************************************************************/
_PNH __cdecl _query_new_handler (
        void
        )
{
        return (_PNH) _decode_pointer(_pnhHeap);
}


/***
*int _callnewh - call the appropriate new handler
*
*Purpose:
*       Call the appropriate new handler.
*
*Entry:
*       None
*
*Return:
*       1 for success
*       0 for failure
*       may throw bad_alloc
*
*******************************************************************************/
extern "C" int __cdecl _callnewh(size_t size)
{
        {
            _PNH pnh = (_PNH) _decode_pointer(_pnhHeap);

            if ( (pnh == NULL) || ((*pnh)(size) == 0) )
                return 0;
        }
        return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\gs_support.c ===
/***
*gs_support.c - initialize the global buffer overrun security cookie
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Define __security_init_cookie, which is called at startup to initialize
*       the global buffer overrun security cookie used by the /GS compile flag.
*
*******************************************************************************/

#include <windows.h>
#include <intrin.h>

#if defined (_M_IX86) && defined (_CRTBLD) && !defined (_SYSCRT) && defined (_DEBUG)
/*
 * __security_init_cookie must be called before any exception handlers using
 * the cookie are registered.  We do a spot check for this condition in the
 * debug version of the x86 CRT.
 */

#define CHECK_FOR_LATE_COOKIE_INIT

#include <cmsgs.h>  // for _RT_COOKIE_INIT_TXT

typedef
EXCEPTION_DISPOSITION
(*PEXCEPTION_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT struct _CONTEXT *ContextRecord,
    IN OUT PVOID DispatcherContext
    );

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

#define EXCEPTION_CHAIN_END ((struct _EXCEPTION_REGISTRATION_RECORD * POINTER_32)-1)

EXCEPTION_DISPOSITION __cdecl
_except_handler4(
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT struct _CONTEXT *ContextRecord,
    IN OUT PVOID DispatcherContext
    );

#endif  /* defined (_M_IX86) && defined (_CRTBLD) && !defined (_SYSCRT) && defined (_DEBUG) */

/*
 * Default value used for the global /GS security cookie, defined here and
 * in gs_cookie.c (since standalone SDK build can't use CRT's internal.h).
 */

#ifdef _WIN64
#define DEFAULT_SECURITY_COOKIE 0x00002B992DDFA232
#else  /* _WIN64 */
#define DEFAULT_SECURITY_COOKIE 0xBB40E64E
#endif  /* _WIN64 */

/*
 * The global security cookie.  This name is known to the compiler.
 */
extern UINT_PTR __security_cookie;
extern UINT_PTR __security_cookie_complement;

/*
 * Union to facilitate converting from FILETIME to unsigned __int64
 */
typedef union {
    unsigned __int64 ft_scalar;
    FILETIME ft_struct;
} FT;

/***
*__security_init_cookie(cookie) - init buffer overrun security cookie.
*
*Purpose:
*       Initialize the global buffer overrun security cookie which is used by
*       the /GS compile switch to detect overwrites to local array variables
*       the potentially corrupt the return address.  This routine is called
*       at EXE/DLL startup.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __security_init_cookie(void)
{
    UINT_PTR cookie;
    FT systime={0};
    LARGE_INTEGER perfctr;

    /*
     * Do nothing if the global cookie has already been initialized.  On x86,
     * reinitialize the cookie if it has been previously initialized to a
     * value with the high word 0x0000.  Some versions of Windows will init
     * the cookie in the loader, but using an older mechanism which forced the
     * high word to zero.
     */

    if (__security_cookie != DEFAULT_SECURITY_COOKIE
#if defined (_X86_)
        && (__security_cookie & 0xFFFF0000) != 0
#endif  /* defined (_X86_) */
       )
    {
        __security_cookie_complement = ~__security_cookie;
        return;
    }


    /*
     * Initialize the global cookie with an unpredictable value which is
     * different for each module in a process.  Combine a number of sources
     * of randomness.
     */

    GetSystemTimeAsFileTime(&systime.ft_struct);
#if defined (_WIN64)
    cookie = systime.ft_scalar;
#else  /* defined (_WIN64) */
    cookie = systime.ft_struct.dwLowDateTime;
    cookie ^= systime.ft_struct.dwHighDateTime;
#endif  /* defined (_WIN64) */

    cookie ^= GetCurrentProcessId();
    cookie ^= GetCurrentThreadId();
    cookie ^= GetTickCount();

    QueryPerformanceCounter(&perfctr);
#if defined (_WIN64)
    cookie ^= perfctr.QuadPart;
#else  /* defined (_WIN64) */
    cookie ^= perfctr.LowPart;
    cookie ^= perfctr.HighPart;
#endif  /* defined (_WIN64) */

#if defined (_WIN64)
    /*
     * On Win64, generate a cookie with the most significant word set to zero,
     * as a defense against buffer overruns involving null-terminated strings.
     * Don't do so on Win32, as it's more important to keep 32 bits of cookie.
     */
    cookie &= 0x0000FFFFffffFFFFi64;
#endif  /* defined (_WIN64) */

    /*
     * Make sure the cookie is initialized to a value that will prevent us from
     * reinitializing it if this routine is ever called twice.
     */

    if (cookie == DEFAULT_SECURITY_COOKIE)
    {
        cookie = DEFAULT_SECURITY_COOKIE + 1;
    }
#if defined (_X86_)
    else if ((cookie & 0xFFFF0000) == 0)
    {
        cookie |= cookie << 16;
    }
#endif  /* defined (_X86_) */

    __security_cookie = cookie;
    __security_cookie_complement = ~cookie;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getpath.c ===
/***
*getpath.c - extract a pathname from an environment variable
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Extract pathnames from a string of semicolon delimited pathnames
*       (generally the value of an environment variable such as PATH).
*
*******************************************************************************/

#include <cruntime.h>
#include <stddef.h>
#include <internal.h>
#include <tchar.h>

/* support HPFS file system */
#define _HPFS_ 1

/***
*_getpath() - extract a pathname from a semicolon-delimited list of pathnames
*
*Purpose:
*       To extract the next pathname from a semicolon-delimited list of
*       pathnames (usually the value on an environment variable) and copy
*       it to a caller-specified buffer. No check is done to see if the path
*       is valid. The maximum number of characters copied to the buffer is
*       maxlen - 1 (and then a '\0' is appended).
*
*ifdef _HPFS_
*       If we hit a quoted string, then allow any characters inside.
*       For example, to put a semi-colon in a path, the user could have
*       an environment variable that looks like:
*
*               PATH=C:\BIN;"D:\CRT\TOOLS;B1";C:\BINP
*endif
*
*       NOTE: Semi-colons in sequence are skipped over; pointers to 0-length
*       pathnames are NOT returned (this includes leading semi-colons).
*
*       NOTE: If this routine is made user-callable, the near attribute
*       must be replaced by _LOAD_DS and the prototype moved from INTERNAL.H
*       to STDLIB.H. The source files MISC\SEARCHEN.C and EXEC\SPAWNVPE.C
*       will need to be recompiled, but should not require any changes.
*
*Entry:
*       src    - Pointer to a string of 0 or more path specificiations,
*                delimited by semicolons (';'), and terminated by a null
*                character
*       dst    - Pointer to the buffer where the next path specification is to
*                be copied
*       maxlen - Maximum number of characters to be copied, counting the
*                terminating null character. Note that a value of 0 is treated
*                as UINT_MAX + 1.
*
*Exit:
*       If a pathname is successfully extracted and copied, a pointer to the
*       first character of next pathname is returned (intervening semicolons
*       are skipped over). If the pathname is too long, as much as possible
*       is copied to the user-specified buffer and NULL is returned.
*
*       Note that the no check is made of the validity of the copied pathname.
*
*Exceptions:
*
*******************************************************************************/

#ifdef WPRFLAG
wchar_t * __cdecl _wgetpath (
#else  /* WPRFLAG */
char * __cdecl _getpath (
#endif  /* WPRFLAG */
        register const _TSCHAR *src,
        register _TSCHAR *dst,
        size_t maxlen
        )
{
        const _TSCHAR *save_src;

        /*
         * strip off leading semi colons
         */
        while ( *src == _T(';') )
                src++;

        /*
         * Save original src pointer
         */
        save_src = src;

        /*
         * Decrement maxlen to allow for the terminating _T('\0')
         */
        if ( --maxlen == 0 )
        {
                errno = ERANGE;
                goto appendnull;
        }


        /*
         * Get the next path in src string
         */
        while (*src && (*src != _T(';'))) {

#if defined (_HPFS_)

                /*
                 * Check for quote char
                 */
                if (*src != _T('"')) {

                        *dst++ = *src++;

                        if ( --maxlen == 0 ) {
                                save_src = src; /* ensure NULL return */
                                errno = ERANGE;
                                goto appendnull;
                        }

                }
                else {

                        /*
                         * Found a quote.  Copy all chars until we hit the
                         * final quote or the end of the string.
                         */
                        src++;                  /* skip over opening quote */

                        while (*src && (*src != _T('"'))) {

                                *dst++ = *src++;

                                if ( --maxlen == 0 ) {
                                        save_src = src; /* ensure NULL return */
                                        errno = ERANGE;
                                        goto appendnull;
                                }
                        }

                        if (*src)
                                src++;          /* skip over closing quote */

                }

#else  /* defined (_HPFS_) */

                *dst++ = *src++;

                if ( --maxlen == 0 ) {
                        save_src = src; /* ensure NULL return */
                        errno = ERANGE;
                        goto appendnull;
                }

#endif  /* defined (_HPFS_) */

        }

        /*
         * If we copied something and stopped because of a _T(';'),
         * skip the _T(';') before returning
         */
        while ( *src == _T(';') )
                src++;

        /*
         * Store a terminating null
         */
appendnull:

        *dst = _T('\0');

        return((save_src != src) ? (_TSCHAR *)src : NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getqloc.c ===
/***
*getqloc.c - get qualified locale
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines __get_qualified_locale - get complete locale information
*
*******************************************************************************/

#include <cruntime.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <setlocal.h>
#include <awint.h>
#include <mtdll.h>
#include <internal.h>
#include <winnls.h>


//  local defines
#define __LCID_DEFAULT  0x1     //  default language locale for country
#define __LCID_PRIMARY  0x2     //  primary language locale for country
#define __LCID_FULL     0x4     //  fully matched language locale for country
#define __LCID_LANGUAGE 0x100   //  language default seen
#define __LCID_EXISTS   0x200   //  language is installed

//  local structure definitions
typedef struct tagLOCALETAB
{
    CHAR *  szName;
    CHAR    chAbbrev[4];
} LOCALETAB;

typedef struct tagRGLOCINFO
{
    LCID        lcid;
    char        chILanguage[8];
    char *      pchSEngLanguage;
    char        chSAbbrevLangName[4];
    char *      pchSEngCountry;
    char        chSAbbrevCtryName[4];
    char        chIDefaultCodepage[8];
    char        chIDefaultAnsiCodepage[8];
} RGLOCINFO;

//  function prototypes
BOOL __cdecl __get_qualified_locale(const LPLC_STRINGS, LPLC_ID, LPLC_STRINGS);
static BOOL TranslateName(const LOCALETAB *, int, const char **);

static void GetLcidFromLangCountry (_psetloc_struct _psetloc_data);
static BOOL CALLBACK LangCountryEnumProc(LPSTR);

static void GetLcidFromLanguage (_psetloc_struct _psetloc_data);
static BOOL CALLBACK LanguageEnumProc(LPSTR);

static void GetLcidFromCountry (_psetloc_struct _psetloc_data);
static BOOL CALLBACK CountryEnumProc(LPSTR);

static void GetLcidFromDefault (_psetloc_struct _psetloc_data);

static int ProcessCodePage (LPSTR lpCodePageStr, _psetloc_struct _psetloc_data);
static BOOL TestDefaultCountry(LCID);
static BOOL TestDefaultLanguage (LCID lcid, BOOL bTestPrimary, _psetloc_struct _psetloc_data);

static int __stdcall crtGetLocaleInfoA(LCID, LCTYPE, LPSTR, int);

static LCID LcidFromHexString(LPSTR);
static int GetPrimaryLen(LPSTR);

//  non-NLS language string table
__declspec(selectany) const LOCALETAB __rg_language[] =
{
    {"american",                    "ENU"},
    {"american english",            "ENU"},
    {"american-english",            "ENU"},
    {"australian",                  "ENA"},
    {"belgian",                     "NLB"},
    {"canadian",                    "ENC"},
    {"chh",                         "ZHH"},
    {"chi",                         "ZHI"},
    {"chinese",                     "CHS"},
    {"chinese-hongkong",            "ZHH"},
    {"chinese-simplified",          "CHS"},
    {"chinese-singapore",           "ZHI"},
    {"chinese-traditional",         "CHT"},
    {"dutch-belgian",               "NLB"},
    {"english-american",            "ENU"},
    {"english-aus",                 "ENA"},
    {"english-belize",              "ENL"},
    {"english-can",                 "ENC"},
    {"english-caribbean",           "ENB"},
    {"english-ire",                 "ENI"},
    {"english-jamaica",             "ENJ"},
    {"english-nz",                  "ENZ"},
    {"english-south africa",        "ENS"},
    {"english-trinidad y tobago",   "ENT"},
    {"english-uk",                  "ENG"},
    {"english-us",                  "ENU"},
    {"english-usa",                 "ENU"},
    {"french-belgian",              "FRB"},
    {"french-canadian",             "FRC"},
    {"french-luxembourg",           "FRL"},
    {"french-swiss",                "FRS"},
    {"german-austrian",             "DEA"},
    {"german-lichtenstein",         "DEC"},
    {"german-luxembourg",           "DEL"},
    {"german-swiss",                "DES"},
    {"irish-english",               "ENI"},
    {"italian-swiss",               "ITS"},
    {"norwegian",                   "NOR"},
    {"norwegian-bokmal",            "NOR"},
    {"norwegian-nynorsk",           "NON"},
    {"portuguese-brazilian",        "PTB"},
    {"spanish-argentina",           "ESS"},
    {"spanish-bolivia",             "ESB"},
    {"spanish-chile",               "ESL"},
    {"spanish-colombia",            "ESO"},
    {"spanish-costa rica",          "ESC"},
    {"spanish-dominican republic",  "ESD"},
    {"spanish-ecuador",             "ESF"},
    {"spanish-el salvador",         "ESE"},
    {"spanish-guatemala",           "ESG"},
    {"spanish-honduras",            "ESH"},
    {"spanish-mexican",             "ESM"},
    {"spanish-modern",              "ESN"},
    {"spanish-nicaragua",           "ESI"},
    {"spanish-panama",              "ESA"},
    {"spanish-paraguay",            "ESZ"},
    {"spanish-peru",                "ESR"},
    {"spanish-puerto rico",         "ESU"},
    {"spanish-uruguay",             "ESY"},
    {"spanish-venezuela",           "ESV"},
    {"swedish-finland",             "SVF"},
    {"swiss",                       "DES"},
    {"uk",                          "ENG"},
    {"us",                          "ENU"},
    {"usa",                         "ENU"}
};

//  non-NLS country/region string table
__declspec( selectany ) const LOCALETAB __rg_country[] =
{
    {"america",                     "USA"},
    {"britain",                     "GBR"},
    {"china",                       "CHN"},
    {"czech",                       "CZE"},
    {"england",                     "GBR"},
    {"great britain",               "GBR"},
    {"holland",                     "NLD"},
    {"hong-kong",                   "HKG"},
    {"new-zealand",                 "NZL"},
    {"nz",                          "NZL"},
    {"pr china",                    "CHN"},
    {"pr-china",                    "CHN"},
    {"puerto-rico",                 "PRI"},
    {"slovak",                      "SVK"},
    {"south africa",                "ZAF"},
    {"south korea",                 "KOR"},
    {"south-africa",                "ZAF"},
    {"south-korea",                 "KOR"},
    {"trinidad & tobago",           "TTO"},
    {"uk",                          "GBR"},
    {"united-kingdom",              "GBR"},
    {"united-states",               "USA"},
    {"us",                          "USA"},
};

//  LANGID's of locales of nondefault languages
__declspec( selectany ) const LANGID __rglangidNotDefault[] =
{
    MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH_CANADIAN),
    MAKELANGID(LANG_SERBIAN, SUBLANG_SERBIAN_CYRILLIC),
    MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN_LUXEMBOURG),
    MAKELANGID(LANG_AFRIKAANS, SUBLANG_DEFAULT),
    MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH_BELGIAN),
    MAKELANGID(LANG_BASQUE, SUBLANG_DEFAULT),
    MAKELANGID(LANG_CATALAN, SUBLANG_DEFAULT),
    MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH_SWISS),
    MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN_SWISS),
    MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH_FINLAND)
};

/***
*BOOL __get_qualified_locale - return fully qualified locale
*
*Purpose:
*       get default locale, qualify partially complete locales
*
*Entry:
*       lpInStr - input strings to be qualified
*       lpOutId - pointer to numeric LCIDs and codepage output
*       lpOutStr - pointer to string LCIDs and codepage output
*
*Exit:
*       TRUE if success, qualified locale is valid
*       FALSE if failure
*
*Exceptions:
*
*******************************************************************************/
BOOL __cdecl __get_qualified_locale(const LPLC_STRINGS lpInStr, LPLC_ID lpOutId,
                                    LPLC_STRINGS lpOutStr)
{
    int     iCodePage;
    _psetloc_struct    _psetloc_data = &_getptd()->_setloc_data;

    //  initialize pointer to call locale info routine based on operating system

    if (!lpInStr)
    {
        //  if no input defined, just use default LCID
        GetLcidFromDefault(_psetloc_data);
    }
    else
    {
        _psetloc_data->pchLanguage = lpInStr->szLanguage;

        //  convert non-NLS country strings to three-letter abbreviations
        _psetloc_data->pchCountry = lpInStr->szCountry;
        if (_psetloc_data->pchCountry && *_psetloc_data->pchCountry)
            TranslateName(__rg_country,
                          sizeof(__rg_country) / sizeof(LOCALETAB) - 1,
                          &_psetloc_data->pchCountry);

        _psetloc_data->iLcidState = 0;

        if (_psetloc_data->pchLanguage && *_psetloc_data->pchLanguage)
        {
            if (_psetloc_data->pchCountry && *_psetloc_data->pchCountry)
            {
                //  both language and country strings defined
                GetLcidFromLangCountry(_psetloc_data);
            }
            else
            {
                //  language string defined, but country string undefined
                GetLcidFromLanguage(_psetloc_data);
            }

            if (!_psetloc_data->iLcidState) {
                //  first attempt failed, try substituting the language name
                //  convert non-NLS language strings to three-letter abbrevs
                if (TranslateName(__rg_language,
                                  sizeof(__rg_language) / sizeof(LOCALETAB) - 1,
                                  &_psetloc_data->pchLanguage))
                {
                    if (_psetloc_data->pchCountry && *_psetloc_data->pchCountry)
                    {
                        GetLcidFromLangCountry(_psetloc_data);
                    }
                    else
                    {
                        GetLcidFromLanguage(_psetloc_data);
                    }
                }
            }
        }
        else
        {
            if (_psetloc_data->pchCountry && *_psetloc_data->pchCountry)
            {
                //  country string defined, but language string undefined
                GetLcidFromCountry(_psetloc_data);
            }
            else
            {
                //  both language and country strings undefined
                GetLcidFromDefault(_psetloc_data);
            }
        }
    }

    //  test for error in LCID processing
    if (!_psetloc_data->iLcidState)
        return FALSE;

    //  process codepage value
    iCodePage = ProcessCodePage(lpInStr ? lpInStr->szCodePage: NULL, _psetloc_data);

    //  verify codepage validity
    if (!iCodePage || iCodePage == CP_UTF7 || iCodePage == CP_UTF8 ||
        !IsValidCodePage((WORD)iCodePage))
        return FALSE;

    //  verify locale is installed
    if (!IsValidLocale(_psetloc_data->lcidLanguage, LCID_INSTALLED))
        return FALSE;

    //  set numeric LCID and codepage results
    if (lpOutId)
    {
        lpOutId->wLanguage = LANGIDFROMLCID(_psetloc_data->lcidLanguage);
        lpOutId->wCountry = LANGIDFROMLCID(_psetloc_data->lcidCountry);
        lpOutId->wCodePage = (WORD)iCodePage;
    }

    //  set string language, country, and codepage results
    if (lpOutStr)
    {
        // Norwegian-Nynorsk is special case because Langauge and country pair
        // for Norwegian-Nynorsk and Norwegian is same ie. Norwegian_Norway
        if ( lpOutId->wLanguage ==  0x0814)
            _ERRCHECK(strcpy_s(lpOutStr->szLanguage, _countof(lpOutStr->szLanguage), "Norwegian-Nynorsk"));
        else if (GetLocaleInfoA(_psetloc_data->lcidLanguage, LOCALE_SENGLANGUAGE,
                                 lpOutStr->szLanguage, MAX_LANG_LEN) == 0)
            return FALSE;
        if (GetLocaleInfoA(_psetloc_data->lcidCountry, LOCALE_SENGCOUNTRY,
                                 lpOutStr->szCountry, MAX_CTRY_LEN) == 0)
            return FALSE;
        _itoa_s((int)iCodePage, (char *)lpOutStr->szCodePage, MAX_CP_LEN, 10);
    }
    return TRUE;
}

/***
*BOOL TranslateName - convert known non-NLS string to NLS equivalent
*
*Purpose:
*   Provide compatibility with existing code for non-NLS strings
*
*Entry:
*   lpTable  - pointer to LOCALETAB used for translation
*   high     - maximum index of table (size - 1)
*   ppchName - pointer to pointer of string to translate
*
*Exit:
*   ppchName - pointer to pointer of string possibly translated
*   TRUE if string translated, FALSE if unchanged
*
*Exceptions:
*
*******************************************************************************/
static BOOL TranslateName (
    const LOCALETAB * lpTable,
    int               high,
    const char **     ppchName)
{
    int     i;
    int     cmp = 1;
    int     low = 0;

    //  typical binary search - do until no more to search or match
    while (low <= high && cmp != 0)
    {
        i = (low + high) / 2;
        cmp = _stricmp(*ppchName, (const char *)(*(lpTable + i)).szName);

        if (cmp == 0)
            *ppchName = (*(lpTable + i)).chAbbrev;
        else if (cmp < 0)
            high = i - 1;
        else
            low = i + 1;
    }

    return !cmp;
}

/***
*void GetLcidFromLangCountry - get LCIDs from language and country strings
*
*Purpose:
*   Match the best LCIDs to the language and country string given.
*   After global variables are initialized, the LangCountryEnumProc
*   routine is registered as an EnumSystemLocalesA callback to actually
*   perform the matching as the LCIDs are enumerated.
*
*Entry:
*   pchLanguage     - language string
*   bAbbrevLanguage - language string is a three-letter abbreviation
*   pchCountry      - country string
*   bAbbrevCountry  - country string ia a three-letter abbreviation
*   iPrimaryLen     - length of language string with primary name
*
*Exit:
*   lcidLanguage - LCID of language string
*   lcidCountry  - LCID of country string
*
*Exceptions:
*
*******************************************************************************/
static void GetLcidFromLangCountry (_psetloc_struct _psetloc_data)
{
    //  initialize static variables for callback use
    _psetloc_data->bAbbrevLanguage = strlen(_psetloc_data->pchLanguage) == 3;
    _psetloc_data->bAbbrevCountry = strlen(_psetloc_data->pchCountry) == 3;
    _psetloc_data->lcidLanguage = 0;
    _psetloc_data->iPrimaryLen = _psetloc_data->bAbbrevLanguage ?
                             2 : GetPrimaryLen(_psetloc_data->pchLanguage);

    EnumSystemLocalesA(LangCountryEnumProc, LCID_INSTALLED);

    //  locale value is invalid if the language was not installed or the language
    //  was not available for the country specified
    if (!(_psetloc_data->iLcidState & __LCID_LANGUAGE) ||
        !(_psetloc_data->iLcidState & __LCID_EXISTS) ||
        !(_psetloc_data->iLcidState & (__LCID_FULL |
                                    __LCID_PRIMARY |
                                    __LCID_DEFAULT)))
        _psetloc_data->iLcidState = 0;
}

/***
*BOOL CALLBACK LangCountryEnumProc - callback routine for GetLcidFromLangCountry
*
*Purpose:
*   Determine if LCID given matches the language in pchLanguage
*   and country in pchCountry.
*
*Entry:
*   lpLcidString   - pointer to string with decimal LCID
*   pchCountry     - pointer to country name
*   bAbbrevCountry - set if country is three-letter abbreviation
*
*Exit:
*   iLcidState   - status of match
*       __LCID_FULL - both language and country match (best match)
*       __LCID_PRIMARY - primary language and country match (better)
*       __LCID_DEFAULT - default language and country match (good)
*       __LCID_LANGUAGE - default primary language exists
*       __LCID_EXISTS - full match of language string exists
*       (Overall match occurs for the best of FULL/PRIMARY/DEFAULT
*        and LANGUAGE/EXISTS both set.)
*   lcidLanguage - LCID matched
*   lcidCountry  - LCID matched
*   FALSE if match occurred to terminate enumeration, else TRUE.
*
*Exceptions:
*
*******************************************************************************/
static BOOL CALLBACK LangCountryEnumProc (LPSTR lpLcidString)
{
    _psetloc_struct    _psetloc_data = &_getptd()->_setloc_data;
    LCID    lcid = LcidFromHexString(lpLcidString);
    char    rgcInfo[120];

    //  test locale country against input value
    if (GetLocaleInfoA(lcid,
                             _psetloc_data->bAbbrevCountry ?
                             LOCALE_SABBREVCTRYNAME : LOCALE_SENGCOUNTRY,
                             rgcInfo, sizeof(rgcInfo)) == 0)
    {
        //  set error condition and exit
        _psetloc_data->iLcidState = 0;
        return TRUE;
    }
    if (!_stricmp(_psetloc_data->pchCountry, rgcInfo))
    {
        //  country matched - test for language match
        if (GetLocaleInfoA(lcid,
                                 _psetloc_data->bAbbrevLanguage ?
                                 LOCALE_SABBREVLANGNAME : LOCALE_SENGLANGUAGE,
                                 rgcInfo, sizeof(rgcInfo)) == 0)
        {
            //  set error condition and exit
            _psetloc_data->iLcidState = 0;
            return TRUE;
        }
        if (!_stricmp(_psetloc_data->pchLanguage, rgcInfo))
        {
            //  language matched also - set state and value
            _psetloc_data->iLcidState |= (__LCID_FULL |
                                       __LCID_LANGUAGE |
                                       __LCID_EXISTS);
            _psetloc_data->lcidLanguage = _psetloc_data->lcidCountry = lcid;
        }

        //  test if match already for primary langauage
        else if (!(_psetloc_data->iLcidState & __LCID_PRIMARY))
        {
            //  if not, use _psetloc_data->iPrimaryLen to partial match language string
            if (_psetloc_data->iPrimaryLen && !_strnicmp(_psetloc_data->pchLanguage, rgcInfo, _psetloc_data->iPrimaryLen))
            {
                //  primary language matched - set state and country LCID
                _psetloc_data->iLcidState |= __LCID_PRIMARY;
                _psetloc_data->lcidCountry = lcid;

                //  if language is primary only (no subtype), set language LCID
                if ((int)strlen(_psetloc_data->pchLanguage) == _psetloc_data->iPrimaryLen)
                    _psetloc_data->lcidLanguage = lcid;
            }

            //  test if default language already defined
            else if (!(_psetloc_data->iLcidState & __LCID_DEFAULT))
            {
                //  if not, test if locale language is default for country
                if (TestDefaultCountry(lcid))
                {
                    //  default language for country - set state, value
                    _psetloc_data->iLcidState |= __LCID_DEFAULT;
                    _psetloc_data->lcidCountry = lcid;
                }
            }
        }
    }
    //  test if input language both exists and default primary language defined
    if ((_psetloc_data->iLcidState & (__LCID_LANGUAGE | __LCID_EXISTS)) !=
                      (__LCID_LANGUAGE | __LCID_EXISTS))
    {
        //  test language match to determine whether it is installed
        if (GetLocaleInfoA(lcid, _psetloc_data->bAbbrevLanguage ? LOCALE_SABBREVLANGNAME
                                                       : LOCALE_SENGLANGUAGE,
                           rgcInfo, sizeof(rgcInfo)) == 0)
        {
            //  set error condition and exit
            _psetloc_data->iLcidState = 0;
            return TRUE;
        }

        if (!_stricmp(_psetloc_data->pchLanguage, rgcInfo))
        {
            //  language matched - set bit for existance
            _psetloc_data->iLcidState |= __LCID_EXISTS;

            if (_psetloc_data->bAbbrevLanguage)
            {
                //  abbreviation - set state
                //  also set language LCID if not set already
                _psetloc_data->iLcidState |= __LCID_LANGUAGE;
                if (!_psetloc_data->lcidLanguage)
                    _psetloc_data->lcidLanguage = lcid;
            }

            //  test if language is primary only (no sublanguage)
            else if (_psetloc_data->iPrimaryLen && ((int)strlen(_psetloc_data->pchLanguage) == _psetloc_data->iPrimaryLen))
            {
                //  primary language only - test if default LCID
                if (TestDefaultLanguage(lcid, TRUE, _psetloc_data))
                {
                    //  default primary language - set state
                    //  also set LCID if not set already
                    _psetloc_data->iLcidState |= __LCID_LANGUAGE;
                    if (!_psetloc_data->lcidLanguage)
                        _psetloc_data->lcidLanguage = lcid;
                }
            }
            else
            {
                //  language with sublanguage - set state
                //  also set LCID if not set already
                _psetloc_data->iLcidState |= __LCID_LANGUAGE;
                if (!_psetloc_data->lcidLanguage)
                    _psetloc_data->lcidLanguage = lcid;
            }
        }
        else if (!_psetloc_data->bAbbrevLanguage && _psetloc_data->iPrimaryLen
                               && !_stricmp(_psetloc_data->pchLanguage, rgcInfo))
        {
            //  primary language match - test for default language only
            if (TestDefaultLanguage(lcid, FALSE, _psetloc_data))
            {
                //  default primary language - set state
                //  also set LCID if not set already
                _psetloc_data->iLcidState |= __LCID_LANGUAGE;
                if (!_psetloc_data->lcidLanguage)
                    _psetloc_data->lcidLanguage = lcid;
            }
        }
    }

    //  if LOCALE_FULL set, return FALSE to stop enumeration,
    //  else return TRUE to continue
    return (_psetloc_data->iLcidState & __LCID_FULL) == 0;
}

/***
*void GetLcidFromLanguage - get LCIDs from language string
*
*Purpose:
*   Match the best LCIDs to the language string given.  After global
*   variables are initialized, the LanguageEnumProc routine is
*   registered as an EnumSystemLocalesA callback to actually perform
*   the matching as the LCIDs are enumerated.
*
*Entry:
*   pchLanguage     - language string
*   bAbbrevLanguage - language string is a three-letter abbreviation
*   iPrimaryLen     - length of language string with primary name
*
*Exit:
*   lcidLanguage - lcidCountry  - LCID of language with default
*                                 country
*
*Exceptions:
*
*******************************************************************************/
static void GetLcidFromLanguage (_psetloc_struct _psetloc_data)
{
    //  initialize static variables for callback use
    _psetloc_data->bAbbrevLanguage = strlen(_psetloc_data->pchLanguage) == 3;
    _psetloc_data->iPrimaryLen = _psetloc_data->bAbbrevLanguage ? 2 : GetPrimaryLen(_psetloc_data->pchLanguage);

    EnumSystemLocalesA(LanguageEnumProc, LCID_INSTALLED);

    //  locale value is invalid if the language was not installed
    //  or the language was not available for the country specified
    if (!(_psetloc_data->iLcidState & __LCID_FULL))
        _psetloc_data->iLcidState = 0;
}

/***
*BOOL CALLBACK LanguageEnumProc - callback routine for GetLcidFromLanguage
*
*Purpose:
*   Determine if LCID given matches the default country for the
*   language in pchLanguage.
*
*Entry:
*   lpLcidString    - pointer to string with decimal LCID
*   pchLanguage     - pointer to language name
*   bAbbrevLanguage - set if language is three-letter abbreviation
*
*Exit:
*   lcidLanguage - lcidCountry - LCID matched
*   FALSE if match occurred to terminate enumeration, else TRUE.
*
*Exceptions:
*
*******************************************************************************/
static BOOL CALLBACK LanguageEnumProc (LPSTR lpLcidString)
{
    _psetloc_struct    _psetloc_data = &_getptd()->_setloc_data;
    LCID    lcid = LcidFromHexString(lpLcidString);
    char    rgcInfo[120];

    //  test locale for language specified
    if (GetLocaleInfoA(lcid, _psetloc_data->bAbbrevLanguage ? LOCALE_SABBREVLANGNAME
                                                   : LOCALE_SENGLANGUAGE,
                       rgcInfo, sizeof(rgcInfo)) == 0)
    {
        //  set error condition and exit
        _psetloc_data->iLcidState = 0;
        return TRUE;
    }

    if (!_stricmp(_psetloc_data->pchLanguage, rgcInfo))
    {
        //  language matched - test if locale country is default
        //  or if locale is implied in the language string
        if (_psetloc_data->bAbbrevLanguage || TestDefaultLanguage(lcid, TRUE, _psetloc_data))
        {
            //  this locale has the default country
            _psetloc_data->lcidLanguage = _psetloc_data->lcidCountry = lcid;
            _psetloc_data->iLcidState |= __LCID_FULL;
        }
    }
    else if (!_psetloc_data->bAbbrevLanguage && _psetloc_data->iPrimaryLen
                              && !_stricmp(_psetloc_data->pchLanguage, rgcInfo))
    {
        //  primary language matched - test if locale country is default
        if (TestDefaultLanguage(lcid, FALSE, _psetloc_data))
        {
            //  this is the default country
            _psetloc_data->lcidLanguage = _psetloc_data->lcidCountry = lcid;
            _psetloc_data->iLcidState |= __LCID_FULL;
        }
    }

    return (_psetloc_data->iLcidState & __LCID_FULL) == 0;
}

/***
*void GetLcidFromCountry - get LCIDs from country string
*
*Purpose:
*   Match the best LCIDs to the country string given.  After global
*   variables are initialized, the CountryEnumProc routine is
*   registered as an EnumSystemLocalesA callback to actually perform
*   the matching as the LCIDs are enumerated.
*
*Entry:
*   pchCountry     - country string
*   bAbbrevCountry - country string is a three-letter abbreviation
*
*Exit:
*   lcidLanguage - lcidCountry  - LCID of country with default
*                                 language
*
*Exceptions:
*
*******************************************************************************/
static void GetLcidFromCountry (_psetloc_struct _psetloc_data)
{
    _psetloc_data->bAbbrevCountry = strlen(_psetloc_data->pchCountry) == 3;

    EnumSystemLocalesA(CountryEnumProc, LCID_INSTALLED);

    //  locale value is invalid if the country was not defined or
    //  no default language was found
    if (!(_psetloc_data->iLcidState & __LCID_FULL))
        _psetloc_data->iLcidState = 0;
}

/***
*BOOL CALLBACK CountryEnumProc - callback routine for GetLcidFromCountry
*
*Purpose:
*   Determine if LCID given matches the default language for the
*   country in pchCountry.
*
*Entry:
*   lpLcidString   - pointer to string with decimal LCID
*   pchCountry     - pointer to country name
*   bAbbrevCountry - set if country is three-letter abbreviation
*
*Exit:
*   lcidLanguage - lcidCountry - LCID matched
*   FALSE if match occurred to terminate enumeration, else TRUE.
*
*Exceptions:
*
*******************************************************************************/
static BOOL CALLBACK CountryEnumProc (LPSTR lpLcidString)
{
    _psetloc_struct    _psetloc_data = &_getptd()->_setloc_data;
    LCID    lcid = LcidFromHexString(lpLcidString);
    char    rgcInfo[120];

    //  test locale for country specified
    if (GetLocaleInfoA(lcid, _psetloc_data->bAbbrevCountry ? LOCALE_SABBREVCTRYNAME
                                                  : LOCALE_SENGCOUNTRY,
                       rgcInfo, sizeof(rgcInfo)) == 0)
    {
        //  set error condition and exit
        _psetloc_data->iLcidState = 0;
        return TRUE;
    }
    if (!_stricmp(_psetloc_data->pchCountry, rgcInfo))
    {
        //  language matched - test if locale country is default
        if (TestDefaultCountry(lcid))
        {
            //  this locale has the default language
            _psetloc_data->lcidLanguage = _psetloc_data->lcidCountry = lcid;
            _psetloc_data->iLcidState |= __LCID_FULL;
        }
    }
    return (_psetloc_data->iLcidState & __LCID_FULL) == 0;
}

/***
*void GetLcidFromDefault - get default LCIDs
*
*Purpose:
*   Set both language and country LCIDs to the system default.
*
*Entry:
*   None.
*
*Exit:
*   lcidLanguage - set to system LCID
*   lcidCountry  - set to system LCID
*
*Exceptions:
*
*******************************************************************************/
static void GetLcidFromDefault (_psetloc_struct _psetloc_data)
{
    _psetloc_data->iLcidState |= (__LCID_FULL | __LCID_LANGUAGE);
    _psetloc_data->lcidLanguage = _psetloc_data->lcidCountry = GetUserDefaultLCID();
}

/***
*int ProcessCodePage - convert codepage string to numeric value
*
*Purpose:
*   Process codepage string consisting of a decimal string, or the
*   special case strings "ACP" and "OCP", for ANSI and OEM codepages,
*   respectively.  Null pointer or string returns the ANSI codepage.
*
*Entry:
*   lpCodePageStr - pointer to codepage string
*
*Exit:
*   Returns numeric value of codepage.
*
*Exceptions:
*
*******************************************************************************/
static int ProcessCodePage (LPSTR lpCodePageStr, _psetloc_struct _psetloc_data)
{
    char    chCodePage[8];

    if (!lpCodePageStr || !*lpCodePageStr || !strcmp(lpCodePageStr, "ACP"))
    {
        //  get ANSI codepage for the country LCID
        if (GetLocaleInfoA(_psetloc_data->lcidCountry, LOCALE_IDEFAULTANSICODEPAGE,
                                 chCodePage, sizeof(chCodePage)) == 0)
            return 0;

        if (strcmp(chCodePage, "0") == 0) // for locales have no assoicated ANSI codepage, e.g. Hindi locale
            return GetACP();

        lpCodePageStr = chCodePage;
    }
    else if (!strcmp(lpCodePageStr, "OCP"))
    {
        //  get OEM codepage for the country LCID
        if (GetLocaleInfoA(_psetloc_data->lcidCountry, LOCALE_IDEFAULTCODEPAGE,
                                 chCodePage, sizeof(chCodePage)) == 0)
            return 0;
        lpCodePageStr = chCodePage;
    }

    //  convert decimal string to numeric value
    return (int)atol(lpCodePageStr);
}

/***
*BOOL TestDefaultCountry - determine if default locale for country
*
*Purpose:
*   Using a hardcoded list, determine if the locale of the given LCID
*   has the default sublanguage for the locale primary language.  The
*   list contains the locales NOT having the default sublanguage.
*
*Entry:
*   lcid - LCID of locale to test
*
*Exit:
*   Returns TRUE if default sublanguage, else FALSE.
*
*Exceptions:
*
*******************************************************************************/
static BOOL TestDefaultCountry (LCID lcid)
{
    LANGID  langid = LANGIDFROMLCID(lcid);
    int     i;

    for (i = 0; i < sizeof(__rglangidNotDefault) / sizeof(LANGID); i++)
    {
        if (langid == __rglangidNotDefault[i])
            return FALSE;
    }
    return TRUE;
}

/***
*BOOL TestDefaultLanguage - determine if default locale for language
*
*Purpose:
*   Determines if the given LCID has the default sublanguage.
*   If bTestPrimary is set, also allow TRUE when string contains an
*   implicit sublanguage.
*
*Entry:
*   LCID         - lcid of locale to test
*   bTestPrimary - set if testing if language is primary
*
*Exit:
*   Returns TRUE if sublanguage is default for locale tested.
*   If bTestPrimary set, TRUE is language has implied sublanguge.
*
*Exceptions:
*
*******************************************************************************/
static BOOL TestDefaultLanguage (LCID lcid, BOOL bTestPrimary, _psetloc_struct _psetloc_data)
{
    char    rgcInfo[120];
    LCID    lcidDefault = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(lcid)),
                                                  SUBLANG_DEFAULT), SORT_DEFAULT);

    if (GetLocaleInfoA(lcidDefault, LOCALE_ILANGUAGE, rgcInfo,
                                          sizeof(rgcInfo)) == 0)
        return FALSE;

    if (lcid != LcidFromHexString(rgcInfo))
    {
        //  test if string contains an implicit sublanguage by
        //  having a character other than upper/lowercase letters.
        if (bTestPrimary && GetPrimaryLen(_psetloc_data->pchLanguage) == (int)strlen(_psetloc_data->pchLanguage))
            return FALSE;
    }
    return TRUE;
}

/***
*LCID LcidFromHexString - convert hex string to value for LCID
*
*Purpose:
*   LCID values returned in hex ANSI strings - straight conversion
*
*Entry:
*   lpHexString - pointer to hex string to convert
*
*Exit:
*   Returns LCID computed.
*
*Exceptions:
*
*******************************************************************************/
static LCID LcidFromHexString (LPSTR lpHexString)
{
    char    ch;
    DWORD   lcid = 0;

    while (ch = *lpHexString++)
    {
        if (ch >= 'a' && ch <= 'f')
            ch += '9' + 1 - 'a';
        else if (ch >= 'A' && ch <= 'F')
            ch += '9' + 1 - 'A';
        lcid = lcid * 0x10 + ch - '0';
    }

    return (LCID)lcid;
}

/***
*int GetPrimaryLen - get length of primary language name
*
*Purpose:
*   Determine primary language string length by scanning until
*   first non-alphabetic character.
*
*Entry:
*   pchLanguage - string to scan
*
*Exit:
*   Returns length of primary language string.
*
*Exceptions:
*
*******************************************************************************/
static int GetPrimaryLen (LPSTR pchLanguage)
{
    int     len = 0;
    char    ch;

    ch = *pchLanguage++;
    while ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'))
    {
        len++;
        ch = *pchLanguage++;
    }

    return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getenv.c ===
/***
*getenv.c - get the value of an environment variable
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines getenv() - searches the environment for a string variable
*       and returns the value of it.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <internal.h>
#include <mtdll.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <awint.h>

#ifndef CRTDLL

/*
 * Flag checked by getenv() and _putenv() to determine if the environment has
 * been initialized.
 */
extern int __env_initialized;

#endif  /* CRTDLL */

errno_t __cdecl _wgetenv_s_helper(size_t *pReturnValue, wchar_t *buffer, size_t sizeInWords, const wchar_t *varname);
errno_t __cdecl _getenv_s_helper(size_t *pReturnValue, char *buffer, size_t sizeInBytes, const char *varname);

#if _DEBUG
errno_t __cdecl _wdupenv_s_helper(wchar_t **pBuffer, size_t *pBufferSizeInWords, const wchar_t *varname,
    int nBlockUse, const char *szFileName, int nLine);
errno_t __cdecl _dupenv_s_helper(char **pBuffer, size_t *pBufferSizeInWords, const char *varname,
    int nBlockUse, const char *szFileName, int nLine);
#else  /* _DEBUG */
errno_t __cdecl _wdupenv_s_helper(wchar_t **pBuffer, size_t *pBufferSizeInWords, const wchar_t *varname);
errno_t __cdecl _dupenv_s_helper(char **pBuffer, size_t *pBufferSizeInWords, const char *varname);
#endif  /* _DEBUG */

#ifdef WPRFLAG
#define _tgetenv_helper_nolock _wgetenv_helper_nolock
#define _tgetenv_s_helper _wgetenv_s_helper
#define _tdupenv_s_helper _wdupenv_s_helper
#else  /* WPRFLAG */
#define _tgetenv_helper_nolock _getenv_helper_nolock
#define _tgetenv_s_helper _getenv_s_helper
#define _tdupenv_s_helper _dupenv_s_helper
#endif  /* WPRFLAG */

/***
*char *getenv(option) - search environment for a string
*
*Purpose:
*       searches the environment for a string of the form "option=value",
*       if found, return value, otherwise NULL.
*
*Entry:
*       const char *option - variable to search for in environment
*
*Exit:
*       returns the value part of the environment string if found,
*       otherwise NULL
*
*Exceptions:
*
*******************************************************************************/

_TSCHAR * __cdecl _tgetenv (
        const _TSCHAR *option
        )
{
        _TSCHAR *retval;

        _VALIDATE_RETURN( (option != NULL), EINVAL, NULL);
        _VALIDATE_RETURN( (_tcsnlen(option, _MAX_ENV) < _MAX_ENV), EINVAL, NULL);

        _mlock( _ENV_LOCK );
        __try {
            retval = (_TSCHAR *)_tgetenv_helper_nolock(option);
        }
        __finally {
            _munlock( _ENV_LOCK );
        }

        return(retval);
}

const _TSCHAR * __cdecl _tgetenv_helper_nolock (
        const _TSCHAR *option
        )
{
        _TSCHAR **search = _tenviron;
        size_t length;

#ifndef CRTDLL
        /*
         * Make sure the environment is initialized.
         */
        if ( !__env_initialized )
            return NULL;
#endif  /* CRTDLL */

        /*
         * At startup, we obtain the 'native' flavor of environment strings
         * from the OS. So a "main" program has _environ and a "wmain" has
         * _wenviron loaded at startup. Only when the user gets or puts the
         * 'other' flavor do we convert it.
         */


#ifdef WPRFLAG
        if (!search && _environ)
        {
            /* don't have requested type, but other exists, so convert it */
            _wenvptr = __crtGetEnvironmentStringsW();
            if ( _wsetenvp() < 0 )
                if (__mbtow_environ() != 0)
                return NULL;

            /* now requested type exists */
            search = _wenviron;
        }
#else  /* WPRFLAG */
        if (!search && _wenviron)
        {
            /* don't have requested type, but other exists, so convert it */
            if (__wtomb_environ() != 0)
                return NULL;

            /* now requested type exists */
            search = _environ;
        }
#endif  /* WPRFLAG */


        if (search && option)
        {
                length = _tcslen(option);

                /*
                ** Make sure `*search' is long enough to be a candidate
                ** (We must NOT index past the '\0' at the end of `*search'!)
                ** and that it has an equal sign ('=') in the correct spot.
                ** If both of these requirements are met, compare the strings.
                */
                while (*search)
                {
                        if (_tcslen(*search) > length &&
                            (*(*search + length) == _T('=')) &&
                            (_tcsnicoll(*search, option, length) == 0))
                        {
                                /* internal consistency check: the environment string should never use a buffer bigger than _MAX_ENV
                                 * see also SDK function SetEnvironmentVariable
                                 */
                                _ASSERTE(_tcsnlen(*search + length + 1, _MAX_ENV) < _MAX_ENV);

                                return(*search + length + 1);
                        }

                        search++;
                }
        }

        return NULL;
}

/***
*errno_t getenv_s(pReturnValue, buffer, size, option) - search environment for a string
*
*Purpose:
*       searches the environment for a string of the form "option=value",
*       if found, copies the value in buffer.
*
*Entry:
*       size_t *pReturnValue - indicates if the variable has been found and
*           size needed
*       char *buffer - destination string
*       size_t sizeInChars - size of the destination buffer
*       const char *varname - variable to search for in environment
*
*Exit:
*       return the error code
*
*Exceptions:
*
*******************************************************************************/

errno_t __cdecl _tgetenv_s (
        size_t *pReturnValue,
        _TSCHAR *buffer,
        size_t sizeInTChars,
        const _TSCHAR *varname
        )
{
        errno_t retval;

        _mlock( _ENV_LOCK );
        __try {
            retval = _tgetenv_s_helper(pReturnValue, buffer, sizeInTChars, varname);
        }
        __finally {
            _munlock( _ENV_LOCK );
        }

        return(retval);
}

static
__forceinline
errno_t __cdecl _tgetenv_s_helper (
        size_t *pReturnValue,
        _TSCHAR *buffer,
        size_t sizeInTChars,
        const _TSCHAR *varname
        )
{
    const _TSCHAR *str;

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(pReturnValue != NULL, EINVAL);
    *pReturnValue = 0;
    _VALIDATE_RETURN_ERRCODE((buffer != NULL && sizeInTChars > 0) || (buffer == NULL && sizeInTChars == 0), EINVAL);
    if (buffer != NULL)
    {
        *buffer = '\0';
    }
    /* varname is already validated in _tgetenv_helper_nolock */

    str = _tgetenv_helper_nolock(varname);
    if (str == NULL)
    {
        return 0;
    }

    *pReturnValue = _tcslen(str) + 1;
    if (sizeInTChars == 0)
    {
        /* we just return the size of the needed buffer */
        return 0;
    }

    if (*pReturnValue > sizeInTChars)
    {
        /* the buffer is too small: we return EINVAL, and we give the user another chance to
         * call getenv_s with a bigger buffer
         */
        return ERANGE;
    }

    _ERRCHECK(_tcscpy_s(buffer, sizeInTChars, str));

    return 0;
}

/***
*errno_t _dupenv_s(pBuffer, pBufferSize, varname) - search environment for a string
*
*Purpose:
*       searches the environment for a string of the form "option=value",
*       if found, copies the value in buffer.
*
*Entry:
*       char **pBuffer - pointer to a buffer which will be allocated
*       size_t *pBufferSize - pointer to the size of the buffer (optional)
*       const char *varname - variable to search for in environment
*
*Exit:
*       return the error code
*
*Exceptions:
*
*******************************************************************************/

#ifdef _DEBUG
errno_t __cdecl _tdupenv_s (
        _TSCHAR **pBuffer,
        size_t *pBufferSizeInTChars,
        const _TSCHAR *varname
        )
{
    return _tdupenv_s_dbg(pBuffer, pBufferSizeInTChars, varname, _NORMAL_BLOCK, NULL, 0);
}

errno_t __cdecl _tdupenv_s_dbg (
        _TSCHAR **pBuffer,
        size_t *pBufferSizeInTChars,
        const _TSCHAR *varname,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
#else  /* _DEBUG */
errno_t __cdecl _tdupenv_s (
        _TSCHAR **pBuffer,
        size_t *pBufferSizeInTChars,
        const _TSCHAR *varname
        )
#endif  /* _DEBUG */
{
        errno_t retval;

        _mlock( _ENV_LOCK );
        __try {
#ifdef _DEBUG
            retval = _tdupenv_s_helper(pBuffer, pBufferSizeInTChars, varname, nBlockUse, szFileName, nLine);
#else  /* _DEBUG */
            retval = _tdupenv_s_helper(pBuffer, pBufferSizeInTChars, varname);
#endif  /* _DEBUG */
        }
        __finally {
            _munlock( _ENV_LOCK );
        }

        return retval;
}

static
__forceinline
#ifdef _DEBUG
errno_t __cdecl _tdupenv_s_helper (
        _TSCHAR **pBuffer,
        size_t *pBufferSizeInTChars,
        const _TSCHAR *varname,
        int nBlockUse,
        const char * szFileName,
        int nLine
        )
#else  /* _DEBUG */
errno_t __cdecl _tdupenv_s_helper (
        _TSCHAR **pBuffer,
        size_t *pBufferSizeInTChars,
        const _TSCHAR *varname
        )
#endif  /* _DEBUG */
{
    const _TSCHAR *str;
    size_t size;

    /* validation section */
    _VALIDATE_RETURN_ERRCODE(pBuffer != NULL, EINVAL);
    *pBuffer = NULL;
    if (pBufferSizeInTChars != NULL)
    {
        *pBufferSizeInTChars = 0;
    }
    _VALIDATE_RETURN_ERRCODE(varname != NULL, EINVAL);

    str = _tgetenv_helper_nolock(varname);
    if (str == NULL)
    {
        return 0;
    }

    size = _tcslen(str) + 1;
#ifdef _DEBUG
    *pBuffer = (_TSCHAR*)_calloc_dbg(size, sizeof(_TSCHAR), nBlockUse, szFileName, nLine);
#else  /* _DEBUG */
    *pBuffer = (_TSCHAR*)calloc(size, sizeof(_TSCHAR));
#endif  /* _DEBUG */
    if (*pBuffer == NULL)
    {
        errno = ENOMEM;
        return errno;
    }

    _ERRCHECK(_tcscpy_s(*pBuffer, size, str));
    if (pBufferSizeInTChars != NULL)
    {
        *pBufferSizeInTChars = size;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapchk.c ===
/***
*heapchk.c - perform a consistency check on the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _heapchk() and _heapset() functions
*
*******************************************************************************/


#ifdef WINHEAP


#include <cruntime.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <winheap.h>


/***
*int _heapchk()         - Validate the heap
*int _heapset(_fill)    - Obsolete function!
*
*Purpose:
*       Both functions perform a consistency check on the heap. The old
*       _heapset used to fill free blocks with _fill, in addition to
*       performing the consistency check. The current _heapset ignores the
*       passed parameter and just returns _heapchk.
*
*Entry:
*       For heapchk()
*           No arguments
*       For heapset()
*           int _fill - ignored
*
*Exit:
*       Returns one of the following values:
*
*           _HEAPOK         - completed okay
*           _HEAPEMPTY      - heap not initialized
*           _HEAPBADBEGIN   - can't find initial header info
*           _HEAPBADNODE    - malformed node somewhere
*
*       Debug version prints out a diagnostic message if an error is found
*       (see errmsg[] above).
*
*       NOTE:  Add code to support memory regions.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapchk (void)
{
        int retcode = _HEAPOK;

#ifndef _WIN64
        if ( __active_heap == __V6_HEAP )
        {
            _mlock( _HEAP_LOCK );
            __try {

            if ( __sbh_heap_check() < 0 )
                retcode = _HEAPBADNODE;

            }
            __finally {
                _munlock( _HEAP_LOCK );
            }
        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP )
        {
            _mlock( _HEAP_LOCK );
            __try {

            if ( __old_sbh_heap_check() < 0 )
                retcode = _HEAPBADNODE;

            }
            __finally {
                _munlock( _HEAP_LOCK );
            }
        }
#endif  /* CRTDLL */
#endif  /* _WIN64 */

        if (!HeapValidate(_crtheap, 0, NULL))
        {
            if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
            {
                _doserrno = ERROR_CALL_NOT_IMPLEMENTED;
                errno = ENOSYS;
            }
            else
                retcode = _HEAPBADNODE;
        }
        return retcode;
}

/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */

int __cdecl _heapset (
        unsigned int _fill
        )
{
        return _heapchk();
}



#else  /* WINHEAP */


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>
#include <string.h>

static int __cdecl _heap_checkset(unsigned int _fill);

/* Debug error values */
#define _EMPTYHEAP   0
#define _BADROVER    1
#define _BADRANGE    2
#define _BADSENTINEL 3
#define _BADEMPTY    4
#define _EMPTYLOOP   5
#define _BADFREE     6
#define _BADORDER    7


#define _PRINTERR(msg)



/***
*int _heapchk()      - Validate the heap
*int _heapset(_fill) - Validate the heap and fill in free entries
*
*Purpose:
*   Performs a consistency check on the heap.
*
*Entry:
*   For heapchk()
*       No arguments
*   For heapset()
*       int _fill - value to be used as filler in free entries
*
*Exit:
*   Returns one of the following values:
*
*       _HEAPOK          - completed okay
*       _HEAPEMPTY       - heap not initialized
*       _HEAPBADBEGIN    - can't find initial header info
*       _HEAPBADNODE     - malformed node somewhere
*
*   Debug version prints out a diagnostic message if an error is found
*   (see errmsg[] above).
*
*   NOTE:  Add code to support memory regions.
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapchk(void)
{
    return(_heap_checkset((unsigned int)_HEAP_NOFILL));
}


int __cdecl _heapset (
    unsigned int _fill
    )
{
    return(_heap_checkset(_fill));
}


/***
*static int _heap_checkset(_fill) - check the heap and fill in the
*   free entries
*
*Purpose:
*   Workhorse routine for both _heapchk() and _heapset().
*
*Entry:
*   int _fill - either _HEAP_NOFILL or a value to be used as filler in
*              free entries
*
*Exit:
*   See description of _heapchk()/_heapset()
*
*******************************************************************************/

static int __cdecl _heap_checkset (
    unsigned int _fill
    )
{
    REG1 _PBLKDESC pdesc;
    REG2 _PBLKDESC pnext;
    int roverfound=0;
    int retval = _HEAPOK;

    /*
     * lock the heap
     */

    _mlock(_HEAP_LOCK);

    /*
     * Validate the sentinel
     */

    if (_heap_desc.sentinel.pnextdesc != NULL) {
        _PRINTERR(_BADSENTINEL);
        retval = _HEAPBADNODE;
        goto done;
    }

    /*
     * Test for an empty heap
     */

    if ( (_heap_desc.pfirstdesc == &_heap_desc.sentinel) &&
         (_heap_desc.proverdesc == &_heap_desc.sentinel) ) {
        retval = _HEAPEMPTY;
        goto done;
    }

    /*
     * Get and validate the first descriptor
     */

    if ((pdesc = _heap_desc.pfirstdesc) == NULL) {
        _PRINTERR(_EMPTYHEAP);
        retval = _HEAPBADBEGIN;
        goto done;
    }

    /*
     * Walk the heap descriptor list
     */

    while (pdesc != &_heap_desc.sentinel) {

        /*
         * Make sure address for this entry is in range.
         */

        if ( (_ADDRESS(pdesc) < _ADDRESS(_heap_desc.pfirstdesc)) ||
             (_ADDRESS(pdesc) > _heap_desc.sentinel.pblock) ) {
            _PRINTERR(_BADRANGE);
            retval = _HEAPBADNODE;
            goto done;
        }

        pnext = pdesc->pnextdesc;

        /*
         * Make sure the blocks corresponding to pdesc and pnext are
         * in proper order.
         */

        if ( _ADDRESS(pdesc) >= _ADDRESS(pnext) ) {
            _PRINTERR(_BADORDER);
            retval = _HEAPBADNODE;
            goto done;
        }

        /*
         * Check the backpointer.
         */

        if (_IS_INUSE(pdesc) || _IS_FREE(pdesc)) {

            if (!_CHECK_PDESC(pdesc)) {
                retval = _HEAPBADPTR;
                goto done;
            }
        }

        /*
         * Check for proverdesc
         */

        if (pdesc == _heap_desc.proverdesc)
            roverfound++;

        /*
         * If it is free, fill it in if appropriate
         */

        if ( _IS_FREE(pdesc) && (_fill != _HEAP_NOFILL) )
            memset( (void *)((unsigned)_ADDRESS(pdesc)+_HDRSIZE),
            _fill, _BLKSIZE(pdesc) );

        /*
         * Onto the next block
         */

        pdesc = pnext;
    }

    /*
     * Make sure we found 1 and only 1 rover
     */

    if (_heap_desc.proverdesc == &_heap_desc.sentinel)
        roverfound++;

    if (roverfound != 1) {
        _PRINTERR(_BADROVER);
        retval = _HEAPBADBEGIN;
        goto done;
    }

    /*
     * Walk the empty list.  We can't really compare values against
     * anything but we may loop forever or may cause a fault.
     */

    pdesc = _heap_desc.emptylist;

    while (pdesc != NULL) {


        pnext = pdesc->pnextdesc;

        /*
         * Header should only appear once
         */

        if (pnext == _heap_desc.emptylist) {
            _PRINTERR(_EMPTYLOOP)
            retval = _HEAPBADPTR;
            goto done;
        }

        pdesc = pnext;

    }


    /*
     * Common return
     */

done:
    /*
     * release the heap lock
     */

    _munlock(_HEAP_LOCK);

    return(retval);

}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heaphook.c ===
/***
*heaphook.c - set the heap hook
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the following functions:
*           _setheaphook() - set the heap hook
*
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\getwch.c ===
/***
*getwch.c - contains _getwch(), _getwche(), _ungetwch() for Win32
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the "direct console" functions listed above.
*
*       NOTE: The real-mode DOS versions of these functions read from
*       standard input and are therefore redirected when standard input
*       is redirected. However, these versions ALWAYS read from the console,
*       even when standard input is redirected.
*
*******************************************************************************/

#include <cruntime.h>
#include <oscalls.h>
#include <conio.h>
#include <internal.h>
#include <mtdll.h>
#include <stdio.h>
#include <stdlib.h>
#include <dbgint.h>
#include <malloc.h>
#include <wchar.h>
#include <string.h>

typedef struct {
        unsigned char LeadChar;
        unsigned char SecondChar;
} CharPair;


/*
 * This is the one character push-back buffer used by _getwch(), _getwche()
 * and _ungetwch().
 */
static wint_t wchbuf = WEOF;
static int bUseW = 2;


/*
 * Declaration for console handle
 */
extern intptr_t _coninpfh;

/*
 * Function that looks up the extended key code for a given event.
 */
const CharPair * __cdecl _getextendedkeycode(KEY_EVENT_RECORD *);


/***
*wint_t _getwch(), _getwche() - read one char. from console (without and with
*                               echo)
*
*Purpose:
*       If the "_ungetwch()" push-back buffer is not empty (empty==-1) Then
*           Mark it empty (-1) and RETURN the value that was in it
*       Read a character using ReadConsole in RAW mode
*       Return the Character Code
*       _getwche(): Same as _getwch() except that the character value returned
*       is echoed (via "_putwch()")
*
*Entry:
*       None, reads from console.
*
*Exit:
*       If an error is returned from the API
*           Then WEOF
*       Otherwise
*            next byte from console
*       Static variable "wchbuf" may be altered
*
*Exceptions:
*
*******************************************************************************/


wint_t __cdecl _getwch (
        void
        )
{
        wchar_t wch;

        _mlock(_CONIO_LOCK);            /* secure the console lock */
        __TRY
            wch = _getwch_nolock();               /* input the character */
        __FINALLY
            _munlock(_CONIO_LOCK);          /* release the console lock */
        __END_TRY_FINALLY

        return wch;
}

wint_t __cdecl _getwche (
        void
        )
{
        wchar_t wch;

        _mlock(_CONIO_LOCK);            /* secure the console lock */
        __TRY
            wch = _getwche_nolock();              /* input and echo the character */
        __FINALLY
            _munlock(_CONIO_LOCK);          /* unlock the console */
        __END_TRY_FINALLY

        return wch;
}



wint_t __cdecl _getwch_nolock (
        void
        )
{
        INPUT_RECORD ConInpRec;
        DWORD NumRead;
        const CharPair *pCP;
        wchar_t wch = 0;                     /* single character buffer */
        DWORD oldstate;
        char ch;

        /*
         * check pushback buffer (wchbuf) a for character
         */
        if ( wchbuf != WEOF ) {
            /*
             * something there, clear buffer and return the character.
             */
            wch = (wchar_t)(wchbuf & 0xFFFF);
            wchbuf = WEOF;
            return wch;
        }

        /*
         * _coninpfh, the handle to the console input, is created the first
         * time that either _getwch() or _cgetws() or _kbhit() is called.
         */

        if ( _coninpfh == -2 )
            __initconin();

        if (_coninpfh == -1)
            return WEOF;

        /*
         * Switch to raw mode (no line input, no echo input)
         */
        GetConsoleMode( (HANDLE)_coninpfh, &oldstate );
        SetConsoleMode( (HANDLE)_coninpfh, 0L );

        for ( ; ; ) {

            /*
             * Get a console input event.
             */
            if ( bUseW ) {
                if ( !ReadConsoleInputW( (HANDLE)_coninpfh,
                                         &ConInpRec,
                                         1L,
                                         &NumRead)) {
                    if ( bUseW == 2 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
                        bUseW = FALSE;
                    else {
                        wch = WEOF;
                        break;
                    }
                }
                else
                    bUseW = TRUE;
                if ( NumRead == 0) {
                    wch = WEOF;
                    break;
                }
            }
            if ( !bUseW) {
                if ( !ReadConsoleInputA( (HANDLE) _coninpfh,
                                         &ConInpRec,
                                         1L,
                                         &NumRead )
                     || (NumRead == 0)) {
                    wch = WEOF;
                    break;
                }
            }

            /*
             * Look for, and decipher, key events.
             */
            if ( (ConInpRec.EventType == KEY_EVENT) &&
                 ConInpRec.Event.KeyEvent.bKeyDown ) {
                /*
                 * Easy case: if uChar.AsciiChar is non-zero, just stuff it
                 * into wch and quit.
                 */
                if (bUseW) {
                    if ( wch = (wchar_t)ConInpRec.Event.KeyEvent.uChar.UnicodeChar )
                        break;
                }
                else {
                    if ( ch = ConInpRec.Event.KeyEvent.uChar.AsciiChar ) {
                         MultiByteToWideChar(GetConsoleCP(),
                                             0,
                                             &ch,
                                             1,
                                             &wch,
                                             1);
                         break;
                     }
                }

                /*
                 * Hard case: either an extended code or an event which should
                 * not be recognized. let _getextendedkeycode() do the work...
                 */
                if ( pCP = _getextendedkeycode( &(ConInpRec.Event.KeyEvent) ) ) {
                    wch = pCP->LeadChar;
                    wchbuf = pCP->SecondChar;
                    break;
                }
            }
        }


        /*
         * Restore previous console mode.
         */
        SetConsoleMode( (HANDLE)_coninpfh, oldstate );

        return wch;
}


/*
 * getwche is just getwch followed by a putch if no error occurred
 */

wint_t __cdecl _getwche_nolock (
        void
        )
{
        wchar_t wch;                 /* character read */

        /*
         * check pushback buffer (wchbuf) a for character. if found, return
         * it without echoing.
         */
        if ( wchbuf != WEOF ) {
            /*
             * something there, clear buffer and return the character.
             */
            wch = (wchar_t)(wchbuf & 0xFFFF);
            wchbuf = WEOF;
            return wch;
        }

        wch = _getwch_nolock();       /* read character */

        if (wch != WEOF) {
                if (_putwch_nolock(wch) != WEOF) {
                        return wch;      /* if no error, return char */
                }
        }
        return WEOF;                     /* get or put failed, return EOF */
}

/***
*wint_t _ungetwch(c) - push back one character for "_getwch()" or "_getwche()"
*
*Purpose:
*       If the Push-back buffer "wchbuf" is -1 Then
*           Set "wchbuf" to the argument and return the argument
*       Else
*           Return EOF to indicate an error
*
*Entry:
*       int c - Character to be pushed back
*
*Exit:
*       If successful
*           returns character that was pushed back
*       Else if error
*           returns EOF
*
*Exceptions:
*
*******************************************************************************/


wint_t __cdecl _ungetwch (
        wint_t c
        )
{
        wchar_t retval;

        _mlock(_CONIO_LOCK);            /* lock the console */
        __TRY
            retval = _ungetwch_nolock(c);        /* pushback character */
        __FINALLY
            _munlock(_CONIO_LOCK);          /* unlock the console */
        __END_TRY_FINALLY

        return retval;
}
wint_t __cdecl _ungetwch_nolock (

        wint_t c
        )
{
        /*
         * Fail if the char is EOF or the pushback buffer is non-empty
         */
        if ( (c == WEOF) || (wchbuf != WEOF) )
            return EOF;

        wchbuf = (c & 0xFF);
        return wchbuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapprm.c ===
/***
*heapprm.c - Set/report heap parameters
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Set or report the values of certain parameters in the heap.
*
*******************************************************************************/


#ifndef WINHEAP


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>

/***
*_heap_param(int flag, int param_id, void *pparam) - set or report the values
*       of the specified heap parameter.
*
*Purpose:
*       Get or set certain parameters which affect the behavior of the heap.
*       The supported parameters vary implementation to implementation and
*       version to version. See description of entry conditions for the
*       currently supported parameters.
*
*Entry:
*       int flag     - _HP_GETPARAM, to get a parameter value, or _HP_SETPARAM,
*                      to set a parameter value
*
*       int param_id - identifier for the heap parameter. values supported in
*                      this release are:
*
*                      _HP_AMBLKSIZ  - _amblksiz (aka _heap_growsize) parameter
*                      _HP_GROWSIZE  - same as _HP_AMBLKSIZ
*                      _HP_RESETSIZE - _heap_resetsize parameter
*
*       void *pparam - pointer to variable of appropriate type for the heap
*                      parameter to be fetched/set
*
*Exit:
*        0 = no error has occurred
*       -1 = an error has occurred (errno is set)
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heap_param (
        int flag,
        int param_id,
        void *pparam
        )
{

        switch ( param_id ) {

                case _HP_RESETSIZE:
                        if ( flag == _HP_SETPARAM ) {
                                _mlock(_HEAP_LOCK);
                                _heap_resetsize = *(unsigned *)pparam;
                                _munlock(_HEAP_LOCK);
                        }
                        else
                                *(unsigned *)pparam = _heap_resetsize;
                        break;

                case _HP_AMBLKSIZ:
                        if ( flag == _HP_SETPARAM )
                                /*
                                 * the only references to _amblksiz (aka
                                 * _heap_growsize) are atomic. therefore, the
                                 * heap does not need to be locked.
                                 */
                                _amblksiz = *(unsigned *)pparam;
                        else
                                *(unsigned *)pparam = _amblksiz;
                        break;

                default:
                        return -1;
        }

        return 0;
}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapsrch.c ===
/***
*heapsrch.c - search the heap for a free block
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _heap_search() function.
*
*******************************************************************************/


#ifndef WINHEAP


#include <cruntime.h>
#include <heap.h>
#include <stddef.h>

#define LOOP_FOREVER    while(1)

/***
*_PBLKDESC _heap_search(unsigned size) - Find a free block of a least size
*       bytes.
*
*Purpose:
*       Finds a free block of at least size bytes. Searches the list of block
*       descriptors from *proverdesc to the end (marked by the sentinel). The
*       search is strictly first fit. Adjacent free blocks are coalesced as
*       they are encountered during the search.
*
*Entry:
*       unsigned size   - size of block requested
*
*Exit:
*       Success:  Pointer to descriptor for free memory block of at least size
*               bytes
*       Failure:  NULL
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

_PBLKDESC __cdecl _heap_search (
        unsigned size
        )
{
        REG1 _PBLKDESC pdesc;
        REG2 _PBLKDESC pdesc2;
        _PBLKDESC pretdesc = NULL;

        /* search from proverdesc thru plastdesc, looking for free block of
         * at least size bytes. coalesce adjacent free blocks during the
         * search. the search is strictly first fit. that is, it terminates
         * when the first block is found of adequate size.
         */
        for ( pdesc = _heap_desc.proverdesc ; pdesc != &(_heap_desc.sentinel) ;
        pdesc = pdesc->pnextdesc )
                /* is pdesc free?
                 */
                if ( _IS_FREE(pdesc) )
                        /* coalesce loop
                         */
                        LOOP_FOREVER {
                                /* if pdesc is big enough, return it
                                 */
                                if ( _BLKSIZE(pdesc) >= size ) {
                                        pretdesc = pdesc;
                                        goto searchdone;
                                }

                                /* see if the next block is free and, if so,
                                 * coalesce it with pdesc
                                 */
                                pdesc2 = pdesc->pnextdesc;
                                if ( _IS_FREE(pdesc2) ) {
                                        /* coalesce pdesc2 with pdesc
                                         */
                                        pdesc->pnextdesc = pdesc2->pnextdesc;
                                        _PUTEMPTY(pdesc2);
                                }
                                else
                                        break;
                        } /* end LOOP_FOREVER */

        for ( pdesc = _heap_desc.pfirstdesc ; pdesc != _heap_desc.proverdesc ;
        pdesc = pdesc->pnextdesc )
                /* is pdesc free?
                 */
                if ( _IS_FREE(pdesc) )
                        /* coalesce loop
                         */
                        LOOP_FOREVER {
                                /* if pdesc is big enough, return it
                                 */
                                if ( _BLKSIZE(pdesc) >= size ) {
                                        pretdesc = pdesc;
                                        goto searchdone;
                                }

                                /* see if the next block is free and, if so,
                                 * coalesce it with pdesc
                                 */
                                pdesc2 = pdesc->pnextdesc;
                                if ( _IS_FREE(pdesc2) ) {
                                        /* coalesce pdesc2 with pdesc
                                         */
                                        pdesc->pnextdesc = pdesc2->pnextdesc;
                                        _PUTEMPTY(pdesc2);

                                        /* special handling for the case where
                                         * the rover has been coalesced (search
                                         * ends)
                                         */
                                        if ( _heap_desc.proverdesc == pdesc2 )
                                        {
                                                _heap_desc.proverdesc = pdesc;
                                                if ( _BLKSIZE(pdesc) >= size )
                                                        pretdesc = pdesc;
                                                goto searchdone;
                                        }
                                }
                                else
                                        break;
                        } /* end LOOP_FOREVER */

searchdone:

        /* common exit for all code paths. win, lose or draw, this is the
         * only code path back to the caller.
         */
        return(pretdesc);
}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapused.c ===
/***
*heapused.c -
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/


#ifdef WINHEAP


#include <cruntime.h>
#include <malloc.h>
#include <errno.h>

size_t __cdecl _heapused(
        size_t *pUsed,
        size_t *pCommit
        )
{
        errno = ENOSYS;
        return( 0 );
}


#else  /* WINHEAP */


#include <cruntime.h>
#include <mtdll.h>  /* needed for _heapused() */
#include <oscalls.h>
#include <dos.h>
#include <heap.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>


size_t __cdecl _heapused(size_t *pUsed, size_t *pCommit)
{
    size_t retval;

    /* lock the heap */
    _mlock(_HEAP_LOCK);

    retval = _heapused_nolock(pUsed, pCommit);

    /* release the heap lock */
    _munlock(_HEAP_LOCK);

    return retval;
}

size_t __cdecl _heapused_nolock(size_t *pUsed, size_t *pCommit)

{
    _PBLKDESC p;
    _PBLKDESC next;
    int index ;
    size_t usedbytes;   /* bytes devoted to in-use blocks */
    size_t freebytes;   /* bytes devoted to free blocks */
    size_t rsrvbytes;   /* total bytes of reserved address space */
    void * * pageptr ;

    if ( (p = _heap_desc.pfirstdesc) == NULL
      || _heap_desc.pfirstdesc == &_heap_desc.sentinel )
    {
        return 0 ;  /* invalid heap */
    }

    /*
     * Scan through the heap, counting free and used blocks.
     * Include the overhead of each block and its heap descriptor.
     */

    freebytes = 0 ;
    usedbytes = 0 ;

    while (p != NULL)
    {

        next = p->pnextdesc;

        if (p == &_heap_desc.sentinel)
        {
            if (next != NULL)
            {
                return 0 ;
            }
        }
        else if (_IS_FREE(p))
        {
            freebytes += _BLKSIZE(p) + _HDRSIZE;
        }
        else if (_IS_INUSE(p))
        {
            usedbytes += _BLKSIZE(p) + _HDRSIZE;
        }

        p = next;
    }

    /*
     * Now we need to count the pages used for descriptors as reserved memory.
     * _heap_descpages points to the head of a singly-linked list of the pages.
     * The descriptors for in-use blocks are considered in-use memory.
     */

    pageptr = _heap_descpages;

    rsrvbytes = 0 ;

    while ( pageptr )
    {
        rsrvbytes += _HEAP_EMPTYLIST_SIZE ;
        pageptr = * pageptr ;
    }

    usedbytes += rsrvbytes ;

    /*
     * Loop through the region descriptor table
     */

    for ( index=0 ; index < _HEAP_REGIONMAX ; index++ )
    {
        rsrvbytes += _heap_regions[index]._totalsize ;
    }

    if ( pUsed )
        * pUsed = usedbytes ;

    if ( pCommit )
        * pCommit = freebytes + usedbytes ;

    return rsrvbytes ;
}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapwalk.c ===
/***
*heapwalk.c - walk the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines the _heapwalk() function
*
*******************************************************************************/


#ifdef WINHEAP


#include <cruntime.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>
#include <stdlib.h>
#include <winheap.h>
#include <internal.h>


/***
*int _heapwalk() - Walk the heap
*
*Purpose:
*       Walk the heap returning information on one entry at a time.
*
*Entry:
*       struct _heapinfo {
*               int * _pentry;  heap entry pointer
*               size_t size;    size of heap entry
*               int _useflag;   free/inuse flag
*               } *entry;
*
*Exit:
*       Returns one of the following values:
*
*               _HEAPOK         - completed okay
*               _HEAPEMPTY      - heap not initialized
*               _HEAPBADPTR     - _pentry pointer is bogus
*               _HEAPBADBEGIN   - can't find initial header info
*               _HEAPBADNODE    - malformed node somewhere
*               _HEAPEND        - end of heap successfully reached
*
*Uses:
*
*Exceptions:
*       Input parameters are validated. Refer to the validation section of the function.
*
*******************************************************************************/

int __cdecl _heapwalk (
        struct _heapinfo *_entry
        )
{
        PROCESS_HEAP_ENTRY Entry;
        DWORD errval;
        int errflag;
        int retval = _HEAPOK;

        /* validation section */
        _VALIDATE_RETURN(_entry != NULL, EINVAL, _HEAPBADPTR);

        Entry.wFlags = 0;
        Entry.iRegionIndex = 0;
        if ( (Entry.lpData = _entry->_pentry) == NULL ) {
                if ( !HeapWalk( _crtheap, &Entry ) ) {
                        if ( GetLastError() == ERROR_CALL_NOT_IMPLEMENTED ) {
                                _doserrno = ERROR_CALL_NOT_IMPLEMENTED;
                                errno = ENOSYS;
                                return _HEAPEND;
                        }
                return _HEAPBADBEGIN;
                }
        }
        else {
                if ( _entry->_useflag == _USEDENTRY ) {
                        if ( !HeapValidate( _crtheap, 0, _entry->_pentry ) )
                                return _HEAPBADNODE;
                Entry.wFlags = PROCESS_HEAP_ENTRY_BUSY;
                }
nextBlock:
                /*
                 * Guard the HeapWalk call in case we were passed a bad pointer
                 * to an allegedly free block.
                 */
                __try {
                        errflag = 0;
                        if ( !HeapWalk( _crtheap, &Entry ) )
                                errflag = 1;
                }
                __except( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ) {
                        errflag = 2;
                }

                /*
                 * Check errflag to see how HeapWalk fared...
                 */
                if ( errflag == 1 ) {
                        /*
                         * HeapWalk returned an error.
                         */
                        if ( (errval = GetLastError()) == ERROR_NO_MORE_ITEMS ) {
                        return _HEAPEND;
                        }
                        else if ( errval == ERROR_CALL_NOT_IMPLEMENTED ) {
                                _doserrno = errval;
                                errno = ENOSYS;
                                return _HEAPEND;
                        }
                        return _HEAPBADNODE;
                }
                else if ( errflag == 2 ) {
                        /*
                         * Exception occurred during the HeapWalk!
                         */
                        return _HEAPBADNODE;
                }
        }

        if ( Entry.wFlags & (PROCESS_HEAP_REGION |
                 PROCESS_HEAP_UNCOMMITTED_RANGE) )
        {
                goto nextBlock;
        }

        _entry->_pentry = Entry.lpData;
        _entry->_size = Entry.cbData;
        if ( Entry.wFlags & PROCESS_HEAP_ENTRY_BUSY ) {
                _entry->_useflag = _USEDENTRY;
        }
        else {
                _entry->_useflag = _FREEENTRY;
        }

        return( retval );
}



#else  /* WINHEAP */


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stddef.h>


/***
*int _heapwalk() - Walk the heap
*
*Purpose:
*       Walk the heap returning information on one entry at a time.
*
*Entry:
*       struct _heapinfo {
*               int * _pentry;  heap entry pointer
*               size_t size;    size of heap entry
*               int _useflag;   free/inuse flag
*               } *entry;
*
*Exit:
*       Returns one of the following values:
*
*               _HEAPOK         - completed okay
*               _HEAPEMPTY      - heap not initialized
*               _HEAPBADPTR     - _pentry pointer is bogus
*               _HEAPBADBEGIN   - can't find initial header info
*               _HEAPBADNODE    - malformed node somewhere
*               _HEAPEND        - end of heap successfully reached
*
*Uses:
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapwalk (
        struct _heapinfo *_entry
        )
{
        REG1 _PBLKDESC pdesc;
        _PBLKDESC polddesc;
        int retval = _HEAPOK;

        /*
         * Lock the heap
         */

        _mlock(_HEAP_LOCK);

        /*
         * Quick header check
         */

        if ( (_heap_desc.pfirstdesc == NULL) ||
             (_heap_desc.proverdesc == NULL) ||
             (_heap_desc.sentinel.pnextdesc != NULL) ) {
                retval = _HEAPBADBEGIN;
                goto done;
        }

        /*
         * Check for an empty heap
         */

        if ( _heap_desc.pfirstdesc == &_heap_desc.sentinel ) {
                retval = _HEAPEMPTY;
                goto done;
        }

        /*
         * If _pentry is NULL, return info about the first entry.
         * Else, get info about the next entry in the heap.
         */

        if ( _entry->_pentry == NULL ) {
                pdesc = _heap_desc.pfirstdesc;
        }
        else {
                /*
                 * Find the entry we gave to the user last time around
                 */

                if ( _heap_findaddr( (void *)((char *)(_entry->_pentry) -
                    _HDRSIZE), &polddesc) != _HEAPFIND_EXACT ) {
                        retval = _HEAPBADPTR;
                        goto done;
                }

                pdesc = polddesc->pnextdesc;

        } /* else */


        /*
         * pdesc = entry to return info about
         */

        /*
         * Skip over dummy entries
         */

        while ( _IS_DUMMY(pdesc) )
                pdesc = pdesc->pnextdesc;


        /*
         * See if we're at the end of the heap
         */

        if ( pdesc == &_heap_desc.sentinel ) {
                retval = _HEAPEND;
                goto done;
        }

        /*
         * Check back pointer (note that pdesc cannot point to a dummy
         * descriptor since we have skipped over them)
         */

        if (!_CHECK_PDESC(pdesc)) {
                retval = _HEAPBADPTR;
                goto done;
        }

        /*
         * Return info on the next block
         */

        _entry->_pentry = ( (void *)((char *)_ADDRESS(pdesc) + _HDRSIZE) );
        _entry->_size = _BLKSIZE(pdesc);
        _entry->_useflag = ( _IS_INUSE(pdesc) ? _USEDENTRY : _FREEENTRY );


        /*
         * Common return
         */

done:
        /*
         * Release the heap lock
         */

        _munlock(_HEAP_LOCK);

        return(retval);

}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heap.h ===
/***
*heap.h - Heap code include file
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains information needed by the C library heap code.
*
*       [Internal]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif  /* _MSC_VER > 1000 */

#ifndef _INC_HEAP
#define _INC_HEAP

#include <crtdefs.h>

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

/*
 * Heap block descriptor
 */

struct _block_descriptor {
        struct _block_descriptor *pnextdesc;    /* ptr to next descriptor */
        void *pblock;               /* ptr to memory block */
};

#define _BLKDESC    struct _block_descriptor
#define _PBLKDESC   struct _block_descriptor *


/*
 * Useful constants
 */

/*
 * Unit of allocation. All allocations are of size n * _GRANULARITY. Note
 * that _GRANULARITY must be a power of 2, or it cannot be used with the
 * _ROUND2 macro.
 */
#if defined (_M_IA64)
#define _GRANULARITY    8
#else  /* defined (_M_IA64) */
#define _GRANULARITY    4
#endif  /* defined (_M_IA64) */

/*
 * Size of the header in a memory block. Note that we must have
 * sizeof(void *) <= _HDRSIZE so the header is big enough to hold a pointer
 * to the descriptor.
 */

#define _HDRSIZE    1 * _GRANULARITY

/* _heapchk/_heapset parameter */
#define _HEAP_NOFILL    0x7FFFFFF


/*
 * Descriptor status values
 */

#define _INUSE      0
#define _FREE       1
#define _DUMMY      2


#if _INUSE != 0
#error *** Heap code assumes _INUSE value is 0! ***
#endif  /* _INUSE != 0 */


/*
 * Macros for manipulating heap memory block descriptors
 *      stat = one of the status values
 *      addr = user-visible address of a heap block
 */

#define _STATUS_MASK    0x3 /* last 2 bits are status */

#define _ADDRESS(pdesc)     ( (void *) ((unsigned)((pdesc)->pblock) & \
                    (~_STATUS_MASK)) )
#define _STATUS(pdesc)      ( (unsigned) ((unsigned)((pdesc)->pblock) & \
                    _STATUS_MASK) )

#define _SET_INUSE(pdesc)   ( pdesc->pblock = (void *) \
                       ((unsigned)_ADDRESS(pdesc) | _INUSE) )
#define _SET_FREE(pdesc)    ( pdesc->pblock = (void *) \
                       ((unsigned)_ADDRESS(pdesc) | _FREE) )
#define _SET_DUMMY(pdesc)   ( pdesc->pblock = (void *) \
                       ((unsigned)_ADDRESS(pdesc) | _DUMMY) )

#define _IS_INUSE(pdesc)    ( _STATUS(pdesc) == _INUSE )
#define _IS_FREE(pdesc)     ( _STATUS(pdesc) == _FREE )
#define _IS_DUMMY(pdesc)    ( _STATUS(pdesc) == _DUMMY )

#define _BLKSIZE(pdesc)     ( (unsigned) ( \
                      (char *)_ADDRESS(pdesc->pnextdesc) - \
                      (char *)_ADDRESS(pdesc) - _HDRSIZE ) )

#define _MEMSIZE(pdesc)     ( (char *)_ADDRESS(pdesc->pnextdesc) - \
                      (char *)_ADDRESS(pdesc) )

#define _BACKPTR(addr)      ( *(_PBLKDESC*)((char *)(addr) - _HDRSIZE) )

#define _CHECK_PDESC(pdesc) ( (*(_PBLKDESC*) (_ADDRESS(pdesc))) == pdesc )

#define _CHECK_BACKPTR(addr)    ( ((char *)(_BACKPTR(addr)->pblock) + _HDRSIZE) \
                    == addr)


/*
 * Heap descriptor
 */

struct _heap_desc_ {

        _PBLKDESC pfirstdesc;   /* pointer to first descriptor */
        _PBLKDESC proverdesc;   /* rover pointer */
        _PBLKDESC emptylist;    /* pointer to empty list */

        _BLKDESC  sentinel; /* Sentinel block for end of heap list */

};

extern struct _heap_desc_ _heap_desc;

/*
 * Region descriptor and heap grow data
 */

struct _heap_region_ {
        void * _regbase;    /* base address of region */
        unsigned _currsize; /* current size of region */
        unsigned _totalsize;    /* total size of region */
        };

#define _heap_growsize _amblksiz

extern unsigned int _heap_resetsize;
extern unsigned int _heap_regionsize;
extern unsigned int _heap_maxregsize;
extern struct _heap_region_ _heap_regions[];
extern void ** _heap_descpages;

#define _PAGESIZE_      0x1000      /* one page */

#define _SEGSIZE_       0x10000     /* one segment (i.e., 64 Kb) */

#define _HEAP_REGIONMAX     0x40        /* Max number of regions: 64 */
                                        /* For small memory systems: */
#define _HEAP_REGIONSIZE_S  0x4000      /* Initial region size (16K) */
#define _HEAP_MAXREGSIZE_S  0x1000000   /* Maximum region size (16M) */
                                        /* For large memory systems: */
#define _HEAP_REGIONSIZE_L  0x100000    /* Initial region size  (1M) */
#define _HEAP_MAXREGSIZE_L  0x1000000   /* Maximum region size (16M) */

#define _HEAP_GROWSIZE      0x10000     /* Default grow increment (64K) */

#define _HEAP_GROWMIN       _PAGESIZE_  /* Minimum grow inc (1 page) */
#define _HEAP_GROWSTART     _PAGESIZE_  /* Startup grow increment */
#define _HEAP_COALESCE      -1      /* Coalesce heap value */

#define _HEAP_EMPTYLIST_SIZE    (1 * _PAGESIZE_)

/*
 * Values returned by _heap_findaddr() routine
 */

#define _HEAPFIND_EXACT     0   /* found address exactly */
#define _HEAPFIND_WITHIN    1   /* address is within a block */
#define _HEAPFIND_BEFORE    -1  /* address before beginning of heap */
#define _HEAPFIND_AFTER     -2  /* address after end of heap */
#define _HEAPFIND_EMPTY     -3  /* address not found: empty heap */

/*
 * Arguments to _heap_param
 */

#define _HP_GETPARAM    0       /* get heap parameter value */
#define _HP_SETPARAM    1       /* set heap parameter value */

#define _HP_AMBLKSIZ    1       /* get/set _amblksiz value (aka */
#define _HP_GROWSIZE    _HP_AMBLKSIZ    /* _heap_growsize */
#define _HP_RESETSIZE   2       /* get/set _heap_resetsize value */


/*
 * Macros to round numbers
 *
 * _ROUND2 = rounds a number up to a power of 2
 * _ROUND = rounds a number up to any other numer
 *
 * n = number to be rounded
 * pow2 = must be a power of two value
 * r = any number
 */

#define _ROUND2(n,pow2) \
        ( ( n + pow2 - 1) & ~(pow2 - 1) )

#define _ROUND(n,r) \
        ( ( (n/r) + ((n%r)?1:0) ) * r)

/*

   Macros for accessing heap descriptor lists:

        _PUTEMPTY(x) = Puts an empty heap desc on the empty list

        (x = _PBLKDESC = pointer to heap block descriptor)
*/

#ifdef _DEBUG

#define _PUTEMPTY(x) \
{                               \
        (x)->pnextdesc = _heap_desc.emptylist;      \
                                \
        (x)->pblock = NULL;             \
                                \
        _heap_desc.emptylist = (x);         \
}

#else  /* _DEBUG */

#define _PUTEMPTY(x) \
{                               \
        (x)->pnextdesc = _heap_desc.emptylist;      \
                                \
        _heap_desc.emptylist = (x);         \
}

#endif  /* _DEBUG */


/*
 * Macros for finding the next 64 Kb boundary from a pointer
 */

#define _NXTSEGBNDRY(p)     ((void *)((unsigned)(p) & 0xffff0000 + 0x10000))

#define _DISTTOBNDRY(p)     ((unsigned)(0x10000 - (0x0000ffff & (unsigned)(p))))


/*
 * Prototypes
 */

_Check_return_  _Ret_opt_bytecap_(_Size) void * __cdecl _nh_malloc(_In_ size_t _Size, _In_ int _NhFlag);
_Check_return_  _Ret_opt_bytecap_(_Size) void * __cdecl _heap_alloc(_In_ size_t _Size);
_Check_return_  _Ret_opt_bytecap_(_Size) void * __cdecl _flat_malloc(_In_ size_t _Size);
_Check_return_ _PBLKDESC __getempty(void);
void __cdecl _heap_abort(void);
_Check_return_ int __cdecl _heap_addblock(_In_ void * _Block, _In_ unsigned int _Size);


void __cdecl _heap_free_region(_In_ int _Index);
_Check_return_ int __cdecl _heap_findaddr(_In_ void * _Block, _Out_ _PBLKDESC * _PDesc);
_Check_return_ int __cdecl _heap_grow(_In_ unsigned int _Size);
_Check_return_ int __cdecl _heap_grow_region(_In_ unsigned _Index, _In_ size_t _Size);
int __cdecl _heap_init(void);

int __cdecl _heap_param(_In_ int _Flag, _In_ int _ParamID, void * _Value);

_Check_return_ _PBLKDESC __cdecl _heap_search(_In_ unsigned _Size);
_Check_return_ _PBLKDESC __cdecl _heap_split_block(_In_ _PBLKDESC _Pdesc, _In_ size_t _NewSize);

#ifdef _DEBUG
void __cdecl _heap_print_all(void);
void __cdecl _heap_print_regions(void);
void __cdecl _heap_print_desc(void);
void __cdecl _heap_print_emptylist(void);
void __cdecl _heap_print_heaplist(void);
#endif  /* _DEBUG */


/*
 * Prototypes and macros for multi-thread support
 */


void __cdecl _free_nolock(_Inout_opt_ void * _Memory);
_Check_return_ size_t __cdecl _msize_nolock(_In_ void * _Memory);
size_t __cdecl _heapused_nolock(_Out_opt_ size_t *_PUsed, _Out_opt_ size_t *_PFree);

#ifdef _DEBUG
void __cdecl _heap_print_regions_nolock(void);
void __cdecl _heap_print_desc_nolock(void);
void __cdecl _heap_print_emptylist_nolock(void);
void __cdecl _heap_print_heaplist_nolock(void);
#endif  /* _DEBUG */



#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* _INC_HEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapadd.c ===
/***
*heapadd.c - Add a block of memory to the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Add a block of memory to the heap.
*
*******************************************************************************/


#ifdef WINHEAP


#include <cruntime.h>
#include <errno.h>
#include <malloc.h>
#include <winheap.h>

int __cdecl _heapadd (
        void * block,
        size_t size
        )
{
        errno = ENOSYS;
        return(-1);
}


#else  /* WINHEAP */


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdlib.h>

static void __cdecl _before(_PBLKDESC, size_t, _PBLKDESC, _PBLKDESC **);

/***
*int _heapadd(block, size) - Add a block of memory to the heap
*
*Purpose:
*       Add a block of user memory the heap.
*
*       NOTE:  The reason for the level of indirection between _heapadd
*       and _heap_addblock is (1) to validate the input, and (2) for
*       mthread locking/unlocking purposes.
*
*       NOTE: _heapadd() DOES NOT enter the block of memory into the region
*       table! This is the cleanest way to avoid nasty bugs such as attempting
*       to grow, shrink or free static memory (e.g., a block that started out
*       being a static array). If the memory block does in fact belong in the
*       region table, it is the caller's responsibility to do it (internal
*       routines only, user programs should NEVER do this).
*
*Entry:
*       void * block = block of memory
*       size_t size = size of memory block
*
*Exit:
*        0 = success
*       -1 = failure
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapadd (
        void * block,
        size_t size
        )
{
        int retval;

        /*
         * Validate user's input. Note that _GRANULARITY must be a power
         * of 2 for the tests below to be valid!
         */

        if ( (size == 0) ||
             ((unsigned)block & (_GRANULARITY - 1)) ||
             (size & (_GRANULARITY - 1))
           )
                return(-1);

        /*
         * Add the block to the heap.
         */

        _mlock(_HEAP_LOCK);
        retval = _heap_addblock(block, size);
        _munlock(_HEAP_LOCK);

        return(retval);

}


/***
*int _heap_addblock(block, size) - Add a block of memory to the heap
*
*Purpose:
*       Add a block of memory to the heap.
*
*       Notes:
*       (1) Must handle case where new memory is already in heap
*       (i.e., could be the address of a previous 'dummy' entry).
*
*Entry:
*       void * block = address of memory block
*       size_t size = size of memory block
*
*Exit:
*       0 = success
*       -1 = failure
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heap_addblock (
        void * block,
        size_t size
        )
{
        _PBLKDESC pdesc;
        REG1 _PBLKDESC pnewdesc;
        _PBLKDESC pdescs[4] = { NULL, NULL, NULL, NULL };
        _PBLKDESC *ppdesc = pdescs;
        size_t lastsize;
        int find;

        /*
         * Make sure we enough empty descriptors to do the job! Do it here
         * and now because recovering from an out-of-descriptors condition
         * is too dicey later on.
         */
        if ( ((pdescs[0] = __getempty()) == NULL) ||
             ((pdescs[1] = __getempty()) == NULL) ||
             ((pdescs[2] = __getempty()) == NULL) )
        {
                goto error;
        }

        /*
         * Find where the address fits into the heap.
         */

        find = _heap_findaddr(block, &pdesc);


        /*
         * Fill in the new heap descriptor.
         * (1) If the new address is an exact fit, use the dummy
         *     descriptor that already exists for it.
         * (2) If the address is NOT in the heap, allocate a new one.
         */

        if ( find == _HEAPFIND_EXACT ) {

                if ( !(_IS_DUMMY(pdesc)) )
                        goto error;

                pnewdesc = pdesc;
        }
        else {
                pnewdesc = *(ppdesc++);
        }

        pnewdesc->pblock = block;       /* pointer to block */
        _SET_FREE(pnewdesc);            /* set me free (why don't ya, babe) */
        *(_PBLKDESC*)block = pnewdesc;  /* init back pointer */


        /*
         * Put the block in the heap
         * find = result of _heap_findaddr() call
         * pnewdesc = points to desc to be inserted
         * pdesc = filled in by _heap_findaddr() call as appropriate
         */

        switch (find) {


                case(_HEAPFIND_EMPTY):

                        /*
                         * No memory in heap yet
                         */

                        _heap_desc.sentinel.pblock = (char *) block + size;
                        _before(pnewdesc, size, &_heap_desc.sentinel,
                                &ppdesc);

                        _heap_desc.pfirstdesc = _heap_desc.proverdesc =
                                pnewdesc;

                        break;


                case(_HEAPFIND_BEFORE):

                        /*
                         * New block is before the heap
                         */

                        _before(pnewdesc, size, _heap_desc.pfirstdesc,
                                &ppdesc);
                        _heap_desc.pfirstdesc = pnewdesc;
                        break;


                case(_HEAPFIND_AFTER):

                        /*
                         * New block is after the heap
                         *
                         * Find the current last block in the heap
                         */

                        if ( _heap_findaddr((void *)((char *)
                            (_heap_desc.sentinel.pblock) - 1), &pdesc) !=
                            _HEAPFIND_WITHIN )
                                _heap_abort();

                        lastsize = _MEMSIZE(pdesc);

                        /*
                         * Start insertion by placing new block immediately
                         * in front of the sentinel
                         */

                        _heap_desc.sentinel.pblock = (char *) block + size;
                        pnewdesc->pnextdesc = &_heap_desc.sentinel;

                        /*
                         * Finish insertion by placing new block after the
                         * old last block (with a possible intervening dummy
                         * block being created)
                         */

                        _before(pdesc, lastsize, pnewdesc,
                                &ppdesc);
                        break;


                case(_HEAPFIND_EXACT):

                        /*
                         * Block is already in the heap (and we've checked
                         * that it was a "dummy" before this call).
                         *
                         * [NOTES: (1) pnewdesc and pdesc are the same,
                         * (2) pnewdesc is already linked to the previous
                         * heap entry, (3) pdesc->pnextdesc is still valid!
                         * (4) Also, if pdesc->pnextdesc is the sentinel,
                         * then simply update the sentinel size (calling
                         * before will cause an error if the previous last
                         * block was bigger than the current one!).
                         * (see code at top of this routine).]
                         */

                        if (pdesc->pnextdesc == &_heap_desc.sentinel)

                                _heap_desc.sentinel.pblock =
                                        (char *) _ADDRESS(pdesc) + size;

                        else
                                _before(pnewdesc, size, pdesc->pnextdesc,
                                        &ppdesc);

                        break;

                default:
                        /*
                         * New block is within heap
                         */

                        if (!(_IS_DUMMY(pdesc)))
                                goto error;

                        /*
                         * If the last block in the heap is a dummy region
                         * and a new region is allocated which lies within
                         * that region, we need to update sentinel.pblock.
                         */
                        if (pdesc->pnextdesc == &_heap_desc.sentinel)
                        {
                            void * newend = (char *) _ADDRESS(pnewdesc) + size;

                            if (_heap_desc.sentinel.pblock < newend)
                                _heap_desc.sentinel.pblock = newend;
                        }

                        _before(pnewdesc, size, pdesc->pnextdesc,
                                &ppdesc);
                        _before(pdesc, _MEMSIZE(pdesc), pnewdesc,
                                &ppdesc);
                        break;


                }

        /*
         * Update rover, if appropriate
         */

         if ( (block < _ADDRESS(_heap_desc.proverdesc)) &&
         (_BLKSIZE(pnewdesc) >= _heap_resetsize) )
                _heap_desc.proverdesc = pnewdesc;

        /*
         * Good return
         */

        /* good:   unreferenced label to be removed */
                return(0);

        /*
         * Error return
         */

        error:
                while ( *ppdesc != NULL ) {
                        _PUTEMPTY(*ppdesc);
                        ppdesc++;
                }

                return(-1);

}


/***
*static void _before(pdesc1, size, pdesc2, pppdesc) - Insert a block before
*       a supplied descriptor
*
*Purpose:
*       This routine inserts a new descriptor before another descriptor.
*
*       Notes:
*       (1) A dummy descriptor will be inserted into the heap as
*           necessary.
*       (2) This routine only updates FORWARD links. Call this
*           routine twice to update links in both directions.
*
*Entry:
*       _PBLKDESC pdesc1    = new descriptor to insert in the heap
*       size_t size         = size of pdesc1 block
*       _PBLKDESC pdesc2    = descriptor before which block should go
*       _PBLKDESC **pppdesc = pointer to a pointer to the list of pointers
*                             of empty descriptors
*
*Exit:
*       (void)
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl _before (
        REG1 _PBLKDESC pdesc1,
        size_t size,
        REG2 _PBLKDESC pdesc2,
        _PBLKDESC **pppdesc
        )
{
        size_t diff;
        _PBLKDESC pdummydesc;
        void * dummyaddr;

        /*
         * Check for dummy descriptors:
         * (1) If first block is dummy, no adjustement needed.
         * (2) If second block is dummy, simply adjust size.
         */

        if (_IS_DUMMY(pdesc1))
                goto link;

        if (_IS_DUMMY(pdesc2)) {
                pdesc2->pblock = (char *)_ADDRESS(pdesc1) + size;
                _SET_DUMMY(pdesc2);
                goto link;
                }


        /*
         * See how much space is between this block and the next one.
         */

        diff = ( (char *) _ADDRESS(pdesc2) -
                 (char *) (dummyaddr = (char *) _ADDRESS(pdesc1) + size) );

        if (diff != 0) {

                /*
                 * There is some space between the two blocks.  Insert
                 * a fake "in use" block.  Remember, there is no 'back
                 * pointer' in dummy blocks.
                 */

                pdummydesc = *((*pppdesc)++);

                pdummydesc->pblock = (char *) dummyaddr;
                _SET_DUMMY(pdummydesc);

                pdesc1->pnextdesc = pdummydesc;
                pdesc1 = pdummydesc;

                }

        /*
         * Put the new block in the heap.
         */

        link:
                pdesc1->pnextdesc = pdesc2;

}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\helperfunc.cpp ===
/***
*crtexe.c - Initialization for console EXE using CRT DLL
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This is the actual startup routine for apps linking to the CRT DLL.
*       It calls the user's main routine [w]main() or [w]WinMain after
*       performing C Run-Time Library initialization.
*
*       With ifdefs, this source file also provides the source code for:
*       wcrtexe.c   the startup routine for console apps with wide chars
*       crtexew.c   the startup routine for Windows apps
*       wcrtexew.c  the startup routine for Windows apps with wide chars
*
*******************************************************************************/

#undef  CRTDLL
#ifdef MRTDLL
#undef MRTDLL
#endif  /* MRTDLL */

#define SPECIAL_CRTEXE

#include <cruntime.h>
#include <internal.h>
#include <math.h>
#include <stdlib.h>
#include <float.h>

#pragma warning(disable:4439)   // C4439: function with a managed parameter must have a __clrcall calling convention

extern "C"
{
int __defaultmatherr;
_MRTIMP void __cdecl __setusermatherr_m( int (__clrcall *)(struct _exception *) );
}

extern "C" void __clrcall __set_matherr()
{
    if ( !__defaultmatherr )
        __setusermatherr_m(_matherr);
}

#ifdef ENABLE_EHTRACE
int __ehtrace_level;
#endif  /* ENABLE_EHTRACE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\initcoll.c ===
/***
*initcoll.c - contains __init_collate
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_collate().
*
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*******************************************************************************/

#include <windows.h>
#include <locale.h>
#include <setlocal.h>

/***
*int __init_collate() - initialization for LC_COLLATE locale category.
*
*Purpose:
*       The LC_COLLATE category currently requires no initialization.
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_collate (
        pthreadlocinfo ploci
        )
{
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapdump.c ===
/***
*heapdump.c -  Output the heap data bases
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Display the heap data bases.
*
*       NOTE:  This module is NOT released with the C libs.  It is for
*       debugging purposes only.
*
*******************************************************************************/

#ifndef WINHEAP

#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdio.h>


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\gs_report.c ===
/***
*gs_report.c - Report a /GS security check failure
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       Defines function used to report a security check failure.
*       This file corresponds to gs_report.c in the Windows sources.
*
*       Entrypoints:
*            __report_gsfailure
*
*******************************************************************************/

#include <windows.h>

#if defined (_CRTBLD) && !defined (_SYSCRT)
#include <dbgint.h>     /* needed for _CRT_DEBUGGER_HOOK */
#endif  /* defined (_CRTBLD) && !defined (_SYSCRT) */

#if defined (_AMD64_)

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG64 ControlPc,
    OUT PULONG64 ImageBase,
    IN OUT PVOID HistoryTable OPTIONAL
    );

PVOID
RtlVirtualUnwind (
    IN ULONG HandlerType,
    IN ULONG64 ImageBase,
    IN ULONG64 ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PVOID *HandlerData,
    OUT PULONG64 EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL
    );

#define UNW_FLAG_NHANDLER 0x00

#elif defined (_IA64_)

#define PSR_RI      41
#define IPSR_RI_MASK ((ULONGLONG)0x3 << PSR_RI)      // PSR.ri (42:41)
#define PROGRAM_COUNTER_TO_CONTEXT(Context, ProgramCounter) \
    ((Context)->StIIP = (ProgramCounter) & ~(0x0fI64), \
     (Context)->StIPSR &= ~(IPSR_RI_MASK), \
     (Context)->StIPSR |= ((ProgramCounter) & 0x0cI64) << (PSR_RI-2), \
     (Context)->StIPSR = ((Context)->StIPSR & (IPSR_RI_MASK)) == (IPSR_RI_MASK) ? \
                         (Context)->StIPSR & ~(IPSR_RI_MASK) : (Context)->StIPSR )

typedef struct _FRAME_POINTERS {
    ULONGLONG MemoryStackFp;
    ULONGLONG BackingStoreFp;
} FRAME_POINTERS, *PFRAME_POINTERS;

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONGLONG ControlPc,
    OUT PULONGLONG ImageBase,
    OUT PULONGLONG TargetGp
    );

ULONGLONG
RtlVirtualUnwind (
    IN ULONGLONG ImageBase,
    IN ULONGLONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PFRAME_POINTERS EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL
    );

#endif  /* defined (_IA64_) */

typedef LONG NTSTATUS;
#define STATUS_STACK_BUFFER_OVERRUN      ((NTSTATUS)0xC0000409L)

extern UINT_PTR __security_cookie;
extern UINT_PTR __security_cookie_complement;

/*
 * Use global memory for the exception and context records, and any other local
 * state needed by __report_gsfailure.  We're not worried about multithread
 * issues here - we're going to die anyway, and it saves us from consuming a
 * good chunk of stack, as well as potentially overwriting useful data in the
 * stack memory dump.
 */

static EXCEPTION_RECORD         GS_ExceptionRecord;
static CONTEXT                  GS_ContextRecord;
static const EXCEPTION_POINTERS GS_ExceptionPointers = {
    &GS_ExceptionRecord,
    &GS_ContextRecord
};

#if defined (_CRTBLD) && !defined (_SYSCRT)
static BOOL DebuggerWasPresent;
#endif  /* defined (_CRTBLD) && !defined (_SYSCRT) */

/***
*__report_gsfailure() - Report security error.
*
*Purpose:
*       A /GS security error has been detected.  We save the registers in a
*       CONTEXT struct & call UnhandledExceptionFilter to display a message
*       to the user (invoke Watson handling) and terminate the program.
*
*       NOTE: __report_gsfailure should not be called directly.  Instead, it
*       should be entered due to a failure detected by __security_check_cookie.
*       That's because __security_check_cookie may perform more checks than
*       just a mismatch against the global security cookie, and because
*       the context captured by __report_gsfailure is unwound assuming that
*       __security_check_cookie was used to detect the failure.
*
*Entry:
*       ULONGLONG StackCookie - the local cookie, passed in as actual argument
*       on AMD64 and IA64 only.  On x86, the local cookie is available in ECX,
*       but since __report_gsfailure isn't __fastcall, it isn't a true
*       argument, and we must flush ECX to the context record quickly.
*
*Exit:
*       Does not return.
*
*Exceptions:
*
*******************************************************************************/

#pragma optimize("", off)   /* force an EBP frame on x86, no stack packing */

#if defined (_X86_)
__declspec(noreturn) void __cdecl __report_gsfailure(void)
#else  /* defined (_X86_) */
__declspec(noreturn) void __cdecl __report_gsfailure(ULONGLONG StackCookie)
#endif  /* defined (_X86_) */
{
    volatile UINT_PTR cookie[2];

    /*
     * Set up a fake exception, and report it via UnhandledExceptionFilter.
     * We can't raise a true exception because the stack (and therefore
     * exception handling) can't be trusted after a buffer overrun.  The
     * exception should appear as if it originated after the call to
     * __security_check_cookie, so it is attributed to the function where the
     * buffer overrun was detected.
     */

#if defined (_X86_)
    /*
     * On x86, we reserve some extra stack which won't be used.  That is to
     * preserve as much of the call frame as possible when the function with
     * the buffer overrun entered __security_check_cookie with a JMP instead of
     * a CALL, after the calling frame has been released in the epilogue of
     * that function.
     */

    volatile ULONG dw[(sizeof(CONTEXT) + sizeof(EXCEPTION_RECORD))/sizeof(ULONG)];

    /*
     * Save the state in the context record immediately.  Hopefully, since
     * opts are disabled, this will happen without modifying ECX, which has
     * the local cookie which failed the check.
     */

    __asm {
        mov dword ptr [GS_ContextRecord.Eax], eax
        mov dword ptr [GS_ContextRecord.Ecx], ecx
        mov dword ptr [GS_ContextRecord.Edx], edx
        mov dword ptr [GS_ContextRecord.Ebx], ebx
        mov dword ptr [GS_ContextRecord.Esi], esi
        mov dword ptr [GS_ContextRecord.Edi], edi
        mov word ptr [GS_ContextRecord.SegSs], ss
        mov word ptr [GS_ContextRecord.SegCs], cs
        mov word ptr [GS_ContextRecord.SegDs], ds
        mov word ptr [GS_ContextRecord.SegEs], es
        mov word ptr [GS_ContextRecord.SegFs], fs
        mov word ptr [GS_ContextRecord.SegGs], gs
        pushfd
        pop [GS_ContextRecord.EFlags]

        /*
         * Set the context EBP/EIP/ESP to the values which would be found
         * in the caller to __security_check_cookie.
         */

        mov eax, [ebp]
        mov dword ptr [GS_ContextRecord.Ebp], eax
        mov eax, [ebp+4]
        mov dword ptr [GS_ContextRecord.Eip], eax
        lea eax, [ebp+8]
        mov dword ptr [GS_ContextRecord.Esp], eax

        /*
         * Make sure the dummy stack space looks referenced.
         */

        mov eax, dword ptr dw
    }

    GS_ContextRecord.ContextFlags = CONTEXT_CONTROL;

    GS_ExceptionRecord.ExceptionAddress  = (PVOID)(ULONG_PTR)GS_ContextRecord.Eip;

#elif defined (_AMD64_)
    /*
     * On AMD64/EM64T, __security_check_cookie branched to __report_gsfailure
     * with a JMP, not CALL, so call RtlVirtualUnwind once to get the context
     * of the caller to __security_check_cookie, which is the function with
     * the buffer overrun.
     */

    ULONG64 ControlPc;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 ImageBase;

    RtlCaptureContext(&GS_ContextRecord);
    ControlPc = GS_ContextRecord.Rip;
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, NULL);
    if (FunctionEntry != NULL) {
        RtlVirtualUnwind(UNW_FLAG_NHANDLER,
                         ImageBase,
                         ControlPc,
                         FunctionEntry,
                         &GS_ContextRecord,
                         &HandlerData,
                         &EstablisherFrame,
                         NULL);
    } else {
        GS_ContextRecord.Rip = (ULONGLONG) _ReturnAddress();
        GS_ContextRecord.Rsp = (ULONGLONG) _AddressOfReturnAddress()+8;
    }

    GS_ExceptionRecord.ExceptionAddress = (PVOID)GS_ContextRecord.Rip;
    GS_ContextRecord.Rcx = StackCookie;

#elif defined (_IA64_)
    /*
     * On IA64, __security_check_cookie branched to __report_gsfailure with a
     * true call, so call RtlVirtualUnwind twice to get the context of the
     * caller to __security_check_cookie, which is the function with the
     * buffer overrun.
     */

    ULONGLONG ControlPc;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONGLONG ImageBase;
    ULONGLONG TargetGp;
    int frames;

    RtlCaptureContext(&GS_ContextRecord);
    ControlPc = GS_ContextRecord.BrRp;

    for (frames = 0; frames < 2; ++frames)
    {
        FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, &TargetGp);
        if (FunctionEntry == NULL)
        {
            break;
        }
        ControlPc = RtlVirtualUnwind(ImageBase,
                                     ControlPc,
                                     FunctionEntry,
                                     &GS_ContextRecord,
                                     &InFunction,
                                     &EstablisherFrame,
                                     NULL);
        PROGRAM_COUNTER_TO_CONTEXT(&GS_ContextRecord, ControlPc);
    }

    GS_ExceptionRecord.ExceptionAddress  = (PVOID)ControlPc;
    GS_ContextRecord.IntV0 = StackCookie;

#else  /* defined (_IA64_) */
#error Unknown platform!
#endif  /* defined (_IA64_) */

    GS_ExceptionRecord.ExceptionCode  = STATUS_STACK_BUFFER_OVERRUN;
    GS_ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;

    /*
     * Save the global cookie and cookie complement locally - using an array
     * to defeat any potential stack-packing.
     */

    cookie[0] = __security_cookie;
    cookie[1] = __security_cookie_complement;

#if defined (_CRTBLD) && !defined (_SYSCRT)
    DebuggerWasPresent = IsDebuggerPresent();
    _CRT_DEBUGGER_HOOK(_CRT_DEBUGGER_GSFAILURE);
#endif  /* defined (_CRTBLD) && !defined (_SYSCRT) */

    /* Make sure any filter already in place is deleted. */
    SetUnhandledExceptionFilter(NULL);

    UnhandledExceptionFilter((EXCEPTION_POINTERS *)&GS_ExceptionPointers);

#if defined (_CRTBLD) && !defined (_SYSCRT)
    /*
     * If we make it back from Watson, then the user may have asked to debug
     * the app.  If we weren't under a debugger before invoking Watson,
     * re-signal the VS CRT debugger hook, so a newly attached debugger gets
     * a chance to break into the process.
     */
    if (!DebuggerWasPresent)
    {
        _CRT_DEBUGGER_HOOK(_CRT_DEBUGGER_GSFAILURE);
    }
#endif  /* defined (_CRTBLD) && !defined (_SYSCRT) */

    TerminateProcess(GetCurrentProcess(), STATUS_STACK_BUFFER_OVERRUN);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\initcrit.c ===
/***
*initcrit.c - CRT wrapper for InitializeCriticalSectionAndSpinCount
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains __crtInitCritSecAndSpinCount, a wrapper for
*       the Win32 API InitializeCriticalSectionAndSpinCount which is only
*       available on NT4SP3 or better.
*
*       *** For internal use only ***
*
*******************************************************************************/


#include <cruntime.h>
#include <windows.h>
#include <internal.h>
#include <rterr.h>
#include <stdlib.h>

typedef
BOOL
(WINAPI * PFN_INIT_CRITSEC_AND_SPIN_COUNT) (
    PCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);

static PFN_INIT_CRITSEC_AND_SPIN_COUNT __pfnInitCritSecAndSpinCount;

/***
*void _initp_misc_initcrit(void*)
*
*Purpose:
*       Initialize static pointer to function
*
*Entry:
*       The per-process encoded value for the NULL pointer.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _initp_misc_initcrit(void* enull)
{
    __pfnInitCritSecAndSpinCount = (PFN_INIT_CRITSEC_AND_SPIN_COUNT) enull;
}

/***
*int __crtInitCritSecAndSpinCount() - initialize critical section
*
*Purpose:
*       Calls InitializeCriticalSectionAndSpinCount, if available, otherwise
*       InitializeCriticalSection.  On multiprocessor systems, a spin count
*       should be used with critical sections, but the appropriate APIs are
*       only available on NT4SP3 or later.
*
*       Also handles the out of memory condition which is possible with
*       InitializeCriticalSection[AndSpinCount].
*
*Entry:
*       PCRITICAL_SECTION lpCriticalSection - ptr to critical section
*       DWORD dwSpinCount - initial spin count setting
*
*Exit:
*       Returns FALSE and sets Win32 last-error code to ERROR_NOT_ENOUGH_MEMORY
*       if InitializeCriticalSection[AndSpinCount] fails.
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __crtInitCritSecAndSpinCount (
    PCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
    )
{
    int ret;

    __try {
        /*
         * Call the real InitializeCriticalSectionAndSpinCount
         */
        ret = InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
    }
    __except (_exception_code()== STATUS_NO_MEMORY ? EXCEPTION_EXECUTE_HANDLER:EXCEPTION_CONTINUE_SEARCH) {
        /*
         * Initialization failed by raising an exception, which is probably
         * STATUS_NO_MEMORY.  It is not safe to set the CRT errno to ENOMEM,
         * since the per-thread data may not yet exist.  Instead, set the Win32
         * error which can be mapped to ENOMEM later.
         */
        if (GetExceptionCode() == STATUS_NO_MEMORY) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
        ret = FALSE;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapinit.c ===
/***
*heapinit.c -  Initialize the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#ifdef WINHEAP

#include <cruntime.h>
#include <malloc.h>
#include <stdlib.h>
#include <winheap.h>
#include <internal.h>

HANDLE _crtheap=NULL;

/*
 * Dummy definition of _amblksiz. Included primarily so the dll will build
 * without having to change crtlib.c (there is an access function for _amblksiz
 * defined in crtlib.c).
 */
unsigned int _amblksiz = BYTES_PER_PARA;

#ifndef _WIN64

int __active_heap;

#ifdef CRTDLL

void __cdecl _GetLinkerVersion(LinkerVersion * plv)
{
        PIMAGE_DOS_HEADER   pidh;
        PIMAGE_NT_HEADERS   pinh;

        plv->dw = 0;
        pidh = (PIMAGE_DOS_HEADER) _crt_wait_module_handle(NULL);

        if ( pidh->e_magic != IMAGE_DOS_SIGNATURE || pidh->e_lfanew == 0)
            return;

        pinh = (PIMAGE_NT_HEADERS)(((PBYTE)pidh) + pidh->e_lfanew);

        plv->bverMajor = pinh->OptionalHeader.MajorLinkerVersion;
        plv->bverMinor = pinh->OptionalHeader.MinorLinkerVersion;
}

#endif  /* CRTDLL */

/***
*__heap_select() - Choose from the V6, V5 or system heaps
*
*Purpose:
*       Check OS, environment and build bits to determine appropriate
*       small-block heap for the app.
*
*Entry:
*       <void>
*Exit:
*       Returns __V6_HEAP, __V5_HEAP or __SYSTEM_HEAP
*
*Exceptions:
*       none
*
*******************************************************************************/

int __cdecl __heap_select(void)
{
        char *env_heap_type = NULL;
#ifdef CRTDLL
        DWORD HeapStringSize=0;
        DWORD actual_size=0;
        char *cp=NULL;
        char *env_heap_select_string = NULL;
        int heap_choice=0;
#endif  /* CRTDLL */

#ifdef CRTDLL

        // First, check the environment variable override

        if (HeapStringSize = GetEnvironmentVariableA(__HEAP_ENV_STRING, env_heap_select_string, 0))
        {
            env_heap_select_string = HeapAlloc(GetProcessHeap(), 0, HeapStringSize);
            if (env_heap_select_string)
            {
                actual_size=GetEnvironmentVariableA(__HEAP_ENV_STRING, env_heap_select_string, HeapStringSize);
                if (actual_size>0 && actual_size<=HeapStringSize)
                {
                    for (cp = env_heap_select_string; *cp; ++cp)
                        if ('a' <= *cp && *cp <= 'z')
                            *cp += 'A' - 'a';
                    if (!strncmp(__GLOBAL_HEAP_SELECTOR,env_heap_select_string,sizeof(__GLOBAL_HEAP_SELECTOR)-1))
                        env_heap_type = env_heap_select_string;
                    else
                    {
                        char *env_app_name = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH+1);
                        if (env_app_name) {
                            GetModuleFileName(NULL,env_app_name,sizeof(env_app_name)-1);
                            for (cp = env_app_name; *cp; ++cp)
                                if ('a' <= *cp && *cp <= 'z')
                                    *cp += 'A' - 'a';
                            env_heap_type = strstr(env_heap_select_string,env_app_name);
                            HeapFree(GetProcessHeap(), 0, env_app_name);
                        }
                    }
                    if (env_heap_type)
                    {
                        if (env_heap_type = strchr(env_heap_type,','))
                        {
                            // Convert ASCII heap code to integer inline, since
                            // strtol would try to use the heap (for locale info).
                            cp = ++env_heap_type;
                            while (*cp == ' ')
                                ++cp;

                            heap_choice = 0;
                            while (*cp >= '0' && *cp <= '9')
                                heap_choice = heap_choice * 10 + *cp++ - '0';

                            if ( (heap_choice == __V5_HEAP) ||
                                 (heap_choice == __V6_HEAP) ||
                                 (heap_choice == __SYSTEM_HEAP) )
                            {
                                HeapFree(GetProcessHeap(), 0, env_heap_select_string);
                                return heap_choice;
                            }
                        }
                    }
                }
                HeapFree(GetProcessHeap(), 0, env_heap_select_string);
            }
        }
#endif  /* CRTDLL */

        return __SYSTEM_HEAP;
}

#endif  /* _WIN64 */

/***
*_heap_init() - Initialize the heap
*
*Purpose:
*       Setup the initial C library heap.
*
*       NOTES:
*       (1) This routine should only be called once!
*       (2) This routine must be called before any other heap requests.
*
*Entry:
*       <void>
*Exit:
*       Returns 1 if successful, 0 otherwise.
*
*Exceptions:
*       If heap cannot be initialized, the program will be terminated
*       with a fatal runtime error.
*
*******************************************************************************/

int __cdecl _heap_init (
        int mtflag
        )
{
#if defined _M_AMD64 || defined _M_IA64
        // HEAP_NO_SERIALIZE is incompatible with the LFH heap
        mtflag = 1;
#endif  /* defined _M_AMD64 || defined _M_IA64 */
        //  Initialize the "big-block" heap first.
        if ( (_crtheap = HeapCreate( mtflag ? 0 : HEAP_NO_SERIALIZE,
                                     BYTES_PER_PAGE, 0 )) == NULL )
            return 0;

#ifndef _WIN64
        // Pick a heap, any heap
        __active_heap = __heap_select();

        if ( __active_heap == __V6_HEAP )
        {
            //  Initialize the small-block heap
            if (__sbh_heap_init(MAX_ALLOC_DATA_SIZE) == 0)
            {
                HeapDestroy(_crtheap);
                _crtheap=NULL;
                return 0;
            }
        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP )
        {
            if ( __old_sbh_new_region() == NULL )
            {
                HeapDestroy( _crtheap );
                _crtheap=NULL;
                return 0;
            }
        }
#endif  /* CRTDLL */
#elif defined _M_AMD64 || defined _M_IA64
        {
            // Enable the Low Fragmentation Heap for AMD64 and IA64 by default
            // It's the 8 byte overhead heap, and has generally better
            // performance charateristics than the 16 byte overhead heap,
            // particularly for apps that perform lots of small allocations
            ULONG HeapType = 2;
            HeapSetInformation(_crtheap, HeapCompatibilityInformation,
                               &HeapType, sizeof(HeapType));
        }
#endif  /* defined _M_AMD64 || defined _M_IA64 */

        return 1;
}

/***
*_heap_term() - return the heap to the OS
*
*Purpose:
*
*       NOTES:
*       (1) This routine should only be called once!
*       (2) This routine must be called AFTER any other heap requests.
*
*Entry:
*       <void>
*Exit:
*       <void>
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _heap_term (void)
{
#ifndef _WIN64
        //  if it has been initialized, destroy the small-block heap
        if ( __active_heap == __V6_HEAP )
        {
            PHEADER pHeader = __sbh_pHeaderList;
            int     cntHeader;

            //  scan through all the headers
            for (cntHeader = 0; cntHeader < __sbh_cntHeaderList; cntHeader++)
            {
                //  decommit and release the address space for the region
                VirtualFree(pHeader->pHeapData, 0, MEM_RELEASE);

                //  free the region data structure
                HeapFree(_crtheap, 0, pHeader->pRegion);

                pHeader++;
            }
            //  free the header list
            HeapFree(_crtheap, 0, __sbh_pHeaderList);
        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP )
        {
            __old_sbh_region_t *preg = &__old_small_block_heap;

            //  Release the regions of the small-block heap
            do
            {
                if ( preg->p_pages_begin != NULL )
                    VirtualFree( preg->p_pages_begin, 0, MEM_RELEASE );
            }
            while ( (preg = preg->p_next_region) != &__old_small_block_heap );
        }
#endif  /* CRTDLL */
#endif  /* _WIN64 */

        //  destroy the large-block heap
        HeapDestroy(_crtheap);
        _crtheap=NULL;
}

/***
*_get_heap_handle() - Get the HANDLE to the Win32 system heap used by the CRT
*
*Purpose:
*       Retrieve the HANDLE to the Win32 system heap used by the CRT.
*
*Entry:
*       <void>
*Exit:
*       Returns the CRT heap HANDLE as an intptr_t
*
*Exceptions:
*
*******************************************************************************/

intptr_t __cdecl _get_heap_handle(void)
{
    _ASSERTE(_crtheap);
    return (intptr_t)_crtheap;
}

#else  /* WINHEAP */


#include <cruntime.h>
#include <oscalls.h>
#include <dos.h>
#include <heap.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

/*
 * Heap descriptor
 */

struct _heap_desc_ _heap_desc = {
        &_heap_desc.sentinel,           /* pfirstdesc */
        &_heap_desc.sentinel,           /* proverdesc */
        NULL,                           /* emptylist */
        NULL,                           /* sentinel.pnextdesc */
        NULL                            /* sentinel.pblock */
        };

/*
 * Array of region structures
 * [Note: We count on the fact that this is always initialized to zero
 * by the compiler.]
 */

struct _heap_region_ _heap_regions[_HEAP_REGIONMAX];

void ** _heap_descpages;        /* linked list of pages used for descriptors */

/*
 * Control parameter locations
 */

unsigned int _heap_resetsize = 0xffffffff;

/* NOTE: Currenlty, _heap_growsize is a #define to _amblksiz */
unsigned int _heap_growsize   = _HEAP_GROWSIZE;         /* region inc size */
unsigned int _heap_regionsize = _HEAP_REGIONSIZE_L;     /* region size */
unsigned int _heap_maxregsize = _HEAP_MAXREGSIZE_L;     /* max region size */

/***
*_heap_init() - Initialize the heap
*
*Purpose:
*       Setup the initial C library heap.  All necessary memory and
*       data bases are init'd appropriately so future requests work
*       correctly.
*
*       NOTES:
*       (1) This routine should only be called once!
*       (2) This routine must be called before any other heap requests.
*
*
*Entry:
*       <void>
*Exit:
*       <void>
*
*Exceptions:
*       If heap cannot be initialized, the program will be terminated
*       with a fatal runtime error.
*
*******************************************************************************/

void __cdecl _heap_init (
        void
        )
{
}



/***
*_heap_term() - Clean-up the heap
*
*Purpose:
*       This routine will decommit and release ALL of the CRT heap.
*       All memory malloc-ed by the CRT will then be invalid.
*
*       NOTES:
*       (1) This routine should only be called once!
*       (2) This routine must be called AFTER any other heap requests.
*
*Entry:
*       <void>
*Exit:
*       <void>
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _heap_term (
        void
        )
{
    int index;
    void **pageptr;

    /*
     * Loop through the region descriptor table, decommitting
     * and releasing (freeing up) each region that is in use.
     */

    for ( index=0 ; index < _HEAP_REGIONMAX ; index++ ) {
        void * regbase ;

        if ( (regbase = _heap_regions[index]._regbase)
          && VirtualFree(regbase, 0, MEM_RELEASE) )
                regbase = _heap_regions[index]._regbase = NULL ;
    }

    /*
     * Now we need to decommit and release the pages used for descriptors
     * _heap_descpages points to the head of a singly-linked list of the pages.
     */

    pageptr = _heap_descpages;

    while ( pageptr ) {
        void **nextpage;

        nextpage = *pageptr;

        if(!VirtualFree(pageptr, 0, MEM_RELEASE))
            break;      /* if the linked list is corrupted, give up */

        pageptr = nextpage;
    }

}



/***
* _heap_grow_emptylist() - Grow the empty heap descriptor list
*
*Purpose:
*       (1) Get memory from OS
*       (2) Form it into a linked list of empty heap descriptors
*       (3) Attach it to the master empty list
*
*       NOTE:  This routine assumes that the emptylist is NULL
*       when called (i.e., there are no available empty heap descriptors).
*
*Entry:
*       (void)
*
*Exit:
*       1, if the empty heap descriptor list was grown
*       0, if the empty heap descriptor list could not be grown.
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl _heap_grow_emptylist (
        void
        )
{
        REG1 _PBLKDESC first;
        REG2 _PBLKDESC next;
        _PBLKDESC last;

        /*
         * Get memory for the new empty heap descriptors
         *
         * Note that last is used to hold the returned pointer because
         * first (and next) are register class.
         */

        if ( !(last = VirtualAlloc(NULL,
                                   _HEAP_EMPTYLIST_SIZE,
                                   MEM_COMMIT,
                                   PAGE_READWRITE)) )
                return 0;

        /*
         * Add this descriptor block to the front of the list
         *
         * Advance "last" to skip over the
         */

        *(void **)last = _heap_descpages;
        _heap_descpages = (void **)(last++);


        /*
         * Init the empty heap descriptor list.
         */

        _heap_desc.emptylist = first = last;


        /*
         * Carve the memory into an empty list
         */

        last = (_PBLKDESC) ((char *) first + _HEAP_EMPTYLIST_SIZE - 2 * sizeof(_BLKDESC));
        next = (_PBLKDESC) ((char *) first + sizeof(_BLKDESC));

        while ( first < last ) {

                /* Init this descriptor */
                first->pnextdesc = next;

                /* onto the next block */

                first = next++;

        }

        /*
         * Take care of the last descriptor (end of the empty list)
         */

        last->pnextdesc = NULL;


        return 1;
}


/***
*__getempty() - get an empty heap descriptor
*
*Purpose:
*       Get a descriptor from the list of empty heap descriptors. If the list
*       is empty, call _heap_grow_emptylist.
*
*Entry:
*       no arguments
*
*Exit:
*       If successful, a pointer to the descriptor is returned.
*       Otherwise, NULL is returned.
*
*Exceptions:
*
*******************************************************************************/

_PBLKDESC __cdecl __getempty(
        void
        )
{
        _PBLKDESC pdesc;

        if ( (_heap_desc.emptylist == NULL) && (_heap_grow_emptylist()
              == 0) )
                return NULL;

        pdesc = _heap_desc.emptylist;

        _heap_desc.emptylist = pdesc->pnextdesc;

        return pdesc;
}

#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapgrow.c ===
/***
*heapgrow.c - Grow the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Get memory from OS and add to the heap.
*
*******************************************************************************/

#ifndef WINHEAP

#include <cruntime.h>
#include <oscalls.h>
#include <heap.h>
#include <malloc.h>
#include <stdlib.h>

static int __cdecl _heap_new_region(unsigned, size_t);


/***
*_heap_grow() - Grow the heap
*
*Purpose:
*       Get memory from the OS and add it to the heap.
*
*Entry:
*       size_t _size = user's block request
*
*Exit:
*        0 = success, new mem is in the heap
*       -1 = failure
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heap_grow (
        REG1 size_t size
        )
{
        REG2 int index;
        int free_entry = -1;

        /*
         * Bump size to include header and round to nearest page boundary.
         */

        size += _HDRSIZE;
        size = _ROUND2(size,_PAGESIZE_);

        /*
         * Loop through the region table looking for an existing region
         * we can grow.  Remember the index of the first null region entry.
         *
         * size = size of grow request
         */

        for (index = 0; index < _HEAP_REGIONMAX; index++) {

                if ( (_heap_regions[index]._totalsize -
                    _heap_regions[index]._currsize) >= size )

                        /*
                         * Grow this region to satisfy the request.
                         */

                        return( _heap_grow_region(index, size) );


                if ( (free_entry == -1) &&
                    (_heap_regions[index]._regbase == NULL) )

                        /*
                         * Remember 1st free table entry for later
                         */

                        free_entry = index;

        }

        /*
         * Could not find any existing regions to grow.  Try to
         * get a new region.
         *
         * size = size of grow request
         * free_entry = index of first free entry in table
         */

        if ( free_entry >= 0 )

                /*
                 * Get a new region to satisfy the request.
                 */

                return( _heap_new_region(free_entry, size) );

        else
                /*
                 * No free table entries: return an error.
                 */

                return(-1);

}


/***
*_heap_new_region() - Get a new heap region
*
*Purpose:
*       Get a new heap region and put it in the region table.
*       Also, grow it large enough to support the caller's
*       request.
*
*       NOTES:
*       (1) Caller has verified that there is room in the _heap_region
*       table for another region.
*       (2) The caller must have rounded the size to a page boundary.
*
*Entry:
*       int index = index in table where new region data should go
*       size_t size = size of request (this has been rounded to a
*                       page-sized boundary)
*
*Exit:
*        0 = success
*       -1 = failure
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl _heap_new_region (
        REG1 unsigned index,
        size_t size
        )
{
        void * region;
        REG2 unsigned int regsize;


        /*
         * Round the heap region size to a page boundary (in case
         * the user played with it).
         */

        regsize = _ROUND2(_heap_regionsize, _PAGESIZE_);

        /*
         * To acommodate large users, request twice
         * as big a region next time around.
         */

        if ( _heap_regionsize < _heap_maxregsize )
                _heap_regionsize *= 2 ;

        /*
         * See if region is big enough for request
         */

        if (regsize < size)
                regsize = size;

        /*
         * Go get the new region
         */

        if (!(region = VirtualAlloc(NULL, regsize, MEM_RESERVE,
        PAGE_READWRITE)))
                goto error;

        /*
         * Put the new region in the table.
         */

         _heap_regions[index]._regbase = region;
         _heap_regions[index]._totalsize = regsize;
         _heap_regions[index]._currsize = 0;


        /*
         * Grow the region to satisfy the size request.
         */

        if (_heap_grow_region(index, size) != 0) {

                /*
                 * Ouch.  Allocated a region but couldn't commit
                 * any pages in it.  Free region and return error.
                 */

                _heap_free_region(index);
                goto error;
        }


        /*
         * Good return
         */

        /* done:   unreferenced label to be removed */
                return(0);

        /*
         * Error return
         */

        error:
                return(-1);

}


/***
*_heap_grow_region() - Grow a heap region
*
*Purpose:
*       Grow a region and add the new memory to the heap.
*
*       NOTES:
*       (1) The caller must have rounded the size to a page boundary.
*
*Entry:
*       unsigned index = index of region in the _heap_regions[] table
*       size_t size = size of request (this has been rounded to a
*                       page-sized boundary)
*
*Exit:
*        0 = success
*       -1 = failure
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heap_grow_region (
        REG1 unsigned index,
        size_t size
        )
{
        size_t left;
        REG2 size_t growsize;
        void * base;
        unsigned dosretval;


        /*
         * Init some variables
         * left = space left in region
         * base = base of next section of region to validate
         */

        left = _heap_regions[index]._totalsize -
                _heap_regions[index]._currsize;

        base = (char *) _heap_regions[index]._regbase +
                _heap_regions[index]._currsize;

        /*
         * Make sure we can satisfy request
         */

        if (left < size)
                goto error;

        /*
         * Round size up to next _heap_growsize boundary.
         * (Must round _heap_growsize itself to page boundary, in
         * case user set it himself).
         */

        growsize = _ROUND2(_heap_growsize, _PAGESIZE_);
        growsize = _ROUND(size, growsize);

        if (left < growsize)
                growsize = left;

        /*
         * Validate the new portion of the region
         */

        if (!VirtualAlloc(base, growsize, MEM_COMMIT, PAGE_READWRITE))
                dosretval = GetLastError();
        else
                dosretval = 0;

        if (dosretval)
                /*
                 * Error committing pages.  If out of memory, return
                 * error, else abort.
                 */

                if (dosretval == ERROR_NOT_ENOUGH_MEMORY)
                        goto error;
                else
                        _heap_abort();


        /*
         * Update the region data base
         */

        _heap_regions[index]._currsize += growsize;




        /*
         * Add the memory to the heap
         */

        if (_heap_addblock(base, growsize) != 0)
                _heap_abort();


        /*
         * Good return
         */

        /* done:   unreferenced label to be removed */
                return(0);

        /*
         * Error return
         */

        error:
                return(-1);

}


/***
*_heap_free_region() - Free up a region
*
*Purpose:
*       Return a heap region to the OS and zero out
*       corresponding region data entry.
*
*Entry:
*       int index = index of region to be freed
*
*Exit:
*       void
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _heap_free_region (
        REG1 int index
        )
{

        /*
         * Give the memory back to the OS
         */

        if (!VirtualFree(_heap_regions[index]._regbase, 0, MEM_RELEASE))
                _heap_abort();

        /*
         * Zero out the heap region entry
         */

        _heap_regions[index]._regbase = NULL;
        _heap_regions[index]._currsize =
        _heap_regions[index]._totalsize = 0;

}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\heapmin.c ===
/***
*heapmin.c - Minimize the heap
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Minimize the heap freeing as much memory as possible back
*       to the OS.
*
*******************************************************************************/


#ifdef WINHEAP


#include <cruntime.h>
#include <windows.h>
#include <errno.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdlib.h>
#include <winheap.h>

/***
*_heapmin() - Minimize the heap
*
*Purpose:
*       Minimize the heap freeing as much memory as possible back
*       to the OS.
*
*Entry:
*       (void)
*
*Exit:
*
*        0 = no error has occurred
*       -1 = an error has occurred (errno is set)
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapmin(void)
{
#ifndef _WIN64
        if ( __active_heap == __V6_HEAP ) {
            _mlock( _HEAP_LOCK );
            __try {
            __sbh_heapmin();
            }
            __finally {
                _munlock( _HEAP_LOCK );
            }
        }
#ifdef CRTDLL
        else if ( __active_heap == __V5_HEAP ) {
            /*
             * Minimize the small-block heap by calling _sbh_decommit_pages()
             * with a big enough count to ensure every page which can be
             * decommitted, is.
             */
            _mlock( _HEAP_LOCK );
            __try {
            __old_sbh_decommit_pages( 2 * _OLD_PAGES_PER_COMMITMENT );
            }
            __finally {
                _munlock( _HEAP_LOCK );
            }
        }
#endif  /* CRTDLL */
#endif  /* _WIN64 */

        if ( HeapCompact( _crtheap, 0 ) == 0 ) {

            if ( GetLastError() == ERROR_CALL_NOT_IMPLEMENTED ) {
                _doserrno = ERROR_CALL_NOT_IMPLEMENTED;
                errno = ENOSYS;
            }
            return -1;
        }
        else {
            return 0;
        }
}

#else  /* WINHEAP */


#include <cruntime.h>
#include <heap.h>
#include <malloc.h>
#include <mtdll.h>
#include <stdlib.h>
#include <windows.h>

static int __cdecl _heapmin_region(int, void *, _PBLKDESC);
static void __cdecl _free_partial_region(_PBLKDESC, unsigned, int);

/***
*_heapmin() - Minimize the heap
*
*Purpose:
*   Minimize the heap freeing as much memory as possible back
*   to the OS.
*
*Entry:
*   (void)
*
*Exit:
*    0 = no error has occurred
*   -1 = an error has occurred (errno is set)
*
*Exceptions:
*
*******************************************************************************/

int __cdecl _heapmin(void)
{
    REG1 int index;
    _PBLKDESC pdesc;
    REG2 _PBLKDESC pdesc2;
    void * regend;
    int region_min_count = 0;

    /*
     * Lock the heap
     */

    _mlock(_HEAP_LOCK);

    /*
     * Coalesce the heap (should return NULL)
     */

    if ( _heap_search((unsigned)_HEAP_COALESCE) != NULL )
        _heap_abort();

    /*
     * Loop through the region descriptor table freeing as much
     * memory to the OS as possible.
     */

    for ( index=0 ; index < _HEAP_REGIONMAX ; index++ ) {

        if ( _heap_regions[index]._regbase == NULL )
            continue;    /* region entry is empty */

        /*
         * Get the entry that contains the last address of
         * the region (allocated so far, that is).
         */

        regend = (char *) _heap_regions[index]._regbase +
                 _heap_regions[index]._currsize - 1;

        if ( _heap_findaddr(regend, &pdesc) != _HEAPFIND_WITHIN )
            _heap_abort();  /* last address not within a block */

        /*
         * See if the containing block is free
         */

        if ( !(_IS_FREE(pdesc)) )
            continue;    /* block is not free */


        /*
         * Region ends with a free block, go free as much mem
         * as possible.
         */

        region_min_count += _heapmin_region(index, regend, pdesc);


    }  /* region loop */

    /*
     * By minimizing the heap, we've likely invalidated the rover and
     * may have produced contiguous dummy blocks so:
     *
     *  (1) reset the rover
     *  (2) coalesce contiguous dummy blocks
     */

    if ( region_min_count ) {

        /*
         * Set proverdesc to pfirstdesc
         */

        _heap_desc.proverdesc = _heap_desc.pfirstdesc;

        for ( pdesc = _heap_desc.pfirstdesc ; pdesc !=
            &_heap_desc.sentinel ; pdesc = pdesc->pnextdesc ) {

            /*
             * Check and remove consecutive dummy blocks
             */

            if ( _IS_DUMMY(pdesc) ) {

                for ( pdesc2 = pdesc->pnextdesc ;
                    _IS_DUMMY(pdesc2) ;
                    pdesc2 = pdesc->pnextdesc ) {

                    /*
                     * coalesce the dummy blocks
                     */

                    pdesc->pnextdesc = pdesc2->pnextdesc;
                    _PUTEMPTY(pdesc2);

                }  /* dummy loop */

            }  /* if */

        }  /* heap loop */

    }  /* region_min_count */

    /*
     * Good return
     */

    /* goodrtn:   unreferenced label to be removed */
    /*
     * Release the heap lock
     */

    _munlock(_HEAP_LOCK);
    return(0);
}


/***
*_heapmin_region() - Minimize a region
*
*Purpose:
*   Free as much of a region back to the OS as possible.
*
*Entry:
*   int index = index of the region in the region table
*   void * regend = last valid address in region
*   pdesc = pointer to the last block of memory in the region
*       (it has already been determined that this block is free)
*
*Exit:
*   int 1 = minimized region
*       0 = no change to region
*
*Exceptions:
*
*******************************************************************************/

static int __cdecl _heapmin_region (
    int index,
    void * regend,
    REG1 _PBLKDESC pdesc
    )
{
    unsigned size;
    REG2 _PBLKDESC pnew;

    /*
     * Init some variables
     *
     * regend = 1st address AFTER region
     * size = amount of free memory at end of current region
     */

    regend = (char *) regend + 1;   /* "regend++" give compiler error... */
    size = ((char *)regend - (char *)_ADDRESS(pdesc));


    /*
     * See if there's enough free memory to release to the OS.
     * (NOTE:  Need more than a page since we may need a back pointer.)
     */

    if ( size <= _PAGESIZE_ )
        return(0);      /* 0 = no change to region */

    /*
     * We're going to free some memory to the OS.  See if the
     * free block crosses the end of the region and, if so,
     * split up the block appropriately.
     */

    if ( (_MEMSIZE(pdesc) - size) != 0 ) {

        /*
         * The free block spans the end of the region.
         * Divide it up.
         */

        /*
         * Get an empty descriptor
         */

        if ( (pnew = __getempty()) == NULL )
            return(0);

        pnew->pblock = regend;        /* init block pointer */
        * (_PBLKDESC*)regend = pnew;  /* init back pointer */
        _SET_FREE(pnew);              /* set the block free */

        pnew->pnextdesc = pdesc->pnextdesc; /* link it in */
        pdesc->pnextdesc = pnew;

    }


    /*
     * At this point, we have a free block of memory that goes
     * up to (but not exceeding) the end of the region.
     *
     * pdesc = descriptor of the last free block in region
     * size = amount of free mem at end of region (i.e., _MEMSIZE(pdesc))
     * regend = 1st address AFTER end of region
     */


    /*
     * See if we should return the whole region of only part of it.
     */

    if ( _ADDRESS(pdesc) == _heap_regions[index]._regbase ) {

        /*
         * Whole region is free, return it to OS
         */

        _heap_free_region(index);

        /*
         * Put a dummy block in the heap to hold space for
         * the memory we just freed up.
         */

        _SET_DUMMY(pdesc);

    }

    else {

        /*
         * Whole region is NOT free, return part of it to OS
         */
        _free_partial_region(pdesc, size, index);
    }

    /*
     * Exit paths
     */

    return(1);  /* 1 = minimized region */

}


/***
*_free_partial_region() - Free part of a region to the OS
*
*Purpose:
*   Free a portion of a region to the OS
*
*Entry:
*   pdesc = descriptor of last free block in region
*   size = amount of free mem at end of region (i.e., _MEMSIZE(pdesc))
*   index = index of region
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static void __cdecl _free_partial_region (
    REG1 _PBLKDESC pdesc,
    unsigned size,
    int index
    )
{
    unsigned left;
    void * base;
    REG2 _PBLKDESC pnew;

    /*
     * Init a few variables.
     */

    left = (size & (_PAGESIZE_-1));
    base = (char *)_ADDRESS(pdesc);

    /*
     * We return memory to the OS in page multiples.  If the
     * free block is not page aligned, we'll insert a new free block
     * to fill in the difference.
     */

    if ( left != 0 ) {

        /*
         * The block is not a multiple of pages so we need
         * to adjust variables accordingly.
         */

        size -= left;
        base = (char *)base + left;
    }


    /*
     * Return the free pages to the OS.
     */

    if (!VirtualFree(base, size, MEM_DECOMMIT))
        _heap_abort();

    /*
     * Adjust the region table entry
     */

    _heap_regions[index]._currsize -= size;

    /*
     * Adjust the heap according to whether we released the whole
     * free block or not. (Don't worry about consecutive dummies,
     * we'll coalesce them later.)
     *
     * base = address of block we just gave back to OS
     * size = size of block we gave back to OS
     * left = size of block we did NOT give back to OS
     */

    if ( left == 0 ) {

        /*
         * The free block was released to the OS in its
         * entirety.  Make the free block a dummy place holder.
         */

        _SET_DUMMY(pdesc);

    }

    else {

        /*
         * Did NOT release the whole free block to the OS.
         * There's a block of free memory we want to leave
         * in the heap.  Insert a dummy entry after it.
         */

        if ( (pnew = __getempty()) == NULL )
            _heap_abort();

        pnew->pblock = (char *)base;
        _SET_DUMMY(pnew);

        pnew->pnextdesc = pdesc->pnextdesc;
        pdesc->pnextdesc = pnew;

    }

}


#endif  /* WINHEAP */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\inithelp.c ===
/***
*inithelp.c - Contains the __getlocaleinfo helper routine
*
*       Copyright (c) Microsoft Corporation.  All rights reserved.
*
*Purpose:
*  Contains the __getlocaleinfo helper routine.
*
*******************************************************************************/

#include <stdlib.h>
#include <cruntime.h>
#include <locale.h>
#include <setlocal.h>
#include <awint.h>
#include <dbgint.h>
#include <ctype.h>
#include <mtdll.h>
#include <internal.h>

/***
*__getlocaleinfo - return locale data
*
*Purpose:
*       Return locale data appropriate for the setlocale init functions.
*       In particular, wide locale strings are converted to char strings
*       or numeric depending on the value of the first parameter.
*
*       Memory is allocated for the char version of the data, and the
*       calling function's pointer is set to it.  This pointer should later
*       be used to free the data.  The wide-char data is fetched using
*       GetLocaleInfo and converted to multibyte using WideCharToMultiByte.
*
*       *** For internal use by the __init_* functions only ***
*
*       *** Future optimization ***
*       When converting a large number of wide-strings to multibyte, do
*       not query the size of the result, but convert them one after
*       another into a large character buffer.  The entire buffer can
*       also be freed with one pointer.
*
*Entry:
*       int lc_type - LC_STR_TYPE for string data, LC_INT_TYPE for numeric data
*       LCID localehandle - LCID based on category and lang or ctry of __lc_id
*       LCTYPE fieldtype - int or string value
*       void *address - cast to either char * or char**
*
*Exit:
*        0  success
*       -1  failure
*
*Exceptions:
*
*******************************************************************************/

#if NO_ERROR == -1
#error Need to use another error return code in __getlocaleinfo
#endif  /* NO_ERROR == -1 */

#define STR_CHAR_CNT    128
#define INT_CHAR_CNT    4

int __cdecl __getlocaleinfo (
        _locale_t plocinfo,
        int lc_type,
        LCID localehandle,
        LCTYPE fieldtype,
        void *address
        )
{
        if (lc_type == LC_STR_TYPE)
        {
            char **straddress = (char **)address;
            unsigned char cbuffer[STR_CHAR_CNT];
            unsigned char *pcbuffer = cbuffer;
            int bufferused = 0; /* 1 indicates buffer points to malloc'ed memory */
            int buffersize = STR_CHAR_CNT;
            int outsize;

            if ((outsize = __crtGetLocaleInfoA(plocinfo, localehandle, fieldtype, pcbuffer, buffersize, 0))
                == 0)
            {
                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    goto error;

                /* buffersize too small, get required size and malloc new buffer */

                if ((buffersize = __crtGetLocaleInfoA (plocinfo, localehandle, fieldtype, NULL, 0, 0))
                    == 0)
                    goto error;

                if ((pcbuffer = (unsigned char *) _calloc_crt (buffersize, sizeof(unsigned char)))
                    == NULL)
                    goto error;

                bufferused = 1;

                if ((outsize = __crtGetLocaleInfoA (plocinfo, localehandle, fieldtype, pcbuffer, buffersize, 0))
                    == 0)
                    goto error;
            }

            if ((*straddress = (char *) _calloc_crt (outsize, sizeof(char))) == NULL)
                goto error;

            _ERRCHECK(strncpy_s(*straddress, outsize, pcbuffer, outsize - 1));

            if (bufferused)
                _free_crt (pcbuffer);

            return 0;

error:
            if (bufferused)
                _free_crt (pcbuffer);
            return -1;

        } else if (lc_type == LC_INT_TYPE)
        {
            int i;
            char c;
            static wchar_t wcbuffer[INT_CHAR_CNT];
            const int buffersize = INT_CHAR_CNT;
            char *charaddress = (char *)address;

            if (__crtGetLocaleInfoW (plocinfo, localehandle, fieldtype, (LPWSTR)&wcbuffer, buffersize, 0) == 0)
                return -1;

            *(char *)charaddress = 0;

            /* assume GetLocaleInfoW returns valid ASCII integer in wcstr format */
            for (i = 0; i < INT_CHAR_CNT; i++)
            {
                if (isdigit(((unsigned char)c = (unsigned char)wcbuffer[i])))
                    *(unsigned char *)charaddress = (unsigned char)(10 * (int)(*charaddress) + (c - '0'));
                else
                    break;
            }
            return 0;
        }
        return -1;
}



_purecall_handler __pPurecall= NULL;

/***
*void _initp_misc_purevirt(void) -
*
*Purpose:
*       Initialize the __pPurecall function pointer
*
*Entry:
*       The per-process encoded value for the null pointer.
*
*Exit:
*       Never returns
*
*Exceptions:
*
*******************************************************************************/

//extern "C"
void __cdecl _initp_misc_purevirt(void* enull)
{
    __pPurecall = (_purecall_handler) enull;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\initnum.c ===
/***
*initnum.c - contains __init_numeric
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Contains the locale-category initialization function: __init_numeric().
*
*       Each initialization function sets up locale-specific information
*       for their category, for use by functions which are affected by
*       their locale category.
*
*       *** For internal use by setlocale() only ***
*
*******************************************************************************/

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <locale.h>
#include <setlocal.h>
#include <malloc.h>
#include <nlsint.h>
#include <dbgint.h>
#include <mtdll.h>

void __cdecl __free_lconv_num(struct lconv *);

static void fix_grouping(
        char *grouping
        )
{
    /*
     * ANSI specifies that the fields should contain "\3" [\3\0] to indicate
     * thousands groupings (100,000,000.00 for example).
     * NT uses "3;0"; ASCII 3 instead of value 3 and the ';' is extra.
     * So here we convert the NT version to the ANSI version.
     */

    while (*grouping)
    {
        /* convert '3' to '\3' */
        if (*grouping >= '0' && *grouping <= '9')
        {
            *grouping = *grouping - '0';
            grouping++;
        }

        /* remove ';' */
        else if (*grouping == ';')
        {
            char *tmp = grouping;

            do
                *tmp = *(tmp+1);
            while (*++tmp);
        }

        /* unknown (illegal) character, ignore */
        else
            grouping++;
    }
}

/***
*int __init_numeric() - initialization for LC_NUMERIC locale category.
*
*Purpose:
*
*Entry:
*       None.
*
*Exit:
*       0 success
*       1 fail
*
*Exceptions:
*
*******************************************************************************/

int __cdecl __init_numeric (
        pthreadlocinfo ploci
        )
{
    struct lconv *lc;
    int ret = 0;
    LCID ctryid;
    int *lc_refcount;
    int *lconv_num_refcount = NULL;
    _locale_tstruct locinfo;

    locinfo.locinfo = ploci;
    locinfo.mbcinfo = 0;

    if ( (ploci->lc_handle[LC_NUMERIC] != _CLOCALEHANDLE) ||
         (ploci->lc_handle[LC_MONETARY] != _CLOCALEHANDLE) )
    {
        /*
         * Allocate structure filled with NULL pointers
         */
        if ( (lc = (struct lconv *)_calloc_crt(1, sizeof(struct lconv)))
             == NULL )
            return 1;

        /*
         * Copy over all fields (esp., the monetary category)
         */
        *lc = *ploci->lconv;

        /*
         * Allocate a new reference counter for the lconv structure
         */
        if ( (lc_refcount = _malloc_crt(sizeof(int))) == NULL )
        {
            _free_crt(lc);
            return 1;
        }
        *lc_refcount = 0;

        if ( ploci->lc_handle[LC_NUMERIC] != _CLOCALEHANDLE )
        {
            /*
             * Allocate a new reference counter for the numeric info
             */
            if ( (lconv_num_refcount = _malloc_crt(sizeof(int))) == NULL )
            {
                _free_crt(lc);
                _free_crt(lc_refcount);
                return 1;
            }
            *lconv_num_refcount = 0;

            /*
             * Numeric data is country--not language--dependent. NT
             * work-around.
             */
            ctryid = MAKELCID(ploci->lc_id[LC_NUMERIC].wCountry, SORT_DEFAULT);

            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid, LOCALE_SDECIMAL,
                    (void *)&lc->decimal_point);
            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid, LOCALE_STHOUSAND,
                    (void *)&lc->thousands_sep);
            ret |= __getlocaleinfo(&locinfo, LC_STR_TYPE, ctryid, LOCALE_SGROUPING,
                    (void *)&lc->grouping);

            if (ret) {
                    /* Clean up before returning failure */
                    __free_lconv_num(lc);
                    _free_crt(lc);
                    _free_crt(lc_refcount);
                    return -1;
            }

            fix_grouping(lc->grouping);
        }
        else {
            /*
             * C locale for just the numeric category.
             */
            /*
             * NULL out the reference count pointer
             */
            lconv_num_refcount = NULL;
            lc->decimal_point = __lconv_c.decimal_point;
            lc->thousands_sep = __lconv_c.thousands_sep;
            lc->grouping = __lconv_c.grouping;
        }
        (*lc_refcount) = 1;
        if (lconv_num_refcount)
            (*lconv_num_refcount) = 1;
    }

    else {
        /*
         * C locale for BOTH numeric and monetary categories.
         */
        lconv_num_refcount = NULL;
        lc_refcount = NULL;
        lc = &__lconv_c;           /* point to new one */
    }
    /*
     * If this is part of LC_ALL, then we need to free the old ploci->lconv
     * set up in init_monetary() before this.
     */
    if ( (ploci->lconv_num_refcount != NULL) &&
         (InterlockedDecrement(ploci->lconv_num_refcount) == 0))
    {
        _ASSERTE(ploci->lconv_num_refcount > 0);
    }
    if ( (ploci->lconv_intl_refcount != NULL) &&
         (InterlockedDecrement(ploci->lconv_intl_refcount) == 0))
    {
        _free_crt(ploci->lconv_intl_refcount);
        _free_crt(ploci->lconv);
    }

    ploci->lconv_num_refcount = lconv_num_refcount;
    ploci->lconv_intl_refcount = lc_refcount;

    ploci->lconv = lc;
    return 0;
}

/*
 *  Free the lconv numeric strings.
 *  Numeric values do not need to be freed.
 */
void __cdecl __free_lconv_num(
        struct lconv *l
        )
{
    if (l == NULL)
        return;

    if ( l->decimal_point != __lconv_c.decimal_point )
        _free_crt(l->decimal_point);

    if ( l->thousands_sep != __lconv_c.thousands_sep )
        _free_crt(l->thousands_sep);

    if ( l->grouping != __lconv_c.grouping )
        _free_crt(l->grouping);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\hpabort.c ===
/***
*hpabort.c - Abort process due to fatal heap error
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#include <cruntime.h>
#include <internal.h>
#include <rterr.h>


/***
* _heap_abort() - Abort process due to fatal heap error
*
*Purpose:
*       Terminate the process and output a heap error message
*
*Entry:
*       Void
*
*Exit:
*       Never returns
*
*Exceptions:
*
*******************************************************************************/

void __cdecl _heap_abort (
        void
        )
{
        _amsg_exit(_RT_HEAP);           /* heap error */
        /*** PROCESS TERMINATED ***/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\initcon.c ===
/***
*initcon.c - direct console I/O initialization and termination for Win32
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Defines __initconin() and _initconout() and __termcon() routines.
*       The first two are called on demand to initialize _coninpfh and
*       _confh, and the third is called indirectly by CRTL termination.
*
*       NOTE:   The __termcon() routine is called indirectly by the C/C++
*               Run-Time Library termination code.
*
*******************************************************************************/

#include <sect_attribs.h>
#include <cruntime.h>
#include <internal.h>
#include <oscalls.h>

void __cdecl __termcon(void);

#ifdef _MSC_VER

_CRTALLOC(".CRT$XPX") static  _PVFV pterm = __termcon;

#endif  /* _MSC_VER */

/*
 * define console handles. these definitions cause this file to be linked
 * in if one of the direct console I/O functions is referenced.
 * The value (-2) is used to indicate the un-initialized state.
 */
intptr_t _coninpfh = -2;    /* console input */
intptr_t _confh = -2;       /* console output */


/***
*void __initconin(void) - open handles for console input
*
*Purpose:
*       Opens handle for console input.
*
*Entry:
*       None.
*
*Exit:
*       No return value. If successful, the handle value is copied into the
*       global variable _coninpfh.  Otherwise _coninpfh is set to -1.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __initconin (
        void
        )
{
        _coninpfh = (intptr_t)CreateFile( "CONIN$",
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL );

}


/***
*void __initconout(void) - open handles for console output
*
*Purpose:
*       Opens handle for console output.
*
*Entry:
*       None.
*
*Exit:
*       No return value. If successful, the handle value is copied into the
*       global variable _confh.  Otherwise _confh is set to -1.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __initconout (
        void
        )
{
        _confh = (intptr_t)CreateFile( "CONOUT$",
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL );
}


/***
*void __termcon(void) - close console I/O handles
*
*Purpose:
*       Closes _coninpfh and _confh.
*
*Entry:
*       None.
*
*Exit:
*       No return value.
*
*Exceptions:
*
*******************************************************************************/

void __cdecl __termcon (
        void
        )
{
        if ( _confh != -1 && _confh != -2 ) {
                CloseHandle( (HANDLE)_confh );
        }

        if ( _coninpfh != -1 && _coninpfh != -2 ) {
                CloseHandle( (HANDLE)_coninpfh );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\internal_securecrt.h ===
/***
*internal_securecrt.h - contains declarations of internal routines and variables for securecrt
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Declares routines and variables used internally in the SecureCRT implementation.
*       In this include file we define the macros needed to implement the secure functions
*       inlined in the *.inl files like tcscpy_s.inl, etc.
*       Note that this file is used for the CRT implementation, while internal_safecrt is used
*       to build the downlevel library safecrt.lib.
*
*       [Internal]
*
****/

#pragma once

#ifndef _INC_INTERNAL_SECURECRT
#define _INC_INTERNAL_SECURECRT

#include <internal.h>

/* string resetting */
#define _FILL_STRING _SECURECRT__FILL_STRING

#define _FILL_BYTE _SECURECRT__FILL_BYTE

#define _RESET_STRING(_String, _Size) \
    *(_String) = 0; \
    _FILL_STRING((_String), (_Size), 1);

/* validations */
#define _VALIDATE_STRING_ERROR(_String, _Size, _Ret) \
    _VALIDATE_RETURN((_String) != NULL && (_Size) > 0, EINVAL, (_Ret))

#define _VALIDATE_STRING(_String, _Size) \
    _VALIDATE_STRING_ERROR((_String), (_Size), EINVAL)

#define _VALIDATE_POINTER_ERROR_RETURN(_Pointer, _ErrorCode, _Ret) \
    _VALIDATE_RETURN((_Pointer) != NULL, (_ErrorCode), (_Ret))

#define _VALIDATE_POINTER_ERROR(_Pointer, _Ret) \
    _VALIDATE_POINTER_ERROR_RETURN((_Pointer), EINVAL, (_Ret))

#define _VALIDATE_POINTER(_Pointer) \
    _VALIDATE_POINTER_ERROR((_Pointer), EINVAL)

#define _VALIDATE_CONDITION_ERROR_RETURN(_Condition, _ErrorCode, _Ret) \
    _VALIDATE_RETURN((_Condition), (_ErrorCode), (_Ret))

#define _VALIDATE_CONDITION_ERROR(_Condition, _Ret) \
    _VALIDATE_CONDITION_ERROR_RETURN((_Condition), EINVAL, (_Ret))

#define _VALIDATE_POINTER_RESET_STRING_ERROR(_Pointer, _String, _Size, _Ret) \
    if ((_Pointer) == NULL) \
    { \
        _RESET_STRING((_String), (_Size)); \
        _VALIDATE_POINTER_ERROR_RETURN((_Pointer), EINVAL, (_Ret)) \
    }

#define _VALIDATE_POINTER_RESET_STRING(_Pointer, _String, _Size) \
    _VALIDATE_POINTER_RESET_STRING_ERROR((_Pointer), (_String), (_Size), EINVAL)

#define _RETURN_BUFFER_TOO_SMALL_ERROR(_String, _Size, _Ret) \
    _VALIDATE_RETURN((L"Buffer is too small" && 0), ERANGE, _Ret)

#define _RETURN_BUFFER_TOO_SMALL(_String, _Size) \
    _RETURN_BUFFER_TOO_SMALL_ERROR((_String), (_Size), ERANGE)

#define _RETURN_DEST_NOT_NULL_TERMINATED(_String, _Size) \
    _VALIDATE_RETURN((L"String is not null terminated" && 0), EINVAL, EINVAL)

#define _RETURN_EINVAL \
    _VALIDATE_RETURN((L"Invalid parameter", 0), EINVAL, EINVAL)

#define _RETURN_ERROR(_Msg, _Ret) \
    _VALIDATE_RETURN(((_Msg), 0), EINVAL, _Ret)

/* returns without calling _invalid_parameter */
#define _RETURN_NO_ERROR \
    return 0

/* Note that _RETURN_TRUNCATE does not set errno */
#define _RETURN_TRUNCATE \
    return STRUNCATE

#define _SET_MBCS_ERROR \
    (errno = EILSEQ)

#define _RETURN_MBCS_ERROR \
    return _SET_MBCS_ERROR

/* locale dependent */
#define _LOCALE_ARG \
    _LocInfo

#define _LOCALE_ARG_DECL \
    _locale_t _LOCALE_ARG

#define _LOCALE_UPDATE \
    _LocaleUpdate _LocUpdate(_LOCALE_ARG)

#define _ISMBBLEAD(_Character) \
    _ismbblead_l((_Character), _LocUpdate.GetLocaleT())

#define _MBSDEC(_String, _Current) \
    _mbsdec((_String), (_Current))

#define _ISMBBLEADPREFIX(_Result, _StringStart, _BytePtr)               \
    {                                                                   \
        unsigned char *_Tmp_VAR, *_StringStart_VAR, *_BytePtr_VAR;      \
                                                                        \
        _StringStart_VAR = (_StringStart);                              \
        _BytePtr_VAR = (_BytePtr);                                      \
        _Tmp_VAR = _BytePtr_VAR;                                        \
        while ((_Tmp_VAR >= _StringStart_VAR) && _ISMBBLEAD(*_Tmp_VAR)) \
        {                                                               \
            _Tmp_VAR--;                                                 \
        }                                                               \
        (_Result) = ((_BytePtr_VAR - _Tmp_VAR) & 1) != 0;               \
    }

#define _LOCALE_SHORTCUT_TEST \
    _LocUpdate.GetLocaleT()->mbcinfo->ismbcodepage == 0

#define _USE_LOCALE_ARG 1

/* misc */
#define _ASSIGN_IF_NOT_NULL(_Pointer, _Value) \
    if ((_Pointer) != NULL) \
    { \
        *(_Pointer) = (_Value); \
    }

#endif  /* _INC_INTERNAL_SECURECRT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\crt\src\input.c ===
/***
*input.c - C formatted input, used by scanf, etc.
*
*       Copyright (c) Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines _input() to do formatted input; called from scanf(),
*       etc. functions.  This module defines _cscanf() instead when
*       CPRFLAG is defined.  The file cscanf.c defines that symbol
*       and then includes this file in order to implement _cscanf().
*
*Note:
*       this file is included in safecrt.lib build directly, plese refer
*       to safecrt_[w]input_s.c
*
*******************************************************************************/


#define ALLOW_RANGE /* allow "%[a-z]"-style scansets */

#include <cruntime.h>
#include <stdio.h>
#include <ctype.h>
#include <cvt.h>
#include <conio.h>
#include <stdarg.h>
#include <string.h>
#include <internal.h>
#include <fltintrn.h>
#include <malloc.h>
#include <locale.h>
#include <mtdll.h>
#include <stdlib.h>
#include <setlocal.h>
#include <dbgint.h>

#ifndef _INC_INTERNAL_SAFECRT
#include <internal_securecrt.h>
#endif  /* _INC_INTERNAL_SAFECRT */

#ifdef _MBCS
#undef _MBCS
#endif  /* _MBCS */
#include <tchar.h>

#ifdef __cplusplus
extern "C"
{
#endif  /* __cplusplus */

#ifdef _SAFECRT_IMPL

#undef _malloc_crt
#undef _realloc_crt
#define _malloc_crt malloc
#define _realloc_crt realloc

/* Helpers for scanf_s. */
#ifdef _UNICODE
int __cdecl _stdin_winput_s(const wchar_t *_Format, va_list _ArgList)
#else  /* _UNICODE */
int __cdecl _stdin_input_s(const char *_Format, va_list _ArgList)
#endif  /* _UNICODE */
{
    int retval = -1;

    _lock(_STREAM_LOCKS + 0);
    __try {
        retval = __tinput_s(stdin, _Format, _ArgList);
    }
    __finally {
        _unlock(_STREAM_LOCKS + 0);
    }

    return retval;
}

#ifdef _UNICODE
int __cdecl _swinput_s(const wchar_t *_String, size_t _Count, const wchar_t *_Format, va_list _ArgList)
#else  /* _UNICODE */
int __cdecl _sinput_s(const char *_String, size_t _Count, const char *_Format, va_list _ArgList)
#endif  /* _UNICODE */
{
    FILE stream;
    FILE *infile = &stream;
    int retval = -1;

    /* validation section */
    _VALIDATE_RETURN( (_String != NULL), EINVAL, -1);
    _VALIDATE_RETURN( (_Format != NULL), EINVAL, -1);
    _VALIDATE_RETURN(_Count <= (INT_MAX / sizeof(_TCHAR)), EINVAL, -1);

    infile->_flag = _IOREAD | _IOSTRG | _IOMYBUF;
    infile->_ptr = infile->_base = (char *) _String;
    infile->_cnt = (int)_Count * sizeof(_TCHAR);

    retval = __tinput_s(infile, _Format, _ArgList);

    return retval;
}

#endif  /* _SAFECRT_IMPL */

#ifdef _SAFECRT_IMPL
#define _FASSIGN(flag, argument, number, dec_point, locale) _safecrt_fassign((flag), (argument), (number), (dec_point))
#else  /* _SAFECRT_IMPL */
#define _FASSIGN(flag, argument, number, dec_point, locale) _fassign_l((flag), (argument), (number), (locale))
#endif  /* _SAFECRT_IMPL */

#if defined (UNICODE)
#define ALLOC_TABLE 1
#else  /* defined (UNICODE) */
#define ALLOC_TABLE 0
#endif  /* defined (UNICODE) */

#define HEXTODEC(chr)   _hextodec(chr)

#define LEFT_BRACKET    ('[' | ('a' - 'A')) /* 'lowercase' version */

static _TINT __cdecl _hextodec(_TCHAR);
#ifdef CPRFLAG

#define INC()           (++charcount, _inc())
#define UN_INC(chr)     (--charcount, _un_inc(chr))
#define EAT_WHITE()     _whiteout(&charcount)

static _TINT __cdecl _inc(void);
static void __cdecl _un_inc(_TINT);
static _TINT __cdecl _whiteout(int *);

#else  /* CPRFLAG */

#define INC()           (++charcount, _inc(stream))
#define UN_INC(chr)     (--charcount, _un_inc(chr, stream))
#define EAT_WHITE()     _whiteout(&charcount, stream)

static _TINT __cdecl _inc(FILE *);
static void __cdecl _un_inc(_TINT, FILE *);
static _TINT __cdecl _whiteout(int *, FILE *);

#endif  /* CPRFLAG */

#ifndef _UNICODE
#define _ISDIGIT(chr)   isdigit((unsigned char)chr)
#define _ISXDIGIT(chr)  isxdigit((unsigned char)chr)
#else  /* _UNICODE */
#define _ISDIGIT(chr)   ( !(chr & 0xff00) && isdigit( ((chr) & 0x00ff) ) )
#define _ISXDIGIT(chr)  ( !(chr & 0xff00) && isxdigit( ((chr) & 0x00ff) ) )
#endif  /* _UNICODE */


#define LONGLONG_IS_INT64 1     /* 1 means long long is same as int64
                                   0 means long long is same as long */

/***
*  int __check_float_string(size_t,size_t *, _TCHAR**, _TCHAR*, int*)
*
*  Purpose:
*       Check if there is enough space insert onemore character in the given
*       block, if not then allocate more memory.
*
*  Return:
*       FALSE if more memory needed and the reallocation failed.
*
*******************************************************************************/

static int __check_float_string(size_t nFloatStrUsed,
                                size_t *pnFloatStrSz,
                                _TCHAR **pFloatStr,
                                _TCHAR *floatstring,
                                int *pmalloc_FloatStrFlag)
{
    void *tmpPointer;
    CRT_WARNING_DISABLE_PUSH(22011, "Silence prefast about overflow/underflow");
    _ASSERTE(nFloatStrUsed<=(*pnFloatStrSz));
    if (nFloatStrUsed==(*pnFloatStrSz))
      {
        if ((*pFloatStr)==floatstring)
        {
            if (((*pFloatStr)=(_TCHAR *)_calloc_crt((*pnFloatStrSz),2*sizeof(_TCHAR)))==NULL)
            {
              return FALSE;
            }
            (*pmalloc_FloatStrFlag)=1;
            memcpy((*pFloatStr),floatstring,(*pnFloatStrSz)*sizeof(_TCHAR));
            (*pnFloatStrSz)*=2;
        }
        else
        {
            if ((tmpPointer=(_TCHAR *)_recalloc_crt((*pFloatStr), (*pnFloatStrSz),2*sizeof(_TCHAR)))==NULL)
            {
                return FALSE;
            }
            (*pFloatStr)=(_TCHAR *)(tmpPointer);
            (*pnFloatStrSz)*=2;
        }
    }
    CRT_WARNING_POP;
    return TRUE;
}


#ifdef CPRFLAG

/***
*int _cscanf(format, arglist) - read formatted input direct from console
*
*Purpose:
*   Reads formatted data like scanf, but uses console I/O functions.
*
*Entry:
*   char *format - format string to determine data formats
*   arglist - list of POINTERS to where to put data
*
*Exit:
*   returns number of successfully matched data items (from input)
*
*Exceptions:
*
*******************************************************************************/
#ifdef _SAFECRT_IMPL

#ifndef _SECURE_SCANF
static int __cdecl input(const _TUCHAR *, va_list);
#else  /* _SECURE_SCANF */
static int __cdecl input_s(const _TUCHAR *, va_list);
#endif  /* _SECURE_SCANF */

#ifndef _SECURE_SCANF
int __cdecl _tcscanf (const _TCHAR *format,...)
#else  /* _SECURE_SCANF */
int __cdecl _tcscanf_s (const _TCHAR *format,...)
#endif  /* _SECURE_SCANF */
{
    va_list arglist;

    va_start(arglist, format);

#ifndef _SECURE_SCANF
    return input(reinterpret_cast<const _TUCHAR*>(format), arglist);   /* get the input */
#else  /* _SECURE_SCANF */
    return input_s(reinterpret_cast<const _TUCHAR*>(format), arglist);   /* get the input */
#endif  /* _SECURE_SCANF */
}

#else  /* _SAFECRT_IMPL */

#ifndef _SECURE_SCANF
    #define _CPRSCANF   _tcscanf
    #define _CPRSCANF_L _tcscanf_l
    #define _CPRINPUT_L _cprinput_l
#else  /* _SECURE_SCANF */
    #define _CPRSCANF   _tcscanf_s
    #define _CPRSCANF_L _tcscanf_s_l
    #define _CPRINPUT_L _cprinput_s_l
#endif  /* _SECURE_SCANF */

static int __cdecl _CPRINPUT_L(const _TUCHAR *, _locale_t , va_list);

int __cdecl _CPRSCANF(const _TCHAR *format,...)
{
    va_list arglist;

    va_start(arglist, format);

    return _CPRINPUT_L(reinterpret_cast<const _TUCHAR*>(format), NULL, arglist);   /* get the input */
}

int __cdecl _CPRSCANF_L(const _TCHAR *format, _locale_t plocinfo, ...)
{
    va_list arglist;

    va_start(arglist, plocinfo);

    return _CPRINPUT_L(reinterpret_cast<const _TUCHAR*>(format), plocinfo, arglist);   /* get the input */
}

#undef _CPRSCANF
#undef _CPRSCANF_L
#undef _CPRINPUT_L

#endif  /* _SAFECRT_IMPL */

#endif  /* CPRFLAG */


#define ASCII       32           /* # of bytes needed to hold 256 bits */

#define SCAN_SHORT     0         /* also for FLOAT */
#define SCAN_LONG      1         /* also for DOUBLE */
#define SCAN_L_DOUBLE  2         /* only for LONG DOUBLE */

#define SCAN_NEAR    0
#define SCAN_FAR     1

#ifndef _UNICODE
#define TABLESIZE    ASCII
#else  /* _UNICODE */
#define TABLESIZE    (ASCII * 256)
#endif  /* _UNICODE */


/***
*int _input(stream, format, arglist), static int input(format, arglist)
*
*Purpose:
*   get input items (data items or literal matches) from the input stream
*   and assign them if appropriate to the items thru the arglist. this
*   function is intended for internal library use only, not for the user
*
*   The _input entry point is for the normal scanf() functions
*   The input entry point is used when compiling for _cscanf() [CPRFLAF
*   defined] and is a static function called only by _cscanf() -- reads from
*   console.
*
*   This code also defines _input_s, which works differently for %c, %s & %[.
*   For these, _input_s first picks up the next argument from the variable
*   argument list & uses it as the maximum size of the character array pointed
*   to by the next argument in the list.
*
*Entry:
*   FILE *stream - file to read from
*   char *format - format string to determine the data to read
*   arglist - list of pointer to data items
*
*Exit:
*   returns number of items assigned and fills in data items
*   returns EOF if error or EOF found on stream before 1st data item matched
*
*Exceptions:
*
*******************************************************************************/

#ifdef _SAFECRT_IMPL
    #define _INTRN_LOCALE_CONV( x ) localeconv()
#else  /* _SAFECRT_IMPL */
    inline const lconv* _INTRN_LOCALE_CONV( _LocaleUpdate& l )
    {
        return l.GetLocaleT()->locinfo->lconv;
    }
#endif  /* _SAFECRT_IMPL */

#ifdef _SAFECRT_IMPL
#ifdef CPRFLAG
#ifndef _SECURE_SCANF
        static int __cdecl input(const _TUCHAR* format, va_list arglist)
#else  /* _SECURE_SCANF */
        static int __cdecl input_s(const _TUCHAR* format, va_list arglist)
#endif  /* _SECURE_SCANF */
#else  /* CPRFLAG */
#ifndef _SECURE_SCANF
        int __cdecl __tinput (FILE* stream, const _TUCHAR* format, va_list arglist)
#else  /* _SECURE_SCANF */
        int __cdecl __tinput_s (FILE* stream, const _TUCHAR* format, va_list arglist)
#endif  /* _SECURE_SCANF */
#endif  /* CPRFLAG */
#else  /* _SAFECRT_IMPL */
#ifdef CPRFLAG
#ifndef _SECURE_SCANF
        static int __cdecl _cprinput_l(const _TUCHAR* format, _locale_t plocinfo, va_list arglist)
#else  /* _SECURE_SCANF */
        static int __cdecl _cprinput_s_l(const _TUCHAR* format, _locale_t plocinfo, va_list arglist)
#endif  /* _SECURE_SCANF */
#else  /* CPRFLAG */
#ifndef _SECURE_SCANF
        int __cdecl _tinput_l(FILE* stream, const _TUCHAR* format, _locale_t plocinfo, va_list arglist)
#else  /* _SECURE_SCANF */
        int __cdecl _tinput_s_l(FILE* stream, const _TUCHAR* format, _locale_t plocinfo, va_list arglist)
#endif  /* _SECURE_SCANF */
#endif  /* CPRFLAG */
#endif  /* _SAFECRT_IMPL */
{
    _TCHAR floatstring[_CVTBUFSIZE + 1];
    _TCHAR *pFloatStr=floatstring;
    size_t nFloatStrUsed=0;
    size_t nFloatStrSz=sizeof(floatstring)/sizeof(floatstring[0]);
    int malloc_FloatStrFlag=0;

    unsigned long number;               /* temp hold-value                   */
#if ALLOC_TABLE
    char *table = NULL;                 /* which chars allowed for %[]       */
    int malloc_flag = 0;                /* is "table" allocated on the heap? */
#else  /* ALLOC_TABLE */
    char AsciiTable[TABLESIZE];
    char *table = AsciiTable;
#endif  /* ALLOC_TABLE */

    unsigned __int64 num64;             /* temp for 64-bit integers          */
    void *pointer=NULL;                 /* points to user data receptacle    */
    void *start;                        /* indicate non-empty string         */


#ifndef _UNICODE
    wchar_t wctemp=L'\0';
#endif  /* _UNICODE */
    _TUCHAR *scanptr;                   /* for building "table" data         */
REG2 _TINT ch = 0;
    int charcount;                      /* total number of chars read        */
REG1 int comchr;                        /* holds designator type             */
    int count;                          /* return value.  # of assignments   */

    int started;                        /* indicate good number              */
    int width;                          /* width of field                    */
    int widthset;                       /* user has specified width          */
#ifdef _SECURE_SCANF
    size_t array_width = 0;
    size_t original_array_width = 0;
    int enomem = 0;
    int format_error = FALSE;
#endif  /* _SECURE_SCANF */

/* Neither coerceshort nor farone are need for the 386 */


    char done_flag;                     /* general purpose loop monitor      */
    char longone;                       /* 0 = SHORT, 1 = LONG, 2 = L_DOUBLE */
    int integer64;                      /* 1 for 64-bit integer, 0 otherwise */
    signed char widechar;               /* -1 = char, 0 = ????, 1 = wchar_t  */
    char reject;                        /* %[^ABC] instead of %[ABC]         */
    char negative;                      /* flag for '-' detected             */
    char suppress;                      /* don't assign anything             */
    char match;                         /* flag: !0 if any fields matched    */
    va_list arglistsave;                /* save arglist value                */

    char fl_wchar_arg;                  /* flags wide char/string argument   */

    _TCHAR decimal;


    _TUCHAR rngch;
    _TUCHAR last;
    _TUCHAR prevchar;
    _TCHAR tch;

    _VALIDATE_RETURN( (format != NULL), EINVAL, EOF);

#ifndef CPRFLAG
    _VALIDATE_RETURN( (stream != NULL), EINVAL, EOF);
#ifndef _UNICODE
    _VALIDATE_STREAM_ANSI_RETURN(stream, EINVAL, EOF);
#endif  /* _UNICODE */
#endif  /* CPRFLAG */

#ifndef _SAFECRT_IMPL
    _LocaleUpdate _loc_update(plocinfo);
#endif  /* _SAFECRT_IMPL */

    /*
    count = # fields assigned
    charcount = # chars read
    match = flag indicating if any fields were matched

    [Note that we need both count and match.  For example, a field
    may match a format but have assignments suppressed.  In this case,
    match will get set, but 'count' will still equal 0.  We need to
    distinguish 'match vs no-match' when terminating due to EOF.]
    */

    count = charcount = match = 0;

    while (*format) {

        if (_istspace((_TUCHAR)*format)) {

            UN_INC(EAT_WHITE()); /* put first non-space char back */

            do {
                tch = *++format;
            } while (_istspace((_TUCHAR)tch));

            continue;

        }

        if (_T('%') == *format && _T('%') != *(format + 1)) {

            number = 0;
            prevchar = 0;
            width = widthset = started = 0;
#ifdef _SECURE_SCANF
            original_array_width = array_width = 0;
            enomem = 0;
#endif  /* _SECURE_SCANF */
            fl_wchar_arg = done_flag = suppress = negative = reject = 0;
            widechar = 0;

            longone = 1;
            integer64 = 0;

            while (!done_flag) {

                comchr = *++format;
                if (_ISDIGIT((_TUCHAR)comchr)) {
                    ++widthset;
                    width = MUL10(width) + (comchr - _T('0'));
                } else
                    switch (comchr) {
                        case _T('F') :
                        case _T('N') :   /* no way to push NEAR in large model */
                            break;  /* NEAR is default in small model */
                        case _T('h') :
                            /* set longone to 0 */
                            --longone;
                            --widechar;         /* set widechar = -1 */
                            break;

                        case _T('I'):
                            if ( (*(format + 1) == _T('6')) &&
                                 (*(format + 2) == _T('4')) )
                            {
                                format += 2;
                                ++integer64;
                                num64 = 0;
                                break;
                            }
                            else if ( (*(format + 1) == _T('3')) &&
                                      (*(format + 2) == _T('2')) )
                            {
                                format += 2;
                                break;
                            }
                            else if ( (*(format + 1) == _T('d')) ||
                                      (*(format + 1) == _T('i')) ||
                                      (*(format + 1) == _T('o')) ||
                                      (*(format + 1) == _T('x')) ||
                                      (*(format + 1) == _T('X')) )
                            {
                                if (sizeof(void*) == sizeof(__int64))
                                {
                                    ++integer64;
                                    num64 = 0;
                                }
                                break;
                            }
                            if (sizeof(void*) == sizeof(__int64))
                            {
                                    ++integer64;
                                    num64 = 0;
                            }
                            goto DEFAULT_LABEL;

                        case _T('L') :
                        /*  ++longone;  */
                            ++longone;
                            break;

                        case _T('l') :
                            if (*(format + 1) == _T('l'))
                            {
                                ++format;
#ifdef LONGLONG_IS_INT64
                                ++integer64;
                                num64 = 0;
                                break;
#else  /* LONGLONG_IS_INT64 */
                                ++longone;
                                    /* NOBREAK */
#endif  /* LONGLONG_IS_INT64 */
                            }
                            else
                            {
                                ++longone;
                                    /* NOBREAK */
                            }
                        case _T('w') :
                            ++widechar;         /* set widechar = 1 */
                            break;

                        case _T('*') :
                            ++suppress;
                            break;

                        default:
DEFAULT_LABEL:
                            ++done_flag;
                            break;
                    }
            }

            if (!suppress) {
                arglistsave = arglist;
                pointer = va_arg(arglist,void *);
            } else {
                pointer = NULL;         // doesn't matter what value we use here - we're only using it as a flag
            }

            done_flag = 0;

            if (!widechar) {    /* use case if not explicitly specified */
                if ((*format == _T('S')) || (*format == _T('C')))
#ifdef _UNICODE
                    --widechar;
                else
                    ++widechar;
#else  /* _UNICODE */
                    ++widechar;
                else
                    --widechar;
#endif  /* _UNICODE */
            }

            /* switch to lowercase to allow %E,%G, and to
               keep the switch table small */

            comchr = *format | (_T('a') - _T('A'));

            if (_T('n') != comchr)
                if (_T('c') != comchr && LEFT_BRACKET != comchr)
                    ch = EAT_WHITE();
                else
                    ch = INC();

            if (_T('n') != comchr)
            {
                if (_TEOF == ch)
                    goto error_return;
            }

            if (!widthset || width) {

#ifdef _SECURE_SCANF
                if(!suppress && (comchr == _T('c') || comchr == _T('s') || comchr == LEFT_BRACKET)) {

                    arglist = arglistsave;

                    /* Reinitialize pointer to point to the array to which we write the input */
                    pointer = va_arg(arglist, void*);

                    arglistsave = arglist;

                    /* Get the next argument - size of the array in characters */
#ifdef _WIN64
                    original_array_width = array_width = (size_t)(va_arg(arglist, unsigned int));
#else  /* _WIN64 */
                    original_array_width = array_width = va_arg(arglist, size_t);
#endif  /* _WIN64 */

                    if(array_width < 1) {
                        if (widechar > 0)
                            *(wchar_t UNALIGNED *)pointer = L'\0';
                        else
                            *(char *)pointer = '\0';

                        errno = ENOMEM;

                        goto error_return;
                    }
                }
#endif  /* _SECURE_SCANF */
                switch(comchr) {

                    case _T('c'):
                /*  case _T('C'):  */
                        if (!widthset) {
                            ++widthset;
                            ++width;
                        }
                        if (widechar > 0)
                            fl_wchar_arg++;
                        goto scanit;


                    case _T('s'):
                /*  case _T('S'):  */
                        if(widechar > 0)
                            fl_wchar_arg++;
                        goto scanit;


                    case LEFT_BRACKET :   /* scanset */
                        if (widechar>0)
                            fl_wchar_arg++;
                        scanptr = (_TUCHAR *)(++format);

                        if (_T('^') == *scanptr) {
                            ++scanptr;
                            --reject; /* set reject to 255 */
                        }

                        /* Allocate "table" on first %[] spec */
#if ALLOC_TABLE
                        if (table == NULL) {
                            table = (char*)_malloc_crt(TABLESIZE);
                            if ( table == NULL)
                                goto error_return;
                            malloc_flag = 1;
                        }
#endif  /* ALLOC_TABLE */
                        memset(table, 0, TABLESIZE);


                        if (LEFT_BRACKET == comchr)
                            if (_T(']') == *scanptr) {
                                prevchar = _T(']');
                                ++scanptr;

                                table[ _T(']') >> 3] = 1 << (_T(']') & 7);

                            }

                        while (_T(']') != *scanptr) {

                            rngch = *scanptr++;

                            if (_T('-') != rngch ||
                                 !prevchar ||           /* first char */
                                 _T(']') == *scanptr) /* last char */

                                table[(prevchar = rngch) >> 3] |= 1 << (rngch & 7);

                            else {  /* handle a-z type set */

                                rngch = *scanptr++; /* get end of range */

                                if (prevchar < rngch)  /* %[a-z] */
                                    last = rngch;
                                else {              /* %[z-a] */
                                    last = prevchar;
                                    prevchar = rngch;
                                }
                                for (rngch = prevchar; rngch <= last; ++rngch)
                                    table[rngch >> 3] |= 1 << (rngch & 7);

                                prevchar = 0;

                            }
                        }


                        if (!*scanptr)
                            goto error_return;      /* trunc'd format string */

                        /* scanset completed.  Now read string */

                        if (LEFT_BRACKET == comchr)
                            format = scanptr;

scanit:
                        start = pointer;

                        /*
                         * execute the format directive. that is, scan input
                         * characters until the directive is fulfilled, eof
                         * is reached, or a non-matching character is
                         * encountered.
                         *
                         * it is important not to get the next character
                         * unless that character needs to be tested! other-
                         * wise, reads from line-buffered devices (e.g.,
                         * scanf()) would require an extra, spurious, newline
                         * if the first newline completes the current format
                         * directive.
                         */
                        UN_INC(ch);

#ifdef _SECURE_SCANF
                        /* One element is needed for '\0' for %s & %[ */
                        if(comchr != _T('c')) {
                            --array_width;
                        }
#endif  /* _SECURE_SCANF */
                        while ( !widthset || width-- ) {

                            ch = INC();
                            if (
#ifndef CPRFLAG
                                 (_TEOF != ch) &&
#endif  /* CPRFLAG */
                                   // char conditions
                                 ( ( comchr == _T('c')) ||
                                   // string conditions !isspace()
                                   ( ( comchr == _T('s') &&
                                       (!(ch >= _T('\t') && ch <= _T('\r')) &&
                                       ch != _T(' ')))) ||
                                   // BRACKET conditions
                                   ( (comchr == LEFT_BRACKET) &&
                                     ((table[ch >> 3] ^ reject) & (1 << (ch & 7)))
                                     )
                                   )
                                )
                            {
                                if (!suppress) {
#ifdef _SECURE_SCANF
                                    if(!array_width) {
                                        /* We have exhausted the user's buffer */

                                        enomem = 1;
                                        break;
                                    }
#endif  /* _SECURE_SCANF */
#ifndef _UNICODE
                                    if (fl_wchar_arg) {
                                        char temp[2];
                                        temp[0] = (char) ch;
                                        if (isleadbyte((unsigned char)ch))
                                        {
                                            temp[1] = (char) INC();
                                        }
                                        wctemp = L'?';
#ifdef _SAFECRT_IMPL
                                        mbtowc(&wctemp, temp, MB_CUR_MAX);
#else  /* _SAFECRT_IMPL */
                                        _mbtowc_l(&wctemp,
                                                  temp,
                                                  _loc_update.GetLocaleT()->locinfo->mb_cur_max,
                                                  _loc_update.GetLocaleT());
#endif  /* _SAFECRT_IMPL */
                                        *(wchar_t UNALIGNED *)pointer = wctemp;
                                        /* just copy L'?' if mbtowc fails, errno is set by mbtowc */
                                        pointer = (wchar_t *)pointer + 1;
#ifdef _SECURE_SCANF
                                        --array_width;
#endif  /* _SECURE_SCANF */
                                    } else
#else  /* _UNICODE */
                                    if (fl_wchar_arg) {
                                        *(wchar_t UNALIGNED *)pointer = ch;
                                        pointer = (wchar_t *)pointer + 1;
#ifdef _SECURE_SCANF
                                        --array_width;
#endif  /* _SECURE_SCANF */
                                    } else
#endif  /* _UNICODE */
                                    {
#ifndef _UNICODE
                                    *(char *)pointer = (char)ch;
                                    pointer = (char *)pointer + 1;
#ifdef _SECURE_SCANF
                                    --array_width;
#endif  /* _SECURE_SCANF */
#else  /* _UNICODE */
                                    int temp = 0;
#ifndef _SECURE_SCANF
                                    /* convert wide to multibyte */
                                    if (_ERRCHECK_EINVAL_ERANGE(wctomb_s(&temp, (char *)pointer, MB_LEN_MAX, ch)) == 0)
                                    {
                                        /* do nothing if wctomb fails, errno will be set to EILSEQ */
                                        pointer = (char *)pointer + temp;
                                    }
#else  /* _SECURE_SCANF */
                                    /* convert wide to multibyte */
#ifdef _SAFECRT_IMPL
                                    if (array_width >= ((size_t)MB_CUR_MAX))
                                    {
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
                                        temp = wctomb((char *)pointer, ch);
_END_SECURE_CRT_DEPRECATION_DISABLE
                                    }
                                    else
                                    {
                                        char tmpbuf[MB_LEN_MAX];
_BEGIN_SECURE_CRT_DEPRECATION_DISABLE
                                        temp = wctomb(tmpbuf, ch);
_END_SECURE_CRT_DEPRECATION_DISABLE
                                        if (temp > 0 && ((size_t)temp) > array_width)
                                        {
                                            /* We have exhausted the user's buffer */
                                            enomem = 1;
                                            break;
                                        }
                                        memcpy(pointer, tmpbuf, temp);
                                    }
#else  /* _SAFECRT_IMPL */
                                    if(wctomb_s(&temp,(char *)pointer, array_width, ch) == ERANGE) {
                                        /* We have exhausted the user's buffer */
                                        enomem = 1;
                                        break;
                                    }
#endif  /* _SAFECRT_IMPL */
                                    if (temp > 0)
                                    {
                                        /* do nothing if wctomb fails, errno will be set to EILSEQ */
                                        pointer = (char *)pointer + temp;
                                        array_width -= temp;
                                    }
#endif  /* _SECURE_SCANF */
#endif  /* _UNICODE */
                                    }
                                } /* suppress */
                                else {
                                    /* just indicate a match */
                                    start = (_TCHAR *)start + 1;
                                }
                            }
                            else  {
                                UN_INC(ch);
                                break;
                            }
                        }

                        /* make sure something has been matched and, if
                           assignment is not suppressed, null-terminate
                           output string if comchr != c */

#ifdef _SECURE_SCANF
                        if(enomem) {
                            errno = ENOMEM;
                            /* In case of error, blank out the input buffer */
                            if (fl_wchar_arg)
                            {
                                _RESET_STRING(((wchar_t UNALIGNED *)start), original_array_width);
                            }
                            else
                            {
                                _RESET_STRING(((char *)start), original_array_width);
                            }

                            goto error_return;
                        }
#endif  /* _SECURE_SCANF */

                        if (start != pointer) {
                            if (!suppress) {
                                ++count;
                                if ('c' != comchr) /* null-terminate strings */
                                    if (fl_wchar_arg)
                                    {
                                        *(wchar_t UNALIGNED *)pointer = L'\0';
#ifdef _SECURE_SCANF
                                        _FILL_STRING(((wchar_t UNALIGNED *)start), original_array_width,
                                            ((wchar_t UNALIGNED *)pointer - (wchar_t UNALIGNED *)start + 1))
#endif  /* _SECURE_SCANF */
                                    }
                                    else
                                    {
                                        *(char *)pointer = '\0';
#ifdef _SECURE_SCANF
                                        _FILL_STRING(((char *)start), original_array_width,
                                            ((char *)pointer - (char *)start + 1))
#endif  /* _SECURE_SCANF */
                                    }
                            } else /*NULL*/;
                        }
                        else
                            goto error_return;

                        break;

                    case _T('i') :      /* could be d, o, or x */

                        comchr = _T('d'); /* use as default */

                    case _T('x'):

                        if (_T('-') == ch) {
                            ++negative;

                            goto x_incwidth;

                        } else if (_T('+') == ch) {
x_incwidth:
                            if (!--width && widthset)
                                ++done_flag;
                            else
                                ch = INC();
                        }

                        if (_T('0') == ch) {

                            if (_T('x') == (_TCHAR)(ch = INC()) || _T('X') == (_TCHAR)ch) {
                                ch = INC();
                                if (widthset) {
                                    width -= 2;
                                    if (width < 1)
                                        ++done_flag;
                                }
                                comchr = _T('x');
                            } else {
                                ++started;
                                if (_T('x') != comchr) {
                                    if (widthset && !--width)
                                        ++done_flag;
                                    comchr = _T('o');
                                }
                                else {
                                    /* scanning a hex number that starts */
                                    /* with a 0. push back the character */
                                    /* currently in ch and restore the 0 */
                                    UN_INC(ch);
                                    ch = _T('0');
                                }
                            }
                        }
                        goto getnum;

                        /* NOTREACHED */

                    case _T('p') :
                        /* force %hp to be treated as %p */
                        longone = 1;
#ifdef _WIN64
                        /* force %p to be 64 bit in WIN64 */
                        ++integer64;
                        num64 = 0;
#endif  /* _WIN64 */
                    case _T('o') :
                    case _T('u') :
                    case _T('d') :

                        if (_T('-') == ch) {
                            ++negative;

                            goto d_incwidth;

                        } else if (_T('+') == ch) {
d_incwidth:
                            if (!--width && widthset)
                                ++done_flag;
                            else
                                ch = INC();
                        }

getnum:
                        if ( integer64 ) {

                            while (!done_flag) {

                                if (_T('x') == comchr || _T('p') == comchr)

                                    if (_ISXDIGIT(ch)) {
                                        num64 <<= 4;
                                        ch = _hextodec(ch);
                                    }
                                    else
                                        ++done_flag;

                                else if (_ISDIGIT(ch))

                                    if (_T('o') == comchr)
                                        if (_T('8') > ch)
                                                num64 <<= 3;
                                        else {
                                                ++done_flag;
                                        }
                                    else /* _T('d') == comchr */
                                        num64 = MUL10(num64);

                                else
                                    ++done_flag;

                                if (!done_flag) {
                                    ++started;
                                    num64 += ch - _T('0');

                                    if (widthset && !--width)
                                        ++done_flag;
                                    else
                                        ch = INC