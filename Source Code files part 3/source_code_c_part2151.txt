ity,pValue,pdblValue)	\
    ( (This)->lpVtbl -> GetCapability(This,Capability,pValue,pdblValue) ) 

#define IAMExtDevice_get_ExternalDeviceID(This,ppszData)	\
    ( (This)->lpVtbl -> get_ExternalDeviceID(This,ppszData) ) 

#define IAMExtDevice_get_ExternalDeviceVersion(This,ppszData)	\
    ( (This)->lpVtbl -> get_ExternalDeviceVersion(This,ppszData) ) 

#define IAMExtDevice_put_DevicePower(This,PowerMode)	\
    ( (This)->lpVtbl -> put_DevicePower(This,PowerMode) ) 

#define IAMExtDevice_get_DevicePower(This,pPowerMode)	\
    ( (This)->lpVtbl -> get_DevicePower(This,pPowerMode) ) 

#define IAMExtDevice_Calibrate(This,hEvent,Mode,pStatus)	\
    ( (This)->lpVtbl -> Calibrate(This,hEvent,Mode,pStatus) ) 

#define IAMExtDevice_put_DevicePort(This,DevicePort)	\
    ( (This)->lpVtbl -> put_DevicePort(This,DevicePort) ) 

#define IAMExtDevice_get_DevicePort(This,pDevicePort)	\
    ( (This)->lpVtbl -> get_DevicePort(This,pDevicePort) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMExtDevice_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0072 */
/* [local] */ 

typedef IAMExtDevice *PEXTDEVICE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0072_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0072_v0_0_s_ifspec;

#ifndef __IAMExtTransport_INTERFACE_DEFINED__
#define __IAMExtTransport_INTERFACE_DEFINED__

/* interface IAMExtTransport */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMExtTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A03CD5F0-3045-11cf-8C44-00AA006B6814")
    IAMExtTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapability( 
            /* [in] */ long Capability,
            /* [out] */ 
            __out  long *pValue,
            /* [out] */ 
            __out  double *pdblValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MediaState( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MediaState( 
            /* [out] */ 
            __out  long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LocalControl( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LocalControl( 
            /* [out] */ 
            __out  long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [in] */ long StatusItem,
            /* [out] */ 
            __out  long *pValue) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetTransportBasicParameters( 
            /* [in] */ long Param,
            /* [out][in] */ 
            __inout  long *pValue,
            /* [out][in] */ 
            __inout  LPOLESTR *ppszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportBasicParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value,
            /* [in] */ LPCOLESTR pszData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportVideoParameters( 
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportVideoParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransportAudioParameters( 
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTransportAudioParameters( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Mode( 
            /* [in] */ long Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [out] */ 
            __out  long *pMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double dblRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [out] */ 
            __out  double *pdblRate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChase( 
            /* [out] */ 
            __out  long *pEnabled,
            /* [out] */ 
            __out  long *pOffset,
            /* [out] */ 
            __out  HEVENT *phEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetChase( 
            /* [in] */ long Enable,
            /* [in] */ long Offset,
            /* [in] */ HEVENT hEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBump( 
            /* [out] */ 
            __out  long *pSpeed,
            /* [out] */ 
            __out  long *pDuration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBump( 
            /* [in] */ long Speed,
            /* [in] */ long Duration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_AntiClogControl( 
            /* [out] */ 
            __out  long *pEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_AntiClogControl( 
            /* [in] */ long Enable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditPropertySet( 
            /* [in] */ long EditID,
            /* [out] */ 
            __out  long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEditPropertySet( 
            /* [out][in] */ long *pEditID,
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditProperty( 
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEditProperty( 
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EditStart( 
            /* [out] */ 
            __out  long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_EditStart( 
            /* [in] */ long Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMExtTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMExtTransport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMExtTransport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMExtTransport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapability )( 
            IAMExtTransport * This,
            /* [in] */ long Capability,
            /* [out] */ 
            __out  long *pValue,
            /* [out] */ 
            __out  double *pdblValue);
        
        HRESULT ( STDMETHODCALLTYPE *put_MediaState )( 
            IAMExtTransport * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *get_MediaState )( 
            IAMExtTransport * This,
            /* [out] */ 
            __out  long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *put_LocalControl )( 
            IAMExtTransport * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *get_LocalControl )( 
            IAMExtTransport * This,
            /* [out] */ 
            __out  long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IAMExtTransport * This,
            /* [in] */ long StatusItem,
            /* [out] */ 
            __out  long *pValue);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetTransportBasicParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out][in] */ 
            __inout  long *pValue,
            /* [out][in] */ 
            __inout  LPOLESTR *ppszData);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportBasicParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value,
            /* [in] */ LPCOLESTR pszData);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportVideoParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportVideoParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransportAudioParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransportAudioParameters )( 
            IAMExtTransport * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_Mode )( 
            IAMExtTransport * This,
            /* [in] */ long Mode);
        
        HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IAMExtTransport * This,
            /* [out] */ 
            __out  long *pMode);
        
        HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            IAMExtTransport * This,
            /* [in] */ double dblRate);
        
        HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            IAMExtTransport * This,
            /* [out] */ 
            __out  double *pdblRate);
        
        HRESULT ( STDMETHODCALLTYPE *GetChase )( 
            IAMExtTransport * This,
            /* [out] */ 
            __out  long *pEnabled,
            /* [out] */ 
            __out  long *pOffset,
            /* [out] */ 
            __out  HEVENT *phEvent);
        
        HRESULT ( STDMETHODCALLTYPE *SetChase )( 
            IAMExtTransport * This,
            /* [in] */ long Enable,
            /* [in] */ long Offset,
            /* [in] */ HEVENT hEvent);
        
        HRESULT ( STDMETHODCALLTYPE *GetBump )( 
            IAMExtTransport * This,
            /* [out] */ 
            __out  long *pSpeed,
            /* [out] */ 
            __out  long *pDuration);
        
        HRESULT ( STDMETHODCALLTYPE *SetBump )( 
            IAMExtTransport * This,
            /* [in] */ long Speed,
            /* [in] */ long Duration);
        
        HRESULT ( STDMETHODCALLTYPE *get_AntiClogControl )( 
            IAMExtTransport * This,
            /* [out] */ 
            __out  long *pEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *put_AntiClogControl )( 
            IAMExtTransport * This,
            /* [in] */ long Enable);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditPropertySet )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [out] */ 
            __out  long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *SetEditPropertySet )( 
            IAMExtTransport * This,
            /* [out][in] */ long *pEditID,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditProperty )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetEditProperty )( 
            IAMExtTransport * This,
            /* [in] */ long EditID,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *get_EditStart )( 
            IAMExtTransport * This,
            /* [out] */ 
            __out  long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *put_EditStart )( 
            IAMExtTransport * This,
            /* [in] */ long Value);
        
        END_INTERFACE
    } IAMExtTransportVtbl;

    interface IAMExtTransport
    {
        CONST_VTBL struct IAMExtTransportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMExtTransport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMExtTransport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMExtTransport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMExtTransport_GetCapability(This,Capability,pValue,pdblValue)	\
    ( (This)->lpVtbl -> GetCapability(This,Capability,pValue,pdblValue) ) 

#define IAMExtTransport_put_MediaState(This,State)	\
    ( (This)->lpVtbl -> put_MediaState(This,State) ) 

#define IAMExtTransport_get_MediaState(This,pState)	\
    ( (This)->lpVtbl -> get_MediaState(This,pState) ) 

#define IAMExtTransport_put_LocalControl(This,State)	\
    ( (This)->lpVtbl -> put_LocalControl(This,State) ) 

#define IAMExtTransport_get_LocalControl(This,pState)	\
    ( (This)->lpVtbl -> get_LocalControl(This,pState) ) 

#define IAMExtTransport_GetStatus(This,StatusItem,pValue)	\
    ( (This)->lpVtbl -> GetStatus(This,StatusItem,pValue) ) 

#define IAMExtTransport_GetTransportBasicParameters(This,Param,pValue,ppszData)	\
    ( (This)->lpVtbl -> GetTransportBasicParameters(This,Param,pValue,ppszData) ) 

#define IAMExtTransport_SetTransportBasicParameters(This,Param,Value,pszData)	\
    ( (This)->lpVtbl -> SetTransportBasicParameters(This,Param,Value,pszData) ) 

#define IAMExtTransport_GetTransportVideoParameters(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTransportVideoParameters(This,Param,pValue) ) 

#define IAMExtTransport_SetTransportVideoParameters(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTransportVideoParameters(This,Param,Value) ) 

#define IAMExtTransport_GetTransportAudioParameters(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTransportAudioParameters(This,Param,pValue) ) 

#define IAMExtTransport_SetTransportAudioParameters(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTransportAudioParameters(This,Param,Value) ) 

#define IAMExtTransport_put_Mode(This,Mode)	\
    ( (This)->lpVtbl -> put_Mode(This,Mode) ) 

#define IAMExtTransport_get_Mode(This,pMode)	\
    ( (This)->lpVtbl -> get_Mode(This,pMode) ) 

#define IAMExtTransport_put_Rate(This,dblRate)	\
    ( (This)->lpVtbl -> put_Rate(This,dblRate) ) 

#define IAMExtTransport_get_Rate(This,pdblRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pdblRate) ) 

#define IAMExtTransport_GetChase(This,pEnabled,pOffset,phEvent)	\
    ( (This)->lpVtbl -> GetChase(This,pEnabled,pOffset,phEvent) ) 

#define IAMExtTransport_SetChase(This,Enable,Offset,hEvent)	\
    ( (This)->lpVtbl -> SetChase(This,Enable,Offset,hEvent) ) 

#define IAMExtTransport_GetBump(This,pSpeed,pDuration)	\
    ( (This)->lpVtbl -> GetBump(This,pSpeed,pDuration) ) 

#define IAMExtTransport_SetBump(This,Speed,Duration)	\
    ( (This)->lpVtbl -> SetBump(This,Speed,Duration) ) 

#define IAMExtTransport_get_AntiClogControl(This,pEnabled)	\
    ( (This)->lpVtbl -> get_AntiClogControl(This,pEnabled) ) 

#define IAMExtTransport_put_AntiClogControl(This,Enable)	\
    ( (This)->lpVtbl -> put_AntiClogControl(This,Enable) ) 

#define IAMExtTransport_GetEditPropertySet(This,EditID,pState)	\
    ( (This)->lpVtbl -> GetEditPropertySet(This,EditID,pState) ) 

#define IAMExtTransport_SetEditPropertySet(This,pEditID,State)	\
    ( (This)->lpVtbl -> SetEditPropertySet(This,pEditID,State) ) 

#define IAMExtTransport_GetEditProperty(This,EditID,Param,pValue)	\
    ( (This)->lpVtbl -> GetEditProperty(This,EditID,Param,pValue) ) 

#define IAMExtTransport_SetEditProperty(This,EditID,Param,Value)	\
    ( (This)->lpVtbl -> SetEditProperty(This,EditID,Param,Value) ) 

#define IAMExtTransport_get_EditStart(This,pValue)	\
    ( (This)->lpVtbl -> get_EditStart(This,pValue) ) 

#define IAMExtTransport_put_EditStart(This,Value)	\
    ( (This)->lpVtbl -> put_EditStart(This,Value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMExtTransport_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0073 */
/* [local] */ 

typedef IAMExtTransport *PIAMEXTTRANSPORT;

#if 0
/* the following is what MIDL knows how to remote */
typedef struct tagTIMECODE
    {
    WORD wFrameRate;
    WORD wFrameFract;
    DWORD dwFrames;
    } 	TIMECODE;

#else /* 0 */
#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
   struct {
  WORD   wFrameRate;
  WORD   wFrameFract;
  DWORD  dwFrames;
  };
   DWORDLONG  qw;
   } TIMECODE;

#endif /* TIMECODE_DEFINED */
#endif /* 0 */
typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE
    {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
    } 	TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0073_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0073_v0_0_s_ifspec;

#ifndef __IAMTimecodeReader_INTERFACE_DEFINED__
#define __IAMTimecodeReader_INTERFACE_DEFINED__

/* interface IAMTimecodeReader */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMTimecodeReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE1-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCRMode( 
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCRMode( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_VITCLine( 
            /* [in] */ long Line) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VITCLine( 
            /* [out] */ 
            __out  long *pLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimecode( 
            /* [out] */ 
            __out  PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCRMode )( 
            IAMTimecodeReader * This,
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCRMode )( 
            IAMTimecodeReader * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_VITCLine )( 
            IAMTimecodeReader * This,
            /* [in] */ long Line);
        
        HRESULT ( STDMETHODCALLTYPE *get_VITCLine )( 
            IAMTimecodeReader * This,
            /* [out] */ 
            __out  long *pLine);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimecode )( 
            IAMTimecodeReader * This,
            /* [out] */ 
            __out  PTIMECODE_SAMPLE pTimecodeSample);
        
        END_INTERFACE
    } IAMTimecodeReaderVtbl;

    interface IAMTimecodeReader
    {
        CONST_VTBL struct IAMTimecodeReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimecodeReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimecodeReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimecodeReader_GetTCRMode(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTCRMode(This,Param,pValue) ) 

#define IAMTimecodeReader_SetTCRMode(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTCRMode(This,Param,Value) ) 

#define IAMTimecodeReader_put_VITCLine(This,Line)	\
    ( (This)->lpVtbl -> put_VITCLine(This,Line) ) 

#define IAMTimecodeReader_get_VITCLine(This,pLine)	\
    ( (This)->lpVtbl -> get_VITCLine(This,pLine) ) 

#define IAMTimecodeReader_GetTimecode(This,pTimecodeSample)	\
    ( (This)->lpVtbl -> GetTimecode(This,pTimecodeSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimecodeReader_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0074 */
/* [local] */ 

typedef IAMTimecodeReader *PIAMTIMECODEREADER;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0074_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0074_v0_0_s_ifspec;

#ifndef __IAMTimecodeGenerator_INTERFACE_DEFINED__
#define __IAMTimecodeGenerator_INTERFACE_DEFINED__

/* interface IAMTimecodeGenerator */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMTimecodeGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE0-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeGenerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCGMode( 
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCGMode( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_VITCLine( 
            /* [in] */ long Line) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_VITCLine( 
            /* [out] */ 
            __out  long *pLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimecode( 
            /* [in] */ PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimecode( 
            /* [out] */ 
            __out  PTIMECODE_SAMPLE pTimecodeSample) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeGenerator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeGenerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeGenerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCGMode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCGMode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        HRESULT ( STDMETHODCALLTYPE *put_VITCLine )( 
            IAMTimecodeGenerator * This,
            /* [in] */ long Line);
        
        HRESULT ( STDMETHODCALLTYPE *get_VITCLine )( 
            IAMTimecodeGenerator * This,
            /* [out] */ 
            __out  long *pLine);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimecode )( 
            IAMTimecodeGenerator * This,
            /* [in] */ PTIMECODE_SAMPLE pTimecodeSample);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimecode )( 
            IAMTimecodeGenerator * This,
            /* [out] */ 
            __out  PTIMECODE_SAMPLE pTimecodeSample);
        
        END_INTERFACE
    } IAMTimecodeGeneratorVtbl;

    interface IAMTimecodeGenerator
    {
        CONST_VTBL struct IAMTimecodeGeneratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeGenerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimecodeGenerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimecodeGenerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimecodeGenerator_GetTCGMode(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTCGMode(This,Param,pValue) ) 

#define IAMTimecodeGenerator_SetTCGMode(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTCGMode(This,Param,Value) ) 

#define IAMTimecodeGenerator_put_VITCLine(This,Line)	\
    ( (This)->lpVtbl -> put_VITCLine(This,Line) ) 

#define IAMTimecodeGenerator_get_VITCLine(This,pLine)	\
    ( (This)->lpVtbl -> get_VITCLine(This,pLine) ) 

#define IAMTimecodeGenerator_SetTimecode(This,pTimecodeSample)	\
    ( (This)->lpVtbl -> SetTimecode(This,pTimecodeSample) ) 

#define IAMTimecodeGenerator_GetTimecode(This,pTimecodeSample)	\
    ( (This)->lpVtbl -> GetTimecode(This,pTimecodeSample) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimecodeGenerator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0075 */
/* [local] */ 

typedef IAMTimecodeGenerator *PIAMTIMECODEGENERATOR;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0075_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0075_v0_0_s_ifspec;

#ifndef __IAMTimecodeDisplay_INTERFACE_DEFINED__
#define __IAMTimecodeDisplay_INTERFACE_DEFINED__

/* interface IAMTimecodeDisplay */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMTimecodeDisplay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B496CE2-811B-11cf-8C77-00AA006B6814")
    IAMTimecodeDisplay : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTCDisplayEnable( 
            /* [out] */ 
            __out  long *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCDisplayEnable( 
            /* [in] */ long State) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTCDisplay( 
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTCDisplay( 
            /* [in] */ long Param,
            /* [in] */ long Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMTimecodeDisplayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMTimecodeDisplay * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMTimecodeDisplay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMTimecodeDisplay * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCDisplayEnable )( 
            IAMTimecodeDisplay * This,
            /* [out] */ 
            __out  long *pState);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCDisplayEnable )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long State);
        
        HRESULT ( STDMETHODCALLTYPE *GetTCDisplay )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long Param,
            /* [out] */ 
            __out  long *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTCDisplay )( 
            IAMTimecodeDisplay * This,
            /* [in] */ long Param,
            /* [in] */ long Value);
        
        END_INTERFACE
    } IAMTimecodeDisplayVtbl;

    interface IAMTimecodeDisplay
    {
        CONST_VTBL struct IAMTimecodeDisplayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMTimecodeDisplay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMTimecodeDisplay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMTimecodeDisplay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMTimecodeDisplay_GetTCDisplayEnable(This,pState)	\
    ( (This)->lpVtbl -> GetTCDisplayEnable(This,pState) ) 

#define IAMTimecodeDisplay_SetTCDisplayEnable(This,State)	\
    ( (This)->lpVtbl -> SetTCDisplayEnable(This,State) ) 

#define IAMTimecodeDisplay_GetTCDisplay(This,Param,pValue)	\
    ( (This)->lpVtbl -> GetTCDisplay(This,Param,pValue) ) 

#define IAMTimecodeDisplay_SetTCDisplay(This,Param,Value)	\
    ( (This)->lpVtbl -> SetTCDisplay(This,Param,Value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMTimecodeDisplay_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0076 */
/* [local] */ 

typedef IAMTimecodeDisplay *PIAMTIMECODEDISPLAY;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0076_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0076_v0_0_s_ifspec;

#ifndef __IAMDevMemoryAllocator_INTERFACE_DEFINED__
#define __IAMDevMemoryAllocator_INTERFACE_DEFINED__

/* interface IAMDevMemoryAllocator */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMDevMemoryAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6545bf0-e76b-11d0-bd52-00a0c911ce86")
    IAMDevMemoryAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ 
            __out  DWORD *pdwcbTotalFree,
            /* [out] */ 
            __out  DWORD *pdwcbLargestFree,
            /* [out] */ 
            __out  DWORD *pdwcbTotalMemory,
            /* [out] */ 
            __out  DWORD *pdwcbMinimumChunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CheckMemory( 
            /* [in] */ const BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Alloc( 
            /* [out] */ 
            __deref_out_bcount(*pdwcbBuffer)  BYTE **ppBuffer,
            /* [out][in] */ 
            __inout  DWORD *pdwcbBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Free( 
            /* [in] */ BYTE *pBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevMemoryObject( 
            /* [out] */ 
            __out  IUnknown **ppUnkInnner,
            /* [in] */ IUnknown *pUnkOuter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDevMemoryAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDevMemoryAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDevMemoryAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ 
            __out  DWORD *pdwcbTotalFree,
            /* [out] */ 
            __out  DWORD *pdwcbLargestFree,
            /* [out] */ 
            __out  DWORD *pdwcbTotalMemory,
            /* [out] */ 
            __out  DWORD *pdwcbMinimumChunk);
        
        HRESULT ( STDMETHODCALLTYPE *CheckMemory )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ const BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Alloc )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ 
            __deref_out_bcount(*pdwcbBuffer)  BYTE **ppBuffer,
            /* [out][in] */ 
            __inout  DWORD *pdwcbBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *Free )( 
            IAMDevMemoryAllocator * This,
            /* [in] */ BYTE *pBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevMemoryObject )( 
            IAMDevMemoryAllocator * This,
            /* [out] */ 
            __out  IUnknown **ppUnkInnner,
            /* [in] */ IUnknown *pUnkOuter);
        
        END_INTERFACE
    } IAMDevMemoryAllocatorVtbl;

    interface IAMDevMemoryAllocator
    {
        CONST_VTBL struct IAMDevMemoryAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDevMemoryAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMDevMemoryAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMDevMemoryAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMDevMemoryAllocator_GetInfo(This,pdwcbTotalFree,pdwcbLargestFree,pdwcbTotalMemory,pdwcbMinimumChunk)	\
    ( (This)->lpVtbl -> GetInfo(This,pdwcbTotalFree,pdwcbLargestFree,pdwcbTotalMemory,pdwcbMinimumChunk) ) 

#define IAMDevMemoryAllocator_CheckMemory(This,pBuffer)	\
    ( (This)->lpVtbl -> CheckMemory(This,pBuffer) ) 

#define IAMDevMemoryAllocator_Alloc(This,ppBuffer,pdwcbBuffer)	\
    ( (This)->lpVtbl -> Alloc(This,ppBuffer,pdwcbBuffer) ) 

#define IAMDevMemoryAllocator_Free(This,pBuffer)	\
    ( (This)->lpVtbl -> Free(This,pBuffer) ) 

#define IAMDevMemoryAllocator_GetDevMemoryObject(This,ppUnkInnner,pUnkOuter)	\
    ( (This)->lpVtbl -> GetDevMemoryObject(This,ppUnkInnner,pUnkOuter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMDevMemoryAllocator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0077 */
/* [local] */ 

typedef IAMDevMemoryAllocator *PAMDEVMEMORYALLOCATOR;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0077_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0077_v0_0_s_ifspec;

#ifndef __IAMDevMemoryControl_INTERFACE_DEFINED__
#define __IAMDevMemoryControl_INTERFACE_DEFINED__

/* interface IAMDevMemoryControl */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMDevMemoryControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c6545bf1-e76b-11d0-bd52-00a0c911ce86")
    IAMDevMemoryControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryWriteSync( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteSync( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDevId( 
            /* [out] */ 
            __out  DWORD *pdwDevId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDevMemoryControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDevMemoryControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDevMemoryControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryWriteSync )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *WriteSync )( 
            IAMDevMemoryControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDevId )( 
            IAMDevMemoryControl * This,
            /* [out] */ 
            __out  DWORD *pdwDevId);
        
        END_INTERFACE
    } IAMDevMemoryControlVtbl;

    interface IAMDevMemoryControl
    {
        CONST_VTBL struct IAMDevMemoryControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDevMemoryControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMDevMemoryControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMDevMemoryControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMDevMemoryControl_QueryWriteSync(This)	\
    ( (This)->lpVtbl -> QueryWriteSync(This) ) 

#define IAMDevMemoryControl_WriteSync(This)	\
    ( (This)->lpVtbl -> WriteSync(This) ) 

#define IAMDevMemoryControl_GetDevId(This,pdwDevId)	\
    ( (This)->lpVtbl -> GetDevId(This,pdwDevId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMDevMemoryControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0078 */
/* [local] */ 

typedef IAMDevMemoryControl *PAMDEVMEMORYCONTROL;


enum _AMSTREAMSELECTINFOFLAGS
    {	AMSTREAMSELECTINFO_ENABLED	= 0x1,
	AMSTREAMSELECTINFO_EXCLUSIVE	= 0x2
    } ;

enum _AMSTREAMSELECTENABLEFLAGS
    {	AMSTREAMSELECTENABLE_ENABLE	= 0x1,
	AMSTREAMSELECTENABLE_ENABLEALL	= 0x2
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0078_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0078_v0_0_s_ifspec;

#ifndef __IAMStreamSelect_INTERFACE_DEFINED__
#define __IAMStreamSelect_INTERFACE_DEFINED__

/* interface IAMStreamSelect */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMStreamSelect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c1960960-17f5-11d1-abe1-00a0c905f375")
    IAMStreamSelect : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ 
            __out  DWORD *pcStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Info( 
            /* [in] */ long lIndex,
            /* [out] */ 
            __out_opt  AM_MEDIA_TYPE **ppmt,
            /* [out] */ 
            __out_opt  DWORD *pdwFlags,
            /* [out] */ 
            __out_opt  LCID *plcid,
            /* [out] */ 
            __out_opt  DWORD *pdwGroup,
            /* [out] */ 
            __out_opt  LPWSTR *ppszName,
            /* [out] */ 
            __out_opt  IUnknown **ppObject,
            /* [out] */ 
            __out_opt  IUnknown **ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ long lIndex,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMStreamSelectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMStreamSelect * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMStreamSelect * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMStreamSelect * This);
        
        HRESULT ( STDMETHODCALLTYPE *Count )( 
            IAMStreamSelect * This,
            /* [out] */ 
            __out  DWORD *pcStreams);
        
        HRESULT ( STDMETHODCALLTYPE *Info )( 
            IAMStreamSelect * This,
            /* [in] */ long lIndex,
            /* [out] */ 
            __out_opt  AM_MEDIA_TYPE **ppmt,
            /* [out] */ 
            __out_opt  DWORD *pdwFlags,
            /* [out] */ 
            __out_opt  LCID *plcid,
            /* [out] */ 
            __out_opt  DWORD *pdwGroup,
            /* [out] */ 
            __out_opt  LPWSTR *ppszName,
            /* [out] */ 
            __out_opt  IUnknown **ppObject,
            /* [out] */ 
            __out_opt  IUnknown **ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            IAMStreamSelect * This,
            /* [in] */ long lIndex,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAMStreamSelectVtbl;

    interface IAMStreamSelect
    {
        CONST_VTBL struct IAMStreamSelectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMStreamSelect_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMStreamSelect_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMStreamSelect_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMStreamSelect_Count(This,pcStreams)	\
    ( (This)->lpVtbl -> Count(This,pcStreams) ) 

#define IAMStreamSelect_Info(This,lIndex,ppmt,pdwFlags,plcid,pdwGroup,ppszName,ppObject,ppUnk)	\
    ( (This)->lpVtbl -> Info(This,lIndex,ppmt,pdwFlags,plcid,pdwGroup,ppszName,ppObject,ppUnk) ) 

#define IAMStreamSelect_Enable(This,lIndex,dwFlags)	\
    ( (This)->lpVtbl -> Enable(This,lIndex,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMStreamSelect_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0079 */
/* [local] */ 

typedef IAMStreamSelect *PAMSTREAMSELECT;


enum _AMRESCTL_RESERVEFLAGS
    {	AMRESCTL_RESERVEFLAGS_RESERVE	= 0,
	AMRESCTL_RESERVEFLAGS_UNRESERVE	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0079_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0079_v0_0_s_ifspec;

#ifndef __IAMResourceControl_INTERFACE_DEFINED__
#define __IAMResourceControl_INTERFACE_DEFINED__

/* interface IAMResourceControl */
/* [local][unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMResourceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8389d2d0-77d7-11d1-abe6-00a0c905f375")
    IAMResourceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reserve( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ 
            __reserved  PVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMResourceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMResourceControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMResourceControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMResourceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reserve )( 
            IAMResourceControl * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ 
            __reserved  PVOID pvReserved);
        
        END_INTERFACE
    } IAMResourceControlVtbl;

    interface IAMResourceControl
    {
        CONST_VTBL struct IAMResourceControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMResourceControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMResourceControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMResourceControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMResourceControl_Reserve(This,dwFlags,pvReserved)	\
    ( (This)->lpVtbl -> Reserve(This,dwFlags,pvReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMResourceControl_INTERFACE_DEFINED__ */


#ifndef __IAMClockAdjust_INTERFACE_DEFINED__
#define __IAMClockAdjust_INTERFACE_DEFINED__

/* interface IAMClockAdjust */
/* [local][unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMClockAdjust;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d5466b0-a49c-11d1-abe8-00a0c905f375")
    IAMClockAdjust : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetClockDelta( 
            /* [in] */ REFERENCE_TIME rtDelta) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMClockAdjustVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMClockAdjust * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMClockAdjust * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMClockAdjust * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetClockDelta )( 
            IAMClockAdjust * This,
            /* [in] */ REFERENCE_TIME rtDelta);
        
        END_INTERFACE
    } IAMClockAdjustVtbl;

    interface IAMClockAdjust
    {
        CONST_VTBL struct IAMClockAdjustVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMClockAdjust_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMClockAdjust_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMClockAdjust_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMClockAdjust_SetClockDelta(This,rtDelta)	\
    ( (This)->lpVtbl -> SetClockDelta(This,rtDelta) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMClockAdjust_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0081 */
/* [local] */ 


enum _AM_FILTER_MISC_FLAGS
    {	AM_FILTER_MISC_FLAGS_IS_RENDERER	= 0x1,
	AM_FILTER_MISC_FLAGS_IS_SOURCE	= 0x2
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0081_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0081_v0_0_s_ifspec;

#ifndef __IAMFilterMiscFlags_INTERFACE_DEFINED__
#define __IAMFilterMiscFlags_INTERFACE_DEFINED__

/* interface IAMFilterMiscFlags */
/* [local][unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMFilterMiscFlags;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2dd74950-a890-11d1-abe8-00a0c905f375")
    IAMFilterMiscFlags : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE GetMiscFlags( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMFilterMiscFlagsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMFilterMiscFlags * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMFilterMiscFlags * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMFilterMiscFlags * This);
        
        ULONG ( STDMETHODCALLTYPE *GetMiscFlags )( 
            IAMFilterMiscFlags * This);
        
        END_INTERFACE
    } IAMFilterMiscFlagsVtbl;

    interface IAMFilterMiscFlags
    {
        CONST_VTBL struct IAMFilterMiscFlagsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMFilterMiscFlags_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMFilterMiscFlags_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMFilterMiscFlags_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMFilterMiscFlags_GetMiscFlags(This)	\
    ( (This)->lpVtbl -> GetMiscFlags(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMFilterMiscFlags_INTERFACE_DEFINED__ */


#ifndef __IDrawVideoImage_INTERFACE_DEFINED__
#define __IDrawVideoImage_INTERFACE_DEFINED__

/* interface IDrawVideoImage */
/* [unique][uuid][local][object][local] */ 


EXTERN_C const IID IID_IDrawVideoImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48efb120-ab49-11d2-aed2-00a0c995e8d5")
    IDrawVideoImage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DrawVideoImageBegin( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawVideoImageEnd( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawVideoImageDraw( 
            /* [in] */ HDC hdc,
            /* [in] */ 
            __in  LPRECT lprcSrc,
            /* [in] */ 
            __in  LPRECT lprcDst) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDrawVideoImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDrawVideoImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDrawVideoImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDrawVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawVideoImageBegin )( 
            IDrawVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawVideoImageEnd )( 
            IDrawVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawVideoImageDraw )( 
            IDrawVideoImage * This,
            /* [in] */ HDC hdc,
            /* [in] */ 
            __in  LPRECT lprcSrc,
            /* [in] */ 
            __in  LPRECT lprcDst);
        
        END_INTERFACE
    } IDrawVideoImageVtbl;

    interface IDrawVideoImage
    {
        CONST_VTBL struct IDrawVideoImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDrawVideoImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDrawVideoImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDrawVideoImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDrawVideoImage_DrawVideoImageBegin(This)	\
    ( (This)->lpVtbl -> DrawVideoImageBegin(This) ) 

#define IDrawVideoImage_DrawVideoImageEnd(This)	\
    ( (This)->lpVtbl -> DrawVideoImageEnd(This) ) 

#define IDrawVideoImage_DrawVideoImageDraw(This,hdc,lprcSrc,lprcDst)	\
    ( (This)->lpVtbl -> DrawVideoImageDraw(This,hdc,lprcSrc,lprcDst) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDrawVideoImage_INTERFACE_DEFINED__ */


#ifndef __IDecimateVideoImage_INTERFACE_DEFINED__
#define __IDecimateVideoImage_INTERFACE_DEFINED__

/* interface IDecimateVideoImage */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDecimateVideoImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e5ea3e0-e924-11d2-b6da-00a0c995e8df")
    IDecimateVideoImage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDecimationImageSize( 
            /* [in] */ long lWidth,
            /* [in] */ long lHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetDecimationImageSize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDecimateVideoImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDecimateVideoImage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDecimateVideoImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDecimateVideoImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDecimationImageSize )( 
            IDecimateVideoImage * This,
            /* [in] */ long lWidth,
            /* [in] */ long lHeight);
        
        HRESULT ( STDMETHODCALLTYPE *ResetDecimationImageSize )( 
            IDecimateVideoImage * This);
        
        END_INTERFACE
    } IDecimateVideoImageVtbl;

    interface IDecimateVideoImage
    {
        CONST_VTBL struct IDecimateVideoImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDecimateVideoImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDecimateVideoImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDecimateVideoImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDecimateVideoImage_SetDecimationImageSize(This,lWidth,lHeight)	\
    ( (This)->lpVtbl -> SetDecimationImageSize(This,lWidth,lHeight) ) 

#define IDecimateVideoImage_ResetDecimationImageSize(This)	\
    ( (This)->lpVtbl -> ResetDecimationImageSize(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDecimateVideoImage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0084 */
/* [local] */ 

typedef 
enum _DECIMATION_USAGE
    {	DECIMATION_LEGACY	= 0,
	DECIMATION_USE_DECODER_ONLY	= ( DECIMATION_LEGACY + 1 ) ,
	DECIMATION_USE_VIDEOPORT_ONLY	= ( DECIMATION_USE_DECODER_ONLY + 1 ) ,
	DECIMATION_USE_OVERLAY_ONLY	= ( DECIMATION_USE_VIDEOPORT_ONLY + 1 ) ,
	DECIMATION_DEFAULT	= ( DECIMATION_USE_OVERLAY_ONLY + 1 ) 
    } 	DECIMATION_USAGE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0084_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0084_v0_0_s_ifspec;

#ifndef __IAMVideoDecimationProperties_INTERFACE_DEFINED__
#define __IAMVideoDecimationProperties_INTERFACE_DEFINED__

/* interface IAMVideoDecimationProperties */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMVideoDecimationProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60d32930-13da-11d3-9ec6-c4fcaef5c7be")
    IAMVideoDecimationProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryDecimationUsage( 
            /* [out] */ 
            __out  DECIMATION_USAGE *lpUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDecimationUsage( 
            /* [in] */ DECIMATION_USAGE Usage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMVideoDecimationPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMVideoDecimationProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMVideoDecimationProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMVideoDecimationProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDecimationUsage )( 
            IAMVideoDecimationProperties * This,
            /* [out] */ 
            __out  DECIMATION_USAGE *lpUsage);
        
        HRESULT ( STDMETHODCALLTYPE *SetDecimationUsage )( 
            IAMVideoDecimationProperties * This,
            /* [in] */ DECIMATION_USAGE Usage);
        
        END_INTERFACE
    } IAMVideoDecimationPropertiesVtbl;

    interface IAMVideoDecimationProperties
    {
        CONST_VTBL struct IAMVideoDecimationPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMVideoDecimationProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMVideoDecimationProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMVideoDecimationProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMVideoDecimationProperties_QueryDecimationUsage(This,lpUsage)	\
    ( (This)->lpVtbl -> QueryDecimationUsage(This,lpUsage) ) 

#define IAMVideoDecimationProperties_SetDecimationUsage(This,Usage)	\
    ( (This)->lpVtbl -> SetDecimationUsage(This,Usage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMVideoDecimationProperties_INTERFACE_DEFINED__ */


#ifndef __IVideoFrameStep_INTERFACE_DEFINED__
#define __IVideoFrameStep_INTERFACE_DEFINED__

/* interface IVideoFrameStep */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IVideoFrameStep;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e46a9787-2b71-444d-a4b5-1fab7b708d6a")
    IVideoFrameStep : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Step( 
            DWORD dwFrames,
            /* [unique] */ 
            __in_opt  IUnknown *pStepObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanStep( 
            long bMultiple,
            /* [unique] */ 
            __in_opt  IUnknown *pStepObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelStep( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoFrameStepVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoFrameStep * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoFrameStep * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoFrameStep * This);
        
        HRESULT ( STDMETHODCALLTYPE *Step )( 
            IVideoFrameStep * This,
            DWORD dwFrames,
            /* [unique] */ 
            __in_opt  IUnknown *pStepObject);
        
        HRESULT ( STDMETHODCALLTYPE *CanStep )( 
            IVideoFrameStep * This,
            long bMultiple,
            /* [unique] */ 
            __in_opt  IUnknown *pStepObject);
        
        HRESULT ( STDMETHODCALLTYPE *CancelStep )( 
            IVideoFrameStep * This);
        
        END_INTERFACE
    } IVideoFrameStepVtbl;

    interface IVideoFrameStep
    {
        CONST_VTBL struct IVideoFrameStepVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoFrameStep_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVideoFrameStep_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVideoFrameStep_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVideoFrameStep_Step(This,dwFrames,pStepObject)	\
    ( (This)->lpVtbl -> Step(This,dwFrames,pStepObject) ) 

#define IVideoFrameStep_CanStep(This,bMultiple,pStepObject)	\
    ( (This)->lpVtbl -> CanStep(This,bMultiple,pStepObject) ) 

#define IVideoFrameStep_CancelStep(This)	\
    ( (This)->lpVtbl -> CancelStep(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVideoFrameStep_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0086 */
/* [local] */ 


enum _AM_PUSHSOURCE_FLAGS
    {	AM_PUSHSOURCECAPS_INTERNAL_RM	= 0x1,
	AM_PUSHSOURCECAPS_NOT_LIVE	= 0x2,
	AM_PUSHSOURCECAPS_PRIVATE_CLOCK	= 0x4,
	AM_PUSHSOURCEREQS_USE_STREAM_CLOCK	= 0x10000,
	AM_PUSHSOURCEREQS_USE_CLOCK_CHAIN	= 0x20000
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0086_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0086_v0_0_s_ifspec;

#ifndef __IAMLatency_INTERFACE_DEFINED__
#define __IAMLatency_INTERFACE_DEFINED__

/* interface IAMLatency */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMLatency;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62EA93BA-EC62-11d2-B770-00C04FB6BD3D")
    IAMLatency : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLatency( 
            /* [in] */ 
            __out  REFERENCE_TIME *prtLatency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMLatencyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMLatency * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMLatency * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMLatency * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLatency )( 
            IAMLatency * This,
            /* [in] */ 
            __out  REFERENCE_TIME *prtLatency);
        
        END_INTERFACE
    } IAMLatencyVtbl;

    interface IAMLatency
    {
        CONST_VTBL struct IAMLatencyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMLatency_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMLatency_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMLatency_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMLatency_GetLatency(This,prtLatency)	\
    ( (This)->lpVtbl -> GetLatency(This,prtLatency) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMLatency_INTERFACE_DEFINED__ */


#ifndef __IAMPushSource_INTERFACE_DEFINED__
#define __IAMPushSource_INTERFACE_DEFINED__

/* interface IAMPushSource */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMPushSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F185FE76-E64E-11d2-B76E-00C04FB6BD3D")
    IAMPushSource : public IAMLatency
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPushSourceFlags( 
            /* [out] */ 
            __out  ULONG *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPushSourceFlags( 
            /* [in] */ ULONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamOffset( 
            /* [in] */ REFERENCE_TIME rtOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamOffset( 
            /* [out] */ 
            __out  REFERENCE_TIME *prtOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxStreamOffset( 
            /* [out] */ 
            __out  REFERENCE_TIME *prtMaxOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxStreamOffset( 
            /* [in] */ REFERENCE_TIME rtMaxOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMPushSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMPushSource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMPushSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMPushSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLatency )( 
            IAMPushSource * This,
            /* [in] */ 
            __out  REFERENCE_TIME *prtLatency);
        
        HRESULT ( STDMETHODCALLTYPE *GetPushSourceFlags )( 
            IAMPushSource * This,
            /* [out] */ 
            __out  ULONG *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPushSourceFlags )( 
            IAMPushSource * This,
            /* [in] */ ULONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamOffset )( 
            IAMPushSource * This,
            /* [in] */ REFERENCE_TIME rtOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamOffset )( 
            IAMPushSource * This,
            /* [out] */ 
            __out  REFERENCE_TIME *prtOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxStreamOffset )( 
            IAMPushSource * This,
            /* [out] */ 
            __out  REFERENCE_TIME *prtMaxOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxStreamOffset )( 
            IAMPushSource * This,
            /* [in] */ REFERENCE_TIME rtMaxOffset);
        
        END_INTERFACE
    } IAMPushSourceVtbl;

    interface IAMPushSource
    {
        CONST_VTBL struct IAMPushSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMPushSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMPushSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMPushSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMPushSource_GetLatency(This,prtLatency)	\
    ( (This)->lpVtbl -> GetLatency(This,prtLatency) ) 


#define IAMPushSource_GetPushSourceFlags(This,pFlags)	\
    ( (This)->lpVtbl -> GetPushSourceFlags(This,pFlags) ) 

#define IAMPushSource_SetPushSourceFlags(This,Flags)	\
    ( (This)->lpVtbl -> SetPushSourceFlags(This,Flags) ) 

#define IAMPushSource_SetStreamOffset(This,rtOffset)	\
    ( (This)->lpVtbl -> SetStreamOffset(This,rtOffset) ) 

#define IAMPushSource_GetStreamOffset(This,prtOffset)	\
    ( (This)->lpVtbl -> GetStreamOffset(This,prtOffset) ) 

#define IAMPushSource_GetMaxStreamOffset(This,prtMaxOffset)	\
    ( (This)->lpVtbl -> GetMaxStreamOffset(This,prtMaxOffset) ) 

#define IAMPushSource_SetMaxStreamOffset(This,rtMaxOffset)	\
    ( (This)->lpVtbl -> SetMaxStreamOffset(This,rtMaxOffset) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMPushSource_INTERFACE_DEFINED__ */


#ifndef __IAMDeviceRemoval_INTERFACE_DEFINED__
#define __IAMDeviceRemoval_INTERFACE_DEFINED__

/* interface IAMDeviceRemoval */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMDeviceRemoval;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f90a6130-b658-11d2-ae49-0000f8754b99")
    IAMDeviceRemoval : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeviceInfo( 
            /* [out] */ 
            __out  CLSID *pclsidInterfaceClass,
            /* [out] */ 
            __out  LPWSTR *pwszSymbolicLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reassociate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disassociate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDeviceRemovalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDeviceRemoval * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDeviceRemoval * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDeviceRemoval * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceInfo )( 
            IAMDeviceRemoval * This,
            /* [out] */ 
            __out  CLSID *pclsidInterfaceClass,
            /* [out] */ 
            __out  LPWSTR *pwszSymbolicLink);
        
        HRESULT ( STDMETHODCALLTYPE *Reassociate )( 
            IAMDeviceRemoval * This);
        
        HRESULT ( STDMETHODCALLTYPE *Disassociate )( 
            IAMDeviceRemoval * This);
        
        END_INTERFACE
    } IAMDeviceRemovalVtbl;

    interface IAMDeviceRemoval
    {
        CONST_VTBL struct IAMDeviceRemovalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDeviceRemoval_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMDeviceRemoval_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMDeviceRemoval_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMDeviceRemoval_DeviceInfo(This,pclsidInterfaceClass,pwszSymbolicLink)	\
    ( (This)->lpVtbl -> DeviceInfo(This,pclsidInterfaceClass,pwszSymbolicLink) ) 

#define IAMDeviceRemoval_Reassociate(This)	\
    ( (This)->lpVtbl -> Reassociate(This) ) 

#define IAMDeviceRemoval_Disassociate(This)	\
    ( (This)->lpVtbl -> Disassociate(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMDeviceRemoval_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0088 */
/* [local] */ 

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0088_0001
    {
    DWORD dwDVAAuxSrc;
    DWORD dwDVAAuxCtl;
    DWORD dwDVAAuxSrc1;
    DWORD dwDVAAuxCtl1;
    DWORD dwDVVAuxSrc;
    DWORD dwDVVAuxCtl;
    DWORD dwDVReserved[ 2 ];
    } 	DVINFO;

typedef struct __MIDL___MIDL_itf_strmif_0000_0088_0001 *PDVINFO;


enum _DVENCODERRESOLUTION
    {	DVENCODERRESOLUTION_720x480	= 2012,
	DVENCODERRESOLUTION_360x240	= 2013,
	DVENCODERRESOLUTION_180x120	= 2014,
	DVENCODERRESOLUTION_88x60	= 2015
    } ;

enum _DVENCODERVIDEOFORMAT
    {	DVENCODERVIDEOFORMAT_NTSC	= 2000,
	DVENCODERVIDEOFORMAT_PAL	= 2001
    } ;

enum _DVENCODERFORMAT
    {	DVENCODERFORMAT_DVSD	= 2007,
	DVENCODERFORMAT_DVHD	= 2008,
	DVENCODERFORMAT_DVSL	= 2009
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0088_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0088_v0_0_s_ifspec;

#ifndef __IDVEnc_INTERFACE_DEFINED__
#define __IDVEnc_INTERFACE_DEFINED__

/* interface IDVEnc */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVEnc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d18e17a0-aacb-11d0-afb0-00aa00b67a42")
    IDVEnc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_IFormatResolution( 
            /* [out] */ 
            __out  int *VideoFormat,
            /* [out] */ 
            __out  int *DVFormat,
            /* [out] */ 
            __out  int *Resolution,
            /* [in] */ BYTE fDVInfo,
            /* [out] */ 
            __out  DVINFO *sDVInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_IFormatResolution( 
            /* [in] */ int VideoFormat,
            /* [in] */ int DVFormat,
            /* [in] */ int Resolution,
            /* [in] */ BYTE fDVInfo,
            /* [in] */ 
            __in  DVINFO *sDVInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVEncVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVEnc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVEnc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVEnc * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_IFormatResolution )( 
            IDVEnc * This,
            /* [out] */ 
            __out  int *VideoFormat,
            /* [out] */ 
            __out  int *DVFormat,
            /* [out] */ 
            __out  int *Resolution,
            /* [in] */ BYTE fDVInfo,
            /* [out] */ 
            __out  DVINFO *sDVInfo);
        
        HRESULT ( STDMETHODCALLTYPE *put_IFormatResolution )( 
            IDVEnc * This,
            /* [in] */ int VideoFormat,
            /* [in] */ int DVFormat,
            /* [in] */ int Resolution,
            /* [in] */ BYTE fDVInfo,
            /* [in] */ 
            __in  DVINFO *sDVInfo);
        
        END_INTERFACE
    } IDVEncVtbl;

    interface IDVEnc
    {
        CONST_VTBL struct IDVEncVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVEnc_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVEnc_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVEnc_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVEnc_get_IFormatResolution(This,VideoFormat,DVFormat,Resolution,fDVInfo,sDVInfo)	\
    ( (This)->lpVtbl -> get_IFormatResolution(This,VideoFormat,DVFormat,Resolution,fDVInfo,sDVInfo) ) 

#define IDVEnc_put_IFormatResolution(This,VideoFormat,DVFormat,Resolution,fDVInfo,sDVInfo)	\
    ( (This)->lpVtbl -> put_IFormatResolution(This,VideoFormat,DVFormat,Resolution,fDVInfo,sDVInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVEnc_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0089 */
/* [local] */ 


enum _DVDECODERRESOLUTION
    {	DVDECODERRESOLUTION_720x480	= 1000,
	DVDECODERRESOLUTION_360x240	= 1001,
	DVDECODERRESOLUTION_180x120	= 1002,
	DVDECODERRESOLUTION_88x60	= 1003
    } ;

enum _DVRESOLUTION
    {	DVRESOLUTION_FULL	= 1000,
	DVRESOLUTION_HALF	= 1001,
	DVRESOLUTION_QUARTER	= 1002,
	DVRESOLUTION_DC	= 1003
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0089_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0089_v0_0_s_ifspec;

#ifndef __IIPDVDec_INTERFACE_DEFINED__
#define __IIPDVDec_INTERFACE_DEFINED__

/* interface IIPDVDec */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IIPDVDec;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b8e8bd60-0bfe-11d0-af91-00aa00b67a42")
    IIPDVDec : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_IPDisplay( 
            /* [out] */ 
            __out  int *displayPix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_IPDisplay( 
            /* [in] */ int displayPix) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIPDVDecVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIPDVDec * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIPDVDec * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIPDVDec * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_IPDisplay )( 
            IIPDVDec * This,
            /* [out] */ 
            __out  int *displayPix);
        
        HRESULT ( STDMETHODCALLTYPE *put_IPDisplay )( 
            IIPDVDec * This,
            /* [in] */ int displayPix);
        
        END_INTERFACE
    } IIPDVDecVtbl;

    interface IIPDVDec
    {
        CONST_VTBL struct IIPDVDecVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIPDVDec_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIPDVDec_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIPDVDec_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIPDVDec_get_IPDisplay(This,displayPix)	\
    ( (This)->lpVtbl -> get_IPDisplay(This,displayPix) ) 

#define IIPDVDec_put_IPDisplay(This,displayPix)	\
    ( (This)->lpVtbl -> put_IPDisplay(This,displayPix) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIPDVDec_INTERFACE_DEFINED__ */


#ifndef __IDVRGB219_INTERFACE_DEFINED__
#define __IDVRGB219_INTERFACE_DEFINED__

/* interface IDVRGB219 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDVRGB219;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("58473A19-2BC8-4663-8012-25F81BABDDD1")
    IDVRGB219 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRGB219( 
            /* [in] */ BOOL bState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVRGB219Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVRGB219 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVRGB219 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVRGB219 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRGB219 )( 
            IDVRGB219 * This,
            /* [in] */ BOOL bState);
        
        END_INTERFACE
    } IDVRGB219Vtbl;

    interface IDVRGB219
    {
        CONST_VTBL struct IDVRGB219Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVRGB219_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVRGB219_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVRGB219_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVRGB219_SetRGB219(This,bState)	\
    ( (This)->lpVtbl -> SetRGB219(This,bState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVRGB219_INTERFACE_DEFINED__ */


#ifndef __IDVSplitter_INTERFACE_DEFINED__
#define __IDVSplitter_INTERFACE_DEFINED__

/* interface IDVSplitter */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IDVSplitter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92a3a302-da7c-4a1f-ba7e-1802bb5d2d02")
    IDVSplitter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DiscardAlternateVideoFrames( 
            /* [in] */ int nDiscard) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDVSplitterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDVSplitter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDVSplitter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDVSplitter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardAlternateVideoFrames )( 
            IDVSplitter * This,
            /* [in] */ int nDiscard);
        
        END_INTERFACE
    } IDVSplitterVtbl;

    interface IDVSplitter
    {
        CONST_VTBL struct IDVSplitterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDVSplitter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDVSplitter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDVSplitter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDVSplitter_DiscardAlternateVideoFrames(This,nDiscard)	\
    ( (This)->lpVtbl -> DiscardAlternateVideoFrames(This,nDiscard) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDVSplitter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0092 */
/* [local] */ 


enum _AM_AUDIO_RENDERER_STAT_PARAM
    {	AM_AUDREND_STAT_PARAM_BREAK_COUNT	= 1,
	AM_AUDREND_STAT_PARAM_SLAVE_MODE	= ( AM_AUDREND_STAT_PARAM_BREAK_COUNT + 1 ) ,
	AM_AUDREND_STAT_PARAM_SILENCE_DUR	= ( AM_AUDREND_STAT_PARAM_SLAVE_MODE + 1 ) ,
	AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR	= ( AM_AUDREND_STAT_PARAM_SILENCE_DUR + 1 ) ,
	AM_AUDREND_STAT_PARAM_DISCONTINUITIES	= ( AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_RATE	= ( AM_AUDREND_STAT_PARAM_DISCONTINUITIES + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR	= ( AM_AUDREND_STAT_PARAM_SLAVE_RATE + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR	= ( AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR	= ( AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR + 1 ) ,
	AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR	= ( AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR + 1 ) ,
	AM_AUDREND_STAT_PARAM_BUFFERFULLNESS	= ( AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR + 1 ) ,
	AM_AUDREND_STAT_PARAM_JITTER	= ( AM_AUDREND_STAT_PARAM_BUFFERFULLNESS + 1 ) 
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0092_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0092_v0_0_s_ifspec;

#ifndef __IAMAudioRendererStats_INTERFACE_DEFINED__
#define __IAMAudioRendererStats_INTERFACE_DEFINED__

/* interface IAMAudioRendererStats */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMAudioRendererStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22320CB2-D41A-11d2-BF7C-D7CB9DF0BF93")
    IAMAudioRendererStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatParam( 
            /* [in] */ DWORD dwParam,
            /* [out] */ 
            __out  DWORD *pdwParam1,
            /* [out] */ 
            __out  DWORD *pdwParam2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMAudioRendererStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMAudioRendererStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMAudioRendererStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMAudioRendererStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatParam )( 
            IAMAudioRendererStats * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ 
            __out  DWORD *pdwParam1,
            /* [out] */ 
            __out  DWORD *pdwParam2);
        
        END_INTERFACE
    } IAMAudioRendererStatsVtbl;

    interface IAMAudioRendererStats
    {
        CONST_VTBL struct IAMAudioRendererStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMAudioRendererStats_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMAudioRendererStats_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMAudioRendererStats_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMAudioRendererStats_GetStatParam(This,dwParam,pdwParam1,pdwParam2)	\
    ( (This)->lpVtbl -> GetStatParam(This,dwParam,pdwParam1,pdwParam2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMAudioRendererStats_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0094 */
/* [local] */ 


enum _AM_INTF_SEARCH_FLAGS
    {	AM_INTF_SEARCH_INPUT_PIN	= 0x1,
	AM_INTF_SEARCH_OUTPUT_PIN	= 0x2,
	AM_INTF_SEARCH_FILTER	= 0x4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0094_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0094_v0_0_s_ifspec;

#ifndef __IAMGraphStreams_INTERFACE_DEFINED__
#define __IAMGraphStreams_INTERFACE_DEFINED__

/* interface IAMGraphStreams */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMGraphStreams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("632105FA-072E-11d3-8AF9-00C04FB6BD3D")
    IAMGraphStreams : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindUpstreamInterface( 
            /* [in] */ IPin *pPin,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __out  void **ppvInterface,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SyncUsingStreamOffset( 
            /* [in] */ BOOL bUseStreamOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxGraphLatency( 
            /* [in] */ REFERENCE_TIME rtMaxGraphLatency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMGraphStreamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMGraphStreams * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMGraphStreams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMGraphStreams * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindUpstreamInterface )( 
            IAMGraphStreams * This,
            /* [in] */ IPin *pPin,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __out  void **ppvInterface,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SyncUsingStreamOffset )( 
            IAMGraphStreams * This,
            /* [in] */ BOOL bUseStreamOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxGraphLatency )( 
            IAMGraphStreams * This,
            /* [in] */ REFERENCE_TIME rtMaxGraphLatency);
        
        END_INTERFACE
    } IAMGraphStreamsVtbl;

    interface IAMGraphStreams
    {
        CONST_VTBL struct IAMGraphStreamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMGraphStreams_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMGraphStreams_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMGraphStreams_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMGraphStreams_FindUpstreamInterface(This,pPin,riid,ppvInterface,dwFlags)	\
    ( (This)->lpVtbl -> FindUpstreamInterface(This,pPin,riid,ppvInterface,dwFlags) ) 

#define IAMGraphStreams_SyncUsingStreamOffset(This,bUseStreamOffset)	\
    ( (This)->lpVtbl -> SyncUsingStreamOffset(This,bUseStreamOffset) ) 

#define IAMGraphStreams_SetMaxGraphLatency(This,rtMaxGraphLatency)	\
    ( (This)->lpVtbl -> SetMaxGraphLatency(This,rtMaxGraphLatency) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMGraphStreams_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0095 */
/* [local] */ 


enum AMOVERLAYFX
    {	AMOVERFX_NOFX	= 0,
	AMOVERFX_MIRRORLEFTRIGHT	= 0x2,
	AMOVERFX_MIRRORUPDOWN	= 0x4,
	AMOVERFX_DEINTERLACE	= 0x8
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0095_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0095_v0_0_s_ifspec;

#ifndef __IAMOverlayFX_INTERFACE_DEFINED__
#define __IAMOverlayFX_INTERFACE_DEFINED__

/* interface IAMOverlayFX */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMOverlayFX;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62fae250-7e65-4460-bfc9-6398b322073c")
    IAMOverlayFX : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryOverlayFXCaps( 
            /* [out] */ 
            __out  DWORD *lpdwOverlayFXCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOverlayFX( 
            /* [in] */ DWORD dwOverlayFX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOverlayFX( 
            /* [out] */ 
            __out  DWORD *lpdwOverlayFX) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMOverlayFXVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMOverlayFX * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMOverlayFX * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMOverlayFX * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryOverlayFXCaps )( 
            IAMOverlayFX * This,
            /* [out] */ 
            __out  DWORD *lpdwOverlayFXCaps);
        
        HRESULT ( STDMETHODCALLTYPE *SetOverlayFX )( 
            IAMOverlayFX * This,
            /* [in] */ DWORD dwOverlayFX);
        
        HRESULT ( STDMETHODCALLTYPE *GetOverlayFX )( 
            IAMOverlayFX * This,
            /* [out] */ 
            __out  DWORD *lpdwOverlayFX);
        
        END_INTERFACE
    } IAMOverlayFXVtbl;

    interface IAMOverlayFX
    {
        CONST_VTBL struct IAMOverlayFXVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMOverlayFX_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMOverlayFX_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMOverlayFX_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMOverlayFX_QueryOverlayFXCaps(This,lpdwOverlayFXCaps)	\
    ( (This)->lpVtbl -> QueryOverlayFXCaps(This,lpdwOverlayFXCaps) ) 

#define IAMOverlayFX_SetOverlayFX(This,dwOverlayFX)	\
    ( (This)->lpVtbl -> SetOverlayFX(This,dwOverlayFX) ) 

#define IAMOverlayFX_GetOverlayFX(This,lpdwOverlayFX)	\
    ( (This)->lpVtbl -> GetOverlayFX(This,lpdwOverlayFX) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMOverlayFX_INTERFACE_DEFINED__ */


#ifndef __IAMOpenProgress_INTERFACE_DEFINED__
#define __IAMOpenProgress_INTERFACE_DEFINED__

/* interface IAMOpenProgress */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMOpenProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E1C39A1-DE53-11cf-AA63-0080C744528D")
    IAMOpenProgress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryProgress( 
            /* [out] */ 
            __out  LONGLONG *pllTotal,
            /* [out] */ 
            __out  LONGLONG *pllCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortOperation( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMOpenProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMOpenProgress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMOpenProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMOpenProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryProgress )( 
            IAMOpenProgress * This,
            /* [out] */ 
            __out  LONGLONG *pllTotal,
            /* [out] */ 
            __out  LONGLONG *pllCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *AbortOperation )( 
            IAMOpenProgress * This);
        
        END_INTERFACE
    } IAMOpenProgressVtbl;

    interface IAMOpenProgress
    {
        CONST_VTBL struct IAMOpenProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMOpenProgress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMOpenProgress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMOpenProgress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMOpenProgress_QueryProgress(This,pllTotal,pllCurrent)	\
    ( (This)->lpVtbl -> QueryProgress(This,pllTotal,pllCurrent) ) 

#define IAMOpenProgress_AbortOperation(This)	\
    ( (This)->lpVtbl -> AbortOperation(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMOpenProgress_INTERFACE_DEFINED__ */


#ifndef __IMpeg2Demultiplexer_INTERFACE_DEFINED__
#define __IMpeg2Demultiplexer_INTERFACE_DEFINED__

/* interface IMpeg2Demultiplexer */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IMpeg2Demultiplexer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("436eee9c-264f-4242-90e1-4e330c107512")
    IMpeg2Demultiplexer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateOutputPin( 
            /* [in] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ 
            __in  LPWSTR pszPinName,
            /* [out] */ 
            __out  IPin **ppIPin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputPinMediaType( 
            /* [in] */ 
            __in  LPWSTR pszPinName,
            /* [in] */ 
            __in  AM_MEDIA_TYPE *pMediaType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteOutputPin( 
            /* [in] */ 
            __in  LPWSTR pszPinName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMpeg2DemultiplexerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMpeg2Demultiplexer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMpeg2Demultiplexer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMpeg2Demultiplexer * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateOutputPin )( 
            IMpeg2Demultiplexer * This,
            /* [in] */ AM_MEDIA_TYPE *pMediaType,
            /* [in] */ 
            __in  LPWSTR pszPinName,
            /* [out] */ 
            __out  IPin **ppIPin);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputPinMediaType )( 
            IMpeg2Demultiplexer * This,
            /* [in] */ 
            __in  LPWSTR pszPinName,
            /* [in] */ 
            __in  AM_MEDIA_TYPE *pMediaType);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteOutputPin )( 
            IMpeg2Demultiplexer * This,
            /* [in] */ 
            __in  LPWSTR pszPinName);
        
        END_INTERFACE
    } IMpeg2DemultiplexerVtbl;

    interface IMpeg2Demultiplexer
    {
        CONST_VTBL struct IMpeg2DemultiplexerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMpeg2Demultiplexer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMpeg2Demultiplexer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMpeg2Demultiplexer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMpeg2Demultiplexer_CreateOutputPin(This,pMediaType,pszPinName,ppIPin)	\
    ( (This)->lpVtbl -> CreateOutputPin(This,pMediaType,pszPinName,ppIPin) ) 

#define IMpeg2Demultiplexer_SetOutputPinMediaType(This,pszPinName,pMediaType)	\
    ( (This)->lpVtbl -> SetOutputPinMediaType(This,pszPinName,pMediaType) ) 

#define IMpeg2Demultiplexer_DeleteOutputPin(This,pszPinName)	\
    ( (This)->lpVtbl -> DeleteOutputPin(This,pszPinName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMpeg2Demultiplexer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0098 */
/* [local] */ 

#define MPEG2_PROGRAM_STREAM_MAP                 0x00000000
#define MPEG2_PROGRAM_ELEMENTARY_STREAM          0x00000001
#define MPEG2_PROGRAM_DIRECTORY_PES_PACKET       0x00000002
#define MPEG2_PROGRAM_PACK_HEADER                0x00000003
#define MPEG2_PROGRAM_PES_STREAM                 0x00000004
#define MPEG2_PROGRAM_SYSTEM_HEADER              0x00000005
#define SUBSTREAM_FILTER_VAL_NONE                0x10000000
typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0098_0001
    {
    ULONG stream_id;
    DWORD dwMediaSampleContent;
    ULONG ulSubstreamFilterValue;
    int iDataOffset;
    } 	STREAM_ID_MAP;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0098_v0_0_s_ifspec;

#ifndef __IEnumStreamIdMap_INTERFACE_DEFINED__
#define __IEnumStreamIdMap_INTERFACE_DEFINED__

/* interface IEnumStreamIdMap */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IEnumStreamIdMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("945C1566-6202-46fc-96C7-D87F289C6534")
    IEnumStreamIdMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ 
            __out_ecount_part(cRequest, *pcReceived)  STREAM_ID_MAP *pStreamIdMap,
            /* [out] */ 
            __out_opt  ULONG *pcReceived) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cRecords) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ 
            __out  IEnumStreamIdMap **ppIEnumStreamIdMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumStreamIdMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumStreamIdMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumStreamIdMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumStreamIdMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumStreamIdMap * This,
            /* [in] */ ULONG cRequest,
            /* [size_is][out][in] */ 
            __out_ecount_part(cRequest, *pcReceived)  STREAM_ID_MAP *pStreamIdMap,
            /* [out] */ 
            __out_opt  ULONG *pcReceived);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumStreamIdMap * This,
            /* [in] */ ULONG cRecords);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumStreamIdMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumStreamIdMap * This,
            /* [out] */ 
            __out  IEnumStreamIdMap **ppIEnumStreamIdMap);
        
        END_INTERFACE
    } IEnumStreamIdMapVtbl;

    interface IEnumStreamIdMap
    {
        CONST_VTBL struct IEnumStreamIdMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumStreamIdMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumStreamIdMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumStreamIdMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumStreamIdMap_Next(This,cRequest,pStreamIdMap,pcReceived)	\
    ( (This)->lpVtbl -> Next(This,cRequest,pStreamIdMap,pcReceived) ) 

#define IEnumStreamIdMap_Skip(This,cRecords)	\
    ( (This)->lpVtbl -> Skip(This,cRecords) ) 

#define IEnumStreamIdMap_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumStreamIdMap_Clone(This,ppIEnumStreamIdMap)	\
    ( (This)->lpVtbl -> Clone(This,ppIEnumStreamIdMap) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumStreamIdMap_INTERFACE_DEFINED__ */


#ifndef __IMPEG2StreamIdMap_INTERFACE_DEFINED__
#define __IMPEG2StreamIdMap_INTERFACE_DEFINED__

/* interface IMPEG2StreamIdMap */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IMPEG2StreamIdMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D0E04C47-25B8-4369-925A-362A01D95444")
    IMPEG2StreamIdMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapStreamId( 
            /* [in] */ ULONG ulStreamId,
            /* [in] */ DWORD MediaSampleContent,
            /* [in] */ ULONG ulSubstreamFilterValue,
            /* [in] */ int iDataOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmapStreamId( 
            /* [in] */ ULONG culStreamId,
            /* [in] */ 
            __in_ecount(culStreamId)  ULONG *pulStreamId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumStreamIdMap( 
            /* [out] */ 
            __out  IEnumStreamIdMap **ppIEnumStreamIdMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMPEG2StreamIdMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMPEG2StreamIdMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMPEG2StreamIdMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMPEG2StreamIdMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *MapStreamId )( 
            IMPEG2StreamIdMap * This,
            /* [in] */ ULONG ulStreamId,
            /* [in] */ DWORD MediaSampleContent,
            /* [in] */ ULONG ulSubstreamFilterValue,
            /* [in] */ int iDataOffset);
        
        HRESULT ( STDMETHODCALLTYPE *UnmapStreamId )( 
            IMPEG2StreamIdMap * This,
            /* [in] */ ULONG culStreamId,
            /* [in] */ 
            __in_ecount(culStreamId)  ULONG *pulStreamId);
        
        HRESULT ( STDMETHODCALLTYPE *EnumStreamIdMap )( 
            IMPEG2StreamIdMap * This,
            /* [out] */ 
            __out  IEnumStreamIdMap **ppIEnumStreamIdMap);
        
        END_INTERFACE
    } IMPEG2StreamIdMapVtbl;

    interface IMPEG2StreamIdMap
    {
        CONST_VTBL struct IMPEG2StreamIdMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMPEG2StreamIdMap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMPEG2StreamIdMap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMPEG2StreamIdMap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMPEG2StreamIdMap_MapStreamId(This,ulStreamId,MediaSampleContent,ulSubstreamFilterValue,iDataOffset)	\
    ( (This)->lpVtbl -> MapStreamId(This,ulStreamId,MediaSampleContent,ulSubstreamFilterValue,iDataOffset) ) 

#define IMPEG2StreamIdMap_UnmapStreamId(This,culStreamId,pulStreamId)	\
    ( (This)->lpVtbl -> UnmapStreamId(This,culStreamId,pulStreamId) ) 

#define IMPEG2StreamIdMap_EnumStreamIdMap(This,ppIEnumStreamIdMap)	\
    ( (This)->lpVtbl -> EnumStreamIdMap(This,ppIEnumStreamIdMap) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMPEG2StreamIdMap_INTERFACE_DEFINED__ */


#ifndef __IRegisterServiceProvider_INTERFACE_DEFINED__
#define __IRegisterServiceProvider_INTERFACE_DEFINED__

/* interface IRegisterServiceProvider */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IRegisterServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7B3A2F01-0751-48DD-B556-004785171C54")
    IRegisterServiceProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown *pUnkObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegisterServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegisterServiceProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegisterServiceProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegisterServiceProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterService )( 
            IRegisterServiceProvider * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown *pUnkObject);
        
        END_INTERFACE
    } IRegisterServiceProviderVtbl;

    interface IRegisterServiceProvider
    {
        CONST_VTBL struct IRegisterServiceProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegisterServiceProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRegisterServiceProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRegisterServiceProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRegisterServiceProvider_RegisterService(This,guidService,pUnkObject)	\
    ( (This)->lpVtbl -> RegisterService(This,guidService,pUnkObject) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRegisterServiceProvider_INTERFACE_DEFINED__ */


#ifndef __IAMClockSlave_INTERFACE_DEFINED__
#define __IAMClockSlave_INTERFACE_DEFINED__

/* interface IAMClockSlave */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAMClockSlave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FD52741-176D-4b36-8F51-CA8F933223BE")
    IAMClockSlave : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetErrorTolerance( 
            /* [in] */ DWORD dwTolerance) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorTolerance( 
            /* [out] */ 
            __out  DWORD *pdwTolerance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMClockSlaveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMClockSlave * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMClockSlave * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMClockSlave * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetErrorTolerance )( 
            IAMClockSlave * This,
            /* [in] */ DWORD dwTolerance);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorTolerance )( 
            IAMClockSlave * This,
            /* [out] */ 
            __out  DWORD *pdwTolerance);
        
        END_INTERFACE
    } IAMClockSlaveVtbl;

    interface IAMClockSlave
    {
        CONST_VTBL struct IAMClockSlaveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMClockSlave_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMClockSlave_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMClockSlave_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMClockSlave_SetErrorTolerance(This,dwTolerance)	\
    ( (This)->lpVtbl -> SetErrorTolerance(This,dwTolerance) ) 

#define IAMClockSlave_GetErrorTolerance(This,pdwTolerance)	\
    ( (This)->lpVtbl -> GetErrorTolerance(This,pdwTolerance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMClockSlave_INTERFACE_DEFINED__ */


#ifndef __IAMGraphBuilderCallback_INTERFACE_DEFINED__
#define __IAMGraphBuilderCallback_INTERFACE_DEFINED__

/* interface IAMGraphBuilderCallback */
/* [unique][local][uuid][object] */ 


EXTERN_C const IID IID_IAMGraphBuilderCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4995f511-9ddb-4f12-bd3b-f04611807b79")
    IAMGraphBuilderCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SelectedFilter( 
            /* [in] */ IMoniker *pMon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreatedFilter( 
            /* [in] */ IBaseFilter *pFil) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMGraphBuilderCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMGraphBuilderCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMGraphBuilderCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMGraphBuilderCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectedFilter )( 
            IAMGraphBuilderCallback * This,
            /* [in] */ IMoniker *pMon);
        
        HRESULT ( STDMETHODCALLTYPE *CreatedFilter )( 
            IAMGraphBuilderCallback * This,
            /* [in] */ IBaseFilter *pFil);
        
        END_INTERFACE
    } IAMGraphBuilderCallbackVtbl;

    interface IAMGraphBuilderCallback
    {
        CONST_VTBL struct IAMGraphBuilderCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMGraphBuilderCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMGraphBuilderCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMGraphBuilderCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMGraphBuilderCallback_SelectedFilter(This,pMon)	\
    ( (This)->lpVtbl -> SelectedFilter(This,pMon) ) 

#define IAMGraphBuilderCallback_CreatedFilter(This,pFil)	\
    ( (This)->lpVtbl -> CreatedFilter(This,pFil) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMGraphBuilderCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0103 */
/* [local] */ 

#ifdef __cplusplus
#ifndef _IAMFilterGraphCallback_
#define _IAMFilterGraphCallback_
// Note: Because this interface was not defined as a proper interface it is
//       supported under C++ only. Methods aren't stdcall.
EXTERN_GUID(IID_IAMFilterGraphCallback,0x56a868fd,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);
interface IAMFilterGraphCallback : public IUnknown
{
    // S_OK means rendering complete, S_FALSE means retry now.
    virtual HRESULT UnableToRender(IPin *pPin) = 0;
 
};
#endif // _IAMFilterGraphCallback_
#endif
struct CodecAPIEventData
    {
    GUID guid;
    DWORD dataLength;
    DWORD reserved[ 3 ];
    } ;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0103_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0103_v0_0_s_ifspec;

#ifndef __ICodecAPI_INTERFACE_DEFINED__
#define __ICodecAPI_INTERFACE_DEFINED__

/* interface ICodecAPI */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ICodecAPI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("901db4c7-31ce-41a2-85dc-8fa0bf41b8da")
    ICodecAPI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSupported( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsModifiable( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterRange( 
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *ValueMin,
            /* [out] */ 
            __out  VARIANT *ValueMax,
            /* [out] */ 
            __out  VARIANT *SteppingDelta) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterValues( 
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ 
            __deref_out_ecount(*ValuesCount)  VARIANT **Values,
            /* [out] */ 
            __out  ULONG *ValuesCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultValue( 
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ const GUID *Api,
            /* [in] */ 
            __in  VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterForEvent( 
            /* [in] */ const GUID *Api,
            /* [in] */ LONG_PTR userData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterForEvent( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllDefaults( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueWithNotify( 
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value,
            /* [size_is][size_is][out] */ 
            __deref_out_ecount(*ChangedParamCount)  GUID **ChangedParam,
            /* [out] */ 
            __out  ULONG *ChangedParamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllDefaultsWithNotify( 
            /* [size_is][size_is][out] */ 
            __deref_out_ecount(*ChangedParamCount)  GUID **ChangedParam,
            /* [out] */ 
            __out  ULONG *ChangedParamCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllSettings( 
            /* [in] */ IStream *__MIDL__ICodecAPI0000) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllSettings( 
            /* [in] */ IStream *__MIDL__ICodecAPI0001) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllSettingsWithNotify( 
            IStream *__MIDL__ICodecAPI0002,
            /* [size_is][size_is][out] */ 
            __deref_out_ecount(*ChangedParamCount)  GUID **ChangedParam,
            /* [out] */ 
            __out  ULONG *ChangedParamCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICodecAPIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICodecAPI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICodecAPI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICodecAPI * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSupported )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *IsModifiable )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterRange )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *ValueMin,
            /* [out] */ 
            __out  VARIANT *ValueMax,
            /* [out] */ 
            __out  VARIANT *SteppingDelta);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterValues )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ 
            __deref_out_ecount(*ValuesCount)  VARIANT **Values,
            /* [out] */ 
            __out  ULONG *ValuesCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultValue )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [in] */ 
            __in  VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterForEvent )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [in] */ LONG_PTR userData);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterForEvent )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllDefaults )( 
            ICodecAPI * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueWithNotify )( 
            ICodecAPI * This,
            /* [in] */ const GUID *Api,
            /* [in] */ VARIANT *Value,
            /* [size_is][size_is][out] */ 
            __deref_out_ecount(*ChangedParamCount)  GUID **ChangedParam,
            /* [out] */ 
            __out  ULONG *ChangedParamCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllDefaultsWithNotify )( 
            ICodecAPI * This,
            /* [size_is][size_is][out] */ 
            __deref_out_ecount(*ChangedParamCount)  GUID **ChangedParam,
            /* [out] */ 
            __out  ULONG *ChangedParamCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllSettings )( 
            ICodecAPI * This,
            /* [in] */ IStream *__MIDL__ICodecAPI0000);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllSettings )( 
            ICodecAPI * This,
            /* [in] */ IStream *__MIDL__ICodecAPI0001);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllSettingsWithNotify )( 
            ICodecAPI * This,
            IStream *__MIDL__ICodecAPI0002,
            /* [size_is][size_is][out] */ 
            __deref_out_ecount(*ChangedParamCount)  GUID **ChangedParam,
            /* [out] */ 
            __out  ULONG *ChangedParamCount);
        
        END_INTERFACE
    } ICodecAPIVtbl;

    interface ICodecAPI
    {
        CONST_VTBL struct ICodecAPIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICodecAPI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICodecAPI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICodecAPI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICodecAPI_IsSupported(This,Api)	\
    ( (This)->lpVtbl -> IsSupported(This,Api) ) 

#define ICodecAPI_IsModifiable(This,Api)	\
    ( (This)->lpVtbl -> IsModifiable(This,Api) ) 

#define ICodecAPI_GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)	\
    ( (This)->lpVtbl -> GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta) ) 

#define ICodecAPI_GetParameterValues(This,Api,Values,ValuesCount)	\
    ( (This)->lpVtbl -> GetParameterValues(This,Api,Values,ValuesCount) ) 

#define ICodecAPI_GetDefaultValue(This,Api,Value)	\
    ( (This)->lpVtbl -> GetDefaultValue(This,Api,Value) ) 

#define ICodecAPI_GetValue(This,Api,Value)	\
    ( (This)->lpVtbl -> GetValue(This,Api,Value) ) 

#define ICodecAPI_SetValue(This,Api,Value)	\
    ( (This)->lpVtbl -> SetValue(This,Api,Value) ) 

#define ICodecAPI_RegisterForEvent(This,Api,userData)	\
    ( (This)->lpVtbl -> RegisterForEvent(This,Api,userData) ) 

#define ICodecAPI_UnregisterForEvent(This,Api)	\
    ( (This)->lpVtbl -> UnregisterForEvent(This,Api) ) 

#define ICodecAPI_SetAllDefaults(This)	\
    ( (This)->lpVtbl -> SetAllDefaults(This) ) 

#define ICodecAPI_SetValueWithNotify(This,Api,Value,ChangedParam,ChangedParamCount)	\
    ( (This)->lpVtbl -> SetValueWithNotify(This,Api,Value,ChangedParam,ChangedParamCount) ) 

#define ICodecAPI_SetAllDefaultsWithNotify(This,ChangedParam,ChangedParamCount)	\
    ( (This)->lpVtbl -> SetAllDefaultsWithNotify(This,ChangedParam,ChangedParamCount) ) 

#define ICodecAPI_GetAllSettings(This,__MIDL__ICodecAPI0000)	\
    ( (This)->lpVtbl -> GetAllSettings(This,__MIDL__ICodecAPI0000) ) 

#define ICodecAPI_SetAllSettings(This,__MIDL__ICodecAPI0001)	\
    ( (This)->lpVtbl -> SetAllSettings(This,__MIDL__ICodecAPI0001) ) 

#define ICodecAPI_SetAllSettingsWithNotify(This,__MIDL__ICodecAPI0002,ChangedParam,ChangedParamCount)	\
    ( (This)->lpVtbl -> SetAllSettingsWithNotify(This,__MIDL__ICodecAPI0002,ChangedParam,ChangedParamCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICodecAPI_INTERFACE_DEFINED__ */


#ifndef __IGetCapabilitiesKey_INTERFACE_DEFINED__
#define __IGetCapabilitiesKey_INTERFACE_DEFINED__

/* interface IGetCapabilitiesKey */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IGetCapabilitiesKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a8809222-07bb-48ea-951c-33158100625b")
    IGetCapabilitiesKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCapabilitiesKey( 
            /* [out] */ 
            __out  HKEY *pHKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetCapabilitiesKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGetCapabilitiesKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGetCapabilitiesKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGetCapabilitiesKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilitiesKey )( 
            IGetCapabilitiesKey * This,
            /* [out] */ 
            __out  HKEY *pHKey);
        
        END_INTERFACE
    } IGetCapabilitiesKeyVtbl;

    interface IGetCapabilitiesKey
    {
        CONST_VTBL struct IGetCapabilitiesKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetCapabilitiesKey_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGetCapabilitiesKey_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGetCapabilitiesKey_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGetCapabilitiesKey_GetCapabilitiesKey(This,pHKey)	\
    ( (This)->lpVtbl -> GetCapabilitiesKey(This,pHKey) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGetCapabilitiesKey_INTERFACE_DEFINED__ */


#ifndef __IEncoderAPI_INTERFACE_DEFINED__
#define __IEncoderAPI_INTERFACE_DEFINED__

/* interface IEncoderAPI */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEncoderAPI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70423839-6ACC-4b23-B079-21DBF08156A5")
    IEncoderAPI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSupported( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAvailable( 
            /* [in] */ const GUID *Api) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterRange( 
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *ValueMin,
            /* [out] */ 
            __out  VARIANT *ValueMax,
            /* [out] */ 
            __out  VARIANT *SteppingDelta) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameterValues( 
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ 
            __out_ecount(*ValuesCount)  VARIANT **Values,
            /* [out] */ 
            __out  ULONG *ValuesCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultValue( 
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ const GUID *Api,
            /* [in] */ 
            __in  VARIANT *Value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEncoderAPIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEncoderAPI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEncoderAPI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEncoderAPI * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSupported )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *IsAvailable )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterRange )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *ValueMin,
            /* [out] */ 
            __out  VARIANT *ValueMax,
            /* [out] */ 
            __out  VARIANT *SteppingDelta);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterValues )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ 
            __out_ecount(*ValuesCount)  VARIANT **Values,
            /* [out] */ 
            __out  ULONG *ValuesCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultValue )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IEncoderAPI * This,
            /* [in] */ const GUID *Api,
            /* [in] */ 
            __in  VARIANT *Value);
        
        END_INTERFACE
    } IEncoderAPIVtbl;

    interface IEncoderAPI
    {
        CONST_VTBL struct IEncoderAPIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEncoderAPI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEncoderAPI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEncoderAPI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEncoderAPI_IsSupported(This,Api)	\
    ( (This)->lpVtbl -> IsSupported(This,Api) ) 

#define IEncoderAPI_IsAvailable(This,Api)	\
    ( (This)->lpVtbl -> IsAvailable(This,Api) ) 

#define IEncoderAPI_GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)	\
    ( (This)->lpVtbl -> GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta) ) 

#define IEncoderAPI_GetParameterValues(This,Api,Values,ValuesCount)	\
    ( (This)->lpVtbl -> GetParameterValues(This,Api,Values,ValuesCount) ) 

#define IEncoderAPI_GetDefaultValue(This,Api,Value)	\
    ( (This)->lpVtbl -> GetDefaultValue(This,Api,Value) ) 

#define IEncoderAPI_GetValue(This,Api,Value)	\
    ( (This)->lpVtbl -> GetValue(This,Api,Value) ) 

#define IEncoderAPI_SetValue(This,Api,Value)	\
    ( (This)->lpVtbl -> SetValue(This,Api,Value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEncoderAPI_INTERFACE_DEFINED__ */


#ifndef __IVideoEncoder_INTERFACE_DEFINED__
#define __IVideoEncoder_INTERFACE_DEFINED__

/* interface IVideoEncoder */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IVideoEncoder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02997C3B-8E1B-460e-9270-545E0DE9563E")
    IVideoEncoder : public IEncoderAPI
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IVideoEncoderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoEncoder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoEncoder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoEncoder * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSupported )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *IsAvailable )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterRange )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *ValueMin,
            /* [out] */ 
            __out  VARIANT *ValueMax,
            /* [out] */ 
            __out  VARIANT *SteppingDelta);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterValues )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [size_is][size_is][out] */ 
            __out_ecount(*ValuesCount)  VARIANT **Values,
            /* [out] */ 
            __out  ULONG *ValuesCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultValue )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [out] */ 
            __out  VARIANT *Value);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IVideoEncoder * This,
            /* [in] */ const GUID *Api,
            /* [in] */ 
            __in  VARIANT *Value);
        
        END_INTERFACE
    } IVideoEncoderVtbl;

    interface IVideoEncoder
    {
        CONST_VTBL struct IVideoEncoderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoEncoder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVideoEncoder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVideoEncoder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVideoEncoder_IsSupported(This,Api)	\
    ( (This)->lpVtbl -> IsSupported(This,Api) ) 

#define IVideoEncoder_IsAvailable(This,Api)	\
    ( (This)->lpVtbl -> IsAvailable(This,Api) ) 

#define IVideoEncoder_GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta)	\
    ( (This)->lpVtbl -> GetParameterRange(This,Api,ValueMin,ValueMax,SteppingDelta) ) 

#define IVideoEncoder_GetParameterValues(This,Api,Values,ValuesCount)	\
    ( (This)->lpVtbl -> GetParameterValues(This,Api,Values,ValuesCount) ) 

#define IVideoEncoder_GetDefaultValue(This,Api,Value)	\
    ( (This)->lpVtbl -> GetDefaultValue(This,Api,Value) ) 

#define IVideoEncoder_GetValue(This,Api,Value)	\
    ( (This)->lpVtbl -> GetValue(This,Api,Value) ) 

#define IVideoEncoder_SetValue(This,Api,Value)	\
    ( (This)->lpVtbl -> SetValue(This,Api,Value) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVideoEncoder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0107 */
/* [local] */ 

#ifndef __ENCODER_API_DEFINES__
#define __ENCODER_API_DEFINES__
typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0107_0001
    {	ConstantBitRate	= 0,
	VariableBitRateAverage	= ( ConstantBitRate + 1 ) ,
	VariableBitRatePeak	= ( VariableBitRateAverage + 1 ) 
    } 	VIDEOENCODER_BITRATE_MODE;

#endif // __ENCODER_API_DEFINES__
#define AM_GETDECODERCAP_QUERY_VMR_SUPPORT   0x00000001
#define      VMR_NOTSUPPORTED                0x00000000
#define      VMR_SUPPORTED                   0x00000001
#define AM_QUERY_DECODER_VMR_SUPPORT         0x00000001
#define AM_QUERY_DECODER_DXVA_1_SUPPORT      0x00000002
#define AM_QUERY_DECODER_DVD_SUPPORT         0x00000003
#define AM_QUERY_DECODER_ATSC_SD_SUPPORT     0x00000004
#define AM_QUERY_DECODER_ATSC_HD_SUPPORT     0x00000005
#define AM_GETDECODERCAP_QUERY_VMR9_SUPPORT  0x00000006
#define AM_GETDECODERCAP_QUERY_EVR_SUPPORT   0x00000007
#define      DECODER_CAP_NOTSUPPORTED        0x00000000
#define      DECODER_CAP_SUPPORTED           0x00000001


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0107_v0_0_s_ifspec;

#ifndef __IAMDecoderCaps_INTERFACE_DEFINED__
#define __IAMDecoderCaps_INTERFACE_DEFINED__

/* interface IAMDecoderCaps */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMDecoderCaps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c0dff467-d499-4986-972b-e1d9090fa941")
    IAMDecoderCaps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDecoderCaps( 
            /* [in] */ DWORD dwCapIndex,
            /* [out] */ 
            __out  DWORD *lpdwCap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMDecoderCapsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMDecoderCaps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMDecoderCaps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMDecoderCaps * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderCaps )( 
            IAMDecoderCaps * This,
            /* [in] */ DWORD dwCapIndex,
            /* [out] */ 
            __out  DWORD *lpdwCap);
        
        END_INTERFACE
    } IAMDecoderCapsVtbl;

    interface IAMDecoderCaps
    {
        CONST_VTBL struct IAMDecoderCapsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMDecoderCaps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMDecoderCaps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMDecoderCaps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMDecoderCaps_GetDecoderCaps(This,dwCapIndex,lpdwCap)	\
    ( (This)->lpVtbl -> GetDecoderCaps(This,dwCapIndex,lpdwCap) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMDecoderCaps_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0108 */
/* [local] */ 

typedef struct _AMCOPPSignature
    {
    BYTE Signature[ 256 ];
    } 	AMCOPPSignature;

typedef struct _AMCOPPCommand
    {
    GUID macKDI;
    GUID guidCommandID;
    DWORD dwSequence;
    DWORD cbSizeData;
    BYTE CommandData[ 4056 ];
    } 	AMCOPPCommand;

typedef struct _AMCOPPCommand *LPAMCOPPCommand;

typedef struct _AMCOPPStatusInput
    {
    GUID rApp;
    GUID guidStatusRequestID;
    DWORD dwSequence;
    DWORD cbSizeData;
    BYTE StatusData[ 4056 ];
    } 	AMCOPPStatusInput;

typedef struct _AMCOPPStatusInput *LPAMCOPPStatusInput;

typedef struct _AMCOPPStatusOutput
    {
    GUID macKDI;
    DWORD cbSizeData;
    BYTE COPPStatus[ 4076 ];
    } 	AMCOPPStatusOutput;

typedef struct _AMCOPPStatusOutput *LPAMCOPPStatusOutput;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0108_v0_0_s_ifspec;

#ifndef __IAMCertifiedOutputProtection_INTERFACE_DEFINED__
#define __IAMCertifiedOutputProtection_INTERFACE_DEFINED__

/* interface IAMCertifiedOutputProtection */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IAMCertifiedOutputProtection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6feded3e-0ff1-4901-a2f1-43f7012c8515")
    IAMCertifiedOutputProtection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE KeyExchange( 
            /* [out] */ 
            __out  GUID *pRandom,
            /* [out] */ 
            __deref_out_bcount(*pdwLengthCertGH)  BYTE **VarLenCertGH,
            /* [out] */ 
            __out  DWORD *pdwLengthCertGH) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SessionSequenceStart( 
            /* [in] */ AMCOPPSignature *pSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProtectionCommand( 
            /* [in] */ const AMCOPPCommand *cmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProtectionStatus( 
            /* [in] */ const AMCOPPStatusInput *pStatusInput,
            /* [out] */ 
            __out  AMCOPPStatusOutput *pStatusOutput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMCertifiedOutputProtectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAMCertifiedOutputProtection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAMCertifiedOutputProtection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAMCertifiedOutputProtection * This);
        
        HRESULT ( STDMETHODCALLTYPE *KeyExchange )( 
            IAMCertifiedOutputProtection * This,
            /* [out] */ 
            __out  GUID *pRandom,
            /* [out] */ 
            __deref_out_bcount(*pdwLengthCertGH)  BYTE **VarLenCertGH,
            /* [out] */ 
            __out  DWORD *pdwLengthCertGH);
        
        HRESULT ( STDMETHODCALLTYPE *SessionSequenceStart )( 
            IAMCertifiedOutputProtection * This,
            /* [in] */ AMCOPPSignature *pSig);
        
        HRESULT ( STDMETHODCALLTYPE *ProtectionCommand )( 
            IAMCertifiedOutputProtection * This,
            /* [in] */ const AMCOPPCommand *cmd);
        
        HRESULT ( STDMETHODCALLTYPE *ProtectionStatus )( 
            IAMCertifiedOutputProtection * This,
            /* [in] */ const AMCOPPStatusInput *pStatusInput,
            /* [out] */ 
            __out  AMCOPPStatusOutput *pStatusOutput);
        
        END_INTERFACE
    } IAMCertifiedOutputProtectionVtbl;

    interface IAMCertifiedOutputProtection
    {
        CONST_VTBL struct IAMCertifiedOutputProtectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMCertifiedOutputProtection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAMCertifiedOutputProtection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAMCertifiedOutputProtection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAMCertifiedOutputProtection_KeyExchange(This,pRandom,VarLenCertGH,pdwLengthCertGH)	\
    ( (This)->lpVtbl -> KeyExchange(This,pRandom,VarLenCertGH,pdwLengthCertGH) ) 

#define IAMCertifiedOutputProtection_SessionSequenceStart(This,pSig)	\
    ( (This)->lpVtbl -> SessionSequenceStart(This,pSig) ) 

#define IAMCertifiedOutputProtection_ProtectionCommand(This,cmd)	\
    ( (This)->lpVtbl -> ProtectionCommand(This,cmd) ) 

#define IAMCertifiedOutputProtection_ProtectionStatus(This,pStatusInput,pStatusOutput)	\
    ( (This)->lpVtbl -> ProtectionStatus(This,pStatusInput,pStatusOutput) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAMCertifiedOutputProtection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0109 */
/* [local] */ 

#include <ddraw.h>









typedef 
enum tagDVD_DOMAIN
    {	DVD_DOMAIN_FirstPlay	= 1,
	DVD_DOMAIN_VideoManagerMenu	= ( DVD_DOMAIN_FirstPlay + 1 ) ,
	DVD_DOMAIN_VideoTitleSetMenu	= ( DVD_DOMAIN_VideoManagerMenu + 1 ) ,
	DVD_DOMAIN_Title	= ( DVD_DOMAIN_VideoTitleSetMenu + 1 ) ,
	DVD_DOMAIN_Stop	= ( DVD_DOMAIN_Title + 1 ) 
    } 	DVD_DOMAIN;

typedef 
enum tagDVD_MENU_ID
    {	DVD_MENU_Title	= 2,
	DVD_MENU_Root	= 3,
	DVD_MENU_Subpicture	= 4,
	DVD_MENU_Audio	= 5,
	DVD_MENU_Angle	= 6,
	DVD_MENU_Chapter	= 7
    } 	DVD_MENU_ID;

typedef 
enum tagDVD_DISC_SIDE
    {	DVD_SIDE_A	= 1,
	DVD_SIDE_B	= 2
    } 	DVD_DISC_SIDE;

typedef 
enum tagDVD_PREFERRED_DISPLAY_MODE
    {	DISPLAY_CONTENT_DEFAULT	= 0,
	DISPLAY_16x9	= 1,
	DISPLAY_4x3_PANSCAN_PREFERRED	= 2,
	DISPLAY_4x3_LETTERBOX_PREFERRED	= 3
    } 	DVD_PREFERRED_DISPLAY_MODE;

typedef WORD DVD_REGISTER;

typedef DVD_REGISTER GPRMARRAY[ 16 ];

typedef DVD_REGISTER SPRMARRAY[ 24 ];

typedef struct tagDVD_ATR
    {
    ULONG ulCAT;
    BYTE pbATRI[ 768 ];
    } 	DVD_ATR;

typedef BYTE DVD_VideoATR[ 2 ];

typedef BYTE DVD_AudioATR[ 8 ];

typedef BYTE DVD_SubpictureATR[ 6 ];

typedef 
enum tagDVD_FRAMERATE
    {	DVD_FPS_25	= 1,
	DVD_FPS_30NonDrop	= 3
    } 	DVD_FRAMERATE;

typedef struct tagDVD_TIMECODE
{
   ULONG Hours1    :4; // Hours
   ULONG Hours10  :4; // Tens of Hours 

   ULONG Minutes1  :4; // Minutes 
   ULONG Minutes10:4; // Tens of Minutes 

   ULONG Seconds1  :4; // Seconds 
   ULONG Seconds10:4; // Tens of Seconds 

   ULONG Frames1   :4; // Frames 
   ULONG Frames10 :2; // Tens of Frames 

   ULONG FrameRateCode: 2; // use DVD_FRAMERATE to indicate frames/sec and drop/non-drop
} DVD_TIMECODE;
typedef 
enum tagDVD_TIMECODE_FLAGS
    {	DVD_TC_FLAG_25fps	= 0x1,
	DVD_TC_FLAG_30fps	= 0x2,
	DVD_TC_FLAG_DropFrame	= 0x4,
	DVD_TC_FLAG_Interpolated	= 0x8
    } 	DVD_TIMECODE_FLAGS;

typedef struct tagDVD_HMSF_TIMECODE
    {
    BYTE bHours;
    BYTE bMinutes;
    BYTE bSeconds;
    BYTE bFrames;
    } 	DVD_HMSF_TIMECODE;

typedef struct tagDVD_PLAYBACK_LOCATION2
    {
    ULONG TitleNum;
    ULONG ChapterNum;
    DVD_HMSF_TIMECODE TimeCode;
    ULONG TimeCodeFlags;
    } 	DVD_PLAYBACK_LOCATION2;

typedef struct tagDVD_PLAYBACK_LOCATION
    {
    ULONG TitleNum;
    ULONG ChapterNum;
    ULONG TimeCode;
    } 	DVD_PLAYBACK_LOCATION;

typedef DWORD VALID_UOP_SOMTHING_OR_OTHER;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0109_0001
    {	UOP_FLAG_Play_Title_Or_AtTime	= 0x1,
	UOP_FLAG_Play_Chapter	= 0x2,
	UOP_FLAG_Play_Title	= 0x4,
	UOP_FLAG_Stop	= 0x8,
	UOP_FLAG_ReturnFromSubMenu	= 0x10,
	UOP_FLAG_Play_Chapter_Or_AtTime	= 0x20,
	UOP_FLAG_PlayPrev_Or_Replay_Chapter	= 0x40,
	UOP_FLAG_PlayNext_Chapter	= 0x80,
	UOP_FLAG_Play_Forwards	= 0x100,
	UOP_FLAG_Play_Backwards	= 0x200,
	UOP_FLAG_ShowMenu_Title	= 0x400,
	UOP_FLAG_ShowMenu_Root	= 0x800,
	UOP_FLAG_ShowMenu_SubPic	= 0x1000,
	UOP_FLAG_ShowMenu_Audio	= 0x2000,
	UOP_FLAG_ShowMenu_Angle	= 0x4000,
	UOP_FLAG_ShowMenu_Chapter	= 0x8000,
	UOP_FLAG_Resume	= 0x10000,
	UOP_FLAG_Select_Or_Activate_Button	= 0x20000,
	UOP_FLAG_Still_Off	= 0x40000,
	UOP_FLAG_Pause_On	= 0x80000,
	UOP_FLAG_Select_Audio_Stream	= 0x100000,
	UOP_FLAG_Select_SubPic_Stream	= 0x200000,
	UOP_FLAG_Select_Angle	= 0x400000,
	UOP_FLAG_Select_Karaoke_Audio_Presentation_Mode	= 0x800000,
	UOP_FLAG_Select_Video_Mode_Preference	= 0x1000000
    } 	VALID_UOP_FLAG;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0109_0002
    {	DVD_CMD_FLAG_None	= 0,
	DVD_CMD_FLAG_Flush	= 0x1,
	DVD_CMD_FLAG_SendEvents	= 0x2,
	DVD_CMD_FLAG_Block	= 0x4,
	DVD_CMD_FLAG_StartWhenRendered	= 0x8,
	DVD_CMD_FLAG_EndAfterRendered	= 0x10
    } 	DVD_CMD_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0109_0003
    {	DVD_ResetOnStop	= 1,
	DVD_NotifyParentalLevelChange	= 2,
	DVD_HMSF_TimeCodeEvents	= 3,
	DVD_AudioDuringFFwdRew	= 4,
	DVD_EnableNonblockingAPIs	= 5,
	DVD_CacheSizeInMB	= 6,
	DVD_EnablePortableBookmarks	= 7,
	DVD_EnableExtendedCopyProtectErrors	= 8
    } 	DVD_OPTION_FLAG;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0109_0004
    {	DVD_Relative_Upper	= 1,
	DVD_Relative_Lower	= 2,
	DVD_Relative_Left	= 3,
	DVD_Relative_Right	= 4
    } 	DVD_RELATIVE_BUTTON;

typedef 
enum tagDVD_PARENTAL_LEVEL
    {	DVD_PARENTAL_LEVEL_8	= 0x8000,
	DVD_PARENTAL_LEVEL_7	= 0x4000,
	DVD_PARENTAL_LEVEL_6	= 0x2000,
	DVD_PARENTAL_LEVEL_5	= 0x1000,
	DVD_PARENTAL_LEVEL_4	= 0x800,
	DVD_PARENTAL_LEVEL_3	= 0x400,
	DVD_PARENTAL_LEVEL_2	= 0x200,
	DVD_PARENTAL_LEVEL_1	= 0x100
    } 	DVD_PARENTAL_LEVEL;

typedef 
enum tagDVD_AUDIO_LANG_EXT
    {	DVD_AUD_EXT_NotSpecified	= 0,
	DVD_AUD_EXT_Captions	= 1,
	DVD_AUD_EXT_VisuallyImpaired	= 2,
	DVD_AUD_EXT_DirectorComments1	= 3,
	DVD_AUD_EXT_DirectorComments2	= 4
    } 	DVD_AUDIO_LANG_EXT;

typedef 
enum tagDVD_SUBPICTURE_LANG_EXT
    {	DVD_SP_EXT_NotSpecified	= 0,
	DVD_SP_EXT_Caption_Normal	= 1,
	DVD_SP_EXT_Caption_Big	= 2,
	DVD_SP_EXT_Caption_Children	= 3,
	DVD_SP_EXT_CC_Normal	= 5,
	DVD_SP_EXT_CC_Big	= 6,
	DVD_SP_EXT_CC_Children	= 7,
	DVD_SP_EXT_Forced	= 9,
	DVD_SP_EXT_DirectorComments_Normal	= 13,
	DVD_SP_EXT_DirectorComments_Big	= 14,
	DVD_SP_EXT_DirectorComments_Children	= 15
    } 	DVD_SUBPICTURE_LANG_EXT;

typedef 
enum tagDVD_AUDIO_APPMODE
    {	DVD_AudioMode_None	= 0,
	DVD_AudioMode_Karaoke	= 1,
	DVD_AudioMode_Surround	= 2,
	DVD_AudioMode_Other	= 3
    } 	DVD_AUDIO_APPMODE;

typedef 
enum tagDVD_AUDIO_FORMAT
    {	DVD_AudioFormat_AC3	= 0,
	DVD_AudioFormat_MPEG1	= 1,
	DVD_AudioFormat_MPEG1_DRC	= 2,
	DVD_AudioFormat_MPEG2	= 3,
	DVD_AudioFormat_MPEG2_DRC	= 4,
	DVD_AudioFormat_LPCM	= 5,
	DVD_AudioFormat_DTS	= 6,
	DVD_AudioFormat_SDDS	= 7,
	DVD_AudioFormat_Other	= 8
    } 	DVD_AUDIO_FORMAT;

typedef 
enum tagDVD_KARAOKE_DOWNMIX
    {	DVD_Mix_0to0	= 0x1,
	DVD_Mix_1to0	= 0x2,
	DVD_Mix_2to0	= 0x4,
	DVD_Mix_3to0	= 0x8,
	DVD_Mix_4to0	= 0x10,
	DVD_Mix_Lto0	= 0x20,
	DVD_Mix_Rto0	= 0x40,
	DVD_Mix_0to1	= 0x100,
	DVD_Mix_1to1	= 0x200,
	DVD_Mix_2to1	= 0x400,
	DVD_Mix_3to1	= 0x800,
	DVD_Mix_4to1	= 0x1000,
	DVD_Mix_Lto1	= 0x2000,
	DVD_Mix_Rto1	= 0x4000
    } 	DVD_KARAOKE_DOWNMIX;

typedef struct tagDVD_AudioAttributes
    {
    DVD_AUDIO_APPMODE AppMode;
    BYTE AppModeData;
    DVD_AUDIO_FORMAT AudioFormat;
    LCID Language;
    DVD_AUDIO_LANG_EXT LanguageExtension;
    BOOL fHasMultichannelInfo;
    DWORD dwFrequency;
    BYTE bQuantization;
    BYTE bNumberOfChannels;
    DWORD dwReserved[ 2 ];
    } 	DVD_AudioAttributes;

typedef struct tagDVD_MUA_MixingInfo
    {
    BOOL fMixTo0;
    BOOL fMixTo1;
    BOOL fMix0InPhase;
    BOOL fMix1InPhase;
    DWORD dwSpeakerPosition;
    } 	DVD_MUA_MixingInfo;

typedef struct tagDVD_MUA_Coeff
    {
    double log2_alpha;
    double log2_beta;
    } 	DVD_MUA_Coeff;

typedef struct tagDVD_MultichannelAudioAttributes
    {
    DVD_MUA_MixingInfo Info[ 8 ];
    DVD_MUA_Coeff Coeff[ 8 ];
    } 	DVD_MultichannelAudioAttributes;

typedef 
enum tagDVD_KARAOKE_CONTENTS
    {	DVD_Karaoke_GuideVocal1	= 0x1,
	DVD_Karaoke_GuideVocal2	= 0x2,
	DVD_Karaoke_GuideMelody1	= 0x4,
	DVD_Karaoke_GuideMelody2	= 0x8,
	DVD_Karaoke_GuideMelodyA	= 0x10,
	DVD_Karaoke_GuideMelodyB	= 0x20,
	DVD_Karaoke_SoundEffectA	= 0x40,
	DVD_Karaoke_SoundEffectB	= 0x80
    } 	DVD_KARAOKE_CONTENTS;

typedef 
enum tagDVD_KARAOKE_ASSIGNMENT
    {	DVD_Assignment_reserved0	= 0,
	DVD_Assignment_reserved1	= 1,
	DVD_Assignment_LR	= 2,
	DVD_Assignment_LRM	= 3,
	DVD_Assignment_LR1	= 4,
	DVD_Assignment_LRM1	= 5,
	DVD_Assignment_LR12	= 6,
	DVD_Assignment_LRM12	= 7
    } 	DVD_KARAOKE_ASSIGNMENT;

typedef struct tagDVD_KaraokeAttributes
    {
    BYTE bVersion;
    BOOL fMasterOfCeremoniesInGuideVocal1;
    BOOL fDuet;
    DVD_KARAOKE_ASSIGNMENT ChannelAssignment;
    WORD wChannelContents[ 8 ];
    } 	DVD_KaraokeAttributes;

typedef 
enum tagDVD_VIDEO_COMPRESSION
    {	DVD_VideoCompression_Other	= 0,
	DVD_VideoCompression_MPEG1	= 1,
	DVD_VideoCompression_MPEG2	= 2
    } 	DVD_VIDEO_COMPRESSION;

typedef struct tagDVD_VideoAttributes
    {
    BOOL fPanscanPermitted;
    BOOL fLetterboxPermitted;
    ULONG ulAspectX;
    ULONG ulAspectY;
    ULONG ulFrameRate;
    ULONG ulFrameHeight;
    DVD_VIDEO_COMPRESSION Compression;
    BOOL fLine21Field1InGOP;
    BOOL fLine21Field2InGOP;
    ULONG ulSourceResolutionX;
    ULONG ulSourceResolutionY;
    BOOL fIsSourceLetterboxed;
    BOOL fIsFilmMode;
    } 	DVD_VideoAttributes;

typedef 
enum tagDVD_SUBPICTURE_TYPE
    {	DVD_SPType_NotSpecified	= 0,
	DVD_SPType_Language	= 1,
	DVD_SPType_Other	= 2
    } 	DVD_SUBPICTURE_TYPE;

typedef 
enum tagDVD_SUBPICTURE_CODING
    {	DVD_SPCoding_RunLength	= 0,
	DVD_SPCoding_Extended	= 1,
	DVD_SPCoding_Other	= 2
    } 	DVD_SUBPICTURE_CODING;

typedef struct tagDVD_SubpictureAttributes
    {
    DVD_SUBPICTURE_TYPE Type;
    DVD_SUBPICTURE_CODING CodingMode;
    LCID Language;
    DVD_SUBPICTURE_LANG_EXT LanguageExtension;
    } 	DVD_SubpictureAttributes;

typedef 
enum tagDVD_TITLE_APPMODE
    {	DVD_AppMode_Not_Specified	= 0,
	DVD_AppMode_Karaoke	= 1,
	DVD_AppMode_Other	= 3
    } 	DVD_TITLE_APPMODE;

typedef struct tagDVD_TitleMainAttributes
    {
    DVD_TITLE_APPMODE AppMode;
    DVD_VideoAttributes VideoAttributes;
    ULONG ulNumberOfAudioStreams;
    DVD_AudioAttributes AudioAttributes[ 8 ];
    DVD_MultichannelAudioAttributes MultichannelAudioAttributes[ 8 ];
    ULONG ulNumberOfSubpictureStreams;
    DVD_SubpictureAttributes SubpictureAttributes[ 32 ];
    } 	DVD_TitleAttributes;

typedef struct tagDVD_MenuAttributes
    {
    BOOL fCompatibleRegion[ 8 ];
    DVD_VideoAttributes VideoAttributes;
    BOOL fAudioPresent;
    DVD_AudioAttributes AudioAttributes;
    BOOL fSubpicturePresent;
    DVD_SubpictureAttributes SubpictureAttributes;
    } 	DVD_MenuAttributes;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0109_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0109_v0_0_s_ifspec;

#ifndef __IDvdControl_INTERFACE_DEFINED__
#define __IDvdControl_INTERFACE_DEFINED__

/* interface IDvdControl */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvdControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A70EFE61-E2A3-11d0-A9BE-00AA0061BE93")
    IDvdControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TitlePlay( 
            /* [in] */ ULONG ulTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterPlay( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimePlay( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG bcdTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopForResume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GoUp( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TimeSearch( 
            /* [in] */ ULONG bcdTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterSearch( 
            /* [in] */ ULONG ulChapter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrevPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TopPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextPGSearch( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForwardScan( 
            /* [in] */ double dwSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BackwardScan( 
            /* [in] */ double dwSpeed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MenuCall( 
            /* [in] */ DVD_MENU_ID MenuID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpperButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LowerButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeftButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RightButtonSelect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonActivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ButtonSelectAndActivate( 
            /* [in] */ ULONG ulButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StillOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseOn( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MenuLanguageSelect( 
            /* [in] */ LCID Language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AudioStreamChange( 
            /* [in] */ ULONG ulAudio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubpictureStreamChange( 
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ BOOL bDisplay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AngleChange( 
            /* [in] */ ULONG ulAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParentalLevelSelect( 
            /* [in] */ ULONG ulParentalLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParentalCountrySelect( 
            /* [in] */ WORD wCountry) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KaraokeAudioPresentationModeChange( 
            /* [in] */ ULONG ulMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VideoModePreferrence( 
            /* [in] */ ULONG ulPreferredDisplayMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ LPCWSTR pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseActivate( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MouseSelect( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChapterPlayAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TitlePlay )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterPlay )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter);
        
        HRESULT ( STDMETHODCALLTYPE *TimePlay )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG bcdTime);
        
        HRESULT ( STDMETHODCALLTYPE *StopForResume )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GoUp )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TimeSearch )( 
            IDvdControl * This,
            /* [in] */ ULONG bcdTime);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterSearch )( 
            IDvdControl * This,
            /* [in] */ ULONG ulChapter);
        
        HRESULT ( STDMETHODCALLTYPE *PrevPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *TopPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *NextPGSearch )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ForwardScan )( 
            IDvdControl * This,
            /* [in] */ double dwSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *BackwardScan )( 
            IDvdControl * This,
            /* [in] */ double dwSpeed);
        
        HRESULT ( STDMETHODCALLTYPE *MenuCall )( 
            IDvdControl * This,
            /* [in] */ DVD_MENU_ID MenuID);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpperButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *LowerButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *LeftButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *RightButtonSelect )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonActivate )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ButtonSelectAndActivate )( 
            IDvdControl * This,
            /* [in] */ ULONG ulButton);
        
        HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseOn )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *PauseOff )( 
            IDvdControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *MenuLanguageSelect )( 
            IDvdControl * This,
            /* [in] */ LCID Language);
        
        HRESULT ( STDMETHODCALLTYPE *AudioStreamChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulAudio);
        
        HRESULT ( STDMETHODCALLTYPE *SubpictureStreamChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ BOOL bDisplay);
        
        HRESULT ( STDMETHODCALLTYPE *AngleChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulAngle);
        
        HRESULT ( STDMETHODCALLTYPE *ParentalLevelSelect )( 
            IDvdControl * This,
            /* [in] */ ULONG ulParentalLevel);
        
        HRESULT ( STDMETHODCALLTYPE *ParentalCountrySelect )( 
            IDvdControl * This,
            /* [in] */ WORD wCountry);
        
        HRESULT ( STDMETHODCALLTYPE *KaraokeAudioPresentationModeChange )( 
            IDvdControl * This,
            /* [in] */ ULONG ulMode);
        
        HRESULT ( STDMETHODCALLTYPE *VideoModePreferrence )( 
            IDvdControl * This,
            /* [in] */ ULONG ulPreferredDisplayMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetRoot )( 
            IDvdControl * This,
            /* [in] */ LPCWSTR pszPath);
        
        HRESULT ( STDMETHODCALLTYPE *MouseActivate )( 
            IDvdControl * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *MouseSelect )( 
            IDvdControl * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *ChapterPlayAutoStop )( 
            IDvdControl * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay);
        
        END_INTERFACE
    } IDvdControlVtbl;

    interface IDvdControl
    {
        CONST_VTBL struct IDvdControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdControl_TitlePlay(This,ulTitle)	\
    ( (This)->lpVtbl -> TitlePlay(This,ulTitle) ) 

#define IDvdControl_ChapterPlay(This,ulTitle,ulChapter)	\
    ( (This)->lpVtbl -> ChapterPlay(This,ulTitle,ulChapter) ) 

#define IDvdControl_TimePlay(This,ulTitle,bcdTime)	\
    ( (This)->lpVtbl -> TimePlay(This,ulTitle,bcdTime) ) 

#define IDvdControl_StopForResume(This)	\
    ( (This)->lpVtbl -> StopForResume(This) ) 

#define IDvdControl_GoUp(This)	\
    ( (This)->lpVtbl -> GoUp(This) ) 

#define IDvdControl_TimeSearch(This,bcdTime)	\
    ( (This)->lpVtbl -> TimeSearch(This,bcdTime) ) 

#define IDvdControl_ChapterSearch(This,ulChapter)	\
    ( (This)->lpVtbl -> ChapterSearch(This,ulChapter) ) 

#define IDvdControl_PrevPGSearch(This)	\
    ( (This)->lpVtbl -> PrevPGSearch(This) ) 

#define IDvdControl_TopPGSearch(This)	\
    ( (This)->lpVtbl -> TopPGSearch(This) ) 

#define IDvdControl_NextPGSearch(This)	\
    ( (This)->lpVtbl -> NextPGSearch(This) ) 

#define IDvdControl_ForwardScan(This,dwSpeed)	\
    ( (This)->lpVtbl -> ForwardScan(This,dwSpeed) ) 

#define IDvdControl_BackwardScan(This,dwSpeed)	\
    ( (This)->lpVtbl -> BackwardScan(This,dwSpeed) ) 

#define IDvdControl_MenuCall(This,MenuID)	\
    ( (This)->lpVtbl -> MenuCall(This,MenuID) ) 

#define IDvdControl_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IDvdControl_UpperButtonSelect(This)	\
    ( (This)->lpVtbl -> UpperButtonSelect(This) ) 

#define IDvdControl_LowerButtonSelect(This)	\
    ( (This)->lpVtbl -> LowerButtonSelect(This) ) 

#define IDvdControl_LeftButtonSelect(This)	\
    ( (This)->lpVtbl -> LeftButtonSelect(This) ) 

#define IDvdControl_RightButtonSelect(This)	\
    ( (This)->lpVtbl -> RightButtonSelect(This) ) 

#define IDvdControl_ButtonActivate(This)	\
    ( (This)->lpVtbl -> ButtonActivate(This) ) 

#define IDvdControl_ButtonSelectAndActivate(This,ulButton)	\
    ( (This)->lpVtbl -> ButtonSelectAndActivate(This,ulButton) ) 

#define IDvdControl_StillOff(This)	\
    ( (This)->lpVtbl -> StillOff(This) ) 

#define IDvdControl_PauseOn(This)	\
    ( (This)->lpVtbl -> PauseOn(This) ) 

#define IDvdControl_PauseOff(This)	\
    ( (This)->lpVtbl -> PauseOff(This) ) 

#define IDvdControl_MenuLanguageSelect(This,Language)	\
    ( (This)->lpVtbl -> MenuLanguageSelect(This,Language) ) 

#define IDvdControl_AudioStreamChange(This,ulAudio)	\
    ( (This)->lpVtbl -> AudioStreamChange(This,ulAudio) ) 

#define IDvdControl_SubpictureStreamChange(This,ulSubPicture,bDisplay)	\
    ( (This)->lpVtbl -> SubpictureStreamChange(This,ulSubPicture,bDisplay) ) 

#define IDvdControl_AngleChange(This,ulAngle)	\
    ( (This)->lpVtbl -> AngleChange(This,ulAngle) ) 

#define IDvdControl_ParentalLevelSelect(This,ulParentalLevel)	\
    ( (This)->lpVtbl -> ParentalLevelSelect(This,ulParentalLevel) ) 

#define IDvdControl_ParentalCountrySelect(This,wCountry)	\
    ( (This)->lpVtbl -> ParentalCountrySelect(This,wCountry) ) 

#define IDvdControl_KaraokeAudioPresentationModeChange(This,ulMode)	\
    ( (This)->lpVtbl -> KaraokeAudioPresentationModeChange(This,ulMode) ) 

#define IDvdControl_VideoModePreferrence(This,ulPreferredDisplayMode)	\
    ( (This)->lpVtbl -> VideoModePreferrence(This,ulPreferredDisplayMode) ) 

#define IDvdControl_SetRoot(This,pszPath)	\
    ( (This)->lpVtbl -> SetRoot(This,pszPath) ) 

#define IDvdControl_MouseActivate(This,point)	\
    ( (This)->lpVtbl -> MouseActivate(This,point) ) 

#define IDvdControl_MouseSelect(This,point)	\
    ( (This)->lpVtbl -> MouseSelect(This,point) ) 

#define IDvdControl_ChapterPlayAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay)	\
    ( (This)->lpVtbl -> ChapterPlayAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdControl_INTERFACE_DEFINED__ */


#ifndef __IDvdInfo_INTERFACE_DEFINED__
#define __IDvdInfo_INTERFACE_DEFINED__

/* interface IDvdInfo */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvdInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A70EFE60-E2A3-11d0-A9BE-00AA0061BE93")
    IDvdInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentDomain( 
            /* [out] */ DVD_DOMAIN *pDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation( 
            /* [out] */ 
            __out  DVD_PLAYBACK_LOCATION *pLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalTitleTime( 
            /* [out] */ 
            __out  ULONG *pulTotalTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentButton( 
            /* [out] */ 
            __out  ULONG *pulButtonsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAngle( 
            /* [out] */ 
            __out  ULONG *pulAnglesAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudio( 
            /* [out] */ 
            __out  ULONG *pulStreamsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpicture( 
            /* [out] */ 
            __out  ULONG *pulStreamsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentStream,
            /* [out] */ 
            __out  BOOL *pIsDisabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentUOPS( 
            /* [out] */ 
            __out  VALID_UOP_SOMTHING_OR_OTHER *pUOP) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllSPRMs( 
            /* [out] */ 
            __out  SPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllGPRMs( 
            /* [out] */ 
            __out  GPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleAttributes( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  DVD_ATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVMGAttributes( 
            /* [out] */ 
            __out  DVD_ATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVideoAttributes( 
            /* [out] */ 
            __out  DVD_VideoATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudioAttributes( 
            /* [out] */ 
            __out  DVD_AudioATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpictureAttributes( 
            /* [out] */ 
            __out  DVD_SubpictureATR *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVolumeInfo( 
            /* [out] */ 
            __out  ULONG *pulNumOfVol,
            /* [out] */ 
            __out  ULONG *pulThisVolNum,
            /* [out] */ 
            __out  DVD_DISC_SIDE *pSide,
            /* [out] */ 
            __out  ULONG *pulNumOfTitles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextInfo( 
            /* [size_is][out] */ 
            __out_bcount_part(ulBufSize, *pulActualSize)  BYTE *pTextManager,
            /* [in] */ ULONG ulBufSize,
            /* [out] */ 
            __out  ULONG *pulActualSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayerParentalLevel( 
            /* [out] */ 
            __out  ULONG *pulParentalLevel,
            /* [out] */ 
            __out  ULONG *pulCountryCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfChapters( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  ULONG *pulNumberOfChapters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleParentalLevels( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  ULONG *pulParentalLevels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [size_is][out] */ 
            __out_ecount_part(ulBufSize, *pulActualSize)  LPSTR pRoot,
            /* [in] */ ULONG ulBufSize,
            /* [out] */ 
            __out  ULONG *pulActualSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentDomain )( 
            IDvdInfo * This,
            /* [out] */ DVD_DOMAIN *pDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLocation )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  DVD_PLAYBACK_LOCATION *pLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalTitleTime )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  ULONG *pulTotalTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentButton )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  ULONG *pulButtonsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentButton);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAngle )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  ULONG *pulAnglesAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentAngle);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudio )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  ULONG *pulStreamsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpicture )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  ULONG *pulStreamsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentStream,
            /* [out] */ 
            __out  BOOL *pIsDisabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentUOPS )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  VALID_UOP_SOMTHING_OR_OTHER *pUOP);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllSPRMs )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  SPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllGPRMs )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  GPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioLanguage )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureLanguage )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleAttributes )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  DVD_ATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetVMGAttributes )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  DVD_ATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVideoAttributes )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  DVD_VideoATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudioAttributes )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  DVD_AudioATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpictureAttributes )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  DVD_SubpictureATR *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVolumeInfo )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  ULONG *pulNumOfVol,
            /* [out] */ 
            __out  ULONG *pulThisVolNum,
            /* [out] */ 
            __out  DVD_DISC_SIDE *pSide,
            /* [out] */ 
            __out  ULONG *pulNumOfTitles);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextInfo )( 
            IDvdInfo * This,
            /* [size_is][out] */ 
            __out_bcount_part(ulBufSize, *pulActualSize)  BYTE *pTextManager,
            /* [in] */ ULONG ulBufSize,
            /* [out] */ 
            __out  ULONG *pulActualSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayerParentalLevel )( 
            IDvdInfo * This,
            /* [out] */ 
            __out  ULONG *pulParentalLevel,
            /* [out] */ 
            __out  ULONG *pulCountryCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfChapters )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  ULONG *pulNumberOfChapters);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleParentalLevels )( 
            IDvdInfo * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  ULONG *pulParentalLevels);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoot )( 
            IDvdInfo * This,
            /* [size_is][out] */ 
            __out_ecount_part(ulBufSize, *pulActualSize)  LPSTR pRoot,
            /* [in] */ ULONG ulBufSize,
            /* [out] */ 
            __out  ULONG *pulActualSize);
        
        END_INTERFACE
    } IDvdInfoVtbl;

    interface IDvdInfo
    {
        CONST_VTBL struct IDvdInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdInfo_GetCurrentDomain(This,pDomain)	\
    ( (This)->lpVtbl -> GetCurrentDomain(This,pDomain) ) 

#define IDvdInfo_GetCurrentLocation(This,pLocation)	\
    ( (This)->lpVtbl -> GetCurrentLocation(This,pLocation) ) 

#define IDvdInfo_GetTotalTitleTime(This,pulTotalTime)	\
    ( (This)->lpVtbl -> GetTotalTitleTime(This,pulTotalTime) ) 

#define IDvdInfo_GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton)	\
    ( (This)->lpVtbl -> GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton) ) 

#define IDvdInfo_GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle)	\
    ( (This)->lpVtbl -> GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle) ) 

#define IDvdInfo_GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream)	\
    ( (This)->lpVtbl -> GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream) ) 

#define IDvdInfo_GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pIsDisabled)	\
    ( (This)->lpVtbl -> GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pIsDisabled) ) 

#define IDvdInfo_GetCurrentUOPS(This,pUOP)	\
    ( (This)->lpVtbl -> GetCurrentUOPS(This,pUOP) ) 

#define IDvdInfo_GetAllSPRMs(This,pRegisterArray)	\
    ( (This)->lpVtbl -> GetAllSPRMs(This,pRegisterArray) ) 

#define IDvdInfo_GetAllGPRMs(This,pRegisterArray)	\
    ( (This)->lpVtbl -> GetAllGPRMs(This,pRegisterArray) ) 

#define IDvdInfo_GetAudioLanguage(This,ulStream,pLanguage)	\
    ( (This)->lpVtbl -> GetAudioLanguage(This,ulStream,pLanguage) ) 

#define IDvdInfo_GetSubpictureLanguage(This,ulStream,pLanguage)	\
    ( (This)->lpVtbl -> GetSubpictureLanguage(This,ulStream,pLanguage) ) 

#define IDvdInfo_GetTitleAttributes(This,ulTitle,pATR)	\
    ( (This)->lpVtbl -> GetTitleAttributes(This,ulTitle,pATR) ) 

#define IDvdInfo_GetVMGAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetVMGAttributes(This,pATR) ) 

#define IDvdInfo_GetCurrentVideoAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetCurrentVideoAttributes(This,pATR) ) 

#define IDvdInfo_GetCurrentAudioAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetCurrentAudioAttributes(This,pATR) ) 

#define IDvdInfo_GetCurrentSubpictureAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetCurrentSubpictureAttributes(This,pATR) ) 

#define IDvdInfo_GetCurrentVolumeInfo(This,pulNumOfVol,pulThisVolNum,pSide,pulNumOfTitles)	\
    ( (This)->lpVtbl -> GetCurrentVolumeInfo(This,pulNumOfVol,pulThisVolNum,pSide,pulNumOfTitles) ) 

#define IDvdInfo_GetDVDTextInfo(This,pTextManager,ulBufSize,pulActualSize)	\
    ( (This)->lpVtbl -> GetDVDTextInfo(This,pTextManager,ulBufSize,pulActualSize) ) 

#define IDvdInfo_GetPlayerParentalLevel(This,pulParentalLevel,pulCountryCode)	\
    ( (This)->lpVtbl -> GetPlayerParentalLevel(This,pulParentalLevel,pulCountryCode) ) 

#define IDvdInfo_GetNumberOfChapters(This,ulTitle,pulNumberOfChapters)	\
    ( (This)->lpVtbl -> GetNumberOfChapters(This,ulTitle,pulNumberOfChapters) ) 

#define IDvdInfo_GetTitleParentalLevels(This,ulTitle,pulParentalLevels)	\
    ( (This)->lpVtbl -> GetTitleParentalLevels(This,ulTitle,pulParentalLevels) ) 

#define IDvdInfo_GetRoot(This,pRoot,ulBufSize,pulActualSize)	\
    ( (This)->lpVtbl -> GetRoot(This,pRoot,ulBufSize,pulActualSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdInfo_INTERFACE_DEFINED__ */


#ifndef __IDvdCmd_INTERFACE_DEFINED__
#define __IDvdCmd_INTERFACE_DEFINED__

/* interface IDvdCmd */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvdCmd;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5a4a97e4-94ee-4a55-9751-74b5643aa27d")
    IDvdCmd : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WaitForStart( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WaitForEnd( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdCmdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdCmd * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdCmd * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdCmd * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForStart )( 
            IDvdCmd * This);
        
        HRESULT ( STDMETHODCALLTYPE *WaitForEnd )( 
            IDvdCmd * This);
        
        END_INTERFACE
    } IDvdCmdVtbl;

    interface IDvdCmd
    {
        CONST_VTBL struct IDvdCmdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdCmd_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdCmd_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdCmd_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdCmd_WaitForStart(This)	\
    ( (This)->lpVtbl -> WaitForStart(This) ) 

#define IDvdCmd_WaitForEnd(This)	\
    ( (This)->lpVtbl -> WaitForEnd(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdCmd_INTERFACE_DEFINED__ */


#ifndef __IDvdState_INTERFACE_DEFINED__
#define __IDvdState_INTERFACE_DEFINED__

/* interface IDvdState */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvdState;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86303d6d-1c4a-4087-ab42-f711167048ef")
    IDvdState : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDiscID( 
            /* [out] */ 
            __out  ULONGLONG *pullUniqueID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentalLevel( 
            /* [out] */ 
            __out  ULONG *pulParentalLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdStateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdState * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdState * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdState * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiscID )( 
            IDvdState * This,
            /* [out] */ 
            __out  ULONGLONG *pullUniqueID);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentalLevel )( 
            IDvdState * This,
            /* [out] */ 
            __out  ULONG *pulParentalLevel);
        
        END_INTERFACE
    } IDvdStateVtbl;

    interface IDvdState
    {
        CONST_VTBL struct IDvdStateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdState_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdState_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdState_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdState_GetDiscID(This,pullUniqueID)	\
    ( (This)->lpVtbl -> GetDiscID(This,pullUniqueID) ) 

#define IDvdState_GetParentalLevel(This,pulParentalLevel)	\
    ( (This)->lpVtbl -> GetParentalLevel(This,pulParentalLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdState_INTERFACE_DEFINED__ */


#ifndef __IDvdControl2_INTERFACE_DEFINED__
#define __IDvdControl2_INTERFACE_DEFINED__

/* interface IDvdControl2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvdControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("33BC7430-EEC0-11D2-8201-00A0C9D74842")
    IDvdControl2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PlayTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChapterInTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayAtTimeInTitle( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReturnFromSubmenu( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayAtTime( 
            /* [in] */ DVD_HMSF_TIMECODE *pTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChapter( 
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayPrevChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplayChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayNextChapter( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayForwards( 
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayBackwards( 
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowMenu( 
            /* [in] */ DVD_MENU_ID MenuID,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectRelativeButton( 
            DVD_RELATIVE_BUTTON buttonDir) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateButton( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectButton( 
            /* [in] */ ULONG ulButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAndActivateButton( 
            /* [in] */ ULONG ulButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StillOff( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [in] */ BOOL bState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAudioStream( 
            /* [in] */ ULONG ulAudio,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectSubpictureStream( 
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubpictureState( 
            /* [in] */ BOOL bState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAngle( 
            /* [in] */ ULONG ulAngle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectParentalLevel( 
            /* [in] */ ULONG ulParentalLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectParentalCountry( 
            /* [in] */ BYTE bCountry[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectKaraokeAudioPresentationMode( 
            /* [in] */ ULONG ulMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectVideoModePreference( 
            /* [in] */ ULONG ulPreferredDisplayMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDVDDirectory( 
            /* [in] */ LPCWSTR pszwPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateAtPosition( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectAtPosition( 
            /* [in] */ POINT point) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayChaptersAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AcceptParentalLevelChange( 
            /* [in] */ BOOL bAccept) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ DVD_OPTION_FLAG flag,
            /* [in] */ BOOL fState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ IDvdState *pState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlayPeriodInTitleAutoStop( 
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DVD_HMSF_TIMECODE *pEndTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGPRM( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ WORD wValue,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultMenuLanguage( 
            /* [in] */ LCID Language) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultAudioLanguage( 
            /* [in] */ LCID Language,
            /* [in] */ DVD_AUDIO_LANG_EXT audioExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectDefaultSubpictureLanguage( 
            /* [in] */ LCID Language,
            /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdControl2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdControl2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *PlayTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChapterInTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayAtTimeInTitle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReturnFromSubmenu )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayAtTime )( 
            IDvdControl2 * This,
            /* [in] */ DVD_HMSF_TIMECODE *pTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChapter )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulChapter,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayPrevChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *ReplayChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayNextChapter )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayForwards )( 
            IDvdControl2 * This,
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayBackwards )( 
            IDvdControl2 * This,
            /* [in] */ double dSpeed,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowMenu )( 
            IDvdControl2 * This,
            /* [in] */ DVD_MENU_ID MenuID,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDvdControl2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectRelativeButton )( 
            IDvdControl2 * This,
            DVD_RELATIVE_BUTTON buttonDir);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateButton )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectButton )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulButton);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndActivateButton )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulButton);
        
        HRESULT ( STDMETHODCALLTYPE *StillOff )( 
            IDvdControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bState);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAudioStream )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulAudio,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectSubpictureStream )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulSubPicture,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubpictureState )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAngle )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulAngle,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectParentalLevel )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulParentalLevel);
        
        HRESULT ( STDMETHODCALLTYPE *SelectParentalCountry )( 
            IDvdControl2 * This,
            /* [in] */ BYTE bCountry[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE *SelectKaraokeAudioPresentationMode )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulMode);
        
        HRESULT ( STDMETHODCALLTYPE *SelectVideoModePreference )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulPreferredDisplayMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetDVDDirectory )( 
            IDvdControl2 * This,
            /* [in] */ LPCWSTR pszwPath);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateAtPosition )( 
            IDvdControl2 * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAtPosition )( 
            IDvdControl2 * This,
            /* [in] */ POINT point);
        
        HRESULT ( STDMETHODCALLTYPE *PlayChaptersAutoStop )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ ULONG ulChapter,
            /* [in] */ ULONG ulChaptersToPlay,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *AcceptParentalLevelChange )( 
            IDvdControl2 * This,
            /* [in] */ BOOL bAccept);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IDvdControl2 * This,
            /* [in] */ DVD_OPTION_FLAG flag,
            /* [in] */ BOOL fState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IDvdControl2 * This,
            /* [in] */ IDvdState *pState,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *PlayPeriodInTitleAutoStop )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulTitle,
            /* [in] */ DVD_HMSF_TIMECODE *pStartTime,
            /* [in] */ DVD_HMSF_TIMECODE *pEndTime,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetGPRM )( 
            IDvdControl2 * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ WORD wValue,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  IDvdCmd **ppCmd);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultMenuLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultAudioLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language,
            /* [in] */ DVD_AUDIO_LANG_EXT audioExtension);
        
        HRESULT ( STDMETHODCALLTYPE *SelectDefaultSubpictureLanguage )( 
            IDvdControl2 * This,
            /* [in] */ LCID Language,
            /* [in] */ DVD_SUBPICTURE_LANG_EXT subpictureExtension);
        
        END_INTERFACE
    } IDvdControl2Vtbl;

    interface IDvdControl2
    {
        CONST_VTBL struct IDvdControl2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdControl2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdControl2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdControl2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdControl2_PlayTitle(This,ulTitle,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayTitle(This,ulTitle,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayChapterInTitle(This,ulTitle,ulChapter,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayChapterInTitle(This,ulTitle,ulChapter,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayAtTimeInTitle(This,ulTitle,pStartTime,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayAtTimeInTitle(This,ulTitle,pStartTime,dwFlags,ppCmd) ) 

#define IDvdControl2_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IDvdControl2_ReturnFromSubmenu(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> ReturnFromSubmenu(This,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayAtTime(This,pTime,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayAtTime(This,pTime,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayChapter(This,ulChapter,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayChapter(This,ulChapter,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayPrevChapter(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayPrevChapter(This,dwFlags,ppCmd) ) 

#define IDvdControl2_ReplayChapter(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> ReplayChapter(This,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayNextChapter(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayNextChapter(This,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayForwards(This,dSpeed,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayForwards(This,dSpeed,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayBackwards(This,dSpeed,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayBackwards(This,dSpeed,dwFlags,ppCmd) ) 

#define IDvdControl2_ShowMenu(This,MenuID,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> ShowMenu(This,MenuID,dwFlags,ppCmd) ) 

#define IDvdControl2_Resume(This,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> Resume(This,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectRelativeButton(This,buttonDir)	\
    ( (This)->lpVtbl -> SelectRelativeButton(This,buttonDir) ) 

#define IDvdControl2_ActivateButton(This)	\
    ( (This)->lpVtbl -> ActivateButton(This) ) 

#define IDvdControl2_SelectButton(This,ulButton)	\
    ( (This)->lpVtbl -> SelectButton(This,ulButton) ) 

#define IDvdControl2_SelectAndActivateButton(This,ulButton)	\
    ( (This)->lpVtbl -> SelectAndActivateButton(This,ulButton) ) 

#define IDvdControl2_StillOff(This)	\
    ( (This)->lpVtbl -> StillOff(This) ) 

#define IDvdControl2_Pause(This,bState)	\
    ( (This)->lpVtbl -> Pause(This,bState) ) 

#define IDvdControl2_SelectAudioStream(This,ulAudio,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SelectAudioStream(This,ulAudio,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectSubpictureStream(This,ulSubPicture,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SelectSubpictureStream(This,ulSubPicture,dwFlags,ppCmd) ) 

#define IDvdControl2_SetSubpictureState(This,bState,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SetSubpictureState(This,bState,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectAngle(This,ulAngle,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SelectAngle(This,ulAngle,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectParentalLevel(This,ulParentalLevel)	\
    ( (This)->lpVtbl -> SelectParentalLevel(This,ulParentalLevel) ) 

#define IDvdControl2_SelectParentalCountry(This,bCountry)	\
    ( (This)->lpVtbl -> SelectParentalCountry(This,bCountry) ) 

#define IDvdControl2_SelectKaraokeAudioPresentationMode(This,ulMode)	\
    ( (This)->lpVtbl -> SelectKaraokeAudioPresentationMode(This,ulMode) ) 

#define IDvdControl2_SelectVideoModePreference(This,ulPreferredDisplayMode)	\
    ( (This)->lpVtbl -> SelectVideoModePreference(This,ulPreferredDisplayMode) ) 

#define IDvdControl2_SetDVDDirectory(This,pszwPath)	\
    ( (This)->lpVtbl -> SetDVDDirectory(This,pszwPath) ) 

#define IDvdControl2_ActivateAtPosition(This,point)	\
    ( (This)->lpVtbl -> ActivateAtPosition(This,point) ) 

#define IDvdControl2_SelectAtPosition(This,point)	\
    ( (This)->lpVtbl -> SelectAtPosition(This,point) ) 

#define IDvdControl2_PlayChaptersAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayChaptersAutoStop(This,ulTitle,ulChapter,ulChaptersToPlay,dwFlags,ppCmd) ) 

#define IDvdControl2_AcceptParentalLevelChange(This,bAccept)	\
    ( (This)->lpVtbl -> AcceptParentalLevelChange(This,bAccept) ) 

#define IDvdControl2_SetOption(This,flag,fState)	\
    ( (This)->lpVtbl -> SetOption(This,flag,fState) ) 

#define IDvdControl2_SetState(This,pState,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SetState(This,pState,dwFlags,ppCmd) ) 

#define IDvdControl2_PlayPeriodInTitleAutoStop(This,ulTitle,pStartTime,pEndTime,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> PlayPeriodInTitleAutoStop(This,ulTitle,pStartTime,pEndTime,dwFlags,ppCmd) ) 

#define IDvdControl2_SetGPRM(This,ulIndex,wValue,dwFlags,ppCmd)	\
    ( (This)->lpVtbl -> SetGPRM(This,ulIndex,wValue,dwFlags,ppCmd) ) 

#define IDvdControl2_SelectDefaultMenuLanguage(This,Language)	\
    ( (This)->lpVtbl -> SelectDefaultMenuLanguage(This,Language) ) 

#define IDvdControl2_SelectDefaultAudioLanguage(This,Language,audioExtension)	\
    ( (This)->lpVtbl -> SelectDefaultAudioLanguage(This,Language,audioExtension) ) 

#define IDvdControl2_SelectDefaultSubpictureLanguage(This,Language,subpictureExtension)	\
    ( (This)->lpVtbl -> SelectDefaultSubpictureLanguage(This,Language,subpictureExtension) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdControl2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0114 */
/* [local] */ 


enum DVD_TextStringType
    {	DVD_Struct_Volume	= 0x1,
	DVD_Struct_Title	= 0x2,
	DVD_Struct_ParentalID	= 0x3,
	DVD_Struct_PartOfTitle	= 0x4,
	DVD_Struct_Cell	= 0x5,
	DVD_Stream_Audio	= 0x10,
	DVD_Stream_Subpicture	= 0x11,
	DVD_Stream_Angle	= 0x12,
	DVD_Channel_Audio	= 0x20,
	DVD_General_Name	= 0x30,
	DVD_General_Comments	= 0x31,
	DVD_Title_Series	= 0x38,
	DVD_Title_Movie	= 0x39,
	DVD_Title_Video	= 0x3a,
	DVD_Title_Album	= 0x3b,
	DVD_Title_Song	= 0x3c,
	DVD_Title_Other	= 0x3f,
	DVD_Title_Sub_Series	= 0x40,
	DVD_Title_Sub_Movie	= 0x41,
	DVD_Title_Sub_Video	= 0x42,
	DVD_Title_Sub_Album	= 0x43,
	DVD_Title_Sub_Song	= 0x44,
	DVD_Title_Sub_Other	= 0x47,
	DVD_Title_Orig_Series	= 0x48,
	DVD_Title_Orig_Movie	= 0x49,
	DVD_Title_Orig_Video	= 0x4a,
	DVD_Title_Orig_Album	= 0x4b,
	DVD_Title_Orig_Song	= 0x4c,
	DVD_Title_Orig_Other	= 0x4f,
	DVD_Other_Scene	= 0x50,
	DVD_Other_Cut	= 0x51,
	DVD_Other_Take	= 0x52
    } ;

enum DVD_TextCharSet
    {	DVD_CharSet_Unicode	= 0,
	DVD_CharSet_ISO646	= 1,
	DVD_CharSet_JIS_Roman_Kanji	= 2,
	DVD_CharSet_ISO8859_1	= 3,
	DVD_CharSet_ShiftJIS_Kanji_Roman_Katakana	= 4
    } ;
#define DVD_TITLE_MENU				0x000
#define DVD_STREAM_DATA_CURRENT     0x800
#define DVD_STREAM_DATA_VMGM        0x400
#define DVD_STREAM_DATA_VTSM        0x401
#define DVD_DEFAULT_AUDIO_STREAM	0x0f
typedef struct tagDVD_DECODER_CAPS
    {
    DWORD dwSize;
    DWORD dwAudioCaps;
    double dFwdMaxRateVideo;
    double dFwdMaxRateAudio;
    double dFwdMaxRateSP;
    double dBwdMaxRateVideo;
    double dBwdMaxRateAudio;
    double dBwdMaxRateSP;
    DWORD dwRes1;
    DWORD dwRes2;
    DWORD dwRes3;
    DWORD dwRes4;
    } 	DVD_DECODER_CAPS;

#define DVD_AUDIO_CAPS_AC3		0x00000001
#define DVD_AUDIO_CAPS_MPEG2	0x00000002
#define DVD_AUDIO_CAPS_LPCM		0x00000004
#define DVD_AUDIO_CAPS_DTS		0x00000008
#define DVD_AUDIO_CAPS_SDDS		0x00000010


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0114_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0114_v0_0_s_ifspec;

#ifndef __IDvdInfo2_INTERFACE_DEFINED__
#define __IDvdInfo2_INTERFACE_DEFINED__

/* interface IDvdInfo2 */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IDvdInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("34151510-EEC0-11D2-8201-00A0C9D74842")
    IDvdInfo2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentDomain( 
            /* [out] */ 
            __out  DVD_DOMAIN *pDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentLocation( 
            /* [out] */ 
            __out  DVD_PLAYBACK_LOCATION2 *pLocation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalTitleTime( 
            /* [out] */ 
            __out  DVD_HMSF_TIMECODE *pTotalTime,
            /* [out] */ 
            __out  ULONG *ulTimeCodeFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentButton( 
            /* [out] */ 
            __out  ULONG *pulButtonsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentButton) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAngle( 
            /* [out] */ 
            __out  ULONG *pulAnglesAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAudio( 
            /* [out] */ 
            __out  ULONG *pulStreamsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSubpicture( 
            /* [out] */ 
            __out  ULONG *pulStreamsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentStream,
            /* [out] */ 
            __out  BOOL *pbIsDisabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentUOPS( 
            /* [out] */ 
            __out  ULONG *pulUOPs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllSPRMs( 
            /* [out] */ 
            __out  SPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllGPRMs( 
            /* [out] */ 
            __out  GPRMARRAY *pRegisterArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureLanguage( 
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleAttributes( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  DVD_MenuAttributes *pMenu,
            /* [out] */ 
            __out  DVD_TitleAttributes *pTitle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVMGAttributes( 
            /* [out] */ 
            __out  DVD_MenuAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVideoAttributes( 
            /* [out] */ 
            __out  DVD_VideoAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAudioAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  DVD_AudioAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKaraokeAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  DVD_KaraokeAttributes *pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubpictureAttributes( 
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  DVD_SubpictureAttributes *pATR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDVolumeInfo( 
            /* [out] */ 
            __out  ULONG *pulNumOfVolumes,
            /* [out] */ 
            __out  ULONG *pulVolume,
            /* [out] */ 
            __out  DVD_DISC_SIDE *pSide,
            /* [out] */ 
            __out  ULONG *pulNumOfTitles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextNumberOfLanguages( 
            /* [out] */ 
            __out  ULONG *pulNumOfLangs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextLanguageInfo( 
            /* [in] */ ULONG ulLangIndex,
            /* [out] */ 
            __out  ULONG *pulNumOfStrings,
            /* [out] */ 
            __out  LCID *pLangCode,
            /* [out] */ 
            __out  enum DVD_TextCharSet *pbCharacterSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextStringAsNative( 
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ 
            __out  BYTE *pbBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ 
            __out  ULONG *pulActualSize,
            /* [out] */ 
            __out  enum DVD_TextStringType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDTextStringAsUnicode( 
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ 
            __out  WCHAR *pchwBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ 
            __out  ULONG *pulActualSize,
            /* [out] */ 
            __out  enum DVD_TextStringType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPlayerParentalLevel( 
            /* [out] */ 
            __out  ULONG *pulParentalLevel,
            /* [out] */ 
            __out  BYTE pbCountryCode[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfChapters( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  ULONG *pulNumOfChapters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTitleParentalLevels( 
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  ULONG *pulParentalLevels) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDVDDirectory( 
            /* [size_is][out] */ 
            __out_ecount_part(ulMaxSize, *pulActualSize)  LPWSTR pszwPath,
            /* [in] */ ULONG ulMaxSize,
            /* [out] */ 
            __out  ULONG *pulActualSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAudioStreamEnabled( 
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ 
            __out  BOOL *pbEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiscID( 
            /* [in] */ LPCWSTR pszwPath,
            /* [out] */ 
            __out  ULONGLONG *pullDiscID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ 
            __out  IDvdState **pStateData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuLanguages( 
            /* [out] */ 
            __out  LCID *pLanguages,
            /* [in] */ ULONG ulMaxLanguages,
            /* [out] */ 
            __out  ULONG *pulActualLanguages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonAtPosition( 
            /* [in] */ POINT point,
            /* [out] */ 
            __out  ULONG *pulButtonIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCmdFromEvent( 
            /* [in] */ LONG_PTR lParam1,
            /* [out] */ 
            __out  IDvdCmd **pCmdObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMenuLanguage( 
            /* [out] */ 
            __out  LCID *pLanguage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultAudioLanguage( 
            /* [out] */ 
            __out  LCID *pLanguage,
            /* [out] */ 
            __out  DVD_AUDIO_LANG_EXT *pAudioExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultSubpictureLanguage( 
            /* [out] */ 
            __out  LCID *pLanguage,
            /* [out] */ 
            __out  DVD_SUBPICTURE_LANG_EXT *pSubpictureExtension) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDecoderCaps( 
            /* [out] */ 
            __out  DVD_DECODER_CAPS *pCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetButtonRect( 
            /* [in] */ ULONG ulButton,
            /* [out] */ 
            __out  RECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSubpictureStreamEnabled( 
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ 
            __out  BOOL *pbEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentDomain )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  DVD_DOMAIN *pDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentLocation )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  DVD_PLAYBACK_LOCATION2 *pLocation);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalTitleTime )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  DVD_HMSF_TIMECODE *pTotalTime,
            /* [out] */ 
            __out  ULONG *ulTimeCodeFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentButton )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  ULONG *pulButtonsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentButton);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAngle )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  ULONG *pulAnglesAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentAngle);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAudio )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  ULONG *pulStreamsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSubpicture )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  ULONG *pulStreamsAvailable,
            /* [out] */ 
            __out  ULONG *pulCurrentStream,
            /* [out] */ 
            __out  BOOL *pbIsDisabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentUOPS )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  ULONG *pulUOPs);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllSPRMs )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  SPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAllGPRMs )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  GPRMARRAY *pRegisterArray);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioLanguage )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureLanguage )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  DVD_MenuAttributes *pMenu,
            /* [out] */ 
            __out  DVD_TitleAttributes *pTitle);
        
        HRESULT ( STDMETHODCALLTYPE *GetVMGAttributes )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  DVD_MenuAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVideoAttributes )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  DVD_VideoAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetAudioAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  DVD_AudioAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetKaraokeAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  DVD_KaraokeAttributes *pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubpictureAttributes )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStream,
            /* [out] */ 
            __out  DVD_SubpictureAttributes *pATR);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDVolumeInfo )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  ULONG *pulNumOfVolumes,
            /* [out] */ 
            __out  ULONG *pulVolume,
            /* [out] */ 
            __out  DVD_DISC_SIDE *pSide,
            /* [out] */ 
            __out  ULONG *pulNumOfTitles);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextNumberOfLanguages )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  ULONG *pulNumOfLangs);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextLanguageInfo )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [out] */ 
            __out  ULONG *pulNumOfStrings,
            /* [out] */ 
            __out  LCID *pLangCode,
            /* [out] */ 
            __out  enum DVD_TextCharSet *pbCharacterSet);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextStringAsNative )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ 
            __out  BYTE *pbBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ 
            __out  ULONG *pulActualSize,
            /* [out] */ 
            __out  enum DVD_TextStringType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDTextStringAsUnicode )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulLangIndex,
            /* [in] */ ULONG ulStringIndex,
            /* [out] */ 
            __out  WCHAR *pchwBuffer,
            /* [in] */ ULONG ulMaxBufferSize,
            /* [out] */ 
            __out  ULONG *pulActualSize,
            /* [out] */ 
            __out  enum DVD_TextStringType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPlayerParentalLevel )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  ULONG *pulParentalLevel,
            /* [out] */ 
            __out  BYTE pbCountryCode[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfChapters )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  ULONG *pulNumOfChapters);
        
        HRESULT ( STDMETHODCALLTYPE *GetTitleParentalLevels )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulTitle,
            /* [out] */ 
            __out  ULONG *pulParentalLevels);
        
        HRESULT ( STDMETHODCALLTYPE *GetDVDDirectory )( 
            IDvdInfo2 * This,
            /* [size_is][out] */ 
            __out_ecount_part(ulMaxSize, *pulActualSize)  LPWSTR pszwPath,
            /* [in] */ ULONG ulMaxSize,
            /* [out] */ 
            __out  ULONG *pulActualSize);
        
        HRESULT ( STDMETHODCALLTYPE *IsAudioStreamEnabled )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ 
            __out  BOOL *pbEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiscID )( 
            IDvdInfo2 * This,
            /* [in] */ LPCWSTR pszwPath,
            /* [out] */ 
            __out  ULONGLONG *pullDiscID);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  IDvdState **pStateData);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuLanguages )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  LCID *pLanguages,
            /* [in] */ ULONG ulMaxLanguages,
            /* [out] */ 
            __out  ULONG *pulActualLanguages);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonAtPosition )( 
            IDvdInfo2 * This,
            /* [in] */ POINT point,
            /* [out] */ 
            __out  ULONG *pulButtonIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetCmdFromEvent )( 
            IDvdInfo2 * This,
            /* [in] */ LONG_PTR lParam1,
            /* [out] */ 
            __out  IDvdCmd **pCmdObj);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMenuLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  LCID *pLanguage);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultAudioLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  LCID *pLanguage,
            /* [out] */ 
            __out  DVD_AUDIO_LANG_EXT *pAudioExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultSubpictureLanguage )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  LCID *pLanguage,
            /* [out] */ 
            __out  DVD_SUBPICTURE_LANG_EXT *pSubpictureExtension);
        
        HRESULT ( STDMETHODCALLTYPE *GetDecoderCaps )( 
            IDvdInfo2 * This,
            /* [out] */ 
            __out  DVD_DECODER_CAPS *pCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetButtonRect )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulButton,
            /* [out] */ 
            __out  RECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *IsSubpictureStreamEnabled )( 
            IDvdInfo2 * This,
            /* [in] */ ULONG ulStreamNum,
            /* [out] */ 
            __out  BOOL *pbEnabled);
        
        END_INTERFACE
    } IDvdInfo2Vtbl;

    interface IDvdInfo2
    {
        CONST_VTBL struct IDvdInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdInfo2_GetCurrentDomain(This,pDomain)	\
    ( (This)->lpVtbl -> GetCurrentDomain(This,pDomain) ) 

#define IDvdInfo2_GetCurrentLocation(This,pLocation)	\
    ( (This)->lpVtbl -> GetCurrentLocation(This,pLocation) ) 

#define IDvdInfo2_GetTotalTitleTime(This,pTotalTime,ulTimeCodeFlags)	\
    ( (This)->lpVtbl -> GetTotalTitleTime(This,pTotalTime,ulTimeCodeFlags) ) 

#define IDvdInfo2_GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton)	\
    ( (This)->lpVtbl -> GetCurrentButton(This,pulButtonsAvailable,pulCurrentButton) ) 

#define IDvdInfo2_GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle)	\
    ( (This)->lpVtbl -> GetCurrentAngle(This,pulAnglesAvailable,pulCurrentAngle) ) 

#define IDvdInfo2_GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream)	\
    ( (This)->lpVtbl -> GetCurrentAudio(This,pulStreamsAvailable,pulCurrentStream) ) 

#define IDvdInfo2_GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pbIsDisabled)	\
    ( (This)->lpVtbl -> GetCurrentSubpicture(This,pulStreamsAvailable,pulCurrentStream,pbIsDisabled) ) 

#define IDvdInfo2_GetCurrentUOPS(This,pulUOPs)	\
    ( (This)->lpVtbl -> GetCurrentUOPS(This,pulUOPs) ) 

#define IDvdInfo2_GetAllSPRMs(This,pRegisterArray)	\
    ( (This)->lpVtbl -> GetAllSPRMs(This,pRegisterArray) ) 

#define IDvdInfo2_GetAllGPRMs(This,pRegisterArray)	\
    ( (This)->lpVtbl -> GetAllGPRMs(This,pRegisterArray) ) 

#define IDvdInfo2_GetAudioLanguage(This,ulStream,pLanguage)	\
    ( (This)->lpVtbl -> GetAudioLanguage(This,ulStream,pLanguage) ) 

#define IDvdInfo2_GetSubpictureLanguage(This,ulStream,pLanguage)	\
    ( (This)->lpVtbl -> GetSubpictureLanguage(This,ulStream,pLanguage) ) 

#define IDvdInfo2_GetTitleAttributes(This,ulTitle,pMenu,pTitle)	\
    ( (This)->lpVtbl -> GetTitleAttributes(This,ulTitle,pMenu,pTitle) ) 

#define IDvdInfo2_GetVMGAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetVMGAttributes(This,pATR) ) 

#define IDvdInfo2_GetCurrentVideoAttributes(This,pATR)	\
    ( (This)->lpVtbl -> GetCurrentVideoAttributes(This,pATR) ) 

#define IDvdInfo2_GetAudioAttributes(This,ulStream,pATR)	\
    ( (This)->lpVtbl -> GetAudioAttributes(This,ulStream,pATR) ) 

#define IDvdInfo2_GetKaraokeAttributes(This,ulStream,pAttributes)	\
    ( (This)->lpVtbl -> GetKaraokeAttributes(This,ulStream,pAttributes) ) 

#define IDvdInfo2_GetSubpictureAttributes(This,ulStream,pATR)	\
    ( (This)->lpVtbl -> GetSubpictureAttributes(This,ulStream,pATR) ) 

#define IDvdInfo2_GetDVDVolumeInfo(This,pulNumOfVolumes,pulVolume,pSide,pulNumOfTitles)	\
    ( (This)->lpVtbl -> GetDVDVolumeInfo(This,pulNumOfVolumes,pulVolume,pSide,pulNumOfTitles) ) 

#define IDvdInfo2_GetDVDTextNumberOfLanguages(This,pulNumOfLangs)	\
    ( (This)->lpVtbl -> GetDVDTextNumberOfLanguages(This,pulNumOfLangs) ) 

#define IDvdInfo2_GetDVDTextLanguageInfo(This,ulLangIndex,pulNumOfStrings,pLangCode,pbCharacterSet)	\
    ( (This)->lpVtbl -> GetDVDTextLanguageInfo(This,ulLangIndex,pulNumOfStrings,pLangCode,pbCharacterSet) ) 

#define IDvdInfo2_GetDVDTextStringAsNative(This,ulLangIndex,ulStringIndex,pbBuffer,ulMaxBufferSize,pulActualSize,pType)	\
    ( (This)->lpVtbl -> GetDVDTextStringAsNative(This,ulLangIndex,ulStringIndex,pbBuffer,ulMaxBufferSize,pulActualSize,pType) ) 

#define IDvdInfo2_GetDVDTextStringAsUnicode(This,ulLangIndex,ulStringIndex,pchwBuffer,ulMaxBufferSize,pulActualSize,pType)	\
    ( (This)->lpVtbl -> GetDVDTextStringAsUnicode(This,ulLangIndex,ulStringIndex,pchwBuffer,ulMaxBufferSize,pulActualSize,pType) ) 

#define IDvdInfo2_GetPlayerParentalLevel(This,pulParentalLevel,pbCountryCode)	\
    ( (This)->lpVtbl -> GetPlayerParentalLevel(This,pulParentalLevel,pbCountryCode) ) 

#define IDvdInfo2_GetNumberOfChapters(This,ulTitle,pulNumOfChapters)	\
    ( (This)->lpVtbl -> GetNumberOfChapters(This,ulTitle,pulNumOfChapters) ) 

#define IDvdInfo2_GetTitleParentalLevels(This,ulTitle,pulParentalLevels)	\
    ( (This)->lpVtbl -> GetTitleParentalLevels(This,ulTitle,pulParentalLevels) ) 

#define IDvdInfo2_GetDVDDirectory(This,pszwPath,ulMaxSize,pulActualSize)	\
    ( (This)->lpVtbl -> GetDVDDirectory(This,pszwPath,ulMaxSize,pulActualSize) ) 

#define IDvdInfo2_IsAudioStreamEnabled(This,ulStreamNum,pbEnabled)	\
    ( (This)->lpVtbl -> IsAudioStreamEnabled(This,ulStreamNum,pbEnabled) ) 

#define IDvdInfo2_GetDiscID(This,pszwPath,pullDiscID)	\
    ( (This)->lpVtbl -> GetDiscID(This,pszwPath,pullDiscID) ) 

#define IDvdInfo2_GetState(This,pStateData)	\
    ( (This)->lpVtbl -> GetState(This,pStateData) ) 

#define IDvdInfo2_GetMenuLanguages(This,pLanguages,ulMaxLanguages,pulActualLanguages)	\
    ( (This)->lpVtbl -> GetMenuLanguages(This,pLanguages,ulMaxLanguages,pulActualLanguages) ) 

#define IDvdInfo2_GetButtonAtPosition(This,point,pulButtonIndex)	\
    ( (This)->lpVtbl -> GetButtonAtPosition(This,point,pulButtonIndex) ) 

#define IDvdInfo2_GetCmdFromEvent(This,lParam1,pCmdObj)	\
    ( (This)->lpVtbl -> GetCmdFromEvent(This,lParam1,pCmdObj) ) 

#define IDvdInfo2_GetDefaultMenuLanguage(This,pLanguage)	\
    ( (This)->lpVtbl -> GetDefaultMenuLanguage(This,pLanguage) ) 

#define IDvdInfo2_GetDefaultAudioLanguage(This,pLanguage,pAudioExtension)	\
    ( (This)->lpVtbl -> GetDefaultAudioLanguage(This,pLanguage,pAudioExtension) ) 

#define IDvdInfo2_GetDefaultSubpictureLanguage(This,pLanguage,pSubpictureExtension)	\
    ( (This)->lpVtbl -> GetDefaultSubpictureLanguage(This,pLanguage,pSubpictureExtension) ) 

#define IDvdInfo2_GetDecoderCaps(This,pCaps)	\
    ( (This)->lpVtbl -> GetDecoderCaps(This,pCaps) ) 

#define IDvdInfo2_GetButtonRect(This,ulButton,pRect)	\
    ( (This)->lpVtbl -> GetButtonRect(This,ulButton,pRect) ) 

#define IDvdInfo2_IsSubpictureStreamEnabled(This,ulStreamNum,pbEnabled)	\
    ( (This)->lpVtbl -> IsSubpictureStreamEnabled(This,ulStreamNum,pbEnabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdInfo2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0115 */
/* [local] */ 

typedef 
enum _AM_DVD_GRAPH_FLAGS
    {	AM_DVD_HWDEC_PREFER	= 0x1,
	AM_DVD_HWDEC_ONLY	= 0x2,
	AM_DVD_SWDEC_PREFER	= 0x4,
	AM_DVD_SWDEC_ONLY	= 0x8,
	AM_DVD_NOVPE	= 0x100,
	AM_DVD_DO_NOT_CLEAR	= 0x200,
	AM_DVD_VMR9_ONLY	= 0x800,
	AM_DVD_EVR_ONLY	= 0x1000
    } 	AM_DVD_GRAPH_FLAGS;

typedef 
enum _AM_DVD_STREAM_FLAGS
    {	AM_DVD_STREAM_VIDEO	= 0x1,
	AM_DVD_STREAM_AUDIO	= 0x2,
	AM_DVD_STREAM_SUBPIC	= 0x4
    } 	AM_DVD_STREAM_FLAGS;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0115_0001
    {
    HRESULT hrVPEStatus;
    BOOL bDvdVolInvalid;
    BOOL bDvdVolUnknown;
    BOOL bNoLine21In;
    BOOL bNoLine21Out;
    int iNumStreams;
    int iNumStreamsFailed;
    DWORD dwFailedStreamsFlag;
    } 	AM_DVD_RENDERSTATUS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0115_v0_0_s_ifspec;

#ifndef __IDvdGraphBuilder_INTERFACE_DEFINED__
#define __IDvdGraphBuilder_INTERFACE_DEFINED__

/* interface IDvdGraphBuilder */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDvdGraphBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FCC152B6-F372-11d0-8E00-00C04FD7C08B")
    IDvdGraphBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFiltergraph( 
            /* [out] */ 
            __out  IGraphBuilder **ppGB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDvdInterface( 
            /* [in] */ REFIID riid,
            /* [out] */ 
            __out  void **ppvIF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderDvdVideoVolume( 
            /* [in] */ LPCWSTR lpcwszPathName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  AM_DVD_RENDERSTATUS *pStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDvdGraphBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDvdGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDvdGraphBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDvdGraphBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFiltergraph )( 
            IDvdGraphBuilder * This,
            /* [out] */ 
            __out  IGraphBuilder **ppGB);
        
        HRESULT ( STDMETHODCALLTYPE *GetDvdInterface )( 
            IDvdGraphBuilder * This,
            /* [in] */ REFIID riid,
            /* [out] */ 
            __out  void **ppvIF);
        
        HRESULT ( STDMETHODCALLTYPE *RenderDvdVideoVolume )( 
            IDvdGraphBuilder * This,
            /* [in] */ LPCWSTR lpcwszPathName,
            /* [in] */ DWORD dwFlags,
            /* [out] */ 
            __out  AM_DVD_RENDERSTATUS *pStatus);
        
        END_INTERFACE
    } IDvdGraphBuilderVtbl;

    interface IDvdGraphBuilder
    {
        CONST_VTBL struct IDvdGraphBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDvdGraphBuilder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDvdGraphBuilder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDvdGraphBuilder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDvdGraphBuilder_GetFiltergraph(This,ppGB)	\
    ( (This)->lpVtbl -> GetFiltergraph(This,ppGB) ) 

#define IDvdGraphBuilder_GetDvdInterface(This,riid,ppvIF)	\
    ( (This)->lpVtbl -> GetDvdInterface(This,riid,ppvIF) ) 

#define IDvdGraphBuilder_RenderDvdVideoVolume(This,lpcwszPathName,dwFlags,pStatus)	\
    ( (This)->lpVtbl -> RenderDvdVideoVolume(This,lpcwszPathName,dwFlags,pStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDvdGraphBuilder_INTERFACE_DEFINED__ */


#ifndef __IDDrawExclModeVideo_INTERFACE_DEFINED__
#define __IDDrawExclModeVideo_INTERFACE_DEFINED__

/* interface IDDrawExclModeVideo */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDDrawExclModeVideo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("153ACC21-D83B-11d1-82BF-00A0C9696C8F")
    IDDrawExclModeVideo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDDrawObject( 
            /* [in] */ IDirectDraw *pDDrawObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDDrawObject( 
            /* [out] */ 
            __out  IDirectDraw **ppDDrawObject,
            /* [out] */ 
            __out  BOOL *pbUsingExternal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDDrawSurface( 
            /* [in] */ IDirectDrawSurface *pDDrawSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDDrawSurface( 
            /* [out] */ 
            __out  IDirectDrawSurface **ppDDrawSurface,
            /* [out] */ 
            __out  BOOL *pbUsingExternal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDrawParameters( 
            /* [in] */ const RECT *prcSource,
            /* [in] */ const RECT *prcTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNativeVideoProps( 
            /* [out] */ 
            __out  DWORD *pdwVideoWidth,
            /* [out] */ 
            __out  DWORD *pdwVideoHeight,
            /* [out] */ 
            __out  DWORD *pdwPictAspectRatioX,
            /* [out] */ 
            __out  DWORD *pdwPictAspectRatioY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCallbackInterface( 
            /* [in] */ IDDrawExclModeVideoCallback *pCallback,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDDrawExclModeVideoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDDrawExclModeVideo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDDrawExclModeVideo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawObject )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDirectDraw *pDDrawObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetDDrawObject )( 
            IDDrawExclModeVideo * This,
            /* [out] */ 
            __out  IDirectDraw **ppDDrawObject,
            /* [out] */ 
            __out  BOOL *pbUsingExternal);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawSurface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDirectDrawSurface *pDDrawSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetDDrawSurface )( 
            IDDrawExclModeVideo * This,
            /* [out] */ 
            __out  IDirectDrawSurface **ppDDrawSurface,
            /* [out] */ 
            __out  BOOL *pbUsingExternal);
        
        HRESULT ( STDMETHODCALLTYPE *SetDrawParameters )( 
            IDDrawExclModeVideo * This,
            /* [in] */ const RECT *prcSource,
            /* [in] */ const RECT *prcTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeVideoProps )( 
            IDDrawExclModeVideo * This,
            /* [out] */ 
            __out  DWORD *pdwVideoWidth,
            /* [out] */ 
            __out  DWORD *pdwVideoHeight,
            /* [out] */ 
            __out  DWORD *pdwPictAspectRatioX,
            /* [out] */ 
            __out  DWORD *pdwPictAspectRatioY);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallbackInterface )( 
            IDDrawExclModeVideo * This,
            /* [in] */ IDDrawExclModeVideoCallback *pCallback,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDDrawExclModeVideoVtbl;

    interface IDDrawExclModeVideo
    {
        CONST_VTBL struct IDDrawExclModeVideoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDDrawExclModeVideo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDDrawExclModeVideo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDDrawExclModeVideo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDDrawExclModeVideo_SetDDrawObject(This,pDDrawObject)	\
    ( (This)->lpVtbl -> SetDDrawObject(This,pDDrawObject) ) 

#define IDDrawExclModeVideo_GetDDrawObject(This,ppDDrawObject,pbUsingExternal)	\
    ( (This)->lpVtbl -> GetDDrawObject(This,ppDDrawObject,pbUsingExternal) ) 

#define IDDrawExclModeVideo_SetDDrawSurface(This,pDDrawSurface)	\
    ( (This)->lpVtbl -> SetDDrawSurface(This,pDDrawSurface) ) 

#define IDDrawExclModeVideo_GetDDrawSurface(This,ppDDrawSurface,pbUsingExternal)	\
    ( (This)->lpVtbl -> GetDDrawSurface(This,ppDDrawSurface,pbUsingExternal) ) 

#define IDDrawExclModeVideo_SetDrawParameters(This,prcSource,prcTarget)	\
    ( (This)->lpVtbl -> SetDrawParameters(This,prcSource,prcTarget) ) 

#define IDDrawExclModeVideo_GetNativeVideoProps(This,pdwVideoWidth,pdwVideoHeight,pdwPictAspectRatioX,pdwPictAspectRatioY)	\
    ( (This)->lpVtbl -> GetNativeVideoProps(This,pdwVideoWidth,pdwVideoHeight,pdwPictAspectRatioX,pdwPictAspectRatioY) ) 

#define IDDrawExclModeVideo_SetCallbackInterface(This,pCallback,dwFlags)	\
    ( (This)->lpVtbl -> SetCallbackInterface(This,pCallback,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDDrawExclModeVideo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0117 */
/* [local] */ 


enum _AM_OVERLAY_NOTIFY_FLAGS
    {	AM_OVERLAY_NOTIFY_VISIBLE_CHANGE	= 0x1,
	AM_OVERLAY_NOTIFY_SOURCE_CHANGE	= 0x2,
	AM_OVERLAY_NOTIFY_DEST_CHANGE	= 0x4
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0117_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0117_v0_0_s_ifspec;

#ifndef __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__
#define __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__

/* interface IDDrawExclModeVideoCallback */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_IDDrawExclModeVideoCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("913c24a0-20ab-11d2-9038-00a0c9697298")
    IDDrawExclModeVideoCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdateOverlay( 
            /* [in] */ BOOL bBefore,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bOldVisible,
            /* [in] */ const RECT *prcOldSrc,
            /* [in] */ const RECT *prcOldDest,
            /* [in] */ BOOL bNewVisible,
            /* [in] */ const RECT *prcNewSrc,
            /* [in] */ const RECT *prcNewDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateColorKey( 
            /* [in] */ const COLORKEY *pKey,
            /* [in] */ DWORD dwColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnUpdateSize( 
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight,
            /* [in] */ DWORD dwARWidth,
            /* [in] */ DWORD dwARHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDDrawExclModeVideoCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDDrawExclModeVideoCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDDrawExclModeVideoCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateOverlay )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ BOOL bBefore,
            /* [in] */ DWORD dwFlags,
            /* [in] */ BOOL bOldVisible,
            /* [in] */ const RECT *prcOldSrc,
            /* [in] */ const RECT *prcOldDest,
            /* [in] */ BOOL bNewVisible,
            /* [in] */ const RECT *prcNewSrc,
            /* [in] */ const RECT *prcNewDest);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateColorKey )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ const COLORKEY *pKey,
            /* [in] */ DWORD dwColor);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdateSize )( 
            IDDrawExclModeVideoCallback * This,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight,
            /* [in] */ DWORD dwARWidth,
            /* [in] */ DWORD dwARHeight);
        
        END_INTERFACE
    } IDDrawExclModeVideoCallbackVtbl;

    interface IDDrawExclModeVideoCallback
    {
        CONST_VTBL struct IDDrawExclModeVideoCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDDrawExclModeVideoCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDDrawExclModeVideoCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDDrawExclModeVideoCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDDrawExclModeVideoCallback_OnUpdateOverlay(This,bBefore,dwFlags,bOldVisible,prcOldSrc,prcOldDest,bNewVisible,prcNewSrc,prcNewDest)	\
    ( (This)->lpVtbl -> OnUpdateOverlay(This,bBefore,dwFlags,bOldVisible,prcOldSrc,prcOldDest,bNewVisible,prcNewSrc,prcNewDest) ) 

#define IDDrawExclModeVideoCallback_OnUpdateColorKey(This,pKey,dwColor)	\
    ( (This)->lpVtbl -> OnUpdateColorKey(This,pKey,dwColor) ) 

#define IDDrawExclModeVideoCallback_OnUpdateSize(This,dwWidth,dwHeight,dwARWidth,dwARHeight)	\
    ( (This)->lpVtbl -> OnUpdateSize(This,dwWidth,dwHeight,dwARWidth,dwARHeight) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDDrawExclModeVideoCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0118 */
/* [local] */ 







extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0118_v0_0_s_ifspec;

#ifndef __IPinConnection_INTERFACE_DEFINED__
#define __IPinConnection_INTERFACE_DEFINED__

/* interface IPinConnection */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPinConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a9a62d3-27d4-403d-91e9-89f540e55534")
    IPinConnection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DynamicQueryAccept( 
            /* [in] */ const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyEndOfStream( 
            /* [in] */ HANDLE hNotifyEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEndPin( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DynamicDisconnect( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPinConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPinConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPinConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *DynamicQueryAccept )( 
            IPinConnection * This,
            /* [in] */ const AM_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEndOfStream )( 
            IPinConnection * This,
            /* [in] */ HANDLE hNotifyEvent);
        
        HRESULT ( STDMETHODCALLTYPE *IsEndPin )( 
            IPinConnection * This);
        
        HRESULT ( STDMETHODCALLTYPE *DynamicDisconnect )( 
            IPinConnection * This);
        
        END_INTERFACE
    } IPinConnectionVtbl;

    interface IPinConnection
    {
        CONST_VTBL struct IPinConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPinConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPinConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPinConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPinConnection_DynamicQueryAccept(This,pmt)	\
    ( (This)->lpVtbl -> DynamicQueryAccept(This,pmt) ) 

#define IPinConnection_NotifyEndOfStream(This,hNotifyEvent)	\
    ( (This)->lpVtbl -> NotifyEndOfStream(This,hNotifyEvent) ) 

#define IPinConnection_IsEndPin(This)	\
    ( (This)->lpVtbl -> IsEndPin(This) ) 

#define IPinConnection_DynamicDisconnect(This)	\
    ( (This)->lpVtbl -> DynamicDisconnect(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPinConnection_INTERFACE_DEFINED__ */


#ifndef __IPinFlowControl_INTERFACE_DEFINED__
#define __IPinFlowControl_INTERFACE_DEFINED__

/* interface IPinFlowControl */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPinFlowControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c56e9858-dbf3-4f6b-8119-384af2060deb")
    IPinFlowControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Block( 
            /* [in] */ DWORD dwBlockFlags,
            /* [in] */ HANDLE hEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPinFlowControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPinFlowControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPinFlowControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPinFlowControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Block )( 
            IPinFlowControl * This,
            /* [in] */ DWORD dwBlockFlags,
            /* [in] */ HANDLE hEvent);
        
        END_INTERFACE
    } IPinFlowControlVtbl;

    interface IPinFlowControl
    {
        CONST_VTBL struct IPinFlowControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPinFlowControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPinFlowControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPinFlowControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPinFlowControl_Block(This,dwBlockFlags,hEvent)	\
    ( (This)->lpVtbl -> Block(This,dwBlockFlags,hEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPinFlowControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0120 */
/* [local] */ 


enum _AM_PIN_FLOW_CONTROL_BLOCK_FLAGS
    {	AM_PIN_FLOW_CONTROL_BLOCK	= 0x1
    } ;
typedef 
enum _AM_GRAPH_CONFIG_RECONNECT_FLAGS
    {	AM_GRAPH_CONFIG_RECONNECT_DIRECTCONNECT	= 0x1,
	AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS	= 0x2,
	AM_GRAPH_CONFIG_RECONNECT_USE_ONLY_CACHED_FILTERS	= 0x4
    } 	AM_GRAPH_CONFIG_RECONNECT_FLAGS;


enum _REM_FILTER_FLAGS
    {	REMFILTERF_LEAVECONNECTED	= 0x1
    } ;
typedef 
enum _AM_FILTER_FLAGS
    {	AM_FILTER_FLAGS_REMOVABLE	= 0x1
    } 	AM_FILTER_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0120_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0120_v0_0_s_ifspec;

#ifndef __IGraphConfig_INTERFACE_DEFINED__
#define __IGraphConfig_INTERFACE_DEFINED__

/* interface IGraphConfig */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IGraphConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03A1EB8E-32BF-4245-8502-114D08A9CB88")
    IGraphConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reconnect( 
            /* [in] */ IPin *pOutputPin,
            /* [in] */ IPin *pInputPin,
            /* [in] */ const AM_MEDIA_TYPE *pmtFirstConnection,
            /* [in] */ IBaseFilter *pUsingFilter,
            /* [in] */ HANDLE hAbortEvent,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconfigure( 
            /* [in] */ IGraphConfigCallback *pCallback,
            /* [in] */ PVOID pvContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HANDLE hAbortEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFilterToCache( 
            /* [in] */ IBaseFilter *pFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCacheFilter( 
            /* [out] */ IEnumFilters **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilterFromCache( 
            /* [in] */ IBaseFilter *pFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartTime( 
            /* [out] */ REFERENCE_TIME *prtStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushThroughData( 
            /* [in] */ IPin *pOutputPin,
            /* [in] */ IPinConnection *pConnection,
            /* [in] */ HANDLE hEventAbort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilterFlags( 
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterFlags( 
            /* [in] */ IBaseFilter *pFilter,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilterEx( 
            /* [in] */ IBaseFilter *pFilter,
            DWORD Flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reconnect )( 
            IGraphConfig * This,
            /* [in] */ IPin *pOutputPin,
            /* [in] */ IPin *pInputPin,
            /* [in] */ const AM_MEDIA_TYPE *pmtFirstConnection,
            /* [in] */ IBaseFilter *pUsingFilter,
            /* [in] */ HANDLE hAbortEvent,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reconfigure )( 
            IGraphConfig * This,
            /* [in] */ IGraphConfigCallback *pCallback,
            /* [in] */ PVOID pvContext,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HANDLE hAbortEvent);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilterToCache )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCacheFilter )( 
            IGraphConfig * This,
            /* [out] */ IEnumFilters **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilterFromCache )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartTime )( 
            IGraphConfig * This,
            /* [out] */ REFERENCE_TIME *prtStart);
        
        HRESULT ( STDMETHODCALLTYPE *PushThroughData )( 
            IGraphConfig * This,
            /* [in] */ IPin *pOutputPin,
            /* [in] */ IPinConnection *pConnection,
            /* [in] */ HANDLE hEventAbort);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterFlags )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterFlags )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilterEx )( 
            IGraphConfig * This,
            /* [in] */ IBaseFilter *pFilter,
            DWORD Flags);
        
        END_INTERFACE
    } IGraphConfigVtbl;

    interface IGraphConfig
    {
        CONST_VTBL struct IGraphConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGraphConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGraphConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGraphConfig_Reconnect(This,pOutputPin,pInputPin,pmtFirstConnection,pUsingFilter,hAbortEvent,dwFlags)	\
    ( (This)->lpVtbl -> Reconnect(This,pOutputPin,pInputPin,pmtFirstConnection,pUsingFilter,hAbortEvent,dwFlags) ) 

#define IGraphConfig_Reconfigure(This,pCallback,pvContext,dwFlags,hAbortEvent)	\
    ( (This)->lpVtbl -> Reconfigure(This,pCallback,pvContext,dwFlags,hAbortEvent) ) 

#define IGraphConfig_AddFilterToCache(This,pFilter)	\
    ( (This)->lpVtbl -> AddFilterToCache(This,pFilter) ) 

#define IGraphConfig_EnumCacheFilter(This,pEnum)	\
    ( (This)->lpVtbl -> EnumCacheFilter(This,pEnum) ) 

#define IGraphConfig_RemoveFilterFromCache(This,pFilter)	\
    ( (This)->lpVtbl -> RemoveFilterFromCache(This,pFilter) ) 

#define IGraphConfig_GetStartTime(This,prtStart)	\
    ( (This)->lpVtbl -> GetStartTime(This,prtStart) ) 

#define IGraphConfig_PushThroughData(This,pOutputPin,pConnection,hEventAbort)	\
    ( (This)->lpVtbl -> PushThroughData(This,pOutputPin,pConnection,hEventAbort) ) 

#define IGraphConfig_SetFilterFlags(This,pFilter,dwFlags)	\
    ( (This)->lpVtbl -> SetFilterFlags(This,pFilter,dwFlags) ) 

#define IGraphConfig_GetFilterFlags(This,pFilter,pdwFlags)	\
    ( (This)->lpVtbl -> GetFilterFlags(This,pFilter,pdwFlags) ) 

#define IGraphConfig_RemoveFilterEx(This,pFilter,Flags)	\
    ( (This)->lpVtbl -> RemoveFilterEx(This,pFilter,Flags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGraphConfig_INTERFACE_DEFINED__ */


#ifndef __IGraphConfigCallback_INTERFACE_DEFINED__
#define __IGraphConfigCallback_INTERFACE_DEFINED__

/* interface IGraphConfigCallback */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IGraphConfigCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ade0fd60-d19d-11d2-abf6-00a0c905f375")
    IGraphConfigCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reconfigure( 
            PVOID pvContext,
            DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGraphConfigCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGraphConfigCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGraphConfigCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGraphConfigCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Reconfigure )( 
            IGraphConfigCallback * This,
            PVOID pvContext,
            DWORD dwFlags);
        
        END_INTERFACE
    } IGraphConfigCallbackVtbl;

    interface IGraphConfigCallback
    {
        CONST_VTBL struct IGraphConfigCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGraphConfigCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IGraphConfigCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IGraphConfigCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IGraphConfigCallback_Reconfigure(This,pvContext,dwFlags)	\
    ( (This)->lpVtbl -> Reconfigure(This,pvContext,dwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IGraphConfigCallback_INTERFACE_DEFINED__ */


#ifndef __IFilterChain_INTERFACE_DEFINED__
#define __IFilterChain_INTERFACE_DEFINED__

/* interface IFilterChain */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IFilterChain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCFBDCF6-0DC2-45f5-9AB2-7C330EA09C29")
    IFilterChain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartChain( 
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseChain( 
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopChain( 
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveChain( 
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFilterChainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFilterChain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFilterChain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFilterChain * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartChain )( 
            IFilterChain * This,
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter);
        
        HRESULT ( STDMETHODCALLTYPE *PauseChain )( 
            IFilterChain * This,
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter);
        
        HRESULT ( STDMETHODCALLTYPE *StopChain )( 
            IFilterChain * This,
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveChain )( 
            IFilterChain * This,
            /* [in] */ IBaseFilter *pStartFilter,
            /* [in] */ IBaseFilter *pEndFilter);
        
        END_INTERFACE
    } IFilterChainVtbl;

    interface IFilterChain
    {
        CONST_VTBL struct IFilterChainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFilterChain_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFilterChain_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFilterChain_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFilterChain_StartChain(This,pStartFilter,pEndFilter)	\
    ( (This)->lpVtbl -> StartChain(This,pStartFilter,pEndFilter) ) 

#define IFilterChain_PauseChain(This,pStartFilter,pEndFilter)	\
    ( (This)->lpVtbl -> PauseChain(This,pStartFilter,pEndFilter) ) 

#define IFilterChain_StopChain(This,pStartFilter,pEndFilter)	\
    ( (This)->lpVtbl -> StopChain(This,pStartFilter,pEndFilter) ) 

#define IFilterChain_RemoveChain(This,pStartFilter,pEndFilter)	\
    ( (This)->lpVtbl -> RemoveChain(This,pStartFilter,pEndFilter) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFilterChain_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0123 */
/* [local] */ 

#if 0
typedef DWORD *LPDIRECTDRAW7;

typedef DWORD *LPDIRECTDRAWSURFACE7;

typedef DWORD *LPDDPIXELFORMAT;

typedef DWORD *LPBITMAPINFOHEADER;

typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_strmif_0000_0123_0001
    {
    DWORD dw1;
    DWORD dw2;
    } 	DDCOLORKEY;

typedef DDCOLORKEY *LPDDCOLORKEY;

#endif
#include <ddraw.h>














typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0123_0002
    {	VMRSample_SyncPoint	= 0x1,
	VMRSample_Preroll	= 0x2,
	VMRSample_Discontinuity	= 0x4,
	VMRSample_TimeValid	= 0x8,
	VMRSample_SrcDstRectsValid	= 0x10
    } 	VMRPresentationFlags;

typedef struct tagVMRPRESENTATIONINFO
    {
    DWORD dwFlags;
    LPDIRECTDRAWSURFACE7 lpSurf;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    SIZE szAspectRatio;
    RECT rcSrc;
    RECT rcDst;
    DWORD dwTypeSpecificFlags;
    DWORD dwInterlaceFlags;
    } 	VMRPRESENTATIONINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0123_v0_0_s_ifspec;

#ifndef __IVMRImagePresenter_INTERFACE_DEFINED__
#define __IVMRImagePresenter_INTERFACE_DEFINED__

/* interface IVMRImagePresenter */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CE704FE7-E71E-41fb-BAA2-C4403E1182F5")
    IVMRImagePresenter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartPresenting( 
            /* [in] */ DWORD_PTR dwUserID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopPresenting( 
            /* [in] */ DWORD_PTR dwUserID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PresentImage( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRPRESENTATIONINFO *lpPresInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenter * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartPresenting )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID);
        
        HRESULT ( STDMETHODCALLTYPE *StopPresenting )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID);
        
        HRESULT ( STDMETHODCALLTYPE *PresentImage )( 
            IVMRImagePresenter * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRPRESENTATIONINFO *lpPresInfo);
        
        END_INTERFACE
    } IVMRImagePresenterVtbl;

    interface IVMRImagePresenter
    {
        CONST_VTBL struct IVMRImagePresenterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImagePresenter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImagePresenter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImagePresenter_StartPresenting(This,dwUserID)	\
    ( (This)->lpVtbl -> StartPresenting(This,dwUserID) ) 

#define IVMRImagePresenter_StopPresenting(This,dwUserID)	\
    ( (This)->lpVtbl -> StopPresenting(This,dwUserID) ) 

#define IVMRImagePresenter_PresentImage(This,dwUserID,lpPresInfo)	\
    ( (This)->lpVtbl -> PresentImage(This,dwUserID,lpPresInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImagePresenter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0124 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0124_0001
    {	AMAP_PIXELFORMAT_VALID	= 0x1,
	AMAP_3D_TARGET	= 0x2,
	AMAP_ALLOW_SYSMEM	= 0x4,
	AMAP_FORCE_SYSMEM	= 0x8,
	AMAP_DIRECTED_FLIP	= 0x10,
	AMAP_DXVA_TARGET	= 0x20
    } 	VMRSurfaceAllocationFlags;

typedef struct tagVMRALLOCATIONINFO
    {
    DWORD dwFlags;
    LPBITMAPINFOHEADER lpHdr;
    LPDDPIXELFORMAT lpPixFmt;
    SIZE szAspectRatio;
    DWORD dwMinBuffers;
    DWORD dwMaxBuffers;
    DWORD dwInterlaceFlags;
    SIZE szNativeSize;
    } 	VMRALLOCATIONINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0124_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0124_v0_0_s_ifspec;

#ifndef __IVMRSurfaceAllocator_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocator_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocator */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31ce832e-4484-458b-8cca-f4d7e3db0b52")
    IVMRSurfaceAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocateSurface( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRALLOCATIONINFO *lpAllocInfo,
            /* [out][in] */ DWORD *lpdwActualBuffers,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeSurface( 
            /* [in] */ DWORD_PTR dwID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrepareSurface( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ LPDIRECTDRAWSURFACE7 lpSurface,
            /* [in] */ DWORD dwSurfaceFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseNotify( 
            /* [in] */ IVMRSurfaceAllocatorNotify *lpIVMRSurfAllocNotify) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ VMRALLOCATIONINFO *lpAllocInfo,
            /* [out][in] */ DWORD *lpdwActualBuffers,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *FreeSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwID);
        
        HRESULT ( STDMETHODCALLTYPE *PrepareSurface )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ LPDIRECTDRAWSURFACE7 lpSurface,
            /* [in] */ DWORD dwSurfaceFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseNotify )( 
            IVMRSurfaceAllocator * This,
            /* [in] */ IVMRSurfaceAllocatorNotify *lpIVMRSurfAllocNotify);
        
        END_INTERFACE
    } IVMRSurfaceAllocatorVtbl;

    interface IVMRSurfaceAllocator
    {
        CONST_VTBL struct IVMRSurfaceAllocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurfaceAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurfaceAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurfaceAllocator_AllocateSurface(This,dwUserID,lpAllocInfo,lpdwActualBuffers,lplpSurface)	\
    ( (This)->lpVtbl -> AllocateSurface(This,dwUserID,lpAllocInfo,lpdwActualBuffers,lplpSurface) ) 

#define IVMRSurfaceAllocator_FreeSurface(This,dwID)	\
    ( (This)->lpVtbl -> FreeSurface(This,dwID) ) 

#define IVMRSurfaceAllocator_PrepareSurface(This,dwUserID,lpSurface,dwSurfaceFlags)	\
    ( (This)->lpVtbl -> PrepareSurface(This,dwUserID,lpSurface,dwSurfaceFlags) ) 

#define IVMRSurfaceAllocator_AdviseNotify(This,lpIVMRSurfAllocNotify)	\
    ( (This)->lpVtbl -> AdviseNotify(This,lpIVMRSurfAllocNotify) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurfaceAllocator_INTERFACE_DEFINED__ */


#ifndef __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__
#define __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__

/* interface IVMRSurfaceAllocatorNotify */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurfaceAllocatorNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aada05a8-5a4e-4729-af0b-cea27aed51e2")
    IVMRSurfaceAllocatorNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseSurfaceAllocator( 
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ IVMRSurfaceAllocator *lpIVRMSurfaceAllocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDDrawDevice( 
            /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeDDrawDevice( 
            /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreDDrawSurfaces( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ LONG EventCode,
            /* [in] */ LONG_PTR Param1,
            /* [in] */ LONG_PTR Param2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBorderColor( 
            /* [in] */ COLORREF clrBorder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceAllocatorNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurfaceAllocatorNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurfaceAllocatorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseSurfaceAllocator )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ DWORD_PTR dwUserID,
            /* [in] */ IVMRSurfaceAllocator *lpIVRMSurfaceAllocator);
        
        HRESULT ( STDMETHODCALLTYPE *SetDDrawDevice )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeDDrawDevice )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LPDIRECTDRAW7 lpDDrawDevice,
            /* [in] */ HMONITOR hMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreDDrawSurfaces )( 
            IVMRSurfaceAllocatorNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyEvent )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ LONG EventCode,
            /* [in] */ LONG_PTR Param1,
            /* [in] */ LONG_PTR Param2);
        
        HRESULT ( STDMETHODCALLTYPE *SetBorderColor )( 
            IVMRSurfaceAllocatorNotify * This,
            /* [in] */ COLORREF clrBorder);
        
        END_INTERFACE
    } IVMRSurfaceAllocatorNotifyVtbl;

    interface IVMRSurfaceAllocatorNotify
    {
        CONST_VTBL struct IVMRSurfaceAllocatorNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurfaceAllocatorNotify_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurfaceAllocatorNotify_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurfaceAllocatorNotify_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurfaceAllocatorNotify_AdviseSurfaceAllocator(This,dwUserID,lpIVRMSurfaceAllocator)	\
    ( (This)->lpVtbl -> AdviseSurfaceAllocator(This,dwUserID,lpIVRMSurfaceAllocator) ) 

#define IVMRSurfaceAllocatorNotify_SetDDrawDevice(This,lpDDrawDevice,hMonitor)	\
    ( (This)->lpVtbl -> SetDDrawDevice(This,lpDDrawDevice,hMonitor) ) 

#define IVMRSurfaceAllocatorNotify_ChangeDDrawDevice(This,lpDDrawDevice,hMonitor)	\
    ( (This)->lpVtbl -> ChangeDDrawDevice(This,lpDDrawDevice,hMonitor) ) 

#define IVMRSurfaceAllocatorNotify_RestoreDDrawSurfaces(This)	\
    ( (This)->lpVtbl -> RestoreDDrawSurfaces(This) ) 

#define IVMRSurfaceAllocatorNotify_NotifyEvent(This,EventCode,Param1,Param2)	\
    ( (This)->lpVtbl -> NotifyEvent(This,EventCode,Param1,Param2) ) 

#define IVMRSurfaceAllocatorNotify_SetBorderColor(This,clrBorder)	\
    ( (This)->lpVtbl -> SetBorderColor(This,clrBorder) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurfaceAllocatorNotify_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0126 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0126_0001
    {	VMR_ARMODE_NONE	= 0,
	VMR_ARMODE_LETTER_BOX	= ( VMR_ARMODE_NONE + 1 ) 
    } 	VMR_ASPECT_RATIO_MODE;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0126_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0126_v0_0_s_ifspec;

#ifndef __IVMRWindowlessControl_INTERFACE_DEFINED__
#define __IVMRWindowlessControl_INTERFACE_DEFINED__

/* interface IVMRWindowlessControl */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRWindowlessControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0eb1088c-4dcd-46f0-878f-39dae86a51b7")
    IVMRWindowlessControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNativeVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight,
            /* [out] */ LONG *lpARWidth,
            /* [out] */ LONG *lpARHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinIdealVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxIdealVideoSize( 
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoPosition( 
            /* [in] */ const LPRECT lpSRCRect,
            /* [in] */ const LPRECT lpDSTRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPosition( 
            /* [out] */ LPRECT lpSRCRect,
            /* [out] */ LPRECT lpDSTRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode( 
            /* [out] */ DWORD *lpAspectRatioMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode( 
            /* [in] */ DWORD AspectRatioMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVideoClippingWindow( 
            /* [in] */ HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RepaintVideo( 
            /* [in] */ HWND hwnd,
            /* [in] */ HDC hdc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayModeChanged( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentImage( 
            /* [out] */ BYTE **lpDib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBorderColor( 
            /* [in] */ COLORREF Clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBorderColor( 
            /* [out] */ COLORREF *lpClr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            /* [in] */ COLORREF Clr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            /* [out] */ COLORREF *lpClr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRWindowlessControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRWindowlessControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRWindowlessControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRWindowlessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight,
            /* [out] */ LONG *lpARWidth,
            /* [out] */ LONG *lpARHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinIdealVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxIdealVideoSize )( 
            IVMRWindowlessControl * This,
            /* [out] */ LONG *lpWidth,
            /* [out] */ LONG *lpHeight);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoPosition )( 
            IVMRWindowlessControl * This,
            /* [in] */ const LPRECT lpSRCRect,
            /* [in] */ const LPRECT lpDSTRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPosition )( 
            IVMRWindowlessControl * This,
            /* [out] */ LPRECT lpSRCRect,
            /* [out] */ LPRECT lpDSTRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetAspectRatioMode )( 
            IVMRWindowlessControl * This,
            /* [out] */ DWORD *lpAspectRatioMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetAspectRatioMode )( 
            IVMRWindowlessControl * This,
            /* [in] */ DWORD AspectRatioMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoClippingWindow )( 
            IVMRWindowlessControl * This,
            /* [in] */ HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *RepaintVideo )( 
            IVMRWindowlessControl * This,
            /* [in] */ HWND hwnd,
            /* [in] */ HDC hdc);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayModeChanged )( 
            IVMRWindowlessControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentImage )( 
            IVMRWindowlessControl * This,
            /* [out] */ BYTE **lpDib);
        
        HRESULT ( STDMETHODCALLTYPE *SetBorderColor )( 
            IVMRWindowlessControl * This,
            /* [in] */ COLORREF Clr);
        
        HRESULT ( STDMETHODCALLTYPE *GetBorderColor )( 
            IVMRWindowlessControl * This,
            /* [out] */ COLORREF *lpClr);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IVMRWindowlessControl * This,
            /* [in] */ COLORREF Clr);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IVMRWindowlessControl * This,
            /* [out] */ COLORREF *lpClr);
        
        END_INTERFACE
    } IVMRWindowlessControlVtbl;

    interface IVMRWindowlessControl
    {
        CONST_VTBL struct IVMRWindowlessControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRWindowlessControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRWindowlessControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRWindowlessControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRWindowlessControl_GetNativeVideoSize(This,lpWidth,lpHeight,lpARWidth,lpARHeight)	\
    ( (This)->lpVtbl -> GetNativeVideoSize(This,lpWidth,lpHeight,lpARWidth,lpARHeight) ) 

#define IVMRWindowlessControl_GetMinIdealVideoSize(This,lpWidth,lpHeight)	\
    ( (This)->lpVtbl -> GetMinIdealVideoSize(This,lpWidth,lpHeight) ) 

#define IVMRWindowlessControl_GetMaxIdealVideoSize(This,lpWidth,lpHeight)	\
    ( (This)->lpVtbl -> GetMaxIdealVideoSize(This,lpWidth,lpHeight) ) 

#define IVMRWindowlessControl_SetVideoPosition(This,lpSRCRect,lpDSTRect)	\
    ( (This)->lpVtbl -> SetVideoPosition(This,lpSRCRect,lpDSTRect) ) 

#define IVMRWindowlessControl_GetVideoPosition(This,lpSRCRect,lpDSTRect)	\
    ( (This)->lpVtbl -> GetVideoPosition(This,lpSRCRect,lpDSTRect) ) 

#define IVMRWindowlessControl_GetAspectRatioMode(This,lpAspectRatioMode)	\
    ( (This)->lpVtbl -> GetAspectRatioMode(This,lpAspectRatioMode) ) 

#define IVMRWindowlessControl_SetAspectRatioMode(This,AspectRatioMode)	\
    ( (This)->lpVtbl -> SetAspectRatioMode(This,AspectRatioMode) ) 

#define IVMRWindowlessControl_SetVideoClippingWindow(This,hwnd)	\
    ( (This)->lpVtbl -> SetVideoClippingWindow(This,hwnd) ) 

#define IVMRWindowlessControl_RepaintVideo(This,hwnd,hdc)	\
    ( (This)->lpVtbl -> RepaintVideo(This,hwnd,hdc) ) 

#define IVMRWindowlessControl_DisplayModeChanged(This)	\
    ( (This)->lpVtbl -> DisplayModeChanged(This) ) 

#define IVMRWindowlessControl_GetCurrentImage(This,lpDib)	\
    ( (This)->lpVtbl -> GetCurrentImage(This,lpDib) ) 

#define IVMRWindowlessControl_SetBorderColor(This,Clr)	\
    ( (This)->lpVtbl -> SetBorderColor(This,Clr) ) 

#define IVMRWindowlessControl_GetBorderColor(This,lpClr)	\
    ( (This)->lpVtbl -> GetBorderColor(This,lpClr) ) 

#define IVMRWindowlessControl_SetColorKey(This,Clr)	\
    ( (This)->lpVtbl -> SetColorKey(This,Clr) ) 

#define IVMRWindowlessControl_GetColorKey(This,lpClr)	\
    ( (This)->lpVtbl -> GetColorKey(This,lpClr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRWindowlessControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0127 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0127_0001
    {	MixerPref_NoDecimation	= 0x1,
	MixerPref_DecimateOutput	= 0x2,
	MixerPref_ARAdjustXorY	= 0x4,
	MixerPref_DecimationReserved	= 0x8,
	MixerPref_DecimateMask	= 0xf,
	MixerPref_BiLinearFiltering	= 0x10,
	MixerPref_PointFiltering	= 0x20,
	MixerPref_FilteringMask	= 0xf0,
	MixerPref_RenderTargetRGB	= 0x100,
	MixerPref_RenderTargetYUV	= 0x1000,
	MixerPref_RenderTargetYUV420	= 0x200,
	MixerPref_RenderTargetYUV422	= 0x400,
	MixerPref_RenderTargetYUV444	= 0x800,
	MixerPref_RenderTargetReserved	= 0xe000,
	MixerPref_RenderTargetMask	= 0xff00,
	MixerPref_DynamicSwitchToBOB	= 0x10000,
	MixerPref_DynamicDecimateBy2	= 0x20000,
	MixerPref_DynamicReserved	= 0xc0000,
	MixerPref_DynamicMask	= 0xf0000
    } 	VMRMixerPrefs;

typedef struct _NORMALIZEDRECT
    {
    float left;
    float top;
    float right;
    float bottom;
    } 	NORMALIZEDRECT;

typedef struct _NORMALIZEDRECT *PNORMALIZEDRECT;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0127_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0127_v0_0_s_ifspec;

#ifndef __IVMRMixerControl_INTERFACE_DEFINED__
#define __IVMRMixerControl_INTERFACE_DEFINED__

/* interface IVMRMixerControl */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRMixerControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1c1a17b0-bed0-415d-974b-dc6696131599")
    IVMRMixerControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlpha( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlpha( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetZOrder( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetZOrder( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputRect( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const NORMALIZEDRECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputRect( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ NORMALIZEDRECT *pRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundClr( 
            /* [in] */ COLORREF ClrBkg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundClr( 
            /* [in] */ COLORREF *lpClrBkg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMixingPrefs( 
            /* [in] */ DWORD dwMixerPrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMixingPrefs( 
            /* [out] */ DWORD *pdwMixerPrefs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlpha )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ float Alpha);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlpha )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ float *pAlpha);
        
        HRESULT ( STDMETHODCALLTYPE *SetZOrder )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ DWORD dwZ);
        
        HRESULT ( STDMETHODCALLTYPE *GetZOrder )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ DWORD *pZ);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputRect )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ const NORMALIZEDRECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputRect )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ NORMALIZEDRECT *pRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundClr )( 
            IVMRMixerControl * This,
            /* [in] */ COLORREF ClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundClr )( 
            IVMRMixerControl * This,
            /* [in] */ COLORREF *lpClrBkg);
        
        HRESULT ( STDMETHODCALLTYPE *SetMixingPrefs )( 
            IVMRMixerControl * This,
            /* [in] */ DWORD dwMixerPrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetMixingPrefs )( 
            IVMRMixerControl * This,
            /* [out] */ DWORD *pdwMixerPrefs);
        
        END_INTERFACE
    } IVMRMixerControlVtbl;

    interface IVMRMixerControl
    {
        CONST_VTBL struct IVMRMixerControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMixerControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMixerControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMixerControl_SetAlpha(This,dwStreamID,Alpha)	\
    ( (This)->lpVtbl -> SetAlpha(This,dwStreamID,Alpha) ) 

#define IVMRMixerControl_GetAlpha(This,dwStreamID,pAlpha)	\
    ( (This)->lpVtbl -> GetAlpha(This,dwStreamID,pAlpha) ) 

#define IVMRMixerControl_SetZOrder(This,dwStreamID,dwZ)	\
    ( (This)->lpVtbl -> SetZOrder(This,dwStreamID,dwZ) ) 

#define IVMRMixerControl_GetZOrder(This,dwStreamID,pZ)	\
    ( (This)->lpVtbl -> GetZOrder(This,dwStreamID,pZ) ) 

#define IVMRMixerControl_SetOutputRect(This,dwStreamID,pRect)	\
    ( (This)->lpVtbl -> SetOutputRect(This,dwStreamID,pRect) ) 

#define IVMRMixerControl_GetOutputRect(This,dwStreamID,pRect)	\
    ( (This)->lpVtbl -> GetOutputRect(This,dwStreamID,pRect) ) 

#define IVMRMixerControl_SetBackgroundClr(This,ClrBkg)	\
    ( (This)->lpVtbl -> SetBackgroundClr(This,ClrBkg) ) 

#define IVMRMixerControl_GetBackgroundClr(This,lpClrBkg)	\
    ( (This)->lpVtbl -> GetBackgroundClr(This,lpClrBkg) ) 

#define IVMRMixerControl_SetMixingPrefs(This,dwMixerPrefs)	\
    ( (This)->lpVtbl -> SetMixingPrefs(This,dwMixerPrefs) ) 

#define IVMRMixerControl_GetMixingPrefs(This,pdwMixerPrefs)	\
    ( (This)->lpVtbl -> GetMixingPrefs(This,pdwMixerPrefs) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMixerControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0128 */
/* [local] */ 

typedef struct tagVMRGUID
    {
    GUID *pGUID;
    GUID GUID;
    } 	VMRGUID;

typedef struct tagVMRMONITORINFO
    {
    VMRGUID guid;
    RECT rcMonitor;
    HMONITOR hMon;
    DWORD dwFlags;
    wchar_t szDevice[ 32 ];
    wchar_t szDescription[ 256 ];
    LARGE_INTEGER liDriverVersion;
    DWORD dwVendorId;
    DWORD dwDeviceId;
    DWORD dwSubSysId;
    DWORD dwRevision;
    } 	VMRMONITORINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0128_v0_0_s_ifspec;

#ifndef __IVMRMonitorConfig_INTERFACE_DEFINED__
#define __IVMRMonitorConfig_INTERFACE_DEFINED__

/* interface IVMRMonitorConfig */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRMonitorConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9cf0b1b6-fbaa-4b7f-88cf-cf1f130a0dce")
    IVMRMonitorConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMonitor( 
            /* [in] */ const VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMonitor( 
            /* [out] */ VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultMonitor( 
            /* [in] */ const VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultMonitor( 
            /* [out] */ VMRGUID *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableMonitors( 
            /* [size_is][out] */ VMRMONITORINFO *pInfo,
            /* [in] */ DWORD dwMaxInfoArraySize,
            /* [out] */ DWORD *pdwNumDevices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMonitorConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMonitorConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMonitorConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMonitorConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMonitor )( 
            IVMRMonitorConfig * This,
            /* [in] */ const VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetMonitor )( 
            IVMRMonitorConfig * This,
            /* [out] */ VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultMonitor )( 
            IVMRMonitorConfig * This,
            /* [in] */ const VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultMonitor )( 
            IVMRMonitorConfig * This,
            /* [out] */ VMRGUID *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableMonitors )( 
            IVMRMonitorConfig * This,
            /* [size_is][out] */ VMRMONITORINFO *pInfo,
            /* [in] */ DWORD dwMaxInfoArraySize,
            /* [out] */ DWORD *pdwNumDevices);
        
        END_INTERFACE
    } IVMRMonitorConfigVtbl;

    interface IVMRMonitorConfig
    {
        CONST_VTBL struct IVMRMonitorConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMonitorConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMonitorConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMonitorConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMonitorConfig_SetMonitor(This,pGUID)	\
    ( (This)->lpVtbl -> SetMonitor(This,pGUID) ) 

#define IVMRMonitorConfig_GetMonitor(This,pGUID)	\
    ( (This)->lpVtbl -> GetMonitor(This,pGUID) ) 

#define IVMRMonitorConfig_SetDefaultMonitor(This,pGUID)	\
    ( (This)->lpVtbl -> SetDefaultMonitor(This,pGUID) ) 

#define IVMRMonitorConfig_GetDefaultMonitor(This,pGUID)	\
    ( (This)->lpVtbl -> GetDefaultMonitor(This,pGUID) ) 

#define IVMRMonitorConfig_GetAvailableMonitors(This,pInfo,dwMaxInfoArraySize,pdwNumDevices)	\
    ( (This)->lpVtbl -> GetAvailableMonitors(This,pInfo,dwMaxInfoArraySize,pdwNumDevices) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMonitorConfig_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0129 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0129_0001
    {	RenderPrefs_RestrictToInitialMonitor	= 0,
	RenderPrefs_ForceOffscreen	= 0x1,
	RenderPrefs_ForceOverlays	= 0x2,
	RenderPrefs_AllowOverlays	= 0,
	RenderPrefs_AllowOffscreen	= 0,
	RenderPrefs_DoNotRenderColorKeyAndBorder	= 0x8,
	RenderPrefs_Reserved	= 0x10,
	RenderPrefs_PreferAGPMemWhenMixing	= 0x20,
	RenderPrefs_Mask	= 0x3f
    } 	VMRRenderPrefs;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0129_0002
    {	VMRMode_Windowed	= 0x1,
	VMRMode_Windowless	= 0x2,
	VMRMode_Renderless	= 0x4,
	VMRMode_Mask	= 0x7
    } 	VMRMode;


enum __MIDL___MIDL_itf_strmif_0000_0129_0003
    {	MAX_NUMBER_OF_STREAMS	= 16
    } ;


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0129_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0129_v0_0_s_ifspec;

#ifndef __IVMRFilterConfig_INTERFACE_DEFINED__
#define __IVMRFilterConfig_INTERFACE_DEFINED__

/* interface IVMRFilterConfig */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRFilterConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e5530c5-7034-48b4-bb46-0b8a6efc8e36")
    IVMRFilterConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetImageCompositor( 
            /* [in] */ IVMRImageCompositor *lpVMRImgCompositor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNumberOfStreams( 
            /* [in] */ DWORD dwMaxStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfStreams( 
            /* [out] */ DWORD *pdwMaxStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs( 
            /* [in] */ DWORD dwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs( 
            /* [out] */ DWORD *pdwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderingMode( 
            /* [in] */ DWORD Mode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingMode( 
            /* [out] */ DWORD *pMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRFilterConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRFilterConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRFilterConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRFilterConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetImageCompositor )( 
            IVMRFilterConfig * This,
            /* [in] */ IVMRImageCompositor *lpVMRImgCompositor);
        
        HRESULT ( STDMETHODCALLTYPE *SetNumberOfStreams )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD dwMaxStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfStreams )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pdwMaxStreams);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pdwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingMode )( 
            IVMRFilterConfig * This,
            /* [in] */ DWORD Mode);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingMode )( 
            IVMRFilterConfig * This,
            /* [out] */ DWORD *pMode);
        
        END_INTERFACE
    } IVMRFilterConfigVtbl;

    interface IVMRFilterConfig
    {
        CONST_VTBL struct IVMRFilterConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRFilterConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRFilterConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRFilterConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRFilterConfig_SetImageCompositor(This,lpVMRImgCompositor)	\
    ( (This)->lpVtbl -> SetImageCompositor(This,lpVMRImgCompositor) ) 

#define IVMRFilterConfig_SetNumberOfStreams(This,dwMaxStreams)	\
    ( (This)->lpVtbl -> SetNumberOfStreams(This,dwMaxStreams) ) 

#define IVMRFilterConfig_GetNumberOfStreams(This,pdwMaxStreams)	\
    ( (This)->lpVtbl -> GetNumberOfStreams(This,pdwMaxStreams) ) 

#define IVMRFilterConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags) ) 

#define IVMRFilterConfig_GetRenderingPrefs(This,pdwRenderFlags)	\
    ( (This)->lpVtbl -> GetRenderingPrefs(This,pdwRenderFlags) ) 

#define IVMRFilterConfig_SetRenderingMode(This,Mode)	\
    ( (This)->lpVtbl -> SetRenderingMode(This,Mode) ) 

#define IVMRFilterConfig_GetRenderingMode(This,pMode)	\
    ( (This)->lpVtbl -> GetRenderingMode(This,pMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRFilterConfig_INTERFACE_DEFINED__ */


#ifndef __IVMRAspectRatioControl_INTERFACE_DEFINED__
#define __IVMRAspectRatioControl_INTERFACE_DEFINED__

/* interface IVMRAspectRatioControl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRAspectRatioControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ede80b5c-bad6-4623-b537-65586c9f8dfd")
    IVMRAspectRatioControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAspectRatioMode( 
            /* [out] */ LPDWORD lpdwARMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAspectRatioMode( 
            /* [in] */ DWORD dwARMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRAspectRatioControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRAspectRatioControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRAspectRatioControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRAspectRatioControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAspectRatioMode )( 
            IVMRAspectRatioControl * This,
            /* [out] */ LPDWORD lpdwARMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetAspectRatioMode )( 
            IVMRAspectRatioControl * This,
            /* [in] */ DWORD dwARMode);
        
        END_INTERFACE
    } IVMRAspectRatioControlVtbl;

    interface IVMRAspectRatioControl
    {
        CONST_VTBL struct IVMRAspectRatioControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRAspectRatioControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRAspectRatioControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRAspectRatioControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRAspectRatioControl_GetAspectRatioMode(This,lpdwARMode)	\
    ( (This)->lpVtbl -> GetAspectRatioMode(This,lpdwARMode) ) 

#define IVMRAspectRatioControl_SetAspectRatioMode(This,dwARMode)	\
    ( (This)->lpVtbl -> SetAspectRatioMode(This,dwARMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRAspectRatioControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0131 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0131_0001
    {	DeinterlacePref_NextBest	= 0x1,
	DeinterlacePref_BOB	= 0x2,
	DeinterlacePref_Weave	= 0x4,
	DeinterlacePref_Mask	= 0x7
    } 	VMRDeinterlacePrefs;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_strmif_0000_0131_0002
    {	DeinterlaceTech_Unknown	= 0,
	DeinterlaceTech_BOBLineReplicate	= 0x1,
	DeinterlaceTech_BOBVerticalStretch	= 0x2,
	DeinterlaceTech_MedianFiltering	= 0x4,
	DeinterlaceTech_EdgeFiltering	= 0x10,
	DeinterlaceTech_FieldAdaptive	= 0x20,
	DeinterlaceTech_PixelAdaptive	= 0x40,
	DeinterlaceTech_MotionVectorSteered	= 0x80
    } 	VMRDeinterlaceTech;

typedef struct _VMRFrequency
    {
    DWORD dwNumerator;
    DWORD dwDenominator;
    } 	VMRFrequency;

typedef struct _VMRVideoDesc
    {
    DWORD dwSize;
    DWORD dwSampleWidth;
    DWORD dwSampleHeight;
    BOOL SingleFieldPerSample;
    DWORD dwFourCC;
    VMRFrequency InputSampleFreq;
    VMRFrequency OutputFrameFreq;
    } 	VMRVideoDesc;

typedef struct _VMRDeinterlaceCaps
    {
    DWORD dwSize;
    DWORD dwNumPreviousOutputFrames;
    DWORD dwNumForwardRefSamples;
    DWORD dwNumBackwardRefSamples;
    VMRDeinterlaceTech DeinterlaceTechnology;
    } 	VMRDeinterlaceCaps;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0131_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0131_v0_0_s_ifspec;

#ifndef __IVMRDeinterlaceControl_INTERFACE_DEFINED__
#define __IVMRDeinterlaceControl_INTERFACE_DEFINED__

/* interface IVMRDeinterlaceControl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRDeinterlaceControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bb057577-0db8-4e6a-87a7-1a8c9a505a0f")
    IVMRDeinterlaceControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberOfDeinterlaceModes( 
            /* [in] */ VMRVideoDesc *lpVideoDescription,
            /* [out][in] */ LPDWORD lpdwNumDeinterlaceModes,
            /* [out] */ LPGUID lpDeinterlaceModes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlaceModeCaps( 
            /* [in] */ LPGUID lpDeinterlaceMode,
            /* [in] */ VMRVideoDesc *lpVideoDescription,
            /* [out][in] */ VMRDeinterlaceCaps *lpDeinterlaceCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [in] */ LPGUID lpDeinterlaceMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeinterlacePrefs( 
            /* [out] */ LPDWORD lpdwDeinterlacePrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDeinterlacePrefs( 
            /* [in] */ DWORD dwDeinterlacePrefs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActualDeinterlaceMode( 
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRDeinterlaceControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRDeinterlaceControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRDeinterlaceControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberOfDeinterlaceModes )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ VMRVideoDesc *lpVideoDescription,
            /* [out][in] */ LPDWORD lpdwNumDeinterlaceModes,
            /* [out] */ LPGUID lpDeinterlaceModes);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlaceModeCaps )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ LPGUID lpDeinterlaceMode,
            /* [in] */ VMRVideoDesc *lpVideoDescription,
            /* [out][in] */ VMRDeinterlaceCaps *lpDeinterlaceCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlaceMode )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeinterlaceMode )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [in] */ LPGUID lpDeinterlaceMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeinterlacePrefs )( 
            IVMRDeinterlaceControl * This,
            /* [out] */ LPDWORD lpdwDeinterlacePrefs);
        
        HRESULT ( STDMETHODCALLTYPE *SetDeinterlacePrefs )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ DWORD dwDeinterlacePrefs);
        
        HRESULT ( STDMETHODCALLTYPE *GetActualDeinterlaceMode )( 
            IVMRDeinterlaceControl * This,
            /* [in] */ DWORD dwStreamID,
            /* [out] */ LPGUID lpDeinterlaceMode);
        
        END_INTERFACE
    } IVMRDeinterlaceControlVtbl;

    interface IVMRDeinterlaceControl
    {
        CONST_VTBL struct IVMRDeinterlaceControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRDeinterlaceControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRDeinterlaceControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRDeinterlaceControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRDeinterlaceControl_GetNumberOfDeinterlaceModes(This,lpVideoDescription,lpdwNumDeinterlaceModes,lpDeinterlaceModes)	\
    ( (This)->lpVtbl -> GetNumberOfDeinterlaceModes(This,lpVideoDescription,lpdwNumDeinterlaceModes,lpDeinterlaceModes) ) 

#define IVMRDeinterlaceControl_GetDeinterlaceModeCaps(This,lpDeinterlaceMode,lpVideoDescription,lpDeinterlaceCaps)	\
    ( (This)->lpVtbl -> GetDeinterlaceModeCaps(This,lpDeinterlaceMode,lpVideoDescription,lpDeinterlaceCaps) ) 

#define IVMRDeinterlaceControl_GetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    ( (This)->lpVtbl -> GetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode) ) 

#define IVMRDeinterlaceControl_SetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    ( (This)->lpVtbl -> SetDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode) ) 

#define IVMRDeinterlaceControl_GetDeinterlacePrefs(This,lpdwDeinterlacePrefs)	\
    ( (This)->lpVtbl -> GetDeinterlacePrefs(This,lpdwDeinterlacePrefs) ) 

#define IVMRDeinterlaceControl_SetDeinterlacePrefs(This,dwDeinterlacePrefs)	\
    ( (This)->lpVtbl -> SetDeinterlacePrefs(This,dwDeinterlacePrefs) ) 

#define IVMRDeinterlaceControl_GetActualDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode)	\
    ( (This)->lpVtbl -> GetActualDeinterlaceMode(This,dwStreamID,lpDeinterlaceMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRDeinterlaceControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0132 */
/* [local] */ 

typedef struct _VMRALPHABITMAP
    {
    DWORD dwFlags;
    HDC hdc;
    LPDIRECTDRAWSURFACE7 pDDS;
    RECT rSrc;
    NORMALIZEDRECT rDest;
    FLOAT fAlpha;
    COLORREF clrSrcKey;
    } 	VMRALPHABITMAP;

typedef struct _VMRALPHABITMAP *PVMRALPHABITMAP;

#define VMRBITMAP_DISABLE            0x00000001
#define VMRBITMAP_HDC                0x00000002
#define VMRBITMAP_ENTIREDDS          0x00000004
#define VMRBITMAP_SRCCOLORKEY        0x00000008
#define VMRBITMAP_SRCRECT            0x00000010


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0132_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0132_v0_0_s_ifspec;

#ifndef __IVMRMixerBitmap_INTERFACE_DEFINED__
#define __IVMRMixerBitmap_INTERFACE_DEFINED__

/* interface IVMRMixerBitmap */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRMixerBitmap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1E673275-0257-40aa-AF20-7C608D4A0428")
    IVMRMixerBitmap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetAlphaBitmap( 
            /* [in] */ const VMRALPHABITMAP *pBmpParms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateAlphaBitmapParameters( 
            /* [in] */ PVMRALPHABITMAP pBmpParms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAlphaBitmapParameters( 
            /* [out] */ PVMRALPHABITMAP pBmpParms) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRMixerBitmapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRMixerBitmap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRMixerBitmap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRMixerBitmap * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetAlphaBitmap )( 
            IVMRMixerBitmap * This,
            /* [in] */ const VMRALPHABITMAP *pBmpParms);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateAlphaBitmapParameters )( 
            IVMRMixerBitmap * This,
            /* [in] */ PVMRALPHABITMAP pBmpParms);
        
        HRESULT ( STDMETHODCALLTYPE *GetAlphaBitmapParameters )( 
            IVMRMixerBitmap * This,
            /* [out] */ PVMRALPHABITMAP pBmpParms);
        
        END_INTERFACE
    } IVMRMixerBitmapVtbl;

    interface IVMRMixerBitmap
    {
        CONST_VTBL struct IVMRMixerBitmapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRMixerBitmap_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRMixerBitmap_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRMixerBitmap_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRMixerBitmap_SetAlphaBitmap(This,pBmpParms)	\
    ( (This)->lpVtbl -> SetAlphaBitmap(This,pBmpParms) ) 

#define IVMRMixerBitmap_UpdateAlphaBitmapParameters(This,pBmpParms)	\
    ( (This)->lpVtbl -> UpdateAlphaBitmapParameters(This,pBmpParms) ) 

#define IVMRMixerBitmap_GetAlphaBitmapParameters(This,pBmpParms)	\
    ( (This)->lpVtbl -> GetAlphaBitmapParameters(This,pBmpParms) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRMixerBitmap_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0133 */
/* [local] */ 

typedef struct _VMRVIDEOSTREAMINFO
    {
    LPDIRECTDRAWSURFACE7 pddsVideoSurface;
    DWORD dwWidth;
    DWORD dwHeight;
    DWORD dwStrmID;
    FLOAT fAlpha;
    DDCOLORKEY ddClrKey;
    NORMALIZEDRECT rNormal;
    } 	VMRVIDEOSTREAMINFO;



extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0133_v0_0_s_ifspec;

#ifndef __IVMRImageCompositor_INTERFACE_DEFINED__
#define __IVMRImageCompositor_INTERFACE_DEFINED__

/* interface IVMRImageCompositor */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImageCompositor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7a4fb5af-479f-4074-bb40-ce6722e43c82")
    IVMRImageCompositor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitCompositionTarget( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TermCompositionTarget( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamMediaType( 
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompositeImage( 
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ DWORD dwClrBkGnd,
            /* [in] */ VMRVIDEOSTREAMINFO *pVideoStreamInfo,
            /* [in] */ UINT cStreams) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImageCompositorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImageCompositor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImageCompositor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImageCompositor * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitCompositionTarget )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget);
        
        HRESULT ( STDMETHODCALLTYPE *TermCompositionTarget )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamMediaType )( 
            IVMRImageCompositor * This,
            /* [in] */ DWORD dwStrmID,
            /* [in] */ AM_MEDIA_TYPE *pmt,
            /* [in] */ BOOL fTexture);
        
        HRESULT ( STDMETHODCALLTYPE *CompositeImage )( 
            IVMRImageCompositor * This,
            /* [in] */ IUnknown *pD3DDevice,
            /* [in] */ LPDIRECTDRAWSURFACE7 pddsRenderTarget,
            /* [in] */ AM_MEDIA_TYPE *pmtRenderTarget,
            /* [in] */ REFERENCE_TIME rtStart,
            /* [in] */ REFERENCE_TIME rtEnd,
            /* [in] */ DWORD dwClrBkGnd,
            /* [in] */ VMRVIDEOSTREAMINFO *pVideoStreamInfo,
            /* [in] */ UINT cStreams);
        
        END_INTERFACE
    } IVMRImageCompositorVtbl;

    interface IVMRImageCompositor
    {
        CONST_VTBL struct IVMRImageCompositorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImageCompositor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImageCompositor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImageCompositor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImageCompositor_InitCompositionTarget(This,pD3DDevice,pddsRenderTarget)	\
    ( (This)->lpVtbl -> InitCompositionTarget(This,pD3DDevice,pddsRenderTarget) ) 

#define IVMRImageCompositor_TermCompositionTarget(This,pD3DDevice,pddsRenderTarget)	\
    ( (This)->lpVtbl -> TermCompositionTarget(This,pD3DDevice,pddsRenderTarget) ) 

#define IVMRImageCompositor_SetStreamMediaType(This,dwStrmID,pmt,fTexture)	\
    ( (This)->lpVtbl -> SetStreamMediaType(This,dwStrmID,pmt,fTexture) ) 

#define IVMRImageCompositor_CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams)	\
    ( (This)->lpVtbl -> CompositeImage(This,pD3DDevice,pddsRenderTarget,pmtRenderTarget,rtStart,rtEnd,dwClrBkGnd,pVideoStreamInfo,cStreams) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImageCompositor_INTERFACE_DEFINED__ */


#ifndef __IVMRVideoStreamControl_INTERFACE_DEFINED__
#define __IVMRVideoStreamControl_INTERFACE_DEFINED__

/* interface IVMRVideoStreamControl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IVMRVideoStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("058d1f11-2a54-4bef-bd54-df706626b727")
    IVMRVideoStreamControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            /* [in] */ LPDDCOLORKEY lpClrKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            /* [out] */ LPDDCOLORKEY lpClrKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStreamActiveState( 
            /* [in] */ BOOL fActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamActiveState( 
            /* [out] */ BOOL *lpfActive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRVideoStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRVideoStreamControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRVideoStreamControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRVideoStreamControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorKey )( 
            IVMRVideoStreamControl * This,
            /* [in] */ LPDDCOLORKEY lpClrKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetColorKey )( 
            IVMRVideoStreamControl * This,
            /* [out] */ LPDDCOLORKEY lpClrKey);
        
        HRESULT ( STDMETHODCALLTYPE *SetStreamActiveState )( 
            IVMRVideoStreamControl * This,
            /* [in] */ BOOL fActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamActiveState )( 
            IVMRVideoStreamControl * This,
            /* [out] */ BOOL *lpfActive);
        
        END_INTERFACE
    } IVMRVideoStreamControlVtbl;

    interface IVMRVideoStreamControl
    {
        CONST_VTBL struct IVMRVideoStreamControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRVideoStreamControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRVideoStreamControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRVideoStreamControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRVideoStreamControl_SetColorKey(This,lpClrKey)	\
    ( (This)->lpVtbl -> SetColorKey(This,lpClrKey) ) 

#define IVMRVideoStreamControl_GetColorKey(This,lpClrKey)	\
    ( (This)->lpVtbl -> GetColorKey(This,lpClrKey) ) 

#define IVMRVideoStreamControl_SetStreamActiveState(This,fActive)	\
    ( (This)->lpVtbl -> SetStreamActiveState(This,fActive) ) 

#define IVMRVideoStreamControl_GetStreamActiveState(This,lpfActive)	\
    ( (This)->lpVtbl -> GetStreamActiveState(This,lpfActive) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRVideoStreamControl_INTERFACE_DEFINED__ */


#ifndef __IVMRSurface_INTERFACE_DEFINED__
#define __IVMRSurface_INTERFACE_DEFINED__

/* interface IVMRSurface */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a9849bbe-9ec8-4263-b764-62730f0d15d0")
    IVMRSurface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSurfaceLocked( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurface( 
            /* [out] */ BYTE **lpSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockSurface( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRSurface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRSurface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSurfaceLocked )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockSurface )( 
            IVMRSurface * This,
            /* [out] */ BYTE **lpSurface);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockSurface )( 
            IVMRSurface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IVMRSurface * This,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lplpSurface);
        
        END_INTERFACE
    } IVMRSurfaceVtbl;

    interface IVMRSurface
    {
        CONST_VTBL struct IVMRSurfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRSurface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRSurface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRSurface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRSurface_IsSurfaceLocked(This)	\
    ( (This)->lpVtbl -> IsSurfaceLocked(This) ) 

#define IVMRSurface_LockSurface(This,lpSurface)	\
    ( (This)->lpVtbl -> LockSurface(This,lpSurface) ) 

#define IVMRSurface_UnlockSurface(This)	\
    ( (This)->lpVtbl -> UnlockSurface(This) ) 

#define IVMRSurface_GetSurface(This,lplpSurface)	\
    ( (This)->lpVtbl -> GetSurface(This,lplpSurface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRSurface_INTERFACE_DEFINED__ */


#ifndef __IVMRImagePresenterConfig_INTERFACE_DEFINED__
#define __IVMRImagePresenterConfig_INTERFACE_DEFINED__

/* interface IVMRImagePresenterConfig */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenterConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9f3a1c85-8555-49ba-935f-be5b5b29d178")
    IVMRImagePresenterConfig : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRenderingPrefs( 
            /* [in] */ DWORD dwRenderFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderingPrefs( 
            /* [out] */ DWORD *dwRenderFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenterConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenterConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenterConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRImagePresenterConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRImagePresenterConfig * This,
            /* [out] */ DWORD *dwRenderFlags);
        
        END_INTERFACE
    } IVMRImagePresenterConfigVtbl;

    interface IVMRImagePresenterConfig
    {
        CONST_VTBL struct IVMRImagePresenterConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenterConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImagePresenterConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImagePresenterConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImagePresenterConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags) ) 

#define IVMRImagePresenterConfig_GetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> GetRenderingPrefs(This,dwRenderFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImagePresenterConfig_INTERFACE_DEFINED__ */


#ifndef __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__
#define __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__

/* interface IVMRImagePresenterExclModeConfig */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVMRImagePresenterExclModeConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6f7ce40-4673-44f1-8f77-5499d68cb4ea")
    IVMRImagePresenterExclModeConfig : public IVMRImagePresenterConfig
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetXlcModeDDObjAndPrimarySurface( 
            /* [in] */ LPDIRECTDRAW7 lpDDObj,
            /* [in] */ LPDIRECTDRAWSURFACE7 lpPrimarySurf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXlcModeDDObjAndPrimarySurface( 
            /* [out] */ LPDIRECTDRAW7 *lpDDObj,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lpPrimarySurf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVMRImagePresenterExclModeConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVMRImagePresenterExclModeConfig * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVMRImagePresenterExclModeConfig * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderingPrefs )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ DWORD dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderingPrefs )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [out] */ DWORD *dwRenderFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetXlcModeDDObjAndPrimarySurface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [in] */ LPDIRECTDRAW7 lpDDObj,
            /* [in] */ LPDIRECTDRAWSURFACE7 lpPrimarySurf);
        
        HRESULT ( STDMETHODCALLTYPE *GetXlcModeDDObjAndPrimarySurface )( 
            IVMRImagePresenterExclModeConfig * This,
            /* [out] */ LPDIRECTDRAW7 *lpDDObj,
            /* [out] */ LPDIRECTDRAWSURFACE7 *lpPrimarySurf);
        
        END_INTERFACE
    } IVMRImagePresenterExclModeConfigVtbl;

    interface IVMRImagePresenterExclModeConfig
    {
        CONST_VTBL struct IVMRImagePresenterExclModeConfigVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVMRImagePresenterExclModeConfig_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVMRImagePresenterExclModeConfig_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVMRImagePresenterExclModeConfig_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVMRImagePresenterExclModeConfig_SetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> SetRenderingPrefs(This,dwRenderFlags) ) 

#define IVMRImagePresenterExclModeConfig_GetRenderingPrefs(This,dwRenderFlags)	\
    ( (This)->lpVtbl -> GetRenderingPrefs(This,dwRenderFlags) ) 


#define IVMRImagePresenterExclModeConfig_SetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf)	\
    ( (This)->lpVtbl -> SetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf) ) 

#define IVMRImagePresenterExclModeConfig_GetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf)	\
    ( (This)->lpVtbl -> GetXlcModeDDObjAndPrimarySurface(This,lpDDObj,lpPrimarySurf) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVMRImagePresenterExclModeConfig_INTERFACE_DEFINED__ */


#ifndef __IVPManager_INTERFACE_DEFINED__
#define __IVPManager_INTERFACE_DEFINED__

/* interface IVPManager */
/* [unique][helpstring][uuid][local][object][local] */ 


EXTERN_C const IID IID_IVPManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aac18c18-e186-46d2-825d-a1f8dc8e395a")
    IVPManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetVideoPortIndex( 
            /* [in] */ DWORD dwVideoPortIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVideoPortIndex( 
            /* [out] */ DWORD *pdwVideoPortIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVPManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVPManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVPManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVPManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetVideoPortIndex )( 
            IVPManager * This,
            /* [in] */ DWORD dwVideoPortIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetVideoPortIndex )( 
            IVPManager * This,
            /* [out] */ DWORD *pdwVideoPortIndex);
        
        END_INTERFACE
    } IVPManagerVtbl;

    interface IVPManager
    {
        CONST_VTBL struct IVPManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVPManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVPManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVPManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVPManager_SetVideoPortIndex(This,dwVideoPortIndex)	\
    ( (This)->lpVtbl -> SetVideoPortIndex(This,dwVideoPortIndex) ) 

#define IVPManager_GetVideoPortIndex(This,pdwVideoPortIndex)	\
    ( (This)->lpVtbl -> GetVideoPortIndex(This,pdwVideoPortIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVPManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_strmif_0000_0139 */
/* [local] */ 

// Restore the previous setting for C4201 compiler warning
#pragma warning(pop)


extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0139_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_strmif_0000_0139_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\SubAuth.h ===
/*++ BUILD Version: 0005     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    subauth.h

Abstract:

    This module defines types and macros for Subauthentication Packages.

Revision History:

--*/

#ifndef _NTSUBAUTH_
#define _NTSUBAUTH_

#ifdef __cplusplus
extern "C" {
#endif

#if (!defined(_NTDEF_)) && (!defined(_NTSECAPI_))
typedef LONG NTSTATUS, *PNTSTATUS;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING, *PSTRING;
#endif

#ifndef _NTDEF_

typedef struct _OLD_LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} OLD_LARGE_INTEGER, *POLD_LARGE_INTEGER;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#endif

#ifndef _NTSAM_SAM_HANDLE_               
typedef PVOID SAM_HANDLE, *PSAM_HANDLE;  
#define _NTSAM_SAM_HANDLE_               
#endif                                   
#ifndef _NTSAM_USER_ACCOUNT_FLAGS_

//
// User account control flags...
//

#define USER_ACCOUNT_DISABLED                       (0x00000001)
#define USER_HOME_DIRECTORY_REQUIRED                (0x00000002)
#define USER_PASSWORD_NOT_REQUIRED                  (0x00000004)
#define USER_TEMP_DUPLICATE_ACCOUNT                 (0x00000008)
#define USER_NORMAL_ACCOUNT                         (0x00000010)
#define USER_MNS_LOGON_ACCOUNT                      (0x00000020)
#define USER_INTERDOMAIN_TRUST_ACCOUNT              (0x00000040)
#define USER_WORKSTATION_TRUST_ACCOUNT              (0x00000080)
#define USER_SERVER_TRUST_ACCOUNT                   (0x00000100)
#define USER_DONT_EXPIRE_PASSWORD                   (0x00000200)
#define USER_ACCOUNT_AUTO_LOCKED                    (0x00000400)
#define USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED        (0x00000800)
#define USER_SMARTCARD_REQUIRED                     (0x00001000)
#define USER_TRUSTED_FOR_DELEGATION                 (0x00002000)
#define USER_NOT_DELEGATED                          (0x00004000)
#define USER_USE_DES_KEY_ONLY                       (0x00008000)
#define USER_DONT_REQUIRE_PREAUTH                   (0x00010000)
#define USER_PASSWORD_EXPIRED                       (0x00020000)
#define USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION (0x00040000)
#define USER_NO_AUTH_DATA_REQUIRED                  (0x00080000)
#define USER_PARTIAL_SECRETS_ACCOUNT                (0x00100000)
#define USER_USE_AES_KEYS                           (0x00200000)
#define NEXT_FREE_ACCOUNT_CONTROL_BIT (USER_USE_AES_KEYS << 1)

#define USER_MACHINE_ACCOUNT_MASK      \
            ( USER_INTERDOMAIN_TRUST_ACCOUNT |\
              USER_WORKSTATION_TRUST_ACCOUNT |\
              USER_SERVER_TRUST_ACCOUNT)

#define USER_ACCOUNT_TYPE_MASK         \
            ( USER_TEMP_DUPLICATE_ACCOUNT |\
              USER_NORMAL_ACCOUNT |\
              USER_MACHINE_ACCOUNT_MASK )

#define USER_COMPUTED_ACCOUNT_CONTROL_BITS  \
            (USER_ACCOUNT_AUTO_LOCKED |     \
             USER_PASSWORD_EXPIRED      )



//
// Logon times may be expressed in day, hour, or minute granularity.
//
//              Days per week    = 7
//              Hours per week   = 168
//              Minutes per week = 10080
//

#define SAM_DAYS_PER_WEEK    (7)
#define SAM_HOURS_PER_WEEK   (24 * SAM_DAYS_PER_WEEK)
#define SAM_MINUTES_PER_WEEK (60 * SAM_HOURS_PER_WEEK)

typedef struct _LOGON_HOURS {

    USHORT UnitsPerWeek;

    //
    // UnitsPerWeek is the number of equal length time units the week is
    // divided into.  This value is used to compute the length of the bit
    // string in logon_hours.  Must be less than or equal to
    // SAM_UNITS_PER_WEEK (10080) for this release.
    //
    // LogonHours is a bit map of valid logon times.  Each bit represents
    // a unique division in a week.  The largest bit map supported is 1260
    // bytes (10080 bits), which represents minutes per week.  In this case
    // the first bit (bit 0, byte 0) is Sunday, 00:00:00 - 00-00:59; bit 1,
    // byte 0 is Sunday, 00:01:00 - 00:01:59, etc.  A NULL pointer means
    // DONT_CHANGE for SamSetInformationUser() calls.
    //

    PUCHAR LogonHours;

} LOGON_HOURS, *PLOGON_HOURS;

typedef struct _SR_SECURITY_DESCRIPTOR {
    ULONG Length;
    PUCHAR SecurityDescriptor;
} SR_SECURITY_DESCRIPTOR, *PSR_SECURITY_DESCRIPTOR;

#define _NTSAM_USER_ACCOUNT_FLAG_
#endif
#ifndef _NTSAM_USER_ALL_INFO_
#include "pshpack4.h"
typedef struct _USER_ALL_INFORMATION {
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    UNICODE_STRING UserComment;
    UNICODE_STRING Parameters;
    UNICODE_STRING LmPassword;
    UNICODE_STRING NtPassword;
    UNICODE_STRING PrivateData;
    SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
} USER_ALL_INFORMATION,  *PUSER_ALL_INFORMATION;
#include "poppack.h"
#define _NTSAM_USER_ALL_INFO_
#endif
#ifndef _NTSAM_SAM_USER_PARMS_                 
#define USER_ALL_PARAMETERS         0x00200000 
#define _NTSAM_SAM_USER_PARMS_                 
#endif                                         

#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;

typedef enum _NETLOGON_LOGON_INFO_CLASS {
    NetlogonInteractiveInformation = 1,
    NetlogonNetworkInformation,
    NetlogonServiceInformation,
    NetlogonGenericInformation,
    NetlogonInteractiveTransitiveInformation,
    NetlogonNetworkTransitiveInformation,
    NetlogonServiceTransitiveInformation
} NETLOGON_LOGON_INFO_CLASS;

typedef struct _NETLOGON_LOGON_IDENTITY_INFO {
    UNICODE_STRING LogonDomainName;
    ULONG ParameterControl;
    OLD_LARGE_INTEGER  LogonId;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
} NETLOGON_LOGON_IDENTITY_INFO,
 *PNETLOGON_LOGON_IDENTITY_INFO;

typedef struct _NETLOGON_INTERACTIVE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_INTERACTIVE_INFO,
 *PNETLOGON_INTERACTIVE_INFO;

typedef struct _NETLOGON_SERVICE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_SERVICE_INFO, *PNETLOGON_SERVICE_INFO;

typedef struct _NETLOGON_NETWORK_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_CHALLENGE LmChallenge;
    STRING NtChallengeResponse;
    STRING LmChallengeResponse;
} NETLOGON_NETWORK_INFO, *PNETLOGON_NETWORK_INFO;

typedef struct _NETLOGON_GENERIC_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    UNICODE_STRING PackageName;
    ULONG DataLength;
#ifdef MIDL_PASS
    [size_is(DataLength)]
#endif
    PUCHAR LogonData;
} NETLOGON_GENERIC_INFO, *PNETLOGON_GENERIC_INFO;


// Values for Flags
#define MSV1_0_PASSTHRU     0x01
#define MSV1_0_GUEST_LOGON  0x02

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

typedef struct _MSV1_0_VALIDATION_INFO {
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickoffTime;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
    USER_SESSION_KEY SessionKey;
    BOOLEAN Authoritative;
    ULONG UserFlags;
    ULONG WhichFields;
    ULONG UserId;
} MSV1_0_VALIDATION_INFO, *PMSV1_0_VALIDATION_INFO;

// values for WhichFields

#define MSV1_0_VALIDATION_LOGOFF_TIME          0x00000001
#define MSV1_0_VALIDATION_KICKOFF_TIME         0x00000002
#define MSV1_0_VALIDATION_LOGON_SERVER         0x00000004
#define MSV1_0_VALIDATION_LOGON_DOMAIN         0x00000008
#define MSV1_0_VALIDATION_SESSION_KEY          0x00000010
#define MSV1_0_VALIDATION_USER_FLAGS           0x00000020
#define MSV1_0_VALIDATION_USER_ID              0x00000040

// legal values for ActionsPerformed
#define MSV1_0_SUBAUTH_ACCOUNT_DISABLED        0x00000001
#define MSV1_0_SUBAUTH_PASSWORD                0x00000002
#define MSV1_0_SUBAUTH_WORKSTATIONS            0x00000004
#define MSV1_0_SUBAUTH_LOGON_HOURS             0x00000008
#define MSV1_0_SUBAUTH_ACCOUNT_EXPIRY          0x00000010
#define MSV1_0_SUBAUTH_PASSWORD_EXPIRY         0x00000020
#define MSV1_0_SUBAUTH_ACCOUNT_TYPE            0x00000040
#define MSV1_0_SUBAUTH_LOCKOUT                 0x00000080

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineGeneric(
    IN PVOID SubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PULONG ReturnBufferLength,
    OUT PVOID *ReturnBuffer
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationFilter(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) 
#define STATUS_INVALID_INFO_CLASS        ((NTSTATUS)0xC0000003L)    
#define STATUS_NO_SUCH_USER              ((NTSTATUS)0xC0000064L)     
#define STATUS_WRONG_PASSWORD            ((NTSTATUS)0xC000006AL)     
#define STATUS_PASSWORD_RESTRICTION      ((NTSTATUS)0xC000006CL)     
#define STATUS_LOGON_FAILURE             ((NTSTATUS)0xC000006DL)     
#define STATUS_ACCOUNT_RESTRICTION       ((NTSTATUS)0xC000006EL)     
#define STATUS_INVALID_LOGON_HOURS       ((NTSTATUS)0xC000006FL)     
#define STATUS_INVALID_WORKSTATION       ((NTSTATUS)0xC0000070L)     
#define STATUS_PASSWORD_EXPIRED          ((NTSTATUS)0xC0000071L)     
#define STATUS_ACCOUNT_DISABLED          ((NTSTATUS)0xC0000072L)     
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     
#define STATUS_ACCOUNT_EXPIRED           ((NTSTATUS)0xC0000193L)    
#define STATUS_PASSWORD_MUST_CHANGE      ((NTSTATUS)0xC0000224L)    
#define STATUS_ACCOUNT_LOCKED_OUT        ((NTSTATUS)0xC0000234L)    
#ifdef __cplusplus
}
#endif

#endif /* _NTSUBAUTH_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\SubsMgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for subsmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __subsmgr_h__
#define __subsmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumItemProperties_FWD_DEFINED__
#define __IEnumItemProperties_FWD_DEFINED__
typedef interface IEnumItemProperties IEnumItemProperties;
#endif 	/* __IEnumItemProperties_FWD_DEFINED__ */


#ifndef __ISubscriptionItem_FWD_DEFINED__
#define __ISubscriptionItem_FWD_DEFINED__
typedef interface ISubscriptionItem ISubscriptionItem;
#endif 	/* __ISubscriptionItem_FWD_DEFINED__ */


#ifndef __IEnumSubscription_FWD_DEFINED__
#define __IEnumSubscription_FWD_DEFINED__
typedef interface IEnumSubscription IEnumSubscription;
#endif 	/* __IEnumSubscription_FWD_DEFINED__ */


#ifndef __ISubscriptionMgr_FWD_DEFINED__
#define __ISubscriptionMgr_FWD_DEFINED__
typedef interface ISubscriptionMgr ISubscriptionMgr;
#endif 	/* __ISubscriptionMgr_FWD_DEFINED__ */


#ifndef __ISubscriptionMgr2_FWD_DEFINED__
#define __ISubscriptionMgr2_FWD_DEFINED__
typedef interface ISubscriptionMgr2 ISubscriptionMgr2;
#endif 	/* __ISubscriptionMgr2_FWD_DEFINED__ */


#ifndef __SubscriptionMgr_FWD_DEFINED__
#define __SubscriptionMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class SubscriptionMgr SubscriptionMgr;
#else
typedef struct SubscriptionMgr SubscriptionMgr;
#endif /* __cplusplus */

#endif 	/* __SubscriptionMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_subsmgr_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// subsmgr.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Channel Manager Interfaces.

typedef GUID SUBSCRIPTIONCOOKIE;



extern RPC_IF_HANDLE __MIDL_itf_subsmgr_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_subsmgr_0000_0000_v0_0_s_ifspec;

#ifndef __IEnumItemProperties_INTERFACE_DEFINED__
#define __IEnumItemProperties_INTERFACE_DEFINED__

/* interface IEnumItemProperties */
/* [object][helpstring][uuid] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumItemProperties *LPENUMITEMPROPERTIES;

typedef struct _tagITEMPROP
    {
    VARIANT variantValue;
    LPWSTR pwszName;
    } 	ITEMPROP;

typedef struct _tagITEMPROP *LPITEMPROP;


EXTERN_C const IID IID_IEnumItemProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F72C8D96-6DBD-11d1-A1E8-00C04FC2FBE1")
    IEnumItemProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ITEMPROP *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumItemProperties **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pnCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumItemPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumItemProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumItemProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumItemProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumItemProperties * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ITEMPROP *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumItemProperties * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumItemProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumItemProperties * This,
            /* [out] */ __RPC__deref_out_opt IEnumItemProperties **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumItemProperties * This,
            /* [out] */ __RPC__out ULONG *pnCount);
        
        END_INTERFACE
    } IEnumItemPropertiesVtbl;

    interface IEnumItemProperties
    {
        CONST_VTBL struct IEnumItemPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumItemProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumItemProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumItemProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumItemProperties_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumItemProperties_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumItemProperties_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumItemProperties_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumItemProperties_GetCount(This,pnCount)	\
    ( (This)->lpVtbl -> GetCount(This,pnCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumItemProperties_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_subsmgr_0000_0001 */
/* [local] */ 

//  Subscription item flag values
//  Temporary subscription item
#define SI_TEMPORARY         0x80000000


extern RPC_IF_HANDLE __MIDL_itf_subsmgr_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_subsmgr_0000_0001_v0_0_s_ifspec;

#ifndef __ISubscriptionItem_INTERFACE_DEFINED__
#define __ISubscriptionItem_INTERFACE_DEFINED__

/* interface ISubscriptionItem */
/* [object][helpstring][uuid] */ 

typedef /* [unique] */  __RPC_unique_pointer ISubscriptionItem *LPSUBSCRIPTIONITEM;

//  SUBSCRIPTIONITEMINFO flags                               
//  To specify that an item should only run on user idle     
//  use TASK_FLAG_START_ONLY_IF_IDLE                         
typedef struct tagSUBSCRIPTIONITEMINFO
    {
    ULONG cbSize;
    DWORD dwFlags;
    DWORD dwPriority;
    SUBSCRIPTIONCOOKIE ScheduleGroup;
    CLSID clsidAgent;
    } 	SUBSCRIPTIONITEMINFO;


EXTERN_C const IID IID_ISubscriptionItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A97559F8-6C4A-11d1-A1E8-00C04FC2FBE1")
    ISubscriptionItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCookie( 
            /* [out] */ __RPC__out SUBSCRIPTIONCOOKIE *pCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubscriptionItemInfo( 
            /* [out] */ __RPC__out SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSubscriptionItemInfo( 
            /* [in] */ __RPC__in const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadProperties( 
            ULONG nCount,
            /* [size_is][in] */ __RPC__in_ecount_full(nCount) const LPCWSTR rgwszName[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(nCount) VARIANT rgValue[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteProperties( 
            ULONG nCount,
            /* [size_is][in] */ __RPC__in_ecount_full(nCount) const LPCWSTR rgwszName[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(nCount) const VARIANT rgValue[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumProperties( 
            /* [out] */ __RPC__deref_out_opt IEnumItemProperties **ppEnumItemProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyChanged( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISubscriptionItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISubscriptionItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISubscriptionItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISubscriptionItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCookie )( 
            ISubscriptionItem * This,
            /* [out] */ __RPC__out SUBSCRIPTIONCOOKIE *pCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubscriptionItemInfo )( 
            ISubscriptionItem * This,
            /* [out] */ __RPC__out SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetSubscriptionItemInfo )( 
            ISubscriptionItem * This,
            /* [in] */ __RPC__in const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ReadProperties )( 
            ISubscriptionItem * This,
            ULONG nCount,
            /* [size_is][in] */ __RPC__in_ecount_full(nCount) const LPCWSTR rgwszName[  ],
            /* [size_is][out] */ __RPC__out_ecount_full(nCount) VARIANT rgValue[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *WriteProperties )( 
            ISubscriptionItem * This,
            ULONG nCount,
            /* [size_is][in] */ __RPC__in_ecount_full(nCount) const LPCWSTR rgwszName[  ],
            /* [size_is][in] */ __RPC__in_ecount_full(nCount) const VARIANT rgValue[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            ISubscriptionItem * This,
            /* [out] */ __RPC__deref_out_opt IEnumItemProperties **ppEnumItemProperties);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyChanged )( 
            ISubscriptionItem * This);
        
        END_INTERFACE
    } ISubscriptionItemVtbl;

    interface ISubscriptionItem
    {
        CONST_VTBL struct ISubscriptionItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISubscriptionItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISubscriptionItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISubscriptionItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISubscriptionItem_GetCookie(This,pCookie)	\
    ( (This)->lpVtbl -> GetCookie(This,pCookie) ) 

#define ISubscriptionItem_GetSubscriptionItemInfo(This,pSubscriptionItemInfo)	\
    ( (This)->lpVtbl -> GetSubscriptionItemInfo(This,pSubscriptionItemInfo) ) 

#define ISubscriptionItem_SetSubscriptionItemInfo(This,pSubscriptionItemInfo)	\
    ( (This)->lpVtbl -> SetSubscriptionItemInfo(This,pSubscriptionItemInfo) ) 

#define ISubscriptionItem_ReadProperties(This,nCount,rgwszName,rgValue)	\
    ( (This)->lpVtbl -> ReadProperties(This,nCount,rgwszName,rgValue) ) 

#define ISubscriptionItem_WriteProperties(This,nCount,rgwszName,rgValue)	\
    ( (This)->lpVtbl -> WriteProperties(This,nCount,rgwszName,rgValue) ) 

#define ISubscriptionItem_EnumProperties(This,ppEnumItemProperties)	\
    ( (This)->lpVtbl -> EnumProperties(This,ppEnumItemProperties) ) 

#define ISubscriptionItem_NotifyChanged(This)	\
    ( (This)->lpVtbl -> NotifyChanged(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISubscriptionItem_INTERFACE_DEFINED__ */


#ifndef __IEnumSubscription_INTERFACE_DEFINED__
#define __IEnumSubscription_INTERFACE_DEFINED__

/* interface IEnumSubscription */
/* [object][helpstring][uuid] */ 

typedef /* [unique] */  __RPC_unique_pointer IEnumSubscription *LPENUMSUBSCRIPTION;


EXTERN_C const IID IID_IEnumSubscription;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F72C8D97-6DBD-11d1-A1E8-00C04FC2FBE1")
    IEnumSubscription : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) SUBSCRIPTIONCOOKIE *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSubscription **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out ULONG *pnCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSubscriptionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSubscription * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSubscription * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSubscription * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSubscription * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) SUBSCRIPTIONCOOKIE *rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSubscription * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSubscription * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSubscription * This,
            /* [out] */ __RPC__deref_out_opt IEnumSubscription **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumSubscription * This,
            /* [out] */ __RPC__out ULONG *pnCount);
        
        END_INTERFACE
    } IEnumSubscriptionVtbl;

    interface IEnumSubscription
    {
        CONST_VTBL struct IEnumSubscriptionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSubscription_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSubscription_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSubscription_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSubscription_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSubscription_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSubscription_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSubscription_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#define IEnumSubscription_GetCount(This,pnCount)	\
    ( (This)->lpVtbl -> GetCount(This,pnCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSubscription_INTERFACE_DEFINED__ */



#ifndef __SubscriptionMgr_LIBRARY_DEFINED__
#define __SubscriptionMgr_LIBRARY_DEFINED__

/* library SubscriptionMgr */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_SubscriptionMgr;

#ifndef __ISubscriptionMgr_INTERFACE_DEFINED__
#define __ISubscriptionMgr_INTERFACE_DEFINED__

/* interface ISubscriptionMgr */
/* [object][helpstring][uuid] */ 

typedef 
enum SUBSCRIPTIONTYPE
    {	SUBSTYPE_URL	= 0,
	SUBSTYPE_CHANNEL	= 1,
	SUBSTYPE_DESKTOPURL	= 2,
	SUBSTYPE_EXTERNAL	= 3,
	SUBSTYPE_DESKTOPCHANNEL	= 4
    } 	SUBSCRIPTIONTYPE;

typedef 
enum SUBSCRIPTIONINFOFLAGS
    {	SUBSINFO_SCHEDULE	= 0x1,
	SUBSINFO_RECURSE	= 0x2,
	SUBSINFO_WEBCRAWL	= 0x4,
	SUBSINFO_MAILNOT	= 0x8,
	SUBSINFO_MAXSIZEKB	= 0x10,
	SUBSINFO_USER	= 0x20,
	SUBSINFO_PASSWORD	= 0x40,
	SUBSINFO_TASKFLAGS	= 0x100,
	SUBSINFO_GLEAM	= 0x200,
	SUBSINFO_CHANGESONLY	= 0x400,
	SUBSINFO_CHANNELFLAGS	= 0x800,
	SUBSINFO_FRIENDLYNAME	= 0x2000,
	SUBSINFO_NEEDPASSWORD	= 0x4000,
	SUBSINFO_TYPE	= 0x8000
    } 	SUBSCRIPTIONINFOFLAGS;

#define SUBSINFO_ALLFLAGS      0x0000EF7F
typedef 
enum CREATESUBSCRIPTIONFLAGS
    {	CREATESUBS_ADDTOFAVORITES	= 0x1,
	CREATESUBS_FROMFAVORITES	= 0x2,
	CREATESUBS_NOUI	= 0x4,
	CREATESUBS_NOSAVE	= 0x8,
	CREATESUBS_SOFTWAREUPDATE	= 0x10
    } 	CREATESUBSCRIPTIONFLAGS;

typedef 
enum SUBSCRIPTIONSCHEDULE
    {	SUBSSCHED_AUTO	= 0,
	SUBSSCHED_DAILY	= 1,
	SUBSSCHED_WEEKLY	= 2,
	SUBSSCHED_CUSTOM	= 3,
	SUBSSCHED_MANUAL	= 4
    } 	SUBSCRIPTIONSCHEDULE;

typedef struct _tagSubscriptionInfo
    {
    DWORD cbSize;
    DWORD fUpdateFlags;
    SUBSCRIPTIONSCHEDULE schedule;
    CLSID customGroupCookie;
    LPVOID pTrigger;
    DWORD dwRecurseLevels;
    DWORD fWebcrawlerFlags;
    BOOL bMailNotification;
    BOOL bGleam;
    BOOL bChangesOnly;
    BOOL bNeedPassword;
    DWORD fChannelFlags;
    BSTR bstrUserName;
    BSTR bstrPassword;
    BSTR bstrFriendlyName;
    DWORD dwMaxSizeKB;
    SUBSCRIPTIONTYPE subType;
    DWORD fTaskFlags;
    DWORD dwReserved;
    } 	SUBSCRIPTIONINFO;

typedef struct _tagSubscriptionInfo *LPSUBSCRIPTIONINFO;

typedef struct _tagSubscriptionInfo *PSUBSCRIPTIONINFO;


EXTERN_C const IID IID_ISubscriptionMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("085FB2C0-0DF8-11d1-8F4B-00A0C905413F")
    ISubscriptionMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeleteSubscription( 
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateSubscription( 
            /* [in] */ __RPC__in LPCWSTR pwszURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSubscribed( 
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [out] */ __RPC__out BOOL *pfSubscribed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubscriptionInfo( 
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [out] */ __RPC__out SUBSCRIPTIONINFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultInfo( 
            /* [in] */ SUBSCRIPTIONTYPE subType,
            /* [out] */ __RPC__out SUBSCRIPTIONINFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSubscriptionProperties( 
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSubscription( 
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in LPCWSTR pwszFriendlyName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ SUBSCRIPTIONTYPE subsType,
            /* [out][in] */ __RPC__inout SUBSCRIPTIONINFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISubscriptionMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISubscriptionMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISubscriptionMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISubscriptionMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteSubscription )( 
            ISubscriptionMgr * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateSubscription )( 
            ISubscriptionMgr * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateAll )( 
            ISubscriptionMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSubscribed )( 
            ISubscriptionMgr * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [out] */ __RPC__out BOOL *pfSubscribed);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubscriptionInfo )( 
            ISubscriptionMgr * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [out] */ __RPC__out SUBSCRIPTIONINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultInfo )( 
            ISubscriptionMgr * This,
            /* [in] */ SUBSCRIPTIONTYPE subType,
            /* [out] */ __RPC__out SUBSCRIPTIONINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ShowSubscriptionProperties )( 
            ISubscriptionMgr * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSubscription )( 
            ISubscriptionMgr * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in LPCWSTR pwszFriendlyName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ SUBSCRIPTIONTYPE subsType,
            /* [out][in] */ __RPC__inout SUBSCRIPTIONINFO *pInfo);
        
        END_INTERFACE
    } ISubscriptionMgrVtbl;

    interface ISubscriptionMgr
    {
        CONST_VTBL struct ISubscriptionMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISubscriptionMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISubscriptionMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISubscriptionMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISubscriptionMgr_DeleteSubscription(This,pwszURL,hwnd)	\
    ( (This)->lpVtbl -> DeleteSubscription(This,pwszURL,hwnd) ) 

#define ISubscriptionMgr_UpdateSubscription(This,pwszURL)	\
    ( (This)->lpVtbl -> UpdateSubscription(This,pwszURL) ) 

#define ISubscriptionMgr_UpdateAll(This)	\
    ( (This)->lpVtbl -> UpdateAll(This) ) 

#define ISubscriptionMgr_IsSubscribed(This,pwszURL,pfSubscribed)	\
    ( (This)->lpVtbl -> IsSubscribed(This,pwszURL,pfSubscribed) ) 

#define ISubscriptionMgr_GetSubscriptionInfo(This,pwszURL,pInfo)	\
    ( (This)->lpVtbl -> GetSubscriptionInfo(This,pwszURL,pInfo) ) 

#define ISubscriptionMgr_GetDefaultInfo(This,subType,pInfo)	\
    ( (This)->lpVtbl -> GetDefaultInfo(This,subType,pInfo) ) 

#define ISubscriptionMgr_ShowSubscriptionProperties(This,pwszURL,hwnd)	\
    ( (This)->lpVtbl -> ShowSubscriptionProperties(This,pwszURL,hwnd) ) 

#define ISubscriptionMgr_CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo)	\
    ( (This)->lpVtbl -> CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISubscriptionMgr_INTERFACE_DEFINED__ */


#ifndef __ISubscriptionMgr2_INTERFACE_DEFINED__
#define __ISubscriptionMgr2_INTERFACE_DEFINED__

/* interface ISubscriptionMgr2 */
/* [object][helpstring][uuid] */ 

//  Run State flags                                          
//  Item is ready and queued to run                          
#define RS_READY            0x00000001                       
//  Running item is paused                                   
#define RS_SUSPENDED        0x00000002                       
//  Item is updating                                         
#define RS_UPDATING         0x00000004                       
//  This item will be suspended while the user is not idle   
#define RS_SUSPENDONIDLE    0x00010000                       
//  This item is allowed to cause user interaction           
#define RS_MAYBOTHERUSER    0x00020000                       
//  Update is done                                           
#define RS_COMPLETED        0x80000000                       
//  Update flags                                             
//  Update window should start minimized                     
#define SUBSMGRUPDATE_MINIMIZE   0x00000001                  

#define SUBSMGRUPDATE_MASK       0x00000001                  
//  Enumeration flags                                        
//  Include temporary items                                  
#define SUBSMGRENUM_TEMP         0x00000001                  

#define SUBSMGRENUM_MASK         0x00000001                  

EXTERN_C const IID IID_ISubscriptionMgr2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("614BC270-AEDF-11d1-A1F9-00C04FC2FBE1")
    ISubscriptionMgr2 : public ISubscriptionMgr
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemFromURL( 
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [out] */ __RPC__deref_out_opt ISubscriptionItem **ppSubscriptionItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemFromCookie( 
            /* [in] */ __RPC__in const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
            /* [out] */ __RPC__deref_out_opt ISubscriptionItem **ppSubscriptionItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubscriptionRunState( 
            /* [in] */ DWORD dwNumCookies,
            /* [size_is][in] */ __RPC__in_ecount_full(dwNumCookies) const SUBSCRIPTIONCOOKIE *pCookies,
            /* [size_is][out] */ __RPC__out_ecount_full(dwNumCookies) DWORD *pdwRunState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSubscriptions( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumSubscription **ppEnumSubscriptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateItems( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwNumCookies,
            /* [size_is][in] */ __RPC__in_ecount_full(dwNumCookies) const SUBSCRIPTIONCOOKIE *pCookies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItems( 
            /* [in] */ DWORD dwNumCookies,
            /* [size_is][in] */ __RPC__in_ecount_full(dwNumCookies) const SUBSCRIPTIONCOOKIE *pCookies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISubscriptionMgr2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISubscriptionMgr2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISubscriptionMgr2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteSubscription )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateSubscription )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateAll )( 
            ISubscriptionMgr2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSubscribed )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [out] */ __RPC__out BOOL *pfSubscribed);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubscriptionInfo )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [out] */ __RPC__out SUBSCRIPTIONINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultInfo )( 
            ISubscriptionMgr2 * This,
            /* [in] */ SUBSCRIPTIONTYPE subType,
            /* [out] */ __RPC__out SUBSCRIPTIONINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ShowSubscriptionProperties )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSubscription )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in HWND hwnd,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [in] */ __RPC__in LPCWSTR pwszFriendlyName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ SUBSCRIPTIONTYPE subsType,
            /* [out][in] */ __RPC__inout SUBSCRIPTIONINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFromURL )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in LPCWSTR pwszURL,
            /* [out] */ __RPC__deref_out_opt ISubscriptionItem **ppSubscriptionItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFromCookie )( 
            ISubscriptionMgr2 * This,
            /* [in] */ __RPC__in const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
            /* [out] */ __RPC__deref_out_opt ISubscriptionItem **ppSubscriptionItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubscriptionRunState )( 
            ISubscriptionMgr2 * This,
            /* [in] */ DWORD dwNumCookies,
            /* [size_is][in] */ __RPC__in_ecount_full(dwNumCookies) const SUBSCRIPTIONCOOKIE *pCookies,
            /* [size_is][out] */ __RPC__out_ecount_full(dwNumCookies) DWORD *pdwRunState);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSubscriptions )( 
            ISubscriptionMgr2 * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IEnumSubscription **ppEnumSubscriptions);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateItems )( 
            ISubscriptionMgr2 * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwNumCookies,
            /* [size_is][in] */ __RPC__in_ecount_full(dwNumCookies) const SUBSCRIPTIONCOOKIE *pCookies);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItems )( 
            ISubscriptionMgr2 * This,
            /* [in] */ DWORD dwNumCookies,
            /* [size_is][in] */ __RPC__in_ecount_full(dwNumCookies) const SUBSCRIPTIONCOOKIE *pCookies);
        
        HRESULT ( STDMETHODCALLTYPE *AbortAll )( 
            ISubscriptionMgr2 * This);
        
        END_INTERFACE
    } ISubscriptionMgr2Vtbl;

    interface ISubscriptionMgr2
    {
        CONST_VTBL struct ISubscriptionMgr2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISubscriptionMgr2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISubscriptionMgr2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISubscriptionMgr2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISubscriptionMgr2_DeleteSubscription(This,pwszURL,hwnd)	\
    ( (This)->lpVtbl -> DeleteSubscription(This,pwszURL,hwnd) ) 

#define ISubscriptionMgr2_UpdateSubscription(This,pwszURL)	\
    ( (This)->lpVtbl -> UpdateSubscription(This,pwszURL) ) 

#define ISubscriptionMgr2_UpdateAll(This)	\
    ( (This)->lpVtbl -> UpdateAll(This) ) 

#define ISubscriptionMgr2_IsSubscribed(This,pwszURL,pfSubscribed)	\
    ( (This)->lpVtbl -> IsSubscribed(This,pwszURL,pfSubscribed) ) 

#define ISubscriptionMgr2_GetSubscriptionInfo(This,pwszURL,pInfo)	\
    ( (This)->lpVtbl -> GetSubscriptionInfo(This,pwszURL,pInfo) ) 

#define ISubscriptionMgr2_GetDefaultInfo(This,subType,pInfo)	\
    ( (This)->lpVtbl -> GetDefaultInfo(This,subType,pInfo) ) 

#define ISubscriptionMgr2_ShowSubscriptionProperties(This,pwszURL,hwnd)	\
    ( (This)->lpVtbl -> ShowSubscriptionProperties(This,pwszURL,hwnd) ) 

#define ISubscriptionMgr2_CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo)	\
    ( (This)->lpVtbl -> CreateSubscription(This,hwnd,pwszURL,pwszFriendlyName,dwFlags,subsType,pInfo) ) 


#define ISubscriptionMgr2_GetItemFromURL(This,pwszURL,ppSubscriptionItem)	\
    ( (This)->lpVtbl -> GetItemFromURL(This,pwszURL,ppSubscriptionItem) ) 

#define ISubscriptionMgr2_GetItemFromCookie(This,pSubscriptionCookie,ppSubscriptionItem)	\
    ( (This)->lpVtbl -> GetItemFromCookie(This,pSubscriptionCookie,ppSubscriptionItem) ) 

#define ISubscriptionMgr2_GetSubscriptionRunState(This,dwNumCookies,pCookies,pdwRunState)	\
    ( (This)->lpVtbl -> GetSubscriptionRunState(This,dwNumCookies,pCookies,pdwRunState) ) 

#define ISubscriptionMgr2_EnumSubscriptions(This,dwFlags,ppEnumSubscriptions)	\
    ( (This)->lpVtbl -> EnumSubscriptions(This,dwFlags,ppEnumSubscriptions) ) 

#define ISubscriptionMgr2_UpdateItems(This,dwFlags,dwNumCookies,pCookies)	\
    ( (This)->lpVtbl -> UpdateItems(This,dwFlags,dwNumCookies,pCookies) ) 

#define ISubscriptionMgr2_AbortItems(This,dwNumCookies,pCookies)	\
    ( (This)->lpVtbl -> AbortItems(This,dwNumCookies,pCookies) ) 

#define ISubscriptionMgr2_AbortAll(This)	\
    ( (This)->lpVtbl -> AbortAll(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISubscriptionMgr2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SubscriptionMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("abbe31d0-6dae-11d0-beca-00c04fd940be")
SubscriptionMgr;
#endif
#endif /* __SubscriptionMgr_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_subsmgr_0001_0049 */
/* [local] */ 



////////////////////////////////////////////////////////////////////////////
// Information Delivery Agent definitions
EXTERN_C const CLSID CLSID_WebCrawlerAgent;      
EXTERN_C const CLSID CLSID_DialAgent;            
EXTERN_C const CLSID CLSID_CDLAgent;             

// AgentFlags property for all delivery agents
typedef 
enum DELIVERY_AGENT_FLAGS
    {	DELIVERY_AGENT_FLAG_NO_BROADCAST	= 0x4,
	DELIVERY_AGENT_FLAG_NO_RESTRICTIONS	= 0x8,
	DELIVERY_AGENT_FLAG_SILENT_DIAL	= 0x10
    } 	DELIVERY_AGENT_FLAGS;


// RecurseFlags property for web crawler
typedef 
enum WEBCRAWL_RECURSEFLAGS
    {	WEBCRAWL_DONT_MAKE_STICKY	= 0x1,
	WEBCRAWL_GET_IMAGES	= 0x2,
	WEBCRAWL_GET_VIDEOS	= 0x4,
	WEBCRAWL_GET_BGSOUNDS	= 0x8,
	WEBCRAWL_GET_CONTROLS	= 0x10,
	WEBCRAWL_LINKS_ELSEWHERE	= 0x20,
	WEBCRAWL_IGNORE_ROBOTSTXT	= 0x80,
	WEBCRAWL_ONLY_LINKS_TO_HTML	= 0x100
    } 	WEBCRAWL_RECURSEFLAGS;


// ChannelFlags property for channel agent
typedef 
enum CHANNEL_AGENT_FLAGS
    {	CHANNEL_AGENT_DYNAMIC_SCHEDULE	= 0x1,
	CHANNEL_AGENT_PRECACHE_SOME	= 0x2,
	CHANNEL_AGENT_PRECACHE_ALL	= 0x4,
	CHANNEL_AGENT_PRECACHE_SCRNSAVER	= 0x8
    } 	CHANNEL_AGENT_FLAGS;


// Status codes for completed delivery agents

// Maximum specified subscription size limit reached
#define INET_E_AGENT_MAX_SIZE_EXCEEDED       _HRESULT_TYPEDEF_(0x800C0F80L)      

// A few URLs failed but the base url and most sub-urls succeeded
#define INET_S_AGENT_PART_FAIL               _HRESULT_TYPEDEF_(0x000C0F81L)      

// Maximum cache limit reached
#define INET_E_AGENT_CACHE_SIZE_EXCEEDED     _HRESULT_TYPEDEF_(0x800C0F82L)      

// Connection to Internet failed
#define INET_E_AGENT_CONNECTION_FAILED       _HRESULT_TYPEDEF_(0x800C0F83L)      

// Scheduled updates are disabled
#define INET_E_SCHEDULED_UPDATES_DISABLED    _HRESULT_TYPEDEF_(0x800C0F84L)      

// Scheduled updates are restricted
#define INET_E_SCHEDULED_UPDATES_RESTRICTED  _HRESULT_TYPEDEF_(0x800C0F85L)      

// Scheduled update occurred before update interval elapse
#define INET_E_SCHEDULED_UPDATE_INTERVAL     _HRESULT_TYPEDEF_(0x800C0F86L)      

// Scheduled update occurred during a restricted time
#define INET_E_SCHEDULED_EXCLUDE_RANGE       _HRESULT_TYPEDEF_(0x800C0F87L)      

// Status codes used during updates

// We are about to exceed our size limit during operation
#define INET_E_AGENT_EXCEEDING_CACHE_SIZE    _HRESULT_TYPEDEF_(0x800C0F90L)      

// We extended the cache size
#define INET_S_AGENT_INCREASED_CACHE_SIZE    _HRESULT_TYPEDEF_(0x000C0F90L)      

// End Information Delivery Agent definitions
////////////////////////////////////////////////////////////////////////////




extern RPC_IF_HANDLE __MIDL_itf_subsmgr_0001_0049_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_subsmgr_0001_0049_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\strsafe.h ===
/******************************************************************
*                                                                 *
*  strsafe.h -- This module defines safer C library string        *
*               routine replacements. These are meant to make C   *
*               a bit more safe in reference to security and      *
*               robustness                                        *
*                                                                 *
*  Copyright (c) Microsoft Corp.  All rights reserved.            *
*                                                                 *
******************************************************************/
#ifndef _STRSAFE_H_INCLUDED_
#define _STRSAFE_H_INCLUDED_
#if (_MSC_VER > 1000)
#pragma once
#endif

#include <stdio.h>          // for _vsnprintf, _vsnwprintf, getc, getwc
#include <string.h>         // for memset
#include <stdarg.h>         // for va_start, etc.
#include <specstrings.h>    // for __in, etc.

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && (_MSC_VER >= 1300)
#define _W64 __w64
#else
#define _W64
#endif
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define ALIGNMENT_MACHINE
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#undef ALIGNMENT_MACHINE
#define UNALIGNED
#define UNALIGNED64
#endif

// typedefs
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef _W64 unsigned int   size_t;
#endif

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef __success(return >= 0) long HRESULT;
#endif

typedef unsigned long DWORD;


// macros
#define SUCCEEDED(hr)   (((HRESULT)(hr)) >= 0)
#define FAILED(hr)      (((HRESULT)(hr)) < 0)

#define S_OK            ((HRESULT)0L)

#ifndef SORTPP_PASS
// compiletime asserts (failure results in error C2118: negative subscript)
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#else
#define C_ASSERT(e)
#endif

#ifdef __cplusplus
#define EXTERN_C    extern "C"
#else
#define EXTERN_C    extern
#endif

// use the new secure crt functions if available
#ifndef STRSAFE_USE_SECURE_CRT
#if defined(__GOT_SECURE_LIB__) && (__GOT_SECURE_LIB__ >= 200402L)
#define STRSAFE_USE_SECURE_CRT 0
#else
#define STRSAFE_USE_SECURE_CRT 0
#endif
#endif  // !STRSAFE_USE_SECURE_CRT

#ifdef _M_CEE_PURE
#define STRSAFEAPI      __inline HRESULT __clrcall
#else
#define STRSAFEAPI      __inline HRESULT __stdcall
#endif

#if defined(STRSAFE_LIB_IMPL) || defined(STRSAFE_LIB)
#define STRSAFEWORKERAPI    EXTERN_C HRESULT __stdcall 
#else
#define STRSAFEWORKERAPI    static STRSAFEAPI
#endif

#ifdef STRSAFE_LOCALE_FUNCTIONS
#if defined(STRSAFE_LOCALE_LIB_IMPL) || defined(STRSAFE_LIB)
#define STRSAFELOCALEWORKERAPI  EXTERN_C HRESULT __stdcall 
#else
#define STRSAFELOCALEWORKERAPI  static STRSAFEAPI
#endif
#endif // STRSAFE_LOCALE_FUNCTIONS

#if defined(STRSAFE_LIB)
#pragma comment(lib, "strsafe.lib")
#endif

// The user can request no "Cb" or no "Cch" fuctions, but not both
#if defined(STRSAFE_NO_CB_FUNCTIONS) && defined(STRSAFE_NO_CCH_FUNCTIONS)
#error cannot specify both STRSAFE_NO_CB_FUNCTIONS and STRSAFE_NO_CCH_FUNCTIONS !!
#endif

// The user may override STRSAFE_MAX_CCH, but it must always be less than INT_MAX
#ifndef STRSAFE_MAX_CCH
#define STRSAFE_MAX_CCH     2147483647  // max buffer size, in characters, that we support (same as INT_MAX)
#endif
C_ASSERT(STRSAFE_MAX_CCH <= 2147483647);
C_ASSERT(STRSAFE_MAX_CCH > 1);

#define STRSAFE_MAX_LENGTH  (STRSAFE_MAX_CCH - 1)   // max buffer length, in characters, that we support


// Flags for controling the Ex functions
//
//      STRSAFE_FILL_BYTE(0xFF)                         0x000000FF  // bottom byte specifies fill pattern
#define STRSAFE_IGNORE_NULLS                            0x00000100  // treat null string pointers as TEXT("") -- don't fault on NULL buffers
#define STRSAFE_FILL_BEHIND_NULL                        0x00000200  // on success, fill in extra space behind the null terminator with fill pattern
#define STRSAFE_FILL_ON_FAILURE                         0x00000400  // on failure, overwrite pszDest with fill pattern and null terminate it
#define STRSAFE_NULL_ON_FAILURE                         0x00000800  // on failure, set *pszDest = TEXT('\0')
#define STRSAFE_NO_TRUNCATION                           0x00001000  // instead of returning a truncated result, copy/append nothing to pszDest and null terminate it

#define STRSAFE_VALID_FLAGS                     (0x000000FF | STRSAFE_IGNORE_NULLS | STRSAFE_FILL_BEHIND_NULL | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE | STRSAFE_NO_TRUNCATION)

// helper macro to set the fill character and specify buffer filling
#define STRSAFE_FILL_BYTE(x)                    ((DWORD)((x & 0x000000FF) | STRSAFE_FILL_BEHIND_NULL))
#define STRSAFE_FAILURE_BYTE(x)                 ((DWORD)((x & 0x000000FF) | STRSAFE_FILL_ON_FAILURE))

#define STRSAFE_GET_FILL_PATTERN(dwFlags)       ((int)(dwFlags & 0x000000FF))


// error return codes
#define STRSAFE_E_INSUFFICIENT_BUFFER           ((HRESULT)0x8007007AL)  // 0x7A = 122L = ERROR_INSUFFICIENT_BUFFER
#define STRSAFE_E_INVALID_PARAMETER             ((HRESULT)0x80070057L)  // 0x57 =  87L = ERROR_INVALID_PARAMETER
#define STRSAFE_E_END_OF_FILE                   ((HRESULT)0x80070026L)  // 0x26 =  38L = ERROR_HANDLE_EOF

//
// These typedefs are used in places where the string is guaranteed to
// be null terminated.
//
typedef __nullterminated char* STRSAFE_LPSTR;
typedef __nullterminated const char* STRSAFE_LPCSTR;
typedef __nullterminated wchar_t* STRSAFE_LPWSTR;
typedef __nullterminated const wchar_t* STRSAFE_LPCWSTR;
typedef __nullterminated const wchar_t UNALIGNED* STRSAFE_LPCUWSTR;


// prototypes for the worker functions

STRSAFEWORKERAPI
StringLengthWorkerA(
    __in STRSAFE_LPCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);

STRSAFEWORKERAPI
StringLengthWorkerW(
    __in STRSAFE_LPCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);
    
#ifdef ALIGNMENT_MACHINE
STRSAFEWORKERAPI
UnalignedStringLengthWorkerW(
    __in STRSAFE_LPCUWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength);
#endif  // ALIGNMENT_MACHINE

STRSAFEWORKERAPI
StringExValidateSrcA(
    __deref_inout_opt STRSAFE_LPCSTR* ppszSrc,
    __inout_opt size_t* pcchToRead,
    __in size_t cchMax,
    __in DWORD dwFlags);

STRSAFEWORKERAPI
StringExValidateSrcW(
    __deref_inout_opt STRSAFE_LPCWSTR* ppszSrc,
    __inout_opt size_t* pcchToRead,
    __in size_t cchMax,
    __in DWORD dwFlags);

STRSAFEWORKERAPI
StringValidateDestA(
    __in_ecount_opt(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax);

STRSAFEWORKERAPI
StringValidateDestW(
    __in_ecount_opt(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax);

STRSAFEWORKERAPI
StringExValidateDestA(
    __deref_inout_opt STRSAFE_LPSTR* ppszDest,
    __inout size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags);

STRSAFEWORKERAPI
StringExValidateDestW(
    __deref_inout_opt STRSAFE_LPWSTR* ppszDest,
    __inout size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags);

STRSAFEWORKERAPI
StringCopyWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy);

STRSAFEWORKERAPI
StringCopyWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy);

STRSAFEWORKERAPI
StringVPrintfWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList);

#ifdef STRSAFE_LOCALE_FUNCTIONS
STRSAFELOCALEWORKERAPI
StringVPrintf_lWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList);
#endif  // STRSAFE_LOCALE_FUNCTIONS

STRSAFEWORKERAPI
StringVPrintfWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList);

#ifdef STRSAFE_LOCALE_FUNCTIONS
STRSAFELOCALEWORKERAPI
StringVPrintf_lWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList);
#endif  // STRSAFE_LOCALE_FUNCTIONS

#ifndef STRSAFE_LIB_IMPL
// always run these functions inline always since they use stdin

STRSAFEAPI
StringGetsWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength);

STRSAFEAPI
StringGetsWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength);
    
#endif  // !STRSAFE_LIB_IMPL

STRSAFEWORKERAPI
StringExHandleFillBehindNullA(
    __out_bcount(cbRemaining) STRSAFE_LPSTR pszDestEnd,
    __in size_t cbRemaining,
    __in DWORD dwFlags);

STRSAFEWORKERAPI
StringExHandleFillBehindNullW(
    __out_bcount(cbRemaining) STRSAFE_LPWSTR pszDestEnd,
    __in size_t cbRemaining,
    __in DWORD dwFlags);

STRSAFEWORKERAPI
StringExHandleOtherFlagsA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in size_t cchOriginalDestLength,
    __deref_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags);

STRSAFEWORKERAPI
StringExHandleOtherFlagsW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in size_t cchOriginalDestLength,
    __deref_out_ecount(*pcchRemaining)STRSAFE_LPWSTR* ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags);

#pragma warning(push)
#pragma warning(disable : 4996) // 'function': was declared deprecated
#pragma warning(disable : 4995) // name was marked as #pragma deprecated


#ifndef STRSAFE_LIB_IMPL

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopy(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in  size_t  cchDest,
    __in  LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for strncpy.  That function will pad the
    destination string with extra null termination characters if the count is
    greater than the length of the source string, and it will fail to null
    terminate the destination string if the source string length is greater
    than or equal to the count. You can not blindly use this instead of strncpy:
    it is common for code to use it to "patch" strings and you would introduce
    errors if the code started null terminating in the middle of the string.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was copied without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of
    pszSrc will be copied to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = (_tcslen(src) + 1) to hold all of the
                       source including the null terminator

    pszSrc         -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCchCopy  StringCchCopyW
#else
#define StringCchCopy  StringCchCopyA
#endif // !UNICODE

STRSAFEAPI
StringCchCopyA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr;

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringCopyWorkerA(pszDest,
                               cchDest,
                               NULL,
                               pszSrc,
                               STRSAFE_MAX_LENGTH);
    }

    return hr;
}

STRSAFEAPI
StringCchCopyW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr;
    
    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);

    if (SUCCEEDED(hr))
    {
        hr = StringCopyWorkerW(pszDest,
                               cchDest,
                               NULL,
                               pszSrc,
                               STRSAFE_MAX_LENGTH);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopy(
    __out_bcount(cbDest) LPTSTR pszDest,
    __in  size_t cbDest,
    __in  LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for strncpy.  That function will pad the
    destination string with extra null termination characters if the count is
    greater than the length of the source string, and it will fail to null
    terminate the destination string if the source string length is greater
    than or equal to the count. You can not blindly use this instead of strncpy:
    it is common for code to use it to "patch" strings and you would introduce
    errors if the code started null terminating in the middle of the string.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was copied without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be copied to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = ((_tcslen(src) + 1) * sizeof(TCHAR)) to
                       hold all of the source including the null terminator

    pszSrc         -   source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCbCopy  StringCbCopyW
#else
#define StringCbCopy  StringCbCopyA
#endif // !UNICODE

STRSAFEAPI
StringCbCopyA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);

    if (SUCCEEDED(hr))
    {
        hr = StringCopyWorkerA(pszDest,
                               cchDest,
                               NULL,
                               pszSrc,
                               STRSAFE_MAX_LENGTH);
    }

    return hr;
}

STRSAFEAPI
StringCbCopyW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);

    if (SUCCEEDED(hr))
    {
        hr = StringCopyWorkerW(pszDest,
                               cchDest,
                               NULL,
                               pszSrc,
                               STRSAFE_MAX_LENGTH);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cchDest,
    __in  LPCTSTR pszSrc          OPTIONAL,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' with
    some additional parameters.  In addition to functionality provided by
    StringCchCopy, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = (_tcslen(pszSrc) + 1) to hold all of
                        the source including the null terminator

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchCopyEx  StringCchCopyExW
#else
#define StringCchCopyEx  StringCchCopyExA
#endif // !UNICODE

STRSAFEAPI
StringCchCopyExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszSrc, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerA(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       STRSAFE_MAX_LENGTH);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;
                
                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchCopyExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszSrc, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerW(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       STRSAFE_MAX_LENGTH);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cbDest,
    __in  LPCTSTR pszSrc          OPTIONAL,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcpy' with
    some additional parameters.  In addition to functionality provided by
    StringCbCopy, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to
                        hold all of the source including the null terminator

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbCopyEx  StringCbCopyExW
#else
#define StringCbCopyEx  StringCbCopyExA
#endif // !UNICODE

STRSAFEAPI
StringCbCopyExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszSrc, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerA(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       STRSAFE_MAX_LENGTH);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }

            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbCopyExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszSrc, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerW(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       STRSAFE_MAX_LENGTH);
                
                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyN(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in  size_t  cchDest,
    __in  LPCTSTR pszSrc,
    __in  size_t  cchToCopy
    );


Routine Description:

    This routine is a safer version of the C built-in function 'strncpy'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cchToCopy is greater than the length of pszSrc.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the entire string or the first cchToCopy characters were copied
    without truncation and the resultant destination string was null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be copied to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest        -   destination string

    cchDest        -   size of destination buffer in characters.
                       length must be = (_tcslen(src) + 1) to hold all of the
                       source including the null terminator

    pszSrc         -   source string

    cchToCopy      -   maximum number of characters to copy from source string,
                       not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCopyNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCchCopyN  StringCchCopyNW
#else
#define StringCchCopyN  StringCchCopyNA
#endif // !UNICODE

STRSAFEAPI
StringCchCopyNA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy)
{
    HRESULT hr;

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        if (cchToCopy > STRSAFE_MAX_LENGTH)
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
            
            *pszDest = '\0';
        }
        else
        {
            hr = StringCopyWorkerA(pszDest,
                                   cchDest,
                                   NULL,
                                   pszSrc,
                                   cchToCopy);
        }
    }

    return hr;
}

STRSAFEAPI
StringCchCopyNW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy)
{
    HRESULT hr;

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        if (cchToCopy > STRSAFE_MAX_LENGTH)
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
            
            *pszDest = L'\0';
        }
        else
        {
            hr = StringCopyWorkerW(pszDest,
                                   cchDest,
                                   NULL,
                                   pszSrc,
                                   cchToCopy);
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyN(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in  size_t  cbDest,
    __in  LPCTSTR pszSrc,
    __in  size_t  cbToCopy
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cbToCopy is greater than the size of pszSrc.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the entire string or the first cbToCopy characters were
    copied without truncation and the resultant destination string was null
    terminated, otherwise it will return a failure code. In failure cases as
    much of pszSrc will be copied to pszDest as possible, and pszDest will be
    null terminated.

Arguments:

    pszDest        -   destination string

    cbDest         -   size of destination buffer in bytes.
                       length must be = ((_tcslen(src) + 1) * sizeof(TCHAR)) to
                       hold all of the source including the null terminator

    pszSrc         -   source string

    cbToCopy       -   maximum number of bytes to copy from source string,
                       not including the null terminator.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCopyEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCbCopyN  StringCbCopyNW
#else
#define StringCbCopyN  StringCbCopyNA
#endif // !UNICODE

STRSAFEAPI
StringCbCopyNA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cbToCopy)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        size_t cchToCopy = cbToCopy / sizeof(char);

        if (cchToCopy > STRSAFE_MAX_LENGTH)
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
            
            *pszDest = '\0';
        }
        else
        {
            hr = StringCopyWorkerA(pszDest,
                                   cchDest,
                                   NULL,
                                   pszSrc,
                                   cchToCopy);
        }
    }

    return hr;
}

STRSAFEAPI
StringCbCopyNW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToCopy)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        size_t cchToCopy = cbToCopy / sizeof(wchar_t);

        if (cchToCopy > STRSAFE_MAX_LENGTH)
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
            
            *pszDest = L'\0';
        }
        else
        {
            hr = StringCopyWorkerW(pszDest,
                                   cchDest,
                                   NULL,
                                   pszSrc,
                                   cchToCopy);
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCopyNEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cchDest,
    __in  LPCTSTR pszSrc          OPTIONAL,
    __in  size_t  cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd OPTIONAL,
    __out_opt size_t* pcchRemaining OPTIONAL,
    __in  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters.  In addition to functionality provided by
    StringCchCopyN, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination
    string including the null terminator. The flags parameter allows
    additional controls.

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cchToCopy is greater than the length of pszSrc.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be = (_tcslen(pszSrc) + 1) to hold all of
                        the source including the null terminator

    pszSrc          -   source string

    cchToCopy       -   maximum number of characters to copy from the source
                        string

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified. If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL. An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchCopyNEx  StringCchCopyNExW
#else
#define StringCchCopyNEx  StringCchCopyNExA
#endif // !UNICODE

STRSAFEAPI
StringCchCopyNExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;

    hr = StringExValidateDestA(&pszDest, 
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszSrc, &cchToCopy, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerA(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       cchToCopy);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchCopyNExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszSrc, &cchToCopy, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerW(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       cchToCopy);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCopyNEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cbDest,
    __in  LPCTSTR pszSrc          OPTIONAL,
    __in  size_t  cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in  DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncpy' with
    some additional parameters.  In addition to functionality provided by
    StringCbCopyN, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

    This routine is meant as a replacement for strncpy, but it does behave
    differently. This function will not pad the destination buffer with extra
    null termination characters if cbToCopy is greater than the size of pszSrc.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszSrc) + 1) * sizeof(TCHAR)) to
                        hold all of the source including the null terminator

    pszSrc          -   source string

    cbToCopy        -   maximum number of bytes to copy from source string

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   pcbRemaining is non-null,the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcpy

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all copied and the
                       resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the copy
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbCopyNEx  StringCbCopyNExW
#else
#define StringCbCopyNEx  StringCbCopyNExA
#endif // !UNICODE

STRSAFEAPI
StringCbCopyNExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchToCopy = cbToCopy / sizeof(char);

        hr = StringExValidateSrcA(&pszSrc, &cchToCopy, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerA(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       cchToCopy);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbCopyNExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToCopy,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchToCopy = cbToCopy / sizeof(wchar_t);

        hr = StringExValidateSrcW(&pszSrc, &cchToCopy, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually src data to copy
                if ((cchToCopy != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerW(pszDest,
                                       cchDest,
                                       &cchCopied,
                                       pszSrc,
                                       cchToCopy);

                pszDestEnd = pszDest + cchCopied;
                cchRemaining = cchDest - cchCopied;

                if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }

            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCat(
    __inout_ecount(cchDest) LPTSTR  pszDest,
    __in     size_t  cchDest,
    __in     LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat'.
    The size of the destination buffer (in characters) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was concatenated without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be appended to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest     -  destination string which must be null terminated

    cchDest     -  size of destination buffer in characters.
                   length must be = (_tcslen(pszDest) + _tcslen(pszSrc) + 1)
                   to hold all of the combine string plus the null
                   terminator

    pszSrc      -  source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCchCatEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error occurs,
                       the destination buffer is modified to contain a truncated
                       version of the ideal result and is null terminated. This
                       is useful for situations where truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchCat  StringCchCatW
#else
#define StringCchCat  StringCchCatA
#endif // !UNICODE

STRSAFEAPI
StringCchCatA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringValidateDestA(pszDest, cchDest, &cchDestLength, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringCopyWorkerA(pszDest + cchDestLength,
                               cchDest - cchDestLength,
                               NULL,
                               pszSrc,
                               STRSAFE_MAX_CCH);
    }

    return hr;
}

STRSAFEAPI
StringCchCatW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringValidateDestW(pszDest, cchDest, &cchDestLength, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringCopyWorkerW(pszDest + cchDestLength,
                               cchDest - cchDestLength,
                               NULL,
                               pszSrc,
                               STRSAFE_MAX_CCH);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCat(
    __inout_bcount(cbDest) LPTSTR  pszDest,
    __in     size_t  cbDest,
    __in     LPCTSTR pszSrc
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat'.
    The size of the destination buffer (in bytes) is a parameter and this
    function will not write past the end of this buffer and it will ALWAYS
    null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was concatenated without truncation and null terminated,
    otherwise it will return a failure code. In failure cases as much of pszSrc
    will be appended to pszDest as possible, and pszDest will be null
    terminated.

Arguments:

    pszDest     -  destination string which must be null terminated

    cbDest      -  size of destination buffer in bytes.
                   length must be = ((_tcslen(pszDest) + _tcslen(pszSrc) + 1) * sizeof(TCHAR)
                   to hold all of the combine string plus the null
                   terminator

    pszSrc      -  source string which must be null terminated

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL.  See StringCbCatEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error occurs,
                       the destination buffer is modified to contain a truncated
                       version of the ideal result and is null terminated. This
                       is useful for situations where truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbCat  StringCbCatW
#else
#define StringCbCat  StringCbCatA
#endif // !UNICODE

STRSAFEAPI
StringCbCatA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc)
{
    HRESULT hr;
    size_t cchDestLength;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringValidateDestA(pszDest, cchDest, &cchDestLength, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringCopyWorkerA(pszDest + cchDestLength,
                               cchDest - cchDestLength,
                               NULL,
                               pszSrc,
                               STRSAFE_MAX_CCH);
    }

    return hr;
}

STRSAFEAPI
StringCbCatW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc)
{
    HRESULT hr;
    size_t cchDestLength;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringValidateDestW(pszDest, cchDest, &cchDestLength, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringCopyWorkerW(pszDest + cchDestLength,
                               cchDest - cchDestLength,
                               NULL,
                               pszSrc,
                               STRSAFE_MAX_CCH);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatEx(
    __inout_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in     size_t  cchDest,
    __in     LPCTSTR pszSrc          OPTIONAL,
    __deref_opt_out_ecount(*pcchRemaining)    LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt    size_t* pcchRemaining   OPTIONAL,
    __in     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' with
    some additional parameters.  In addition to functionality provided by
    StringCchCat, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters
                        length must be (_tcslen(pszDest) + _tcslen(pszSrc) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcat

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchCatEx  StringCchCatExW
#else
#define StringCchCatEx  StringCchCatExA
#endif // !UNICODE

STRSAFEAPI
StringCchCatExA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        hr = StringExValidateSrcA(&pszSrc, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerA(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       STRSAFE_MAX_LENGTH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;
            
                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);
            
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchCatExW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        hr = StringExValidateSrcW(&pszSrc, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerW(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       STRSAFE_MAX_LENGTH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(wchar_t);
            
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatEx(
    __inout_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in     size_t  cbDest,
    __in     LPCTSTR pszSrc          OPTIONAL,
    __deref_opt_out_bcount(*pcbRemaining)    LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt    size_t* pcbRemaining    OPTIONAL,
    __in     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strcat' with
    some additional parameters.  In addition to functionality provided by
    StringCbCat, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + _tcslen(pszSrc) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string which must be null terminated

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).
                    this flag is useful for emulating functions like lstrcat

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated
                       and the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbCatEx  StringCbCatExW
#else
#define StringCbCatEx  StringCbCatExA
#endif // !UNICODE

STRSAFEAPI
StringCbCatExA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);
    size_t cchDestLength;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        hr = StringExValidateSrcA(&pszSrc, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerA(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       STRSAFE_MAX_LENGTH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbCatExW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);
    size_t cchDestLength;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        hr = StringExValidateSrcW(&pszSrc, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if (*pszSrc != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerW(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       STRSAFE_MAX_LENGTH);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatN(
    __inout_ecount(cchDest) LPTSTR  pszDest,
    __in     size_t  cchDest,
    __in     LPCTSTR pszSrc,
    __in     size_t  cchToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat'.
    The size of the destination buffer (in characters) is a parameter as well as
    the maximum number of characters to append, excluding the null terminator.
    This function will not write past the end of the destination buffer and it will
    ALWAYS null terminate pszDest (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if all of pszSrc or the first cchToAppend characters were appended
    to the destination string and it was null terminated, otherwise it will
    return a failure code. In failure cases as much of pszSrc will be appended
    to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters.
                        length must be (_tcslen(pszDest) + min(cchToAppend, _tcslen(pszSrc)) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cchToAppend     -   maximum number of characters to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCchCatNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if all of pszSrc or the first cchToAppend characters
                       were concatenated to pszDest and the resultant dest
                       string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchCatN  StringCchCatNW
#else
#define StringCchCatN  StringCchCatNA
#endif // !UNICODE

STRSAFEAPI
StringCchCatNA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringValidateDestA(pszDest, cchDest, &cchDestLength, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        if (cchToAppend > STRSAFE_MAX_LENGTH)
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
        }
        else
        {
            hr = StringCopyWorkerA(pszDest + cchDestLength,
                                   cchDest - cchDestLength,
                                   NULL,
                                   pszSrc,
                                   cchToAppend);
        }
    }

    return hr;
}

STRSAFEAPI
StringCchCatNW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringValidateDestW(pszDest, cchDest, &cchDestLength, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        if (cchToAppend > STRSAFE_MAX_LENGTH)
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
        }
        else
        {
            hr = StringCopyWorkerW(pszDest + cchDestLength,
                                   cchDest - cchDestLength,
                                   NULL,
                                   pszSrc,
                                   cchToAppend);
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatN(
    __inout_bcount(cbDest) LPTSTR  pszDest,
    __in     size_t  cbDest,
    __in     LPCTSTR pszSrc,
    __in     size_t  cbToAppend
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat'.
    The size of the destination buffer (in bytes) is a parameter as well as
    the maximum number of bytes to append, excluding the null terminator.
    This function will not write past the end of the destination buffer and it will
    ALWAYS null terminate pszDest (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if all of pszSrc or the first cbToAppend bytes were appended
    to the destination string and it was null terminated, otherwise it will
    return a failure code. In failure cases as much of pszSrc will be appended
    to pszDest as possible, and pszDest will be null terminated.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + min(cbToAppend / sizeof(TCHAR), _tcslen(pszSrc)) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cbToAppend      -   maximum number of bytes to append

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL. See StringCbCatNEx if you require
    the handling of NULL values.

Return Value:

    S_OK           -   if all of pszSrc or the first cbToAppend bytes were
                       concatenated to pszDest and the resultant dest string
                       was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbCatN  StringCbCatNW
#else
#define StringCbCatN  StringCbCatNA
#endif // !UNICODE

STRSAFEAPI
StringCbCatNA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cbToAppend)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);
    size_t cchDestLength;

    hr = StringValidateDestA(pszDest, cchDest, &cchDestLength, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        size_t cchToAppend = cbToAppend / sizeof(char);
        
        if (cchToAppend > STRSAFE_MAX_LENGTH)
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
        }
        else
        {
            hr = StringCopyWorkerA(pszDest + cchDestLength,
                                   cchDest - cchDestLength,
                                   NULL,
                                   pszSrc,
                                   cchToAppend);
        }
    }

    return hr;
}

STRSAFEAPI
StringCbCatNW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToAppend)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);
    size_t cchDestLength;

    hr = StringValidateDestW(pszDest, cchDest, &cchDestLength, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        size_t cchToAppend = cbToAppend / sizeof(wchar_t);
        
        if (cchToAppend > STRSAFE_MAX_LENGTH)
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
        }
        else
        {
            hr = StringCopyWorkerW(pszDest + cchDestLength,
                                   cchDest - cchDestLength,
                                   NULL,
                                   pszSrc,
                                   cchToAppend);
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchCatNEx(
    __inout_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in     size_t  cchDest,
    __in     LPCTSTR pszSrc          OPTIONAL,
    __in     size_t  cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining)    LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt    size_t* pcchRemaining   OPTIONAL,
    __in     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters.  In addition to functionality provided by
    StringCchCatN, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cchDest         -   size of destination buffer in characters.
                        length must be (_tcslen(pszDest) + min(cchToAppend, _tcslen(pszSrc)) + 1)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cchToAppend     -   maximum number of characters to append

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if all of pszSrc or the first cchToAppend characters
                       were concatenated to pszDest and the resultant dest
                       string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchCatNEx  StringCchCatNExW
#else
#define StringCchCatNEx  StringCchCatNExA
#endif // !UNICODE

STRSAFEAPI
StringCchCatNExA(
    __inout_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        hr = StringExValidateSrcA(&pszSrc, &cchToAppend, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerA(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       cchToAppend);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchCatNExW(
    __inout_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToAppend,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDestLength;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;

        hr = StringExValidateSrcW(&pszSrc, &cchToAppend, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerW(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       cchToAppend);
                
                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbCatNEx(
    __inout_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in     size_t  cbDest,
    __in     LPCTSTR pszSrc          OPTIONAL,
    __in     size_t  cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining)    LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt    size_t* pcchRemaining   OPTIONAL,
    __in     DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters.  In addition to functionality provided by
    StringCbCatN, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string which must be null terminated

    cbDest          -   size of destination buffer in bytes.
                        length must be ((_tcslen(pszDest) + min(cbToAppend / sizeof(TCHAR), _tcslen(pszSrc)) + 1) * sizeof(TCHAR)
                        to hold all of the combine string plus the null
                        terminator.

    pszSrc          -   source string

    cbToAppend      -   maximum number of bytes to append

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function appended any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any pre-existing
                    or truncated string

        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any pre-existing or
                    truncated string

        STRSAFE_NO_TRUNCATION
                    if the function returns STRSAFE_E_INSUFFICIENT_BUFFER, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    pszDest and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    S_OK           -   if all of pszSrc or the first cbToAppend bytes were
                       concatenated to pszDest and the resultant dest string
                       was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the operation
                       failed due to insufficient space. When this error
                       occurs, the destination buffer is modified to contain
                       a truncated version of the ideal result and is null
                       terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbCatNEx  StringCbCatNExW
#else
#define StringCbCatNEx  StringCbCatNExA
#endif // !UNICODE

STRSAFEAPI
StringCbCatNExA(
    __inout_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);
    size_t cchDestLength;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchToAppend = cbToAppend / sizeof(char);

        hr = StringExValidateSrcA(&pszSrc, &cchToAppend, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != '\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerA(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       cchToAppend);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbCatNExW(
    __inout_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cbToAppend,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);
    size_t cchDestLength;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               &cchDestLength,
                               STRSAFE_MAX_CCH,
                               dwFlags);

    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchToAppend = cbToAppend / sizeof(wchar_t);

        hr = StringExValidateSrcW(&pszSrc, &cchToAppend, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else if (cchRemaining <= 1)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                hr = StringCopyWorkerW(pszDestEnd,
                                       cchRemaining,
                                       &cchCopied,
                                       pszSrc,
                                       cchToAppend);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      cchDestLength,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }
                                     
        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchVPrintf(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in  size_t  cchDest,
    __in __format_string  LPCTSTR pszFormat,
    __in  va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cchDest     -  size of destination buffer in characters
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    argList     -  va_list from the variable arguments according to the
                   stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCchVPrintfEx if you
    require the handling of NULL values.

Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchVPrintf  StringCchVPrintfW
#else
#define StringCchVPrintf  StringCchVPrintfA
#endif // !UNICODE

STRSAFEAPI
StringCchVPrintfA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringVPrintfWorkerA(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);
    }

    return hr;
}

STRSAFEAPI
StringCchVPrintfW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringVPrintfWorkerW(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#if defined(STRSAFE_LOCALE_FUNCTIONS) && !defined(STRSAFE_NO_CCH_FUNCTIONS)
/*++

STDAPI
StringCchVPrintf_l(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in size_t  cchDest,
    __in __format_string  LPCTSTR pszFormat,
    __in locale_t locale,
    __in va_list argList
    );

Routine Description:

    This routine is a version of StringCchVPrintf that also takes a locale.
    Please see notes for StringCchVPrintf above.

--*/
#ifdef UNICODE
#define StringCchVPrintf_l  StringCchVPrintf_lW
#else
#define StringCchVPrintf_l  StringCchVPrintf_lA
#endif // !UNICODE

STRSAFEAPI
StringCchVPrintf_lA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr;

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringVPrintf_lWorkerA(pszDest,
                                    cchDest,
                                    NULL,
                                    pszFormat,
                                    locale,
                                    argList);
    }

    return hr;
}

STRSAFEAPI
StringCchVPrintf_lW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr;

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringVPrintf_lWorkerW(pszDest,
                                    cchDest,
                                    NULL,
                                    pszFormat,
                                    locale,
                                    argList);
    }

    return hr;
}
#endif  //  STRSAFE_LOCALE_FUNCTIONS && !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbVPrintf(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in size_t  cbDest,
    __in __format_string LPCTSTR pszFormat,
    __in va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cbDest      -  size of destination buffer in bytes
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    argList     -  va_list from the variable arguments according to the
                   stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCbVPrintfEx if you
    require the handling of NULL values.


Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbVPrintf  StringCbVPrintfW
#else
#define StringCbVPrintf  StringCbVPrintfA
#endif // !UNICODE

STRSAFEAPI
StringCbVPrintfA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringVPrintfWorkerA(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);
    }

    return hr;
}

STRSAFEAPI
StringCbVPrintfW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);
 
    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringVPrintfWorkerW(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#if defined(STRSAFE_LOCALE_FUNCTIONS) && !defined(STRSAFE_NO_CB_FUNCTIONS)
/*++

STDAPI
StringCbVPrintf_l(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in size_t  cbDest,
    __in __format_string LPCTSTR pszFormat,
    __in local_t locale,
    __in va_list argList
    );

Routine Description:

    This routine is a version of StringCbVPrintf that also takes a locale.
    Please see notes for StringCbVPrintf above.

--*/
#ifdef UNICODE
#define StringCbVPrintf_l   StringCbVPrintf_lW
#else
#define StringCbVPrintf_l   StringCbVPrintf_lA
#endif // !UNICODE

STRSAFEAPI
StringCbVPrintf_lA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringVPrintf_lWorkerA(pszDest,
                                    cchDest,
                                    NULL,
                                    pszFormat,
                                    locale,
                                    argList);
    }

    return hr;
}

STRSAFEAPI
StringCbVPrintf_lW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);
 
    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringVPrintf_lWorkerW(pszDest,
                                    cchDest,
                                    NULL,
                                    pszFormat,
                                    locale,
                                    argList);
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS && !STRSAFE_NO_CB_FUNCTIONS


#ifndef _M_CEE_PURE

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchPrintf(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in size_t  cchDest,
    __in __format_string  LPCTSTR pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cchDest     -  size of destination buffer in characters
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    ...         -  additional parameters to be formatted according to
                   the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCchPrintfEx if you
    require the handling of NULL values.

Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchPrintf  StringCchPrintfW
#else
#define StringCchPrintf  StringCchPrintfA
#endif // !UNICODE

STRSAFEAPI
StringCchPrintfA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...)
{
    HRESULT hr;

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerA(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);

        va_end(argList);
    }

    return hr;
}

STRSAFEAPI
StringCchPrintfW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...)
{
    HRESULT hr;

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerW(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);

        va_end(argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#if defined(STRSAFE_LOCALE_FUNCTIONS) && !defined(STRSAFE_NO_CCH_FUNCTIONS)
/*++

STDAPI
StringCchPrintf_l(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in size_t  cchDest,
    __in __format_string  LPCTSTR pszFormat,
    __in  locale_t locale,
    ...
    );

Routine Description:

    This routine is a version of a StringCchPrintf_l that also takes a locale.
    Please see notes for StringCchPrintf above.

--*/
#ifdef UNICODE
#define StringCchPrintf_l   StringCchPrintf_lW
#else
#define StringCchPrintf_l   StringCchPrintf_lA
#endif // !UNICODE

STRSAFEAPI
StringCchPrintf_lA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    ...)
{
    HRESULT hr;

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        va_list argList;

        va_start(argList, locale);

        hr = StringVPrintf_lWorkerA(pszDest,
                                    cchDest,
                                    NULL,
                                    pszFormat,
                                    locale,
                                    argList);

        va_end(argList);
    }

    return hr;
}

STRSAFEAPI
StringCchPrintf_lW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    ...)
{
    HRESULT hr;

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        va_list argList;

        va_start(argList, locale);

        hr = StringVPrintf_lWorkerW(pszDest,
                                    cchDest,
                                    NULL,
                                    pszFormat,
                                    locale,
                                    argList);

        va_end(argList);
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS && !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbPrintf(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in size_t  cbDest,
    __in __format_string LPCTSTR pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string was printed without truncation and null terminated,
    otherwise it will return a failure code. In failure cases it will return
    a truncated version of the ideal result.

Arguments:

    pszDest     -  destination string

    cbDest      -  size of destination buffer in bytes
                   length must be sufficient to hold the resulting formatted
                   string, including the null terminator.

    pszFormat   -  format string which must be null terminated

    ...         -  additional parameters to be formatted according to
                   the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL.  See StringCbPrintfEx if you
    require the handling of NULL values.


Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbPrintf  StringCbPrintfW
#else
#define StringCbPrintf  StringCbPrintfA
#endif // !UNICODE

STRSAFEAPI
StringCbPrintfA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerA(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);

        va_end(argList);
    }

    return hr;
}

STRSAFEAPI
StringCbPrintfW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        va_list argList;

        va_start(argList, pszFormat);

        hr = StringVPrintfWorkerW(pszDest,
                                  cchDest,
                                  NULL,
                                  pszFormat,
                                  argList);

        va_end(argList);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#if defined(STRSAFE_LOCALE_FUNCTIONS) && !defined(STRSAFE_NO_CB_FUNCTIONS)
/*++

STDAPI
StringCbPrintf_l(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in size_t  cbDest,
    __in __format_string LPCTSTR pszFormat,
    __in locale_t locale,
    ...
    );

Routine Description:

    This routine is a version of StringCbPrintf that also takes a locale.
    Please see notes for StringCbPrintf above.

--*/
#ifdef UNICODE
#define StringCbPrintf_l    StringCbPrintf_lW
#else
#define StringCbPrintf_l    StringCbPrintf_lA
#endif // !UNICODE

STRSAFEAPI
StringCbPrintf_lA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    ...)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        va_list argList;

        va_start(argList, locale);

        hr = StringVPrintf_lWorkerA(pszDest,
                                    cchDest,
                                    NULL,
                                    pszFormat,
                                    locale,
                                    argList);

        va_end(argList);
    }

    return hr;
}

STRSAFEAPI
StringCbPrintf_lW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    ...)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        va_list argList;

        va_start(argList, locale);

        hr = StringVPrintf_lWorkerW(pszDest,
                                    cchDest,
                                    NULL,
                                    pszFormat,
                                    locale,
                                    argList);

        va_end(argList);
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS && !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchPrintfEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in  size_t  cchDest,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCchPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return
                        the number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    ...             -   additional parameters to be formatted according to
                        the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was sufficient space in the dest buffer for
                       the resultant string and it was null terminated.

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchPrintfEx  StringCchPrintfExW
#else
#define StringCchPrintfEx  StringCchPrintfExA
#endif // !UNICODE

STRSAFEAPI
StringCchPrintfExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...)
{
    HRESULT hr;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, pszFormat);

                hr = StringVPrintfWorkerA(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

             // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchPrintfExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...)
{
    HRESULT hr;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, pszFormat);

                hr = StringVPrintfWorkerW(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#if defined(STRSAFE_LOCALE_FUNCTIONS) && !defined(STRSAFE_NO_CCH_FUNCTIONS)
/*++

STDAPI
StringCchPrintf_lEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cchDest,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    __in locale_t locale,
    ...
    );

Routine Description:

    This routine is a version of StringCchPrintfEx that also takes a locale.
    Please see notes for StringCchPrintfEx above.

--*/
#ifdef UNICODE
#define StringCchPrintf_lEx StringCchPrintf_lExW
#else
#define StringCchPrintf_lEx StringCchPrintf_lExA
#endif // !UNICODE

STRSAFEAPI
StringCchPrintf_lExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    ...)
{
    HRESULT hr;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, locale);

                hr = StringVPrintf_lWorkerA(pszDest,
                                            cchDest,
                                            &cchNewDestLength,
                                            pszFormat,
                                            locale,
                                            argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

             // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchPrintf_lExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    ...)
{
    HRESULT hr;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, locale);

                hr = StringVPrintf_lWorkerW(pszDest,
                                            cchDest,
                                            &cchNewDestLength,
                                            pszFormat,
                                            locale,
                                            argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS && !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbPrintfEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cbDest,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCbPrintf, this routine also returns a pointer to the end of the
    destination string and the number of bytes left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    ...             -   additional parameters to be formatted according to
                        the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbPrintfEx  StringCbPrintfExW
#else
#define StringCbPrintfEx  StringCbPrintfExA
#endif // !UNICODE

STRSAFEAPI
StringCbPrintfExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    ...)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, pszFormat);

                hr = StringVPrintfWorkerA(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbPrintfExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    ...)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, pszFormat);

                hr = StringVPrintfWorkerW(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#if defined(STRSAFE_LOCALE_FUNCTIONS) && !defined(STRSAFE_NO_CB_FUNCTIONS)
/*++

STDAPI
StringCbPrintf_lEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cbDest,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    __in locale_t locale,
    ...
    );

Routine Description:

    This routine is a version of StringCbPrintfEx that also takes a locale.
    Please seee notes for StringCbPrintfEx above.

--*/
#ifdef UNICODE
#define StringCbPrintf_lEx  StringCbPrintf_lExW
#else
#define StringCbPrintf_lEx  StringCbPrintf_lExA
#endif // !UNICODE

STRSAFEAPI
StringCbPrintf_lExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    ...)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, locale);

                hr = StringVPrintf_lWorkerA(pszDest,
                                            cchDest,
                                            &cchNewDestLength,
                                            pszFormat,
                                            locale,
                                            argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbPrintf_lExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    ...)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;
                va_list argList;

                va_start(argList, locale);

                hr = StringVPrintf_lWorkerW(pszDest,
                                            cchDest,
                                            &cchNewDestLength,
                                            pszFormat,
                                            locale,
                                            argList);

                va_end(argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS && !STRSAFE_NO_CB_FUNCTIONS

#endif  // !_M_CEE_PURE


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchVPrintfEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cchDest,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    __in va_list argList
    );


Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCchVPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return
                        the number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    argList         -   va_list from the variable arguments according to the
                        stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCchVPrintfEx  StringCchVPrintfExW
#else
#define StringCchVPrintfEx  StringCchVPrintfExA
#endif // !UNICODE

STRSAFEAPI
StringCchVPrintfExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                hr = StringVPrintfWorkerA(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchVPrintfExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                hr = StringVPrintfWorkerW(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#if defined(STRSAFE_LOCALE_FUNCTIONS) && !defined(STRSAFE_NO_CCH_FUNCTIONS)
/*++

STDAPI
StringCchVPrintf_lEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cchDest,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    __in locale_t locale,
    __in va_list argList
    );

Routine Description:

    This routine is a version of StringCchVPrintfEx that also takes a locale.
    Please see notes for StringCchVPrintfEx above.

--*/
#ifdef UNICODE
#define StringCchVPrintf_lEx    StringCchVPrintf_lExW
#else
#define StringCchVPrintf_lEx    StringCchVPrintf_lExA
#endif // !UNICODE

STRSAFEAPI
StringCchVPrintf_lExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);
        
        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                hr = StringVPrintf_lWorkerA(pszDest,
                                            cchDest,
                                            &cchNewDestLength,
                                            pszFormat,
                                            locale,
                                            argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = cchRemaining * sizeof(char);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchVPrintf_lExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                hr = StringVPrintf_lWorkerW(pszDest,
                                            cchDest,
                                            &cchNewDestLength,
                                            pszFormat,
                                            locale,
                                            argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = cchRemaining * sizeof(wchar_t);

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS && !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbVPrintfEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cbDest,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    __in va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters.  In addition to functionality provided by
    StringCbVPrintf, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.
                        length must be sufficient to contain the resulting
                        formatted string plus the null terminator.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return
                        a pointer to the end of the destination string.  If the
                        function printed any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return
                        the number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT(""))

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated. This will overwrite any truncated
                    string returned when the failure is
                    STRSAFE_E_INSUFFICIENT_BUFFER

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string. This will overwrite any truncated string
                    returned when the failure is STRSAFE_E_INSUFFICIENT_BUFFER.

    pszFormat       -   format string which must be null terminated

    argList         -   va_list from the variable arguments according to the
                        stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    pszDest and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both pszDest and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    S_OK           -   if there was source data and it was all concatenated and
                       the resultant dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result and is
                       null terminated. This is useful for situations where
                       truncation is ok.

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function

--*/
#ifdef UNICODE
#define StringCbVPrintfEx  StringCbVPrintfExW
#else
#define StringCbVPrintfEx  StringCbVPrintfExA
#endif // !UNICODE

STRSAFEAPI
StringCbVPrintfExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                hr = StringVPrintfWorkerA(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbVPrintfExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                hr = StringVPrintfWorkerW(pszDest,
                                          cchDest,
                                          &cchNewDestLength,
                                          pszFormat,
                                          argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#if defined(STRSAFE_LOCALE_FUNCTIONS) && !defined(STRSAFE_NO_CB_FUNCTIONS)
/*++

STDAPI
StringCbVPrintf_lEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cbDest,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in DWORD   dwFlags,
    __in __format_string LPCTSTR pszFormat       OPTIONAL,
    __in locale_t locale,
    __in va_list argList
    );

Routine Description:

    This routine is a version of StringCbVPrintfEx that also takes a locale.
    Please see notes for StringCbVPrintfEx above.

--*/
#ifdef UNICODE
#define StringCbVPrintf_lEx StringCbVPrintf_lExW
#else
#define StringCbVPrintf_lEx StringCbVPrintf_lExA
#endif // !UNICODE

STRSAFEAPI
StringCbVPrintf_lExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcA(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = '\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != '\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                hr = StringVPrintf_lWorkerA(pszDest,
                                            cchDest,
                                            &cchNewDestLength,
                                            pszFormat,
                                            locale,
                                            argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr)                           &&
                    (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                    (cchRemaining > 1))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                    cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbVPrintf_lExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        hr = StringExValidateSrcW(&pszFormat, NULL, STRSAFE_MAX_CCH, dwFlags);

        if (SUCCEEDED(hr))
        {
            if (dwFlags & (~STRSAFE_VALID_FLAGS))
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
                
                if (cchDest != 0)
                {
                    *pszDest = L'\0';
                }
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        hr = STRSAFE_E_INVALID_PARAMETER;
                    }
                    else
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                    }
                }
            }
            else
            {
                size_t cchNewDestLength = 0;

                hr = StringVPrintf_lWorkerW(pszDest,
                                            cchDest,
                                            &cchNewDestLength,
                                            pszFormat,
                                            locale,
                                            argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;

                if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
                {
                    size_t cbRemaining;
                    
                    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                    cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                    // handle the STRSAFE_FILL_BEHIND_NULL flag
                    StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
                }
            }
        }
        else
        {
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr) || (hr == STRSAFE_E_INSUFFICIENT_BUFFER))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS && !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_LIB_IMPL

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchGets(
    __out_ecount(cchDest) LPTSTR  pszDest,
    __in size_t  cchDest
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets'.
    The size of the destination buffer (in characters) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for fgets.  That function does not replace
    newline characters with a null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if any characters were read from stdin and copied to pszDest and
    pszDest was null terminated, otherwise it will return a failure code.

Arguments:

    pszDest     -   destination string

    cchDest     -   size of destination buffer in characters.

Notes:
    pszDest should not be NULL. See StringCchGetsEx if you require the handling
    of NULL values.

    cchDest must be > 1 for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCchGets  StringCchGetsW
#else
#define StringCchGets  StringCchGetsA
#endif // !UNICODE

STRSAFEAPI
StringCchGetsA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest)
{
    HRESULT hr;

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringGetsWorkerA(pszDest, cchDest, NULL);
    }

    return hr;
}

STRSAFEAPI
StringCchGetsW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest)
{
    HRESULT hr;

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringGetsWorkerW(pszDest, cchDest, NULL);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbGets(
    __out_bcount(cbDest) LPTSTR  pszDest,
    __in size_t  cbDest
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets'.
    The size of the destination buffer (in bytes) is a parameter and
    this function will not write past the end of this buffer and it will
    ALWAYS null terminate the destination buffer (unless it is zero length).

    This routine is not a replacement for fgets.  That function does not replace
    newline characters with a null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if any characters were read from stdin and copied to pszDest
    and pszDest was null terminated, otherwise it will return a failure code.

Arguments:

    pszDest     -   destination string

    cbDest      -   size of destination buffer in bytes.

Notes:
    pszDest should not be NULL. See StringCbGetsEx if you require the handling
    of NULL values.

    cbDest must be > sizeof(TCHAR) for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCbGets  StringCbGetsW
#else
#define StringCbGets  StringCbGetsA
#endif // !UNICODE

STRSAFEAPI
StringCbGetsA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringValidateDestA(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringGetsWorkerA(pszDest, cchDest, NULL);
    }

    return hr;
}

STRSAFEAPI
StringCbGetsW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringValidateDestW(pszDest, cchDest, NULL, STRSAFE_MAX_CCH);
    
    if (SUCCEEDED(hr))
    {
        hr = StringGetsWorkerW(pszDest, cchDest, NULL);
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchGetsEx(
    __out_ecount(cchDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cchDest,
    __deref_opt_out_ecount(*pcchRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcchRemaining   OPTIONAL,
    __in DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets' with
    some additional parameters. In addition to functionality provided by
    StringCchGets, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cchDest         -   size of destination buffer in characters.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcchRemaining   -   if pcchRemaining is non-null, the function will return the
                        number of characters left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated.

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string.

Notes:
    pszDest should not be NULL unless the STRSAFE_IGNORE_NULLS flag is specified.
    If STRSAFE_IGNORE_NULLS is passed and pszDest is NULL, an error may still be
    returned even though NULLS are ignored

    cchDest must be > 1 for this function to succeed.

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCchGetsEx  StringCchGetsExW
#else
#define StringCchGetsEx  StringCchGetsExA
#endif // !UNICODE

STRSAFEAPI
StringCchGetsExA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        if (dwFlags & (~STRSAFE_VALID_FLAGS))
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
            
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }
        else if (cchDest == 0)
        {
            if (pszDest == NULL)
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            size_t cchNewDestLength = 0;

            hr = StringGetsWorkerA(pszDest, cchDest, &cchNewDestLength);

            pszDestEnd = pszDest + cchNewDestLength;
            cchRemaining = cchDest - cchNewDestLength;

            if (SUCCEEDED(hr)                           &&
                (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                (cchRemaining > 1))
            {
                size_t cbRemaining;
                
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                cbRemaining = cchRemaining * sizeof(char);

                // handle the STRSAFE_FILL_BEHIND_NULL flag
                StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(char) since cchDest < STRSAFE_MAX_CCH and sizeof(char) is 1
            cbDest = cchDest * sizeof(char);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr)                           ||
            (hr == STRSAFE_E_INSUFFICIENT_BUFFER)   ||
            (hr == STRSAFE_E_END_OF_FILE))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCchGetsExW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __deref_opt_out_ecount(*pcchRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        if (dwFlags & (~STRSAFE_VALID_FLAGS))
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
            
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }
        else if (cchDest == 0)
        {
            if (pszDest == NULL)
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            size_t cchNewDestLength = 0;

            hr = StringGetsWorkerW(pszDest, cchDest, &cchNewDestLength);

            pszDestEnd = pszDest + cchNewDestLength;
            cchRemaining = cchDest - cchNewDestLength;

            if (SUCCEEDED(hr)                           &&
                (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                (cchRemaining > 1))
            {
                size_t cbRemaining;
                
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                cbRemaining = cchRemaining * sizeof(wchar_t);

                // handle the STRSAFE_FILL_BEHIND_NULL flag
                StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cchDest != 0))
        {
            size_t cbDest;

            // safe to multiply cchDest * sizeof(wchar_t) since cchDest < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            cbDest = cchDest * sizeof(wchar_t);

            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr)                           ||
            (hr == STRSAFE_E_INSUFFICIENT_BUFFER)   ||
            (hr == STRSAFE_E_END_OF_FILE))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
        
            if (pcchRemaining)
            {
                *pcchRemaining = cchRemaining;
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbGetsEx(
    __out_bcount(cbDest) LPTSTR  pszDest         OPTIONAL,
    __in size_t  cbDest,
    __deref_opt_out_bcount(*pcbRemaining) LPTSTR* ppszDestEnd     OPTIONAL,
    __out_opt size_t* pcbRemaining    OPTIONAL,
    __in DWORD   dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'gets' with
    some additional parameters. In addition to functionality provided by
    StringCbGets, this routine also returns a pointer to the end of the
    destination string and the number of characters left in the destination string
    including the null terminator. The flags parameter allows additional controls.

Arguments:

    pszDest         -   destination string

    cbDest          -   size of destination buffer in bytes.

    ppszDestEnd     -   if ppszDestEnd is non-null, the function will return a
                        pointer to the end of the destination string.  If the
                        function copied any data, the result will point to the
                        null termination character

    pcbRemaining    -   if pcbRemaining is non-null, the function will return the
                        number of bytes left in the destination string,
                        including the null terminator

    dwFlags         -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND_NULL
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer
                    behind the null terminator

        STRSAFE_IGNORE_NULLS
                    treat NULL string pointers like empty strings (TEXT("")).

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer, and it will
                    be null terminated.

        STRSAFE_NO_TRUNCATION /
        STRSAFE_NULL_ON_FAILURE
                    if the function fails, the destination buffer will be set
                    to the empty string.

Notes:
    pszDest should not be NULL unless the STRSAFE_IGNORE_NULLS flag is specified.
    If STRSAFE_IGNORE_NULLS is passed and pszDest is NULL, an error may still be
    returned even though NULLS are ignored

    cbDest must be > sizeof(TCHAR) for this function to succeed

Return Value:

    S_OK           -   data was read from stdin and copied, and the resultant
                       dest string was null terminated

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

      STRSAFE_E_END_OF_FILE /
      HRESULT_CODE(hr) == ERROR_HANDLE_EOF
                   -   this return value indicates an error or end-of-file
                       condition, use feof or ferror to determine which one has
                       occured.

      STRSAFE_E_INSUFFICIENT_BUFFER /
      HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER
                   -   this return value is an indication that there was
                       insufficient space in the destination buffer to copy any
                       data

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCbGetsEx  StringCbGetsExW
#else
#define StringCbGetsEx  StringCbGetsExA
#endif // !UNICODE

STRSAFEAPI
StringCbGetsExA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(char);

    hr = StringExValidateDestA(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        if (dwFlags & (~STRSAFE_VALID_FLAGS))
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
            
            if (cchDest != 0)
            {
                *pszDest = '\0';
            }
        }
        else if (cchDest == 0)
        {
            if (pszDest == NULL)
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            size_t cchNewDestLength = 0;

            hr = StringGetsWorkerA(pszDest, cchDest, &cchNewDestLength);

            pszDestEnd = pszDest + cchNewDestLength;
            cchRemaining = cchDest - cchNewDestLength;
            
            if (SUCCEEDED(hr)                           &&
                (dwFlags & STRSAFE_FILL_BEHIND_NULL)    &&
                (cchRemaining > 1))
            {
                size_t cbRemaining;
                
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                cbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));

                // handle the STRSAFE_FILL_BEHIND_NULL flag
                StringExHandleFillBehindNullA(pszDestEnd, cbRemaining, dwFlags);
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsA(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr)                           ||
            (hr == STRSAFE_E_INSUFFICIENT_BUFFER)   ||
            (hr == STRSAFE_E_END_OF_FILE))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(char) since cchRemaining < STRSAFE_MAX_CCH and sizeof(char) is 1
                *pcbRemaining = (cchRemaining * sizeof(char)) + (cbDest % sizeof(char));
            }
        }
    }

    return hr;
}

STRSAFEAPI
StringCbGetsExW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __deref_opt_out_bcount(*pcbRemaining) STRSAFE_LPWSTR* ppszDestEnd,
    __out_opt size_t* pcbRemaining,
    __in DWORD dwFlags)
{
    HRESULT hr;
    size_t cchDest = cbDest / sizeof(wchar_t);

    hr = StringExValidateDestW(&pszDest,
                               &cchDest,
                               NULL,
                               STRSAFE_MAX_CCH,
                               dwFlags);
    
    if (SUCCEEDED(hr))
    {
        STRSAFE_LPWSTR pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;

        if (dwFlags & (~STRSAFE_VALID_FLAGS))
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
            
            if (cchDest != 0)
            {
                *pszDest = L'\0';
            }
        }
        else if (cchDest == 0)
        {
            if (pszDest == NULL)
            {
                hr = STRSAFE_E_INVALID_PARAMETER;
            }
            else
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            size_t cchNewDestLength = 0;

            hr = StringGetsWorkerW(pszDest, cchDest, &cchNewDestLength);

            pszDestEnd = pszDest + cchNewDestLength;
            cchRemaining = cchDest - cchNewDestLength;

            if (SUCCEEDED(hr) && (dwFlags & STRSAFE_FILL_BEHIND_NULL))
            {
                size_t cbRemaining;
                
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                cbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));

                // handle the STRSAFE_FILL_BEHIND_NULL flag
                StringExHandleFillBehindNullW(pszDestEnd, cbRemaining, dwFlags);
            }
        }

        if (FAILED(hr)                                                                              &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_NULL_ON_FAILURE)) &&
            (cbDest != 0))
        {
            // handle the STRSAFE_FILL_ON_FAILURE, STRSAFE_NULL_ON_FAILURE, and STRSAFE_NO_TRUNCATION flags
            StringExHandleOtherFlagsW(pszDest,
                                      cbDest,
                                      0,
                                      &pszDestEnd,
                                      &cchRemaining,
                                      dwFlags);
        }

        if (SUCCEEDED(hr)                           ||
            (hr == STRSAFE_E_INSUFFICIENT_BUFFER)   ||
            (hr == STRSAFE_E_END_OF_FILE))
        {
            if (ppszDestEnd)
            {
                *ppszDestEnd = pszDestEnd;
            }
            
            if (pcbRemaining)
            {
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
                *pcbRemaining = (cchRemaining * sizeof(wchar_t)) + (cbDest % sizeof(wchar_t));
            }
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#endif  // !STRSAFE_LIB_IMPL

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
StringCchLength(
    __in_opt LPCTSTR psz         OPTIONAL,
    __in size_t  cchMax,
    __out_opt size_t* pcchLength  OPTIONAL
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strlen'.
    It is used to make sure a string is not larger than a given length, and
    it optionally returns the current length in characters not including
    the null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string is non-null and the length including the null
    terminator is less than or equal to cchMax characters.

Arguments:

    psz         -   string to check the length of

    cchMax      -   maximum number of characters including the null terminator
                    that psz is allowed to contain

    pcch        -   if the function succeeds and pcch is non-null, the current length
                    in characters of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz)

Notes:
    psz can be null but the function will fail

    cchMax should be greater than zero or the function will fail

Return Value:

    S_OK           -   psz is non-null and the length including the null
                       terminator is less than or equal to cchMax characters

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCchLength  StringCchLengthW
#else
#define StringCchLength  StringCchLengthA
#endif // !UNICODE

STRSAFEAPI
StringCchLengthA(
    __in_opt STRSAFE_LPCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerA(psz, cchMax, pcchLength);
    }
    
    if (FAILED(hr) && pcchLength)
    {
        *pcchLength = 0;
    }

    return hr;
}

STRSAFEAPI
StringCchLengthW(
    __in_opt STRSAFE_LPCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerW(psz, cchMax, pcchLength);
    }
    
    if (FAILED(hr) && pcchLength)
    {
        *pcchLength = 0;
    }

    return hr;
}
#endif  // !STRSAFE_NO_CCH_FUNCTIONS


#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
StringCbLength(
    __in_opt LPCTSTR psz,        OPTIONAL
    __in size_t  cbMax,
    __out_opt size_t* pcbLength   OPTIONAL
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strlen'.
    It is used to make sure a string is not larger than a given length, and
    it optionally returns the current length in bytes not including
    the null terminator.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string is non-null and the length including the null
    terminator is less than or equal to cbMax bytes.

Arguments:

    psz         -   string to check the length of

    cbMax       -   maximum number of bytes including the null terminator
                    that psz is allowed to contain

    pcb         -   if the function succeeds and pcb is non-null, the current length
                    in bytes of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz) * sizeof(TCHAR)

Notes:
    psz can be null but the function will fail

    cbMax should be greater than or equal to sizeof(TCHAR) or the function will fail

Return Value:

    S_OK           -   psz is non-null and the length including the null
                       terminator is less than or equal to cbMax bytes

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define StringCbLength  StringCbLengthW
#else
#define StringCbLength  StringCbLengthA
#endif // !UNICODE

STRSAFEAPI
StringCbLengthA(
    __in_opt STRSAFE_LPCSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength)
{
    HRESULT hr;
    size_t cchMax = cbMax / sizeof(char);
    size_t cchLength = 0;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerA(psz, cchMax, &cchLength);
    }

    if (pcbLength)
    {
        if (SUCCEEDED(hr))
        {
             // safe to multiply cchLength * sizeof(char) since cchLength < STRSAFE_MAX_CCH and sizeof(char) is 1
            *pcbLength = cchLength * sizeof(char);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return hr;
}

STRSAFEAPI
StringCbLengthW(
    __in_opt STRSAFE_LPCWSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength)
{
    HRESULT hr;
    size_t cchMax = cbMax / sizeof(wchar_t);
    size_t cchLength = 0;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = StringLengthWorkerW(psz, cchMax, &cchLength);
    }

    if (pcbLength)
    {
        if (SUCCEEDED(hr))
        {
            // safe to multiply cchLength * sizeof(wchar_t) since cchLength < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbLength = cchLength * sizeof(wchar_t);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return hr;
}
#endif  // !STRSAFE_NO_CB_FUNCTIONS

#ifndef STRSAFE_NO_CCH_FUNCTIONS
/*++

STDAPI
UnalignedStringCchLength(
    __in_opt LPCUTSTR    psz         OPTIONAL,
    __in size_t      cchMax,
    __out_opt size_t*     pcchLength  OPTIONAL
    );

Routine Description:

    This routine is a version of StringCchLength that accepts an unaligned string pointer.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string is non-null and the length including the null
    terminator is less than or equal to cchMax characters.

Arguments:

    psz         -   string to check the length of

    cchMax      -   maximum number of characters including the null terminator
                    that psz is allowed to contain

    pcch        -   if the function succeeds and pcch is non-null, the current length
                    in characters of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz)

Notes:
    psz can be null but the function will fail

    cchMax should be greater than zero or the function will fail

Return Value:

    S_OK           -   psz is non-null and the length including the null
                       terminator is less than or equal to cchMax characters

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define UnalignedStringCchLength    UnalignedStringCchLengthW
#else
#define UnalignedStringCchLength    StringCchLengthA
#endif // !UNICODE

#ifdef ALIGNMENT_MACHINE
STRSAFEAPI
UnalignedStringCchLengthW(
    __in_opt STRSAFE_LPCUWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = UnalignedStringLengthWorkerW(psz, cchMax, pcchLength);
    }
    
    if (FAILED(hr) && pcchLength)
    {
        *pcchLength = 0;
    }

    return hr;
}
#else
#define UnalignedStringCchLengthW   StringCchLengthW
#endif  // !ALIGNMENT_MACHINE
#endif  // !STRSAFE_NO_CCH_FUNCTIONS

#ifndef STRSAFE_NO_CB_FUNCTIONS
/*++

STDAPI
UnalignedStringCbLength(
    __in_opt LPCUTSTR    psz,        OPTIONAL
    __in size_t      cbMax,
    __out_opt size_t*     pcbLength   OPTIONAL
    );

Routine Description:

    This routine is a version of StringCbLength that accepts an unaligned string pointer.

    This function returns a hresult, and not a pointer.  It returns
    S_OK if the string is non-null and the length including the null
    terminator is less than or equal to cbMax bytes.

Arguments:

    psz         -   string to check the length of

    cbMax       -   maximum number of bytes including the null terminator
                    that psz is allowed to contain

    pcb         -   if the function succeeds and pcb is non-null, the current length
                    in bytes of psz excluding the null terminator will be returned.
                    This out parameter is equivalent to the return value of strlen(psz) * sizeof(TCHAR)

Notes:
    psz can be null but the function will fail

    cbMax should be greater than or equal to sizeof(TCHAR) or the function will fail

Return Value:

    S_OK           -   psz is non-null and the length including the null
                       terminator is less than or equal to cbMax bytes

    failure        -   you can use the macro HRESULT_CODE() to get a win32
                       error code for all hresult failure cases

    It is strongly recommended to use the SUCCEEDED() / FAILED() macros to test the
    return value of this function.

--*/
#ifdef UNICODE
#define UnalignedStringCbLength UnalignedStringCbLengthW
#else
#define UnalignedStringCbLength StringCbLengthA
#endif // !UNICODE

#ifdef ALIGNMENT_MACHINE
STRSAFEAPI
UnalignedStringCbLengthW(
    __in_opt STRSAFE_LPCUWSTR psz,
    __in size_t cbMax,
    __out_opt size_t* pcbLength)
{
    HRESULT hr;
    size_t cchMax = cbMax / sizeof(wchar_t);
    size_t cchLength = 0;

    if ((psz == NULL) || (cchMax > STRSAFE_MAX_CCH))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else
    {
        hr = UnalignedStringLengthWorkerW(psz, cchMax, &cchLength);
    }

    if (pcbLength)
    {
        if (SUCCEEDED(hr))
        {
            // safe to multiply cchLength * sizeof(wchar_t) since cchLength < STRSAFE_MAX_CCH and sizeof(wchar_t) is 2
            *pcbLength = cchLength * sizeof(wchar_t);
        }
        else
        {
            *pcbLength = 0;
        }
    }

    return hr;
}
#else
#define UnalignedStringCbLengthW    StringCbLengthW
#endif  // !ALIGNMENT_MACHINE
#endif  // !STRSAFE_NO_CB_FUNCTIONS


#endif  // !STRSAFE_LIB_IMPL


// Below here are the worker functions that actually do the work

#if defined(STRSAFE_LIB_IMPL) || !defined(STRSAFE_LIB)

STRSAFEWORKERAPI
StringLengthWorkerA(
    __in STRSAFE_LPCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr = S_OK;
    size_t cchOriginalMax = cchMax;

    while (cchMax && (*psz != '\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (pcchLength)
    {
        if (SUCCEEDED(hr))
        {
            *pcchLength = cchOriginalMax - cchMax;
        }
        else
        {
            *pcchLength = 0;
        }
    }

    return hr;
}

STRSAFEWORKERAPI
StringLengthWorkerW(
    __in STRSAFE_LPCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr = S_OK;
    size_t cchOriginalMax = cchMax;

    while (cchMax && (*psz != L'\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (pcchLength)
    {
        if (SUCCEEDED(hr))
        {
            *pcchLength = cchOriginalMax - cchMax;
        }
        else
        {
            *pcchLength = 0;
        }
    }

    return hr;
}

#ifdef ALIGNMENT_MACHINE
STRSAFEWORKERAPI
UnalignedStringLengthWorkerW(
    __in STRSAFE_LPCUWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    HRESULT hr = S_OK;
    size_t cchOriginalMax = cchMax;

    while (cchMax && (*psz != L'\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (pcchLength)
    {
        if (SUCCEEDED(hr))
        {
            *pcchLength = cchOriginalMax - cchMax;
        }
        else
        {
            *pcchLength = 0;
        }
    }

    return hr;
}
#endif  // ALIGNMENT_MACHINE

STRSAFEWORKERAPI
StringExValidateSrcA(
    __deref_inout_opt STRSAFE_LPCSTR* ppszSrc,
    __inout_opt size_t* pcchToRead,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (pcchToRead && (*pcchToRead >= cchMax))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else if ((dwFlags & STRSAFE_IGNORE_NULLS) && (*ppszSrc == NULL))
    {
        *ppszSrc = "";

        if (pcchToRead)
        {
            *pcchToRead = 0;
        }
    }
    
    return hr;
}

STRSAFEWORKERAPI
StringExValidateSrcW(
    __deref_inout_opt STRSAFE_LPCWSTR* ppszSrc,
    __inout_opt size_t* pcchToRead,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (pcchToRead && (*pcchToRead >= cchMax))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }
    else if ((dwFlags & STRSAFE_IGNORE_NULLS) && (*ppszSrc == NULL))
    {
        *ppszSrc = L"";
        
        if (pcchToRead)
        {
            *pcchToRead = 0;
        }
    }

    return hr;
}

STRSAFEWORKERAPI
StringValidateDestA(
    __in_ecount_opt(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax)
{
    HRESULT hr = S_OK;

    if ((cchDest == 0) || (cchDest > cchMax))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (pcchDestLength)
    {
        if (SUCCEEDED(hr))
        {
            hr = StringLengthWorkerA(pszDest, cchDest, pcchDestLength);
        }
        else
        {
            *pcchDestLength = 0;
        }
    }

    return hr;
}

STRSAFEWORKERAPI
StringValidateDestW(
    __in_ecount_opt(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax)
{
    HRESULT hr = S_OK;

    if ((cchDest == 0) || (cchDest > cchMax))
    {
        hr = STRSAFE_E_INVALID_PARAMETER;
    }

    if (pcchDestLength)
    {
        if (SUCCEEDED(hr))
        {
            hr = StringLengthWorkerW(pszDest, cchDest, pcchDestLength);
        }
        else
        {
            *pcchDestLength = 0;
        }
    }

    return hr;
}

STRSAFEWORKERAPI
StringExValidateDestA(
    __deref_inout_opt STRSAFE_LPSTR* ppszDest,
    __inout size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    HRESULT hr = S_OK;
    
    if (dwFlags & STRSAFE_IGNORE_NULLS)
    {
        if (((*ppszDest == NULL) && (*pcchDest != 0))   ||
            (*pcchDest > cchMax))
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
        }
        
        if (pcchDestLength)
        {
            if (FAILED(hr) || (*pcchDest == 0))
            {
                *pcchDestLength = 0;
            }
            else
            {
                hr = StringLengthWorkerA(*ppszDest, *pcchDest, pcchDestLength);
            }
        }
    }
    else
    {
        hr = StringValidateDestA(*ppszDest, *pcchDest, pcchDestLength, cchMax);
    }

    return hr;
}

STRSAFEWORKERAPI
StringExValidateDestW(
    __deref_inout_opt STRSAFE_LPWSTR* ppszDest,
    __inout size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    HRESULT hr = S_OK;
    
    if (dwFlags & STRSAFE_IGNORE_NULLS)
    {
        if (((*ppszDest == NULL) && (*pcchDest != 0))   ||
            (*pcchDest > cchMax))
        {
            hr = STRSAFE_E_INVALID_PARAMETER;
        }
        
        if (pcchDestLength)
        {
            if (FAILED(hr) || (*pcchDest == 0))
            {
                *pcchDestLength = 0;
            }
            else
            {
                hr = StringLengthWorkerW(*ppszDest, *pcchDest, pcchDestLength);
            }
        }
    }
    else
    {
        hr = StringValidateDestW(*ppszDest, *pcchDest, pcchDestLength, cchMax);
    }

    return hr;
}

STRSAFEWORKERAPI
StringCopyWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in STRSAFE_LPCSTR pszSrc,
    __in size_t cchToCopy)
{
    HRESULT hr = S_OK;
    size_t cchNewDestLength = 0;
    
    // ASSERT(cchDest != 0);

    while (cchDest && cchToCopy && (*pszSrc != '\0'))
    {
        *pszDest++ = *pszSrc++;
        cchDest--;
        cchToCopy--;

        cchNewDestLength++;
    }

    if (cchDest == 0)
    {
        // we are going to truncate pszDest
        pszDest--;
        cchNewDestLength--;

        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }

    *pszDest= '\0';

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return hr;
}

STRSAFEWORKERAPI
StringCopyWorkerW(
    __out_ecount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in STRSAFE_LPCWSTR pszSrc,
    __in size_t cchToCopy)
{
    HRESULT hr = S_OK;
    size_t cchNewDestLength = 0;
    
    // ASSERT(cchDest != 0);

    while (cchDest && cchToCopy && (*pszSrc != L'\0'))
    {
        *pszDest++ = *pszSrc++;
        cchDest--;
        cchToCopy--;

        cchNewDestLength++;
    }

    if (cchDest == 0)
    {
        // we are going to truncate pszDest
        pszDest--;
        cchNewDestLength--;

        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }

    *pszDest= L'\0';

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return hr;
}

STRSAFEWORKERAPI
StringVPrintfWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr = S_OK;
    int iRet;
    size_t cchMax;
    size_t cchNewDestLength = 0;

    // leave the last space for the null terminator
    cchMax = cchDest - 1;

#if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
    iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
#else
    iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
#endif
    // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

    if ((iRet < 0) || (((size_t)iRet) > cchMax))
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = '\0';

        cchNewDestLength = cchMax;

        // we have truncated pszDest
        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }
    else if (((size_t)iRet) == cchMax)
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = '\0';

        cchNewDestLength = cchMax;
    }
    else
    {
        cchNewDestLength = (size_t)iRet;
    }

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return hr;
}

#ifdef STRSAFE_LOCALE_FUNCTIONS
STRSAFELOCALEWORKERAPI
StringVPrintf_lWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string STRSAFE_LPCSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr = S_OK;
    int iRet;
    size_t cchMax;
    size_t cchNewDestLength = 0;

    // leave the last space for the null terminator
    cchMax = cchDest - 1;

#if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
    iRet = _vsnprintf_s_l(pszDest, cchDest, cchMax, pszFormat, locale, argList);
#else
    iRet = _vsnprintf_l(pszDest, cchMax, pszFormat, locale, argList);
#endif
    // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

    if ((iRet < 0) || (((size_t)iRet) > cchMax))
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = '\0';

        cchNewDestLength = cchMax;

        // we have truncated pszDest
        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }
    else if (((size_t)iRet) == cchMax)
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = '\0';

        cchNewDestLength = cchMax;
    }
    else
    {
        cchNewDestLength = (size_t)iRet;
    }

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS

STRSAFEWORKERAPI
StringVPrintfWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in va_list argList)
{
    HRESULT hr = S_OK;
    int iRet;
    size_t cchMax;
    size_t cchNewDestLength = 0;

    // leave the last space for the null terminator
    cchMax = cchDest - 1;

#if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
    iRet = _vsnwprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
#else
    iRet = _vsnwprintf(pszDest, cchMax, pszFormat, argList);
#endif
    // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

    if ((iRet < 0) || (((size_t)iRet) > cchMax))
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = L'\0';

        cchNewDestLength = cchMax;

        // we have truncated pszDest
        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }
    else if (((size_t)iRet) == cchMax)
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = L'\0';

        cchNewDestLength = cchMax;
    }
    else
    {
        cchNewDestLength = (size_t)iRet;
    }

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return hr;
}

#ifdef STRSAFE_LOCALE_FUNCTIONS
STRSAFELOCALEWORKERAPI
StringVPrintf_lWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string STRSAFE_LPCWSTR pszFormat,
    __in _locale_t locale,
    __in va_list argList)
{
    HRESULT hr = S_OK;
    int iRet;
    size_t cchMax;
    size_t cchNewDestLength = 0;

    // leave the last space for the null terminator
    cchMax = cchDest - 1;

#if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
    iRet = _vsnwprintf_s_l(pszDest, cchDest, cchMax, pszFormat, locale, argList);
#else
    iRet = _vsnwprintf_l(pszDest, cchMax, pszFormat, locale, argList);
#endif
    // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

    if ((iRet < 0) || (((size_t)iRet) > cchMax))
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = L'\0';

        cchNewDestLength = cchMax;

        // we have truncated pszDest
        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }
    else if (((size_t)iRet) == cchMax)
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = L'\0';

        cchNewDestLength = cchMax;
    }
    else
    {
        cchNewDestLength = (size_t)iRet;
    }

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return hr;
}
#endif  // STRSAFE_LOCALE_FUNCTIONS

#endif  // defined(STRSAFE_LIB_IMPL) || !defined(STRSAFE_LIB)

#ifndef STRSAFE_LIB_IMPL
// the StringGetsWorkerA/W functions always run inline since we do not want to
// have a different strsafe lib versions each type of c runtime (eg msvcrt,
// libcmt, etc..)

STRSAFEAPI
StringGetsWorkerA(
    __out_ecount(cchDest) STRSAFE_LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength)
{
    HRESULT hr = S_OK;
    size_t cchNewDestLength = 0;

    if (cchDest == 1)
    {
        *pszDest = '\0';

        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }
    else
    {
        while (cchDest > 1)
        {
            char ch;
            int i = getc(stdin);
            
            if (i == EOF)
            {
                if (cchNewDestLength == 0)
                {
                    // we failed to read anything from stdin
                    hr = STRSAFE_E_END_OF_FILE;
                }

                break;
            }
            
            ch = (char)i;

            if (ch == '\n')
            {
                break;
            }

            *pszDest++ = ch;
            cchDest--;

            cchNewDestLength++;
        }

        *pszDest = '\0';
    }

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return hr;
}

STRSAFEAPI
StringGetsWorkerW(
    __out_ecount(cchDest) STRSAFE_LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength)
{
    HRESULT hr = S_OK;
    size_t cchNewDestLength = 0;

    if (cchDest == 1)
    {
        *pszDest = '\0';

        hr = STRSAFE_E_INSUFFICIENT_BUFFER;
    }
    else
    {
        while (cchDest > 1)
        {
            wchar_t ch = getwc(stdin);
            // ASSERT(sizeof(wchar_t) == sizeof(wint_t));
            
            if (ch == WEOF)
            {
                if (cchNewDestLength == 0)
                {
                    // we failed to read anything from stdin
                    hr = STRSAFE_E_END_OF_FILE;
                }

                break;
            }
            
            if (ch == L'\n')
            {
                break;
            }

            *pszDest++ = ch;
            cchDest--;

            cchNewDestLength++;
        }

        *pszDest = L'\0';
    }

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return hr;
}

#endif  // !STRSAFE_LIB_IMPL

#if defined(STRSAFE_LIB_IMPL) || !defined(STRSAFE_LIB)

STRSAFEWORKERAPI
StringExHandleFillBehindNullA(
    __out_bcount(cbRemaining) STRSAFE_LPSTR pszDestEnd,
    __in size_t cbRemaining,
    __in DWORD dwFlags)
{
    if (cbRemaining > sizeof(char))
    {
        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), cbRemaining - sizeof(char));
    }
    
    return S_OK;
}

STRSAFEWORKERAPI
StringExHandleFillBehindNullW(
    __out_bcount(cbRemaining) STRSAFE_LPWSTR pszDestEnd,
    __in size_t cbRemaining,
    __in DWORD dwFlags)
{
    if (cbRemaining > sizeof(wchar_t))
    {
        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), cbRemaining - sizeof(wchar_t));
    }
    
    return S_OK;
}

STRSAFEWORKERAPI
StringExHandleOtherFlagsA(
    __out_bcount(cbDest) STRSAFE_LPSTR pszDest,
    __in size_t cbDest,
    __in size_t cchOriginalDestLength,
    __deref_out_ecount(*pcchRemaining) STRSAFE_LPSTR* ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    size_t cchDest = cbDest / sizeof(char);
    
    if ((cchDest > 0) && (dwFlags & STRSAFE_NO_TRUNCATION))
    {
        char* pszOriginalDestEnd;

        pszOriginalDestEnd = pszDest + cchOriginalDestLength;

        *ppszDestEnd = pszOriginalDestEnd;
        *pcchRemaining = cchDest - cchOriginalDestLength;

        // null terminate the end of the original string
        *pszOriginalDestEnd = '\0';
    }

    if (dwFlags & STRSAFE_FILL_ON_FAILURE)
    {
        memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

        if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
        {
            *ppszDestEnd = pszDest;
            *pcchRemaining = cchDest;
        }
        else if (cchDest > 0)
        {
            char* pszDestEnd;
            
            pszDestEnd = pszDest + cchDest - 1;

            *ppszDestEnd = pszDestEnd;
            *pcchRemaining = 1;

            // null terminate the end of the string
            *pszDestEnd = L'\0';
        }
    }

    if ((cchDest > 0) && (dwFlags & STRSAFE_NULL_ON_FAILURE))
    {
        *ppszDestEnd = pszDest;
        *pcchRemaining = cchDest;

        // null terminate the beginning of the string
        *pszDest = '\0';
    }

    return S_OK;
}

STRSAFEWORKERAPI
StringExHandleOtherFlagsW(
    __out_bcount(cbDest) STRSAFE_LPWSTR pszDest,
    __in size_t cbDest,
    __in size_t cchOriginalDestLength,
    __deref_out_ecount(*pcchRemaining)STRSAFE_LPWSTR* ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    size_t cchDest = cbDest / sizeof(wchar_t);
    
    if ((cchDest > 0) && (dwFlags & STRSAFE_NO_TRUNCATION))
    {
        wchar_t* pszOriginalDestEnd;

        pszOriginalDestEnd = pszDest + cchOriginalDestLength;

        *ppszDestEnd = pszOriginalDestEnd;
        *pcchRemaining = cchDest - cchOriginalDestLength;

        // null terminate the end of the original string
        *pszOriginalDestEnd = L'\0';
    }

    if (dwFlags & STRSAFE_FILL_ON_FAILURE)
    {
        memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

        if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
        {
            *ppszDestEnd = pszDest;
            *pcchRemaining = cchDest;
        }
        else if (cchDest > 0)
        {
            wchar_t* pszDestEnd;
            
            pszDestEnd = pszDest + cchDest - 1;

            *ppszDestEnd = pszDestEnd;
            *pcchRemaining = 1;

            // null terminate the end of the string
            *pszDestEnd = L'\0';
        }
    }

    if ((cchDest > 0) && (dwFlags & STRSAFE_NULL_ON_FAILURE))
    {
        *ppszDestEnd = pszDest;
        *pcchRemaining = cchDest;

        // null terminate the beginning of the string
        *pszDest = L'\0';
    }

    return S_OK;
}


#endif  // defined(STRSAFE_LIB_IMPL) || !defined(STRSAFE_LIB)


// Do not call these functions, they are worker functions for internal use within this file
#ifdef DEPRECATE_SUPPORTED
#pragma deprecated(StringLengthWorkerA)
#pragma deprecated(StringLengthWorkerW)
#pragma deprecated(UnalignedStringLengthWorkerW)
#pragma deprecated(StringExValidateSrcA)
#pragma deprecated(StringExValidateSrcW)
#pragma deprecated(StringValidateDestA)
#pragma deprecated(StringValidateDestW)
#pragma deprecated(StringExValidateDestA)
#pragma deprecated(StringExValidateDestW)
#pragma deprecated(StringCopyWorkerA)
#pragma deprecated(StringCopyWorkerW)
#pragma deprecated(StringVPrintfWorkerA)
#pragma deprecated(StringVPrintfWorkerW)
#pragma deprecated(StringGetsWorkerA)
#pragma deprecated(StringGetsWorkerW)
#pragma deprecated(StringExHandleFillBehindNullA)
#pragma deprecated(StringExHandleFillBehindNullW)
#pragma deprecated(StringExHandleOtherFlagsA)
#pragma deprecated(StringExHandleOtherFlagsW)
#else
#define StringLengthWorkerA             StringLengthWorkerA_instead_use_StringCchLengthA_or_StringCbLengthA
#define StringLengthWorkerW             StringLengthWorkerW_instead_use_StringCchLengthW_or_StringCbLengthW
#define UnalignedStringLengthWorkerW    UnalignedStringLengthWorkerW_instead_use_UnalignedStringCchLengthW
#define StringExValidateSrcA            StringExValidateSrcA_do_not_call_this_function
#define StringExValidateSrcW            StringExValidateSrcW_do_not_call_this_function
#define StringValidateDestA             StringValidateDestA_do_not_call_this_function
#define StringValidateDestW             StringValidateDestW_do_not_call_this_function
#define StringExValidateDestA           StringExValidateDestA_do_not_call_this_function
#define StringExValidateDestW           StringExValidateDestW_do_not_call_this_function
#define StringCopyWorkerA               StringCopyWorkerA_instead_use_StringCchCopyA_or_StringCbCopyA
#define StringCopyWorkerW               StringCopyWorkerW_instead_use_StringCchCopyW_or_StringCbCopyW
#define StringVPrintfWorkerA            StringVPrintfWorkerA_instead_use_StringCchVPrintfA_or_StringCbVPrintfA
#define StringVPrintfWorkerW            StringVPrintfWorkerW_instead_use_StringCchVPrintfW_or_StringCbVPrintfW
#define StringGetsWorkerA               StringGetsWorkerA_instead_use_StringCchGetsA_or_StringCbGetsA
#define StringGetsWorkerW               StringGetsWorkerW_instead_use_StringCchGetsW_or_StringCbGetsW
#define StringExHandleFillBehindNullA   StringExHandleFillBehindNullA_do_not_call_this_function
#define StringExHandleFillBehindNullW   StringExHandleFillBehindNullW_do_not_call_this_function
#define StringExHandleOtherFlagsA       StringExHandleOtherFlagsA_do_not_call_this_function
#define StringExHandleOtherFlagsW       StringExHandleOtherFlagsW_do_not_call_this_function
#endif // !DEPRECATE_SUPPORTED


#ifndef STRSAFE_NO_DEPRECATE
// Deprecate all of the unsafe functions to generate compiletime errors. If you do not want
// this then you can #define STRSAFE_NO_DEPRECATE before including this file
#ifdef DEPRECATE_SUPPORTED

// First all the names that are a/w variants (or shouldn't be #defined by now anyway)
#pragma deprecated(lstrcpyA)
#pragma deprecated(lstrcpyW)
#pragma deprecated(lstrcatA)
#pragma deprecated(lstrcatW)
#pragma deprecated(wsprintfA)
#pragma deprecated(wsprintfW)

#pragma deprecated(StrCpyW)
#pragma deprecated(StrCatW)
#pragma deprecated(StrNCatA)
#pragma deprecated(StrNCatW)
#pragma deprecated(StrCatNA)
#pragma deprecated(StrCatNW)

#pragma deprecated(strcpy)
#pragma deprecated(wcscpy)
#pragma deprecated(strcat)
#pragma deprecated(wcscat)
#pragma deprecated(sprintf)
#pragma deprecated(_getws)

// Then all the windows.h names
#undef lstrcpy
#undef lstrcat
#pragma deprecated(lstrcpy)
#pragma deprecated(lstrcat)
#ifdef UNICODE
#define lstrcpy    lstrcpyW
#define lstrcat    lstrcatW
#define wsprintf   wsprintfW
#else
#define lstrcpy    lstrcpyA
#define lstrcat    lstrcatA
#define wsprintf   wsprintfA
#define wvsprintf  wvsprintfA
#endif

// Then the shlwapi names
#undef StrCpyA
#undef StrCpy
#undef StrCatA
#undef StrCat
#undef StrNCat
#undef StrCatN
#pragma deprecated(StrCpyA)
#pragma deprecated(StrCatA)
#pragma deprecated(StrCatN)
#pragma deprecated(StrCpy)
#pragma deprecated(StrCat)
#pragma deprecated(StrNCat)
#define StrCpyA lstrcpyA
#define StrCatA lstrcatA
#define StrCatN StrNCat
#ifdef UNICODE
#define StrCpy  StrCpyW
#define StrCat  StrCatW
#define StrNCat StrNCatW
#else
#define StrCpy  lstrcpyA
#define StrCat  lstrcatA
#define StrNCat StrNCatA
#endif

#undef _tcscpy
#undef _ftcscpy
#undef _tcscat
#undef _ftcscat
#undef _stprintf
#undef _sntprintf
#undef _vstprintf
#undef _vsntprintf
#undef _getts
#pragma deprecated(_tcscpy)
#pragma deprecated(_ftcscpy)
#pragma deprecated(_tcscat)
#pragma deprecated(_ftcscat)
#pragma deprecated(_stprintf)
#pragma deprecated(_sntprintf)
#pragma deprecated(_vstprintf)
#pragma deprecated(_vsntprintf)
#pragma deprecated(_getts)
#ifdef _UNICODE
#define _tcscpy     wcscpy
#define _ftcscpy    wcscpy
#define _tcscat     wcscat
#define _ftcscat    wcscat
#define _stprintf   swprintf
#define _sntprintf  _snwprintf
#define _vstprintf  vswprintf
#define _vsntprintf _vsnwprintf
#define _getts      _getws
#else
#define _tcscpy     strcpy
#define _ftcscpy    strcpy
#define _tcscat     strcat
#define _ftcscat    strcat
#define _stprintf   sprintf
#define _sntprintf  _snprintf
#define _vsntprintf _vsnprintf
#define _getts      gets
#endif

#else // DEPRECATE_SUPPORTED

#undef strcpy
#define strcpy      strcpy_instead_use_StringCchCopyA_or_StringCbCopyA;

#undef wcscpy
#define wcscpy      wcscpy_instead_use_StringCchCopyW_or_StringCbCopyW;

#undef strcat
#define strcat      strcat_instead_use_StringCchCatA_or_StringCbCatA;

#undef wcscat
#define wcscat      wcscat_instead_use_StringCchCatW_or_StringCbCatW;

#undef sprintf
#define sprintf     sprintf_instead_use_StringCchPrintfA_or_StringCbPrintfA;

#undef swprintf
#define swprintf    swprintf_instead_use_StringCchPrintfW_or_StringCbPrintfW;

#undef _snprintf
#define _snprintf   _snprintf_instead_use_StringCchPrintfA_or_StringCbPrintfA;

#undef _snwprintf
#define _snwprintf  _snwprintf_instead_use_StringCchPrintfW_or_StringCbPrintfW;

#undef _vsnprintf
#define _vsnprintf  _vsnprintf_instead_use_StringCchVPrintfA_or_StringCbVPrintfA;

#undef _vsnwprintf
#define _vsnwprintf _vsnwprintf_instead_use_StringCchVPrintfW_or_StringCbVPrintfW;

#undef strcpyA
#define strcpyA     strcpyA_instead_use_StringCchCopyA_or_StringCbCopyA;

#undef strcpyW
#define strcpyW     strcpyW_instead_use_StringCchCopyW_or_StringCbCopyW;

#undef lstrcpy
#define lstrcpy     lstrcpy_instead_use_StringCchCopy_or_StringCbCopy;

#undef lstrcpyA
#define lstrcpyA    lstrcpyA_instead_use_StringCchCopyA_or_StringCbCopyA;

#undef lstrcpyW
#define lstrcpyW    lstrcpyW_instead_use_StringCchCopyW_or_StringCbCopyW;

#undef StrCpy
#define StrCpy      StrCpy_instead_use_StringCchCopy_or_StringCbCopy;

#undef StrCpyA
#define StrCpyA     StrCpyA_instead_use_StringCchCopyA_or_StringCbCopyA;

#undef StrCpyW
#define StrCpyW     StrCpyW_instead_use_StringCchCopyW_or_StringCbCopyW;

#undef _tcscpy
#define _tcscpy     _tcscpy_instead_use_StringCchCopy_or_StringCbCopy;

#undef _ftcscpy
#define _ftcscpy    _ftcscpy_instead_use_StringCchCopy_or_StringCbCopy;

#undef lstrcat
#define lstrcat     lstrcat_instead_use_StringCchCat_or_StringCbCat;

#undef lstrcatA
#define lstrcatA    lstrcatA_instead_use_StringCchCatA_or_StringCbCatA;

#undef lstrcatW
#define lstrcatW    lstrcatW_instead_use_StringCchCatW_or_StringCbCatW;

#undef StrCat
#define StrCat      StrCat_instead_use_StringCchCat_or_StringCbCat;

#undef StrCatA
#define StrCatA     StrCatA_instead_use_StringCchCatA_or_StringCbCatA;

#undef StrCatW
#define StrCatW     StrCatW_instead_use_StringCchCatW_or_StringCbCatW;

#undef StrNCat
#define StrNCat     StrNCat_instead_use_StringCchCatN_or_StringCbCatN;

#undef StrNCatA
#define StrNCatA    StrNCatA_instead_use_StringCchCatNA_or_StringCbCatNA;

#undef StrNCatW
#define StrNCatW    StrNCatW_instead_use_StringCchCatNW_or_StringCbCatNW;

#undef StrCatN
#define StrCatN     StrCatN_instead_use_StringCchCatN_or_StringCbCatN;

#undef StrCatNA
#define StrCatNA    StrCatNA_instead_use_StringCchCatNA_or_StringCbCatNA;

#undef StrCatNW
#define StrCatNW    StrCatNW_instead_use_StringCchCatNW_or_StringCbCatNW;

#undef _tcscat
#define _tcscat     _tcscat_instead_use_StringCchCat_or_StringCbCat;

#undef _ftcscat
#define _ftcscat    _ftcscat_instead_use_StringCchCat_or_StringCbCat;

#undef wsprintf
#define wsprintf    wsprintf_instead_use_StringCchPrintf_or_StringCbPrintf;

#undef wsprintfA
#define wsprintfA   wsprintfA_instead_use_StringCchPrintfA_or_StringCbPrintfA;

#undef wsprintfW
#define wsprintfW   wsprintfW_instead_use_StringCchPrintfW_or_StringCbPrintfW;

#undef _vstprintf
#define _vstprintf  _vstprintf_instead_use_StringCchVPrintf_or_StringCbVPrintf;

#undef _vsntprintf
#define _vsntprintf _vsntprintf_instead_use_StringCchVPrintf_or_StringCbVPrintf;

#undef _stprintf
#define _stprintf   _stprintf_instead_use_StringCchPrintf_or_StringCbPrintf;

#undef _sntprintf
#define _sntprintf  _sntprintf_instead_use_StringCchPrintf_or_StringCbPrintf;

#undef _getts
#define _getts      _getts_instead_use_StringCchGets_or_StringCbGets;

#undef gets
#define gets        _gets_instead_use_StringCchGetsA_or_StringCbGetsA;

#undef _getws
#define _getws      _getws_instead_use_StringCchGetsW_or_StringCbGetsW;

#endif  // DEPRECATE_SUPPORTED
#endif  // !STRSAFE_NO_DEPRECATE

#pragma warning(pop)

#endif  // _STRSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\subscriptionservices.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for subscriptionservicespri.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __subscriptionservicespri_h__
#define __subscriptionservicespri_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMPSubscriptionService_FWD_DEFINED__
#define __IWMPSubscriptionService_FWD_DEFINED__
typedef interface IWMPSubscriptionService IWMPSubscriptionService;
#endif 	/* __IWMPSubscriptionService_FWD_DEFINED__ */


#ifndef __IWMPSubscriptionServiceCallback_FWD_DEFINED__
#define __IWMPSubscriptionServiceCallback_FWD_DEFINED__
typedef interface IWMPSubscriptionServiceCallback IWMPSubscriptionServiceCallback;
#endif 	/* __IWMPSubscriptionServiceCallback_FWD_DEFINED__ */


#ifndef __IWMPSubscriptionService2_FWD_DEFINED__
#define __IWMPSubscriptionService2_FWD_DEFINED__
typedef interface IWMPSubscriptionService2 IWMPSubscriptionService2;
#endif 	/* __IWMPSubscriptionService2_FWD_DEFINED__ */


#ifndef __IWMPDownloadItem_FWD_DEFINED__
#define __IWMPDownloadItem_FWD_DEFINED__
typedef interface IWMPDownloadItem IWMPDownloadItem;
#endif 	/* __IWMPDownloadItem_FWD_DEFINED__ */


#ifndef __IWMPDownloadItem2_FWD_DEFINED__
#define __IWMPDownloadItem2_FWD_DEFINED__
typedef interface IWMPDownloadItem2 IWMPDownloadItem2;
#endif 	/* __IWMPDownloadItem2_FWD_DEFINED__ */


#ifndef __IWMPDownloadCollection_FWD_DEFINED__
#define __IWMPDownloadCollection_FWD_DEFINED__
typedef interface IWMPDownloadCollection IWMPDownloadCollection;
#endif 	/* __IWMPDownloadCollection_FWD_DEFINED__ */


#ifndef __IWMPDownloadManager_FWD_DEFINED__
#define __IWMPDownloadManager_FWD_DEFINED__
typedef interface IWMPDownloadManager IWMPDownloadManager;
#endif 	/* __IWMPDownloadManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "wmp.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_subscriptionservicespri_0000_0000 */
/* [local] */ 

//=========================================================================
//
// Microsoft Windows Media Technologies
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//=========================================================================
#ifndef SUBSCRIPTION_CAP_ALLOWPLAY
#define SUBSCRIPTION_CAP_ALLOWPLAY              0x00000001
#endif
#ifndef SUBSCRIPTION_CAP_ALLOWCDBURN
#define SUBSCRIPTION_CAP_ALLOWCDBURN            0x00000002
#endif
#ifndef SUBSCRIPTION_CAP_ALLOWPDATRANSFER
#define SUBSCRIPTION_CAP_ALLOWPDATRANSFER       0x00000004
#endif
#ifndef SUBSCRIPTION_CAP_BACKGROUNDPROCESSING
#define SUBSCRIPTION_CAP_BACKGROUNDPROCESSING   0x00000008
#endif
#ifndef SUBSCRIPTION_CAP_DEVICEAVAILABLE
#define SUBSCRIPTION_CAP_DEVICEAVAILABLE        0x00000010
#endif
#ifndef SUBSCRIPTION_CAP_PREPAREFORSYNC
#define SUBSCRIPTION_CAP_PREPAREFORSYNC         0x00000020
#endif
#ifndef SUBSCRIPTION_CAP_IS_CONTENTPARTNER
#define SUBSCRIPTION_CAP_IS_CONTENTPARTNER      0x00000040
#endif
#ifndef SUBSCRIPTION_CAP_ALTLOGIN
#define SUBSCRIPTION_CAP_ALTLOGIN      0x00000080
#endif
#ifndef SUBSCRIPTION_V1_CAPS
#define SUBSCRIPTION_V1_CAPS                    0x0000000F
#endif
#ifndef SUBSCRIPTION_CAP_UILESSMODE_ALLOWPLAY
#define SUBSCRIPTION_CAP_UILESSMODE_ALLOWPLAY     0x00000100
#endif
typedef /* [public][helpstring] */ 
enum WMPSubscriptionServiceEvent
    {	wmpsseCurrentBegin	= 1,
	wmpsseCurrentEnd	= 2,
	wmpsseFullBegin	= 3,
	wmpsseFullEnd	= 4
    } 	WMPSubscriptionServiceEvent;



extern RPC_IF_HANDLE __MIDL_itf_subscriptionservicespri_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_subscriptionservicespri_0000_0000_v0_0_s_ifspec;

#ifndef __IWMPSubscriptionService_INTERFACE_DEFINED__
#define __IWMPSubscriptionService_INTERFACE_DEFINED__

/* interface IWMPSubscriptionService */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPSubscriptionService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("376055F8-2A59-4a73-9501-DCA5273A7A10")
    IWMPSubscriptionService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE allowPlay( 
            HWND hwnd,
            IWMPMedia *pMedia,
            BOOL *pfAllowPlay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE allowCDBurn( 
            HWND hwnd,
            IWMPPlaylist *pPlaylist,
            BOOL *pfAllowBurn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE allowPDATransfer( 
            HWND hwnd,
            IWMPPlaylist *pPlaylist,
            BOOL *pfAllowTransfer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startBackgroundProcessing( 
            HWND hwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPSubscriptionServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPSubscriptionService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPSubscriptionService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPSubscriptionService * This);
        
        HRESULT ( STDMETHODCALLTYPE *allowPlay )( 
            IWMPSubscriptionService * This,
            HWND hwnd,
            IWMPMedia *pMedia,
            BOOL *pfAllowPlay);
        
        HRESULT ( STDMETHODCALLTYPE *allowCDBurn )( 
            IWMPSubscriptionService * This,
            HWND hwnd,
            IWMPPlaylist *pPlaylist,
            BOOL *pfAllowBurn);
        
        HRESULT ( STDMETHODCALLTYPE *allowPDATransfer )( 
            IWMPSubscriptionService * This,
            HWND hwnd,
            IWMPPlaylist *pPlaylist,
            BOOL *pfAllowTransfer);
        
        HRESULT ( STDMETHODCALLTYPE *startBackgroundProcessing )( 
            IWMPSubscriptionService * This,
            HWND hwnd);
        
        END_INTERFACE
    } IWMPSubscriptionServiceVtbl;

    interface IWMPSubscriptionService
    {
        CONST_VTBL struct IWMPSubscriptionServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPSubscriptionService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPSubscriptionService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPSubscriptionService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPSubscriptionService_allowPlay(This,hwnd,pMedia,pfAllowPlay)	\
    ( (This)->lpVtbl -> allowPlay(This,hwnd,pMedia,pfAllowPlay) ) 

#define IWMPSubscriptionService_allowCDBurn(This,hwnd,pPlaylist,pfAllowBurn)	\
    ( (This)->lpVtbl -> allowCDBurn(This,hwnd,pPlaylist,pfAllowBurn) ) 

#define IWMPSubscriptionService_allowPDATransfer(This,hwnd,pPlaylist,pfAllowTransfer)	\
    ( (This)->lpVtbl -> allowPDATransfer(This,hwnd,pPlaylist,pfAllowTransfer) ) 

#define IWMPSubscriptionService_startBackgroundProcessing(This,hwnd)	\
    ( (This)->lpVtbl -> startBackgroundProcessing(This,hwnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPSubscriptionService_INTERFACE_DEFINED__ */


#ifndef __IWMPSubscriptionServiceCallback_INTERFACE_DEFINED__
#define __IWMPSubscriptionServiceCallback_INTERFACE_DEFINED__

/* interface IWMPSubscriptionServiceCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPSubscriptionServiceCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DD01D127-2DC2-4c3a-876E-63312079F9B0")
    IWMPSubscriptionServiceCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE onComplete( 
            HRESULT hrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPSubscriptionServiceCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPSubscriptionServiceCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPSubscriptionServiceCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPSubscriptionServiceCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *onComplete )( 
            IWMPSubscriptionServiceCallback * This,
            HRESULT hrResult);
        
        END_INTERFACE
    } IWMPSubscriptionServiceCallbackVtbl;

    interface IWMPSubscriptionServiceCallback
    {
        CONST_VTBL struct IWMPSubscriptionServiceCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPSubscriptionServiceCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPSubscriptionServiceCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPSubscriptionServiceCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPSubscriptionServiceCallback_onComplete(This,hrResult)	\
    ( (This)->lpVtbl -> onComplete(This,hrResult) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPSubscriptionServiceCallback_INTERFACE_DEFINED__ */


#ifndef __IWMPSubscriptionService2_INTERFACE_DEFINED__
#define __IWMPSubscriptionService2_INTERFACE_DEFINED__

/* interface IWMPSubscriptionService2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWMPSubscriptionService2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A94C120E-D600-4ec6-B05E-EC9D56D84DE0")
    IWMPSubscriptionService2 : public IWMPSubscriptionService
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE stopBackgroundProcessing( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE serviceEvent( 
            WMPSubscriptionServiceEvent event) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE deviceAvailable( 
            BSTR bstrDeviceName,
            IWMPSubscriptionServiceCallback *pCB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE prepareForSync( 
            BSTR bstrFilename,
            BSTR bstrDeviceName,
            IWMPSubscriptionServiceCallback *pCB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPSubscriptionService2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPSubscriptionService2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPSubscriptionService2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPSubscriptionService2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *allowPlay )( 
            IWMPSubscriptionService2 * This,
            HWND hwnd,
            IWMPMedia *pMedia,
            BOOL *pfAllowPlay);
        
        HRESULT ( STDMETHODCALLTYPE *allowCDBurn )( 
            IWMPSubscriptionService2 * This,
            HWND hwnd,
            IWMPPlaylist *pPlaylist,
            BOOL *pfAllowBurn);
        
        HRESULT ( STDMETHODCALLTYPE *allowPDATransfer )( 
            IWMPSubscriptionService2 * This,
            HWND hwnd,
            IWMPPlaylist *pPlaylist,
            BOOL *pfAllowTransfer);
        
        HRESULT ( STDMETHODCALLTYPE *startBackgroundProcessing )( 
            IWMPSubscriptionService2 * This,
            HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *stopBackgroundProcessing )( 
            IWMPSubscriptionService2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *serviceEvent )( 
            IWMPSubscriptionService2 * This,
            WMPSubscriptionServiceEvent event);
        
        HRESULT ( STDMETHODCALLTYPE *deviceAvailable )( 
            IWMPSubscriptionService2 * This,
            BSTR bstrDeviceName,
            IWMPSubscriptionServiceCallback *pCB);
        
        HRESULT ( STDMETHODCALLTYPE *prepareForSync )( 
            IWMPSubscriptionService2 * This,
            BSTR bstrFilename,
            BSTR bstrDeviceName,
            IWMPSubscriptionServiceCallback *pCB);
        
        END_INTERFACE
    } IWMPSubscriptionService2Vtbl;

    interface IWMPSubscriptionService2
    {
        CONST_VTBL struct IWMPSubscriptionService2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPSubscriptionService2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPSubscriptionService2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPSubscriptionService2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPSubscriptionService2_allowPlay(This,hwnd,pMedia,pfAllowPlay)	\
    ( (This)->lpVtbl -> allowPlay(This,hwnd,pMedia,pfAllowPlay) ) 

#define IWMPSubscriptionService2_allowCDBurn(This,hwnd,pPlaylist,pfAllowBurn)	\
    ( (This)->lpVtbl -> allowCDBurn(This,hwnd,pPlaylist,pfAllowBurn) ) 

#define IWMPSubscriptionService2_allowPDATransfer(This,hwnd,pPlaylist,pfAllowTransfer)	\
    ( (This)->lpVtbl -> allowPDATransfer(This,hwnd,pPlaylist,pfAllowTransfer) ) 

#define IWMPSubscriptionService2_startBackgroundProcessing(This,hwnd)	\
    ( (This)->lpVtbl -> startBackgroundProcessing(This,hwnd) ) 


#define IWMPSubscriptionService2_stopBackgroundProcessing(This)	\
    ( (This)->lpVtbl -> stopBackgroundProcessing(This) ) 

#define IWMPSubscriptionService2_serviceEvent(This,event)	\
    ( (This)->lpVtbl -> serviceEvent(This,event) ) 

#define IWMPSubscriptionService2_deviceAvailable(This,bstrDeviceName,pCB)	\
    ( (This)->lpVtbl -> deviceAvailable(This,bstrDeviceName,pCB) ) 

#define IWMPSubscriptionService2_prepareForSync(This,bstrFilename,bstrDeviceName,pCB)	\
    ( (This)->lpVtbl -> prepareForSync(This,bstrFilename,bstrDeviceName,pCB) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPSubscriptionService2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_subscriptionservicespri_0000_0003 */
/* [local] */ 

#ifndef __WMPNotifySubscriptionPluginAddRemove
#define __WMPNotifySubscriptionPluginAddRemove
__inline BOOL WMPNotifySubscriptionPluginAddRemove()
{
    BOOL fRet = FALSE;
    UINT  msg = RegisterWindowMessageA( "WMPlayer_PluginAddRemove" );
    if( 0 != msg ) 
     {
        fRet = PostMessage( HWND_BROADCAST, msg, 1, 0 );
     }
     return fRet;
}
#endif
#define WMP_SUBSCR_DL_TYPE_BACKGROUND       L"background"
#define WMP_SUBSCR_DL_TYPE_REALTIME         L"real time"
typedef /* [public][helpstring] */ 
enum WMPSubscriptionDownloadState
    {	wmpsdlsDownloading	= 0,
	wmpsdlsPaused	= ( wmpsdlsDownloading + 1 ) ,
	wmpsdlsProcessing	= ( wmpsdlsPaused + 1 ) ,
	wmpsdlsCompleted	= ( wmpsdlsProcessing + 1 ) ,
	wmpsdlsCancelled	= ( wmpsdlsCompleted + 1 ) 
    } 	WMPSubscriptionDownloadState;



extern RPC_IF_HANDLE __MIDL_itf_subscriptionservicespri_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_subscriptionservicespri_0000_0003_v0_0_s_ifspec;

#ifndef __IWMPDownloadItem_INTERFACE_DEFINED__
#define __IWMPDownloadItem_INTERFACE_DEFINED__

/* interface IWMPDownloadItem */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPDownloadItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C9470E8E-3F6B-46a9-A0A9-452815C34297")
    IWMPDownloadItem : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_sourceURL( 
            /* [retval][out] */ BSTR *pbstrURL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_size( 
            /* [retval][out] */ long *plSize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [retval][out] */ BSTR *pbstrType) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_progress( 
            /* [retval][out] */ long *plProgress) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_downloadState( 
            /* [retval][out] */ WMPSubscriptionDownloadState *pwmpsdls) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE pause( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE resume( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPDownloadItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPDownloadItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPDownloadItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPDownloadItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPDownloadItem * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPDownloadItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPDownloadItem * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPDownloadItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_sourceURL )( 
            IWMPDownloadItem * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_size )( 
            IWMPDownloadItem * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IWMPDownloadItem * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_progress )( 
            IWMPDownloadItem * This,
            /* [retval][out] */ long *plProgress);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_downloadState )( 
            IWMPDownloadItem * This,
            /* [retval][out] */ WMPSubscriptionDownloadState *pwmpsdls);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *pause )( 
            IWMPDownloadItem * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *resume )( 
            IWMPDownloadItem * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cancel )( 
            IWMPDownloadItem * This);
        
        END_INTERFACE
    } IWMPDownloadItemVtbl;

    interface IWMPDownloadItem
    {
        CONST_VTBL struct IWMPDownloadItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPDownloadItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPDownloadItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPDownloadItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPDownloadItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPDownloadItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPDownloadItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPDownloadItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPDownloadItem_get_sourceURL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_sourceURL(This,pbstrURL) ) 

#define IWMPDownloadItem_get_size(This,plSize)	\
    ( (This)->lpVtbl -> get_size(This,plSize) ) 

#define IWMPDownloadItem_get_type(This,pbstrType)	\
    ( (This)->lpVtbl -> get_type(This,pbstrType) ) 

#define IWMPDownloadItem_get_progress(This,plProgress)	\
    ( (This)->lpVtbl -> get_progress(This,plProgress) ) 

#define IWMPDownloadItem_get_downloadState(This,pwmpsdls)	\
    ( (This)->lpVtbl -> get_downloadState(This,pwmpsdls) ) 

#define IWMPDownloadItem_pause(This)	\
    ( (This)->lpVtbl -> pause(This) ) 

#define IWMPDownloadItem_resume(This)	\
    ( (This)->lpVtbl -> resume(This) ) 

#define IWMPDownloadItem_cancel(This)	\
    ( (This)->lpVtbl -> cancel(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPDownloadItem_INTERFACE_DEFINED__ */


#ifndef __IWMPDownloadItem2_INTERFACE_DEFINED__
#define __IWMPDownloadItem2_INTERFACE_DEFINED__

/* interface IWMPDownloadItem2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPDownloadItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FBB3336-6DA3-479d-B8FF-67D46E20A987")
    IWMPDownloadItem2 : public IWMPDownloadItem
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getItemInfo( 
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ BSTR *pbstrVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPDownloadItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPDownloadItem2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPDownloadItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPDownloadItem2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPDownloadItem2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPDownloadItem2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPDownloadItem2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPDownloadItem2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_sourceURL )( 
            IWMPDownloadItem2 * This,
            /* [retval][out] */ BSTR *pbstrURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_size )( 
            IWMPDownloadItem2 * This,
            /* [retval][out] */ long *plSize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_type )( 
            IWMPDownloadItem2 * This,
            /* [retval][out] */ BSTR *pbstrType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_progress )( 
            IWMPDownloadItem2 * This,
            /* [retval][out] */ long *plProgress);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_downloadState )( 
            IWMPDownloadItem2 * This,
            /* [retval][out] */ WMPSubscriptionDownloadState *pwmpsdls);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *pause )( 
            IWMPDownloadItem2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *resume )( 
            IWMPDownloadItem2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *cancel )( 
            IWMPDownloadItem2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getItemInfo )( 
            IWMPDownloadItem2 * This,
            /* [in] */ BSTR bstrItemName,
            /* [retval][out] */ BSTR *pbstrVal);
        
        END_INTERFACE
    } IWMPDownloadItem2Vtbl;

    interface IWMPDownloadItem2
    {
        CONST_VTBL struct IWMPDownloadItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPDownloadItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPDownloadItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPDownloadItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPDownloadItem2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPDownloadItem2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPDownloadItem2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPDownloadItem2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPDownloadItem2_get_sourceURL(This,pbstrURL)	\
    ( (This)->lpVtbl -> get_sourceURL(This,pbstrURL) ) 

#define IWMPDownloadItem2_get_size(This,plSize)	\
    ( (This)->lpVtbl -> get_size(This,plSize) ) 

#define IWMPDownloadItem2_get_type(This,pbstrType)	\
    ( (This)->lpVtbl -> get_type(This,pbstrType) ) 

#define IWMPDownloadItem2_get_progress(This,plProgress)	\
    ( (This)->lpVtbl -> get_progress(This,plProgress) ) 

#define IWMPDownloadItem2_get_downloadState(This,pwmpsdls)	\
    ( (This)->lpVtbl -> get_downloadState(This,pwmpsdls) ) 

#define IWMPDownloadItem2_pause(This)	\
    ( (This)->lpVtbl -> pause(This) ) 

#define IWMPDownloadItem2_resume(This)	\
    ( (This)->lpVtbl -> resume(This) ) 

#define IWMPDownloadItem2_cancel(This)	\
    ( (This)->lpVtbl -> cancel(This) ) 


#define IWMPDownloadItem2_getItemInfo(This,bstrItemName,pbstrVal)	\
    ( (This)->lpVtbl -> getItemInfo(This,bstrItemName,pbstrVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPDownloadItem2_INTERFACE_DEFINED__ */


#ifndef __IWMPDownloadCollection_INTERFACE_DEFINED__
#define __IWMPDownloadCollection_INTERFACE_DEFINED__

/* interface IWMPDownloadCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPDownloadCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A319C7F-85F9-436c-B88E-82FD88000E1C")
    IWMPDownloadCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_id( 
            /* [retval][out] */ long *plId) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_count( 
            /* [retval][out] */ long *plCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in] */ long lItem,
            /* [retval][out] */ IWMPDownloadItem2 **ppDownload) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE startDownload( 
            /* [in] */ BSTR bstrSourceURL,
            /* [in] */ BSTR bstrType,
            /* [retval][out] */ IWMPDownloadItem2 **ppDownload) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE removeItem( 
            /* [in] */ long lItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPDownloadCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPDownloadCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPDownloadCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPDownloadCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPDownloadCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPDownloadCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPDownloadCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPDownloadCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_id )( 
            IWMPDownloadCollection * This,
            /* [retval][out] */ long *plId);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_count )( 
            IWMPDownloadCollection * This,
            /* [retval][out] */ long *plCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *item )( 
            IWMPDownloadCollection * This,
            /* [in] */ long lItem,
            /* [retval][out] */ IWMPDownloadItem2 **ppDownload);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *startDownload )( 
            IWMPDownloadCollection * This,
            /* [in] */ BSTR bstrSourceURL,
            /* [in] */ BSTR bstrType,
            /* [retval][out] */ IWMPDownloadItem2 **ppDownload);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *removeItem )( 
            IWMPDownloadCollection * This,
            /* [in] */ long lItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IWMPDownloadCollection * This);
        
        END_INTERFACE
    } IWMPDownloadCollectionVtbl;

    interface IWMPDownloadCollection
    {
        CONST_VTBL struct IWMPDownloadCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPDownloadCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPDownloadCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPDownloadCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPDownloadCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPDownloadCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPDownloadCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPDownloadCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPDownloadCollection_get_id(This,plId)	\
    ( (This)->lpVtbl -> get_id(This,plId) ) 

#define IWMPDownloadCollection_get_count(This,plCount)	\
    ( (This)->lpVtbl -> get_count(This,plCount) ) 

#define IWMPDownloadCollection_item(This,lItem,ppDownload)	\
    ( (This)->lpVtbl -> item(This,lItem,ppDownload) ) 

#define IWMPDownloadCollection_startDownload(This,bstrSourceURL,bstrType,ppDownload)	\
    ( (This)->lpVtbl -> startDownload(This,bstrSourceURL,bstrType,ppDownload) ) 

#define IWMPDownloadCollection_removeItem(This,lItem)	\
    ( (This)->lpVtbl -> removeItem(This,lItem) ) 

#define IWMPDownloadCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPDownloadCollection_INTERFACE_DEFINED__ */


#ifndef __IWMPDownloadManager_INTERFACE_DEFINED__
#define __IWMPDownloadManager_INTERFACE_DEFINED__

/* interface IWMPDownloadManager */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IWMPDownloadManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E15E9AD1-8F20-4cc4-9EC7-1A328CA86A0D")
    IWMPDownloadManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getDownloadCollection( 
            /* [in] */ long lCollectionId,
            /* [retval][out] */ IWMPDownloadCollection **ppCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE createDownloadCollection( 
            /* [retval][out] */ IWMPDownloadCollection **ppCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMPDownloadManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMPDownloadManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMPDownloadManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMPDownloadManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWMPDownloadManager * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWMPDownloadManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWMPDownloadManager * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWMPDownloadManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getDownloadCollection )( 
            IWMPDownloadManager * This,
            /* [in] */ long lCollectionId,
            /* [retval][out] */ IWMPDownloadCollection **ppCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *createDownloadCollection )( 
            IWMPDownloadManager * This,
            /* [retval][out] */ IWMPDownloadCollection **ppCollection);
        
        END_INTERFACE
    } IWMPDownloadManagerVtbl;

    interface IWMPDownloadManager
    {
        CONST_VTBL struct IWMPDownloadManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMPDownloadManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMPDownloadManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMPDownloadManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMPDownloadManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWMPDownloadManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWMPDownloadManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWMPDownloadManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWMPDownloadManager_getDownloadCollection(This,lCollectionId,ppCollection)	\
    ( (This)->lpVtbl -> getDownloadCollection(This,lCollectionId,ppCollection) ) 

#define IWMPDownloadManager_createDownloadCollection(This,ppCollection)	\
    ( (This)->lpVtbl -> createDownloadCollection(This,ppCollection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMPDownloadManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\structuredquery.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for structuredquery.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __structuredquery_h__
#define __structuredquery_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IQueryParser_FWD_DEFINED__
#define __IQueryParser_FWD_DEFINED__
typedef interface IQueryParser IQueryParser;
#endif 	/* __IQueryParser_FWD_DEFINED__ */


#ifndef __IConditionFactory_FWD_DEFINED__
#define __IConditionFactory_FWD_DEFINED__
typedef interface IConditionFactory IConditionFactory;
#endif 	/* __IConditionFactory_FWD_DEFINED__ */


#ifndef __IQuerySolution_FWD_DEFINED__
#define __IQuerySolution_FWD_DEFINED__
typedef interface IQuerySolution IQuerySolution;
#endif 	/* __IQuerySolution_FWD_DEFINED__ */


#ifndef __ICondition_FWD_DEFINED__
#define __ICondition_FWD_DEFINED__
typedef interface ICondition ICondition;
#endif 	/* __ICondition_FWD_DEFINED__ */


#ifndef __IConditionGenerator_FWD_DEFINED__
#define __IConditionGenerator_FWD_DEFINED__
typedef interface IConditionGenerator IConditionGenerator;
#endif 	/* __IConditionGenerator_FWD_DEFINED__ */


#ifndef __IRichChunk_FWD_DEFINED__
#define __IRichChunk_FWD_DEFINED__
typedef interface IRichChunk IRichChunk;
#endif 	/* __IRichChunk_FWD_DEFINED__ */


#ifndef __IInterval_FWD_DEFINED__
#define __IInterval_FWD_DEFINED__
typedef interface IInterval IInterval;
#endif 	/* __IInterval_FWD_DEFINED__ */


#ifndef __IMetaData_FWD_DEFINED__
#define __IMetaData_FWD_DEFINED__
typedef interface IMetaData IMetaData;
#endif 	/* __IMetaData_FWD_DEFINED__ */


#ifndef __IEntity_FWD_DEFINED__
#define __IEntity_FWD_DEFINED__
typedef interface IEntity IEntity;
#endif 	/* __IEntity_FWD_DEFINED__ */


#ifndef __IRelationship_FWD_DEFINED__
#define __IRelationship_FWD_DEFINED__
typedef interface IRelationship IRelationship;
#endif 	/* __IRelationship_FWD_DEFINED__ */


#ifndef __INamedEntity_FWD_DEFINED__
#define __INamedEntity_FWD_DEFINED__
typedef interface INamedEntity INamedEntity;
#endif 	/* __INamedEntity_FWD_DEFINED__ */


#ifndef __ISchemaProvider_FWD_DEFINED__
#define __ISchemaProvider_FWD_DEFINED__
typedef interface ISchemaProvider ISchemaProvider;
#endif 	/* __ISchemaProvider_FWD_DEFINED__ */


#ifndef __ITokenCollection_FWD_DEFINED__
#define __ITokenCollection_FWD_DEFINED__
typedef interface ITokenCollection ITokenCollection;
#endif 	/* __ITokenCollection_FWD_DEFINED__ */


#ifndef __INamedEntityCollector_FWD_DEFINED__
#define __INamedEntityCollector_FWD_DEFINED__
typedef interface INamedEntityCollector INamedEntityCollector;
#endif 	/* __INamedEntityCollector_FWD_DEFINED__ */


#ifndef __ISchemaLocalizerSupport_FWD_DEFINED__
#define __ISchemaLocalizerSupport_FWD_DEFINED__
typedef interface ISchemaLocalizerSupport ISchemaLocalizerSupport;
#endif 	/* __ISchemaLocalizerSupport_FWD_DEFINED__ */


#ifndef __IQueryParserManager_FWD_DEFINED__
#define __IQueryParserManager_FWD_DEFINED__
typedef interface IQueryParserManager IQueryParserManager;
#endif 	/* __IQueryParserManager_FWD_DEFINED__ */


#ifndef __QueryParser_FWD_DEFINED__
#define __QueryParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class QueryParser QueryParser;
#else
typedef struct QueryParser QueryParser;
#endif /* __cplusplus */

#endif 	/* __QueryParser_FWD_DEFINED__ */


#ifndef __NegationCondition_FWD_DEFINED__
#define __NegationCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class NegationCondition NegationCondition;
#else
typedef struct NegationCondition NegationCondition;
#endif /* __cplusplus */

#endif 	/* __NegationCondition_FWD_DEFINED__ */


#ifndef __CompoundCondition_FWD_DEFINED__
#define __CompoundCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompoundCondition CompoundCondition;
#else
typedef struct CompoundCondition CompoundCondition;
#endif /* __cplusplus */

#endif 	/* __CompoundCondition_FWD_DEFINED__ */


#ifndef __LeafCondition_FWD_DEFINED__
#define __LeafCondition_FWD_DEFINED__

#ifdef __cplusplus
typedef class LeafCondition LeafCondition;
#else
typedef struct LeafCondition LeafCondition;
#endif /* __cplusplus */

#endif 	/* __LeafCondition_FWD_DEFINED__ */


#ifndef __ConditionFactory_FWD_DEFINED__
#define __ConditionFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class ConditionFactory ConditionFactory;
#else
typedef struct ConditionFactory ConditionFactory;
#endif /* __cplusplus */

#endif 	/* __ConditionFactory_FWD_DEFINED__ */


#ifndef __Interval_FWD_DEFINED__
#define __Interval_FWD_DEFINED__

#ifdef __cplusplus
typedef class Interval Interval;
#else
typedef struct Interval Interval;
#endif /* __cplusplus */

#endif 	/* __Interval_FWD_DEFINED__ */


#ifndef __QueryParserManager_FWD_DEFINED__
#define __QueryParserManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class QueryParserManager QueryParserManager;
#else
typedef struct QueryParserManager QueryParserManager;
#endif /* __cplusplus */

#endif 	/* __QueryParserManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_structuredquery_0000_0000 */
/* [local] */ 











typedef /* [v1_enum] */ 
enum tagCONDITION_TYPE
    {	CT_AND_CONDITION	= 0,
	CT_OR_CONDITION	= ( CT_AND_CONDITION + 1 ) ,
	CT_NOT_CONDITION	= ( CT_OR_CONDITION + 1 ) ,
	CT_LEAF_CONDITION	= ( CT_NOT_CONDITION + 1 ) 
    } 	CONDITION_TYPE;

typedef /* [v1_enum] */ 
enum tagCONDITION_OPERATION
    {	COP_IMPLICIT	= 0,
	COP_EQUAL	= ( COP_IMPLICIT + 1 ) ,
	COP_NOTEQUAL	= ( COP_EQUAL + 1 ) ,
	COP_LESSTHAN	= ( COP_NOTEQUAL + 1 ) ,
	COP_GREATERTHAN	= ( COP_LESSTHAN + 1 ) ,
	COP_LESSTHANOREQUAL	= ( COP_GREATERTHAN + 1 ) ,
	COP_GREATERTHANOREQUAL	= ( COP_LESSTHANOREQUAL + 1 ) ,
	COP_VALUE_STARTSWITH	= ( COP_GREATERTHANOREQUAL + 1 ) ,
	COP_VALUE_ENDSWITH	= ( COP_VALUE_STARTSWITH + 1 ) ,
	COP_VALUE_CONTAINS	= ( COP_VALUE_ENDSWITH + 1 ) ,
	COP_VALUE_NOTCONTAINS	= ( COP_VALUE_CONTAINS + 1 ) ,
	COP_DOSWILDCARDS	= ( COP_VALUE_NOTCONTAINS + 1 ) ,
	COP_WORD_EQUAL	= ( COP_DOSWILDCARDS + 1 ) ,
	COP_WORD_STARTSWITH	= ( COP_WORD_EQUAL + 1 ) ,
	COP_APPLICATION_SPECIFIC	= ( COP_WORD_STARTSWITH + 1 ) 
    } 	CONDITION_OPERATION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_SINGLE_OPTION
    {	SQSO_SCHEMA	= 0,
	SQSO_LOCALE_WORD_BREAKING	= ( SQSO_SCHEMA + 1 ) ,
	SQSO_WORD_BREAKER	= ( SQSO_LOCALE_WORD_BREAKING + 1 ) ,
	SQSO_NATURAL_SYNTAX	= ( SQSO_WORD_BREAKER + 1 ) ,
	SQSO_AUTOMATIC_WILDCARD	= ( SQSO_NATURAL_SYNTAX + 1 ) ,
	SQSO_TRACE_LEVEL	= ( SQSO_AUTOMATIC_WILDCARD + 1 ) ,
	SQSO_LANGUAGE_KEYWORDS	= ( SQSO_TRACE_LEVEL + 1 ) 
    } 	STRUCTURED_QUERY_SINGLE_OPTION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_MULTIOPTION
    {	SQMO_VIRTUAL_PROPERTY	= 0,
	SQMO_DEFAULT_PROPERTY	= ( SQMO_VIRTUAL_PROPERTY + 1 ) ,
	SQMO_GENERATOR_FOR_TYPE	= ( SQMO_DEFAULT_PROPERTY + 1 ) 
    } 	STRUCTURED_QUERY_MULTIOPTION;

typedef /* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_PARSE_ERROR
    {	SQPE_NONE	= 0,
	SQPE_EXTRA_OPENING_PARENTHESIS	= ( SQPE_NONE + 1 ) ,
	SQPE_EXTRA_CLOSING_PARENTHESIS	= ( SQPE_EXTRA_OPENING_PARENTHESIS + 1 ) ,
	SQPE_IGNORED_MODIFIER	= ( SQPE_EXTRA_CLOSING_PARENTHESIS + 1 ) ,
	SQPE_IGNORED_CONNECTOR	= ( SQPE_IGNORED_MODIFIER + 1 ) ,
	SQPE_IGNORED_KEYWORD	= ( SQPE_IGNORED_CONNECTOR + 1 ) ,
	SQPE_UNHANDLED	= ( SQPE_IGNORED_KEYWORD + 1 ) 
    } 	STRUCTURED_QUERY_PARSE_ERROR;

/* [v1_enum] */ 
enum tagSTRUCTURED_QUERY_RESOLVE_OPTION
    {	SQRO_DONT_RESOLVE_DATETIME	= 0x1,
	SQRO_ALWAYS_ONE_INTERVAL	= 0x2,
	SQRO_DONT_SIMPLIFY_CONDITION_TREES	= 0x4,
	SQRO_DONT_MAP_RELATIONS	= 0x8,
	SQRO_DONT_RESOLVE_RANGES	= 0x10,
	SQRO_DONT_REMOVE_UNRESTRICTED_KEYWORDS	= 0x20,
	SQRO_DONT_SPLIT_WORDS	= 0x40,
	SQRO_IGNORE_PHRASE_ORDER	= 0x80
    } ;
typedef int STRUCTURED_QUERY_RESOLVE_OPTION;

typedef /* [v1_enum] */ 
enum tagINTERVAL_LIMIT_KIND
    {	ILK_EXPLICIT_INCLUDED	= 0,
	ILK_EXPLICIT_EXCLUDED	= ( ILK_EXPLICIT_INCLUDED + 1 ) ,
	ILK_NEGATIVE_INFINITY	= ( ILK_EXPLICIT_EXCLUDED + 1 ) ,
	ILK_POSITIVE_INFINITY	= ( ILK_NEGATIVE_INFINITY + 1 ) 
    } 	INTERVAL_LIMIT_KIND;

typedef /* [v1_enum] */ 
enum tagQUERY_PARSER_MANAGER_OPTION
    {	QPMO_SCHEMA_BINARY_NAME	= 0,
	QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_SCHEMA_BINARY_NAME + 1 ) ,
	QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_PRELOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
	QPMO_LOCALIZED_SCHEMA_BINARY_PATH	= ( QPMO_UNLOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
	QPMO_APPEND_LCID_TO_LOCALIZED_PATH	= ( QPMO_LOCALIZED_SCHEMA_BINARY_PATH + 1 ) ,
	QPMO_LOCALIZER_SUPPORT	= ( QPMO_APPEND_LCID_TO_LOCALIZED_PATH + 1 ) 
    } 	QUERY_PARSER_MANAGER_OPTION;



extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0000_v0_0_s_ifspec;

#ifndef __IQueryParser_INTERFACE_DEFINED__
#define __IQueryParser_INTERFACE_DEFINED__

/* interface IQueryParser */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQueryParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2EBDEE67-3505-43f8-9946-EA44ABC8E5B0")
    IQueryParser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Parse( 
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ __RPC__in_opt IEnumUnknown *pCustomProperties,
            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOption( 
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [retval][out] */ __RPC__out PROPVARIANT *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMultiOption( 
            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
            /* [in] */ __RPC__in LPCWSTR pszOptionKey,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSchemaProvider( 
            /* [retval][out] */ __RPC__deref_out_opt ISchemaProvider **ppSchemaProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestateToString( 
            /* [in] */ __RPC__in_opt ICondition *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParsePropertyValue( 
            /* [in] */ __RPC__in LPCWSTR pszPropertyName,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestatePropertyValueToString( 
            /* [in] */ __RPC__in_opt ICondition *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPropertyName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryParser * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryParser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryParser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Parse )( 
            IQueryParser * This,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ __RPC__in_opt IEnumUnknown *pCustomProperties,
            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IQueryParser * This,
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetOption )( 
            IQueryParser * This,
            /* [in] */ STRUCTURED_QUERY_SINGLE_OPTION option,
            /* [retval][out] */ __RPC__out PROPVARIANT *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetMultiOption )( 
            IQueryParser * This,
            /* [in] */ STRUCTURED_QUERY_MULTIOPTION option,
            /* [in] */ __RPC__in LPCWSTR pszOptionKey,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchemaProvider )( 
            IQueryParser * This,
            /* [retval][out] */ __RPC__deref_out_opt ISchemaProvider **ppSchemaProvider);
        
        HRESULT ( STDMETHODCALLTYPE *RestateToString )( 
            IQueryParser * This,
            /* [in] */ __RPC__in_opt ICondition *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString);
        
        HRESULT ( STDMETHODCALLTYPE *ParsePropertyValue )( 
            IQueryParser * This,
            /* [in] */ __RPC__in LPCWSTR pszPropertyName,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [retval][out] */ __RPC__deref_out_opt IQuerySolution **ppSolution);
        
        HRESULT ( STDMETHODCALLTYPE *RestatePropertyValueToString )( 
            IQueryParser * This,
            /* [in] */ __RPC__in_opt ICondition *pCondition,
            /* [in] */ BOOL fUseEnglish,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszPropertyName,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszQueryString);
        
        END_INTERFACE
    } IQueryParserVtbl;

    interface IQueryParser
    {
        CONST_VTBL struct IQueryParserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryParser_Parse(This,pszInputString,pCustomProperties,ppSolution)	\
    ( (This)->lpVtbl -> Parse(This,pszInputString,pCustomProperties,ppSolution) ) 

#define IQueryParser_SetOption(This,option,pOptionValue)	\
    ( (This)->lpVtbl -> SetOption(This,option,pOptionValue) ) 

#define IQueryParser_GetOption(This,option,pOptionValue)	\
    ( (This)->lpVtbl -> GetOption(This,option,pOptionValue) ) 

#define IQueryParser_SetMultiOption(This,option,pszOptionKey,pOptionValue)	\
    ( (This)->lpVtbl -> SetMultiOption(This,option,pszOptionKey,pOptionValue) ) 

#define IQueryParser_GetSchemaProvider(This,ppSchemaProvider)	\
    ( (This)->lpVtbl -> GetSchemaProvider(This,ppSchemaProvider) ) 

#define IQueryParser_RestateToString(This,pCondition,fUseEnglish,ppszQueryString)	\
    ( (This)->lpVtbl -> RestateToString(This,pCondition,fUseEnglish,ppszQueryString) ) 

#define IQueryParser_ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution)	\
    ( (This)->lpVtbl -> ParsePropertyValue(This,pszPropertyName,pszInputString,ppSolution) ) 

#define IQueryParser_RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString)	\
    ( (This)->lpVtbl -> RestatePropertyValueToString(This,pCondition,fUseEnglish,ppszPropertyName,ppszQueryString) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryParser_INTERFACE_DEFINED__ */


#ifndef __IConditionFactory_INTERFACE_DEFINED__
#define __IConditionFactory_INTERFACE_DEFINED__

/* interface IConditionFactory */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConditionFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A5EFE073-B16F-474f-9F3E-9F8B497A3E08")
    IConditionFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MakeNot( 
            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeAndOr( 
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeLeaf( 
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in const PROPVARIANT *pValue,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ 
            __in  ICondition *pConditionTree,
            /* [in] */ 
            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ 
            __in_opt  const SYSTEMTIME *pstReferenceTime,
            /* [retval][out] */ 
            __out  ICondition **ppResolvedConditionTree) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConditionFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConditionFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConditionFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeNot )( 
            IConditionFactory * This,
            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE *MakeAndOr )( 
            IConditionFactory * This,
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE *MakeLeaf )( 
            IConditionFactory * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in const PROPVARIANT *pValue,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IConditionFactory * This,
            /* [in] */ 
            __in  ICondition *pConditionTree,
            /* [in] */ 
            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ 
            __in_opt  const SYSTEMTIME *pstReferenceTime,
            /* [retval][out] */ 
            __out  ICondition **ppResolvedConditionTree);
        
        END_INTERFACE
    } IConditionFactoryVtbl;

    interface IConditionFactory
    {
        CONST_VTBL struct IConditionFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConditionFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConditionFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConditionFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConditionFactory_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery) ) 

#define IConditionFactory_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery) ) 

#define IConditionFactory_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery) ) 

#define IConditionFactory_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
    ( (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConditionFactory_INTERFACE_DEFINED__ */


#ifndef __IQuerySolution_INTERFACE_DEFINED__
#define __IQuerySolution_INTERFACE_DEFINED__

/* interface IQuerySolution */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IQuerySolution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6EBC66B-8921-4193-AFDD-A1789FB7FF57")
    IQuerySolution : public IConditionFactory
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out] */ 
            __out_opt  ICondition **ppQueryNode,
            /* [out] */ 
            __out_opt  IEntity **ppMainType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrors( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppParseErrors) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetLexicalData( 
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszInputString,
            /* [out] */ 
            __out_opt  ITokenCollection **ppTokens,
            /* [out] */ 
            __out_opt  LCID *pLocale,
            /* [out] */ 
            __out_opt  IUnknown **ppWordBreaker) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQuerySolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQuerySolution * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQuerySolution * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQuerySolution * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeNot )( 
            IQuerySolution * This,
            /* [in] */ __RPC__in_opt ICondition *pSubCondition,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE *MakeAndOr )( 
            IQuerySolution * This,
            /* [in] */ CONDITION_TYPE nodeType,
            /* [in] */ __RPC__in_opt IEnumUnknown *pSubConditions,
            /* [in] */ BOOL simplify,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        HRESULT ( STDMETHODCALLTYPE *MakeLeaf )( 
            IQuerySolution * This,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in const PROPVARIANT *pValue,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL expand,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppResultQuery);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IQuerySolution * This,
            /* [in] */ 
            __in  ICondition *pConditionTree,
            /* [in] */ 
            __in  STRUCTURED_QUERY_RESOLVE_OPTION sqro,
            /* [ref][in] */ 
            __in_opt  const SYSTEMTIME *pstReferenceTime,
            /* [retval][out] */ 
            __out  ICondition **ppResolvedConditionTree);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetQuery )( 
            IQuerySolution * This,
            /* [out] */ 
            __out_opt  ICondition **ppQueryNode,
            /* [out] */ 
            __out_opt  IEntity **ppMainType);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrors )( 
            IQuerySolution * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppParseErrors);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetLexicalData )( 
            IQuerySolution * This,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszInputString,
            /* [out] */ 
            __out_opt  ITokenCollection **ppTokens,
            /* [out] */ 
            __out_opt  LCID *pLocale,
            /* [out] */ 
            __out_opt  IUnknown **ppWordBreaker);
        
        END_INTERFACE
    } IQuerySolutionVtbl;

    interface IQuerySolution
    {
        CONST_VTBL struct IQuerySolutionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQuerySolution_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQuerySolution_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQuerySolution_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQuerySolution_MakeNot(This,pSubCondition,simplify,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeNot(This,pSubCondition,simplify,ppResultQuery) ) 

#define IQuerySolution_MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeAndOr(This,nodeType,pSubConditions,simplify,ppResultQuery) ) 

#define IQuerySolution_MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery)	\
    ( (This)->lpVtbl -> MakeLeaf(This,pszPropertyName,op,pszValueType,pValue,pPropertyNameTerm,pOperationTerm,pValueTerm,expand,ppResultQuery) ) 

#define IQuerySolution_Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree)	\
    ( (This)->lpVtbl -> Resolve(This,pConditionTree,sqro,pstReferenceTime,ppResolvedConditionTree) ) 


#define IQuerySolution_GetQuery(This,ppQueryNode,ppMainType)	\
    ( (This)->lpVtbl -> GetQuery(This,ppQueryNode,ppMainType) ) 

#define IQuerySolution_GetErrors(This,riid,ppParseErrors)	\
    ( (This)->lpVtbl -> GetErrors(This,riid,ppParseErrors) ) 

#define IQuerySolution_GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker)	\
    ( (This)->lpVtbl -> GetLexicalData(This,ppszInputString,ppTokens,pLocale,ppWordBreaker) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQuerySolution_INTERFACE_DEFINED__ */


#ifndef __ICondition_INTERFACE_DEFINED__
#define __ICondition_INTERFACE_DEFINED__

/* interface ICondition */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICondition;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0FC988D4-C935-4b97-A973-46282EA175C8")
    ICondition : public IPersistStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConditionType( 
            /* [retval][out] */ __RPC__out CONDITION_TYPE *pNodeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubConditions( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetComparisonInfo( 
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszPropertyName,
            /* [out] */ 
            __out_opt  CONDITION_OPERATION *pOperation,
            /* [out] */ 
            __out_opt  PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueType( 
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValueTypeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValueNormalization( 
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszNormalization) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetInputTerms( 
            /* [out] */ 
            __out_opt  IRichChunk **ppPropertyTerm,
            /* [out] */ 
            __out_opt  IRichChunk **ppOperationTerm,
            /* [out] */ 
            __out_opt  IRichChunk **ppValueTerm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICondition * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICondition * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            ICondition * This,
            /* [out] */ __RPC__out CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *IsDirty )( 
            ICondition * This);
        
        HRESULT ( STDMETHODCALLTYPE *Load )( 
            ICondition * This,
            /* [unique][in] */ __RPC__in_opt IStream *pStm);
        
        HRESULT ( STDMETHODCALLTYPE *Save )( 
            ICondition * This,
            /* [unique][in] */ __RPC__in_opt IStream *pStm,
            /* [in] */ BOOL fClearDirty);
        
        HRESULT ( STDMETHODCALLTYPE *GetSizeMax )( 
            ICondition * This,
            /* [out] */ __RPC__out ULARGE_INTEGER *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetConditionType )( 
            ICondition * This,
            /* [retval][out] */ __RPC__out CONDITION_TYPE *pNodeType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubConditions )( 
            ICondition * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetComparisonInfo )( 
            ICondition * This,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszPropertyName,
            /* [out] */ 
            __out_opt  CONDITION_OPERATION *pOperation,
            /* [out] */ 
            __out_opt  PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueType )( 
            ICondition * This,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValueTypeName);
        
        HRESULT ( STDMETHODCALLTYPE *GetValueNormalization )( 
            ICondition * This,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszNormalization);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetInputTerms )( 
            ICondition * This,
            /* [out] */ 
            __out_opt  IRichChunk **ppPropertyTerm,
            /* [out] */ 
            __out_opt  IRichChunk **ppOperationTerm,
            /* [out] */ 
            __out_opt  IRichChunk **ppValueTerm);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICondition * This,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppc);
        
        END_INTERFACE
    } IConditionVtbl;

    interface ICondition
    {
        CONST_VTBL struct IConditionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICondition_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICondition_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICondition_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICondition_GetClassID(This,pClassID)	\
    ( (This)->lpVtbl -> GetClassID(This,pClassID) ) 


#define ICondition_IsDirty(This)	\
    ( (This)->lpVtbl -> IsDirty(This) ) 

#define ICondition_Load(This,pStm)	\
    ( (This)->lpVtbl -> Load(This,pStm) ) 

#define ICondition_Save(This,pStm,fClearDirty)	\
    ( (This)->lpVtbl -> Save(This,pStm,fClearDirty) ) 

#define ICondition_GetSizeMax(This,pcbSize)	\
    ( (This)->lpVtbl -> GetSizeMax(This,pcbSize) ) 


#define ICondition_GetConditionType(This,pNodeType)	\
    ( (This)->lpVtbl -> GetConditionType(This,pNodeType) ) 

#define ICondition_GetSubConditions(This,riid,ppv)	\
    ( (This)->lpVtbl -> GetSubConditions(This,riid,ppv) ) 

#define ICondition_GetComparisonInfo(This,ppszPropertyName,pOperation,pValue)	\
    ( (This)->lpVtbl -> GetComparisonInfo(This,ppszPropertyName,pOperation,pValue) ) 

#define ICondition_GetValueType(This,ppszValueTypeName)	\
    ( (This)->lpVtbl -> GetValueType(This,ppszValueTypeName) ) 

#define ICondition_GetValueNormalization(This,ppszNormalization)	\
    ( (This)->lpVtbl -> GetValueNormalization(This,ppszNormalization) ) 

#define ICondition_GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm)	\
    ( (This)->lpVtbl -> GetInputTerms(This,ppPropertyTerm,ppOperationTerm,ppValueTerm) ) 

#define ICondition_Clone(This,ppc)	\
    ( (This)->lpVtbl -> Clone(This,ppc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICondition_INTERFACE_DEFINED__ */


#ifndef __IConditionGenerator_INTERFACE_DEFINED__
#define __IConditionGenerator_INTERFACE_DEFINED__

/* interface IConditionGenerator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IConditionGenerator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("92D2CC58-4386-45a3-B98C-7E0CE64A4117")
    IConditionGenerator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt ISchemaProvider *pSchemaProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecognizeNamedEntities( 
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ LCID lcid,
            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
            /* [out][in] */ __RPC__inout_opt INamedEntityCollector *pNamedEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateForLeaf( 
            /* [in] */ __RPC__in_opt IConditionFactory *pConditionFactory,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValue2,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL automaticWildcard,
            /* [out] */ __RPC__out BOOL *pNoStringQuery,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppQueryExpression) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT *ppropvar,
            /* [in] */ BOOL fUseEnglish,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IConditionGeneratorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IConditionGenerator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IConditionGenerator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IConditionGenerator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IConditionGenerator * This,
            /* [in] */ __RPC__in_opt ISchemaProvider *pSchemaProvider);
        
        HRESULT ( STDMETHODCALLTYPE *RecognizeNamedEntities )( 
            IConditionGenerator * This,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ LCID lcid,
            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
            /* [out][in] */ __RPC__inout_opt INamedEntityCollector *pNamedEntities);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateForLeaf )( 
            IConditionGenerator * This,
            /* [in] */ __RPC__in_opt IConditionFactory *pConditionFactory,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszPropertyName,
            /* [in] */ CONDITION_OPERATION op,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValueType,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [unique][in] */ __RPC__in_opt LPCWSTR pszValue2,
            /* [in] */ __RPC__in_opt IRichChunk *pPropertyNameTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pOperationTerm,
            /* [in] */ __RPC__in_opt IRichChunk *pValueTerm,
            /* [in] */ BOOL automaticWildcard,
            /* [out] */ __RPC__out BOOL *pNoStringQuery,
            /* [retval][out] */ __RPC__deref_out_opt ICondition **ppQueryExpression);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
            IConditionGenerator * This,
            /* [unique][in] */ LPCWSTR pszValueType,
            /* [in] */ const PROPVARIANT *ppropvar,
            /* [in] */ BOOL fUseEnglish,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase);
        
        END_INTERFACE
    } IConditionGeneratorVtbl;

    interface IConditionGenerator
    {
        CONST_VTBL struct IConditionGeneratorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IConditionGenerator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IConditionGenerator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IConditionGenerator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IConditionGenerator_Initialize(This,pSchemaProvider)	\
    ( (This)->lpVtbl -> Initialize(This,pSchemaProvider) ) 

#define IConditionGenerator_RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities)	\
    ( (This)->lpVtbl -> RecognizeNamedEntities(This,pszInputString,lcid,pTokenCollection,pNamedEntities) ) 

#define IConditionGenerator_GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression)	\
    ( (This)->lpVtbl -> GenerateForLeaf(This,pConditionFactory,pszPropertyName,op,pszValueType,pszValue,pszValue2,pPropertyNameTerm,pOperationTerm,pValueTerm,automaticWildcard,pNoStringQuery,ppQueryExpression) ) 

#define IConditionGenerator_DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase)	\
    ( (This)->lpVtbl -> DefaultPhrase(This,pszValueType,ppropvar,fUseEnglish,ppszPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IConditionGenerator_INTERFACE_DEFINED__ */


#ifndef __IRichChunk_INTERFACE_DEFINED__
#define __IRichChunk_INTERFACE_DEFINED__

/* interface IRichChunk */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRichChunk;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4FDEF69C-DBC9-454e-9910-B34F3C64B510")
    IRichChunk : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ 
            __out_opt  ULONG *pFirstPos,
            /* [out] */ 
            __out_opt  ULONG *pLength,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppsz,
            /* [out] */ 
            __out_opt  PROPVARIANT *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRichChunkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRichChunk * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRichChunk * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRichChunk * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IRichChunk * This,
            /* [out] */ 
            __out_opt  ULONG *pFirstPos,
            /* [out] */ 
            __out_opt  ULONG *pLength,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppsz,
            /* [out] */ 
            __out_opt  PROPVARIANT *pValue);
        
        END_INTERFACE
    } IRichChunkVtbl;

    interface IRichChunk
    {
        CONST_VTBL struct IRichChunkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRichChunk_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRichChunk_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRichChunk_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRichChunk_GetData(This,pFirstPos,pLength,ppsz,pValue)	\
    ( (This)->lpVtbl -> GetData(This,pFirstPos,pLength,ppsz,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRichChunk_INTERFACE_DEFINED__ */


#ifndef __IInterval_INTERFACE_DEFINED__
#define __IInterval_INTERFACE_DEFINED__

/* interface IInterval */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IInterval;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6BF0A714-3C18-430b-8B5D-83B1C234D3DB")
    IInterval : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLimits( 
            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkLower,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarLower,
            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkUpper,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarUpper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIntervalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInterval * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInterval * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInterval * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetLimits )( 
            IInterval * This,
            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkLower,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarLower,
            /* [out] */ __RPC__out INTERVAL_LIMIT_KIND *pilkUpper,
            /* [out] */ __RPC__out PROPVARIANT *ppropvarUpper);
        
        END_INTERFACE
    } IIntervalVtbl;

    interface IInterval
    {
        CONST_VTBL struct IIntervalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInterval_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInterval_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInterval_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInterval_GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper)	\
    ( (This)->lpVtbl -> GetLimits(This,pilkLower,ppropvarLower,pilkUpper,ppropvarUpper) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInterval_INTERFACE_DEFINED__ */


#ifndef __IMetaData_INTERFACE_DEFINED__
#define __IMetaData_INTERFACE_DEFINED__

/* interface IMetaData */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_IMetaData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("780102B0-C43B-4876-BC7B-5E9BA5C88794")
    IMetaData : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszKey,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMetaDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMetaData * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMetaData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMetaData * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IMetaData * This,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszKey,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppszValue);
        
        END_INTERFACE
    } IMetaDataVtbl;

    interface IMetaData
    {
        CONST_VTBL struct IMetaDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMetaData_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMetaData_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMetaData_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMetaData_GetData(This,ppszKey,ppszValue)	\
    ( (This)->lpVtbl -> GetData(This,ppszKey,ppszValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMetaData_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_structuredquery_0000_0008 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0008_v0_0_s_ifspec;

#ifndef __IEntity_INTERFACE_DEFINED__
#define __IEntity_INTERFACE_DEFINED__

/* interface IEntity */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24264891-E80B-4fd3-B7CE-4FF2FAE8931F")
    IEntity : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Base( 
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pBaseEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Relationships( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pRelationships) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRelationship( 
            /* [in] */ __RPC__in LPCWSTR pszRelationName,
            /* [retval][out] */ __RPC__deref_out_opt IRelationship **pRelationship) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NamedEntities( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pNamedEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamedEntity( 
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [retval][out] */ __RPC__deref_out_opt INamedEntity **ppNamedEntity) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEntity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEntity * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Name )( 
            IEntity * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *Base )( 
            IEntity * This,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pBaseEntity);
        
        HRESULT ( STDMETHODCALLTYPE *Relationships )( 
            IEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pRelationships);
        
        HRESULT ( STDMETHODCALLTYPE *GetRelationship )( 
            IEntity * This,
            /* [in] */ __RPC__in LPCWSTR pszRelationName,
            /* [retval][out] */ __RPC__deref_out_opt IRelationship **pRelationship);
        
        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
            IEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
        
        HRESULT ( STDMETHODCALLTYPE *NamedEntities )( 
            IEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pNamedEntities);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamedEntity )( 
            IEntity * This,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [retval][out] */ __RPC__deref_out_opt INamedEntity **ppNamedEntity);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
            IEntity * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase);
        
        END_INTERFACE
    } IEntityVtbl;

    interface IEntity
    {
        CONST_VTBL struct IEntityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEntity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEntity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEntity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEntity_Name(This,ppszName)	\
    ( (This)->lpVtbl -> Name(This,ppszName) ) 

#define IEntity_Base(This,pBaseEntity)	\
    ( (This)->lpVtbl -> Base(This,pBaseEntity) ) 

#define IEntity_Relationships(This,riid,pRelationships)	\
    ( (This)->lpVtbl -> Relationships(This,riid,pRelationships) ) 

#define IEntity_GetRelationship(This,pszRelationName,pRelationship)	\
    ( (This)->lpVtbl -> GetRelationship(This,pszRelationName,pRelationship) ) 

#define IEntity_MetaData(This,riid,pMetaData)	\
    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 

#define IEntity_NamedEntities(This,riid,pNamedEntities)	\
    ( (This)->lpVtbl -> NamedEntities(This,riid,pNamedEntities) ) 

#define IEntity_GetNamedEntity(This,pszValue,ppNamedEntity)	\
    ( (This)->lpVtbl -> GetNamedEntity(This,pszValue,ppNamedEntity) ) 

#define IEntity_DefaultPhrase(This,ppszPhrase)	\
    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEntity_INTERFACE_DEFINED__ */


#ifndef __IRelationship_INTERFACE_DEFINED__
#define __IRelationship_INTERFACE_DEFINED__

/* interface IRelationship */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IRelationship;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2769280B-5108-498c-9C7F-A51239B63147")
    IRelationship : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Name( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsReal( 
            /* [retval][out] */ __RPC__out BOOL *pIsReal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destination( 
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pDestinationEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRelationshipVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRelationship * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRelationship * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRelationship * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Name )( 
            IRelationship * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *IsReal )( 
            IRelationship * This,
            /* [retval][out] */ __RPC__out BOOL *pIsReal);
        
        HRESULT ( STDMETHODCALLTYPE *Destination )( 
            IRelationship * This,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pDestinationEntity);
        
        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
            IRelationship * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
            IRelationship * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase);
        
        END_INTERFACE
    } IRelationshipVtbl;

    interface IRelationship
    {
        CONST_VTBL struct IRelationshipVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRelationship_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRelationship_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRelationship_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRelationship_Name(This,ppszName)	\
    ( (This)->lpVtbl -> Name(This,ppszName) ) 

#define IRelationship_IsReal(This,pIsReal)	\
    ( (This)->lpVtbl -> IsReal(This,pIsReal) ) 

#define IRelationship_Destination(This,pDestinationEntity)	\
    ( (This)->lpVtbl -> Destination(This,pDestinationEntity) ) 

#define IRelationship_MetaData(This,riid,pMetaData)	\
    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 

#define IRelationship_DefaultPhrase(This,ppszPhrase)	\
    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRelationship_INTERFACE_DEFINED__ */


#ifndef __INamedEntity_INTERFACE_DEFINED__
#define __INamedEntity_INTERFACE_DEFINED__

/* interface INamedEntity */
/* [unique][uuid][object][helpstring] */ 


EXTERN_C const IID IID_INamedEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ABDBD0B1-7D54-49fb-AB5C-BFF4130004CD")
    INamedEntity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValue) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE DefaultPhrase( 
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamedEntity * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamedEntity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamedEntity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            INamedEntity * This,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszValue);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *DefaultPhrase )( 
            INamedEntity * This,
            /* [retval][out] */ 
            __deref_opt_out  LPWSTR *ppszPhrase);
        
        END_INTERFACE
    } INamedEntityVtbl;

    interface INamedEntity
    {
        CONST_VTBL struct INamedEntityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedEntity_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamedEntity_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamedEntity_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamedEntity_GetValue(This,ppszValue)	\
    ( (This)->lpVtbl -> GetValue(This,ppszValue) ) 

#define INamedEntity_DefaultPhrase(This,ppszPhrase)	\
    ( (This)->lpVtbl -> DefaultPhrase(This,ppszPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamedEntity_INTERFACE_DEFINED__ */


#ifndef __ISchemaProvider_INTERFACE_DEFINED__
#define __ISchemaProvider_INTERFACE_DEFINED__

/* interface ISchemaProvider */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ISchemaProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8CF89BCB-394C-49b2-AE28-A59DD4ED7F68")
    ISchemaProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Entities( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pEntities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RootEntity( 
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pRootEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEntity( 
            /* [in] */ __RPC__in LPCWSTR pszEntityName,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pEntity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MetaData( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Localize( 
            /* [in] */ LCID lcid,
            /* [in] */ __RPC__in_opt ISchemaLocalizerSupport *pSchemaLocalizerSupport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveBinary( 
            /* [in] */ __RPC__in LPCWSTR pszSchemaBinaryPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LookupAuthoredNamedEntity( 
            /* [in] */ __RPC__in_opt IEntity *pEntity,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
            /* [in] */ ULONG cTokensBegin,
            /* [out] */ __RPC__out ULONG *pcTokensLength,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Entities )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pEntities);
        
        HRESULT ( STDMETHODCALLTYPE *RootEntity )( 
            ISchemaProvider * This,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pRootEntity);
        
        HRESULT ( STDMETHODCALLTYPE *GetEntity )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in LPCWSTR pszEntityName,
            /* [retval][out] */ __RPC__deref_out_opt IEntity **pEntity);
        
        HRESULT ( STDMETHODCALLTYPE *MetaData )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **pMetaData);
        
        HRESULT ( STDMETHODCALLTYPE *Localize )( 
            ISchemaProvider * This,
            /* [in] */ LCID lcid,
            /* [in] */ __RPC__in_opt ISchemaLocalizerSupport *pSchemaLocalizerSupport);
        
        HRESULT ( STDMETHODCALLTYPE *SaveBinary )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in LPCWSTR pszSchemaBinaryPath);
        
        HRESULT ( STDMETHODCALLTYPE *LookupAuthoredNamedEntity )( 
            ISchemaProvider * This,
            /* [in] */ __RPC__in_opt IEntity *pEntity,
            /* [in] */ __RPC__in LPCWSTR pszInputString,
            /* [in] */ __RPC__in_opt ITokenCollection *pTokenCollection,
            /* [in] */ ULONG cTokensBegin,
            /* [out] */ __RPC__out ULONG *pcTokensLength,
            /* [out] */ __RPC__deref_out_opt LPWSTR *ppszValue);
        
        END_INTERFACE
    } ISchemaProviderVtbl;

    interface ISchemaProvider
    {
        CONST_VTBL struct ISchemaProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaProvider_Entities(This,riid,pEntities)	\
    ( (This)->lpVtbl -> Entities(This,riid,pEntities) ) 

#define ISchemaProvider_RootEntity(This,pRootEntity)	\
    ( (This)->lpVtbl -> RootEntity(This,pRootEntity) ) 

#define ISchemaProvider_GetEntity(This,pszEntityName,pEntity)	\
    ( (This)->lpVtbl -> GetEntity(This,pszEntityName,pEntity) ) 

#define ISchemaProvider_MetaData(This,riid,pMetaData)	\
    ( (This)->lpVtbl -> MetaData(This,riid,pMetaData) ) 

#define ISchemaProvider_Localize(This,lcid,pSchemaLocalizerSupport)	\
    ( (This)->lpVtbl -> Localize(This,lcid,pSchemaLocalizerSupport) ) 

#define ISchemaProvider_SaveBinary(This,pszSchemaBinaryPath)	\
    ( (This)->lpVtbl -> SaveBinary(This,pszSchemaBinaryPath) ) 

#define ISchemaProvider_LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue)	\
    ( (This)->lpVtbl -> LookupAuthoredNamedEntity(This,pEntity,pszInputString,pTokenCollection,cTokensBegin,pcTokensLength,ppszValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaProvider_INTERFACE_DEFINED__ */


#ifndef __ITokenCollection_INTERFACE_DEFINED__
#define __ITokenCollection_INTERFACE_DEFINED__

/* interface ITokenCollection */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ITokenCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22D8B4F2-F577-4adb-A335-C2AE88416FAB")
    ITokenCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NumberOfTokens( 
            __RPC__in ULONG *pCount) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetToken( 
            /* [in] */ ULONG i,
            /* [out] */ 
            __out_opt  ULONG *pBegin,
            /* [out] */ 
            __out_opt  ULONG *pLength,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppsz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITokenCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITokenCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITokenCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITokenCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *NumberOfTokens )( 
            ITokenCollection * This,
            __RPC__in ULONG *pCount);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ITokenCollection * This,
            /* [in] */ ULONG i,
            /* [out] */ 
            __out_opt  ULONG *pBegin,
            /* [out] */ 
            __out_opt  ULONG *pLength,
            /* [out] */ 
            __deref_opt_out  LPWSTR *ppsz);
        
        END_INTERFACE
    } ITokenCollectionVtbl;

    interface ITokenCollection
    {
        CONST_VTBL struct ITokenCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITokenCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITokenCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITokenCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITokenCollection_NumberOfTokens(This,pCount)	\
    ( (This)->lpVtbl -> NumberOfTokens(This,pCount) ) 

#define ITokenCollection_GetToken(This,i,pBegin,pLength,ppsz)	\
    ( (This)->lpVtbl -> GetToken(This,i,pBegin,pLength,ppsz) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITokenCollection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_structuredquery_0000_0013 */
/* [local] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL___MIDL_itf_structuredquery_0000_0013_0001
    {	NEC_LOW	= 0,
	NEC_MEDIUM	= ( NEC_LOW + 1 ) ,
	NEC_HIGH	= ( NEC_MEDIUM + 1 ) 
    } 	NAMED_ENTITY_CERTAINTY;



extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_structuredquery_0000_0013_v0_0_s_ifspec;

#ifndef __INamedEntityCollector_INTERFACE_DEFINED__
#define __INamedEntityCollector_INTERFACE_DEFINED__

/* interface INamedEntityCollector */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_INamedEntityCollector;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF2440F6-8AFC-47d0-9A7F-396A0ACFB43D")
    INamedEntityCollector : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ ULONG beginSpan,
            /* [in] */ ULONG endSpan,
            /* [in] */ ULONG beginActual,
            /* [in] */ ULONG endActual,
            /* [in] */ __RPC__in_opt IEntity *pType,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [in] */ NAMED_ENTITY_CERTAINTY certainty) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamedEntityCollectorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamedEntityCollector * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamedEntityCollector * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamedEntityCollector * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            INamedEntityCollector * This,
            /* [in] */ ULONG beginSpan,
            /* [in] */ ULONG endSpan,
            /* [in] */ ULONG beginActual,
            /* [in] */ ULONG endActual,
            /* [in] */ __RPC__in_opt IEntity *pType,
            /* [in] */ __RPC__in LPCWSTR pszValue,
            /* [in] */ NAMED_ENTITY_CERTAINTY certainty);
        
        END_INTERFACE
    } INamedEntityCollectorVtbl;

    interface INamedEntityCollector
    {
        CONST_VTBL struct INamedEntityCollectorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamedEntityCollector_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INamedEntityCollector_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INamedEntityCollector_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INamedEntityCollector_Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty)	\
    ( (This)->lpVtbl -> Add(This,beginSpan,endSpan,beginActual,endActual,pType,pszValue,certainty) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INamedEntityCollector_INTERFACE_DEFINED__ */


#ifndef __ISchemaLocalizerSupport_INTERFACE_DEFINED__
#define __ISchemaLocalizerSupport_INTERFACE_DEFINED__

/* interface ISchemaLocalizerSupport */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_ISchemaLocalizerSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CA3FDCA2-BFBE-4eed-90D7-0CAEF0A1BDA1")
    ISchemaLocalizerSupport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Localize( 
            /* [in] */ __RPC__in LPCWSTR pszGlobalString,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszLocalString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISchemaLocalizerSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISchemaLocalizerSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISchemaLocalizerSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISchemaLocalizerSupport * This);
        
        HRESULT ( STDMETHODCALLTYPE *Localize )( 
            ISchemaLocalizerSupport * This,
            /* [in] */ __RPC__in LPCWSTR pszGlobalString,
            /* [retval][out] */ __RPC__deref_out_opt LPWSTR *ppszLocalString);
        
        END_INTERFACE
    } ISchemaLocalizerSupportVtbl;

    interface ISchemaLocalizerSupport
    {
        CONST_VTBL struct ISchemaLocalizerSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISchemaLocalizerSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISchemaLocalizerSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISchemaLocalizerSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISchemaLocalizerSupport_Localize(This,pszGlobalString,ppszLocalString)	\
    ( (This)->lpVtbl -> Localize(This,pszGlobalString,ppszLocalString) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISchemaLocalizerSupport_INTERFACE_DEFINED__ */


#ifndef __IQueryParserManager_INTERFACE_DEFINED__
#define __IQueryParserManager_INTERFACE_DEFINED__

/* interface IQueryParserManager */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IQueryParserManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A879E3C4-AF77-44fb-8F37-EBD1487CF920")
    IQueryParserManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateLoadedParser( 
            /* [in] */ __RPC__in LPCWSTR pszCatalog,
            /* [in] */ LANGID langidForKeywords,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppQueryParser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeOptions( 
            /* [in] */ BOOL fUnderstandNQS,
            /* [in] */ BOOL fAutoWildCard,
            /* [in] */ __RPC__in_opt IQueryParser *pQueryParser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryParserManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryParserManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryParserManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryParserManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateLoadedParser )( 
            IQueryParserManager * This,
            /* [in] */ __RPC__in LPCWSTR pszCatalog,
            /* [in] */ LANGID langidForKeywords,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][retval][out] */ __RPC__deref_out_opt void **ppQueryParser);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeOptions )( 
            IQueryParserManager * This,
            /* [in] */ BOOL fUnderstandNQS,
            /* [in] */ BOOL fAutoWildCard,
            /* [in] */ __RPC__in_opt IQueryParser *pQueryParser);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IQueryParserManager * This,
            /* [in] */ QUERY_PARSER_MANAGER_OPTION option,
            /* [in] */ __RPC__in const PROPVARIANT *pOptionValue);
        
        END_INTERFACE
    } IQueryParserManagerVtbl;

    interface IQueryParserManager
    {
        CONST_VTBL struct IQueryParserManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryParserManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IQueryParserManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IQueryParserManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IQueryParserManager_CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser)	\
    ( (This)->lpVtbl -> CreateLoadedParser(This,pszCatalog,langidForKeywords,riid,ppQueryParser) ) 

#define IQueryParserManager_InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser)	\
    ( (This)->lpVtbl -> InitializeOptions(This,fUnderstandNQS,fAutoWildCard,pQueryParser) ) 

#define IQueryParserManager_SetOption(This,option,pOptionValue)	\
    ( (This)->lpVtbl -> SetOption(This,option,pOptionValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IQueryParserManager_INTERFACE_DEFINED__ */



#ifndef __StructuredQuery1_LIBRARY_DEFINED__
#define __StructuredQuery1_LIBRARY_DEFINED__

/* library StructuredQuery1 */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_StructuredQuery1;

EXTERN_C const CLSID CLSID_QueryParser;

#ifdef __cplusplus

class DECLSPEC_UUID("B72F8FD8-0FAB-4dd9-BDBF-245A6CE1485B")
QueryParser;
#endif

EXTERN_C const CLSID CLSID_NegationCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("8DE9C74C-605A-4acd-BEE3-2B222AA2D23D")
NegationCondition;
#endif

EXTERN_C const CLSID CLSID_CompoundCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("116F8D13-101E-4fa5-84D4-FF8279381935")
CompoundCondition;
#endif

EXTERN_C const CLSID CLSID_LeafCondition;

#ifdef __cplusplus

class DECLSPEC_UUID("52F15C89-5A17-48e1-BBCD-46A3F89C7CC2")
LeafCondition;
#endif

EXTERN_C const CLSID CLSID_ConditionFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("E03E85B0-7BE3-4000-BA98-6C13DE9FA486")
ConditionFactory;
#endif

EXTERN_C const CLSID CLSID_Interval;

#ifdef __cplusplus

class DECLSPEC_UUID("D957171F-4BF9-4de2-BCD5-C70A7CA55836")
Interval;
#endif

EXTERN_C const CLSID CLSID_QueryParserManager;

#ifdef __cplusplus

class DECLSPEC_UUID("5088B39A-29B4-4d9d-8245-4EE289222F66")
QueryParserManager;
#endif
#endif /* __StructuredQuery1_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\tabflicks.h ===
#pragma once

#define FLICK_WM_HANDLED_MASK 0x1
#define NUM_FLICK_DIRECTIONS 8

typedef enum FLICKDIRECTION
{
    FLICKDIRECTION_MIN = 0,
    FLICKDIRECTION_RIGHT = 0,
    FLICKDIRECTION_UPRIGHT = 1,
    FLICKDIRECTION_UP = 2,
    FLICKDIRECTION_UPLEFT = 3,
    FLICKDIRECTION_LEFT = 4,
    FLICKDIRECTION_DOWNLEFT = 5,
    FLICKDIRECTION_DOWN = 6,
    FLICKDIRECTION_DOWNRIGHT = 7,
    FLICKDIRECTION_INVALID = 8,
}FLICKDIRECTION;

typedef enum FLICKMODE
{
    FLICKMODE_MIN = 0,
    FLICKMODE_OFF = 0,
    FLICKMODE_ON = 1, 
    FLICKMODE_LEARNING = 2, 
    FLICKMODE_MAX = 2,
    FLICKMODE_DEFAULT = 2,
}FLICKMODE;

typedef enum FLICKACTION_COMMANDCODE
{
    FLICKACTION_COMMANDCODE_NULL = 0,
    FLICKACTION_COMMANDCODE_SCROLL = 1,
    FLICKACTION_COMMANDCODE_APPCOMMAND = 2,
    FLICKACTION_COMMANDCODE_CUSTOMKEY = 3,
    FLICKACTION_COMMANDCODE_KEYMODIFIER = 4,
}FLICKACTION_COMMANDCODE;

typedef struct FLICK_POINT
{
    INT x:16;
    INT y:16;
}FLICK_POINT;

typedef struct FLICK_DATA
{
    FLICKACTION_COMMANDCODE iFlickActionCommandCode:5;
    FLICKDIRECTION iFlickDirection:3;
    BOOL fControlModifier:1;
    BOOL fMenuModifier:1;
    BOOL fAltGRModifier:1;
    BOOL fWinModifier:1;
    BOOL fShiftModifier:1;
    INT  iReserved:2;
    BOOL fOnInkingSurface:1;
    INT  iActionArgument:16;
}FLICK_DATA;

typedef enum SCROLLDIRECTION
{
    SCROLLDIRECTION_UP = 0,
    SCROLLDIRECTION_DOWN = 1,
}SCROLLDIRECTION;

typedef enum KEYMODIFIER
{
    KEYMODIFIER_CONTROL = 1,
    KEYMODIFIER_MENU = 2,
    KEYMODIFIER_SHIFT = 4,
    KEYMODIFIER_WIN = 8,
    KEYMODIFIER_ALTGR = 16,
    KEYMODIFIER_EXT = 32,
}KEYMODIFIER;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\suppress.h ===
#pragma once
//
// DO NOT EDIT THIS FILE
//
// Auto-generated from directory %SDXROOT%\sdktools\analysis\prefast\suppression\inc 
//   using file %SDXROOT%\tools\analysis\x86\OACR\inc\pftwarnings.h
//
#if _MSC_VER <= 1400
#pragma warning(disable: 4068)	// turn off unknown pragma warning so prefast pragmas won't show
				// show up in build.wrn/build.err
#endif



#ifdef _PREFAST_
#if( _MSC_VER < 1400 ) 



#define __WARNING_USING_UNINIT_VAR 1
#define __WARNING_DEREF_NULL_PTR 11
#define __WARNING_MEMORY_LEAK 14



#define __WARNING_USING_TAINTED_DATA 29



#define __WARNING_RETVAL_IGNORED_FUNC_COULD_FAIL 31



#define __WARNING_MISSING_ZERO_TERMINATION 53



#define __WARNING_USE_SAFER_FUNCTION 56
#define __WARNING_CHAR_BYTE_SIZE_MISMATCH 57



#define __WARNING_BAD_CONCATENATION 59



#define __WARNING_MISSING_STRING_ARGUMENT_TO_FORMAT_FUNCTION 63
#define __WARNING_MISSING_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 64
#define __WARNING_NON_POINTER_ARGUMENT_TO_FORMAT_FUNCTION 66
#define __WARNING_NON_STRING_ARGUMENT_TO_FORMAT_FUNCTION 67
#define __WARNING_GRATUITOUS_CALL_TO_FORMAT_FUNCTION 69



#define __WARNING_INDEX_EXCEEDS_MAX_NONSTACK 200
#define __WARNING_INDEX_EXCEEDS_MAX 201
#define __WARNING_BUFFER_OVERRUN 202
#define __WARNING_BUFFER_OVERRUN_NONSTACK 203
#define __WARNING_UNVALIDATED_PARAM 204
#define __WARNING_STACK_BUFFER_EVIL_FUNCTION 205
#define __WARNING_GENERIC_OVERRUN_EVIL_FUNCTION 207
#define __WARNING_SIZEOF_CHAR_BYTE_SIZE_MISMATCH 209



#define __WARNING_MEMORY_LEAK_EXCEPTION 211



#define __WARNING_CAST_HRESULT_TO_BOOL 214
#define __WARNING_CAST_BOOL_TO_HRESULT 215
#define __WARNING_COMPILER_INSERTED_CAST_BOOL_TO_HRESULT 216
#define __WARNING_TESTING_HRESULT_WITH_NOT 217
#define __WARNING_COMPARING_HRESULT_TO_ONE 219
#define __WARNING_COMPARING_HRESULT_TO_MINUS_ONE 220
#define __WARNING_COMPARING_HRESULT_TO_INT 221
#define __WARNING_ASSIGNING_ONE_TO_HRESULT 225
#define __WARNING_ASSIGNING_MINUS_ONE_TO_HRESULT 226
#define __WARNING_USING_HRESULT_IN_BOOLEAN_CONTEXT 230
#define __WARNING_RETURNING_ONE_AS_HRESULT 231



#define __WARNING_NONZEROLOGICALOR 235
#define __WARNING_LOGICALORNONZERO 236
#define __WARNING_ZEROLOGICALANDLOSINGSIDEEFFECTS 237
#define __WARNING_NONZEROLOGICALAND 239
#define __WARNING_LOGICALANDNONZERO 240
#define __WARNING_COLLIDEDRETURNFROMTRYFINALLY 241
#define __WARNING_LOCALUNWINDFORCED 242
#define __WARNING_GLOBALUNWINDHALTED 243
#define __WARNING_LOCALDECLHIDESGLOBAL 244
#define __WARNING_FORINITDECLHIDESGLOBAL 245
#define __WARNING_LOCALDECLHIDESLOCAL 246
#define __WARNING_FORINITDECLHIDESLOCAL 247
#define __WARNING_CREATINGNULLDACL 248
#define __WARNING_KERNELUNRELEASEDVADS 249
#define __WARNING_WIN32UNRELEASEDVADS 250
#define __WARNING_INITCRITSRAISESONFAILURE 251
#define __WARNING_UNTAGGEDALLOCATION 252
#define __WARNING_MMSECUREVMNEARLYUSELESS 253
#define __WARNING_UNPROTECTEDUSEOFALLOCA 255
#define __WARNING_PROHIBITEDUSEOFALLOCA 257
#define __WARNING_USINGTERMINATETHREAD 258
#define __WARNING_DEADCODEINBITORLIMITEDSWITCH 259
#define __WARNING_USEOFBYTEAREA 260
#define __WARNING_MUSTSUCCEEDALLOCATION 261
#define __WARNING_EXCESSIVESTACKUSAGE 262
#define __WARNING_USINGALLOCAINLOOP 263



#define __WARNING_MISPARENTHESIZED_CASTS 268
#define __WARNING_POINTER_DEREF_DISCARDED 269
#define __WARNING_MISSING_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 270
#define __WARNING_EXTRA_ARGUMENT_TO_FORMAT_FUNCTION 271
#define __WARNING_NON_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 272
#define __WARNING_NON_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 273
#define __WARNING_NON_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 274
#define __WARNING_CHAR_TO_WCHAR_CAST 276
#define __WARNING_CREATEPROCESS_ESCAPE 277
#define __WARNING_ARRAY_NEW_DELETE_MISMATCH 278
#define __WARNING_NEW_ARRAY_DELETE_MISMATCH 279
#define __WARNING_MEMORY_ALLOCATION_MISMATCH 280



#define __WARNING_BITWISERELATIONPRECEDENCEERROR 281
#define __WARNING_ASSIGNMENTREPLACESTEST 282



#define __WARNING_PRIMITIVE_ARRAY_NEW_DELETE_MISMATCH 283
#define __WARNING_OBJECT_AS_STRING_ARGUMENT_TO_FORMAT_FUNCTION 284



#define __WARNING_LOGICALOROFCONSTANTS 285
#define __WARNING_NONZEROLOGICALORLOSINGSIDEEFFECTS 286
#define __WARNING_REDUNDANTTEST 287
#define __WARNING_MUTUALINCLUSIONOVERANDISFALSE 288
#define __WARNING_MUTUALEXCLUSIONOVERORISTRUE 289
#define __WARNING_LOGICALNOTBITWISEAND 290
#define __WARNING_LOGICALNOTBITWISEOR 291



#define __WARNING_LOOP_COUNTS_UP_FROM_MAX 292
#define __WARNING_LOOP_INDEX_GOES_NEGATIVE 293
#define __WARNING_LOOP_BODY_NEVER_EXECUTED 294
#define __WARNING_INFINITE_LOOP 295
#define __WARNING_LOOP_ONLY_EXECUTED_ONCE 296



#define __WARNING_RESULTOFSHIFTCASTTOLARGERSIZE 297



#define __WARNING_CONST_STRING_TO_WRITABLE_STRING 298
#define __WARNING_BITFIELD_TO_BOOL_COMPARISON 299
#define __WARNING_DISCARDED_TOP_LEVEL_EXPRESSION 300
#define __WARNING_DEPRECATED_FUNCTION_USAGE 301
#define __WARNING_CHAR_WCHAR_ARGUMENT_TO_FORMAT_FUNCTION 302
#define __WARNING_WCHAR_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 303
#define __WARNING_ADDRESSOF_LOCAL_ARRAY 304



#define __WARNING_SIZEOF_COUNTOF_MISMATCH 305



#define __WARNING_INCORRECT_VARARG_FUNCTIONCALL 306
#define __WARNING_WCHAR_TO_BSTR 307



#define __WARNING_REALLOCLEAK 308



#define __WARNING_PASSING_FUNCTION_UNEXPECTED_NULL 309



#define __WARNING_ILLEGALEXCEPTEXPRCONST 310



#define __WARNING_USE_OTHER_FUNCTION 311



#define __WARNING_EXCEPTIONCONTINUEEXECUTION 312
#define __WARNING_BITANDVSZEROVALUEDFLAG 313
#define __WARNING_BITORVSQUESTION 314
#define __WARNING_BITORVSBITAND 315
#define __WARNING_INAPPROPRIATEUSEOFBITOR 316
#define __WARNING_NOTNOTCOMPLEMENT 317
#define __WARNING_EXCEPTIONCONTINUESEARCH 318
#define __WARNING_IGNOREDBYCOMMA 319



#define __WARNING_EXCEPT_BLOCK_EMPTY 322
#define __WARNING_ARITH_OP_ON_BOOL 323
#define __WARNING_STRCPY_INSTEAD_OF_STRCMP 324
#define __WARNING_NULL_COMPARISON_FOR_BSTR 325
#define __WARNING_CONST_CONST_COMP 326
#define __WARNING_DEST_BUFFER_INSUFFICIENT 327
#define __WARNING_POTENTIAL_ARGUMENT_TYPE_MISMATCH 328
#define __WARNING_POTENTIAL_INCORRECT_RETVAL_CHECK 329



#define __WARNING_VIRTUALFREEINVALIDPARAM1 331
#define __WARNING_VIRTUALFREEINVALIDPARAM2 332
#define __WARNING_VIRTUALFREEINVALIDPARAM3 333
#define __WARNING_SIZEOFEXPR 334



#define __WARNING_LEAKING_PROCESS_HANDLE 335



#define __WARNING_QUESTIONPRECEDENCE 336



#define __WARNING_CODE_REVIEW_GROUP_350 350
#define __WARNING_CODE_REVIEW_GROUP_351 351
#define __WARNING_CODE_REVIEW_GROUP_352 352
#define __WARNING_CODE_REVIEW_GROUP_353 353
#define __WARNING_CODE_REVIEW_GROUP_354 354
#define __WARNING_CODE_REVIEW_GROUP_355 355
#define __WARNING_CODE_REVIEW_GROUP_356 356
#define __WARNING_CODE_REVIEW_GROUP_357 357
#define __WARNING_CODE_REVIEW_GROUP_358 358
#define __WARNING_CODE_REVIEW_GROUP_359 359
#define __WARNING_CODE_REVIEW_GROUP_360 360
#define __WARNING_CODE_REVIEW_GROUP_361 361
#define __WARNING_CODE_REVIEW_GROUP_362 362
#define __WARNING_CODE_REVIEW_GROUP_363 363
#define __WARNING_CODE_REVIEW_GROUP_364 364
#define __WARNING_CODE_REVIEW_GROUP_365 365
#define __WARNING_CODE_REVIEW_GROUP_366 366
#define __WARNING_CODE_REVIEW_GROUP_367 367
#define __WARNING_CODE_REVIEW_GROUP_368 368
#define __WARNING_CODE_REVIEW_GROUP_369 369
#define __WARNING_CODE_REVIEW_GROUP_370 370
#define __WARNING_CODE_REVIEW_GROUP_371 371
#define __WARNING_CODE_REVIEW_GROUP_372 372
#define __WARNING_CODE_REVIEW_GROUP_373 373
#define __WARNING_CODE_REVIEW_GROUP_374 374
#define __WARNING_CODE_REVIEW_GROUP_375 375
#define __WARNING_CODE_REVIEW_GROUP_376 376
#define __WARNING_CODE_REVIEW_GROUP_377 377
#define __WARNING_CODE_REVIEW_GROUP_378 378
#define __WARNING_CODE_REVIEW_GROUP_379 379



#define __WARNING_LEGACY_SHUTDOWN_API 380
#define __WARNING_SHUTDOWN_API 381
#define __WARNING_SHUTDOWN_RESOURCE_ID 382



#define __WARNING_ELEMENTS_TO_BYTES 383
#define __WARNING_DIVIDING_SIZEOF_POINTER 384



#define __WARNING_READ_OVERRUN 385
#define __WARNING_WRITE_OVERRUN 386
#define __WARNING_INVALID_PARAM_VALUE_1 387
#define __WARNING_INVALID_PARAM_VALUE_2 388



#define __WARNING_LOCALE_DEPENDENT_CONSTANT_STRING_COMPARISON 400
#define __WARNING_DEFAULT_LOCALE_CONSTANT_STRING_COMPARISON 401



#define __WARNING_POTENTIAL_READ_OVERRUN 411
#define __WARNING_POTENTIAL_WRITE_OVERRUN 412



#define __WARNING_INITIATE_SHUTDOWN_API 413



#define __WARNING_LC_ALL_PASSED_AS_FIRST_PARAM_TO_SETLOCALE 431
#define __WARNING_OVERRIDING_LOCALE_SETTINGS_WITH_SETLOCALEINFO 433
#define __WARNING_CALLING_SETTHREADLOCALE 434
#define __WARNING_CALLING_GETUSERDEFAULTLCID 435
#define __WARNING_CALLING_GETSYSTEMDEFAULTLCID 436
#define __WARNING_CALLING_GETSYSTEMDEFAULTUILANGUAGE 437
#define __WARNING_CALLING_GETUSERDEFAULTUILANGUAGE 438
#define __WARNING_CALLING_ANSI_API_FOR_WINDOW_CREATION_OR_RESOURCE_LOADING 439



#define __WARNING_CHECKFORTRUNCATION 503
#define __WARNING_HRESULT_FROM_WIN32_WITH_FUNCTION 505
#define __WARNING_PREFER_PATHFILEEXISTSANDATTRIBUTES 506
#define __WARNING_PREFER_DEFAULTSTACKSIZE 507
#define __WARNING_SETWINDOWPOS_MISUSE1 508
#define __WARNING_SETWINDOWPOS_MISUSE2 509
#define __WARNING_SETWINDOWPOS_MISUSE3 510
#define __WARNING_PREFER_STRCATBUFF 511
#define __WARNING_OBSOLETE_FUNCTION 512
#define __WARNING_AVOID_COMPLEX_DLLMAIN 513
#define __WARNING_CREATEFILEMAPPING_MISUSE1 514
#define __WARNING_COM_OBJECT_DESTRUCTOR 518
#define __WARNING_CATCH_ALL 519
#define __WARNING_HEAP_BUFFER_OVERFLOW 520
#define __WARNING_MEMSET_ZEROMEMORY 521
#define __WARNING_AVOID_PROPVARIANT_VARIANT_CASTS 526
#define __WARNING_DEACTIVATECONTEXT_OUTSIDE_FINALLY 527
#define __WARNING_AVOID_EXT_TEXT_OUT_CALL 528
#define __WARNING_AVOID_MUTABLE_VALUE_VARIANT 529
#define __WARNING_CAST_64STAR_TO_32STAR 531
#define __WARNING_CAST_FFFFFFFF_TO_64BIT 532
#define __WARNING_MUST_CHECK_S_OK 535
#define __WARNING_LOCALREALLOC_LPTR 541
#define __WARNING_ALLOCA_RESETSTKOFLW_CATCH 543
#define __WARNING_FOR_SCOPE_IGNORED 549
#define __WARNING_INCORRECT_USAGE_OF_BOOL_AND_VARIANT_BOOL 551



#define __WARNING_BUFFER_OVERFLOW 2000
#define __WARNING_BUFFER_UNDERFLOW 2001
#define __WARNING_READ_UNTRACKED_BUFFER 2002
#define __WARNING_UNTRACKED_BUFFER 2003
#define __WARNING_UNINITIALIZED_POINTER 2004
#define __WARNING_ZEROLENGTHARRAY 2005
#define __WARNING_INCORRECT_ANNOTATION_STRING 2006
#define __WARNING_INCORRECT_ANNOTATION 2007
#define __WARNING_BUFFERACCESS 2009
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW 2010
#define __WARNING_POTENTIAL_BUFFER_UNDERFLOW 2011
#define __WARNING_UNTRACKED_BUFFER_BUT_UNANNOTATABLE 2012
#define __WARNING_COMPLEX_EXPR 2013
#define __WARNING_INCORRECT_VALIDATION 2014
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_HIGH_PRIORITY 2015
#define __WARNING_BUFFER_OVERFLOW_NULL_TERMINATED 2016
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_MISC 2017
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED 2018
#define __WARNING_INSANE_ANNOTATION 2020
#define __WARNING_ANNOTATION_MISMATCH_MISSING_FIRST 2021
#define __WARNING_ANNOTATION_MISMATCH_MISSING_SECOND 2022
#define __WARNING_ANNOTATION_MISMATCH 2023
#define __WARNING_POSTCONDITION_BUFFER_OVERFLOW 2030
#define __WARNING_POSTCONDITION_BUFFER_UNDERFLOW 2031
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_OVERFLOW 2040
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_UNDERFLOW 2041
#define __WARNING_INCORRECT_VALIDATION_POSTCONDITION 2044
#define __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION 2045
#define __WARNING_CHECKER_ASSERTION_FAILURE 2050
#define __WARNING_IRREDUCIBLE_CFG 2051
#define __WARNING_POTENTIALLY_UNCONSTRAINED_CALL 2052
#define __WARNING_RANGE_PRECONDITION_VIOLATION 2060
#define __WARNING_RANGE_POSTCONDITION_VIOLATION 2061
#define __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION 2070
#define __WARNING_POTENTIAL_RANGE_POSTCONDITION_VIOLATION 2071
#define __WARNING_VALIDATED_ACCESS 2080
#define __WARNING_USING_STRUCT_ANNOTATION 2081
#define __WARNING_SUSPICIOUS_FUNCTION_POINTER_CAST 2090



#define __WARNING_BIG_FORMAL_PARAM 5400
#define __WARNING_IMPLICIT_CTOR 5401
#define __WARNING_UPCAST_CTOR 5402
#define __WARNING_NONCONST_LOCAL 5403
#define __WARNING_NONCONST_PARAM 5404
#define __WARNING_NONCONST_FUNCTION 5405
#define __WARNING_UNUSED_PARAM 5406
#define __WARNING_STATIC_FUNCTION 5407
#define __WARNING_FREE_CONSTRUCTOR_CALL 5408
#define __WARNING_IDENTITY_ASSIGNMENT 5409
#define __WARNING_VIRTUAL_CALL_IN_CTOR 5410
#define __WARNING_CASE_FALLTHRU 5411
#define __WARNING_SMARTPOINTER_DELETE 5412
#define __WARNING_RETURN_FROM_GOTO_CONTEXT 5413
#define __WARNING_MISSING_OVERRIDE 5414
#define __WARNING_DOESNT_OVERRIDE 5415
#define __WARNING_OVERRIDE_CONST_MISMATCH 5416
#define __WARNING_OVERRIDING_NONVIRTUAL 5417
#define __WARNING_DIFFERENT_CALLING_CONVENTION 5418
#define __WARNING_VERYBIG_FORMAL_PARAM 5419
#define __WARNING_SAMENAME_DATAMEMBER 5420
#define __WARNING_POOR_DATAALIGNMENT 5421
#define __WARNING_REMOVERETURNCONST_FUNCTIONCAST 5422
#define __WARNING_BOGUS_BSTRCONST 5423
#define __WARNING_DANGEROUS_POINTERCAST 5424
#define __WARNING_UNSAFE_STRING_FUNCTION 5425
#define __WARNING_OBSOLETE_INI_ACCESSOR 5426
#define __WARNING_BANNED_FUNCTION 5427
#define __WARNING_FUNCTION_NEEDS_REVIEW 5428
#define __WARNING_OBSOLETE_ACL_FUNCTION 5429
#define __WARNING_BOGUS_EXPRESSION_LIST 5430
#define __WARNING_HRESULT_NOT_CHECKED 5431
#define __WARNING_NONCONST_LOCAL_BUFFERPTR 5432
#define __WARNING_NONCONST_BUFFER_PARAM 5433
#define __WARNING_INCOMPLETE_MEMBER_FUNCTION_CALL 5434
#define __WARNING_SIZEOF_POINTER_IN_DIVISION 5435
#define __WARNING_STATIC_MASKING_VIRTUAL 5436
#define __WARNING_TRUE_CONSTANT_EXPR_IN_AND 5437
#define __WARNING_FALSE_CONSTANT_EXPR_IN_AND 5438
#define __WARNING_TRUE_CONSTANT_EXPR_IN_OR 5439
#define __WARNING_FALSE_CONSTANT_EXPR_IN_OR 5440
#define __WARNING_IF_CONDITION_IS_ALWAYS_TRUE 5441
#define __WARNING_IF_CONDITION_IS_ALWAYS_FALSE 5442
#define __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR 5443
#define __WARNING_BSTR_PARAM_SHOULD_BE_CONST_WCHAR_PTR 5444
#define __WARNING_ISBADPTR_FUNCTION 5445
#define __WARNING_SPECIFY_SELECTANY 5446
#define __WARNING_INCORRECT_SELECTANY 5447
#define __WARNING_STRINGCONST_ASSIGNED_TO_NONCONST 5448
#define __WARNING_FREESTANDING_CONSTANT 5449
#define __WARNING_LOCAL_FUNCDECL 5450
#define __WARNING_DIFFERENT_RETURN_TYPE_SIZE 5451
#define __WARNING_DIFFERENT_RETURN_TYPE_KIND 5452
#define __WARNING_DIFFERENT_PARAM_COUNT 5453
#define __WARNING_DIFFERENT_PARAM_TYPE_SIZE 5454
#define __WARNING_DIFFERENT_PARAM_TYPE_KIND 5455
#define __WARNING_REMOVEPARAMCONST_FUNCTIONCAST 5456
#define __WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER 5457
#define __WARNING_CAST_CAN_BE_CONST 5458
#define __WARNING_SUPERFLUOUS_CAST 5459
#define __WARNING_SUPERFLUOUS_NOTNOT 5460
#define __WARNING_BACKWARD_JUMP 5461
#define __WARNING_BACKWARD_JUMP_IN_MACRO 5462
#define __WARNING_FILEMAPPING_WITH_GLOBAL_NAME 5463
#define __WARNING_FUNCTION_CALLED_TWICE_IN_MACRO 5464
#define __WARNING_UNSIGNED_SHORT_NEGATIVE_INT_COMPARISON 5465
#define __WARNING_OUTOFRANGE_SHORT_LONG_COMPARISON 5466
#define __WARNING_UNREACHABLE_CASE_LABEL 5467
#define __WARNING_USE_WIDE_API 5468
#define __WARNING_GOTO 5469
#define __WARNING_UNINITIALIZED_DATAMEMBER 5470
#define __WARNING_NO_MEMBERINIT 5471
#define __WARNING_INCONSISTENT_COUNT_ANNOTATIONS_IN_PROTOTYPE_AND_DEFINITION 5472
#define __WARNING_WRONG_MEMBERINIT_ORDER 5473
#define __WARNING_FORMAL_TYPE_MISMATCH 5474
#define __WARNING_NOHEAP_MEMBER 5475
#define __WARNING_NOHEAP_BASECLASS 5476
#define __WARNING_NEW_ON_NOHEAP 5477
#define __WARNING_CONDITIONAL_WITH_FALSE_TRUE 5478
#define __WARNING_CONDITIONAL_WITH_TRUE_FALSE 5479
#define __WARNING_CONDITIONAL_WITH_SAME_ALTERNATIVES 5480
#define __WARNING_INVALID_COUNT_ANNOTATION_ARGUMENT 5481
#define __WARNING_MULTIPLE_COUNT_ANNOTATIONS 5482
#define __WARNING_DEPRECATED_NOCOUNT 5483
#define __WARNING_DANGEROUS_ALL_ACCESS_ACL 5484
#define __WARNING_URL_NEEDS_TO_BE_REVIEWED 5485
#define __WARNING_SD_REQUIRED_FOR_NAMED_OBJECT 5486
#define __WARNING_UNSPECIFIED_ACCESSRIGHTS 5487
#define __WARNING_USE_CONST_MACRO_FOR_ANNOTATION 5488
#define __WARNING_DEPRECATED_WIN16_FUNCTION 5489
#define __WARNING_USE_CPLUSPLUS_BOOL_CONST 5490
#define __WARNING_RETURNTYPE_CAN_BE_BOOL 5491
#define __WARNING_LOCAL_CAN_BE_BOOL 5492
#define __WARNING_FORMAL_CAN_BE_BOOL 5493
#define __WARNING_BASECLASS_SHOULDHAVE_PROTECTED_OR_VIRTUAL_DTOR 5494
#define __WARNING_HUNGARIAN_INFERRED 5495
#define __WARNING_ENUM_TYPEDEF 5496
#define __WARNING_INTEGRAL_CAST_TO_OBJECT_WITH_VTABLE 5498
#define __WARNING_USE_PREFIX_OPERATOR 5499
#define __WARNING_LHS_TEMP_OBJECT 5500
#define __WARNING_RHS_TEMP_OBJECT 5501
#define __WARNING_EXC_NOT_CAUGHT_BY_REFERENCE 5502
#define __WARNING_EXC_NOT_THROWN_BY_VALUE 5503
#define __WARNING_INCONSISTENT_DECLSPECS 5504
#define __WARNING_SEALED_BASE_CLASS 5505
#define __WARNING_SEALED_BASE_METHOD 5506
#define __WARNING_NOTRUNCCAST_PARAM 5507
#define __WARNING_UNBOUND_RETURN 5508
#define __WARNING_MISSING_BINDRETURN 5509
#define __WARNING_CLARYFY_PRECEDENCE_FOR_QUESTIONOPERATOR 5510
#define __WARNING_DEPRECATED_FUNCTION 5512
#define __WARNING_DEPRECATED_LANGUAGE_TYPE_USED 5513
#define __WARNING_UNMARKED_INTL_DEPRECATED_FUNCTION 5514
#define __WARNING_DEPRECATED_INTL_FUNCTION_CALL 5515
#define __WARNING_ANNOTATION_ARG_WITHOUT_DEREF 5516
#define __WARNING_ANNOTATION_ARG_WITH_DEREF 5517
#define __WARNING_NONPTR_COUNT_ANNOTATION 5518
#define __WARNING_OLEO_DEPRECATED_FUNCTION 5519
#define __WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER 5520
#define __WARNING_ILLEGAL_SAL_ANNOTATION_SYNTAX 5521
#define __WARNING_SAL_DEREF_AT_NONPOINTER 5522
#define __WARNING_OLEO_BANNED_FUNCTION 5523
#define __WARNING_RETURNING_TEMP_OBJECT 5524
#define __WARNING_STRCPY_LOOP 5525
#define __WARNING_POSSIBLE_STRCPY_LOOP 5526
#define __WARNING_MISSING_ANNOTATION 5527



#define __WARNING_AVOID_BLOCKING_HWNDBROADCAST 8601
#define __WARNING_AVOID_TIMEOUT_HWNDBROADCAST 8602
#define __WARNING_AVOID_SENDMESSAGE_TIMEOUT_MISUSE 8604
#define __WARNING_ALLOCA_RESETSTKOFLW 8615
#define __WARNING_INTERLOCKEDDECREMENT_MISUSE1 8616
#define __WARNING_AVOID_BEGIN_THREAD_RETURN_VALUE 8617
#define __WARNING_UNSIGNED_CAST_OF_GETMESSAGEPOS 8623
#define __WARNING_UNRELEASED_REF 8624
#define __WARNING_COMPILER_OPTIMIZATES_OUT_CLEARING_SENSITIVEDATA 8625
#define __WARNING_LOCAL_FREE_NONALLOCATED 8636
#define __WARNING_UNSAFE_CALL_IN_GLOBAL_INIT 8637
#define __WARNING_DLOAD_FUNCDEFN 8638
#define __WARNING_CLOSEHANDLE_STRING 8639
#define __WARNING_DLOAD_FUNCSTATIC 8640
#define __WARNING_BAD_POSTMESSAGE_FLAG 8642
#define __WARNING_DPA_INSERTPTR_RETURN 8644
#define __WARNING_OBSOLETE_MESSAGE_SYMBOL_QUESTION 8645
#define __WARNING_DO_NOT_USE_PULSEEVENT 8648
#define __WARNING_REDUNDANT_CHECK_FOR_ARRAY_IS_NOT_NULL 8649
#define __WARNING_IMPROPER_NOT_OPERATOR_ON_ZERO 8650
#define __WARNING_IMPROPER_CHAR_ARRAY_PTR_TO_CHAR_PTR_CAST 8651
#define __WARNING_CAST_NTSTATUS_TO_BOOL 8714
#define __WARNING_CAST_BOOL_TO_NTSTATUS 8715
#define __WARNING_COMPILER_INSERTED_CAST_BOOL_TO_NTSTATUS 8716
#define __WARNING_INVALID_VARIANT_TYPE 8717
#define __WARNING_UNANNOTATED_BUFFER 8718
#define __WARNING_BANNED_API_USAGE 8719
#define __WARNING_ISBADXXXPTR_API_USAGE 8720
#define __WARNING_DEPRECATED_PERF_COUNT 8721
#define __WARNING_UNANNOTATED_BUFFER_IN_DECL 8722
#define __WARNING_UNANNOTATED_BUFFER_IN_DEFN_WO_DECL 8723
#define __WARNING_SETUNHANDLEDEXCEPTIONFILTER_USE 8725



#define __WARNING_ALLOC_SIZE_OVERFLOW 12011
#define __WARNING_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 12012
#define __WARNING_INDEX_WRONG_OVERFLOW_CHECK 12013
#define __WARNING_ALLOC_SIZE_NEGATIVE 12014
#define __WARNING_INDEX_NEGATIVE 12015
#define __WARNING_LOOP_INDEX_WRONG_OVERFLOW_CHECK 12016
#define __WARNING_ALLOC_SIZE_UNDERFLOW 12017
#define __WARNING_INDEX_UNDERFLOW 12018
#define __WARNING_LOOP_INDEX_UNDERFLOW 12019
#define __WARNING_SIGNED_UNSIGNED_COMPARISON 12020
#define __WARNING_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 12021
#define __WARNING_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 12022
#define __WARNING_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 12023
#define __WARNING_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 12024
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW 12051
#define __WARNING_UNTRUSTED_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 12052
#define __WARNING_UNTRUSTED_INDEX_WRONG_OVERFLOW_CHECK 12053
#define __WARNING_UNTRUSTED_ALLOC_SIZE_NEGATIVE 12054
#define __WARNING_UNTRUSTED_INDEX_NEGATIVE 12055
#define __WARNING_UNTRUSTED_LOOP_INDEX_WRONG_OVERFLOW_CHECK 12056
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW 12057
#define __WARNING_UNTRUSTED_INDEX_UNDERFLOW 12058
#define __WARNING_UNTRUSTED_LOOP_INDEX_UNDERFLOW 12059
#define __WARNING_UNTRUSTED_SIGNED_UNSIGNED_COMPARISON 12060
#define __WARNING_UNTRUSTED_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 12061
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 12062
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 12063
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 12064
#define __WARNING_UNTRUSTED_ALLOC_SIZE 12081
#define __WARNING_UNTRUSTED_INDEX 12082
#define __WARNING_UNTRUSTED_LOOP_INDEX 12083
#define __WARNING_UNTRUSTED_OVERFLOWN_EXPR 12084
#define __WARNING_UNTRUSTED_UNDERFLOWN_EXPR 12085



#define __WARNING_UNRELATED_SIZE_BUFFER_ACCESS 12101
#define __WARNING_UNRELATED_LOOP_TERMINATION 12102
#define __WARNING_UNRELATED_LOOP_TERMINATION_NO_SIZEEXPR 12103
#define __WARNING_BUFFER_COPY_NO_KNOWN_SIZEEXPR 12104
#define __WARNING_BUFFER_COPY_NO_PREDICATE 12105
#define __WARNING_BUFFER_COPY_SOURCE_LEN 12106
#define __WARNING_BUFFER_COPY_STRUCT_FIELD_ANNOTATION 12107
#define __WARNING_SIZEEXPR_NOT_REINIT 12108
#define __WARNING_MOVE_OBJECT_WITH_VTABLE_TO_HEAP 12109
#define __WARNING_ENCODE_GLOBAL_FUNCTION_POINTER 12110
#define __WARNING_ENCODE_GLOBAL_DISPATCH_TABLE 12111
#define __WARNING_ENCODE_MEMBER_FUNCTION_POINTER 12112
#define __WARNING_ENCODE_MEMBER_DISPATCH_TABLE 12113
#define __WARNING_MISSING_ENCODE_ASSIGNMENT 12114
#define __WARNING_MISSING_DECODE_CALL 12115
#define __WARNING_BUFFER_COPY_FUNCTION_NO_PREDICATE 12116



#define __WARNING_ACCESSIBILITY_COLORAPI 13502
#define __WARNING_ACCESSIBILITY_CLIPCURSOR 13503



#define __WARNING_MISMATCH_RETURN_TYPE 13601
#define __WARNING_MISMATCH_INITEXPR_TYPE 13602
#define __WARNING_MISMATCH_ASSIGNMENT_TYPE 13603
#define __WARNING_MISMATCH_FORMAL_TYPE_AT_CALL 13604
#define __WARNING_MISMATCH_ADD_PROPERTY 13605
#define __WARNING_MISMATCH_REMOVE_PROPERTY 13606
#define __WARNING_MISMATCH_POST_TYPE 13607
#define __WARNING_MISMATCH_FORMAL_VALID_AT_CALL 13608
#define __WARNING_MISMATCH_FORMAL_VALIDSRC_AT_CALL 13609
#define __WARNING_MISMATCH_REFERENCE_VALID 13610
#define __WARNING_MISMATCH_REFERENCE_VALIDSRC 13611
#define __WARNING_MISMATCH_MEMBER_VALID 13612
#define __WARNING_MISMATCH_MEMBER_VALIDSRC 13613
#define __WARNING_MISMATCH_IN_UNTRUSTED_DATA_SPECS 13614
#define __WARNING_POTENTIAL_FILE_READ 13615
#define __WARNING_CONSUMES_UNTRUSTED_DATA 13616
#define __WARNING_MISMATCH_PUBLIC_FORMAL_VALID_AT_CALL 13617
#define __WARNING_FILE_PARSER_CLASS 13620
#define __WARNING_FILE_PARSER_FUNCTION 13621
#define __WARNING_MISMATCH_RETURN_TYPE_COMPNAME 13622
#define __WARNING_MISMATCH_INITEXPR_TYPE_COMPNAME 13623
#define __WARNING_MISMATCH_ASSIGNMENT_TYPE_COMPNAME 13624
#define __WARNING_MISMATCH_FORMAL_TYPE_AT_CALL_COMPNAME 13625
#define __WARNING_MISMATCH_ADD_PROPERTY_COMPNAME 13626
#define __WARNING_MISMATCH_REMOVE_PROPERTY_COMPNAME 13627
#define __WARNING_MISMATCH_POST_TYPE_COMPNAME 13628
#define __WARNING_ALLOCATOR 13629



#define __WARNING_TEMP_FILE 13700
#define __WARNING_ZERO_DIVISION 13701
#define __WARNING_ZERO_DIVISION_WITH_FIELD 13702
#define __WARNING_PARAMETER_BUFFER_TO_STRUCT_CAST 13703
#define __WARNING_MEMBER_BUFFER_TO_STRUCT_CAST 13704
#define __WARNING_SAFE_AFTER_UNSAFE_ARITHMETIC 13705
#define __WARNING_UNSAFE_AFTER_SAFE_ARITHMETIC 13706
#define __WARNING_PARAMETER_BUFFER_IN_MEMCPY 13707
#define __WARNING_MEMBER_BUFFER_IN_MEMCPY 13708
#define __WARNING_PARAMETER_BUFFER_IN_WRITE_CALL 13709
#define __WARNING_PARAMETER_BUFFER_IN_READ_CALL 13710
#define __WARNING_MEMBER_BUFFER_IN_WRITE_CALL 13711
#define __WARNING_MEMBER_BUFFER_IN_READ_CALL 13712
#define __WARNING_PARAMETER_BUFFER_UPDATED_INSIDE_LOOP 13713
#define __WARNING_PARAMETER_BUFFER_UPDATED_OUTSIDE_LOOP 13714
#define __WARNING_MEMBER_BUFFER_UPDATED_INSIDE_LOOP 13715
#define __WARNING_MEMBER_BUFFER_UPDATED_OUTSIDE_LOOP 13716



#define __WARNING_CONTROL_ENTRY 13900



#define __WARNING_IPV6_NAME_RESOLUTION_IPV4_SPECIFIC 24001
#define __WARNING_IPV6_ADDRESS_STRUCTURE_IPV4_SPECIFIC 24002
#define __WARNING_IPV6_MULTICAST_IPV4_SPECIFIC 24003
#define __WARNING_IPV6_CONSTANT_IPV4_SPECIFIC 24004
#define __WARNING_IPV6_OBSOLETE_FUNCTION 24005
#define __WARNING_IPV6_DEPRECATED_FUNCTION 24006
#define __WARNING_IPV6_USE_EX_VERSION 24007
#define __WARNING_IPV6_INVALID_DEVICE 24008
#define __WARNING_IPV6_DEPRECATED_IOCTL 24009



#define __WARNING_FILESUCCESS 98101
#define __WARNING_FILEFAILURE 98102



#define __WARNING_INTERNALERROR 99101
#define __WARNING_INTERNALEXCEPTION 99102
#define __WARNING_INTERNALCOMEXCEPTION 99103
#define __WARNING_PLUGINVERSIONMISMATCH 99104

#else 



#define __WARNING_USING_UNINIT_VAR 6001
#define __WARNING_DEREF_NULL_PTR 6011
#define __WARNING_MEMORY_LEAK 6014
#define __WARNING_USING_TAINTED_DATA 6029
#define __WARNING_RETVAL_IGNORED_FUNC_COULD_FAIL 6031
#define __WARNING_MISSING_ZERO_TERMINATION1 6053
#define __WARNING_MISSING_ZERO_TERMINATION2 6054
#define __WARNING_CHAR_BYTE_SIZE_MISMATCH 6057
#define __WARNING_BAD_CONCATENATION 6059
#define __WARNING_MISSING_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6063
#define __WARNING_MISSING_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6064
#define __WARNING_NON_POINTER_ARGUMENT_TO_FORMAT_FUNCTION 6066
#define __WARNING_NON_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6067
#define __WARNING_INDEX_EXCEEDS_MAX_NONSTACK 6200
#define __WARNING_INDEX_EXCEEDS_MAX 6201
#define __WARNING_BUFFER_OVERRUN 6202
#define __WARNING_BUFFER_OVERRUN_NONSTACK 6203
#define __WARNING_UNVALIDATED_PARAM 6204
#define __WARNING_SIZEOF_CHAR_BYTE_SIZE_MISMATCH 6209
#define __WARNING_MEMORY_LEAK_EXCEPTION 6211
#define __WARNING_CAST_HRESULT_TO_BOOL 6214
#define __WARNING_CAST_BOOL_TO_HRESULT 6215
#define __WARNING_COMPILER_INSERTED_CAST_BOOL_TO_HRESULT 6216
#define __WARNING_TESTING_HRESULT_WITH_NOT 6217
#define __WARNING_COMPARING_HRESULT_TO_ONE 6219
#define __WARNING_COMPARING_HRESULT_TO_MINUS_ONE 6220
#define __WARNING_COMPARING_HRESULT_TO_INT 6221
#define __WARNING_ASSIGNING_ONE_TO_HRESULT 6225
#define __WARNING_ASSIGNING_MINUS_ONE_TO_HRESULT 6226
#define __WARNING_USING_HRESULT_IN_BOOLEAN_CONTEXT 6230
#define __WARNING_NONZEROLOGICALOR 6235
#define __WARNING_LOGICALORNONZERO 6236
#define __WARNING_ZEROLOGICALANDLOSINGSIDEEFFECTS 6237
#define __WARNING_NONZEROLOGICALAND 6239
#define __WARNING_LOGICALANDNONZERO 6240
#define __WARNING_LOCALUNWINDFORCED 6242
#define __WARNING_LOCALDECLHIDESGLOBAL 6244
#define __WARNING_LOCALDECLHIDESLOCAL 6246
#define __WARNING_CREATINGNULLDACL 6248
#define __WARNING_WIN32UNRELEASEDVADS 6250
#define __WARNING_UNPROTECTEDUSEOFALLOCA 6255
#define __WARNING_USINGTERMINATETHREAD 6258
#define __WARNING_DEADCODEINBITORLIMITEDSWITCH 6259
#define __WARNING_USEOFBYTEAREA 6260
#define __WARNING_EXCESSIVESTACKUSAGE 6262
#define __WARNING_USINGALLOCAINLOOP 6263
#define __WARNING_STRING_LITERAL_TO_NONCONST_CAST 6267
#define __WARNING_MISPARENTHESIZED_CASTS 6268
#define __WARNING_POINTER_DEREF_DISCARDED 6269
#define __WARNING_MISSING_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6270
#define __WARNING_EXTRA_ARGUMENT_TO_FORMAT_FUNCTION 6271
#define __WARNING_NON_FLOAT_ARGUMENT_TO_FORMAT_FUNCTION 6272
#define __WARNING_NON_INTEGER_ARGUMENT_TO_FORMAT_FUNCTION 6273
#define __WARNING_NON_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6274
#define __WARNING_CHAR_TO_WCHAR_CAST 6276
#define __WARNING_CREATEPROCESS_ESCAPE 6277
#define __WARNING_ARRAY_NEW_DELETE_MISMATCH 6278
#define __WARNING_NEW_ARRAY_DELETE_MISMATCH 6279
#define __WARNING_MEMORY_ALLOCATION_MISMATCH 6280
#define __WARNING_BITWISERELATIONPRECEDENCEERROR 6281
#define __WARNING_ASSIGNMENTREPLACESTEST 6282
#define __WARNING_PRIMITIVE_ARRAY_NEW_DELETE_MISMATCH 6283
#define __WARNING_OBJECT_AS_STRING_ARGUMENT_TO_FORMAT_FUNCTION 6284
#define __WARNING_LOGICALOROFCONSTANTS 6285
#define __WARNING_NONZEROLOGICALORLOSINGSIDEEFFECTS 6286
#define __WARNING_REDUNDANTTEST 6287
#define __WARNING_MUTUALINCLUSIONOVERANDISFALSE 6288
#define __WARNING_MUTUALEXCLUSIONOVERORISTRUE 6289
#define __WARNING_LOGICALNOTBITWISEAND 6290
#define __WARNING_LOGICALNOTBITWISEOR 6291
#define __WARNING_LOOP_COUNTS_UP_FROM_MAX 6292
#define __WARNING_LOOP_INDEX_GOES_NEGATIVE 6293
#define __WARNING_LOOP_BODY_NEVER_EXECUTED 6294
#define __WARNING_INFINITE_LOOP 6295
#define __WARNING_LOOP_ONLY_EXECUTED_ONCE 6296
#define __WARNING_RESULTOFSHIFTCASTTOLARGERSIZE 6297
#define __WARNING_CONST_STRING_TO_WRITABLE_STRING 6298
#define __WARNING_BITFIELD_TO_BOOL_COMPARISON 6299
#define __WARNING_CHAR_WCHAR_ARGUMENT_TO_FORMAT_FUNCTION 6302
#define __WARNING_WCHAR_CHAR_ARGUMENT_TO_FORMAT_FUNCTION 6303
#define __WARNING_SIZEOF_COUNTOF_MISMATCH 6305
#define __WARNING_INCORRECT_VARARG_FUNCTIONCALL 6306
#define __WARNING_WCHAR_TO_BSTR 6307
#define __WARNING_REALLOCLEAK 6308
#define __WARNING_PASSING_FUNCTION_UNEXPECTED_NULL 6309
#define __WARNING_ILLEGALEXCEPTEXPRCONST 6310
#define __WARNING_EXCEPTIONCONTINUEEXECUTION 6312
#define __WARNING_BITANDVSZEROVALUEDFLAG 6313
#define __WARNING_BITORVSQUESTION 6314
#define __WARNING_BITORVSBITAND 6315
#define __WARNING_INAPPROPRIATEUSEOFBITOR 6316
#define __WARNING_NOTNOTCOMPLEMENT 6317
#define __WARNING_EXCEPTIONCONTINUESEARCH 6318
#define __WARNING_IGNOREDBYCOMMA 6319
#define __WARNING_EXCEPTIONEXECUTEHANDLER 6320
#define __WARNING_EXCEPT_BLOCK_EMPTY 6322
#define __WARNING_ARITH_OP_ON_BOOL 6323
#define __WARNING_STRCPY_INSTEAD_OF_STRCMP 6324
#define __WARNING_CONST_CONST_COMP 6326
#define __WARNING_DEST_BUFFER_INSUFFICIENT 6327
#define __WARNING_POTENTIAL_ARGUMENT_TYPE_MISMATCH 6328
#define __WARNING_POTENTIAL_INCORRECT_RETVAL_CHECK 6329
#define __WARNING_VIRTUALFREEINVALIDPARAM1 6331
#define __WARNING_VIRTUALFREEINVALIDPARAM2 6332
#define __WARNING_VIRTUALFREEINVALIDPARAM3 6333
#define __WARNING_SIZEOFEXPR 6334
#define __WARNING_LEAKING_PROCESS_HANDLE 6335
#define __WARNING_QUESTIONPRECEDENCE 6336
#define __WARNING_SHUTDOWN_API 6381
#define __WARNING_ELEMENTS_TO_BYTES 6383
#define __WARNING_DIVIDING_SIZEOF_POINTER 6384
#define __WARNING_READ_OVERRUN 6385
#define __WARNING_WRITE_OVERRUN 6386
#define __WARNING_INVALID_PARAM_VALUE_1 6387
#define __WARNING_INVALID_PARAM_VALUE_2 6388
#define __WARNING_BOOL_VARIANT_BOOL_COMPARISON 6392
#define __WARNING_COMPARE64BIT 6393
#define __WARNING_MS03_026_LHS 6394
#define __WARNING_LOCALE_DEPENDENT_CONSTANT_STRING_COMPARISON 6400
#define __WARNING_DEFAULT_LOCALE_CONSTANT_STRING_COMPARISON 6401
#define __WARNING_INVALID_ATTRIBUTE_PROPERTY 6500
#define __WARNING_CONFLICTING_ATTRIBUTE_PROPERTY_VALUES 6501
#define __WARNING_REFERENCES_CANT_BE_NULL 6503
#define __WARNING_NULL_ON_NON_POINTER 6504
#define __WARNING_MUSTCHECK_ON_VOID 6505
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER_OR_ARRAY 6506
#define __WARNING_NULL_MISMATCH_AT_DEREF_0 6507
#define __WARNING_WRITE_ACCESS_ON_CONST 6508
#define __WARNING_RETURN_USED_ON_PRECONDITION 6509
#define __WARNING_NULLTERMINATED_ON_NON_POINTER 6510
#define __WARNING_MUSTCHECK_MAYBE 6511
#define __WARNING_NULL_CONFLICTS_WITH_NOT_VALID 6512
#define __WARNING_ELEMENT_SIZE_WITHOUT_BUFFER_SIZE 6513
#define __WARNING_BUFFER_SIZE_EXCEEDS_ARRAY_SIZE 6514
#define __WARNING_BUFFER_SIZE_ON_NON_POINTER 6515
#define __WARNING_NO_PROPERTIES_ON_ATTRIBUTE 6516
#define __WARNING_VALID_SIZE_ON_NON_READABLE_BUFFER 6517
#define __WARNING_WRITABLE_SIZE_ON_NON_WRITABLE_BUFFER 6518
#define __WARNING_NEEDSRELEASE_MAYBE 6519
#define __WARNING_INVALID_SIZE_STRING_DEREF 6521
#define __WARNING_INVALID_SIZE_STRING_TYPE 6522
#define __WARNING_INVALID_SIZE_STRING_PARAM 6523
#define __WARNING_INVALID_SIZE_STRING_UNREACHABLE_LOCATION 6525
#define __WARNING_INVALID_SIZE_STRING_BUFFER_TYPE 6526
#define __WARNING_NEEDSRELEASE_ON_VOID 6527
#define __WARNING_UNRECOGNIZED_FORMAT_STRING_STYLE 6530
#define __WARNING_BUFFERSIZE_INFEASIBLE 6535
#define __WARNING_MANAGEDCODENOTSUPPORTED 6990
#define __WARNING_ATTRIBUTESNOTSUPPORTED 6991
#define __WARNING_NATIVEEVENTSYNTAXNOTSUPPORTED 6992
#define __WARNING_OMPNOTSUPPORTED 6993
#define __WARNING_PCHNOTFOUND 6994
#define __WARNING_SAVETOXMLFAILED 6995



#define __WARNING_DUMMY_IO_WARNING1 22010
#define __WARNING_ALLOC_SIZE_OVERFLOW 22011
#define __WARNING_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22012
#define __WARNING_INDEX_WRONG_OVERFLOW_CHECK 22013
#define __WARNING_ALLOC_SIZE_NEGATIVE 22014
#define __WARNING_INDEX_NEGATIVE 22015
#define __WARNING_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22016
#define __WARNING_ALLOC_SIZE_UNDERFLOW 22017
#define __WARNING_INDEX_UNDERFLOW 22018
#define __WARNING_LOOP_INDEX_UNDERFLOW 22019
#define __WARNING_SIGNED_UNSIGNED_COMPARISON 22020
#define __WARNING_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22021
#define __WARNING_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22022
#define __WARNING_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22023
#define __WARNING_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22024
#define __WARNING_RETVAL_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22025
#define __WARNING_REFARG_IS_USED_IN_ALLOC_SIZE_COMPUTATION 22026
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22027
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22028
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22029
#define __WARNING_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22030
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW 22051
#define __WARNING_UNTRUSTED_ALLOC_SIZE_WRONG_OVERFLOW_CHECK 22052
#define __WARNING_UNTRUSTED_INDEX_WRONG_OVERFLOW_CHECK 22053
#define __WARNING_UNTRUSTED_ALLOC_SIZE_NEGATIVE 22054
#define __WARNING_UNTRUSTED_INDEX_NEGATIVE 22055
#define __WARNING_UNTRUSTED_LOOP_INDEX_WRONG_OVERFLOW_CHECK 22056
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW 22057
#define __WARNING_UNTRUSTED_INDEX_UNDERFLOW 22058
#define __WARNING_UNTRUSTED_LOOP_INDEX_UNDERFLOW 22059
#define __WARNING_UNTRUSTED_SIGNED_UNSIGNED_COMPARISON 22060
#define __WARNING_UNTRUSTED_DIFF_SIZE_SIGNED_UNSIGNED_COMPARISON 22061
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_WITH_ACCESS 22062
#define __WARNING_UNTRUSTED_ALLOC_SIZE_OVERFLOW_IN_ALLOC_WRAPPER 22063
#define __WARNING_UNTRUSTED_ALLOC_SIZE_UNDERFLOW_IN_ALLOC_WRAPPER 22064
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_RETVAL 22067
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOCATOR_SIZE_FUNC_REFARG 22068
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_SIZE 22069
#define __WARNING_UNTRUSTED_OVERFLOW_OR_UNDERFLOW_IN_ALLOC_WRAPPER 22070
#define __WARNING_UNTRUSTED_ALLOC_SIZE 22081
#define __WARNING_UNTRUSTED_INDEX 22082
#define __WARNING_UNTRUSTED_LOOP_INDEX 22083
#define __WARNING_UNTRUSTED_OVERFLOWN_EXPR 22084
#define __WARNING_UNTRUSTED_UNDERFLOWN_EXPR 22085



#define __WARNING_UNRELATED_SIZE_BUFFER_ACCESS 22101
#define __WARNING_UNRELATED_LOOP_TERMINATION 22102
#define __WARNING_UNRELATED_LOOP_TERMINATION_NO_SIZEEXPR 22103
#define __WARNING_BUFFER_COPY_NO_KNOWN_SIZEEXPR 22104
#define __WARNING_BUFFER_COPY_NO_PREDICATE 22105
#define __WARNING_BUFFER_COPY_SOURCE_LEN 22106
#define __WARNING_BUFFER_COPY_STRUCT_FIELD_ANNOTATION 22107
#define __WARNING_SIZEEXPR_NOT_REINIT 22108
#define __WARNING_MOVE_OBJECT_WITH_VTABLE_TO_HEAP 22109
#define __WARNING_ENCODE_GLOBAL_FUNCTION_POINTER 22110
#define __WARNING_ENCODE_GLOBAL_DISPATCH_TABLE 22111
#define __WARNING_ENCODE_MEMBER_FUNCTION_POINTER 22112
#define __WARNING_ENCODE_MEMBER_DISPATCH_TABLE 22113
#define __WARNING_MISSING_ENCODE_ASSIGNMENT 22114
#define __WARNING_MISSING_DECODE_CALL 22115
#define __WARNING_BUFFER_COPY_FUNCTION_NO_PREDICATE 22116
#define __WARNING_SENDMESSAGE_WITHOUT_CHECKING_BUFFER_SIZE 22117



#define __WARNING_MISMATCH_RETURN_TYPE 23601
#define __WARNING_MISMATCH_INITEXPR_TYPE 23602
#define __WARNING_MISMATCH_ASSIGNMENT_TYPE 23603
#define __WARNING_MISMATCH_FORMAL_TYPE_AT_CALL 23604
#define __WARNING_MISMATCH_ADD_PROPERTY 23605
#define __WARNING_MISMATCH_REMOVE_PROPERTY 23606
#define __WARNING_MISMATCH_POST_TYPE 23607
#define __WARNING_MISMATCH_FORMAL_VALID_AT_CALL 23608
#define __WARNING_MISMATCH_FORMAL_VALIDSRC_AT_CALL 23609
#define __WARNING_MISMATCH_REFERENCE_VALID 23610
#define __WARNING_MISMATCH_REFERENCE_VALIDSRC 23611
#define __WARNING_MISMATCH_MEMBER_VALID 23612
#define __WARNING_MISMATCH_MEMBER_VALIDSRC 23613
#define __WARNING_MISMATCH_IN_UNTRUSTED_DATA_SPECS 23614
#define __WARNING_POTENTIAL_FILE_READ 23615
#define __WARNING_CONSUMES_UNTRUSTED_DATA 23616
#define __WARNING_MISMATCH_PUBLIC_FORMAL_VALID_AT_CALL 23617
#define __WARNING_FILE_PARSER_CLASS 23620
#define __WARNING_FILE_PARSER_FUNCTION 23621
#define __WARNING_MISMATCH_RETURN_TYPE_COMPNAME 23622
#define __WARNING_MISMATCH_INITEXPR_TYPE_COMPNAME 23623
#define __WARNING_MISMATCH_ASSIGNMENT_TYPE_COMPNAME 23624
#define __WARNING_MISMATCH_FORMAL_TYPE_AT_CALL_COMPNAME 23625
#define __WARNING_MISMATCH_ADD_PROPERTY_COMPNAME 23626
#define __WARNING_MISMATCH_REMOVE_PROPERTY_COMPNAME 23627
#define __WARNING_MISMATCH_POST_TYPE_COMPNAME 23628
#define __WARNING_ALLOCATOR 23629



#define __WARNING_BIG_FORMAL_PARAM 25000
#define __WARNING_IMPLICIT_CTOR 25001
#define __WARNING_UPCAST_CTOR 25002
#define __WARNING_NONCONST_LOCAL 25003
#define __WARNING_NONCONST_PARAM 25004
#define __WARNING_NONCONST_FUNCTION 25005
#define __WARNING_UNUSED_PARAM 25006
#define __WARNING_STATIC_FUNCTION 25007
#define __WARNING_FREE_CONSTRUCTOR_CALL 25008
#define __WARNING_IDENTITY_ASSIGNMENT 25009
#define __WARNING_VIRTUAL_CALL_IN_CTOR 25010
#define __WARNING_CASE_FALLTHRU 25011
#define __WARNING_SMARTPOINTER_DELETE 25012
#define __WARNING_RETURN_FROM_GOTO_CONTEXT 25013
#define __WARNING_MISSING_OVERRIDE 25014
#define __WARNING_DOESNT_OVERRIDE 25015
#define __WARNING_OVERRIDE_CONST_MISMATCH 25016
#define __WARNING_OVERRIDING_NONVIRTUAL 25017
#define __WARNING_DIFFERENT_CALLING_CONVENTION 25018
#define __WARNING_VERYBIG_FORMAL_PARAM 25019
#define __WARNING_SAMENAME_DATAMEMBER 25020
#define __WARNING_POOR_DATAALIGNMENT 25021
#define __WARNING_REMOVERETURNCONST_FUNCTIONCAST 25022
#define __WARNING_BOGUS_BSTRCONST 25023
#define __WARNING_DANGEROUS_POINTERCAST 25024
#define __WARNING_UNSAFE_STRING_FUNCTION 25025
#define __WARNING_OBSOLETE_INI_ACCESSOR 25026
#define __WARNING_BANNED_FUNCTION 25027
#define __WARNING_FUNCTION_NEEDS_REVIEW 25028
#define __WARNING_OBSOLETE_ACL_FUNCTION 25029
#define __WARNING_BOGUS_EXPRESSION_LIST 25030
#define __WARNING_HRESULT_NOT_CHECKED 25031
#define __WARNING_NONCONST_LOCAL_BUFFERPTR 25032
#define __WARNING_NONCONST_BUFFER_PARAM 25033
#define __WARNING_SIZEOF_POINTER_IN_DIVISION 25035
#define __WARNING_STATIC_MASKING_VIRTUAL 25036
#define __WARNING_TRUE_CONSTANT_EXPR_IN_AND 25037
#define __WARNING_FALSE_CONSTANT_EXPR_IN_AND 25038
#define __WARNING_TRUE_CONSTANT_EXPR_IN_OR 25039
#define __WARNING_FALSE_CONSTANT_EXPR_IN_OR 25040
#define __WARNING_IF_CONDITION_IS_ALWAYS_TRUE 25041
#define __WARNING_IF_CONDITION_IS_ALWAYS_FALSE 25042
#define __WARNING_LOCAL_BSTR_SHOULD_BE_CONST_WCHAR_PTR 25043
#define __WARNING_BSTR_PARAM_SHOULD_BE_CONST_WCHAR_PTR 25044
#define __WARNING_ISBADPTR_FUNCTION 25045
#define __WARNING_SPECIFY_SELECTANY 25046
#define __WARNING_INCORRECT_SELECTANY 25047
#define __WARNING_STRINGCONST_ASSIGNED_TO_NONCONST 25048
#define __WARNING_FREESTANDING_CONSTANT 25049
#define __WARNING_LOCAL_FUNCDECL 25050
#define __WARNING_DIFFERENT_RETURN_TYPE_SIZE 25051
#define __WARNING_DIFFERENT_RETURN_TYPE_KIND 25052
#define __WARNING_DIFFERENT_PARAM_COUNT 25053
#define __WARNING_DIFFERENT_PARAM_TYPE_SIZE 25054
#define __WARNING_DIFFERENT_PARAM_TYPE_KIND 25055
#define __WARNING_REMOVEPARAMCONST_FUNCTIONCAST 25056
#define __WARNING_COUNT_REQUIRED_FOR_WRITABLE_BUFFER 25057
#define __WARNING_CAST_CAN_BE_CONST 25058
#define __WARNING_SUPERFLUOUS_CAST 25059
#define __WARNING_SUPERFLUOUS_NOTNOT 25060
#define __WARNING_BACKWARD_JUMP 25061
#define __WARNING_BACKWARD_JUMP_IN_MACRO 25062
#define __WARNING_FILEMAPPING_WITH_GLOBAL_NAME 25063
#define __WARNING_FUNCTION_CALLED_TWICE_IN_MACRO 25064
#define __WARNING_UNSIGNED_SHORT_NEGATIVE_INT_COMPARISON 25065
#define __WARNING_OUTOFRANGE_SHORT_LONG_COMPARISON 25066
#define __WARNING_UNREACHABLE_CASE_LABEL 25067
#define __WARNING_USE_WIDE_API 25068
#define __WARNING_GOTO 25069
#define __WARNING_UNINITIALIZED_DATAMEMBER 25070
#define __WARNING_NO_MEMBERINIT 25071
#define __WARNING_WRONG_MEMBERINIT_ORDER 25073
#define __WARNING_NOHEAP_MEMBER 25075
#define __WARNING_NOHEAP_BASECLASS 25076
#define __WARNING_NEW_ON_NOHEAP 25077
#define __WARNING_CONDITIONAL_WITH_FALSE_TRUE 25078
#define __WARNING_CONDITIONAL_WITH_TRUE_FALSE 25079
#define __WARNING_CONDITIONAL_WITH_SAME_ALTERNATIVES 25080
#define __WARNING_DANGEROUS_ALL_ACCESS_ACL 25084
#define __WARNING_URL_NEEDS_TO_BE_REVIEWED 25085
#define __WARNING_SD_REQUIRED_FOR_NAMED_OBJECT 25086
#define __WARNING_UNSPECIFIED_ACCESSRIGHTS 25087
#define __WARNING_DEPRECATED_WIN16_FUNCTION 25089
#define __WARNING_USE_CPLUSPLUS_BOOL_CONST 25090
#define __WARNING_RETURNTYPE_CAN_BE_BOOL 25091
#define __WARNING_LOCAL_CAN_BE_BOOL 25092
#define __WARNING_FORMAL_CAN_BE_BOOL 25093
#define __WARNING_BASECLASS_SHOULDHAVE_PROTECTED_OR_VIRTUAL_DTOR 25094
#define __WARNING_ENUM_TYPEDEF 25096
#define __WARNING_INTEGRAL_CAST_TO_OBJECT_WITH_VTABLE 25098
#define __WARNING_USE_PREFIX_OPERATOR 25099
#define __WARNING_LHS_TEMP_OBJECT 25100
#define __WARNING_RHS_TEMP_OBJECT 25101
#define __WARNING_EXC_NOT_CAUGHT_BY_REFERENCE 25102
#define __WARNING_EXC_NOT_THROWN_BY_VALUE 25103
#define __WARNING_INCONSISTENT_DECLSPECS 25104
#define __WARNING_SEALED_BASE_CLASS 25105
#define __WARNING_SEALED_BASE_METHOD 25106
#define __WARNING_NOTRUNCCAST_PARAM 25107
#define __WARNING_UNBOUND_RETURN 25108
#define __WARNING_MISSING_BINDRETURN 25109
#define __WARNING_CLARYFY_PRECEDENCE_FOR_QUESTIONOPERATOR 25110
#define __WARNING_DEPRECATED_FUNCTION 25112
#define __WARNING_DEPRECATED_LANGUAGE_TYPE_USED 25113
#define __WARNING_UNMARKED_INTL_DEPRECATED_FUNCTION 25114
#define __WARNING_DEPRECATED_INTL_FUNCTION_CALL 25115
#define __WARNING_OLEO_DEPRECATED_FUNCTION 25119
#define __WARNING_COUNT_REQUIRED_FOR_VOIDPTR_BUFFER 25120
#define __WARNING_OLEO_BANNED_FUNCTION 25123
#define __WARNING_RETURNING_TEMP_OBJECT 25124
#define __WARNING_STRCPY_LOOP 25125
#define __WARNING_POSSIBLE_STRCPY_LOOP 25126
#define __WARNING_BOOLEAN_BITWISE_OPERATOR_MIX 25127
#define __WARNING_DIFFERENT_COMPARE_ON_64BIT 25128
#define __WARNING_POSSIBLE_64BIT_TRUNCATION 25129
#define __WARNING_NONCONST_CLSID 25130



#define __WARNING_HUNGARIAN_INFERRED 25351
#define __WARNING_MISSING_ANNOTATION 25352
#define __WARNING_OVERRIDE_AT_NON_VIRTUAL 25353
#define __WARNING_OVERRIDE_AT_STATIC 25354
#define __WARNING_OVERRIDE_AT_BASECLASS 25355
#define __WARNING_ILLEGAL_ANNOTATION 25356
#define __WARNING_PRE_ANNOTATION_AT_RETURNVALUE 25357



#define __WARNING_BUFFER_OVERFLOW 26000
#define __WARNING_BUFFER_UNDERFLOW 26001
#define __WARNING_READ_UNTRACKED_BUFFER 26002
#define __WARNING_UNTRACKED_BUFFER 26003
#define __WARNING_UNINITIALIZED_POINTER 26004
#define __WARNING_ZEROLENGTHARRAY 26005
#define __WARNING_INCORRECT_ANNOTATION_STRING 26006
#define __WARNING_INCORRECT_ANNOTATION 26007
#define __WARNING_BUFFERACCESS 26009
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW 26010
#define __WARNING_POTENTIAL_BUFFER_UNDERFLOW 26011
#define __WARNING_UNTRACKED_BUFFER_BUT_UNANNOTATABLE 26012
#define __WARNING_COMPLEX_EXPR 26013
#define __WARNING_INCORRECT_VALIDATION 26014
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_HIGH_PRIORITY 26015
#define __WARNING_BUFFER_OVERFLOW_NULL_TERMINATED 26016
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_MISC 26017
#define __WARNING_POTENTIAL_BUFFER_OVERFLOW_NULLTERMINATED 26018
#define __WARNING_INSANE_ANNOTATION 26020
#define __WARNING_ANNOTATION_MISMATCH_MISSING_FIRST 26021
#define __WARNING_ANNOTATION_MISMATCH_MISSING_SECOND 26022
#define __WARNING_ANNOTATION_MISMATCH 26023
#define __WARNING_POSTCONDITION_BUFFER_OVERFLOW 26030
#define __WARNING_POSTCONDITION_BUFFER_UNDERFLOW 26031
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_OVERFLOW 26040
#define __WARNING_POTENTIAL_POSTCONDITION_BUFFER_UNDERFLOW 26041
#define __WARNING_INCORRECT_VALIDATION_POSTCONDITION 26044
#define __WARNING_HIGH_PRIORITY_OVERFLOW_POSTCONDITION 26045
#define __WARNING_CHECKER_ASSERTION_FAILURE 26050
#define __WARNING_IRREDUCIBLE_CFG 26051
#define __WARNING_POTENTIALLY_UNCONSTRAINED_CALL 26052
#define __WARNING_RANGE_PRECONDITION_VIOLATION 26060
#define __WARNING_RANGE_POSTCONDITION_VIOLATION 26061
#define __WARNING_POTENTIAL_RANGE_PRECONDITION_VIOLATION 26070
#define __WARNING_POTENTIAL_RANGE_POSTCONDITION_VIOLATION 26071
#define __WARNING_VALIDATED_ACCESS 26080
#define __WARNING_USING_STRUCT_ANNOTATION 26081
#define __WARNING_SUSPICIOUS_FUNCTION_POINTER_CAST 26090



#define __WARNING_AVOID_BLOCKING_HWNDBROADCAST 28601
#define __WARNING_AVOID_TIMEOUT_HWNDBROADCAST 28602
#define __WARNING_AVOID_SENDMESSAGE_TIMEOUT_MISUSE 28604
#define __WARNING_ALLOCA_RESETSTKOFLW 28615
#define __WARNING_INTERLOCKEDDECREMENT_MISUSE1 28616
#define __WARNING_AVOID_BEGIN_THREAD_RETURN_VALUE 28617
#define __WARNING_UNSIGNED_CAST_OF_GETMESSAGEPOS 28623
#define __WARNING_UNRELEASED_REF 28624
#define __WARNING_COMPILER_OPTIMIZATES_OUT_CLEARING_SENSITIVEDATA 28625
#define __WARNING_LOCAL_FREE_NONALLOCATED 28636
#define __WARNING_UNSAFE_CALL_IN_GLOBAL_INIT 28637
#define __WARNING_DLOAD_FUNCDEFN 28638
#define __WARNING_CLOSEHANDLE_STRING 28639
#define __WARNING_DLOAD_FUNCSTATIC 28640
#define __WARNING_BAD_POSTMESSAGE_FLAG 28642
#define __WARNING_DPA_INSERTPTR_RETURN 28644
#define __WARNING_OBSOLETE_MESSAGE_SYMBOL_QUESTION 28645
#define __WARNING_DO_NOT_USE_PULSEEVENT 28648
#define __WARNING_REDUNDANT_CHECK_FOR_ARRAY_IS_NOT_NULL 28649
#define __WARNING_IMPROPER_NOT_OPERATOR_ON_ZERO 28650
#define __WARNING_IMPROPER_CHAR_ARRAY_PTR_TO_CHAR_PTR_CAST 28651
#define __WARNING_CAST_NTSTATUS_TO_BOOL 28714
#define __WARNING_CAST_BOOL_TO_NTSTATUS 28715
#define __WARNING_COMPILER_INSERTED_CAST_BOOL_TO_NTSTATUS 28716
#define __WARNING_INVALID_VARIANT_TYPE 28717
#define __WARNING_UNANNOTATED_BUFFER 28718
#define __WARNING_BANNED_API_USAGE 28719
#define __WARNING_ISBADXXXPTR_API_USAGE 28720
#define __WARNING_DEPRECATED_PERF_COUNT 28721
#define __WARNING_UNANNOTATED_BUFFER_IN_DECL 28722
#define __WARNING_UNANNOTATED_BUFFER_IN_DEFN_WO_DECL 28723
#define __WARNING_SETUNHANDLEDEXCEPTIONFILTER_USE 28725
#define __WARNING_INCORRECT_NULLTERM_ASSIGN 28730



#define __WARNING_OUT_NOTNULL_ON_FAILURE 28901
#define __WARNING_QI_SUCCESS_NO_ADDREF 28903
#define __WARNING_BUFFER_SIZE_EQUALS_COUNT 28910
#define __WARNING_REDUNDANT_TEST_IN_MACRO 28920
#define __WARNING_REDUNDANT_POINTER_TEST_CLEANUP 28921
#define __WARNING_REDUNDANT_POINTER_TEST 28922
#define __WARNING_REDUNDANT_SCALAR_TEST 28923
#define __WARNING_REDUNDANT_POINTER_TEST_FAR_EVIDENCE 28924
#define __WARNING_POTENTIALLY_REDUNDANT_GLOBAL_POINTER_TEST 28925
#define __WARNING_UNUSED_POINTER_ASSIGNMENT 28930
#define __WARNING_UNUSED_SCALAR_ASSIGNMENT 28931
#define __WARNING_UNUSED_FORMALPARAM_ASSIGNMENT 28933
#define __WARNING_UNUSED_PTR2PTR_FORMALPARAM_ASSIGNMENT 28934
#define __WARNING_UNUSED_OUT_FORMALPARAM_ASSIGNMENT 28935
#define __WARNING_UNREACHABLE_CODE 28940
#define __WARNING_UNANNONATED_EXP_IN_VOLATILE_CONTEXT 28952
#define __WARNING_UNEXPECED_LEVEL_IN_VOLATILE_CONTEXT 28953
#define __WARNING_MULTIPLE_VOLATILE_ACCESS 28954
#define __WARNING_MULTIPLE_VOLATILE_ACCESS_FROM_ANNOT 28955
#define __WARNING_COMPILER_GENERATED_VOLATILE_CAST 28956
#define __WARNING_LOCAL_VARIABLE_IN_VOLATILE_CONTEXT 28957
#define __WARNING_MULTIPLE_VOLATILE_ACCESS_WITH_CALLS 28958
#define __WARNING_MULTIPLE_VOLATILE_ACCESS_FROM_ANNOT_WITH_CALLS 28959



#define __WARNING_ACCESSIBILITY_COLORAPI 30022
#define __WARNING_ACCESSIBILITY_CLIPCURSOR 30023



#define __WARNING_TEMP_FILE 33700
#define __WARNING_ZERO_DIVISION 33701
#define __WARNING_ZERO_DIVISION_WITH_FIELD 33702
#define __WARNING_PARAMETER_BUFFER_TO_STRUCT_CAST 33703
#define __WARNING_MEMBER_BUFFER_TO_STRUCT_CAST 33704
#define __WARNING_SAFE_AFTER_UNSAFE_ARITHMETIC 33705
#define __WARNING_UNSAFE_AFTER_SAFE_ARITHMETIC 33706
#define __WARNING_PARAMETER_BUFFER_IN_MEMCPY 33707
#define __WARNING_MEMBER_BUFFER_IN_MEMCPY 33708
#define __WARNING_PARAMETER_BUFFER_IN_WRITE_CALL 33709
#define __WARNING_PARAMETER_BUFFER_IN_READ_CALL 33710
#define __WARNING_MEMBER_BUFFER_IN_WRITE_CALL 33711
#define __WARNING_MEMBER_BUFFER_IN_READ_CALL 33712
#define __WARNING_PARAMETER_BUFFER_UPDATED_INSIDE_LOOP 33713
#define __WARNING_PARAMETER_BUFFER_UPDATED_OUTSIDE_LOOP 33714
#define __WARNING_MEMBER_BUFFER_UPDATED_INSIDE_LOOP 33715
#define __WARNING_MEMBER_BUFFER_UPDATED_OUTSIDE_LOOP 33716



#define __WARNING_NDIS_DRIVER_PARAMETER_BUFFER 33801
#define __WARNING_USE_FILE_DEVICE_SECURE_OPEN 33802
#define __WARNING_USE_SUFFIXED_CALL 33803
#define __WARNING_USE_RPC_IF_ALLOW_SECURE_ONLY 33804

#endif 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\SvcGuid.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    svcguid.h

Abstract:

    Defines GUIDs for well-known services including:

        HOSTNAME
        RFC 1060 (Assigned Numbers) from IANA (All TCP/IP Services)
        NetWare services

Created:

    May 8, 1994

Revision History:

--*/

#ifndef _SVCGUID_
#define _SVCGUID_

#if _MSC_VER > 1000
#pragma once
#endif

#include  <basetyps.h>

//
// HOSTNAME--special GUID which refers to the name of a host as opposed
// to any particular service on that host.
//

#define SVCID_HOSTNAME { 0x0002a800, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }

//
// GUIDs for dealing with AF_INET address spaces alone. These are
// intended to be used when fetching hostent or servent information
// from such a provider. These are not general-purpose types and
// should be used only when the intent is getting at down-level
// information.
//

#define SVCID_INET_HOSTADDRBYINETSTRING \
              { 0x0002a801, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }
#define SVCID_INET_SERVICEBYNAME \
                  { 0x0002a802, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }
#define SVCID_INET_HOSTADDRBYNAME \
                  { 0x0002a803, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }

//
// Macros for defining and testing TCP and UDP GUIDs from a well-known
// port.
//

#define SVCID_TCP_RR(_Port, _RR) \
             { (0x0009 << 16) | (_Port), 0, _RR, { 0xC0,0,0,0,0,0,0,0x46 } }

#define SVCID_TCP(_Port)       SVCID_TCP_RR(_Port, 0)

#define SVCID_DNS(_RecordType) SVCID_TCP_RR(53, _RecordType)

#define IS_SVCID_DNS(_g) \
             ( (((_g)->Data1) == 0x00090035) && \
               (((_g)->Data2) == 0) &&          \
               (((_g)->Data4[0]) == 0xC0) &&    \
               (((_g)->Data4[1]) == 0) &&       \
               (((_g)->Data4[2]) == 0) &&       \
               (((_g)->Data4[3]) == 0) &&       \
               (((_g)->Data4[4]) == 0) &&       \
               (((_g)->Data4[5]) == 0) &&       \
               (((_g)->Data4[6]) == 0) &&       \
               (((_g)->Data4[7]) == 0x46) )

#define IS_SVCID_TCP(_g) \
             ( ((((_g)->Data1) & 0xFFFF0000) == 0x00090000) && \
               (((_g)->Data2) == 0) &&                       \
               (((_g)->Data4[0]) == 0xC0) &&                 \
               (((_g)->Data4[1]) == 0) &&                    \
               (((_g)->Data4[2]) == 0) &&                    \
               (((_g)->Data4[3]) == 0) &&                    \
               (((_g)->Data4[4]) == 0) &&                    \
               (((_g)->Data4[5]) == 0) &&                    \
               (((_g)->Data4[6]) == 0) &&                    \
               (((_g)->Data4[7]) == 0x46) )

#define PORT_FROM_SVCID_TCP(_g) \
               ((WORD)(_g->Data1 & 0xFFFF))

#define RR_FROM_SVCID(_RR) (_RR->Data3)


#define SET_TCP_SVCID_RR(_g,_Port, _RR) {                    \
               (_g)->Data1 = (0x0009 << 16 ) | (_Port);      \
               (_g)->Data2 = 0;                              \
               (_g)->Data3 = _RR;                            \
               (_g)->Data4[0] = 0xC0;                        \
               (_g)->Data4[1] = 0x0;                         \
               (_g)->Data4[2] = 0x0;                         \
               (_g)->Data4[3] = 0x0;                         \
               (_g)->Data4[4] = 0x0;                         \
               (_g)->Data4[5] = 0x0;                         \
               (_g)->Data4[6] = 0x0;                         \
               (_g)->Data4[7] = 0x46; }

#define SET_TCP_SVCID(_g,_Port) SET_TCP_SVCID_RR(_g, _Port, 0)

#define SVCID_UDP_RR(_Port, _RR) \
             { (0x000A << 16) | (_Port), 0, _RR, { 0xC0,0,0,0,0,0,0,0x46 } }

#define SVCID_UDP(_Port) SVCID_UDP_RR(_Port, 0)

#define IS_SVCID_UDP(_g) \
             ( ((((_g)->Data1) & 0xFFFF0000) == 0x000A0000) && \
               (((_g)->Data2) == 0) &&                       \
               (((_g)->Data4[0]) == 0xC0) &&                 \
               (((_g)->Data4[1]) == 0) &&                    \
               (((_g)->Data4[2]) == 0) &&                    \
               (((_g)->Data4[3]) == 0) &&                    \
               (((_g)->Data4[4]) == 0) &&                    \
               (((_g)->Data4[5]) == 0) &&                    \
               (((_g)->Data4[6]) == 0) &&                    \
               (((_g)->Data4[7]) == 0x46) )

#define PORT_FROM_SVCID_UDP(_g) \
               ((WORD)(_g->Data1 & 0xFFFF))

#define SET_UDP_SVCID_RR(_g,_Port, _RR) {                    \
               (_g)->Data1 = (0x000A << 16 ) | (_Port);      \
               (_g)->Data2 = 0;                              \
               (_g)->Data3 = _RR;                            \
               (_g)->Data4[0] = 0xC0;                        \
               (_g)->Data4[1] = 0x0;                         \
               (_g)->Data4[2] = 0x0;                         \
               (_g)->Data4[3] = 0x0;                         \
               (_g)->Data4[4] = 0x0;                         \
               (_g)->Data4[5] = 0x0;                         \
               (_g)->Data4[6] = 0x0;                         \
               (_g)->Data4[7] = 0x46; }

#define SET_UDP_SVCID(_g, _Port) SET_UDP_SVCID_RR(_g, _Port, 0)

//
// Macros for defining and testing Netware (SAP) services based on the
// SAP ID.
//

#define SVCID_NETWARE(_SapId) \
             { (0x000B << 16) | (_SapId), 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } }

#define IS_SVCID_NETWARE(_g) \
             ( ((((_g)->Data1) & 0xFFFF0000) == 0x000B0000) && \
               (((_g)->Data2) == 0) &&                       \
               (((_g)->Data3) == 0) &&                       \
               (((_g)->Data4[0]) == 0xC0) &&                 \
               (((_g)->Data4[1]) == 0) &&                    \
               (((_g)->Data4[2]) == 0) &&                    \
               (((_g)->Data4[3]) == 0) &&                    \
               (((_g)->Data4[4]) == 0) &&                    \
               (((_g)->Data4[5]) == 0) &&                    \
               (((_g)->Data4[6]) == 0) &&                    \
               (((_g)->Data4[7]) == 0x46) )

#define SAPID_FROM_SVCID_NETWARE(_g) \
               ((WORD)(_g->Data1 & 0xFFFF))

#define SET_NETWARE_SVCID(_g,_SapId) {                       \
               (_g)->Data1 = (0x000B << 16 ) | (_SapId);     \
               (_g)->Data2 = 0;                              \
               (_g)->Data3 = 0;                              \
               (_g)->Data4[0] = 0xC0;                        \
               (_g)->Data4[1] = 0x0;                         \
               (_g)->Data4[2] = 0x0;                         \
               (_g)->Data4[3] = 0x0;                         \
               (_g)->Data4[4] = 0x0;                         \
               (_g)->Data4[5] = 0x0;                         \
               (_g)->Data4[6] = 0x0;                         \
               (_g)->Data4[7] = 0x46; }

//
// RFC 1060 services as defined by the IANA
// GUID block = 0009xxxx-0000-0000-C0000-000000000046
//

#define SVCID_ECHO_TCP                SVCID_TCP( 7 )
#define SVCID_DISCARD_TCP             SVCID_TCP( 9 )
#define SVCID_SYSTAT_TCP              SVCID_TCP( 11 )
#define SVCID_SYSTAT_TCP              SVCID_TCP( 11 )
#define SVCID_DAYTIME_TCP             SVCID_TCP( 13 )
#define SVCID_NETSTAT_TCP             SVCID_TCP( 15 )
#define SVCID_QOTD_TCP                SVCID_TCP( 17 )
#define SVCID_CHARGEN_TCP             SVCID_TCP( 19 )
#define SVCID_FTP_DATA_TCP            SVCID_TCP( 20 )
#define SVCID_FTP_TCP                 SVCID_TCP( 21 )
#define SVCID_TELNET_TCP              SVCID_TCP( 23 )
#define SVCID_SMTP_TCP                SVCID_TCP( 25 )
#define SVCID_TIME_TCP                SVCID_TCP( 37 )
#define SVCID_NAME_TCP                SVCID_TCP( 42 )
#define SVCID_WHOIS_TCP               SVCID_TCP( 43 )
#define SVCID_DOMAIN_TCP              SVCID_TCP( 53 )
#define SVCID_NAMESERVER_TCP          SVCID_TCP( 53 )
#define SVCID_MTP_TCP                 SVCID_TCP( 57 )
#define SVCID_RJE_TCP                 SVCID_TCP( 77 )
#define SVCID_FINGER_TCP              SVCID_TCP( 79 )
#define SVCID_LINK_TCP                SVCID_TCP( 87 )
#define SVCID_SUPDUP_TCP              SVCID_TCP( 95 )
#define SVCID_HOSTNAMES_TCP           SVCID_TCP( 101 )
#define SVCID_ISO_TSAP_TCP            SVCID_TCP( 102 )
#define SVCID_DICTIONARY_TCP          SVCID_TCP( 103 )
#define SVCID_X400_TCP                SVCID_TCP( 103 )
#define SVCID_X400_SND_TCP            SVCID_TCP( 104 )
#define SVCID_CSNET_NS_TCP            SVCID_TCP( 105 )
#define SVCID_POP_TCP                 SVCID_TCP( 109 )
#define SVCID_POP2_TCP                SVCID_TCP( 109 )
#define SVCID_POP3_TCP                SVCID_TCP( 110 )
#define SVCID_PORTMAP_TCP             SVCID_TCP( 111 )
#define SVCID_SUNRPC_TCP              SVCID_TCP( 111 )
#define SVCID_AUTH_TCP                SVCID_TCP( 113 )
#define SVCID_SFTP_TCP                SVCID_TCP( 115 )
#define SVCID_PATH_TCP                SVCID_TCP( 117 )
#define SVCID_UUCP_PATH_TCP           SVCID_TCP( 117 )
#define SVCID_NNTP_TCP                SVCID_TCP( 119 )
#define SVCID_NBSESSION_TCP           SVCID_TCP( 139 )
#define SVCID_NEWS_TCP                SVCID_TCP( 144 )
#define SVCID_TCPREPO_TCP             SVCID_TCP( 158 )
#define SVCID_PRINT_SRV_TCP           SVCID_TCP( 170 )
#define SVCID_VMNET_TCP               SVCID_TCP( 175 )
#define SVCID_VMNET0_TCP              SVCID_TCP( 400 )
#define SVCID_EXEC_TCP                SVCID_TCP( 512 )
#define SVCID_LOGIN_TCP               SVCID_TCP( 513 )
#define SVCID_SHELL_TCP               SVCID_TCP( 514 )
#define SVCID_PRINTER_TCP             SVCID_TCP( 515 )
#define SVCID_EFS_TCP                 SVCID_TCP( 520 )
#define SVCID_TEMPO_TCP               SVCID_TCP( 526 )
#define SVCID_COURIER_TCP             SVCID_TCP( 530 )
#define SVCID_CONFERENCE_TCP          SVCID_TCP( 531 )
#define SVCID_NETNEWS_TCP             SVCID_TCP( 532 )
#define SVCID_UUCP_TCP                SVCID_TCP( 540 )
#define SVCID_KLOGIN_TCP              SVCID_TCP( 543 )
#define SVCID_KSHELL_TCP              SVCID_TCP( 544 )
#define SVCID_REMOTEFS_TCP            SVCID_TCP( 556 )
#define SVCID_GARCON_TCP              SVCID_TCP( 600 )
#define SVCID_MAITRD_TCP              SVCID_TCP( 601 )
#define SVCID_BUSBOY_TCP              SVCID_TCP( 602 )
#define SVCID_KERBEROS_TCP            SVCID_TCP( 750 )
#define SVCID_KERBEROS_MASTER_TCP     SVCID_TCP( 751 )
#define SVCID_KRB_PROP_TCP            SVCID_TCP( 754 )
#define SVCID_ERLOGIN_TCP             SVCID_TCP( 888 )
#define SVCID_KPOP_TCP                SVCID_TCP( 1109 )
#define SVCID_INGRESLOCK_TCP          SVCID_TCP( 1524 )
#define SVCID_KNETD_TCP               SVCID_TCP( 2053 )
#define SVCID_EKLOGIN_TCP             SVCID_TCP( 2105 )
#define SVCID_RMT_TCP                 SVCID_TCP( 5555 )
#define SVCID_MTB_TCP                 SVCID_TCP( 5556 )
#define SVCID_MAN_TCP                 SVCID_TCP( 9535 )
#define SVCID_W_TCP                   SVCID_TCP( 9536 )
#define SVCID_MANTST_TCP              SVCID_TCP( 9537 )
#define SVCID_BNEWS_TCP               SVCID_TCP( 10000 )
#define SVCID_QUEUE_TCP               SVCID_TCP( 10001 )
#define SVCID_POKER_TCP               SVCID_TCP( 10002 )
#define SVCID_GATEWAY_TCP             SVCID_TCP( 10003 )
#define SVCID_REMP_TCP                SVCID_TCP( 10004 )
#define SVCID_QMASTER_TCP             SVCID_TCP( 10012 )

#define SVCID_ECHO_UDP                SVCID_UDP( 7 )
#define SVCID_DISCARD_UDP             SVCID_UDP( 9 )
#define SVCID_DAYTIME_UDP             SVCID_UDP( 13 )
#define SVCID_QOTD_UDP                SVCID_UDP( 17 )
#define SVCID_CHARGEN_UDP             SVCID_UDP( 19 )
#define SVCID_TIME_UDP                SVCID_UDP( 37 )
#define SVCID_RLP_UDP                 SVCID_UDP( 39 )
#define SVCID_NAME_UDP                SVCID_UDP( 42 )
#define SVCID_DOMAIN_UDP              SVCID_UDP( 53 )
#define SVCID_NAMESERVER_UDP          SVCID_UDP( 53 )
#define SVCID_BOOTP_UDP               SVCID_UDP( 67 )
#define SVCID_TFTP_UDP                SVCID_UDP( 69 )
#define SVCID_PORTMAP_UDP             SVCID_UDP( 111 )
#define SVCID_SUNRPC_UDP              SVCID_UDP( 111 )
#define SVCID_NTP_UDP                 SVCID_UDP( 123 )
#define SVCID_NBNAME_UDP              SVCID_UDP( 137 )
#define SVCID_NBDATAGRAM_UDP          SVCID_UDP( 138 )
#define SVCID_SGMP_UDP                SVCID_UDP( 153 )
#define SVCID_SNMP_UDP                SVCID_UDP( 161 )
#define SVCID_SNMP_TRAP_UDP           SVCID_UDP( 162 )
#define SVCID_LOAD_UDP                SVCID_UDP( 315 )
#define SVCID_SYTEK_UDP               SVCID_UDP( 500 )
#define SVCID_BIFF_UDP                SVCID_UDP( 512 )
#define SVCID_WHO_UDP                 SVCID_UDP( 513 )
#define SVCID_SYSLOG_UDP              SVCID_UDP( 514 )
#define SVCID_TALK_UDP                SVCID_UDP( 517 )
#define SVCID_NTALK_UDP               SVCID_UDP( 518 )
#define SVCID_ROUTE_UDP               SVCID_UDP( 520 )
#define SVCID_TIMED_UDP               SVCID_UDP( 525 )
#define SVCID_RVD_CONTROL_UDP         SVCID_UDP( 531 )
#define SVCID_NETWALL_UDP             SVCID_UDP( 533 )
#define SVCID_NEW_RWHO_UDP            SVCID_UDP( 550 )
#define SVCID_RMONITOR_UDP            SVCID_UDP( 560 )
#define SVCID_MONITOR_UDP             SVCID_UDP( 561 )
#define SVCID_ACCTMASTER_UDP          SVCID_UDP( 700 )
#define SVCID_ACCTSLAVE_UDP           SVCID_UDP( 701 )
#define SVCID_ACCT_UDP                SVCID_UDP( 702 )
#define SVCID_ACCTLOGIN_UDP           SVCID_UDP( 703 )
#define SVCID_ACCTPRINTER_UDP         SVCID_UDP( 704 )
#define SVCID_ELCSD_UDP               SVCID_UDP( 704 )
#define SVCID_ACCTINFO_UDP            SVCID_UDP( 705 )
#define SVCID_ACCTSLAVE2_UDP          SVCID_UDP( 706 )
#define SVCID_ACCTDISK_UDP            SVCID_UDP( 707 )
#define SVCID_KERBEROS_UDP            SVCID_UDP( 750 )
#define SVCID_KERBEROS_MASTER_UDP     SVCID_UDP( 751 )
#define SVCID_PASSWD_SERVER_UDP       SVCID_UDP( 752 )
#define SVCID_USERREG_SERVER_UDP      SVCID_UDP( 753 )
#define SVCID_PHONE_UDP               SVCID_UDP( 1167 )
#define SVCID_MAZE_UDP                SVCID_UDP( 1666 )
#define SVCID_NFS_UDP                 SVCID_UDP( 2049 )
#define SVCID_RSCS0_UDP               SVCID_UDP( 10000 )
#define SVCID_RSCS1_UDP               SVCID_UDP( 10001 )
#define SVCID_RSCS2_UDP               SVCID_UDP( 10002 )
#define SVCID_RSCS3_UDP               SVCID_UDP( 10003 )
#define SVCID_RSCS4_UDP               SVCID_UDP( 10004 )
#define SVCID_RSCS5_UDP               SVCID_UDP( 10005 )
#define SVCID_RSCS6_UDP               SVCID_UDP( 10006 )
#define SVCID_RSCS7_UDP               SVCID_UDP( 10007 )
#define SVCID_RSCS8_UDP               SVCID_UDP( 10008 )
#define SVCID_RSCS9_UDP               SVCID_UDP( 10009 )
#define SVCID_RSCSA_UDP               SVCID_UDP( 10010 )
#define SVCID_RSCSB_UDP               SVCID_UDP( 10011 )
#define SVCID_QMASTER_UDP             SVCID_UDP( 10012 )

//
// NetWare services
// GUID block = 000axxxx-0000-0000-C0000-000000000046
//

#define SVCID_PRINT_QUEUE                 SVCID_NETWARE( 0x3 )
#define SVCID_FILE_SERVER                 SVCID_NETWARE( 0x4 )
#define SVCID_JOB_SERVER                  SVCID_NETWARE( 0x5 )
#define SVCID_GATEWAY                     SVCID_NETWARE( 0x6 )
#define SVCID_PRINT_SERVER                SVCID_NETWARE( 0x7 )
#define SVCID_ARCHIVE_QUEUE               SVCID_NETWARE( 0x8 )
#define SVCID_ARCHIVE_SERVER              SVCID_NETWARE( 0x9 )
#define SVCID_JOB_QUEUE                   SVCID_NETWARE( 0xA )
#define SVCID_ADMINISTRATION              SVCID_NETWARE( 0xB )
#define SVCID_NAS_SNA_GATEWAY             SVCID_NETWARE( 0x21 )
#define SVCID_REMOTE_BRIDGE_SERVER        SVCID_NETWARE( 0x24 )
#define SVCID_TIME_SYNCHRONIZATION_SERVER SVCID_NETWARE( 0x2D )
#define SVCID_ARCHIVE_SERVER_DYNAMIC_SAP  SVCID_NETWARE( 0x2E )
#define SVCID_ADVERTISING_PRINT_SERVER    SVCID_NETWARE( 0x47 )
#define SVCID_BTRIEVE_VAP                 SVCID_NETWARE( 0x4B )
#define SVCID_DIRECTORY_SERVER            SVCID_NETWARE( 0x278 )
#define SVCID_NETWARE_386                 SVCID_NETWARE( 0x107 )
#define SVCID_HP_PRINT_SERVER             SVCID_NETWARE( 0x30C )
#define SVCID_SNA_SERVER                  SVCID_NETWARE( 0x444 )
#define SVCID_SAA_SERVER                  SVCID_NETWARE( 0x130 )

//
// DNS services by record type
// GUID block = 00090035-0000-xxxx-C0000-000000000046
//

#define SVCID_DNS_TYPE_A                  SVCID_DNS( 0x0001 )
#define SVCID_DNS_TYPE_NS                 SVCID_DNS( 0x0002 )
#define SVCID_DNS_TYPE_MD                 SVCID_DNS( 0x0003 )
#define SVCID_DNS_TYPE_MF                 SVCID_DNS( 0x0004 )
#define SVCID_DNS_TYPE_CNAME              SVCID_DNS( 0x0005 )
#define SVCID_DNS_TYPE_SOA                SVCID_DNS( 0x0006 )
#define SVCID_DNS_TYPE_MB                 SVCID_DNS( 0x0007 )
#define SVCID_DNS_TYPE_MG                 SVCID_DNS( 0x0008 )
#define SVCID_DNS_TYPE_MR                 SVCID_DNS( 0x0009 )
#define SVCID_DNS_TYPE_NULL               SVCID_DNS( 0x000a )
#define SVCID_DNS_TYPE_WKS                SVCID_DNS( 0x000b )
#define SVCID_DNS_TYPE_PTR                SVCID_DNS( 0x000c )
#define SVCID_DNS_TYPE_HINFO              SVCID_DNS( 0x000d )
#define SVCID_DNS_TYPE_MINFO              SVCID_DNS( 0x000e )
#define SVCID_DNS_TYPE_MX                 SVCID_DNS( 0x000f )
#define SVCID_DNS_TYPE_TEXT               SVCID_DNS( 0x0010 )
#define SVCID_DNS_TYPE_RP                 SVCID_DNS( 0x0011 )
#define SVCID_DNS_TYPE_AFSDB              SVCID_DNS( 0x0012 )
#define SVCID_DNS_TYPE_X25                SVCID_DNS( 0x0013 )
#define SVCID_DNS_TYPE_ISDN               SVCID_DNS( 0x0014 )
#define SVCID_DNS_TYPE_RT                 SVCID_DNS( 0x0015 )
#define SVCID_DNS_TYPE_NSAP               SVCID_DNS( 0x0016 )
#define SVCID_DNS_TYPE_NSAPPTR            SVCID_DNS( 0x0017 )
#define SVCID_DNS_TYPE_SIG                SVCID_DNS( 0x0018 )
#define SVCID_DNS_TYPE_KEY                SVCID_DNS( 0x0019 )
#define SVCID_DNS_TYPE_PX                 SVCID_DNS( 0x001a )
#define SVCID_DNS_TYPE_GPOS               SVCID_DNS( 0x001b )
#define SVCID_DNS_TYPE_AAAA               SVCID_DNS( 0x001c )
#define SVCID_DNS_TYPE_LOC                SVCID_DNS( 0x001d )
#define SVCID_DNS_TYPE_NXT                SVCID_DNS( 0x001e )
#define SVCID_DNS_TYPE_SRV                SVCID_DNS( 0x0021 )
#define SVCID_DNS_TYPE_ATMA               SVCID_DNS( 0x0022 )

#endif // _SVCGUID_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\SvrAPI.h ===
/********************************************************************/
/**                     Microsoft Windows                          **/
/**               Copyright(c) Microsoft Corp., 1995 - 1999        **/
/********************************************************************/

/********************************************************************
 *                                                                  *
 *  About this file ...  SVRAPI.H                                   *
 *                                                                  *
 *  This file contains information about the NetAccess,             *
 *  NetConnection, NetFile, NetServer, NetSession, NetShare and     *
 *  NetSecurity APIs.                                               *
 *  There is a section for each set of APIs.                        *
 *  Each section contains:                                          *
 *                                                                  *
 *      Function prototypes.                                        *
 *                                                                  *
 *      Data structure templates.                                   *
 *                                                                  *
 *      Definition of special values.                               *
 *                                                                  *
 *      Description of level of Win95 peer server support           *
 *
 *  For background information refer to the Lan Manager Programmer's
 *  Reference.
 *
 *  WARNING:
 *      The APIs documented herein are not guaranteed to be supported
 * in future versions of Windows. Their primary purpose is to       *
 * administer Win95 peer servers.                                   *
 *                                                                  *
 ********************************************************************/

/*
 *      NOTE:  Lengths of ASCIIZ strings are given as the maximum
 *      strlen() value.  This does not include space for the
 *      terminating 0-byte.  When allocating space for such an item,
 *      use the form:
 *
 *              char username[LM20_UNLEN+1];
 *
 *      An exception to this is the PATHLEN manifest, which does
 *      include space for the terminating 0-byte.
 *
 *      User names, computer names and share names should be
 *      upper-cased by the caller and drawn from the ANSI 
 *      character set.
 * 
 */

/*NOINC*/
#ifndef SVRAPI_INCLUDED
#define SVRAPI_INCLUDED

#include <lmcons.h>
#include <lmerr.h>

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#if !defined(_SVRAPI_)
#define API_FUNCTION DECLSPEC_IMPORT API_RET_TYPE APIENTRY
#else
#define API_FUNCTION API_RET_TYPE APIENTRY
#endif

/*INC*/


/****************************************************************
 *                                                              *
 *                 Access Class                                 *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - ACCESS                *
 *
 * 	Requires User level security to be enabled
 *                                                              *
 *	Peer Server Support:
 *      Remote support of these APIs on NWSERVER is limited as
 *      described below:
 *
 *		NetAccessAdd -
 *				local and remote VSERVER - level 2
 *              remote NWSERVER -          level 2
 *	    NetAccessCheck - local only
 *      NetAccessDel - 
 *              local, remote NWSERVER and remote VSERVER
 *      NetAccessEnum -
 *              sLevel 0 on remote NWSERVER (fRecursive = 1),
 *              slevel 0, 1, 2 on local and remote VSERVER
 *		NetAccessGetInfo -
 *               all sLevels on local and remote VSERVER,
 *      		 sLevel 0, 12 on remote NWSERVER
 *      NetAccessSetInfo - 
 *              sLevel 1, 12 on local and remote VSERVER,
 *              sLevel 12 on remote NWSERVER
 *              parmnum = PARMNUM_ALL only
 *      NetAccessGetUserPerms - local and remote VSERVER only
 ****************************************************************/

extern API_FUNCTION
  NetAccessAdd ( const char FAR * pszServer,
                 short            sLevel,
                 char FAR *       pbBuffer,
                 unsigned short   cbBuffer );

extern API_FUNCTION
  NetAccessCheck ( char FAR *           pszReserved,
                   char FAR *           pszUserName,
                   char FAR *           pszResource,
                   unsigned short       usOperation,
                   unsigned short FAR * pusResult );

extern API_FUNCTION
  NetAccessDel ( const char FAR * pszServer,
                 char FAR *       pszResource );

extern API_FUNCTION
  NetAccessEnum ( const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail );

extern API_FUNCTION
  NetAccessGetInfo ( const char FAR *     pszServer,
                     char FAR *           pszResource,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );

extern API_FUNCTION
  NetAccessSetInfo ( const char FAR * pszServer,
                     char FAR *       pszResource,
                     short            sLevel,
                     char FAR *       pbBuffer,
                     unsigned short   cbBuffer,
                     short            sParmNum );

extern API_FUNCTION
  NetAccessGetUserPerms ( char FAR *           pszServer,
                          char FAR *           pszUgName,
                          char FAR *           pszResource,
                          unsigned short FAR * pusPerms );


/****************************************************************
 *                                                              *
 *              Data structure templates - ACCESS               *
 *                                                              *
 ****************************************************************/

struct access_list {
        char            acl_ugname[LM20_UNLEN+1];
        char            acl_ugname_pad_1;
        short           acl_access;
};      /* access_list */

struct access_list_2
{
        char FAR *      acl2_ugname;
        unsigned short  acl2_access;
};      /* access_list_2 */
             
struct access_list_12
{
        char FAR *      acl12_ugname;
        unsigned short  acl12_access;
};      /* access_list_12 */
             
struct access_info_0 {
        char FAR *      acc0_resource_name;
};      /* access_info_0 */

struct access_info_1 {
        char  FAR *     acc1_resource_name;
        short           acc1_attr;                      /* See values below */
        short           acc1_count;
};      /* access_info_1 */

struct access_info_2 
{
        char  FAR *     acc2_resource_name;
        short           acc2_attr;
        short           acc2_count;
};      /* access_info_2 */

struct access_info_10 {
        char FAR *      acc10_resource_name;
};      /* access_info_10 */

struct access_info_12 
{
        char  FAR *     acc12_resource_name;
        short           acc12_attr;
        short           acc12_count;
};      /* access_info_12 */


/****************************************************************
 *                                                              *
 *              Special values and constants - ACCESS           *
 *                                                              *
 ****************************************************************/

/*
 *      Maximum number of permission entries for each resource.
 */

#define MAXPERMENTRIES  64


/*
 *      Bit values for the access permissions.  ACCESS_ALL is a handy
 *      way to specify maximum permissions.  These are used in
 *      acl_access field of access_list structures.
 */
/*NOINC*/
#define         ACCESS_NONE     0
#define         ACCESS_ALL     (ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM|ACCESS_FINDFIRST)
/*INC*/
#define         ACCESS_READ     0x1
#define         ACCESS_WRITE    0x2
#define         ACCESS_CREATE   0x4
#define         ACCESS_EXEC     0x8
#define         ACCESS_DELETE   0x10
#define         ACCESS_ATRIB    0x20
#define         ACCESS_PERM     0x40
#define         ACCESS_FINDFIRST 0x80

#define         ACCESS_GROUP    0x8000

/*
 *      Bit values for the acc1_attr field of the access_info_1 structure.
 *      Only one bit is currently defined.
 */

#define         ACCESS_AUDIT            0x1

/*
 *      Parmnum value for NetAccessSetInfo.
 */

#define         ACCESS_ATTR_PARMNUM     2


/*
 *      ACCESS_LETTERS defines a letter for each bit position in
 *      the acl_access field of struct access_list.  Note that some
 *      bits have a corresponding letter of ' ' (space).
 */

#define         ACCESS_LETTERS          "RWCXDAP         "



/****************************************************************
 *								*
 *	  	Share Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SHARE                     *
 *                                                              *
 *	Peer Server Support
 * 		NetShareAdd() - sLevel 50 on VSERVER and NWSERVER
 * 		NetShareDel() - VSERVER and NWSERVER
 *		NetShareEnum() - sLevel 1,50 on VSERVER; 50 on NWSERVER
 *      NetShareGetInfo() - sLevel 50 on VSERVER, NWSERVER
 * 		NetShareSetInfo() - sLevel 50, sParmNum PARMNUM_ALL
 *						 on VSERVER, NWSERVER
 ****************************************************************/

/***	NetShareAdd - add a new share to the server tables
 *
 *	NetShareAdd( servername, level, buf, buflen )
 *
 *	ENTRY:	servername - asciz string containing name of server
 *                       or NULL if local
 *		level- Must be 50 for Win95 peer servers.
 *		buf - far ptr to struct share_info
 *		buflen - unsigned int length of buffer
 *
 *	EXIT:	0 = success
 *		ERROR_INVALID_LEVEL
 *      ERROR_BAD_NETPATH
 *		ERROR_INVALID_PARAMETER
 *		NERR_UnknownDevDir
 *		NERR_ShareExists
 *		NERR_UnknownServer
 *		NERR_ServerNotStarted
 *		NERR_RedirectedPath
 *		NERR_DuplicateShare
 *		NERR_BufTooSmall
 *		ERROR_NOT_ENOUGH_MEMORY
 *
 */
extern API_FUNCTION
  NetShareAdd ( const char FAR * pszServer,
                short            sLevel,
                const char FAR * pbBuffer,
                unsigned short   cbBuffer );

/***	NetShareDel (Admin only)
 *
 *	API_FUNCTION NetShareDel( servername, netname, reserved )
 *
 *	ENTRY
 *
 *	char FAR *  servername;     asciz remote srv name, NULL if local
 *	char FAR *  netname;        asciz network name of share being deleted
 *	unsigned short reserved;    MBZ
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_PARAMETER
 *
 *
 *	Note:  Deleting a share will also delete any existing connections
 *		to the shared resource, and close open files within the
 *		connections.
 */
extern API_FUNCTION
  NetShareDel ( const char FAR * pszServer,
                const char FAR * pszNetName,
                unsigned short   usReserved );

/* 2.1  NetShareEnum
 *
 * API_FUNCTION
 * NetShareEnum( servername, level, buf, buflen, entriesread, totalentries )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * short               sLevel;         level of detail requested; 1 or 50
 * char FAR *          pbBuffer;       buffer to return entries in
 * unsigned short      cbBuffer;       size of buffer on call
 * unsigned short FAR *pcEntriesRead;  # of entries supplied on return
 * unsigned short FAR *pcTotalAvail ;  total # of entries available
 *
 * Supply information about existing shares at specified level.
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct share_info_1".
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  ERROR_MORE_DATA
 */
extern API_FUNCTION
  NetShareEnum ( const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail );

/* 2.2  NetShareGetInfo
 *
 * Purpose: Read complete information about a single outstanding share.
 *
 * API_FUNCTION
 * NetShareGetInfo( servername, netname, level, buf, buflen, totalavail )
 * char FAR *          servername;     asciz remote server name or NULL if local
 * char FAR *          netname;        asciz network name of share being queried
 * short               level;          level of info requested (50 for Win95 peer servers)
 * char FAR *          buf;            for returned entry
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response:
 *     Level 50 contains a "struct share_info_50".
 *
 * Returns 0 if successful.  Possible error returns:
 *  ERROR_INVALID_LEVEL
 *  ERROR_INVALID_PARAMETER
 *  ERROR_BAD_NETPATH
 *  NERR_NetNotStarted
 *  NERR_ServerNotStarted
 *  NERR_NetNameNotFound
 *  NERR_MoreData
 *  NERR_BufTooSmall
 */
extern API_FUNCTION
  NetShareGetInfo ( const char FAR *     pszServer,
                    const char FAR *     pszNetName,
                    short                sLevel,
                    char FAR *           pbBuffer,
                    unsigned short       cbBuffer,
                    unsigned short FAR * pcbTotalAvail );

/***	NetShareSetInfo (Admin only)
 *
 *	API_FUNCTION NetShareSetInfo( servername,
 *					netname,
 *					level,
 *					buf,
 *					buflen,
 *					parmnum )
 *					
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	netname;        asciz network name of share being set
 *	level;		level of info provided (50 for Win95 peer servers)
 *	buf;            contents described below
 *	buflen;         size of buffer
 *	parmnum;        must be PARMNUM_ALL for Win95 peer servers
 *
 *	Buffer contents on call if parmnum is zero:
 *   	    Level 50 contains a "struct share_info_50".
 *
 *	Settable fields are:
 *          shi_remark
 *          shi_passwd
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_NetNameNotFound
 *	ERROR_INVALID_LEVEL
 * 	NERR_BufTooSmall
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 *	ERROR_INVALID_PARAMETER
 ***/
extern API_FUNCTION
  NetShareSetInfo ( const char FAR * pszServer,
                    const char FAR * pszNetName,
                    short            sLevel,
                    const char FAR * pbBuffer,
                    unsigned short   cbBuffer,
                    short            sParmNum );


/****************************************************************
 *								*
 *	  	Data structure templates - SHARE		*
 *
 ****************************************************************/

struct share_info_0 {
    char		shi0_netname[LM20_NNLEN+1];
};  /* share_info_0 */

struct share_info_1 {
    char		shi1_netname[LM20_NNLEN+1];
    char		shi1_pad1;
    unsigned short	shi1_type;
    char FAR *		shi1_remark;
};  /* share_info_1 */

struct share_info_2 {
    char		shi2_netname[LM20_NNLEN+1];
    char		shi2_pad1;
    unsigned short	shi2_type;
    char FAR *		shi2_remark;
    unsigned short	shi2_permissions;
    unsigned short	shi2_max_uses;
    unsigned short	shi2_current_uses;
    char FAR *		shi2_path;
    char 		shi2_passwd[SHPWLEN+1];
    char		shi2_pad2;
};  /* share_info_2 */

struct share_info_50 {
	char		shi50_netname[LM20_NNLEN+1];    /* share name */
	unsigned char 	shi50_type;                 /* see below */
    unsigned short	shi50_flags;                /* see below */
	char FAR *	shi50_remark;                   /* ANSI comment string */
	char FAR *	shi50_path;                     /* shared resource */
	char		shi50_rw_password[SHPWLEN+1];   /* read-write password (share-level security) */
	char		shi50_ro_password[SHPWLEN+1];   /* read-only password (share-level security) */
};	/* share_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SHARE		*
 *								*
 ****************************************************************/

/* Field values for shi50_flags; */

/* These flags are relevant for share-level security on VSERVER
 * When operating with user-level security, use SHI50F_FULL - the actual
 * access rights are determined by the NetAccess APIs.
 */
#define	SHI50F_RDONLY		0x0001
#define	SHI50F_FULL			0x0002
#define	SHI50F_DEPENDSON	(SHI50F_RDONLY|SHI50F_FULL)
#define	SHI50F_ACCESSMASK	(SHI50F_RDONLY|SHI50F_FULL)

/* The share is restored on system startup */
#define	SHI50F_PERSIST		0x0100
/* The share is not normally visible  */
#define SHI50F_SYSTEM		0x0200


/*
 *	Values for parmnum parameter to NetShareSetInfo.
 */

#ifndef PARMNUM_ALL
#define PARMNUM_ALL				0
#endif

#define	SHI_REMARK_PARMNUM		4
#define	SHI_PERMISSIONS_PARMNUM		5
#define	SHI_MAX_USES_PARMNUM		6
#define	SHI_PASSWD_PARMNUM		9

#define	SHI1_NUM_ELEMENTS		4
#define	SHI2_NUM_ELEMENTS		10


/*
 *	Share types .
 *  
 *  STYPE_DISKTREE and STYPE_PRINTQ are recognized on peer servers
 */

#define STYPE_DISKTREE 			0       /* disk share */
#define STYPE_PRINTQ   			1       /* printer share */
#define STYPE_DEVICE   			2
#define STYPE_IPC      			3

#define SHI_USES_UNLIMITED		-1



/****************************************************************
 *								*
 *	  	Session Class			                *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - SESSION                   *
 *
 *	Peer Server Support                                         *
 *  	NetSessionDel() - NWSERVER and VSERVER 					*
 *	    NetSessionEnum() - sLevel 50 on NWSERVER and VSERVER    *
 *		NetSessionGetInfo() - not supported on peer servers     *
 ****************************************************************/

/***	NetSessionDel (Admin only)
 *
 *
 *	API_FUNCTION NetSessionDel( servername, clientname, reserved )
 *
 *	ENTRY
 *
 * 	servername;     asciz remote srv name, NULL if local
 *	clientname;     asciz remote computer name (returned by NetSessionEnum)
 *                               	of session being deleted
 *                  In the case of a Win95 NWSERVER, the clientname should be the
 *                  ascii connection number
 *	reserved;       session key returned by NetSessionEnum
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *  ERROR_BAD_NETPATH
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly
 * 	ERROR_ACCESS_DENIED
 *	NERR_BufTooSmall
 *	NERR_ClientNameNotFound
 *
 ***/
extern API_FUNCTION
  NetSessionDel ( const char FAR * pszServer,
                  const char FAR * pszClientName,
                  short            sReserved );

/***	NetSessionEnum
 *
 *	API_FUNCTION NetSessionEnum( servername,
 *				       level,
 *				       buf,
 *				       buflen,
 *				       entriesread,
 *				       totalentries )
 *	ENTRY
 *				
 *	servername;     asciz remote srv name, NULL if local
 * 	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call;
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *  ERROR_BAD_NETPATH
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	Buffer contains an array of session_info structures.
 *
 ***/
extern API_FUNCTION
  NetSessionEnum ( const char FAR *     pszServer,
                   short                sLevel,
                   char FAR *           pbBuffer,
                   unsigned short       cbBuffer,
                   unsigned short FAR * pcEntriesRead,
                   unsigned short FAR * pcTotalAvail );


extern API_FUNCTION
  NetSessionGetInfo ( const char FAR *     pszServer,
                      const char FAR *     pszClientName,
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *		Data structure templates - SESSION		*
 *								*
 ****************************************************************/


struct session_info_0 {
    char FAR *		sesi0_cname;
};  /* session_info_0 */

struct session_info_1 {
    char FAR *		sesi1_cname;
    char FAR *		sesi1_username;
    unsigned short	sesi1_num_conns;
    unsigned short	sesi1_num_opens;
    unsigned short	sesi1_num_users;
    unsigned long	sesi1_time;
    unsigned long	sesi1_idle_time;
    unsigned long	sesi1_user_flags;
};  /* session_info_1 */

struct session_info_2 {
    char FAR *		 sesi2_cname;
    char FAR *		 sesi2_username;
    unsigned short	 sesi2_num_conns;
    unsigned short	 sesi2_num_opens;
    unsigned short	 sesi2_num_users;
    unsigned long	 sesi2_time;
    unsigned long	 sesi2_idle_time;
    unsigned long	 sesi2_user_flags;
    char FAR *		 sesi2_cltype_name;
};  /* session_info_2 */

struct session_info_10 {
        char FAR *     sesi10_cname;
        char FAR *     sesi10_username;
        unsigned long  sesi10_time;
        unsigned long  sesi10_idle_time;
};  /* session_info_10 */


struct session_info_50 {
	char FAR * sesi50_cname;            //remote computer name (connection id in Netware)
	char FAR * sesi50_username;
	unsigned long sesi50_key;           // used to delete session (not used in Netware)
	unsigned short sesi50_num_conns;
	unsigned short sesi50_num_opens;    //not available in Netware
	unsigned long sesi50_time;
	unsigned long sesi50_idle_time;		//not available in Netware
	unsigned char sesi50_protocol;
	unsigned char pad1;
};	/* session_info_50 */


/****************************************************************
 *								*
 *	  	Special values and constants - SESSION		*
 *								*
 ****************************************************************/

/*
 *	Bits defined in sesi1_user_flags.
 */

#define SESS_GUEST		1	/* session is logged on as a guest */
#define SESS_NOENCRYPTION	2	/* session is not using encryption */


#define SESI1_NUM_ELEMENTS	8
#define SESI2_NUM_ELEMENTS	9



/****************************************************************
 *								*
 *	  	Connection Class			        *
 *								*
 ****************************************************************/

/****************************************************************
 *                                                              *
 *              Function prototypes - CONNECTION                *
 *                                                              *
 *  Peer Server Support
 * 		NetConnectionEnum -
 *               sLevel 50 on VSERVER and NWSERVER              *
 *               On NWSERVER, this API doesnt provide more      *
 *               information than NetSessionEnum
 ****************************************************************/

/***	NetConnectionEnum (Admin only)
 *
 *	API_FUNCTION NetConnectionEnum( servername, 
 *					  qualifier, 
 *					  level, 
 *					  buf, 
 *					  buflen, 
 *					  totalavail )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	qualifier;      netname or client computer name.
 *                  computer name should be prefaced by '\\'.
 *	level;	    	level of info requested
 *	buf;            for returned entry
 *	buflen;         size of buffer 
 *	totalavail;     total size needed for buffer
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	NERR_RemoteOnly		(DOS)
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *	NERR_ClientNameNotFound
 *	NERR_NetNameNotFound
 *
 *	Buffer contents on response (format for a single entry):
 *   	    Level 50 contains a "struct connection_info_50".
 ***/
extern API_FUNCTION
  NetConnectionEnum ( const char FAR *     pszServer,
                      const char FAR *     pszQualifier,   /* upper case */
                      short                sLevel,
                      char FAR *           pbBuffer,
                      unsigned short       cbBuffer,
                      unsigned short FAR * pcEntriesRead,
                      unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - CONNECTION		*
 *								*
 ****************************************************************/

struct connection_info_0 {
    unsigned short	coni0_id;
};  /* connection_info_0 */

struct connection_info_1 {
    unsigned short	coni1_id;
    unsigned short	coni1_type;
    unsigned short	coni1_num_opens;
    unsigned short	coni1_num_users;
    unsigned long	coni1_time;
    char FAR *		coni1_username;
    char FAR *		coni1_netname;
};  /* connection_info_1 */

struct connection_info_50 {
	unsigned short coni50_type;         // share type
	unsigned short coni50_num_opens;	//not used in Netware
	unsigned long coni50_time;
	char FAR * coni50_netname;          // share name          
	char FAR * coni50_username;         // user connected to share
}; /* connection_info_50 */


/****************************************************************
 *								*
 *	  	File Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - FILE                      *
 *                                                              *
 *  Peer Server Support
 * 		NetFileEnum - sLevel 50 on VSERVER and NWSERVER        *
 *      NetFileClose2 - VSERVER only
 ****************************************************************/

/***	NetFileClose2
 *
 *	int FAR PASCAL	NetFileClose2( servername, fileid )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	fileid;     	file id supplied by NetFileEnum
 *
 *	EXIT
 *
 *	0 = success
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	NERR_RemoteErr
 * 	ERROR_ACCESS_DENIED
 *	NERR_FileIdNotFound
 *
 ***/
extern API_FUNCTION
  NetFileClose2 ( const char FAR * pszServer,
                  unsigned long    ulFileId );

/***	NetFileEnum (Admin Only)
 *
 *	int FAR PASCAL NetFileEnum( servername,
 *				    level, 
 *				    buf, 
 *				    buflen, 
 *				    entriesread, 
 *				    totalentries )
 *
 *	ENTRY
 *
 *	servername;     asciz remote srv name, NULL if local
 *	basepath;	path qualifier for file matching
 *              (not used for Win95 NWSERVER)
 *	level;          level of detail requested; (50 for Win95 peer servers)
 *	buf;            for returned entries
 *	buflen;         size of buffer on call; 
 *	entriesread;    # of entries supplied on return
 *	totalentries;   total # of entries available
 *
 * 	EXIT
 *
 *	0 = success
 *	NERR_RemoteOnly
 *	NERR_NetNotStarted
 *	NERR_ServerNotStarted
 *	ERROR_INVALID_LEVEL
 *	NERR_RemoteErr
 *	ERROR_MORE_DATA
 * 	ERROR_ACCESS_DENIED
 *
 *	
 *	Buffer contents on response (format for a single entry):
 *   	    Level 0 contains a "struct file_info_0".
 *   	    Level 50 contains a "struct file_info_50".
 *
 ***/

extern API_FUNCTION
  NetFileEnum ( const char FAR *     pszServer,
                const char FAR *     pszBasePath,
                short                sLevel,
                char FAR *           pbBuffer,
                unsigned short       cbBuffer,
                unsigned short FAR * pcEntriesRead,
                unsigned short FAR * pcTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - FILE			*
 *								*
 ****************************************************************/

struct file_info_0 {
    unsigned short	fi0_id;
};  /* file_info_0 */

struct file_info_1 {
    unsigned short	fi1_id;
    unsigned short	fi1_permissions;
    unsigned short	fi1_num_locks;
    char FAR *		fi1_pathname;
    char FAR *		fi1_username;
};  /* file_info_1 */

struct file_info_2 {
    unsigned long	fi2_id;
};  /* file_info_2 */

struct file_info_3 {
    unsigned long	fi3_id;
    unsigned short	fi3_permissions;
    unsigned short	fi3_num_locks;
    char FAR *		fi3_pathname;
    char FAR *		fi3_username;
};  /* file_info_3 */

struct file_info_50 {
	unsigned long fi50_id;              // not used on NWSERVER
	unsigned short fi50_permissions;    // not available on NWSERVER
	unsigned short fi50_num_locks;      // not available on NWSERVER
	char FAR * fi50_pathname;
	char FAR * fi50_username;
	char FAR * fi50_sharename;
}; /* file_info_50 */

struct res_file_enum_2 {
    unsigned short	res_pad;	 /* not used now */
    unsigned short      res_fs;          /* server type */
    unsigned long	res_pro;	  /* progressive */
};  /* res_file_enum_2 */

/****************************************************************
 *								*
 *		Special values and constants - FILE		*
 *								*
 ****************************************************************/

					/* bit values for permissions */
#define	PERM_FILE_READ		0x1	/* user has read access */
#define	PERM_FILE_WRITE		0x2	/* user has write access */
#define	PERM_FILE_CREATE	0x4	/* user has create access */


typedef struct res_file_enum_2 FRK;

/*NOINC*/
#define FRK_INIT( f )	\
	{		\
		(f).res_pad = 0L;	\
		(f).res_fs = 0;	\
		(f).res_pro = 0;	\
	}

/*INC*/


/****************************************************************
 *								*
 *	  	Server Class			                *
 *								*
 ****************************************************************/


/****************************************************************
 *                                                              *
 *              Function prototypes - SERVER                    *
 *                                                              *
 * Peer Server Support
 * 	NetServerGetInfo - sLevel 1,50 on NWSERVER, VSERVER
 ****************************************************************/

/* 6.2  NetServerGetInfo 
 *
 * Purpose: Read the current configuration parameters of the server.
 *
 * int FAR PASCAL
 * NetServerGetInfo( servername, level, buf, buflen, totalavail )
 * char FAR *          servername;   asciz remote server name or NULL if local
 * short               level;          level of information to be returned
 * char FAR *          buf;            for returned data
 * unsigned short      buflen;         size of buffer
 * unsigned short FAR *totalavail;     total size needed for buffer
 *
 * Buffer contents on response (format for a single entry):
 *     Level 1 contains a "struct server_info_1".
 *     Level 50 contains a "struct server_info_50".
 *
 * If the buflen is not large enough for all of the information, the call
 * will return as much as will fit in the buffer.
 *
 * Returns 0 if successful. Error return information:
 *
 *     - ERROR_INVALID_LEVEL       - Level parameter specified is invalid
 *     - ERROR_INVALID_PARAMETER   - An invalid input parameter was detected.
 *     - NERR_NetNotStarted        - Network not installed on local machine
 *     - NERR_ServerNotStarted     - Server is not started
 *     - NERR_BufTooSmall          - The buffer supplied was to small to
 *                                   return the fixed length structure
 *				     requested.
 *     - NERR_MoreData             - The buffer supplied was too small to
 *				     return all the information available
 *				     for this server.
 *
 */


extern API_FUNCTION
  NetServerGetInfo ( const char FAR *     pszServer,
                     short                sLevel,
                     char FAR *           pbBuffer,
                     unsigned short       cbBuffer,
                     unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SERVER		*
 *								*
 ****************************************************************/

struct server_info_0 {
    char	    sv0_name[CNLEN + 1]; 	/* Server name		    */
};	 /* server_info_0 */


struct server_info_1 {
    char	    sv1_name[CNLEN + 1];
    unsigned char   sv1_version_major;		/* Major version # of net   */
    unsigned char   sv1_version_minor;		/* Minor version # of net   */
    unsigned long   sv1_type;	     		/* Server type 		    */
    char FAR *	    sv1_comment; 		/* Exported server comment  */
};	 /* server_info_1 */


/* NOTE struct prefix must equal server_info_1 like below! */

struct server_info_50 {
    char	    sv50_name[CNLEN + 1];
    unsigned char   sv50_version_major;		/* Major version # of net   */
    unsigned char   sv50_version_minor;		/* Minor version # of net   */
    unsigned long   sv50_type;	     		/* Server type 		    */
    char FAR *	    sv50_comment; 		/* Exported server comment  */
    unsigned short  sv50_security;    		/* SV_SECURITY_* (see below) */
    unsigned short  sv50_auditing;    /* 0 = no auditing; nonzero = auditing */
    char FAR *      sv50_container;		/* Security server/domain    */
    char FAR *	    sv50_ab_server;		/* Address book server       */
    char FAR *	    sv50_ab_dll;		/* Address book provider DLL */
};	/* server_info_50 */


struct server_info_2 {
    char            sv2_name[CNLEN + 1];
    unsigned char   sv2_version_major;
    unsigned char   sv2_version_minor;
    unsigned long   sv2_type;	
    char FAR *	    sv2_comment;		
    unsigned long   sv2_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv2_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv2_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv2_users;       /* max number of users allowed          */
    unsigned short  sv2_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv2_alerts;	    /* alert names (semicolon separated)    */
    unsigned short  sv2_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv2_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv2_numadmin;    /* max number of administrators allowed */
    unsigned short  sv2_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv2_hidden;      /* 0 = visible; nonzero = hidden        */
    unsigned short  sv2_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv2_anndelta;    /* announce randomize interval (sec)    */
                                    /* name of guest account                */
    char            sv2_guestacct[LM20_UNLEN + 1];
    unsigned char   sv2_pad1;	    /* Word alignment pad byte		    */
    char FAR *      sv2_userpath;    /* ASCIIZ path to user directories      */
    unsigned short  sv2_chdevs;      /* max # shared character devices       */
    unsigned short  sv2_chdevq;      /* max # character device queues        */
    unsigned short  sv2_chdevjobs;   /* max # character device jobs          */
    unsigned short  sv2_connections; /* max # of connections		    */
    unsigned short  sv2_shares;	    /* max # of shares			    */
    unsigned short  sv2_openfiles;   /* max # of open files		    */
    unsigned short  sv2_sessopens;   /* max # of open files per session	    */
    unsigned short  sv2_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv2_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv2_opensearch;  /* max # of open searches		    */
    unsigned short  sv2_activelocks; /* max # of active file locks           */
    unsigned short  sv2_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv2_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv2_numbigbuf;   /* number of big (64K) buffers          */
    unsigned short  sv2_numfiletasks;/* number of file worker processes      */
    unsigned short  sv2_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv2_erroralert;  /* error log alerting threshold         */
    unsigned short  sv2_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv2_accessalert; /* access violation alerting threshold  */
    unsigned short  sv2_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv2_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv2_maxauditsz;  /* Maximum audit file size (KB)        */
    char FAR *	    sv2_srvheuristics; /* performance related server switches*/
};	/* server_info_2 */


struct server_info_3 {
    char	    sv3_name[CNLEN + 1];
    unsigned char   sv3_version_major;
    unsigned char   sv3_version_minor;
    unsigned long   sv3_type;
    char FAR *	    sv3_comment;
    unsigned long   sv3_ulist_mtime; /* User list, last modification time    */
    unsigned long   sv3_glist_mtime; /* Group list, last modification time   */
    unsigned long   sv3_alist_mtime; /* Access list, last modification time  */
    unsigned short  sv3_users;	     /* max number of users allowed	     */
    unsigned short  sv3_disc;	    /* auto-disconnect timeout(in minutes)  */
    char FAR *	    sv3_alerts;     /* alert names (semicolon separated)    */
    unsigned short  sv3_security;    /* SV_USERSECURITY or SV_SHARESECURITY  */
    unsigned short  sv3_auditing;    /* 0 = no auditing; nonzero = auditing  */

    unsigned short  sv3_numadmin;    /* max number of administrators allowed */
    unsigned short  sv3_lanmask;     /* bit mask representing the srv'd nets */
    unsigned short  sv3_hidden;      /* 0 = visible; nonzero = hidden	     */
    unsigned short  sv3_announce;    /* visible server announce rate (sec)   */
    unsigned short  sv3_anndelta;    /* announce randomize interval (sec)    */
				    /* name of guest account		    */
    char	    sv3_guestacct[LM20_UNLEN + 1];
    unsigned char   sv3_pad1;	    /* Word alignment pad byte		    */
    char FAR *	    sv3_userpath;    /* ASCIIZ path to user directories	     */
    unsigned short  sv3_chdevs;      /* max # shared character devices	     */
    unsigned short  sv3_chdevq;      /* max # character device queues	     */
    unsigned short  sv3_chdevjobs;   /* max # character device jobs	     */
    unsigned short  sv3_connections; /* max # of connections		    */
    unsigned short  sv3_shares;     /* max # of shares			    */
    unsigned short  sv3_openfiles;   /* max # of open files		    */
    unsigned short  sv3_sessopens;   /* max # of open files per session     */
    unsigned short  sv3_sessvcs;     /* max # of virtual circuits per client */
    unsigned short  sv3_sessreqs;    /* max # of simul. reqs. from a client  */
    unsigned short  sv3_opensearch;  /* max # of open searches		    */
    unsigned short  sv3_activelocks; /* max # of active file locks	     */
    unsigned short  sv3_numreqbuf;   /* number of server (standard) buffers  */
    unsigned short  sv3_sizreqbuf;   /* size of svr (standard) bufs (bytes)  */
    unsigned short  sv3_numbigbuf;   /* number of big (64K) buffers	     */
    unsigned short  sv3_numfiletasks;/* number of file worker processes      */
    unsigned short  sv3_alertsched;  /* alert counting interval (minutes)    */
    unsigned short  sv3_erroralert;  /* error log alerting threshold	     */
    unsigned short  sv3_logonalert;  /* logon violation alerting threshold   */
    unsigned short  sv3_accessalert; /* access violation alerting threshold  */
    unsigned short  sv3_diskalert;   /* low disk space alert threshold (KB)  */
    unsigned short  sv3_netioalert;  /* net I/O error ratio alert threshold  */
                                    /*  (tenths of a percent)               */
    unsigned short  sv3_maxauditsz;  /* Maximum audit file size (KB)	     */
    char FAR *	    sv3_srvheuristics; /* performance related server switches*/
    unsigned long   sv3_auditedevents; /* Audit event control mask	     */
    unsigned short  sv3_autoprofile; /* (0,1,2,3) = (NONE,LOAD,SAVE,or BOTH) */
    char FAR *	    sv3_autopath;    /* file pathname (where to load & save) */
};	/* server_info_3 */



/****************************************************************
 *								*
 *	  	Special values and constants - SERVER		*
 *								*
 ****************************************************************/

/*
 *	Mask to be applied to svX_version_major in order to obtain
 *	the major version number.
 */

#define MAJOR_VERSION_MASK	0x0F

/*
 *	Bit-mapped values for svX_type fields. X = 1, 2 or 3.
 */

#define SV_TYPE_WORKSTATION	0x00000001
#define SV_TYPE_SERVER		0x00000002
#define SV_TYPE_SQLSERVER	0x00000004
#define SV_TYPE_DOMAIN_CTRL	0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL	0x00000010
#define SV_TYPE_TIME_SOURCE	0x00000020
#define SV_TYPE_AFP		0x00000040
#define SV_TYPE_NOVELL		0x00000080      /* This flag is also set by Win95 NWSERVER */
#define SV_TYPE_DOMAIN_MEMBER	0x00000100
#define SV_TYPE_PRINTQ_SERVER	0x00000200
#define SV_TYPE_DIALIN_SERVER	0x00000400
#define SV_TYPE_ALL		0xFFFFFFFF   /* handy for NetServerEnum2 */

/*
 *	Special value for svX_disc that specifies infinite disconnect
 *	time. X = 2 or 3.
 */

#define SV_NODISC		0xFFFF	/* No autodisconnect timeout enforced */

/*
 *	Values of svX_security field. X = 2 or 3.
 */

#define SV_USERSECURITY		1
#define SV_SHARESECURITY	0

/*
 *	Values of svX_security field. X = 50.
 *  For Win95 NWSERVER, the only possible returned value is SV_SECURITY_NETWARE.
 */

#define SV_SECURITY_SHARE	0	/* Share-level */
#define SV_SECURITY_WINNT	1	/* User-level - Windows NT workst'n */
#define SV_SECURITY_WINNTAS	2	/* User-level - Windows NT domain */
#define SV_SECURITY_NETWARE	3	/* User-level - NetWare 3.x bindery */

/*
 *	Values of svX_hidden field. X = 2 or 3.
 */

#define SV_HIDDEN		1
#define SV_VISIBLE		0

#define SVI1_NUM_ELEMENTS	5
#define SVI2_NUM_ELEMENTS	44
#define SVI3_NUM_ELEMENTS	45


/*
 *      Masks describing AUTOPROFILE parameters
 */

#define SW_AUTOPROF_LOAD_MASK	0x1
#define SW_AUTOPROF_SAVE_MASK	0x2



/****************************************************************
 *                                                              *
 *                 Security Class                               *
 *                                                              *
 ****************************************************************/


/****************************************************************
 *                                                              *
 *                  Function prototypes - SECURITY              *
 *                                                              *
 ****************************************************************/

extern API_FUNCTION
  NetSecurityGetInfo ( const char FAR *     pszServer,
                       short                sLevel,
                       char FAR *           pbBuffer,
                       unsigned short       cbBuffer,
                       unsigned short FAR * pcbTotalAvail );


/****************************************************************
 *								*
 *	  	Data structure templates - SECURITY		*
 *								*
 ****************************************************************/

struct security_info_1 {
    unsigned long   sec1_security;    	/* SEC_SECURITY_* (see below) */
    char FAR *      sec1_container;	/* Security server/domain     */
    char FAR *	    sec1_ab_server;	/* Address book server        */
    char FAR *	    sec1_ab_dll;	/* Address book provider DLL  */
};	/* security_info_1 */


/****************************************************************
 *								*
 *	  	Special values and constants - SECURITY		*
 *								*
 ****************************************************************/

/*
/*
 *	Values of secX_security field. X = 1.
 */

#define SEC_SECURITY_SHARE	SV_SECURITY_SHARE
#define SEC_SECURITY_WINNT	SV_SECURITY_WINNT
#define SEC_SECURITY_WINNTAS	SV_SECURITY_WINNTAS
#define SEC_SECURITY_NETWARE	SV_SECURITY_NETWARE



/*NOINC*/
#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* SVRAPI_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Tapi.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

The  Telephony  API  is jointly copyrighted by Intel and Microsoft.  You are
granted  a royalty free worldwide, unlimited license to make copies, and use
the   API/SPI  for  making  applications/drivers  that  interface  with  the
specification provided that this paragraph and the Intel/Microsoft copyright
statement is maintained as is in the text and source code files.

Copyright (c) Microsoft Corporation, All rights reserved.
Portions copyright 1992, 1993 Intel/Microsoft, all rights reserved.

Module Name:

    tapi.h

Notes:

    Additions to the Telephony Application Programming Interface (TAPI) since
    version 1.0 are noted by version number (e.g. "TAPI v1.4").

--*/

#ifndef TAPI_H
#define TAPI_H



//
//  -- TAPI VERSION INFO -- TAPI VERSION INFO -- TAPI VERSION INFO --
//
// To build  a TAPI 1.4 application put a define as below in your source
// file before you include TAPI.H:
//
// #define TAPI_CURRENT_VERSION 0x00010004
//
//

#ifndef TAPI_CURRENT_VERSION
#define TAPI_CURRENT_VERSION 0x00020002
#endif

#include <windows.h>
#if WIN32
#include <basetsd.h>
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
#include <oaidl.h>
#endif

#pragma pack(1)
// Type definitions of the data types used in tapi

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//
// TAPI type definitions
//

#define DECLARE_OPAQUE32(name)  typedef DWORD name

DECLARE_OPAQUE32(HCALL);
typedef HCALL FAR * LPHCALL;

#if (TAPI_CURRENT_VERSION >= 0x00030000)
DECLARE_OPAQUE32(HCALLHUB);                                     // TAPI v3.0
typedef HCALLHUB FAR * LPHCALLHUB;                              // TAPI v3.0
#endif

DECLARE_OPAQUE32(HLINE);
typedef HLINE FAR * LPHLINE;

DECLARE_OPAQUE32(HPHONE);
typedef HPHONE FAR * LPHPHONE;

DECLARE_OPAQUE32(HLINEAPP);
typedef HLINEAPP FAR * LPHLINEAPP;

DECLARE_OPAQUE32(HPHONEAPP);
typedef HPHONEAPP FAR * LPHPHONEAPP;

#if (TAPI_CURRENT_VERSION >= 0x00020002)
DECLARE_OPAQUE32(HAGENTSESSION);                                // TAPI v2.2
typedef HAGENTSESSION FAR * LPHAGENTSESSION;                    // TAPI v2.2

DECLARE_OPAQUE32(HAGENT);                                       // TAPI v2.2
typedef HAGENT FAR * LPHAGENT;                                  // TAPI v2.2
#endif

#if (TAPI_CURRENT_VERSION >= 0x00030000)
DECLARE_OPAQUE32(HPRIVATECHANNEL);                              // TAPI v3.0
typedef HPRIVATECHANNEL FAR * LPHPRIVATECHANNEL;                // TAPI v3.0
#endif

typedef HICON FAR * LPHICON;

typedef void (CALLBACK * LINECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );

typedef void (CALLBACK * PHONECALLBACK)(
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );


// Messages for Phones and Lines

#define LINE_ADDRESSSTATE                       0L
#define LINE_CALLINFO                           1L
#define LINE_CALLSTATE                          2L
#define LINE_CLOSE                              3L
#define LINE_DEVSPECIFIC                        4L
#define LINE_DEVSPECIFICFEATURE                 5L
#define LINE_GATHERDIGITS                       6L
#define LINE_GENERATE                           7L
#define LINE_LINEDEVSTATE                       8L
#define LINE_MONITORDIGITS                      9L
#define LINE_MONITORMEDIA                       10L
#define LINE_MONITORTONE                        11L
#define LINE_REPLY                              12L
#define LINE_REQUEST                            13L
#define PHONE_BUTTON                            14L
#define PHONE_CLOSE                             15L
#define PHONE_DEVSPECIFIC                       16L
#define PHONE_REPLY                             17L
#define PHONE_STATE                             18L
#define LINE_CREATE                             19L             // TAPI v1.4
#define PHONE_CREATE                            20L             // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINE_AGENTSPECIFIC                      21L             // TAPI v2.0
#define LINE_AGENTSTATUS                        22L             // TAPI v2.0
#define LINE_APPNEWCALL                         23L             // TAPI v2.0
#define LINE_PROXYREQUEST                       24L             // TAPI v2.0
#define LINE_REMOVE                             25L             // TAPI v2.0
#define PHONE_REMOVE                            26L             // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
#define LINE_AGENTSESSIONSTATUS                 27L             // TAPI v2.2
#define LINE_QUEUESTATUS                        28L             // TAPI v2.2
#define LINE_AGENTSTATUSEX                      29L             // TAPI v2.2
#define LINE_GROUPSTATUS                        30L             // TAPI v2.2
#define LINE_PROXYSTATUS                        31L             // TAPI v2.2
#endif

#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINE_APPNEWCALLHUB                      32L             // TAPI v3.0
#define LINE_CALLHUBCLOSE                       33L             // TAPI v3.0
#define LINE_DEVSPECIFICEX                      34L             // TAPI v3.0
#endif

#define INITIALIZE_NEGOTIATION                  0xFFFFFFFFUL

#define LINEADDRCAPFLAGS_FWDNUMRINGS            0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID          0x00000002
#define LINEADDRCAPFLAGS_SECURE                 0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT         0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE        0x00000010
#define LINEADDRCAPFLAGS_DIALED                 0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK            0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK            0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT             0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL          0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT          0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID           0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD           0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE           0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD         0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE         0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL            0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID         0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR          0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR          0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT          0x00100000
#define LINEADDRCAPFLAGS_CONFDROP               0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT         0x00400000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRCAPFLAGS_PREDICTIVEDIALER       0x00800000      // TAPI v2.0
#define LINEADDRCAPFLAGS_QUEUE                  0x01000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_ROUTEPOINT             0x02000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_HOLDMAKESNEW           0x04000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOINTERNALCALLS        0x08000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS        0x10000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_SETCALLINGID           0x20000000      // TAPI v2.0
#endif
#if (TAPI_CURRENT_VERSION >= 0x00020002)
#define LINEADDRCAPFLAGS_ACDGROUP               0x40000000      // TAPI v2.2
#endif
#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEADDRCAPFLAGS_NOPSTNADDRESSTRANSLATION 0x80000000    // TAPI v3.0
#endif

#define LINEADDRESSMODE_ADDRESSID               0x00000001
#define LINEADDRESSMODE_DIALABLEADDR            0x00000002

#define LINEADDRESSSHARING_PRIVATE              0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL          0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW           0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED        0x00000008
#define LINEADDRESSSHARING_MONITORED            0x00000010

#define LINEADDRESSSTATE_OTHER                  0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC            0x00000002
#define LINEADDRESSSTATE_INUSEZERO              0x00000004
#define LINEADDRESSSTATE_INUSEONE               0x00000008
#define LINEADDRESSSTATE_INUSEMANY              0x00000010
#define LINEADDRESSSTATE_NUMCALLS               0x00000020
#define LINEADDRESSSTATE_FORWARD                0x00000040
#define LINEADDRESSSTATE_TERMINALS              0x00000080
#define LINEADDRESSSTATE_CAPSCHANGE             0x00000100      // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEADDRESSTYPE_PHONENUMBER             0x00000001
#define LINEADDRESSTYPE_SDP                     0x00000002
#define LINEADDRESSTYPE_EMAILNAME               0x00000004
#define LINEADDRESSTYPE_DOMAINNAME              0x00000008
#define LINEADDRESSTYPE_IPADDRESS               0x00000010
#endif

#define LINEADDRFEATURE_FORWARD                 0x00000001
#define LINEADDRFEATURE_MAKECALL                0x00000002
#define LINEADDRFEATURE_PICKUP                  0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL         0x00000008
#define LINEADDRFEATURE_SETTERMINAL             0x00000010
#define LINEADDRFEATURE_SETUPCONF               0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL          0x00000040
#define LINEADDRFEATURE_UNPARK                  0x00000080
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRFEATURE_PICKUPHELD              0x00000100      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPGROUP             0x00000200      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPDIRECT            0x00000400      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPWAITING           0x00000800      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDFWD              0x00001000      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDDND              0x00002000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEAGENTFEATURE_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEAGENTFEATURE_SETAGENTACTIVITY       0x00000004      // TAPI v2.0
#define LINEAGENTFEATURE_AGENTSPECIFIC          0x00000008      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTACTIVITYLIST   0x00000010      // TAPI v2.0
#define LINEAGENTFEATURE_GETAGENTGROUP          0x00000020      // TAPI v2.0

#define LINEAGENTSTATE_LOGGEDOFF                0x00000001      // TAPI v2.0
#define LINEAGENTSTATE_NOTREADY                 0x00000002      // TAPI v2.0
#define LINEAGENTSTATE_READY                    0x00000004      // TAPI v2.0
#define LINEAGENTSTATE_BUSYACD                  0x00000008      // TAPI v2.0
#define LINEAGENTSTATE_BUSYINCOMING             0x00000010      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOUTBOUND             0x00000020      // TAPI v2.0
#define LINEAGENTSTATE_BUSYOTHER                0x00000040      // TAPI v2.0
#define LINEAGENTSTATE_WORKINGAFTERCALL         0x00000080      // TAPI v2.0
#define LINEAGENTSTATE_UNKNOWN                  0x00000100      // TAPI v2.0
#define LINEAGENTSTATE_UNAVAIL                  0x00000200      // TAPI v2.0

#define LINEAGENTSTATUS_GROUP                   0x00000001      // TAPI v2.0
#define LINEAGENTSTATUS_STATE                   0x00000002      // TAPI v2.0
#define LINEAGENTSTATUS_NEXTSTATE               0x00000004      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITY                0x00000008      // TAPI v2.0
#define LINEAGENTSTATUS_ACTIVITYLIST            0x00000010      // TAPI v2.0
#define LINEAGENTSTATUS_GROUPLIST               0x00000020      // TAPI v2.0
#define LINEAGENTSTATUS_CAPSCHANGE              0x00000040      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDSTATES             0x00000080      // TAPI v2.0
#define LINEAGENTSTATUS_VALIDNEXTSTATES         0x00000100      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
#define LINEAGENTSTATEEX_NOTREADY               0x00000001      // TAPI v2.2
#define LINEAGENTSTATEEX_READY                  0x00000002      // TAPI v2.2
#define LINEAGENTSTATEEX_BUSYACD                0x00000004      // TAPI v2.2
#define LINEAGENTSTATEEX_BUSYINCOMING           0x00000008      // TAPI v2.2
#define LINEAGENTSTATEEX_BUSYOUTGOING           0x00000010      // TAPI v2.2
#define LINEAGENTSTATEEX_UNKNOWN                0x00000020      // TAPI v2.2
#define LINEAGENTSTATEEX_RELEASED               0x00000040      // TAPI v2.2

#define LINEAGENTSTATUSEX_NEWAGENT              0x00000001      // TAPI v2.2
#define LINEAGENTSTATUSEX_STATE                 0x00000002      // TAPI v2.2
#define LINEAGENTSTATUSEX_UPDATEINFO            0x00000004      // TAPI v2.2
//#define LINEAGENTSTATUSEX_DESTROYED             0x00000004      // TAPI v2.2

#define LINEAGENTSESSIONSTATE_NOTREADY          0x00000001      // TAPI v2.2
#define LINEAGENTSESSIONSTATE_READY             0x00000002      // TAPI v2.2
#define LINEAGENTSESSIONSTATE_BUSYONCALL        0x00000004      // TAPI v2.2
#define LINEAGENTSESSIONSTATE_BUSYWRAPUP        0x00000008      // TAPI v2.2
#define LINEAGENTSESSIONSTATE_ENDED             0x00000010      // TAPI v2.2
#define LINEAGENTSESSIONSTATE_RELEASED          0x00000020      // TAPI v2.2

#define LINEAGENTSESSIONSTATUS_NEWSESSION       0x00000001      // TAPI v2.2
#define LINEAGENTSESSIONSTATUS_STATE            0x00000002      // TAPI v2.2
#define LINEAGENTSESSIONSTATUS_UPDATEINFO       0x00000004      // TAPI v2.2
//#define LINEAGENTSESSIONSTATUS_DESTROYED        0x00000008      // TAPI v2.2

#define LINEQUEUESTATUS_UPDATEINFO              0x00000001      // TAPI v2.2
#define LINEQUEUESTATUS_NEWQUEUE                0x00000002      // TAPI v2.2
#define LINEQUEUESTATUS_QUEUEREMOVED            0x00000004      // TAPI v2.2

#define LINEGROUPSTATUS_NEWGROUP                0x00000001      // TAPI v2.2
#define LINEGROUPSTATUS_GROUPREMOVED            0x00000002      // TAPI v2.2

#define LINEPROXYSTATUS_OPEN                    0x00000001      // TAPI v2.2
#define LINEPROXYSTATUS_CLOSE                   0x00000002      // TAPI v2.2
#define LINEPROXYSTATUS_ALLOPENFORACD           0x00000004      // TAPI v2.2
#endif

#define LINEANSWERMODE_NONE                     0x00000001
#define LINEANSWERMODE_DROP                     0x00000002
#define LINEANSWERMODE_HOLD                     0x00000004

#define LINEBEARERMODE_VOICE                    0x00000001
#define LINEBEARERMODE_SPEECH                   0x00000002
#define LINEBEARERMODE_MULTIUSE                 0x00000004
#define LINEBEARERMODE_DATA                     0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA            0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING         0x00000020
#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEBEARERMODE_RESTRICTEDDATA           0x00000080      // TAPI v2.0
#endif

#define LINEBUSYMODE_STATION                    0x00000001
#define LINEBUSYMODE_TRUNK                      0x00000002
#define LINEBUSYMODE_UNKNOWN                    0x00000004
#define LINEBUSYMODE_UNAVAIL                    0x00000008

#define LINECALLCOMPLCOND_BUSY                  0x00000001
#define LINECALLCOMPLCOND_NOANSWER              0x00000002

#define LINECALLCOMPLMODE_CAMPON                0x00000001
#define LINECALLCOMPLMODE_CALLBACK              0x00000002
#define LINECALLCOMPLMODE_INTRUDE               0x00000004
#define LINECALLCOMPLMODE_MESSAGE               0x00000008

#define LINECALLFEATURE_ACCEPT                  0x00000001
#define LINECALLFEATURE_ADDTOCONF               0x00000002
#define LINECALLFEATURE_ANSWER                  0x00000004
#define LINECALLFEATURE_BLINDTRANSFER           0x00000008
#define LINECALLFEATURE_COMPLETECALL            0x00000010
#define LINECALLFEATURE_COMPLETETRANSF          0x00000020
#define LINECALLFEATURE_DIAL                    0x00000040
#define LINECALLFEATURE_DROP                    0x00000080
#define LINECALLFEATURE_GATHERDIGITS            0x00000100
#define LINECALLFEATURE_GENERATEDIGITS          0x00000200
#define LINECALLFEATURE_GENERATETONE            0x00000400
#define LINECALLFEATURE_HOLD                    0x00000800
#define LINECALLFEATURE_MONITORDIGITS           0x00001000
#define LINECALLFEATURE_MONITORMEDIA            0x00002000
#define LINECALLFEATURE_MONITORTONES            0x00004000
#define LINECALLFEATURE_PARK                    0x00008000
#define LINECALLFEATURE_PREPAREADDCONF          0x00010000
#define LINECALLFEATURE_REDIRECT                0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF          0x00040000
#define LINECALLFEATURE_SECURECALL              0x00080000
#define LINECALLFEATURE_SENDUSERUSER            0x00100000
#define LINECALLFEATURE_SETCALLPARAMS           0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL         0x00400000
#define LINECALLFEATURE_SETTERMINAL             0x00800000
#define LINECALLFEATURE_SETUPCONF               0x01000000
#define LINECALLFEATURE_SETUPTRANSFER           0x02000000
#define LINECALLFEATURE_SWAPHOLD                0x04000000
#define LINECALLFEATURE_UNHOLD                  0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE_SETTREATMENT            0x20000000      // TAPI v2.0
#define LINECALLFEATURE_SETQOS                  0x40000000      // TAPI v2.0
#define LINECALLFEATURE_SETCALLDATA             0x80000000      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE2_NOHOLDCONFERENCE       0x00000001      // TAPI v2.0
#define LINECALLFEATURE2_ONESTEPTRANSFER        0x00000002      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCAMPON            0x00000004      // TAPI v2.0
#define LINECALLFEATURE2_COMPLCALLBACK          0x00000008      // TAPI v2.0
#define LINECALLFEATURE2_COMPLINTRUDE           0x00000010      // TAPI v2.0
#define LINECALLFEATURE2_COMPLMESSAGE           0x00000020      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERNORM           0x00000040      // TAPI v2.0
#define LINECALLFEATURE2_TRANSFERCONF           0x00000080      // TAPI v2.0
#define LINECALLFEATURE2_PARKDIRECT             0x00000100      // TAPI v2.0
#define LINECALLFEATURE2_PARKNONDIRECT          0x00000200      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINECALLHUBTRACKING_NONE                0x00000000      // TAPI v3.0
#define LINECALLHUBTRACKING_PROVIDERLEVEL       0x00000001      // TAPI v3.0
#define LINECALLHUBTRACKING_ALLCALLS            0x00000002      // TAPI v3.0
#endif

#define LINECALLINFOSTATE_OTHER                 0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC           0x00000002
#define LINECALLINFOSTATE_BEARERMODE            0x00000004
#define LINECALLINFOSTATE_RATE                  0x00000008
#define LINECALLINFOSTATE_MEDIAMODE             0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC           0x00000020
#define LINECALLINFOSTATE_CALLID                0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID         0x00000080
#define LINECALLINFOSTATE_ORIGIN                0x00000100
#define LINECALLINFOSTATE_REASON                0x00000200
#define LINECALLINFOSTATE_COMPLETIONID          0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR          0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR          0x00001000
#define LINECALLINFOSTATE_NUMMONITORS           0x00002000
#define LINECALLINFOSTATE_TRUNK                 0x00004000
#define LINECALLINFOSTATE_CALLERID              0x00008000
#define LINECALLINFOSTATE_CALLEDID              0x00010000
#define LINECALLINFOSTATE_CONNECTEDID           0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID         0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID         0x00080000
#define LINECALLINFOSTATE_DISPLAY               0x00100000
#define LINECALLINFOSTATE_USERUSERINFO          0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP         0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP          0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO          0x01000000
#define LINECALLINFOSTATE_TERMINAL              0x02000000
#define LINECALLINFOSTATE_DIALPARAMS            0x04000000
#define LINECALLINFOSTATE_MONITORMODES          0x08000000
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLINFOSTATE_TREATMENT             0x10000000      // TAPI v2.0
#define LINECALLINFOSTATE_QOS                   0x20000000      // TAPI v2.0
#define LINECALLINFOSTATE_CALLDATA              0x40000000      // TAPI v2.0
#endif

#define LINECALLORIGIN_OUTBOUND                 0x00000001
#define LINECALLORIGIN_INTERNAL                 0x00000002
#define LINECALLORIGIN_EXTERNAL                 0x00000004
#define LINECALLORIGIN_UNKNOWN                  0x00000010
#define LINECALLORIGIN_UNAVAIL                  0x00000020
#define LINECALLORIGIN_CONFERENCE               0x00000040
#define LINECALLORIGIN_INBOUND                  0x00000080      // TAPI v1.4

#define LINECALLPARAMFLAGS_SECURE               0x00000001
#define LINECALLPARAMFLAGS_IDLE                 0x00000002
#define LINECALLPARAMFLAGS_BLOCKID              0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK          0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK          0x00000010
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE     0x00000020      // TAPI v2.0
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL       0x00000040      // TAPI v2.0
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER      0x00000080      // TAPI v2.0
#endif

#define LINECALLPARTYID_BLOCKED                 0x00000001
#define LINECALLPARTYID_OUTOFAREA               0x00000002
#define LINECALLPARTYID_NAME                    0x00000004
#define LINECALLPARTYID_ADDRESS                 0x00000008
#define LINECALLPARTYID_PARTIAL                 0x00000010
#define LINECALLPARTYID_UNKNOWN                 0x00000020
#define LINECALLPARTYID_UNAVAIL                 0x00000040

#define LINECALLPRIVILEGE_NONE                  0x00000001
#define LINECALLPRIVILEGE_MONITOR               0x00000002
#define LINECALLPRIVILEGE_OWNER                 0x00000004

#define LINECALLREASON_DIRECT                   0x00000001
#define LINECALLREASON_FWDBUSY                  0x00000002
#define LINECALLREASON_FWDNOANSWER              0x00000004
#define LINECALLREASON_FWDUNCOND                0x00000008
#define LINECALLREASON_PICKUP                   0x00000010
#define LINECALLREASON_UNPARK                   0x00000020
#define LINECALLREASON_REDIRECT                 0x00000040
#define LINECALLREASON_CALLCOMPLETION           0x00000080
#define LINECALLREASON_TRANSFER                 0x00000100
#define LINECALLREASON_REMINDER                 0x00000200
#define LINECALLREASON_UNKNOWN                  0x00000400
#define LINECALLREASON_UNAVAIL                  0x00000800
#define LINECALLREASON_INTRUDE                  0x00001000      // TAPI v1.4
#define LINECALLREASON_PARKED                   0x00002000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLREASON_CAMPEDON                 0x00004000      // TAPI v2.0
#define LINECALLREASON_ROUTEREQUEST             0x00008000      // TAPI v2.0
#endif

#define LINECALLSELECT_LINE                     0x00000001
#define LINECALLSELECT_ADDRESS                  0x00000002
#define LINECALLSELECT_CALL                     0x00000004
#if (TAPI_CURRENT_VERSION >= 0x00020001)
#define LINECALLSELECT_DEVICEID                 0x00000008      // TAPI v2.1
#endif
#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINECALLSELECT_CALLID                   0x00000010      // TAPI v3.0
#endif

#define LINECALLSTATE_IDLE                      0x00000001
#define LINECALLSTATE_OFFERING                  0x00000002
#define LINECALLSTATE_ACCEPTED                  0x00000004
#define LINECALLSTATE_DIALTONE                  0x00000008
#define LINECALLSTATE_DIALING                   0x00000010
#define LINECALLSTATE_RINGBACK                  0x00000020
#define LINECALLSTATE_BUSY                      0x00000040
#define LINECALLSTATE_SPECIALINFO               0x00000080
#define LINECALLSTATE_CONNECTED                 0x00000100
#define LINECALLSTATE_PROCEEDING                0x00000200
#define LINECALLSTATE_ONHOLD                    0x00000400
#define LINECALLSTATE_CONFERENCED               0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF            0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER        0x00002000
#define LINECALLSTATE_DISCONNECTED              0x00004000
#define LINECALLSTATE_UNKNOWN                   0x00008000

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLTREATMENT_SILENCE               0x00000001      // TAPI v2.0
#define LINECALLTREATMENT_RINGBACK              0x00000002      // TAPI v2.0
#define LINECALLTREATMENT_BUSY                  0x00000003      // TAPI v2.0
#define LINECALLTREATMENT_MUSIC                 0x00000004      // TAPI v2.0
#endif

#define LINECARDOPTION_PREDEFINED               0x00000001      // TAPI v1.4
#define LINECARDOPTION_HIDDEN                   0x00000002      // TAPI v1.4

#define LINECONNECTEDMODE_ACTIVE                0x00000001      // TAPI v1.4
#define LINECONNECTEDMODE_INACTIVE              0x00000002      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECONNECTEDMODE_ACTIVEHELD            0x00000004      // TAPI v2.0
#define LINECONNECTEDMODE_INACTIVEHELD          0x00000008      // TAPI v2.0
#define LINECONNECTEDMODE_CONFIRMED             0x00000010      // TAPI v2.0
#endif

#define LINEDEVCAPFLAGS_CROSSADDRCONF           0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP             0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP              0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL            0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR            0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP               0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING             0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET               0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE            0x00000100
#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEDEVCAPFLAGS_MSP                     0x00000200      // TAPI v3.0
#define LINEDEVCAPFLAGS_CALLHUB                 0x00000400      // TAPI v3.0
#define LINEDEVCAPFLAGS_CALLHUBTRACKING         0x00000800      // TAPI v3.0
#define LINEDEVCAPFLAGS_PRIVATEOBJECTS          0x00001000      // TAPI v3.0
#endif
#define LINEDEVCAPFLAGS_LOCAL                   0x00002000

#define LINEDEVSTATE_OTHER                      0x00000001
#define LINEDEVSTATE_RINGING                    0x00000002
#define LINEDEVSTATE_CONNECTED                  0x00000004
#define LINEDEVSTATE_DISCONNECTED               0x00000008
#define LINEDEVSTATE_MSGWAITON                  0x00000010
#define LINEDEVSTATE_MSGWAITOFF                 0x00000020
#define LINEDEVSTATE_INSERVICE                  0x00000040
#define LINEDEVSTATE_OUTOFSERVICE               0x00000080
#define LINEDEVSTATE_MAINTENANCE                0x00000100
#define LINEDEVSTATE_OPEN                       0x00000200
#define LINEDEVSTATE_CLOSE                      0x00000400
#define LINEDEVSTATE_NUMCALLS                   0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS             0x00001000
#define LINEDEVSTATE_TERMINALS                  0x00002000
#define LINEDEVSTATE_ROAMMODE                   0x00004000
#define LINEDEVSTATE_BATTERY                    0x00008000
#define LINEDEVSTATE_SIGNAL                     0x00010000
#define LINEDEVSTATE_DEVSPECIFIC                0x00020000
#define LINEDEVSTATE_REINIT                     0x00040000
#define LINEDEVSTATE_LOCK                       0x00080000
#define LINEDEVSTATE_CAPSCHANGE                 0x00100000      // TAPI v1.4
#define LINEDEVSTATE_CONFIGCHANGE               0x00200000      // TAPI v1.4
#define LINEDEVSTATE_TRANSLATECHANGE            0x00400000      // TAPI v1.4
#define LINEDEVSTATE_COMPLCANCEL                0x00800000      // TAPI v1.4
#define LINEDEVSTATE_REMOVED                    0x01000000      // TAPI v1.4

#define LINEDEVSTATUSFLAGS_CONNECTED            0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT              0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE            0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED               0x00000008

#define LINEDIALTONEMODE_NORMAL                 0x00000001
#define LINEDIALTONEMODE_SPECIAL                0x00000002
#define LINEDIALTONEMODE_INTERNAL               0x00000004
#define LINEDIALTONEMODE_EXTERNAL               0x00000008
#define LINEDIALTONEMODE_UNKNOWN                0x00000010
#define LINEDIALTONEMODE_UNAVAIL                0x00000020

#define LINEDIGITMODE_PULSE                     0x00000001
#define LINEDIGITMODE_DTMF                      0x00000002
#define LINEDIGITMODE_DTMFEND                   0x00000004

#define LINEDISCONNECTMODE_NORMAL               0x00000001
#define LINEDISCONNECTMODE_UNKNOWN              0x00000002
#define LINEDISCONNECTMODE_REJECT               0x00000004
#define LINEDISCONNECTMODE_PICKUP               0x00000008
#define LINEDISCONNECTMODE_FORWARDED            0x00000010
#define LINEDISCONNECTMODE_BUSY                 0x00000020
#define LINEDISCONNECTMODE_NOANSWER             0x00000040
#define LINEDISCONNECTMODE_BADADDRESS           0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE          0x00000100
#define LINEDISCONNECTMODE_CONGESTION           0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE         0x00000400
#define LINEDISCONNECTMODE_UNAVAIL              0x00000800
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEDISCONNECTMODE_NUMBERCHANGED        0x00002000      // TAPI v2.0
#define LINEDISCONNECTMODE_OUTOFORDER           0x00004000      // TAPI v2.0
#define LINEDISCONNECTMODE_TEMPFAILURE          0x00008000      // TAPI v2.0
#define LINEDISCONNECTMODE_QOSUNAVAIL           0x00010000      // TAPI v2.0
#define LINEDISCONNECTMODE_BLOCKED              0x00020000      // TAPI v2.0
#define LINEDISCONNECTMODE_DONOTDISTURB         0x00040000      // TAPI v2.0
#define LINEDISCONNECTMODE_CANCELLED            0x00080000      // TAPI v2.0
#endif

#define LINEERR_ALLOCATED                       0x80000001
#define LINEERR_BADDEVICEID                     0x80000002
#define LINEERR_BEARERMODEUNAVAIL               0x80000003
#define LINEERR_CALLUNAVAIL                     0x80000005
#define LINEERR_COMPLETIONOVERRUN               0x80000006
#define LINEERR_CONFERENCEFULL                  0x80000007
#define LINEERR_DIALBILLING                     0x80000008
#define LINEERR_DIALDIALTONE                    0x80000009
#define LINEERR_DIALPROMPT                      0x8000000A
#define LINEERR_DIALQUIET                       0x8000000B
#define LINEERR_INCOMPATIBLEAPIVERSION          0x8000000C
#define LINEERR_INCOMPATIBLEEXTVERSION          0x8000000D
#define LINEERR_INIFILECORRUPT                  0x8000000E
#define LINEERR_INUSE                           0x8000000F
#define LINEERR_INVALADDRESS                    0x80000010
#define LINEERR_INVALADDRESSID                  0x80000011
#define LINEERR_INVALADDRESSMODE                0x80000012
#define LINEERR_INVALADDRESSSTATE               0x80000013
#define LINEERR_INVALAPPHANDLE                  0x80000014
#define LINEERR_INVALAPPNAME                    0x80000015
#define LINEERR_INVALBEARERMODE                 0x80000016
#define LINEERR_INVALCALLCOMPLMODE              0x80000017
#define LINEERR_INVALCALLHANDLE                 0x80000018
#define LINEERR_INVALCALLPARAMS                 0x80000019
#define LINEERR_INVALCALLPRIVILEGE              0x8000001A
#define LINEERR_INVALCALLSELECT                 0x8000001B
#define LINEERR_INVALCALLSTATE                  0x8000001C
#define LINEERR_INVALCALLSTATELIST              0x8000001D
#define LINEERR_INVALCARD                       0x8000001E
#define LINEERR_INVALCOMPLETIONID               0x8000001F
#define LINEERR_INVALCONFCALLHANDLE             0x80000020
#define LINEERR_INVALCONSULTCALLHANDLE          0x80000021
#define LINEERR_INVALCOUNTRYCODE                0x80000022
#define LINEERR_INVALDEVICECLASS                0x80000023
#define LINEERR_INVALDEVICEHANDLE               0x80000024
#define LINEERR_INVALDIALPARAMS                 0x80000025
#define LINEERR_INVALDIGITLIST                  0x80000026
#define LINEERR_INVALDIGITMODE                  0x80000027
#define LINEERR_INVALDIGITS                     0x80000028
#define LINEERR_INVALEXTVERSION                 0x80000029
#define LINEERR_INVALGROUPID                    0x8000002A
#define LINEERR_INVALLINEHANDLE                 0x8000002B
#define LINEERR_INVALLINESTATE                  0x8000002C
#define LINEERR_INVALLOCATION                   0x8000002D
#define LINEERR_INVALMEDIALIST                  0x8000002E
#define LINEERR_INVALMEDIAMODE                  0x8000002F
#define LINEERR_INVALMESSAGEID                  0x80000030
#define LINEERR_INVALPARAM                      0x80000032
#define LINEERR_INVALPARKID                     0x80000033
#define LINEERR_INVALPARKMODE                   0x80000034
#define LINEERR_INVALPOINTER                    0x80000035
#define LINEERR_INVALPRIVSELECT                 0x80000036
#define LINEERR_INVALRATE                       0x80000037
#define LINEERR_INVALREQUESTMODE                0x80000038
#define LINEERR_INVALTERMINALID                 0x80000039
#define LINEERR_INVALTERMINALMODE               0x8000003A
#define LINEERR_INVALTIMEOUT                    0x8000003B
#define LINEERR_INVALTONE                       0x8000003C
#define LINEERR_INVALTONELIST                   0x8000003D
#define LINEERR_INVALTONEMODE                   0x8000003E
#define LINEERR_INVALTRANSFERMODE               0x8000003F
#define LINEERR_LINEMAPPERFAILED                0x80000040
#define LINEERR_NOCONFERENCE                    0x80000041
#define LINEERR_NODEVICE                        0x80000042
#define LINEERR_NODRIVER                        0x80000043
#define LINEERR_NOMEM                           0x80000044
#define LINEERR_NOREQUEST                       0x80000045
#define LINEERR_NOTOWNER                        0x80000046
#define LINEERR_NOTREGISTERED                   0x80000047
#define LINEERR_OPERATIONFAILED                 0x80000048
#define LINEERR_OPERATIONUNAVAIL                0x80000049
#define LINEERR_RATEUNAVAIL                     0x8000004A
#define LINEERR_RESOURCEUNAVAIL                 0x8000004B
#define LINEERR_REQUESTOVERRUN                  0x8000004C
#define LINEERR_STRUCTURETOOSMALL               0x8000004D
#define LINEERR_TARGETNOTFOUND                  0x8000004E
#define LINEERR_TARGETSELF                      0x8000004F
#define LINEERR_UNINITIALIZED                   0x80000050
#define LINEERR_USERUSERINFOTOOBIG              0x80000051
#define LINEERR_REINIT                          0x80000052
#define LINEERR_ADDRESSBLOCKED                  0x80000053
#define LINEERR_BILLINGREJECTED                 0x80000054
#define LINEERR_INVALFEATURE                    0x80000055
#define LINEERR_NOMULTIPLEINSTANCE              0x80000056
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEERR_INVALAGENTID                    0x80000057      // TAPI v2.0
#define LINEERR_INVALAGENTGROUP                 0x80000058      // TAPI v2.0
#define LINEERR_INVALPASSWORD                   0x80000059      // TAPI v2.0
#define LINEERR_INVALAGENTSTATE                 0x8000005A      // TAPI v2.0
#define LINEERR_INVALAGENTACTIVITY              0x8000005B      // TAPI v2.0
#define LINEERR_DIALVOICEDETECT                 0x8000005C      // TAPI v2.0
#endif
#if (TAPI_CURRENT_VERSION >= 0x00020002)
#define LINEERR_USERCANCELLED                   0x8000005D      // TAPI v2.2
#endif
#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEERR_INVALADDRESSTYPE                0x8000005E      // TAPI v3.0
#endif
#if (TAPI_CURRENT_VERSION >= 0x00020002)
#define LINEERR_INVALAGENTSESSIONSTATE          0x8000005F      // TAPI v2.2
#define LINEERR_DISCONNECTED                    0X80000060
#define LINEERR_SERVICE_NOT_RUNNING             0x80000061
#endif

#define LINEFEATURE_DEVSPECIFIC                 0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT             0x00000002
#define LINEFEATURE_FORWARD                     0x00000004
#define LINEFEATURE_MAKECALL                    0x00000008
#define LINEFEATURE_SETMEDIACONTROL             0x00000010
#define LINEFEATURE_SETTERMINAL                 0x00000020
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEFEATURE_SETDEVSTATUS                0x00000040      // TAPI v2.0
#define LINEFEATURE_FORWARDFWD                  0x00000080      // TAPI v2.0
#define LINEFEATURE_FORWARDDND                  0x00000100      // TAPI v2.0
#endif

#define LINEFORWARDMODE_UNCOND                  0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL          0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL          0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC          0x00000008
#define LINEFORWARDMODE_BUSY                    0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL            0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL            0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC            0x00000080
#define LINEFORWARDMODE_NOANSW                  0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL          0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL          0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC          0x00000800
#define LINEFORWARDMODE_BUSYNA                  0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL          0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL          0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC          0x00008000
#define LINEFORWARDMODE_UNKNOWN                 0x00010000      // TAPI v1.4
#define LINEFORWARDMODE_UNAVAIL                 0x00020000      // TAPI v1.4

#define LINEGATHERTERM_BUFFERFULL               0x00000001
#define LINEGATHERTERM_TERMDIGIT                0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT             0x00000004
#define LINEGATHERTERM_INTERTIMEOUT             0x00000008
#define LINEGATHERTERM_CANCEL                   0x00000010

#define LINEGENERATETERM_DONE                   0x00000001
#define LINEGENERATETERM_CANCEL                 0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
//
// These constants are mutually exclusive - there's no way to specify more
// than one at a time (and it doesn't make sense, either) so they're
// ordinal rather than bits.
//
#define LINEINITIALIZEEXOPTION_USEHIDDENWINDOW      0x00000001  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USEEVENT             0x00000002  // TAPI v2.0
#define LINEINITIALIZEEXOPTION_USECOMPLETIONPORT    0x00000003  // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEINITIALIZEEXOPTION_CALLHUBTRACKING      0x80000000  // TAPI v3.0
#endif

#define LINELOCATIONOPTION_PULSEDIAL            0x00000001      // TAPI v1.4

#define LINEMAPPER                              0xFFFFFFFF

#define LINEMEDIACONTROL_NONE                   0x00000001
#define LINEMEDIACONTROL_START                  0x00000002
#define LINEMEDIACONTROL_RESET                  0x00000004
#define LINEMEDIACONTROL_PAUSE                  0x00000008
#define LINEMEDIACONTROL_RESUME                 0x00000010
#define LINEMEDIACONTROL_RATEUP                 0x00000020
#define LINEMEDIACONTROL_RATEDOWN               0x00000040
#define LINEMEDIACONTROL_RATENORMAL             0x00000080
#define LINEMEDIACONTROL_VOLUMEUP               0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN             0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL           0x00000400

#define LINEMEDIAMODE_UNKNOWN                   0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE          0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE            0x00000008
#define LINEMEDIAMODE_DATAMODEM                 0x00000010
#define LINEMEDIAMODE_G3FAX                     0x00000020
#define LINEMEDIAMODE_TDD                       0x00000040
#define LINEMEDIAMODE_G4FAX                     0x00000080
#define LINEMEDIAMODE_DIGITALDATA               0x00000100
#define LINEMEDIAMODE_TELETEX                   0x00000200
#define LINEMEDIAMODE_VIDEOTEX                  0x00000400
#define LINEMEDIAMODE_TELEX                     0x00000800
#define LINEMEDIAMODE_MIXED                     0x00001000
#define LINEMEDIAMODE_ADSI                      0x00002000
#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#if (TAPI_CURRENT_VERSION >= 0x00020001)
#define LINEMEDIAMODE_VIDEO                     0x00008000      // TAPI v2.1
#endif
#define LAST_LINEMEDIAMODE                      0x00008000

#define LINEOFFERINGMODE_ACTIVE                 0x00000001      // TAPI v1.4
#define LINEOFFERINGMODE_INACTIVE               0x00000002      // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEOPENOPTION_SINGLEADDRESS            0x80000000      // TAPI v2.0
#define LINEOPENOPTION_PROXY                    0x40000000      // TAPI v2.0
#endif

#define LINEPARKMODE_DIRECTED                   0x00000001
#define LINEPARKMODE_NONDIRECTED                0x00000002

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEPROXYREQUEST_SETAGENTGROUP          0x00000001      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTSTATE          0x00000002      // TAPI v2.0
#define LINEPROXYREQUEST_SETAGENTACTIVITY       0x00000003      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTCAPS           0x00000004      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTSTATUS         0x00000005      // TAPI v2.0
#define LINEPROXYREQUEST_AGENTSPECIFIC          0x00000006      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTACTIVITYLIST   0x00000007      // TAPI v2.0
#define LINEPROXYREQUEST_GETAGENTGROUPLIST      0x00000008      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
#define LINEPROXYREQUEST_CREATEAGENT                0x00000009  // TAPI v2.2
#define LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD  0x0000000A  // TAPI v2.2
#define LINEPROXYREQUEST_GETAGENTINFO               0x0000000B  // TAPI v2.2
#define LINEPROXYREQUEST_CREATEAGENTSESSION         0x0000000C  // TAPI v2.2
#define LINEPROXYREQUEST_GETAGENTSESSIONLIST        0x0000000D  // TAPI v2.2
#define LINEPROXYREQUEST_SETAGENTSESSIONSTATE       0x0000000E  // TAPI v2.2
#define LINEPROXYREQUEST_GETAGENTSESSIONINFO        0x0000000F  // TAPI v2.2
#define LINEPROXYREQUEST_GETQUEUELIST               0x00000010  // TAPI v2.2
#define LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD  0x00000011  // TAPI v2.2
#define LINEPROXYREQUEST_GETQUEUEINFO               0x00000012  // TAPI v2.2
#define LINEPROXYREQUEST_GETGROUPLIST               0x00000013  // TAPI v2.2
#define LINEPROXYREQUEST_SETAGENTSTATEEX            0x00000014  // TAPI v2.2
#endif

#define LINEREMOVEFROMCONF_NONE                 0x00000001
#define LINEREMOVEFROMCONF_LAST                 0x00000002
#define LINEREMOVEFROMCONF_ANY                  0x00000003

#define LINEREQUESTMODE_MAKECALL                0x00000001
#define LINEREQUESTMODE_MEDIACALL               0x00000002
#define LINEREQUESTMODE_DROP                    0x00000004
#define LAST_LINEREQUESTMODE                    LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN                    0x00000001
#define LINEROAMMODE_UNAVAIL                    0x00000002
#define LINEROAMMODE_HOME                       0x00000004
#define LINEROAMMODE_ROAMA                      0x00000008
#define LINEROAMMODE_ROAMB                      0x00000010

#define LINESPECIALINFO_NOCIRCUIT               0x00000001
#define LINESPECIALINFO_CUSTIRREG               0x00000002
#define LINESPECIALINFO_REORDER                 0x00000004
#define LINESPECIALINFO_UNKNOWN                 0x00000008
#define LINESPECIALINFO_UNAVAIL                 0x00000010

#define LINETERMDEV_PHONE                       0x00000001
#define LINETERMDEV_HEADSET                     0x00000002
#define LINETERMDEV_SPEAKER                     0x00000004

#define LINETERMMODE_BUTTONS                    0x00000001
#define LINETERMMODE_LAMPS                      0x00000002
#define LINETERMMODE_DISPLAY                    0x00000004
#define LINETERMMODE_RINGER                     0x00000008
#define LINETERMMODE_HOOKSWITCH                 0x00000010
#define LINETERMMODE_MEDIATOLINE                0x00000020
#define LINETERMMODE_MEDIAFROMLINE              0x00000040
#define LINETERMMODE_MEDIABIDIRECT              0x00000080

#define LINETERMSHARING_PRIVATE                 0x00000001
#define LINETERMSHARING_SHAREDEXCL              0x00000002
#define LINETERMSHARING_SHAREDCONF              0x00000004

#define LINETOLLLISTOPTION_ADD                  0x00000001
#define LINETOLLLISTOPTION_REMOVE               0x00000002

#define LINETONEMODE_CUSTOM                     0x00000001
#define LINETONEMODE_RINGBACK                   0x00000002
#define LINETONEMODE_BUSY                       0x00000004
#define LINETONEMODE_BEEP                       0x00000008
#define LINETONEMODE_BILLING                    0x00000010

#define LINETRANSFERMODE_TRANSFER               0x00000001
#define LINETRANSFERMODE_CONFERENCE             0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE        0x00000001
#define LINETRANSLATEOPTION_CANCELCALLWAITING   0x00000002      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELOCAL          0x00000004      // TAPI v1.4
#define LINETRANSLATEOPTION_FORCELD             0x00000008      // TAPI v1.4

#define LINETRANSLATERESULT_CANONICAL           0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL       0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE        0x00000004
#define LINETRANSLATERESULT_LOCAL               0x00000008
#define LINETRANSLATERESULT_INTOLLLIST          0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST       0x00000020
#define LINETRANSLATERESULT_DIALBILLING         0x00000040
#define LINETRANSLATERESULT_DIALQUIET           0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE        0x00000100
#define LINETRANSLATERESULT_DIALPROMPT          0x00000200
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define LINETRANSLATERESULT_VOICEDETECT         0x00000400      // TAPI v2.0
#endif
#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINETRANSLATERESULT_NOTRANSLATION       0x00000800      // TAPI v3.0
#endif

#define PHONEBUTTONFUNCTION_UNKNOWN             0x00000000
#define PHONEBUTTONFUNCTION_CONFERENCE          0x00000001
#define PHONEBUTTONFUNCTION_TRANSFER            0x00000002
#define PHONEBUTTONFUNCTION_DROP                0x00000003
#define PHONEBUTTONFUNCTION_HOLD                0x00000004
#define PHONEBUTTONFUNCTION_RECALL              0x00000005
#define PHONEBUTTONFUNCTION_DISCONNECT          0x00000006
#define PHONEBUTTONFUNCTION_CONNECT             0x00000007
#define PHONEBUTTONFUNCTION_MSGWAITON           0x00000008
#define PHONEBUTTONFUNCTION_MSGWAITOFF          0x00000009
#define PHONEBUTTONFUNCTION_SELECTRING          0x0000000A
#define PHONEBUTTONFUNCTION_ABBREVDIAL          0x0000000B
#define PHONEBUTTONFUNCTION_FORWARD             0x0000000C
#define PHONEBUTTONFUNCTION_PICKUP              0x0000000D
#define PHONEBUTTONFUNCTION_RINGAGAIN           0x0000000E
#define PHONEBUTTONFUNCTION_PARK                0x0000000F
#define PHONEBUTTONFUNCTION_REJECT              0x00000010
#define PHONEBUTTONFUNCTION_REDIRECT            0x00000011
#define PHONEBUTTONFUNCTION_MUTE                0x00000012
#define PHONEBUTTONFUNCTION_VOLUMEUP            0x00000013
#define PHONEBUTTONFUNCTION_VOLUMEDOWN          0x00000014
#define PHONEBUTTONFUNCTION_SPEAKERON           0x00000015
#define PHONEBUTTONFUNCTION_SPEAKEROFF          0x00000016
#define PHONEBUTTONFUNCTION_FLASH               0x00000017
#define PHONEBUTTONFUNCTION_DATAON              0x00000018
#define PHONEBUTTONFUNCTION_DATAOFF             0x00000019
#define PHONEBUTTONFUNCTION_DONOTDISTURB        0x0000001A
#define PHONEBUTTONFUNCTION_INTERCOM            0x0000001B
#define PHONEBUTTONFUNCTION_BRIDGEDAPP          0x0000001C
#define PHONEBUTTONFUNCTION_BUSY                0x0000001D
#define PHONEBUTTONFUNCTION_CALLAPP             0x0000001E
#define PHONEBUTTONFUNCTION_DATETIME            0x0000001F
#define PHONEBUTTONFUNCTION_DIRECTORY           0x00000020
#define PHONEBUTTONFUNCTION_COVER               0x00000021
#define PHONEBUTTONFUNCTION_CALLID              0x00000022
#define PHONEBUTTONFUNCTION_LASTNUM             0x00000023
#define PHONEBUTTONFUNCTION_NIGHTSRV            0x00000024
#define PHONEBUTTONFUNCTION_SENDCALLS           0x00000025
#define PHONEBUTTONFUNCTION_MSGINDICATOR        0x00000026
#define PHONEBUTTONFUNCTION_REPDIAL             0x00000027
#define PHONEBUTTONFUNCTION_SETREPDIAL          0x00000028
#define PHONEBUTTONFUNCTION_SYSTEMSPEED         0x00000029
#define PHONEBUTTONFUNCTION_STATIONSPEED        0x0000002A
#define PHONEBUTTONFUNCTION_CAMPON              0x0000002B
#define PHONEBUTTONFUNCTION_SAVEREPEAT          0x0000002C
#define PHONEBUTTONFUNCTION_QUEUECALL           0x0000002D
#define PHONEBUTTONFUNCTION_NONE                0x0000002E
#if (TAPI_CURRENT_VERSION >= 0x00030001)
#define PHONEBUTTONFUNCTION_SEND                0x0000002F      // TAPI v3.1
#endif

#define PHONEBUTTONMODE_DUMMY                   0x00000001
#define PHONEBUTTONMODE_CALL                    0x00000002
#define PHONEBUTTONMODE_FEATURE                 0x00000004
#define PHONEBUTTONMODE_KEYPAD                  0x00000008
#define PHONEBUTTONMODE_LOCAL                   0x00000010
#define PHONEBUTTONMODE_DISPLAY                 0x00000020

#define PHONEBUTTONSTATE_UP                     0x00000001
#define PHONEBUTTONSTATE_DOWN                   0x00000002
#define PHONEBUTTONSTATE_UNKNOWN                0x00000004      // TAPI v1.4
#define PHONEBUTTONSTATE_UNAVAIL                0x00000008      // TAPI v1.4

#define PHONEERR_ALLOCATED                      0x90000001
#define PHONEERR_BADDEVICEID                    0x90000002
#define PHONEERR_INCOMPATIBLEAPIVERSION         0x90000003
#define PHONEERR_INCOMPATIBLEEXTVERSION         0x90000004
#define PHONEERR_INIFILECORRUPT                 0x90000005
#define PHONEERR_INUSE                          0x90000006
#define PHONEERR_INVALAPPHANDLE                 0x90000007
#define PHONEERR_INVALAPPNAME                   0x90000008
#define PHONEERR_INVALBUTTONLAMPID              0x90000009
#define PHONEERR_INVALBUTTONMODE                0x9000000A
#define PHONEERR_INVALBUTTONSTATE               0x9000000B
#define PHONEERR_INVALDATAID                    0x9000000C
#define PHONEERR_INVALDEVICECLASS               0x9000000D
#define PHONEERR_INVALEXTVERSION                0x9000000E
#define PHONEERR_INVALHOOKSWITCHDEV             0x9000000F
#define PHONEERR_INVALHOOKSWITCHMODE            0x90000010
#define PHONEERR_INVALLAMPMODE                  0x90000011
#define PHONEERR_INVALPARAM                     0x90000012
#define PHONEERR_INVALPHONEHANDLE               0x90000013
#define PHONEERR_INVALPHONESTATE                0x90000014
#define PHONEERR_INVALPOINTER                   0x90000015
#define PHONEERR_INVALPRIVILEGE                 0x90000016
#define PHONEERR_INVALRINGMODE                  0x90000017
#define PHONEERR_NODEVICE                       0x90000018
#define PHONEERR_NODRIVER                       0x90000019
#define PHONEERR_NOMEM                          0x9000001A
#define PHONEERR_NOTOWNER                       0x9000001B
#define PHONEERR_OPERATIONFAILED                0x9000001C
#define PHONEERR_OPERATIONUNAVAIL               0x9000001D
#define PHONEERR_RESOURCEUNAVAIL                0x9000001F
#define PHONEERR_REQUESTOVERRUN                 0x90000020
#define PHONEERR_STRUCTURETOOSMALL              0x90000021
#define PHONEERR_UNINITIALIZED                  0x90000022
#define PHONEERR_REINIT                         0x90000023
#define PHONEERR_DISCONNECTED                   0x90000024
#define PHONEERR_SERVICE_NOT_RUNNING            0x90000025

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEFEATURE_GETBUTTONINFO              0x00000001      // TAPI v2.0
#define PHONEFEATURE_GETDATA                    0x00000002      // TAPI v2.0
#define PHONEFEATURE_GETDISPLAY                 0x00000004      // TAPI v2.0
#define PHONEFEATURE_GETGAINHANDSET             0x00000008      // TAPI v2.0
#define PHONEFEATURE_GETGAINSPEAKER             0x00000010      // TAPI v2.0
#define PHONEFEATURE_GETGAINHEADSET             0x00000020      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHANDSET       0x00000040      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHSPEAKER       0x00000080      // TAPI v2.0
#define PHONEFEATURE_GETHOOKSWITCHHEADSET       0x00000100      // TAPI v2.0
#define PHONEFEATURE_GETLAMP                    0x00000200      // TAPI v2.0
#define PHONEFEATURE_GETRING                    0x00000400      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHANDSET           0x00000800      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMESPEAKER           0x00001000      // TAPI v2.0
#define PHONEFEATURE_GETVOLUMEHEADSET           0x00002000      // TAPI v2.0
#define PHONEFEATURE_SETBUTTONINFO              0x00004000      // TAPI v2.0
#define PHONEFEATURE_SETDATA                    0x00008000      // TAPI v2.0
#define PHONEFEATURE_SETDISPLAY                 0x00010000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHANDSET             0x00020000      // TAPI v2.0
#define PHONEFEATURE_SETGAINSPEAKER             0x00040000      // TAPI v2.0
#define PHONEFEATURE_SETGAINHEADSET             0x00080000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHANDSET       0x00100000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHSPEAKER       0x00200000      // TAPI v2.0
#define PHONEFEATURE_SETHOOKSWITCHHEADSET       0x00400000      // TAPI v2.0
#define PHONEFEATURE_SETLAMP                    0x00800000      // TAPI v2.0
#define PHONEFEATURE_SETRING                    0x01000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHANDSET           0x02000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMESPEAKER           0x04000000      // TAPI v2.0
#define PHONEFEATURE_SETVOLUMEHEADSET           0x08000000      // TAPI v2.0
#endif
#if (TAPI_CURRENT_VERSION >= 0x00030001)
#define PHONEFEATURE_GENERICPHONE               0x10000000      // TAPI v3.1
#endif

#define PHONEHOOKSWITCHDEV_HANDSET              0x00000001
#define PHONEHOOKSWITCHDEV_SPEAKER              0x00000002
#define PHONEHOOKSWITCHDEV_HEADSET              0x00000004

#define PHONEHOOKSWITCHMODE_ONHOOK              0x00000001
#define PHONEHOOKSWITCHMODE_MIC                 0x00000002
#define PHONEHOOKSWITCHMODE_SPEAKER             0x00000004
#define PHONEHOOKSWITCHMODE_MICSPEAKER          0x00000008
#define PHONEHOOKSWITCHMODE_UNKNOWN             0x00000010

#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define PHONEINITIALIZEEXOPTION_USEHIDDENWINDOW     0x00000001  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USEEVENT            0x00000002  // TAPI v2.0
#define PHONEINITIALIZEEXOPTION_USECOMPLETIONPORT   0x00000003  // TAPI v2.0
#endif

#define PHONELAMPMODE_DUMMY                     0x00000001
#define PHONELAMPMODE_OFF                       0x00000002
#define PHONELAMPMODE_STEADY                    0x00000004
#define PHONELAMPMODE_WINK                      0x00000008
#define PHONELAMPMODE_FLASH                     0x00000010
#define PHONELAMPMODE_FLUTTER                   0x00000020
#define PHONELAMPMODE_BROKENFLUTTER             0x00000040
#define PHONELAMPMODE_UNKNOWN                   0x00000080

#define PHONEPRIVILEGE_MONITOR                  0x00000001
#define PHONEPRIVILEGE_OWNER                    0x00000002

#define PHONESTATE_OTHER                        0x00000001
#define PHONESTATE_CONNECTED                    0x00000002
#define PHONESTATE_DISCONNECTED                 0x00000004
#define PHONESTATE_OWNER                        0x00000008
#define PHONESTATE_MONITORS                     0x00000010
#define PHONESTATE_DISPLAY                      0x00000020
#define PHONESTATE_LAMP                         0x00000040
#define PHONESTATE_RINGMODE                     0x00000080
#define PHONESTATE_RINGVOLUME                   0x00000100
#define PHONESTATE_HANDSETHOOKSWITCH            0x00000200
#define PHONESTATE_HANDSETVOLUME                0x00000400
#define PHONESTATE_HANDSETGAIN                  0x00000800
#define PHONESTATE_SPEAKERHOOKSWITCH            0x00001000
#define PHONESTATE_SPEAKERVOLUME                0x00002000
#define PHONESTATE_SPEAKERGAIN                  0x00004000
#define PHONESTATE_HEADSETHOOKSWITCH            0x00008000
#define PHONESTATE_HEADSETVOLUME                0x00010000
#define PHONESTATE_HEADSETGAIN                  0x00020000
#define PHONESTATE_SUSPEND                      0x00040000
#define PHONESTATE_RESUME                       0x00080000
#define PHONESTATE_DEVSPECIFIC                  0x00100000
#define PHONESTATE_REINIT                       0x00200000
#define PHONESTATE_CAPSCHANGE                   0x00400000      // TAPI v1.4
#define PHONESTATE_REMOVED                      0x00800000      // TAPI v1.4

#define PHONESTATUSFLAGS_CONNECTED              0x00000001
#define PHONESTATUSFLAGS_SUSPENDED              0x00000002

#define STRINGFORMAT_ASCII                      0x00000001
#define STRINGFORMAT_DBCS                       0x00000002
#define STRINGFORMAT_UNICODE                    0x00000003
#define STRINGFORMAT_BINARY                     0x00000004

#define TAPI_REPLY                              WM_USER + 99

#define TAPIERR_CONNECTED                       0L
#define TAPIERR_DROPPED                         -1L
#define TAPIERR_NOREQUESTRECIPIENT              -2L
#define TAPIERR_REQUESTQUEUEFULL                -3L
#define TAPIERR_INVALDESTADDRESS                -4L
#define TAPIERR_INVALWINDOWHANDLE               -5L
#define TAPIERR_INVALDEVICECLASS                -6L
#define TAPIERR_INVALDEVICEID                   -7L
#define TAPIERR_DEVICECLASSUNAVAIL              -8L
#define TAPIERR_DEVICEIDUNAVAIL                 -9L
#define TAPIERR_DEVICEINUSE                     -10L
#define TAPIERR_DESTBUSY                        -11L
#define TAPIERR_DESTNOANSWER                    -12L
#define TAPIERR_DESTUNAVAIL                     -13L
#define TAPIERR_UNKNOWNWINHANDLE                -14L
#define TAPIERR_UNKNOWNREQUESTID                -15L
#define TAPIERR_REQUESTFAILED                   -16L
#define TAPIERR_REQUESTCANCELLED                -17L
#define TAPIERR_INVALPOINTER                    -18L
#define TAPIERR_NOTADMIN                        -19L
#define TAPIERR_MMCWRITELOCKED                  -20L
#define TAPIERR_PROVIDERALREADYINSTALLED        -21L
#define TAPIERR_SCP_ALREADY_EXISTS		-22L
#define TAPIERR_SCP_DOES_NOT_EXIST		-23L


#define TAPIMAXDESTADDRESSSIZE                  80L
#define TAPIMAXAPPNAMESIZE                      40L
#define TAPIMAXCALLEDPARTYSIZE                  40L
#define TAPIMAXCOMMENTSIZE                      80L
#define TAPIMAXDEVICECLASSSIZE                  40L
#define TAPIMAXDEVICEIDSIZE                     40L


#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;

#endif /* GUID_DEFINED */

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif

typedef struct lineaddresscaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressSize;
    DWORD       dwAddressOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;
    DWORD       dwAddressSharing;
    DWORD       dwAddressStates;
    DWORD       dwCallInfoStates;
    DWORD       dwCallerIDFlags;
    DWORD       dwCalledIDFlags;
    DWORD       dwConnectedIDFlags;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwCallStates;
    DWORD       dwDialToneModes;
    DWORD       dwBusyModes;
    DWORD       dwSpecialInfo;
    DWORD       dwDisconnectModes;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwMaxNumOnHoldCalls;
    DWORD       dwMaxNumOnHoldPendingCalls;
    DWORD       dwMaxNumConference;
    DWORD       dwMaxNumTransConf;
    DWORD       dwAddrCapFlags;
    DWORD       dwCallFeatures;
    DWORD       dwRemoveFromConfCaps;
    DWORD       dwRemoveFromConfState;
    DWORD       dwTransferModes;
    DWORD       dwParkModes;
    DWORD       dwForwardModes;
    DWORD       dwMaxForwardEntries;
    DWORD       dwMaxSpecificEntries;
    DWORD       dwMinFwdNumRings;
    DWORD       dwMaxFwdNumRings;
    DWORD       dwMaxCallCompletions;
    DWORD       dwCallCompletionConds;
    DWORD       dwCallCompletionModes;
    DWORD       dwNumCompletionMessages;
    DWORD       dwCompletionMsgTextEntrySize;
    DWORD       dwCompletionMsgTextSize;
    DWORD       dwCompletionMsgTextOffset;

    DWORD       dwAddressFeatures;                              // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwNumCallTreatments;                            // TAPI v2.0
    DWORD       dwCallTreatmentListSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentListOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwMaxCallDataSize;                              // TAPI v2.0
    DWORD       dwCallFeatures2;                                // TAPI v2.0
    DWORD       dwMaxNoAnswerTimeout;                           // TAPI v2.0
    DWORD       dwConnectedModes;                               // TAPI v2.0
    DWORD       dwOfferingModes;                                // TAPI v2.0
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
#endif

} LINEADDRESSCAPS, FAR *LPLINEADDRESSCAPS;

typedef struct lineaddressstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumInUse;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwAddressFeatures;
    DWORD       dwNumRingsNoAnswer;
    DWORD       dwForwardNumEntries;
    DWORD       dwForwardSize;
    DWORD       dwForwardOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

} LINEADDRESSSTATUS, FAR *LPLINEADDRESSSTATUS;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineagentactivityentry_tag
{
    DWORD       dwID;                                           // TAPI v2.0
    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYENTRY, *LPLINEAGENTACTIVITYENTRY;

typedef struct lineagentactivitylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTACTIVITYLIST, *LPLINEAGENTACTIVITYLIST;

typedef struct lineagentcaps_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwAgentHandlerInfoSize;                         // TAPI v2.0
    DWORD       dwAgentHandlerInfoOffset;                       // TAPI v2.0
    DWORD       dwCapsVersion;                                  // TAPI v2.0
    DWORD       dwFeatures;                                     // TAPI v2.0
    DWORD       dwStates;                                       // TAPI v2.0
    DWORD       dwNextStates;                                   // TAPI v2.0
    DWORD       dwMaxNumGroupEntries;                           // TAPI v2.0
    DWORD       dwAgentStatusMessages;                          // TAPI v2.0
    DWORD       dwNumAgentExtensionIDs;                         // TAPI v2.0
    DWORD       dwAgentExtensionIDListSize;                     // TAPI v2.0
    DWORD       dwAgentExtensionIDListOffset;                   // TAPI v2.0

#if (TAPI_CURRENT_VERSION >= 0x00020002)
    GUID        ProxyGUID;                                      // TAPI v2.2
#endif

} LINEAGENTCAPS, *LPLINEAGENTCAPS;

typedef struct lineagentgroupentry_tag
{
    struct
    {
        DWORD   dwGroupID1;                                     // TAPI v2.0
        DWORD   dwGroupID2;                                     // TAPI v2.0
        DWORD   dwGroupID3;                                     // TAPI v2.0
        DWORD   dwGroupID4;                                     // TAPI v2.0

    } GroupID;

    DWORD       dwNameSize;                                     // TAPI v2.0
    DWORD       dwNameOffset;                                   // TAPI v2.0

} LINEAGENTGROUPENTRY, *LPLINEAGENTGROUPENTRY;

typedef struct lineagentgrouplist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwListSize;                                     // TAPI v2.0
    DWORD       dwListOffset;                                   // TAPI v2.0

} LINEAGENTGROUPLIST, *LPLINEAGENTGROUPLIST;

typedef struct lineagentstatus_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwNumEntries;                                   // TAPI v2.0
    DWORD       dwGroupListSize;                                // TAPI v2.0
    DWORD       dwGroupListOffset;                              // TAPI v2.0
    DWORD       dwState;                                        // TAPI v2.0
    DWORD       dwNextState;                                    // TAPI v2.0
    DWORD       dwActivityID;                                   // TAPI v2.0
    DWORD       dwActivitySize;                                 // TAPI v2.0
    DWORD       dwActivityOffset;                               // TAPI v2.0
    DWORD       dwAgentFeatures;                                // TAPI v2.0
    DWORD       dwValidStates;                                  // TAPI v2.0
    DWORD       dwValidNextStates;                              // TAPI v2.0

} LINEAGENTSTATUS, *LPLINEAGENTSTATUS;

typedef struct lineappinfo_tag
{
    DWORD       dwMachineNameSize;                              // TAPI v2.0
    DWORD       dwMachineNameOffset;                            // TAPI v2.0
    DWORD       dwUserNameSize;                                 // TAPI v2.0
    DWORD       dwUserNameOffset;                               // TAPI v2.0
    DWORD       dwModuleFilenameSize;                           // TAPI v2.0
    DWORD       dwModuleFilenameOffset;                         // TAPI v2.0
    DWORD       dwFriendlyNameSize;                             // TAPI v2.0
    DWORD       dwFriendlyNameOffset;                           // TAPI v2.0
    DWORD       dwMediaModes;                                   // TAPI v2.0
    DWORD       dwAddressID;                                    // TAPI v2.0

} LINEAPPINFO, *LPLINEAPPINFO;
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
typedef struct lineagententry_tag
{
    HAGENT      hAgent;                                         // TAPI v2.2
    DWORD       dwNameSize;                                     // TAPI v2.2
    DWORD       dwNameOffset;                                   // TAPI v2.2
    DWORD       dwIDSize;                                       // TAPI v2.2
    DWORD       dwIDOffset;                                     // TAPI v2.2
    DWORD       dwPINSize;                                      // TAPI v2.2
    DWORD       dwPINOffset;                                    // TAPI v2.2

} LINEAGENTENTRY, *LPLINEAGENTENTRY;

typedef struct lineagentlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.2
    DWORD       dwNeededSize;                                   // TAPI v2.2
    DWORD       dwUsedSize;                                     // TAPI v2.2
    DWORD       dwNumEntries;                                   // TAPI v2.2
    DWORD       dwListSize;                                     // TAPI v2.2
    DWORD       dwListOffset;                                   // TAPI v2.2

} LINEAGENTLIST, *LPLINEAGENTLIST;

typedef struct lineagentinfo_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.2
    DWORD       dwNeededSize;                                   // TAPI v2.2
    DWORD       dwUsedSize;                                     // TAPI v2.2
    DWORD       dwAgentState;                                   // TAPI v2.2
    DWORD       dwNextAgentState;                               // TAPI v2.2
    DWORD       dwMeasurementPeriod;                            // TAPI v2.2
    CURRENCY    cyOverallCallRate;                              // TAPI v2.2
    DWORD       dwNumberOfACDCalls;                             // TAPI v2.2
    DWORD       dwNumberOfIncomingCalls;                        // TAPI v2.2
    DWORD       dwNumberOfOutgoingCalls;                        // TAPI v2.2
    DWORD       dwTotalACDTalkTime;                             // TAPI v2.2
    DWORD       dwTotalACDCallTime;                             // TAPI v2.2
    DWORD       dwTotalACDWrapUpTime;                           // TAPI v2.2

} LINEAGENTINFO, *LPLINEAGENTINFO;

typedef struct lineagentsession_tag
{
    HAGENTSESSION   hAgentSession;                              // TAPI v2.2
    HAGENT          hAgent;                                     // TAPI v2.2
    GUID            GroupID;                                    // TAPI v2.2
    DWORD           dwWorkingAddressID;                         // TAPI v2.2

} LINEAGENTSESSIONENTRY  , *LPLINEAGENTSESSIONENTRY;

typedef struct lineagentsessionlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.2
    DWORD       dwNeededSize;                                   // TAPI v2.2
    DWORD       dwUsedSize;                                     // TAPI v2.2
    DWORD       dwNumEntries;                                   // TAPI v2.2
    DWORD       dwListSize;                                     // TAPI v2.2
    DWORD       dwListOffset;                                   // TAPI v2.2

} LINEAGENTSESSIONLIST, *LPLINEAGENTSESSIONLIST;

typedef struct lineagentsessioninfo_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.2
    DWORD       dwNeededSize;                                   // TAPI v2.2
    DWORD       dwUsedSize;                                     // TAPI v2.2
    DWORD       dwAgentSessionState;                            // TAPI v2.2
    DWORD       dwNextAgentSessionState;                        // TAPI v2.2
    DATE        dateSessionStartTime;                           // TAPI v2.2
    DWORD       dwSessionDuration;                              // TAPI v2.2
    DWORD       dwNumberOfCalls;                                // TAPI v2.2
    DWORD       dwTotalTalkTime;                                // TAPI v2.2
    DWORD       dwAverageTalkTime;                              // TAPI v2.2
    DWORD       dwTotalCallTime;                                // TAPI v2.2
    DWORD       dwAverageCallTime;                              // TAPI v2.2
    DWORD       dwTotalWrapUpTime;                              // TAPI v2.2
    DWORD       dwAverageWrapUpTime;                            // TAPI v2.2
    CURRENCY    cyACDCallRate;                                  // TAPI v2.2
    DWORD       dwLongestTimeToAnswer;                          // TAPI v2.2
    DWORD       dwAverageTimeToAnswer;                          // TAPI v2.2

} LINEAGENTSESSIONINFO, *LPLINEAGENTSESSIONINFO;

typedef struct linequeueentry_tag
{
    DWORD       dwQueueID;                                      // TAPI v2.2
    DWORD       dwNameSize;                                     // TAPI v2.2
    DWORD       dwNameOffset;                                   // TAPI v2.2

} LINEQUEUEENTRY, *LPLINEQUEUEENTRY;

typedef struct linequeuelist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.2
    DWORD       dwNeededSize;                                   // TAPI v2.2
    DWORD       dwUsedSize;                                     // TAPI v2.2
    DWORD       dwNumEntries;                                   // TAPI v2.2
    DWORD       dwListSize;                                     // TAPI v2.2
    DWORD       dwListOffset;                                   // TAPI v2.2

} LINEQUEUELIST, *LPLINEQUEUELIST;

typedef struct linequeueinfo_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.2
    DWORD       dwNeededSize;                                   // TAPI v2.2
    DWORD       dwUsedSize;                                     // TAPI v2.2
    DWORD       dwMeasurementPeriod;                            // TAPI v2.2
    DWORD       dwTotalCallsQueued;                             // TAPI v2.2
    DWORD       dwCurrentCallsQueued;                           // TAPI v2.2
    DWORD       dwTotalCallsAbandoned;                          // TAPI v2.2
    DWORD       dwTotalCallsFlowedIn;                           // TAPI v2.2
    DWORD       dwTotalCallsFlowedOut;                          // TAPI v2.2
    DWORD       dwLongestEverWaitTime;                          // TAPI v2.2
    DWORD       dwCurrentLongestWaitTime;                       // TAPI v2.2
    DWORD       dwAverageWaitTime;                              // TAPI v2.2
    DWORD       dwFinalDisposition;                             // TAPI v2.2

} LINEQUEUEINFO, *LPLINEQUEUEINFO;

typedef struct lineproxyrequestlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.2
    DWORD       dwNeededSize;                                   // TAPI v2.2
    DWORD       dwUsedSize;                                     // TAPI v2.2
    DWORD       dwNumEntries;                                   // TAPI v2.2
    DWORD       dwListSize;                                     // TAPI v2.2
    DWORD       dwListOffset;                                   // TAPI v2.2

} LINEPROXYREQUESTLIST, *LPLINEPROXYREQUESTLIST;
#endif

#if (TAPI_CURRENT_VERSION >= 0x00030000)
typedef struct linecallhubtrackinginfo_tag
{
    DWORD       dwTotalSize;                                    // TAPI v3.0
    DWORD       dwNeededSize;                                   // TAPI v3.0
    DWORD       dwUsedSize;                                     // TAPI v3.0
    DWORD       dwAvailableTracking;                            // TAPI v3.0
    DWORD       dwCurrentTracking;                              // TAPI v3.0

} LINECALLHUBTRACKINGINFO, FAR *LPLINECALLHUBTRACKINGINFO;
#endif

typedef struct linedialparams_tag
{
    DWORD       dwDialPause;
    DWORD       dwDialSpeed;
    DWORD       dwDigitDuration;
    DWORD       dwWaitForDialtone;

} LINEDIALPARAMS, FAR *LPLINEDIALPARAMS;

typedef struct linecallinfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    HLINE       hLine;
    DWORD       dwLineDeviceID;
    DWORD       dwAddressID;
    DWORD       dwBearerMode;
    DWORD       dwRate;
    DWORD       dwMediaMode;
    DWORD       dwAppSpecific;
    DWORD       dwCallID;
    DWORD       dwRelatedCallID;
    DWORD       dwCallParamFlags;
    DWORD       dwCallStates;
    DWORD       dwMonitorDigitModes;
    DWORD       dwMonitorMediaModes;
    LINEDIALPARAMS  DialParams;
    DWORD       dwOrigin;
    DWORD       dwReason;
    DWORD       dwCompletionID;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwCountryCode;
    DWORD       dwTrunk;
    DWORD       dwCallerIDFlags;
    DWORD       dwCallerIDSize;
    DWORD       dwCallerIDOffset;
    DWORD       dwCallerIDNameSize;
    DWORD       dwCallerIDNameOffset;
    DWORD       dwCalledIDFlags;
    DWORD       dwCalledIDSize;
    DWORD       dwCalledIDOffset;
    DWORD       dwCalledIDNameSize;
    DWORD       dwCalledIDNameOffset;
    DWORD       dwConnectedIDFlags;
    DWORD       dwConnectedIDSize;
    DWORD       dwConnectedIDOffset;
    DWORD       dwConnectedIDNameSize;
    DWORD       dwConnectedIDNameOffset;
    DWORD       dwRedirectionIDFlags;
    DWORD       dwRedirectionIDSize;
    DWORD       dwRedirectionIDOffset;
    DWORD       dwRedirectionIDNameSize;
    DWORD       dwRedirectionIDNameOffset;
    DWORD       dwRedirectingIDFlags;
    DWORD       dwRedirectingIDSize;
    DWORD       dwRedirectingIDOffset;
    DWORD       dwRedirectingIDNameSize;
    DWORD       dwRedirectingIDNameOffset;
    DWORD       dwAppNameSize;
    DWORD       dwAppNameOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;
    DWORD       dwCommentOffset;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwUserUserInfoSize;
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;
    DWORD       dwLowLevelCompOffset;
    DWORD       dwChargingInfoSize;
    DWORD       dwChargingInfoOffset;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallTreatment;                                // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00030000)
    DWORD       dwCallerIDAddressType;                          // TAPI v3.0
    DWORD       dwCalledIDAddressType;                          // TAPI v3.0
    DWORD       dwConnectedIDAddressType;                       // TAPI v3.0
    DWORD       dwRedirectionIDAddressType;                     // TAPI v3.0
    DWORD       dwRedirectingIDAddressType;                     // TAPI v3.0
#endif

} LINECALLINFO, FAR *LPLINECALLINFO;

typedef struct linecalllist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallsNumEntries;
    DWORD       dwCallsSize;
    DWORD       dwCallsOffset;

} LINECALLLIST, FAR *LPLINECALLLIST;

typedef struct linecallparams_tag               // Defaults:
{
    DWORD       dwTotalSize;                    // ---------
    DWORD       dwBearerMode;                   // voice
    DWORD       dwMinRate;                      // (3.1kHz)
    DWORD       dwMaxRate;                      // (3.1kHz)
    DWORD       dwMediaMode;                    // interactiveVoice
    DWORD       dwCallParamFlags;               // 0
    DWORD       dwAddressMode;                  // addressID
    DWORD       dwAddressID;                    // (any available)
    LINEDIALPARAMS  DialParams;                 // (0, 0, 0, 0)
    DWORD       dwOrigAddressSize;              // 0
    DWORD       dwOrigAddressOffset;
    DWORD       dwDisplayableAddressSize;
    DWORD       dwDisplayableAddressOffset;
    DWORD       dwCalledPartySize;              // 0
    DWORD       dwCalledPartyOffset;
    DWORD       dwCommentSize;                  // 0
    DWORD       dwCommentOffset;
    DWORD       dwUserUserInfoSize;             // 0
    DWORD       dwUserUserInfoOffset;
    DWORD       dwHighLevelCompSize;            // 0
    DWORD       dwHighLevelCompOffset;
    DWORD       dwLowLevelCompSize;             // 0
    DWORD       dwLowLevelCompOffset;
    DWORD       dwDevSpecificSize;              // 0
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPredictiveAutoTransferStates;                 // TAPI v2.0
    DWORD       dwTargetAddressSize;                            // TAPI v2.0
    DWORD       dwTargetAddressOffset;                          // TAPI v2.0
    DWORD       dwSendingFlowspecSize;                          // TAPI v2.0
    DWORD       dwSendingFlowspecOffset;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecSize;                        // TAPI v2.0
    DWORD       dwReceivingFlowspecOffset;                      // TAPI v2.0
    DWORD       dwDeviceClassSize;                              // TAPI v2.0
    DWORD       dwDeviceClassOffset;                            // TAPI v2.0
    DWORD       dwDeviceConfigSize;                             // TAPI v2.0
    DWORD       dwDeviceConfigOffset;                           // TAPI v2.0
    DWORD       dwCallDataSize;                                 // TAPI v2.0
    DWORD       dwCallDataOffset;                               // TAPI v2.0
    DWORD       dwNoAnswerTimeout;                              // TAPI v2.0
    DWORD       dwCallingPartyIDSize;                           // TAPI v2.0
    DWORD       dwCallingPartyIDOffset;                         // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00030000)
    DWORD       dwAddressType;                                  // TAPI v3.0
#endif

} LINECALLPARAMS, FAR *LPLINECALLPARAMS;

typedef struct linecallstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwCallState;
    DWORD       dwCallStateMode;
    DWORD       dwCallPrivilege;
    DWORD       dwCallFeatures;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwCallFeatures2;                                // TAPI v2.0
#if WIN32
    SYSTEMTIME  tStateEntryTime;                                // TAPI v2.0
#else
    WORD        tStateEntryTime[8];                             // TAPI v2.0
#endif
#endif

} LINECALLSTATUS, FAR *LPLINECALLSTATUS;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linecalltreatmententry_tag
{
    DWORD       dwCallTreatmentID;                              // TAPI v2.0
    DWORD       dwCallTreatmentNameSize;                        // TAPI v2.0
    DWORD       dwCallTreatmentNameOffset;                      // TAPI v2.0

} LINECALLTREATMENTENTRY, FAR *LPLINECALLTREATMENTENTRY;
#endif

typedef struct linecardentry_tag
{
    DWORD       dwPermanentCardID;
    DWORD       dwCardNameSize;
    DWORD       dwCardNameOffset;
    DWORD       dwCardNumberDigits;                             // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4

} LINECARDENTRY, FAR *LPLINECARDENTRY;

typedef struct linecountryentry_tag
{
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwCountryCode;                                  // TAPI v1.4
    DWORD       dwNextCountryID;                                // TAPI v1.4
    DWORD       dwCountryNameSize;                              // TAPI v1.4
    DWORD       dwCountryNameOffset;                            // TAPI v1.4
    DWORD       dwSameAreaRuleSize;                             // TAPI v1.4
    DWORD       dwSameAreaRuleOffset;                           // TAPI v1.4
    DWORD       dwLongDistanceRuleSize;                         // TAPI v1.4
    DWORD       dwLongDistanceRuleOffset;                       // TAPI v1.4
    DWORD       dwInternationalRuleSize;                        // TAPI v1.4
    DWORD       dwInternationalRuleOffset;                      // TAPI v1.4

} LINECOUNTRYENTRY, FAR *LPLINECOUNTRYENTRY;

typedef struct linecountrylist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumCountries;                                 // TAPI v1.4
    DWORD       dwCountryListSize;                              // TAPI v1.4
    DWORD       dwCountryListOffset;                            // TAPI v1.4

} LINECOUNTRYLIST, FAR *LPLINECOUNTRYLIST;

typedef struct linedevcaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwSwitchInfoSize;
    DWORD       dwSwitchInfoOffset;
    DWORD       dwPermanentLineID;
    DWORD       dwLineNameSize;
    DWORD       dwLineNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwAddressModes;
    DWORD       dwNumAddresses;
    DWORD       dwBearerModes;
    DWORD       dwMaxRate;
    DWORD       dwMediaModes;
    DWORD       dwGenerateToneModes;
    DWORD       dwGenerateToneMaxNumFreq;
    DWORD       dwGenerateDigitModes;
    DWORD       dwMonitorToneMaxNumFreq;
    DWORD       dwMonitorToneMaxNumEntries;
    DWORD       dwMonitorDigitModes;
    DWORD       dwGatherDigitsMinTimeout;
    DWORD       dwGatherDigitsMaxTimeout;
    DWORD       dwMedCtlDigitMaxListSize;
    DWORD       dwMedCtlMediaMaxListSize;
    DWORD       dwMedCtlToneMaxListSize;
    DWORD       dwMedCtlCallStateMaxListSize;
    DWORD       dwDevCapFlags;
    DWORD       dwMaxNumActiveCalls;
    DWORD       dwAnswerMode;
    DWORD       dwRingModes;
    DWORD       dwLineStates;
    DWORD       dwUUIAcceptSize;
    DWORD       dwUUIAnswerSize;
    DWORD       dwUUIMakeCallSize;
    DWORD       dwUUIDropSize;
    DWORD       dwUUISendUserUserInfoSize;
    DWORD       dwUUICallInfoSize;
    LINEDIALPARAMS  MinDialParams;
    LINEDIALPARAMS  MaxDialParams;
    LINEDIALPARAMS  DefaultDialParams;
    DWORD       dwNumTerminals;
    DWORD       dwTerminalCapsSize;
    DWORD       dwTerminalCapsOffset;
    DWORD       dwTerminalTextEntrySize;
    DWORD       dwTerminalTextSize;
    DWORD       dwTerminalTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwLineFeatures;                                 // TAPI v1.4

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwSettableDevStatus;                            // TAPI v2.0
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
    GUID        PermanentLineGuid;                              // TAPI v2.2
#endif

#if (TAPI_CURRENT_VERSION >= 0x00030000)
    DWORD       dwAddressTypes;                                 // TAPI v3.0
    GUID        ProtocolGuid;                                   // TAPI v3.0
    DWORD       dwAvailableTracking;                            // TAPI v3.0
#endif

} LINEDEVCAPS, FAR *LPLINEDEVCAPS;

typedef struct linedevstatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumOpens;
    DWORD       dwOpenMediaModes;
    DWORD       dwNumActiveCalls;
    DWORD       dwNumOnHoldCalls;
    DWORD       dwNumOnHoldPendCalls;
    DWORD       dwLineFeatures;
    DWORD       dwNumCallCompletions;
    DWORD       dwRingMode;
    DWORD       dwSignalLevel;
    DWORD       dwBatteryLevel;
    DWORD       dwRoamMode;
    DWORD       dwDevStatusFlags;
    DWORD       dwTerminalModesSize;
    DWORD       dwTerminalModesOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwAvailableMediaModes;                          // TAPI v2.0
    DWORD       dwAppInfoSize;                                  // TAPI v2.0
    DWORD       dwAppInfoOffset;                                // TAPI v2.0
#endif

} LINEDEVSTATUS, FAR *LPLINEDEVSTATUS;

typedef struct lineextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} LINEEXTENSIONID, FAR *LPLINEEXTENSIONID;

typedef struct lineforward_tag
{
    DWORD       dwForwardMode;
    DWORD       dwCallerAddressSize;
    DWORD       dwCallerAddressOffset;
    DWORD       dwDestCountryCode;
    DWORD       dwDestAddressSize;
    DWORD       dwDestAddressOffset;

#if (TAPI_CURRENT_VERSION >= 0x00030001)
    DWORD       dwCallerAddressType;
    DWORD       dwDestAddressType;
#endif

} LINEFORWARD, FAR *LPLINEFORWARD;

typedef struct lineforwardlist_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNumEntries;
    LINEFORWARD ForwardList[1];

} LINEFORWARDLIST, FAR *LPLINEFORWARDLIST;

typedef struct linegeneratetone_tag
{
    DWORD       dwFrequency;
    DWORD       dwCadenceOn;
    DWORD       dwCadenceOff;
    DWORD       dwVolume;

} LINEGENERATETONE, FAR *LPLINEGENERATETONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} LINEINITIALIZEEXPARAMS, FAR *LPLINEINITIALIZEEXPARAMS;
#endif

typedef struct linelocationentry_tag
{
    DWORD       dwPermanentLocationID;
    DWORD       dwLocationNameSize;
    DWORD       dwLocationNameOffset;
    DWORD       dwCountryCode;
    DWORD       dwCityCodeSize;
    DWORD       dwCityCodeOffset;
    DWORD       dwPreferredCardID;

    DWORD       dwLocalAccessCodeSize;                          // TAPI v1.4
    DWORD       dwLocalAccessCodeOffset;                        // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeSize;                   // TAPI v1.4
    DWORD       dwLongDistanceAccessCodeOffset;                 // TAPI v1.4
    DWORD       dwTollPrefixListSize;                           // TAPI v1.4
    DWORD       dwTollPrefixListOffset;                         // TAPI v1.4
    DWORD       dwCountryID;                                    // TAPI v1.4
    DWORD       dwOptions;                                      // TAPI v1.4
    DWORD       dwCancelCallWaitingSize;                        // TAPI v1.4
    DWORD       dwCancelCallWaitingOffset;                      // TAPI v1.4

} LINELOCATIONENTRY, FAR *LPLINELOCATIONENTRY;

typedef struct linemediacontrolcallstate_tag
{
    DWORD       dwCallStates;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLCALLSTATE, FAR *LPLINEMEDIACONTROLCALLSTATE;

typedef struct linemediacontroldigit_tag
{
    DWORD       dwDigit;
    DWORD       dwDigitModes;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLDIGIT, FAR *LPLINEMEDIACONTROLDIGIT;

typedef struct linemediacontrolmedia_tag
{
    DWORD       dwMediaModes;
    DWORD       dwDuration;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLMEDIA, FAR *LPLINEMEDIACONTROLMEDIA;

typedef struct linemediacontroltone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;
    DWORD       dwMediaControl;

} LINEMEDIACONTROLTONE, FAR *LPLINEMEDIACONTROLTONE;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD_PTR   dwCallbackInstance;                             // TAPI v2.0
    DWORD_PTR   dwParam1;                                       // TAPI v2.0
    DWORD_PTR   dwParam2;                                       // TAPI v2.0
    DWORD_PTR   dwParam3;                                       // TAPI v2.0

} LINEMESSAGE, FAR *LPLINEMESSAGE;
#endif

typedef struct linemonitortone_tag
{
    DWORD       dwAppSpecific;
    DWORD       dwDuration;
    DWORD       dwFrequency1;
    DWORD       dwFrequency2;
    DWORD       dwFrequency3;

} LINEMONITORTONE, FAR *LPLINEMONITORTONE;

typedef struct lineproviderentry_tag
{
    DWORD       dwPermanentProviderID;                          // TAPI v1.4
    DWORD       dwProviderFilenameSize;                         // TAPI v1.4
    DWORD       dwProviderFilenameOffset;                       // TAPI v1.4

} LINEPROVIDERENTRY, FAR *LPLINEPROVIDERENTRY;

typedef struct lineproviderlist_tag
{
    DWORD       dwTotalSize;                                    // TAPI v1.4
    DWORD       dwNeededSize;                                   // TAPI v1.4
    DWORD       dwUsedSize;                                     // TAPI v1.4
    DWORD       dwNumProviders;                                 // TAPI v1.4
    DWORD       dwProviderListSize;                             // TAPI v1.4
    DWORD       dwProviderListOffset;                           // TAPI v1.4

} LINEPROVIDERLIST, FAR *LPLINEPROVIDERLIST;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct lineproxyrequest_tag
{
    DWORD       dwSize;                                         // TAPI v2.0
    DWORD       dwClientMachineNameSize;                        // TAPI v2.0
    DWORD       dwClientMachineNameOffset;                      // TAPI v2.0
    DWORD       dwClientUserNameSize;                           // TAPI v2.0
    DWORD       dwClientUserNameOffset;                         // TAPI v2.0
    DWORD       dwClientAppAPIVersion;                          // TAPI v2.0
    DWORD       dwRequestType;                                  // TAPI v2.0

    union
    {
    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } SetAgentGroup;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentState;                   // TAPI v2.0
        DWORD                   dwNextAgentState;               // TAPI v2.0

    } SetAgentState;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwActivityID;                   // TAPI v2.0

    } SetAgentActivity;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTCAPS           AgentCaps;                      // TAPI v2.0

    } GetAgentCaps;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTSTATUS         AgentStatus;                    // TAPI v2.0

    } GetAgentStatus;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        DWORD                   dwAgentExtensionIDIndex;        // TAPI v2.0
        DWORD                   dwSize;                         // TAPI v2.0
        BYTE                    Params[1];                      // TAPI v2.0

    } AgentSpecific;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTACTIVITYLIST   ActivityList;                   // TAPI v2.0

    } GetAgentActivityList;

    struct
    {
        DWORD                   dwAddressID;                    // TAPI v2.0
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.0

    } GetAgentGroupList;

#if (TAPI_CURRENT_VERSION >= 0x00020002)

    struct
    {
        HAGENT                  hAgent;                         // TAPI v2.2
        DWORD                   dwAgentIDSize;                  // TAPI v2.2
        DWORD                   dwAgentIDOffset;                // TAPI v2.2
        DWORD                   dwAgentPINSize;                 // TAPI v2.2
        DWORD                   dwAgentPINOffset;

    } CreateAgent;

    struct
    {
        HAGENT                  hAgent;                         // TAPI v2.2
        DWORD                   dwAgentState;                   // TAPI v2.2
        DWORD                   dwNextAgentState;               // TAPI v2.2

    } SetAgentStateEx;

    struct
    {
        HAGENT                  hAgent;                         // TAPI v2.2
        DWORD                   dwMeasurementPeriod;            // TAPI v2.2

    } SetAgentMeasurementPeriod;

    struct
    {
        HAGENT                  hAgent;                         // TAPI v2.2
        LINEAGENTINFO           AgentInfo;                      // TAPI v2.2

    } GetAgentInfo;

    struct
    {
        HAGENTSESSION           hAgentSession;                  // TAPI v2.2
        DWORD                   dwAgentPINSize;
        DWORD                   dwAgentPINOffset;
        HAGENT                  hAgent;                         // TAPI v2.2
        GUID                    GroupID;                        // TAPI v2.2
        DWORD                   dwWorkingAddressID;             // TAPI v2.2

    } CreateAgentSession;

    struct
    {
        HAGENT                  hAgent;                         // TAPI v2.2
        LINEAGENTSESSIONLIST    SessionList;                    // TAPI v2.2

    } GetAgentSessionList;

    struct
    {
        HAGENTSESSION           hAgentSession;                  // TAPI v2.2
        LINEAGENTSESSIONINFO    SessionInfo;                    // TAPI v2.2

    } GetAgentSessionInfo;

    struct
    {
        HAGENTSESSION           hAgentSession;                  // TAPI v2.2
        DWORD                   dwAgentSessionState;            // TAPI v2.2
        DWORD                   dwNextAgentSessionState;        // TAPI v2.2

    } SetAgentSessionState;

    struct
    {
        GUID                    GroupID;                        // TAPI v2.2
        LINEQUEUELIST           QueueList;                      // TAPI v2.2

    } GetQueueList;

    struct
    {
        DWORD                   dwQueueID;                      // TAPI v2.2
        DWORD                   dwMeasurementPeriod;            // TAPI v2.2

    } SetQueueMeasurementPeriod;


    struct
    {
        DWORD                   dwQueueID;                      // TAPI v2.2
        LINEQUEUEINFO           QueueInfo;                      // TAPI v2.2

    } GetQueueInfo;

    struct
    {
        LINEAGENTGROUPLIST      GroupList;                      // TAPI v2.2

    } GetGroupList;

#endif

    }; //ProxyRequestType;


} LINEPROXYREQUEST, *LPLINEPROXYREQUEST;
#endif

typedef struct linereqmakecall_tag
{
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALL, FAR *LPLINEREQMAKECALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmakecallW_tag
{
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMAKECALLW, FAR *LPLINEREQMAKECALLW;
#endif

#ifdef UNICODE
#define LINEREQMAKECALL LINEREQMAKECALLW
#endif

typedef struct linereqmediacall_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    char        szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    char        szDestAddress[TAPIMAXDESTADDRESSSIZE];
    char        szAppName[TAPIMAXAPPNAMESIZE];
    char        szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    char        szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALL, FAR *LPLINEREQMEDIACALL;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct linereqmediacallW_tag
{
    HWND        hWnd;
    WPARAM      wRequestID;
    WCHAR       szDeviceClass[TAPIMAXDEVICECLASSSIZE];
    unsigned char   ucDeviceID[TAPIMAXDEVICEIDSIZE];
    DWORD       dwSize;
    DWORD       dwSecure;
    WCHAR       szDestAddress[TAPIMAXDESTADDRESSSIZE];
    WCHAR       szAppName[TAPIMAXAPPNAMESIZE];
    WCHAR       szCalledParty[TAPIMAXCALLEDPARTYSIZE];
    WCHAR       szComment[TAPIMAXCOMMENTSIZE];

} LINEREQMEDIACALLW, FAR *LPLINEREQMEDIACALLW;
#endif

#ifdef UNICODE
#define LINEREQMEDIACALL LINEREQMEDIACALLW
#endif

typedef struct linetermcaps_tag
{
    DWORD       dwTermDev;
    DWORD       dwTermModes;
    DWORD       dwTermSharing;

} LINETERMCAPS, FAR *LPLINETERMCAPS;

typedef struct linetranslatecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwNumLocations;
    DWORD       dwLocationListSize;
    DWORD       dwLocationListOffset;
    DWORD       dwCurrentLocationID;
    DWORD       dwNumCards;
    DWORD       dwCardListSize;
    DWORD       dwCardListOffset;
    DWORD       dwCurrentPreferredCardID;

} LINETRANSLATECAPS, FAR *LPLINETRANSLATECAPS;

typedef struct linetranslateoutput_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwDialableStringSize;
    DWORD       dwDialableStringOffset;
    DWORD       dwDisplayableStringSize;
    DWORD       dwDisplayableStringOffset;
    DWORD       dwCurrentCountry;
    DWORD       dwDestCountry;
    DWORD       dwTranslateResults;

} LINETRANSLATEOUTPUT, FAR *LPLINETRANSLATEOUTPUT;

typedef struct phonebuttoninfo_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwButtonMode;
    DWORD       dwButtonFunction;
    DWORD       dwButtonTextSize;
    DWORD       dwButtonTextOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

    DWORD       dwButtonState;                                  // TAPI v1.4

} PHONEBUTTONINFO, FAR *LPPHONEBUTTONINFO;

typedef struct phonecaps_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwProviderInfoSize;
    DWORD       dwProviderInfoOffset;
    DWORD       dwPhoneInfoSize;
    DWORD       dwPhoneInfoOffset;
    DWORD       dwPermanentPhoneID;
    DWORD       dwPhoneNameSize;
    DWORD       dwPhoneNameOffset;
    DWORD       dwStringFormat;
    DWORD       dwPhoneStates;
    DWORD       dwHookSwitchDevs;
    DWORD       dwHandsetHookSwitchModes;
    DWORD       dwSpeakerHookSwitchModes;
    DWORD       dwHeadsetHookSwitchModes;
    DWORD       dwVolumeFlags;
    DWORD       dwGainFlags;
    DWORD       dwDisplayNumRows;
    DWORD       dwDisplayNumColumns;
    DWORD       dwNumRingModes;
    DWORD       dwNumButtonLamps;
    DWORD       dwButtonModesSize;
    DWORD       dwButtonModesOffset;
    DWORD       dwButtonFunctionsSize;
    DWORD       dwButtonFunctionsOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwNumSetData;
    DWORD       dwSetDataSize;
    DWORD       dwSetDataOffset;
    DWORD       dwNumGetData;
    DWORD       dwGetDataSize;
    DWORD       dwGetDataOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwDeviceClassesSize;                            // TAPI v2.0
    DWORD       dwDeviceClassesOffset;                          // TAPI v2.0
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
    DWORD       dwSettableHandsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableSpeakerHookSwitchModes;               // TAPI v2.0
    DWORD       dwSettableHeadsetHookSwitchModes;               // TAPI v2.0
    DWORD       dwMonitoredHandsetHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredSpeakerHookSwitchModes;              // TAPI v2.0
    DWORD       dwMonitoredHeadsetHookSwitchModes;              // TAPI v2.0
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
    GUID        PermanentPhoneGuid;                             // TAPI v2.2
#endif

} PHONECAPS, FAR *LPPHONECAPS;

typedef struct phoneextensionid_tag
{
    DWORD       dwExtensionID0;
    DWORD       dwExtensionID1;
    DWORD       dwExtensionID2;
    DWORD       dwExtensionID3;

} PHONEEXTENSIONID, FAR *LPPHONEEXTENSIONID;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
typedef struct phoneinitializeexparams_tag
{
    DWORD       dwTotalSize;                                    // TAPI v2.0
    DWORD       dwNeededSize;                                   // TAPI v2.0
    DWORD       dwUsedSize;                                     // TAPI v2.0
    DWORD       dwOptions;                                      // TAPI v2.0

    union
    {
        HANDLE  hEvent;                                         // TAPI v2.0
        HANDLE  hCompletionPort;                                // TAPI v2.0

    } Handles;

    DWORD       dwCompletionKey;                                // TAPI v2.0

} PHONEINITIALIZEEXPARAMS, FAR *LPPHONEINITIALIZEEXPARAMS;

typedef struct phonemessage_tag
{
    DWORD       hDevice;                                        // TAPI v2.0
    DWORD       dwMessageID;                                    // TAPI v2.0
    DWORD_PTR   dwCallbackInstance;                             // TAPI v2.0
    DWORD_PTR   dwParam1;                                       // TAPI v2.0
    DWORD_PTR   dwParam2;                                       // TAPI v2.0
    DWORD_PTR   dwParam3;                                       // TAPI v2.0

} PHONEMESSAGE, FAR *LPPHONEMESSAGE;
#endif

typedef struct phonestatus_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStatusFlags;
    DWORD       dwNumOwners;
    DWORD       dwNumMonitors;
    DWORD       dwRingMode;
    DWORD       dwRingVolume;
    DWORD       dwHandsetHookSwitchMode;
    DWORD       dwHandsetVolume;
    DWORD       dwHandsetGain;
    DWORD       dwSpeakerHookSwitchMode;
    DWORD       dwSpeakerVolume;
    DWORD       dwSpeakerGain;
    DWORD       dwHeadsetHookSwitchMode;
    DWORD       dwHeadsetVolume;
    DWORD       dwHeadsetGain;
    DWORD       dwDisplaySize;
    DWORD       dwDisplayOffset;
    DWORD       dwLampModesSize;
    DWORD       dwLampModesOffset;
    DWORD       dwOwnerNameSize;
    DWORD       dwOwnerNameOffset;
    DWORD       dwDevSpecificSize;
    DWORD       dwDevSpecificOffset;

#if (TAPI_CURRENT_VERSION >= 0x00020000)
    DWORD       dwPhoneFeatures;                                // TAPI v2.0
#endif

} PHONESTATUS, FAR *LPPHONESTATUS;

typedef struct varstring_tag
{
    DWORD       dwTotalSize;
    DWORD       dwNeededSize;
    DWORD       dwUsedSize;
    DWORD       dwStringFormat;
    DWORD       dwStringSize;
    DWORD       dwStringOffset;

} VARSTRING, FAR *LPVARSTRING;



LONG
WINAPI
lineAccept(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineAddProvider(                                                // TAPI v1.4
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#if WIN32
LONG
WINAPI
lineAddProviderA(                                               // TAPI v1.4
    LPCSTR              lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

LONG
WINAPI
lineAddProviderW(
    LPCWSTR             lpszProviderFilename,
    HWND                hwndOwner,
    LPDWORD             lpdwPermanentProviderID
    );

#ifdef UNICODE
#define lineAddProvider lineAddProviderW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineAddProvider lineAddProviderA
#endif
#endif

#endif


LONG
WINAPI
lineAddToConference(
    HCALL               hConfCall,
    HCALL               hConsultCall
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineAgentSpecific(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentExtensionIDIndex,
    LPVOID              lpParams,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineAnswer(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineBlindTransfer(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineBlindTransferA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
WINAPI
lineBlindTransferW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddressW,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineBlindTransfer lineBlindTransferW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineBlindTransfer lineBlindTransferA
#endif
#endif
#endif

LONG
WINAPI
lineClose(
    HLINE               hLine
    );

LONG
WINAPI
lineCompleteCall(
    HCALL               hCall,
    LPDWORD             lpdwCompletionID,
    DWORD               dwCompletionMode,
    DWORD               dwMessageID
    );

LONG
WINAPI
lineCompleteTransfer(
    HCALL               hCall,
    HCALL               hConsultCall,
    LPHCALL             lphConfCall,
    DWORD               dwTransferMode
    );

LONG
WINAPI
lineConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineConfigDialogA(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

LONG
WINAPI
lineConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineConfigDialog lineConfigDialogW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineConfigDialog lineConfigDialogA
#endif
#endif
#endif

LONG
WINAPI
lineConfigDialogEdit(                                           // TAPI v1.4
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#if WIN32
LONG
WINAPI
lineConfigDialogEditA(                                          // TAPI v1.4
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

LONG
WINAPI
lineConfigDialogEditW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass,
    LPVOID              const lpDeviceConfigIn,
    DWORD               dwSize,
    LPVARSTRING         lpDeviceConfigOut
    );

#ifdef UNICODE
#define lineConfigDialogEdit lineConfigDialogEditW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineConfigDialogEdit lineConfigDialogEditA
#endif
#endif
#endif

LONG
WINAPI
lineConfigProvider(                                             // TAPI v1.4
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    );

#if (TAPI_CURRENT_VERSION >= 0x00020002)
LONG
WINAPI
lineCreateAgentW(                                               // TAPI v2.2
    HLINE               hLine,
    __in_opt LPCWSTR              lpszAgentID,
    __in_opt LPCWSTR              lpszAgentPIN,
    LPHAGENT            lphAgent
    );

LONG
WINAPI
lineCreateAgentA(                                               // TAPI v2.2
    HLINE               hLine,
    __in_opt LPCSTR     lpszAgentID,
    __in_opt LPCSTR     lpszAgentPIN,
    LPHAGENT            lphAgent
    );

#ifdef UNICODE
#define lineCreateAgent lineCreateAgentW
#else
#define lineCreateAgent lineCreateAgentA
#endif

LONG
WINAPI
lineCreateAgentSessionW(                                        // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    __in_opt LPCWSTR    lpszAgentPIN,
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    LPHAGENTSESSION     lphAgentSession
    );

LONG
WINAPI
lineCreateAgentSessionA(                                        // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    __in_opt LPCSTR     lpszAgentPIN,
    DWORD               dwWorkingAddressID,
    LPGUID              lpGroupID,
    LPHAGENTSESSION     lphAgentSession
    );

#ifdef UNICODE
#define lineCreateAgentSession lineCreateAgentSessionW
#else
#define lineCreateAgentSession lineCreateAgentSessionA
#endif
#endif

LONG
WINAPI
lineDeallocateCall(
    HCALL               hCall
    );

LONG
WINAPI
lineDevSpecific(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDevSpecificFeature(
    HLINE               hLine,
    DWORD               dwFeature,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
lineDial(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineDialA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
WINAPI
lineDialW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineDial lineDialW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineDial lineDialA
#endif
#endif
#endif

LONG
WINAPI
lineDrop(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

LONG
WINAPI
lineForward(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineForwardA(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
lineForwardW(
    HLINE               hLine,
    DWORD               bAllAddresses,
    DWORD               dwAddressID,
    LPLINEFORWARDLIST   const lpForwardList,
    DWORD               dwNumRingsNoAnswer,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineForward lineForwardW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineForward lineForwardA
#endif
#endif
#endif

LONG
WINAPI
lineGatherDigits(
    HCALL               hCall,
    DWORD               dwDigitModes,
    __out_ecount_opt(dwNumDigits)
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#if WIN32
LONG
WINAPI
lineGatherDigitsA(
    HCALL               hCall,
    DWORD               dwDigitModes,
    __out_ecount_opt(dwNumDigits)
    LPSTR               lpsDigits,
    DWORD               dwNumDigits,
    LPCSTR              lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

LONG
WINAPI
lineGatherDigitsW(
    HCALL               hCall,
    DWORD               dwDigitModes,
    __out_ecount_opt(dwNumDigits)
    LPWSTR              lpsDigits,
    DWORD               dwNumDigits,
    LPCWSTR             lpszTerminationDigits,
    DWORD               dwFirstDigitTimeout,
    DWORD               dwInterDigitTimeout
    );

#ifdef UNICODE
#define lineGatherDigits lineGatherDigitsW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGatherDigits lineGatherDigitsA
#endif
#endif
#endif

LONG
WINAPI
lineGenerateDigits(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    );

#if WIN32
LONG
WINAPI
lineGenerateDigitsA(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCSTR              lpszDigits,
    DWORD               dwDuration
    );

LONG
WINAPI
lineGenerateDigitsW(
    HCALL               hCall,
    DWORD               dwDigitMode,
    LPCWSTR             lpszDigits,
    DWORD               dwDuration
    );

#ifdef UNICODE
#define lineGenerateDigits lineGenerateDigitsW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGenerateDigits lineGenerateDigitsA
#endif
#endif
#endif

LONG
WINAPI
lineGenerateTone(
    HCALL               hCall,
    DWORD               dwToneMode,
    DWORD               dwDuration,
    DWORD               dwNumTones,
    LPLINEGENERATETONE  const lpTones
    );

LONG
WINAPI
lineGetAddressCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#if WIN32
LONG
WINAPI
lineGetAddressCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

LONG
WINAPI
lineGetAddressCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEADDRESSCAPS   lpAddressCaps
    );

#ifdef UNICODE
#define lineGetAddressCaps lineGetAddressCapsW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetAddressCaps lineGetAddressCapsA
#endif
#endif
#endif

LONG
WINAPI
lineGetAddressID(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    );

#if WIN32
LONG
WINAPI
lineGetAddressIDA(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCSTR              lpsAddress,
    DWORD               dwSize
    );

LONG
WINAPI
lineGetAddressIDW(
    HLINE               hLine,
    LPDWORD             lpdwAddressID,
    DWORD               dwAddressMode,
    LPCWSTR             lpsAddress,
    DWORD               dwSize
    );

#ifdef UNICODE
#define lineGetAddressID lineGetAddressIDW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetAddressID lineGetAddressIDA
#endif
#endif
#endif

LONG
WINAPI
lineGetAddressStatus(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#if WIN32
LONG
WINAPI
lineGetAddressStatusA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

LONG
WINAPI
lineGetAddressStatusW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
    );

#ifdef UNICODE
#define lineGetAddressStatus lineGetAddressStatusW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetAddressStatus lineGetAddressStatusA
#endif
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetAgentActivityListA(                                      // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

LONG
WINAPI
lineGetAgentActivityListW(                                      // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTACTIVITYLIST lpAgentActivityList
    );

#ifdef UNICODE
#define lineGetAgentActivityList lineGetAgentActivityListW
#else
#define lineGetAgentActivityList lineGetAgentActivityListA
#endif


LONG
WINAPI
lineGetAgentCapsA(                                              // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    );

LONG
WINAPI
lineGetAgentCapsW(                                              // TAPI v2.0
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAddressID,
    DWORD               dwAppAPIVersion,
    LPLINEAGENTCAPS     lpAgentCaps
    );

#ifdef UNICODE
#define lineGetAgentCaps lineGetAgentCapsW
#else
#define lineGetAgentCaps lineGetAgentCapsA
#endif


LONG
WINAPI
lineGetAgentGroupListA(                                         // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

LONG
WINAPI
lineGetAgentGroupListW(                                         // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

#ifdef UNICODE
#define lineGetAgentGroupList lineGetAgentGroupListW
#else
#define lineGetAgentGroupList lineGetAgentGroupListA
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
LONG
WINAPI
lineGetAgentInfo(                                               // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    LPLINEAGENTINFO     lpAgentInfo
    );

LONG
WINAPI
lineGetAgentSessionInfo(                                        // TAPI v2.2
    HLINE                   hLine,
    HAGENTSESSION           hAgentSession,
    LPLINEAGENTSESSIONINFO  lpAgentSessionInfo
    );

LONG
WINAPI
lineGetAgentSessionList(                                        // TAPI v2.2
    HLINE                   hLine,
    HAGENT                  hAgent,
    LPLINEAGENTSESSIONLIST  lpAgentSessionList
    );
#endif

LONG
WINAPI
lineGetAgentStatusA(                                            // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    );

LONG
WINAPI
lineGetAgentStatusW(                                            // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    LPLINEAGENTSTATUS   lpAgentStatus
    );

#ifdef UNICODE
#define lineGetAgentStatus lineGetAgentStatusW
#else
#define lineGetAgentStatus lineGetAgentStatusA
#endif
#endif

LONG
WINAPI
lineGetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#if WIN32
LONG
WINAPI
lineGetAppPriorityA(                                            // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

LONG
WINAPI
lineGetAppPriorityW(                                            // TAPI v1.4
    LPCWSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPVARSTRING         lpExtensionName,
    LPDWORD             lpdwPriority
    );

#ifdef UNICODE
#define lineGetAppPriority lineGetAppPriorityW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetAppPriority lineGetAppPriorityA
#endif
#endif
#endif

LONG
WINAPI
lineGetCallInfo(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#if WIN32
LONG
WINAPI
lineGetCallInfoA(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

LONG
WINAPI
lineGetCallInfoW(
    HCALL               hCall,
    LPLINECALLINFO      lpCallInfo
    );

#ifdef UNICODE
#define lineGetCallInfo lineGetCallInfoW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetCallInfo lineGetCallInfoA
#endif
#endif
#endif

LONG
WINAPI
lineGetCallStatus(
    HCALL               hCall,
    LPLINECALLSTATUS    lpCallStatus
    );

LONG
WINAPI
lineGetConfRelatedCalls(
    HCALL               hCall,
    LPLINECALLLIST      lpCallList
    );

LONG
WINAPI
lineGetCountry(                                                 // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#if WIN32
LONG
WINAPI
lineGetCountryA(                                                // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

LONG
WINAPI
lineGetCountryW(                                                // TAPI v1.4
    DWORD               dwCountryID,
    DWORD               dwAPIVersion,
    LPLINECOUNTRYLIST   lpLineCountryList
    );

#ifdef UNICODE
#define lineGetCountry lineGetCountryW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetCountry lineGetCountryA
#endif
#endif
#endif

LONG
WINAPI
lineGetDevCaps(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#if WIN32
LONG
WINAPI
lineGetDevCapsA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

LONG
WINAPI
lineGetDevCapsW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

#ifdef UNICODE
#define lineGetDevCaps lineGetDevCapsW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetDevCaps lineGetDevCapsA
#endif
#endif
#endif

LONG
WINAPI
lineGetDevConfig(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetDevConfigA(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCSTR              lpszDeviceClass
    );

LONG
WINAPI
lineGetDevConfigW(
    DWORD               dwDeviceID,
    LPVARSTRING         lpDeviceConfig,
    LPCWSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineGetDevConfig lineGetDevConfigW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetDevConfig lineGetDevConfigA
#endif
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
LONG
WINAPI
lineGetGroupListA(                                              // TAPI v2.2
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    );

LONG
WINAPI
lineGetGroupListW(                                              // TAPI v2.2
    HLINE                   hLine,
    LPLINEAGENTGROUPLIST    lpGroupList
    );

#ifdef UNICODE
#define lineGetGroupList lineGetGroupListW
#else
#define lineGetGroupList lineGetGroupListA
#endif
#endif

LONG
WINAPI
lineGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
lineGetIconA(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

LONG
WINAPI
lineGetIconW(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef UNICODE
#define lineGetIcon lineGetIconW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetIcon lineGetIconA
#endif
#endif
#endif

LONG
WINAPI
lineGetID(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineGetIDA(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

LONG
WINAPI
lineGetIDW(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineGetID lineGetIDW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetID lineGetIDA
#endif
#endif
#endif

LONG
WINAPI
lineGetLineDevStatus(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#if WIN32
LONG
WINAPI
lineGetLineDevStatusA(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

LONG
WINAPI
lineGetLineDevStatusW(
    HLINE               hLine,
    LPLINEDEVSTATUS     lpLineDevStatus
    );

#ifdef UNICODE
#define lineGetDevStatus lineGetDevStatusW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetDevStatus lineGetDevStatusA
#endif
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineGetMessage(                                                 // TAPI v2.0
    HLINEAPP        hLineApp,
    LPLINEMESSAGE   lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
lineGetNewCalls(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwSelect,
    LPLINECALLLIST      lpCallList
    );

LONG
WINAPI
lineGetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPDWORD             lpdwNumRings
    );

LONG
WINAPI
lineGetProviderList(                                            // TAPI v1.4
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#if WIN32
LONG
WINAPI
lineGetProviderListA(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

LONG
WINAPI
lineGetProviderListW(
    DWORD               dwAPIVersion,
    LPLINEPROVIDERLIST  lpProviderList
    );

#ifdef UNICODE
#define lineGetProviderList lineGetProviderListW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetProviderList lineGetProviderListA
#endif
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020002)
LONG
WINAPI
lineGetProxyStatus(                                             // TAPI v2.2
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAppAPIVersion,
    LPLINEPROXYREQUESTLIST  lpLineProxyReqestList
    );

LONG
WINAPI
lineGetQueueInfo(                                               // TAPI v2.2
    HLINE               hLine,
    DWORD               dwQueueID,
    LPLINEQUEUEINFO     lpLineQueueInfo
    );

LONG
WINAPI
lineGetQueueListA(                                              // TAPI v2.2
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    );

LONG
WINAPI
lineGetQueueListW(                                              // TAPI v2.2
    HLINE               hLine,
    LPGUID              lpGroupID,
    LPLINEQUEUELIST     lpQueueList
    );

#ifdef UNICODE
#define lineGetQueueList lineGetQueueListW
#else
#define lineGetQueueList lineGetQueueListA
#endif
#endif

LONG
WINAPI
lineGetRequest(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#if WIN32
LONG
WINAPI
lineGetRequestA(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

LONG
WINAPI
lineGetRequestW(
    HLINEAPP            hLineApp,
    DWORD               dwRequestMode,
    LPVOID              lpRequestBuffer
    );

#ifdef UNICODE
#define lineGetRequest lineGetRequestW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetRequest lineGetRequestA
#endif
#endif
#endif

LONG
WINAPI
lineGetStatusMessages(
    HLINE               hLine,
    LPDWORD             lpdwLineStates,
    LPDWORD             lpdwAddressStates
    );

LONG
WINAPI
lineGetTranslateCaps(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#if WIN32
LONG
WINAPI
lineGetTranslateCapsA(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

LONG
WINAPI
lineGetTranslateCapsW(
    HLINEAPP hLineApp,
    DWORD dwAPIVersion,
    LPLINETRANSLATECAPS lpTranslateCaps
    );

#ifdef UNICODE
#define lineGetTranslateCaps lineGetTranslateCapsW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineGetTranslateCaps lineGetTranslateCapsA
#endif
#endif
#endif

LONG
WINAPI
lineHandoff(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    );

#if WIN32
LONG
WINAPI
lineHandoffA(
    HCALL               hCall,
    LPCSTR              lpszFileName,
    DWORD               dwMediaMode
    );

LONG
WINAPI
lineHandoffW(
    HCALL               hCall,
    LPCWSTR             lpszFileName,
    DWORD               dwMediaMode
    );

#ifdef UNICODE
#define lineHandoff lineHandoffW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineHandoff lineHandoffA
#endif
#endif
#endif

LONG
WINAPI
lineHold(
    HCALL               hCall
    );

LONG
WINAPI
lineInitialize(
    LPHLINEAPP          lphLineApp,
    HINSTANCE           hInstance,
    LINECALLBACK        lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineInitializeExA(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

LONG
WINAPI
lineInitializeExW(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

#ifdef UNICODE
#define lineInitializeEx lineInitializeExW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineInitializeEx lineInitializeExA
#endif
#endif
#endif

LONG
WINAPI
lineMakeCall(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineMakeCallA(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
lineMakeCallW(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineMakeCall lineMakeCallW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineMakeCall lineMakeCallA
#endif
#endif
#endif

LONG
WINAPI
lineMonitorDigits(
    HCALL               hCall,
    DWORD               dwDigitModes
    );

LONG
WINAPI
lineMonitorMedia(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

LONG
WINAPI
lineMonitorTones(
    HCALL               hCall,
    LPLINEMONITORTONE   const lpToneList,
    DWORD               dwNumEntries
    );

LONG
WINAPI
lineNegotiateAPIVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPLINEEXTENSIONID   lpExtensionID
    );

LONG
WINAPI
lineNegotiateExtVersion(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
lineOpen(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineOpenA(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
lineOpenW(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineOpen lineOpenW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineOpen lineOpenA
#endif
#endif
#endif

LONG
WINAPI
linePark(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#if WIN32
LONG
WINAPI
lineParkA(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCSTR              lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

LONG
WINAPI
lineParkW(
    HCALL               hCall,
    DWORD               dwParkMode,
    LPCWSTR             lpszDirAddress,
    LPVARSTRING         lpNonDirAddress
    );

#ifdef UNICODE
#define linePark lineParkW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define linePark lineParkA
#endif
#endif
#endif

LONG
WINAPI
linePickup(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    );

#if WIN32
LONG
WINAPI
linePickupA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszGroupID
    );

LONG
WINAPI
linePickupW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszGroupID
    );

#ifdef UNICODE
#define linePickup linePickupW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define linePickup linePickupA
#endif
#endif
#endif

LONG
WINAPI
linePrepareAddToConference(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
linePrepareAddToConferenceA(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
linePrepareAddToConferenceW(
    HCALL               hConfCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define linePrepareAddToConference linePrepareAddToConferenceW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define linePrepareAddToConference linePrepareAddToConferenceA
#endif
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineProxyMessage(                                               // TAPI v2.0
    HLINE               hLine,
    HCALL               hCall,
    DWORD               dwMsg,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwParam3
    );

LONG
WINAPI
lineProxyResponse(                                              // TAPI v2.0
    HLINE               hLine,
    LPLINEPROXYREQUEST  lpProxyRequest,
    DWORD               dwResult
    );
#endif

LONG
WINAPI
lineRedirect(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

#if WIN32
LONG
WINAPI
lineRedirectA(
    HCALL               hCall,
    LPCSTR              lpszDestAddress,
    DWORD               dwCountryCode
    );

LONG
WINAPI
lineRedirectW(
    HCALL               hCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode
    );

#ifdef UNICODE
#define lineRedirect lineRedirectW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineRedirect lineRedirectA
#endif
#endif
#endif

LONG
WINAPI
lineRegisterRequestRecipient(
    HLINEAPP            hLineApp,
    DWORD               dwRegistrationInstance,
    DWORD               dwRequestMode,
    DWORD               bEnable
    );

LONG
WINAPI
lineReleaseUserUserInfo(                                        // TAPI v1.4
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveFromConference(
    HCALL               hCall
    );

LONG
WINAPI
lineRemoveProvider(                                             // TAPI v1.4
    DWORD               dwPermanentProviderID,
    HWND                hwndOwner
    );

LONG
WINAPI
lineSecureCall(
    HCALL               hCall
    );

LONG
WINAPI
lineSendUserUserInfo(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetAgentActivity(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwActivityID
    );

LONG
WINAPI
lineSetAgentGroup(                                              // TAPI v2.0
    HLINE                   hLine,
    DWORD                   dwAddressID,
    LPLINEAGENTGROUPLIST    lpAgentGroupList
    );

#if (TAPI_CURRENT_VERSION >= 0x00020002)
LONG
WINAPI
lineSetAgentMeasurementPeriod(                                  // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwMeasurementPeriod
    );

LONG
WINAPI
lineSetAgentSessionState(                                       // TAPI v2.2
    HLINE               hLine,
    HAGENTSESSION       hAgentSession,
    DWORD               dwAgentSessionState,
    DWORD               dwNextAgentSessionState
    );

LONG
WINAPI
lineSetAgentStateEx(                                            // TAPI v2.2
    HLINE               hLine,
    HAGENT              hAgent,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    );
#endif

LONG
WINAPI
lineSetAgentState(                                              // TAPI v2.0
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwAgentState,
    DWORD               dwNextAgentState
    );
#endif

LONG
WINAPI
lineSetAppPriority(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    );

#if WIN32
LONG
WINAPI
lineSetAppPriorityA(                                             // TAPI v1.4
    LPCSTR              lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCSTR              lpszExtensionName,
    DWORD               dwPriority
    );

LONG
WINAPI
lineSetAppPriorityW(                                             // TAPI v1.4
    LPCWSTR             lpszAppFilename,
    DWORD               dwMediaMode,
    LPLINEEXTENSIONID   lpExtensionID,
    DWORD               dwRequestMode,
    LPCWSTR             lpszExtensionName,
    DWORD               dwPriority
    );

#ifdef UNICODE
#define lineSetAppPriority lineSetAppPriorityW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineSetAppPriority lineSetAppPriorityA
#endif
#endif
#endif

LONG
WINAPI
lineSetAppSpecific(
    HCALL               hCall,
    DWORD               dwAppSpecific
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallData(                                                // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpCallData,
    DWORD               dwSize
    );
#endif

LONG
WINAPI
lineSetCallParams(
    HCALL               hCall,
    DWORD               dwBearerMode,
    DWORD               dwMinRate,
    DWORD               dwMaxRate,
    LPLINEDIALPARAMS    const lpDialParams
    );

LONG
WINAPI
lineSetCallPrivilege(
    HCALL               hCall,
    DWORD               dwCallPrivilege
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetCallQualityOfService(                                    // TAPI v2.0
    HCALL               hCall,
    LPVOID              lpSendingFlowspec,
    DWORD               dwSendingFlowspecSize,
    LPVOID              lpReceivingFlowspec,
    DWORD               dwReceivingFlowspecSize
    );

LONG
WINAPI
lineSetCallTreatment(                                           // TAPI v2.0
    HCALL               hCall,
    DWORD               dwTreatment
    );
#endif

LONG
WINAPI
lineSetCurrentLocation(
    HLINEAPP            hLineApp,
    DWORD               dwLocation
    );

LONG
WINAPI
lineSetDevConfig(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
lineSetDevConfigA(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCSTR              lpszDeviceClass
    );

LONG
WINAPI
lineSetDevConfigW(
    DWORD               dwDeviceID,
    LPVOID              const lpDeviceConfig,
    DWORD               dwSize,
    LPCWSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define lineSetDevConfig lineSetDevConfigW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineSetDevConfig lineSetDevConfigA
#endif
#endif
#endif

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
lineSetLineDevStatus(                                           // TAPI v2.0
    HLINE               hLine,
    DWORD               dwStatusToChange,
    DWORD               fStatus
    );
#endif

LONG
WINAPI
lineSetMediaControl(
    HLINE                       hLine,
    DWORD                       dwAddressID,
    HCALL                       hCall,
    DWORD                       dwSelect,
    LPLINEMEDIACONTROLDIGIT     const lpDigitList,
    DWORD                       dwDigitNumEntries,
    LPLINEMEDIACONTROLMEDIA     const lpMediaList,
    DWORD                       dwMediaNumEntries,
    LPLINEMEDIACONTROLTONE      const lpToneList,
    DWORD                       dwToneNumEntries,
    LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
    DWORD                       dwCallStateNumEntries
    );

LONG
WINAPI
lineSetMediaMode(
    HCALL               hCall,
    DWORD               dwMediaModes
    );

#if (TAPI_CURRENT_VERSION >= 0x00020002)
LONG
WINAPI
lineSetQueueMeasurementPeriod(                                  // TAPI v2.2
    HLINE               hLine,
    DWORD               dwQueueID,
    DWORD               dwMeasurementPeriod
    );
#endif

LONG
WINAPI
lineSetNumRings(
    HLINE               hLine,
    DWORD               dwAddressID,
    DWORD               dwNumRings
    );

LONG
WINAPI
lineSetStatusMessages(
    HLINE               hLine,
    DWORD               dwLineStates,
    DWORD               dwAddressStates
    );

LONG
WINAPI
lineSetTerminal(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    DWORD               dwTerminalModes,
    DWORD               dwTerminalID,
    DWORD               bEnable
    );

LONG
WINAPI
lineSetTollList(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    );

#if WIN32
LONG
WINAPI
lineSetTollListA(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCSTR              lpszAddressIn,
    DWORD               dwTollListOption
    );

LONG
WINAPI
lineSetTollListW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    LPCWSTR             lpszAddressInW,
    DWORD               dwTollListOption
    );

#ifdef UNICODE
#define lineSetTollList lineSetTollListW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineSetTollList lineSetTollListA
#endif
#endif
#endif

LONG
WINAPI
lineSetupConference(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupConferenceA(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
lineSetupConferenceW(
    HCALL               hCall,
    HLINE               hLine,
    LPHCALL             lphConfCall,
    LPHCALL             lphConsultCall,
    DWORD               dwNumParties,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineSetupConference lineSetupConferenceW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineSetupConference lineSetupConferenceA
#endif
#endif
#endif

LONG
WINAPI
lineSetupTransfer(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#if WIN32
LONG
WINAPI
lineSetupTransferA(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

LONG
WINAPI
lineSetupTransferW(
    HCALL               hCall,
    LPHCALL             lphConsultCall,
    LPLINECALLPARAMS    const lpCallParams
    );

#ifdef UNICODE
#define lineSetupTransfer lineSetupTransferW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineSetupTransfer lineSetupTransferA
#endif
#endif
#endif

LONG
WINAPI
lineShutdown(
    HLINEAPP            hLineApp
    );

LONG
WINAPI
lineSwapHold(
    HCALL               hActiveCall,
    HCALL               hHeldCall
    );

LONG
WINAPI
lineTranslateAddress(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#if WIN32
LONG
WINAPI
lineTranslateAddressA(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCSTR                  lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

LONG
WINAPI
lineTranslateAddressW(
    HLINEAPP                hLineApp,
    DWORD                   dwDeviceID,
    DWORD                   dwAPIVersion,
    LPCWSTR                 lpszAddressIn,
    DWORD                   dwCard,
    DWORD                   dwTranslateOptions,
    LPLINETRANSLATEOUTPUT   lpTranslateOutput
    );

#ifdef UNICODE
#define lineTranslateAddress lineTranslateAddressW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineTranslateAddress lineTranslateAddressA
#endif
#endif
#endif

LONG
WINAPI
lineTranslateDialog(                                            // TAPI v1.4
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    );

#if WIN32
LONG
WINAPI
lineTranslateDialogA(                                            // TAPI v1.4
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCSTR              lpszAddressIn
    );

LONG
WINAPI
lineTranslateDialogW(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    HWND                hwndOwner,
    LPCWSTR             lpszAddressIn
    );

#ifdef UNICODE
#define lineTranslateDialog lineTranslateDialogW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineTranslateDialog lineTranslateDialogA
#endif
#endif
#endif

LONG
WINAPI
lineUncompleteCall(
    HLINE               hLine,
    DWORD               dwCompletionID
    );

LONG
WINAPI
lineUnhold(
    HCALL               hCall
    );

LONG
WINAPI
lineUnpark(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    );

#if WIN32
LONG
WINAPI
lineUnparkA(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCSTR              lpszDestAddress
    );

LONG
WINAPI
lineUnparkW(
    HLINE               hLine,
    DWORD               dwAddressID,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress
    );

#ifdef UNICODE
#define lineUnpark lineUnparkW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define lineUnpark lineUnparkA
#endif
#endif
#endif



LONG
WINAPI
phoneClose(
    HPHONE              hPhone
    );

LONG
WINAPI
phoneConfigDialog(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneConfigDialogA(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCSTR              lpszDeviceClass
    );

LONG
WINAPI
phoneConfigDialogW(
    DWORD               dwDeviceID,
    HWND                hwndOwner,
    LPCWSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define phoneConfigDialog phoneConfigDialogW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define phoneConfigDialog phoneConfigDialogA
#endif
#endif
#endif

LONG
WINAPI
phoneDevSpecific(
    HPHONE              hPhone,
    LPVOID              lpParams,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneGetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

LONG
WINAPI
phoneGetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   lpButtonInfo
    );

#ifdef UNICODE
#define phoneGetButtonInfo phoneGetButtonInfoW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define phoneGetButtonInfo phoneGetButtonInfoA
#endif
#endif
#endif

LONG
WINAPI
phoneGetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneGetDevCaps(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#if WIN32
LONG
WINAPI
phoneGetDevCapsA(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

LONG
WINAPI
phoneGetDevCapsW(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPPHONECAPS         lpPhoneCaps
    );

#ifdef UNICODE
#define phoneGetDevCaps phoneGetDevCapsW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define phoneGetDevCaps phoneGetDevCapsA
#endif
#endif
#endif

LONG
WINAPI
phoneGetDisplay(
    HPHONE              hPhone,
    LPVARSTRING         lpDisplay
    );

LONG
WINAPI
phoneGetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwGain
    );

LONG
WINAPI
phoneGetHookSwitch(
    HPHONE              hPhone,
    LPDWORD             lpdwHookSwitchDevs
    );

LONG
WINAPI
phoneGetIcon(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

#if WIN32
LONG
WINAPI
phoneGetIconA(
    DWORD               dwDeviceID,
    LPCSTR              lpszDeviceClass,
    LPHICON             lphIcon
    );

LONG
WINAPI
phoneGetIconW(
    DWORD               dwDeviceID,
    LPCWSTR             lpszDeviceClass,
    LPHICON             lphIcon
    );

#ifdef UNICODE
#define phoneGetIcon phoneGetIconW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define phoneGetIcon phoneGetIconA
#endif
#endif
#endif

LONG
WINAPI
phoneGetID(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

#if WIN32
LONG
WINAPI
phoneGetIDA(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCSTR              lpszDeviceClass
    );

LONG
WINAPI
phoneGetIDW(
    HPHONE              hPhone,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    );

#ifdef UNICODE
#define phoneGetID phoneGetIDW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define phoneGetID phoneGetIDA
#endif
#endif
#endif

LONG
WINAPI
phoneGetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPDWORD             lpdwLampMode
    );

#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneGetMessage(                                                // TAPI v2.0
    HPHONEAPP       hPhoneApp,
    LPPHONEMESSAGE  lpMessage,
    DWORD           dwTimeout
    );
#endif

LONG
WINAPI
phoneGetRing(
    HPHONE              hPhone,
    LPDWORD             lpdwRingMode,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneGetStatus(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

#if WIN32
LONG
WINAPI
phoneGetStatusA(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );

LONG
WINAPI
phoneGetStatusW(
    HPHONE              hPhone,
    LPPHONESTATUS       lpPhoneStatus
    );


#ifdef UNICODE
#define phoneGetStatus phoneGetStatusW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define phoneGetStatus phoneGetStatusA
#endif
#endif
#endif

LONG
WINAPI
phoneGetStatusMessages(
    HPHONE              hPhone,
    LPDWORD             lpdwPhoneStates,
    LPDWORD             lpdwButtonModes,
    LPDWORD             lpdwButtonStates
    );

LONG
WINAPI
phoneGetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    LPDWORD             lpdwVolume
    );

LONG
WINAPI
phoneInitialize(
    LPHPHONEAPP         lphPhoneApp,
    HINSTANCE           hInstance,
    PHONECALLBACK       lpfnCallback,
    LPCSTR              lpszAppName,
    LPDWORD             lpdwNumDevs
    );


#if (TAPI_CURRENT_VERSION >= 0x00020000)
LONG
WINAPI
phoneInitializeExA(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCSTR                      lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

LONG
WINAPI
phoneInitializeExW(                                              // TAPI v2.0
    LPHPHONEAPP                 lphPhoneApp,
    HINSTANCE                   hInstance,
    PHONECALLBACK               lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPPHONEINITIALIZEEXPARAMS   lpPhoneInitializeExParams
    );

#ifdef UNICODE
#define phoneInitializeEx phoneInitializeExW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define phoneInitializeEx phoneInitializeExA
#endif
#endif
#endif

LONG
WINAPI
phoneNegotiateAPIVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPILowVersion,
    DWORD               dwAPIHighVersion,
    LPDWORD             lpdwAPIVersion,
    LPPHONEEXTENSIONID  lpExtensionID
    );

LONG
WINAPI
phoneNegotiateExtVersion(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtLowVersion,
    DWORD               dwExtHighVersion,
    LPDWORD             lpdwExtVersion
    );

LONG
WINAPI
phoneOpen(
    HPHONEAPP           hPhoneApp,
    DWORD               dwDeviceID,
    LPHPHONE            lphPhone,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivilege
    );

LONG
WINAPI
phoneSetButtonInfo(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#if WIN32
LONG
WINAPI
phoneSetButtonInfoA(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

LONG
WINAPI
phoneSetButtonInfoW(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    LPPHONEBUTTONINFO   const lpButtonInfo
    );

#ifdef UNICODE
#define phoneSetButtonInfo phoneSetButtonInfoW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define phoneSetButtonInfo phoneSetButtonInfoA
#endif
#endif
#endif

LONG
WINAPI
phoneSetData(
    HPHONE              hPhone,
    DWORD               dwDataID,
    LPVOID              const lpData,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetDisplay(
    HPHONE              hPhone,
    DWORD               dwRow,
    DWORD               dwColumn,
    LPCSTR              lpsDisplay,
    DWORD               dwSize
    );

LONG
WINAPI
phoneSetGain(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwGain
    );

LONG
WINAPI
phoneSetHookSwitch(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDevs,
    DWORD               dwHookSwitchMode
    );

LONG
WINAPI
phoneSetLamp(
    HPHONE              hPhone,
    DWORD               dwButtonLampID,
    DWORD               dwLampMode
    );

LONG
WINAPI
phoneSetRing(
    HPHONE              hPhone,
    DWORD               dwRingMode,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneSetStatusMessages(
    HPHONE              hPhone,
    DWORD               dwPhoneStates,
    DWORD               dwButtonModes,
    DWORD               dwButtonStates
    );

LONG
WINAPI
phoneSetVolume(
    HPHONE              hPhone,
    DWORD               dwHookSwitchDev,
    DWORD               dwVolume
    );

LONG
WINAPI
phoneShutdown(
    HPHONEAPP           hPhoneApp
    );



LONG
WINAPI
tapiGetLocationInfo(
    __out_ecount(8) LPSTR               lpszCountryCode,
    __out_ecount(8) LPSTR               lpszCityCode
    );

#if WIN32
LONG
WINAPI
tapiGetLocationInfoA(
    __out_ecount(8) LPSTR               lpszCountryCode,
    __out_ecount(8) LPSTR               lpszCityCode
    );

LONG
WINAPI
tapiGetLocationInfoW(
    __out_ecount(8) LPWSTR               lpszCountryCodeW,
    __out_ecount(8) LPWSTR               lpszCityCodeW
    );

#ifdef UNICODE
#define tapiGetLocationInfo tapiGetLocationInfoW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define tapiGetLocationInfo tapiGetLocationInfoA
#endif
#endif
#endif

LONG
WINAPI
tapiRequestDrop(
    HWND                hwnd,
    WPARAM              wRequestID
    );

LONG
WINAPI
tapiRequestMakeCall(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMakeCallA(
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

LONG
WINAPI
tapiRequestMakeCallW(
    LPCWSTR              lpszDestAddress,
    LPCWSTR              lpszAppName,
    LPCWSTR              lpszCalledParty,
    LPCWSTR              lpszComment
    );

#ifdef UNICODE
#define tapiRequestMakeCall tapiRequestMakeCallW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define tapiRequestMakeCall tapiRequestMakeCallA
#endif
#endif
#endif

LONG
WINAPI
tapiRequestMediaCall(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

#if WIN32
LONG
WINAPI
tapiRequestMediaCallA(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCSTR              lpszDeviceClass,
    LPCSTR              lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCSTR              lpszDestAddress,
    LPCSTR              lpszAppName,
    LPCSTR              lpszCalledParty,
    LPCSTR              lpszComment
    );

LONG
WINAPI
tapiRequestMediaCallW(
    HWND                hwnd,
    WPARAM              wRequestID,
    LPCWSTR             lpszDeviceClass,
    LPCWSTR             lpDeviceID,
    DWORD               dwSize,
    DWORD               dwSecure,
    LPCWSTR             lpszDestAddress,
    LPCWSTR             lpszAppName,
    LPCWSTR             lpszCalledParty,
    LPCWSTR             lpszComment
    );

#ifdef UNICODE
#define tapiRequestMediaCall tapiRequestMediaCallW
#else
#if (TAPI_CURRENT_VERSION >= 0x00020000)
#define tapiRequestMediaCall tapiRequestMediaCallA
#endif
#endif
#endif

/*

TAPIERROR_FORMATMESSAGE - macro to convert a TAPI error constant
    into a constant that FormatMessage will accept

        TAPIERR : Negative numbers and 0
            Map to : strip off high WORD
            Example: 0xFFFFFFFF (-1) becomes 0x0000FFFF
        LINEERR : Start at 0x80000000
            Map to : strip off 0x80000000 and add 0xE000
            Example: 0x80000004 becomes 0x0000E004
        PHONEERR: Start at 0x90000000
            Map to : strip off 0x90000000 and add 0xF000
            Example: 0x9000000A becomes 0x0000F00A

        pseudocode:

        if (__ErrCode__ is a TAPIERR)
            strip off high word

            else if (__ErrCode__ is a PHONEERR)
                strip off 0x90000000
                add 0xE000

                else
                    strip off 0x80000000
                    add 0xF000

*/

#define TAPIERROR_FORMATMESSAGE(__ErrCode__)                                                   \
                                                                                               \
                    ( ( (__ErrCode__) > 0xFFFF0000 ) ?                                         \
                                                                                               \
                            ( (__ErrCode__) & 0x0000FFFF ) :                                   \
                                                                                               \
                            ( ( (__ErrCode__) & 0x10000000 ) ?                                 \
                                                                                               \
                              ( (__ErrCode__) - 0x90000000 + 0xF000 ) :                        \
                                                                                               \
                              ( (__ErrCode__) - 0x80000000 + 0xE000 ) ) )



#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#pragma pack()

#endif // TAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Tapi3Err.h ===
/*****************************************************************************
*
* Copyright (c) Microsoft Corporation. All rights reserved.
*
* Module Name:
*
*    tapi3err.h
*
* Abstract:
*
*    Error Notifications for TAPI 3.0
*
*****************************************************************************/

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __TAPI3ERR_H__
#define __TAPI3ERR_H__

//--------------------------------------------------------------------------
//     Core TAPI Error messages
//--------------------------------------------------------------------------

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: TAPI_E_NOTENOUGHMEMORY
//
// MessageText:
//
// The buffer passed in to this method was not big enough.
//
#define TAPI_E_NOTENOUGHMEMORY           ((HRESULT)0x80040001L)

//
// MessageId: TAPI_E_NOITEMS
//
// MessageText:
//
// No items exist that match the request.
//
#define TAPI_E_NOITEMS                   ((HRESULT)0x80040002L)

//
// MessageId: TAPI_E_NOTSUPPORTED
//
// MessageText:
//
// This method is not supported.
//
#define TAPI_E_NOTSUPPORTED              ((HRESULT)0x80040003L)

//
// MessageId: TAPI_E_INVALIDMEDIATYPE
//
// MessageText:
//
// The MEDIATYPE passed in to this method was invalid.
//
#define TAPI_E_INVALIDMEDIATYPE          ((HRESULT)0x80040004L)

//
// MessageId: TAPI_E_OPERATIONFAILED
//
// MessageText:
//
// The operation failed for an unspecified reason.
//
#define TAPI_E_OPERATIONFAILED           ((HRESULT)0x80040005L)

//
// MessageId: TAPI_E_ALLOCATED
//
// MessageText:
//
// The device is already in use.
//
#define TAPI_E_ALLOCATED                 ((HRESULT)0x80040006L)

//
// MessageId: TAPI_E_CALLUNAVAIL
//
// MessageText:
//
// No call appearance available.
//
#define TAPI_E_CALLUNAVAIL               ((HRESULT)0x80040007L)

//
// MessageId: TAPI_E_COMPLETIONOVERRUN
//
// MessageText:
//
// Too many call completions outstanding.
//
#define TAPI_E_COMPLETIONOVERRUN         ((HRESULT)0x80040008L)

//
// MessageId: TAPI_E_CONFERENCEFULL
//
// MessageText:
//
// The conference is full.
//
#define TAPI_E_CONFERENCEFULL            ((HRESULT)0x80040009L)

//
// MessageId: TAPI_E_DIALMODIFIERNOTSUPPORTED
//
// MessageText:
//
// The dial modifier is not supported.
//
#define TAPI_E_DIALMODIFIERNOTSUPPORTED  ((HRESULT)0x8004000AL)

//
// MessageId: TAPI_E_INUSE
//
// MessageText:
//
// The device is already in use.
//
#define TAPI_E_INUSE                     ((HRESULT)0x8004000BL)

//
// MessageId: TAPI_E_INVALADDRESS
//
// MessageText:
//
// The phone number is invalid or not properly formatted.
//
#define TAPI_E_INVALADDRESS              ((HRESULT)0x8004000CL)

//
// MessageId: TAPI_E_INVALADDRESSSTATE
//
// MessageText:
//
// Operation not permitted in current address state.
//
#define TAPI_E_INVALADDRESSSTATE         ((HRESULT)0x8004000DL)

//
// MessageId: TAPI_E_INVALCALLPARAMS
//
// MessageText:
//
// Invalid LINECALLPARAMS structure.
//
#define TAPI_E_INVALCALLPARAMS           ((HRESULT)0x8004000EL)

//
// MessageId: TAPI_E_INVALCALLPRIVILEGE
//
// MessageText:
//
// Invalid call privilege.
//
#define TAPI_E_INVALCALLPRIVILEGE        ((HRESULT)0x8004000FL)

//
// MessageId: TAPI_E_INVALCALLSTATE
//
// MessageText:
//
// Operation not permitted in current call state.
//
#define TAPI_E_INVALCALLSTATE            ((HRESULT)0x80040010L)

//
// MessageId: TAPI_E_INVALCARD
//
// MessageText:
//
// Invalid calling card.
//
#define TAPI_E_INVALCARD                 ((HRESULT)0x80040011L)

//
// MessageId: TAPI_E_INVALCOMPLETIONID
//
// MessageText:
//
// Invalid call completion ID.
//
#define TAPI_E_INVALCOMPLETIONID         ((HRESULT)0x80040012L)

//
// MessageId: TAPI_E_INVALCOUNTRYCODE
//
// MessageText:
//
// Invalid country code.
//
#define TAPI_E_INVALCOUNTRYCODE          ((HRESULT)0x80040013L)

//
// MessageId: TAPI_E_INVALDEVICECLASS
//
// MessageText:
//
// Invalid device class identifier
//
#define TAPI_E_INVALDEVICECLASS          ((HRESULT)0x80040014L)

//
// MessageId: TAPI_E_INVALDIALPARAMS
//
// MessageText:
//
// Invalid dialing parameters
//
#define TAPI_E_INVALDIALPARAMS           ((HRESULT)0x80040015L)

//
// MessageId: TAPI_E_INVALDIGITS
//
// MessageText:
//
// Invalid digits.
//
#define TAPI_E_INVALDIGITS               ((HRESULT)0x80040016L)

//
// MessageId: TAPI_E_INVALGROUPID
//
// MessageText:
//
// Invalid group pickup ID.
//
#define TAPI_E_INVALGROUPID              ((HRESULT)0x80040017L)

//
// MessageId: TAPI_E_INVALLOCATION
//
// MessageText:
//
// Invalid location ID.
//
#define TAPI_E_INVALLOCATION             ((HRESULT)0x80040018L)

//
// MessageId: TAPI_E_INVALMESSAGEID
//
// MessageText:
//
// Invalid message ID.
//
#define TAPI_E_INVALMESSAGEID            ((HRESULT)0x80040019L)

//
// MessageId: TAPI_E_INVALPARKID
//
// MessageText:
//
// Invalid park ID.
//
#define TAPI_E_INVALPARKID               ((HRESULT)0x8004001AL)

//
// MessageId: TAPI_E_INVALRATE
//
// MessageText:
//
// Invalid rate.
//
#define TAPI_E_INVALRATE                 ((HRESULT)0x8004001BL)

//
// MessageId: TAPI_E_INVALTIMEOUT
//
// MessageText:
//
// Invalid timeout value.
//
#define TAPI_E_INVALTIMEOUT              ((HRESULT)0x8004001CL)

//
// MessageId: TAPI_E_INVALTONE
//
// MessageText:
//
// Invalid tone.
//
#define TAPI_E_INVALTONE                 ((HRESULT)0x8004001DL)

//
// MessageId: TAPI_E_INVALLIST
//
// MessageText:
//
// Invalid list passed as a parameter
//
#define TAPI_E_INVALLIST                 ((HRESULT)0x8004001EL)

//
// MessageId: TAPI_E_INVALMODE
//
// MessageText:
//
// Invalid mode passed as a parameter
//
#define TAPI_E_INVALMODE                 ((HRESULT)0x8004001FL)

//
// MessageId: TAPI_E_NOCONFERENCE
//
// MessageText:
//
// The call is not part of a conference.
//
#define TAPI_E_NOCONFERENCE              ((HRESULT)0x80040020L)

//
// MessageId: TAPI_E_NODEVICE
//
// MessageText:
//
// The device was removed, or the device class is not recognized.
//
#define TAPI_E_NODEVICE                  ((HRESULT)0x80040021L)

//
// MessageId: TAPI_E_NOREQUEST
//
// MessageText:
//
// No Assisted Telephony requests are pending.
//
#define TAPI_E_NOREQUEST                 ((HRESULT)0x80040022L)

//
// MessageId: TAPI_E_NOTOWNER
//
// MessageText:
//
// The application is does not have OWNER privilege on the call.
//
#define TAPI_E_NOTOWNER                  ((HRESULT)0x80040023L)

//
// MessageId: TAPI_E_NOTREGISTERED
//
// MessageText:
//
// The application is not registered to handle requests.
//
#define TAPI_E_NOTREGISTERED             ((HRESULT)0x80040024L)

//
// MessageId: TAPI_E_REQUESTOVERRUN
//
// MessageText:
//
// The request queue is already full.
//
#define TAPI_E_REQUESTOVERRUN            ((HRESULT)0x80040025L)

//
// MessageId: TAPI_E_TARGETNOTFOUND
//
// MessageText:
//
// The call handoff failed because the specified target was not found.
//
#define TAPI_E_TARGETNOTFOUND            ((HRESULT)0x80040026L)

//
// MessageId: TAPI_E_TARGETSELF
//
// MessageText:
//
// No higher priority target exists for the call handoff.
//
#define TAPI_E_TARGETSELF                ((HRESULT)0x80040027L)

//
// MessageId: TAPI_E_USERUSERINFOTOOBIG
//
// MessageText:
//
// The amount of user-user info exceeds the maximum permitted.
//
#define TAPI_E_USERUSERINFOTOOBIG        ((HRESULT)0x80040028L)

//
// MessageId: TAPI_E_REINIT
//
// MessageText:
//
// The operation cannot be completed until all TAPI applications shutdown and reinitialize. 
//
#define TAPI_E_REINIT                    ((HRESULT)0x80040029L)

//
// MessageId: TAPI_E_ADDRESSBLOCKED
//
// MessageText:
//
// You are not permitted to call this number.
//
#define TAPI_E_ADDRESSBLOCKED            ((HRESULT)0x8004002AL)

//
// MessageId: TAPI_E_BILLINGREJECTED
//
// MessageText:
//
// The calling card number or other billing information was rejected.
//
#define TAPI_E_BILLINGREJECTED           ((HRESULT)0x8004002BL)

//
// MessageId: TAPI_E_INVALFEATURE
//
// MessageText:
//
// Invalid device-specific feature.
//
#define TAPI_E_INVALFEATURE              ((HRESULT)0x8004002CL)

//
// MessageId: TAPI_E_INVALBUTTONLAMPID
//
// MessageText:
//
// Invalid button or lamp ID.
//
#define TAPI_E_INVALBUTTONLAMPID         ((HRESULT)0x8004002DL)

//
// MessageId: TAPI_E_INVALBUTTONSTATE
//
// MessageText:
//
// Invalid button state.
//
#define TAPI_E_INVALBUTTONSTATE          ((HRESULT)0x8004002EL)

//
// MessageId: TAPI_E_INVALDATAID
//
// MessageText:
//
// Invalid data segment ID.
//
#define TAPI_E_INVALDATAID               ((HRESULT)0x8004002FL)

//
// MessageId: TAPI_E_INVALHOOKSWITCHDEV
//
// MessageText:
//
// Invalid hookswitch device ID.
//
#define TAPI_E_INVALHOOKSWITCHDEV        ((HRESULT)0x80040030L)

//
// MessageId: TAPI_E_DROPPED
//
// MessageText:
//
// The call was disconnected.
//
#define TAPI_E_DROPPED                   ((HRESULT)0x80040031L)

//
// MessageId: TAPI_E_NOREQUESTRECIPIENT
//
// MessageText:
//
// No program is available to handle the request.
//
#define TAPI_E_NOREQUESTRECIPIENT        ((HRESULT)0x80040032L)

//
// MessageId: TAPI_E_REQUESTQUEUEFULL
//
// MessageText:
//
// The queue of call requests is full.
//
#define TAPI_E_REQUESTQUEUEFULL          ((HRESULT)0x80040033L)

//
// MessageId: TAPI_E_DESTBUSY
//
// MessageText:
//
// The called number is busy.
//
#define TAPI_E_DESTBUSY                  ((HRESULT)0x80040034L)

//
// MessageId: TAPI_E_DESTNOANSWER
//
// MessageText:
//
// The called party does not answer.
//
#define TAPI_E_DESTNOANSWER              ((HRESULT)0x80040035L)

//
// MessageId: TAPI_E_DESTUNAVAIL
//
// MessageText:
//
// The called number could not be reached
//
#define TAPI_E_DESTUNAVAIL               ((HRESULT)0x80040036L)

//
// MessageId: TAPI_E_REQUESTFAILED
//
// MessageText:
//
// The request failed for unspecified reasons.
//
#define TAPI_E_REQUESTFAILED             ((HRESULT)0x80040037L)

//
// MessageId: TAPI_E_REQUESTCANCELLED
//
// MessageText:
//
// The request was cancelled.
//
#define TAPI_E_REQUESTCANCELLED          ((HRESULT)0x80040038L)

//
// MessageId: TAPI_E_INVALPRIVILEGE
//
// MessageText:
//
// Invalid privilege.
//
#define TAPI_E_INVALPRIVILEGE            ((HRESULT)0x80040039L)

//
// MessageId: TAPI_E_INVALIDDIRECTION
//
// MessageText:
//
// The TERMINAL_DIRECTION passed in was invalid.
//
#define TAPI_E_INVALIDDIRECTION          ((HRESULT)0x8004003AL)

//
// MessageId: TAPI_E_INVALIDTERMINAL
//
// MessageText:
//
// The Terminal passed in was invalid for this operation.
//
#define TAPI_E_INVALIDTERMINAL           ((HRESULT)0x8004003BL)

//
// MessageId: TAPI_E_INVALIDTERMINALCLASS
//
// MessageText:
//
// The Terminal Class is invalid.
//
#define TAPI_E_INVALIDTERMINALCLASS      ((HRESULT)0x8004003CL)

//
// MessageId: TAPI_E_NODRIVER
//
// MessageText:
//
// The service provider was removed.
//
#define TAPI_E_NODRIVER                  ((HRESULT)0x8004003DL)

//
// MessageId: TAPI_E_MAXSTREAMS
//
// MessageText:
//
// The maximum number of streams was reached.
//
#define TAPI_E_MAXSTREAMS                ((HRESULT)0x8004003EL)

//
// MessageId: TAPI_E_NOTERMINALSELECTED
//
// MessageText:
//
// The operation could not be performed because it requires terminals to be selected.
//
#define TAPI_E_NOTERMINALSELECTED        ((HRESULT)0x8004003FL)

//
// MessageId: TAPI_E_TERMINALINUSE
//
// MessageText:
//
// The operation could not be performed because the terminal is in use.
//
#define TAPI_E_TERMINALINUSE             ((HRESULT)0x80040040L)

//
// MessageId: TAPI_E_NOTSTOPPED
//
// MessageText:
//
// The operation could not be performed because it requires the stream to be stopped.
//
#define TAPI_E_NOTSTOPPED                ((HRESULT)0x80040041L)

//
// MessageId: TAPI_E_MAXTERMINALS
//
// MessageText:
//
// The maximum number of terminals has been reached.
//
#define TAPI_E_MAXTERMINALS              ((HRESULT)0x80040042L)

//
// MessageId: TAPI_E_INVALIDSTREAM
//
// MessageText:
//
// The Stream passed in was invalid for this operation.
//
#define TAPI_E_INVALIDSTREAM             ((HRESULT)0x80040043L)

//
// MessageId: TAPI_E_TIMEOUT
//
// MessageText:
//
// The call failed due to a timeout.
//
#define TAPI_E_TIMEOUT                   ((HRESULT)0x80040044L)

//--------------------------------------------------------------------------
//     Call Center Error messages
//--------------------------------------------------------------------------

//
// MessageId: TAPI_E_CALLCENTER_GROUP_REMOVED
//
// MessageText:
//
// The ACD Proxy has removed this Group. Operations on this object are invalid.
//
#define TAPI_E_CALLCENTER_GROUP_REMOVED  ((HRESULT)0x80040045L)

//
// MessageId: TAPI_E_CALLCENTER_QUEUE_REMOVED
//
// MessageText:
//
// The ACD Proxy has removed this Queue. Operations on this object are invalid.
//
#define TAPI_E_CALLCENTER_QUEUE_REMOVED  ((HRESULT)0x80040046L)

//
// MessageId: TAPI_E_CALLCENTER_NO_AGENT_ID
//
// MessageText:
//
// The Agent object was created with CreateAgent. It does not have an ID, use CreateAgentWithID.
//
#define TAPI_E_CALLCENTER_NO_AGENT_ID    ((HRESULT)0x80040047L)

//
// MessageId: TAPI_E_CALLCENTER_INVALAGENTID
//
// MessageText:
//
// Invalid agent ID.
//
#define TAPI_E_CALLCENTER_INVALAGENTID   ((HRESULT)0x80040048L)

//
// MessageId: TAPI_E_CALLCENTER_INVALAGENTGROUP
//
// MessageText:
//
// Invalid agent group.
//
#define TAPI_E_CALLCENTER_INVALAGENTGROUP ((HRESULT)0x80040049L)

//
// MessageId: TAPI_E_CALLCENTER_INVALPASSWORD
//
// MessageText:
//
// Invalid agent password.
//
#define TAPI_E_CALLCENTER_INVALPASSWORD  ((HRESULT)0x8004004AL)

//
// MessageId: TAPI_E_CALLCENTER_INVALAGENTSTATE
//
// MessageText:
//
// Invalid agent state
//
#define TAPI_E_CALLCENTER_INVALAGENTSTATE ((HRESULT)0x8004004BL)

//
// MessageId: TAPI_E_CALLCENTER_INVALAGENTACTIVITY
//
// MessageText:
//
// Invalid agent activity.
//
#define TAPI_E_CALLCENTER_INVALAGENTACTIVITY ((HRESULT)0x8004004CL)

//
// MessageId: TAPI_E_REGISTRY_SETTING_CORRUPT
//
// MessageText:
//
// Registry Setting is Corrupt.
//
#define TAPI_E_REGISTRY_SETTING_CORRUPT  ((HRESULT)0x8004004DL)

//--------------------------------------------------------------------------
//     Terminal Specific Error messages
//--------------------------------------------------------------------------

//
// MessageId: TAPI_E_TERMINAL_PEER
//
// MessageText:
//
// The peer for one of these bridge terminals has already been assigned.
//
#define TAPI_E_TERMINAL_PEER             ((HRESULT)0x8004004EL)

//
// MessageId: TAPI_E_PEER_NOT_SET
//
// MessageText:
//
// The peer for this bridge terminal must be set to complete this operation.
//
#define TAPI_E_PEER_NOT_SET              ((HRESULT)0x8004004FL)


//--------------------------------------------------------------------------
//     Media Service Provider Error messages
//--------------------------------------------------------------------------
//
// MessageId: TAPI_E_NOEVENT
//
// MessageText:
//
// There is no event in the MSP's event queue.
//
#define TAPI_E_NOEVENT                   ((HRESULT)0x80040050L)

//--------------------------------------------------------------------------
//     Core TAPI Error messages
//--------------------------------------------------------------------------

//
// MessageId: TAPI_E_INVALADDRESSTYPE
//
// MessageText:
//
// The specified address type is not supported by this address.
//
#define TAPI_E_INVALADDRESSTYPE          ((HRESULT)0x80040051L)

//
// MessageId: TAPI_E_RESOURCEUNAVAIL
//
// MessageText:
//
// A resource needed to fulfill the request is not available.
//
#define TAPI_E_RESOURCEUNAVAIL           ((HRESULT)0x80040052L)

//
// MessageId: TAPI_E_PHONENOTOPEN
//
// MessageText:
//
// The phone is not open.
//
#define TAPI_E_PHONENOTOPEN              ((HRESULT)0x80040053L)

//
// MessageId: TAPI_E_CALLNOTSELECTED
//
// MessageText:
//
// The specified call is not currently selected.
//
#define TAPI_E_CALLNOTSELECTED           ((HRESULT)0x80040054L)

//
// MessageId: TAPI_E_WRONGEVENT
//
// MessageText:
//
// This information is not available for this type of event.
//
#define TAPI_E_WRONGEVENT                ((HRESULT)0x80040055L)

//
// MessageId: TAPI_E_NOFORMAT
//
// MessageText:
//
// The format is unknown
//
#define TAPI_E_NOFORMAT                  ((HRESULT)0x80040056L)

//
// MessageId: TAPI_E_INVALIDSTREAMSTATE
//
// MessageText:
//
// The operation is not permitted in current stream state.
//
#define TAPI_E_INVALIDSTREAMSTATE        ((HRESULT)0x80040057L)

//
// MessageId: TAPI_E_WRONG_STATE
//
// MessageText:
//
// The operation requested is not permitted for the current state.
//
#define TAPI_E_WRONG_STATE               ((HRESULT)0x80040058L)

//
// MessageId: TAPI_E_NOT_INITIALIZED
//
// MessageText:
//
// The object has not been initialized.
//
#define TAPI_E_NOT_INITIALIZED           ((HRESULT)0x80040059L)

//
// MessageId: TAPI_E_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The Telephony Service could not be contacted.
//
#define TAPI_E_SERVICE_NOT_RUNNING       ((HRESULT)0x8004005AL)

#endif // #ifndef __TAPI3ERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\SyncMgr.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for syncmgr.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __syncmgr_h__
#define __syncmgr_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISyncMgrHandlerCollection_FWD_DEFINED__
#define __ISyncMgrHandlerCollection_FWD_DEFINED__
typedef interface ISyncMgrHandlerCollection ISyncMgrHandlerCollection;
#endif 	/* __ISyncMgrHandlerCollection_FWD_DEFINED__ */


#ifndef __ISyncMgrHandler_FWD_DEFINED__
#define __ISyncMgrHandler_FWD_DEFINED__
typedef interface ISyncMgrHandler ISyncMgrHandler;
#endif 	/* __ISyncMgrHandler_FWD_DEFINED__ */


#ifndef __ISyncMgrHandlerInfo_FWD_DEFINED__
#define __ISyncMgrHandlerInfo_FWD_DEFINED__
typedef interface ISyncMgrHandlerInfo ISyncMgrHandlerInfo;
#endif 	/* __ISyncMgrHandlerInfo_FWD_DEFINED__ */


#ifndef __ISyncMgrSyncItemContainer_FWD_DEFINED__
#define __ISyncMgrSyncItemContainer_FWD_DEFINED__
typedef interface ISyncMgrSyncItemContainer ISyncMgrSyncItemContainer;
#endif 	/* __ISyncMgrSyncItemContainer_FWD_DEFINED__ */


#ifndef __ISyncMgrSyncItem_FWD_DEFINED__
#define __ISyncMgrSyncItem_FWD_DEFINED__
typedef interface ISyncMgrSyncItem ISyncMgrSyncItem;
#endif 	/* __ISyncMgrSyncItem_FWD_DEFINED__ */


#ifndef __ISyncMgrSyncItemInfo_FWD_DEFINED__
#define __ISyncMgrSyncItemInfo_FWD_DEFINED__
typedef interface ISyncMgrSyncItemInfo ISyncMgrSyncItemInfo;
#endif 	/* __ISyncMgrSyncItemInfo_FWD_DEFINED__ */


#ifndef __IEnumSyncMgrSyncItems_FWD_DEFINED__
#define __IEnumSyncMgrSyncItems_FWD_DEFINED__
typedef interface IEnumSyncMgrSyncItems IEnumSyncMgrSyncItems;
#endif 	/* __IEnumSyncMgrSyncItems_FWD_DEFINED__ */


#ifndef __ISyncMgrSessionCreator_FWD_DEFINED__
#define __ISyncMgrSessionCreator_FWD_DEFINED__
typedef interface ISyncMgrSessionCreator ISyncMgrSessionCreator;
#endif 	/* __ISyncMgrSessionCreator_FWD_DEFINED__ */


#ifndef __ISyncMgrSyncCallback_FWD_DEFINED__
#define __ISyncMgrSyncCallback_FWD_DEFINED__
typedef interface ISyncMgrSyncCallback ISyncMgrSyncCallback;
#endif 	/* __ISyncMgrSyncCallback_FWD_DEFINED__ */


#ifndef __ISyncMgrUIOperation_FWD_DEFINED__
#define __ISyncMgrUIOperation_FWD_DEFINED__
typedef interface ISyncMgrUIOperation ISyncMgrUIOperation;
#endif 	/* __ISyncMgrUIOperation_FWD_DEFINED__ */


#ifndef __ISyncMgrEventLinkUIOperation_FWD_DEFINED__
#define __ISyncMgrEventLinkUIOperation_FWD_DEFINED__
typedef interface ISyncMgrEventLinkUIOperation ISyncMgrEventLinkUIOperation;
#endif 	/* __ISyncMgrEventLinkUIOperation_FWD_DEFINED__ */


#ifndef __ISyncMgrScheduleWizardUIOperation_FWD_DEFINED__
#define __ISyncMgrScheduleWizardUIOperation_FWD_DEFINED__
typedef interface ISyncMgrScheduleWizardUIOperation ISyncMgrScheduleWizardUIOperation;
#endif 	/* __ISyncMgrScheduleWizardUIOperation_FWD_DEFINED__ */


#ifndef __ISyncMgrSyncResult_FWD_DEFINED__
#define __ISyncMgrSyncResult_FWD_DEFINED__
typedef interface ISyncMgrSyncResult ISyncMgrSyncResult;
#endif 	/* __ISyncMgrSyncResult_FWD_DEFINED__ */


#ifndef __ISyncMgrControl_FWD_DEFINED__
#define __ISyncMgrControl_FWD_DEFINED__
typedef interface ISyncMgrControl ISyncMgrControl;
#endif 	/* __ISyncMgrControl_FWD_DEFINED__ */


#ifndef __ISyncMgrEventStore_FWD_DEFINED__
#define __ISyncMgrEventStore_FWD_DEFINED__
typedef interface ISyncMgrEventStore ISyncMgrEventStore;
#endif 	/* __ISyncMgrEventStore_FWD_DEFINED__ */


#ifndef __ISyncMgrEvent_FWD_DEFINED__
#define __ISyncMgrEvent_FWD_DEFINED__
typedef interface ISyncMgrEvent ISyncMgrEvent;
#endif 	/* __ISyncMgrEvent_FWD_DEFINED__ */


#ifndef __IEnumSyncMgrEvents_FWD_DEFINED__
#define __IEnumSyncMgrEvents_FWD_DEFINED__
typedef interface IEnumSyncMgrEvents IEnumSyncMgrEvents;
#endif 	/* __IEnumSyncMgrEvents_FWD_DEFINED__ */


#ifndef __ISyncMgrConflictStore_FWD_DEFINED__
#define __ISyncMgrConflictStore_FWD_DEFINED__
typedef interface ISyncMgrConflictStore ISyncMgrConflictStore;
#endif 	/* __ISyncMgrConflictStore_FWD_DEFINED__ */


#ifndef __IEnumSyncMgrConflict_FWD_DEFINED__
#define __IEnumSyncMgrConflict_FWD_DEFINED__
typedef interface IEnumSyncMgrConflict IEnumSyncMgrConflict;
#endif 	/* __IEnumSyncMgrConflict_FWD_DEFINED__ */


#ifndef __ISyncMgrConflict_FWD_DEFINED__
#define __ISyncMgrConflict_FWD_DEFINED__
typedef interface ISyncMgrConflict ISyncMgrConflict;
#endif 	/* __ISyncMgrConflict_FWD_DEFINED__ */


#ifndef __ISyncMgrResolutionHandler_FWD_DEFINED__
#define __ISyncMgrResolutionHandler_FWD_DEFINED__
typedef interface ISyncMgrResolutionHandler ISyncMgrResolutionHandler;
#endif 	/* __ISyncMgrResolutionHandler_FWD_DEFINED__ */


#ifndef __ISyncMgrConflictPresenter_FWD_DEFINED__
#define __ISyncMgrConflictPresenter_FWD_DEFINED__
typedef interface ISyncMgrConflictPresenter ISyncMgrConflictPresenter;
#endif 	/* __ISyncMgrConflictPresenter_FWD_DEFINED__ */


#ifndef __ISyncMgrConflictResolveInfo_FWD_DEFINED__
#define __ISyncMgrConflictResolveInfo_FWD_DEFINED__
typedef interface ISyncMgrConflictResolveInfo ISyncMgrConflictResolveInfo;
#endif 	/* __ISyncMgrConflictResolveInfo_FWD_DEFINED__ */


#ifndef __ISyncMgrConflictFolder_FWD_DEFINED__
#define __ISyncMgrConflictFolder_FWD_DEFINED__
typedef interface ISyncMgrConflictFolder ISyncMgrConflictFolder;
#endif 	/* __ISyncMgrConflictFolder_FWD_DEFINED__ */


#ifndef __ISyncMgrConflictItems_FWD_DEFINED__
#define __ISyncMgrConflictItems_FWD_DEFINED__
typedef interface ISyncMgrConflictItems ISyncMgrConflictItems;
#endif 	/* __ISyncMgrConflictItems_FWD_DEFINED__ */


#ifndef __ISyncMgrConflictResolutionItems_FWD_DEFINED__
#define __ISyncMgrConflictResolutionItems_FWD_DEFINED__
typedef interface ISyncMgrConflictResolutionItems ISyncMgrConflictResolutionItems;
#endif 	/* __ISyncMgrConflictResolutionItems_FWD_DEFINED__ */


#ifndef __SyncMgrClient_FWD_DEFINED__
#define __SyncMgrClient_FWD_DEFINED__

#ifdef __cplusplus
typedef class SyncMgrClient SyncMgrClient;
#else
typedef struct SyncMgrClient SyncMgrClient;
#endif /* __cplusplus */

#endif 	/* __SyncMgrClient_FWD_DEFINED__ */


#ifndef __SyncMgrControl_FWD_DEFINED__
#define __SyncMgrControl_FWD_DEFINED__

#ifdef __cplusplus
typedef class SyncMgrControl SyncMgrControl;
#else
typedef struct SyncMgrControl SyncMgrControl;
#endif /* __cplusplus */

#endif 	/* __SyncMgrControl_FWD_DEFINED__ */


#ifndef __SyncMgrScheduleWizard_FWD_DEFINED__
#define __SyncMgrScheduleWizard_FWD_DEFINED__

#ifdef __cplusplus
typedef class SyncMgrScheduleWizard SyncMgrScheduleWizard;
#else
typedef struct SyncMgrScheduleWizard SyncMgrScheduleWizard;
#endif /* __cplusplus */

#endif 	/* __SyncMgrScheduleWizard_FWD_DEFINED__ */


#ifndef __SyncMgrFolder_FWD_DEFINED__
#define __SyncMgrFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class SyncMgrFolder SyncMgrFolder;
#else
typedef struct SyncMgrFolder SyncMgrFolder;
#endif /* __cplusplus */

#endif 	/* __SyncMgrFolder_FWD_DEFINED__ */


#ifndef __SyncSetupFolder_FWD_DEFINED__
#define __SyncSetupFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class SyncSetupFolder SyncSetupFolder;
#else
typedef struct SyncSetupFolder SyncSetupFolder;
#endif /* __cplusplus */

#endif 	/* __SyncSetupFolder_FWD_DEFINED__ */


#ifndef __ConflictFolder_FWD_DEFINED__
#define __ConflictFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class ConflictFolder ConflictFolder;
#else
typedef struct ConflictFolder ConflictFolder;
#endif /* __cplusplus */

#endif 	/* __ConflictFolder_FWD_DEFINED__ */


#ifndef __SyncResultsFolder_FWD_DEFINED__
#define __SyncResultsFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class SyncResultsFolder SyncResultsFolder;
#else
typedef struct SyncResultsFolder SyncResultsFolder;
#endif /* __cplusplus */

#endif 	/* __SyncResultsFolder_FWD_DEFINED__ */


#ifndef __SimpleConflictPresenter_FWD_DEFINED__
#define __SimpleConflictPresenter_FWD_DEFINED__

#ifdef __cplusplus
typedef class SimpleConflictPresenter SimpleConflictPresenter;
#else
typedef struct SimpleConflictPresenter SimpleConflictPresenter;
#endif /* __cplusplus */

#endif 	/* __SimpleConflictPresenter_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_syncmgr_0000_0000 */
/* [local] */ 

























#define	MAX_SYNCMGR_ID	( 64 )

#define	MAX_SYNCMGR_PROGRESSTEXT	( 260 )

#define	MAX_SYNCMGR_NAME	( 128 )



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0000_v0_0_s_ifspec;

#ifndef __ISyncMgrHandlerCollection_INTERFACE_DEFINED__
#define __ISyncMgrHandlerCollection_INTERFACE_DEFINED__

/* interface ISyncMgrHandlerCollection */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrHandlerCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a7f337a3-d20b-45cb-9ed7-87d094ca5045")
    ISyncMgrHandlerCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHandlerEnumerator( 
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToHandler( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrHandlerCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrHandlerCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrHandlerCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrHandlerCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandlerEnumerator )( 
            ISyncMgrHandlerCollection * This,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            ISyncMgrHandlerCollection * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        END_INTERFACE
    } ISyncMgrHandlerCollectionVtbl;

    interface ISyncMgrHandlerCollection
    {
        CONST_VTBL struct ISyncMgrHandlerCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrHandlerCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrHandlerCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrHandlerCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrHandlerCollection_GetHandlerEnumerator(This,ppenum)	\
    ( (This)->lpVtbl -> GetHandlerEnumerator(This,ppenum) ) 

#define ISyncMgrHandlerCollection_BindToHandler(This,pszHandlerID,riid,ppv)	\
    ( (This)->lpVtbl -> BindToHandler(This,pszHandlerID,riid,ppv) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrHandlerCollection_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0001 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum SYNCMGR_HANDLER_CAPABILITIES
    {	SYNCMGR_HCM_NONE	= 0,
	SYNCMGR_HCM_PROVIDES_ICON	= 0x1,
	SYNCMGR_HCM_EVENT_STORE	= 0x2,
	SYNCMGR_HCM_CONFLICT_STORE	= 0x4,
	SYNCMGR_HCM_SUPPORTS_CONCURRENT_SESSIONS	= 0x10,
	SYNCMGR_HCM_CAN_BROWSE_CONTENT	= 0x10000,
	SYNCMGR_HCM_CAN_SHOW_SCHEDULE	= 0x20000,
	SYNCMGR_HCM_QUERY_BEFORE_ACTIVATE	= 0x100000,
	SYNCMGR_HCM_QUERY_BEFORE_DEACTIVATE	= 0x200000,
	SYNCMGR_HCM_QUERY_BEFORE_ENABLE	= 0x400000,
	SYNCMGR_HCM_QUERY_BEFORE_DISABLE	= 0x800000,
	SYNCMGR_HCM_VALID_MASK	= 0xf30017
    } 	SYNCMGR_HANDLER_CAPABILITIES;

typedef /* [v1_enum] */ 
enum SYNCMGR_HANDLER_POLICIES
    {	SYNCMGR_HPM_NONE	= 0,
	SYNCMGR_HPM_PREVENT_ACTIVATE	= 0x1,
	SYNCMGR_HPM_PREVENT_DEACTIVATE	= 0x2,
	SYNCMGR_HPM_PREVENT_ENABLE	= 0x4,
	SYNCMGR_HPM_PREVENT_DISABLE	= 0x8,
	SYNCMGR_HPM_PREVENT_START_SYNC	= 0x10,
	SYNCMGR_HPM_PREVENT_STOP_SYNC	= 0x20,
	SYNCMGR_HPM_DISABLE_ENABLE	= 0x100,
	SYNCMGR_HPM_DISABLE_DISABLE	= 0x200,
	SYNCMGR_HPM_DISABLE_START_SYNC	= 0x400,
	SYNCMGR_HPM_DISABLE_STOP_SYNC	= 0x800,
	SYNCMGR_HPM_DISABLE_BROWSE	= 0x1000,
	SYNCMGR_HPM_DISABLE_SCHEDULE	= 0x2000,
	SYNCMGR_HPM_HIDDEN_BY_DEFAULT	= 0x10000,
	SYNCMGR_HPM_BACKGROUND_SYNC_ONLY	= ( SYNCMGR_HPM_PREVENT_START_SYNC | SYNCMGR_HPM_PREVENT_STOP_SYNC ) ,
	SYNCMGR_HPM_VALID_MASK	= 0x12f3f
    } 	SYNCMGR_HANDLER_POLICIES;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0001_v0_0_s_ifspec;

#ifndef __ISyncMgrHandler_INTERFACE_DEFINED__
#define __ISyncMgrHandler_INTERFACE_DEFINED__

/* interface ISyncMgrHandler */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04ec2e43-ac77-49f9-9b98-0307ef7a72a2")
    ISyncMgrHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandlerInfo( 
            /* [out] */ __RPC__deref_out_opt ISyncMgrHandlerInfo **ppHandlerInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ __RPC__in REFGUID rguidObjectID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ __RPC__out SYNCMGR_HANDLER_CAPABILITIES *pmCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPolicies( 
            /* [out] */ __RPC__out SYNCMGR_HANDLER_POLICIES *pmPolicies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fActivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Synchronize( 
            /* [size_is][string][ref][in] */ __RPC__in_ecount_full(cItems) LPCWSTR *ppszItemIDs,
            /* [in] */ ULONG cItems,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ __RPC__in_opt ISyncMgrSessionCreator *pSessionCreator,
            /* [unique][in] */ __RPC__in_opt IUnknown *punk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISyncMgrHandler * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandlerInfo )( 
            ISyncMgrHandler * This,
            /* [out] */ __RPC__deref_out_opt ISyncMgrHandlerInfo **ppHandlerInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ISyncMgrHandler * This,
            /* [in] */ __RPC__in REFGUID rguidObjectID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            ISyncMgrHandler * This,
            /* [out] */ __RPC__out SYNCMGR_HANDLER_CAPABILITIES *pmCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetPolicies )( 
            ISyncMgrHandler * This,
            /* [out] */ __RPC__out SYNCMGR_HANDLER_POLICIES *pmPolicies);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ISyncMgrHandler * This,
            /* [in] */ BOOL fActivate);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            ISyncMgrHandler * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *Synchronize )( 
            ISyncMgrHandler * This,
            /* [size_is][string][ref][in] */ __RPC__in_ecount_full(cItems) LPCWSTR *ppszItemIDs,
            /* [in] */ ULONG cItems,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ __RPC__in_opt ISyncMgrSessionCreator *pSessionCreator,
            /* [unique][in] */ __RPC__in_opt IUnknown *punk);
        
        END_INTERFACE
    } ISyncMgrHandlerVtbl;

    interface ISyncMgrHandler
    {
        CONST_VTBL struct ISyncMgrHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrHandler_GetName(This,ppszName)	\
    ( (This)->lpVtbl -> GetName(This,ppszName) ) 

#define ISyncMgrHandler_GetHandlerInfo(This,ppHandlerInfo)	\
    ( (This)->lpVtbl -> GetHandlerInfo(This,ppHandlerInfo) ) 

#define ISyncMgrHandler_GetObject(This,rguidObjectID,riid,ppv)	\
    ( (This)->lpVtbl -> GetObject(This,rguidObjectID,riid,ppv) ) 

#define ISyncMgrHandler_GetCapabilities(This,pmCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pmCapabilities) ) 

#define ISyncMgrHandler_GetPolicies(This,pmPolicies)	\
    ( (This)->lpVtbl -> GetPolicies(This,pmPolicies) ) 

#define ISyncMgrHandler_Activate(This,fActivate)	\
    ( (This)->lpVtbl -> Activate(This,fActivate) ) 

#define ISyncMgrHandler_Enable(This,fEnable)	\
    ( (This)->lpVtbl -> Enable(This,fEnable) ) 

#define ISyncMgrHandler_Synchronize(This,ppszItemIDs,cItems,hwndOwner,pSessionCreator,punk)	\
    ( (This)->lpVtbl -> Synchronize(This,ppszItemIDs,cItems,hwndOwner,pSessionCreator,punk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0002 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum SYNCMGR_HANDLER_TYPE
    {	SYNCMGR_HT_UNSPECIFIED	= 0,
	SYNCMGR_HT_APPLICATION	= 1,
	SYNCMGR_HT_DEVICE	= 2,
	SYNCMGR_HT_FOLDER	= 3,
	SYNCMGR_HT_SERVICE	= 4,
	SYNCMGR_HT_COMPUTER	= 5,
	SYNCMGR_HT_MIN	= 0,
	SYNCMGR_HT_MAX	= SYNCMGR_HT_COMPUTER
    } 	SYNCMGR_HANDLER_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0002_v0_0_s_ifspec;

#ifndef __ISyncMgrHandlerInfo_INTERFACE_DEFINED__
#define __ISyncMgrHandlerInfo_INTERFACE_DEFINED__

/* interface ISyncMgrHandlerInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrHandlerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4ff1d798-ecf7-4524-aa81-1e362a0aef3a")
    ISyncMgrHandlerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ __RPC__out SYNCMGR_HANDLER_TYPE *pnType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeLabel( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTypeLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComment( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszComment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastSyncTime( 
            /* [out] */ __RPC__out FILETIME *pftLastSync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsConnected( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrHandlerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrHandlerInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrHandlerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrHandlerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ISyncMgrHandlerInfo * This,
            /* [out] */ __RPC__out SYNCMGR_HANDLER_TYPE *pnType);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLabel )( 
            ISyncMgrHandlerInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTypeLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetComment )( 
            ISyncMgrHandlerInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszComment);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastSyncTime )( 
            ISyncMgrHandlerInfo * This,
            /* [out] */ __RPC__out FILETIME *pftLastSync);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ISyncMgrHandlerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabled )( 
            ISyncMgrHandlerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsConnected )( 
            ISyncMgrHandlerInfo * This);
        
        END_INTERFACE
    } ISyncMgrHandlerInfoVtbl;

    interface ISyncMgrHandlerInfo
    {
        CONST_VTBL struct ISyncMgrHandlerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrHandlerInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrHandlerInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrHandlerInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrHandlerInfo_GetType(This,pnType)	\
    ( (This)->lpVtbl -> GetType(This,pnType) ) 

#define ISyncMgrHandlerInfo_GetTypeLabel(This,ppszTypeLabel)	\
    ( (This)->lpVtbl -> GetTypeLabel(This,ppszTypeLabel) ) 

#define ISyncMgrHandlerInfo_GetComment(This,ppszComment)	\
    ( (This)->lpVtbl -> GetComment(This,ppszComment) ) 

#define ISyncMgrHandlerInfo_GetLastSyncTime(This,pftLastSync)	\
    ( (This)->lpVtbl -> GetLastSyncTime(This,pftLastSync) ) 

#define ISyncMgrHandlerInfo_IsActive(This)	\
    ( (This)->lpVtbl -> IsActive(This) ) 

#define ISyncMgrHandlerInfo_IsEnabled(This)	\
    ( (This)->lpVtbl -> IsEnabled(This) ) 

#define ISyncMgrHandlerInfo_IsConnected(This)	\
    ( (This)->lpVtbl -> IsConnected(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrHandlerInfo_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrSyncItemContainer_INTERFACE_DEFINED__
#define __ISyncMgrSyncItemContainer_INTERFACE_DEFINED__

/* interface ISyncMgrSyncItemContainer */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrSyncItemContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("90701133-be32-4129-a65c-99e616cafff4")
    ISyncMgrSyncItemContainer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSyncItem( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID,
            /* [out] */ __RPC__deref_out_opt ISyncMgrSyncItem **ppItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncItemEnumerator( 
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrSyncItems **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncItemCount( 
            /* [out] */ __RPC__out ULONG *pcItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrSyncItemContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrSyncItemContainer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrSyncItemContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrSyncItemContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncItem )( 
            ISyncMgrSyncItemContainer * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID,
            /* [out] */ __RPC__deref_out_opt ISyncMgrSyncItem **ppItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncItemEnumerator )( 
            ISyncMgrSyncItemContainer * This,
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrSyncItems **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncItemCount )( 
            ISyncMgrSyncItemContainer * This,
            /* [out] */ __RPC__out ULONG *pcItems);
        
        END_INTERFACE
    } ISyncMgrSyncItemContainerVtbl;

    interface ISyncMgrSyncItemContainer
    {
        CONST_VTBL struct ISyncMgrSyncItemContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrSyncItemContainer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrSyncItemContainer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrSyncItemContainer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrSyncItemContainer_GetSyncItem(This,pszItemID,ppItem)	\
    ( (This)->lpVtbl -> GetSyncItem(This,pszItemID,ppItem) ) 

#define ISyncMgrSyncItemContainer_GetSyncItemEnumerator(This,ppenum)	\
    ( (This)->lpVtbl -> GetSyncItemEnumerator(This,ppenum) ) 

#define ISyncMgrSyncItemContainer_GetSyncItemCount(This,pcItems)	\
    ( (This)->lpVtbl -> GetSyncItemCount(This,pcItems) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrSyncItemContainer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0004 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum SYNCMGR_ITEM_CAPABILITIES
    {	SYNCMGR_ICM_NONE	= 0,
	SYNCMGR_ICM_PROVIDES_ICON	= 0x1,
	SYNCMGR_ICM_EVENT_STORE	= 0x2,
	SYNCMGR_ICM_CONFLICT_STORE	= 0x4,
	SYNCMGR_ICM_CAN_DELETE	= 0x10,
	SYNCMGR_ICM_CAN_BROWSE_CONTENT	= 0x10000,
	SYNCMGR_ICM_QUERY_BEFORE_ENABLE	= 0x100000,
	SYNCMGR_ICM_QUERY_BEFORE_DISABLE	= 0x200000,
	SYNCMGR_ICM_QUERY_BEFORE_DELETE	= 0x400000,
	SYNCMGR_ICM_VALID_MASK	= 0x710017
    } 	SYNCMGR_ITEM_CAPABILITIES;

typedef /* [v1_enum] */ 
enum SYNCMGR_ITEM_POLICIES
    {	SYNCMGR_IPM_NONE	= 0,
	SYNCMGR_IPM_PREVENT_ENABLE	= 0x1,
	SYNCMGR_IPM_PREVENT_DISABLE	= 0x2,
	SYNCMGR_IPM_PREVENT_START_SYNC	= 0x4,
	SYNCMGR_IPM_PREVENT_STOP_SYNC	= 0x8,
	SYNCMGR_IPM_DISABLE_ENABLE	= 0x10,
	SYNCMGR_IPM_DISABLE_DISABLE	= 0x20,
	SYNCMGR_IPM_DISABLE_START_SYNC	= 0x40,
	SYNCMGR_IPM_DISABLE_STOP_SYNC	= 0x80,
	SYNCMGR_IPM_DISABLE_BROWSE	= 0x100,
	SYNCMGR_IPM_DISABLE_DELETE	= 0x200,
	SYNCMGR_IPM_HIDDEN_BY_DEFAULT	= 0x10000,
	SYNCMGR_IPM_VALID_MASK	= 0x102ff
    } 	SYNCMGR_ITEM_POLICIES;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0004_v0_0_s_ifspec;

#ifndef __ISyncMgrSyncItem_INTERFACE_DEFINED__
#define __ISyncMgrSyncItem_INTERFACE_DEFINED__

/* interface ISyncMgrSyncItem */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrSyncItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b20b24ce-2593-4f04-bd8b-7ad6c45051cd")
    ISyncMgrSyncItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetItemID( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemInfo( 
            /* [out] */ __RPC__deref_out_opt ISyncMgrSyncItemInfo **ppItemInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ __RPC__in REFGUID rguidObjectID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCapabilities( 
            /* [out] */ __RPC__out SYNCMGR_ITEM_CAPABILITIES *pmCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPolicies( 
            /* [out] */ __RPC__out SYNCMGR_ITEM_POLICIES *pmPolicies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrSyncItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrSyncItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrSyncItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrSyncItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemID )( 
            ISyncMgrSyncItem * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszItemID);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISyncMgrSyncItem * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemInfo )( 
            ISyncMgrSyncItem * This,
            /* [out] */ __RPC__deref_out_opt ISyncMgrSyncItemInfo **ppItemInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ISyncMgrSyncItem * This,
            /* [in] */ __RPC__in REFGUID rguidObjectID,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetCapabilities )( 
            ISyncMgrSyncItem * This,
            /* [out] */ __RPC__out SYNCMGR_ITEM_CAPABILITIES *pmCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *GetPolicies )( 
            ISyncMgrSyncItem * This,
            /* [out] */ __RPC__out SYNCMGR_ITEM_POLICIES *pmPolicies);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            ISyncMgrSyncItem * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            ISyncMgrSyncItem * This);
        
        END_INTERFACE
    } ISyncMgrSyncItemVtbl;

    interface ISyncMgrSyncItem
    {
        CONST_VTBL struct ISyncMgrSyncItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrSyncItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrSyncItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrSyncItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrSyncItem_GetItemID(This,ppszItemID)	\
    ( (This)->lpVtbl -> GetItemID(This,ppszItemID) ) 

#define ISyncMgrSyncItem_GetName(This,ppszName)	\
    ( (This)->lpVtbl -> GetName(This,ppszName) ) 

#define ISyncMgrSyncItem_GetItemInfo(This,ppItemInfo)	\
    ( (This)->lpVtbl -> GetItemInfo(This,ppItemInfo) ) 

#define ISyncMgrSyncItem_GetObject(This,rguidObjectID,riid,ppv)	\
    ( (This)->lpVtbl -> GetObject(This,rguidObjectID,riid,ppv) ) 

#define ISyncMgrSyncItem_GetCapabilities(This,pmCapabilities)	\
    ( (This)->lpVtbl -> GetCapabilities(This,pmCapabilities) ) 

#define ISyncMgrSyncItem_GetPolicies(This,pmPolicies)	\
    ( (This)->lpVtbl -> GetPolicies(This,pmPolicies) ) 

#define ISyncMgrSyncItem_Enable(This,fEnable)	\
    ( (This)->lpVtbl -> Enable(This,fEnable) ) 

#define ISyncMgrSyncItem_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrSyncItem_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrSyncItemInfo_INTERFACE_DEFINED__
#define __ISyncMgrSyncItemInfo_INTERFACE_DEFINED__

/* interface ISyncMgrSyncItemInfo */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrSyncItemInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e7fd9502-be0c-4464-90a1-2b5277031232")
    ISyncMgrSyncItemInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTypeLabel( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTypeLabel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComment( 
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszComment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastSyncTime( 
            /* [out] */ __RPC__out FILETIME *pftLastSync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsConnected( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrSyncItemInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrSyncItemInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrSyncItemInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrSyncItemInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeLabel )( 
            ISyncMgrSyncItemInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszTypeLabel);
        
        HRESULT ( STDMETHODCALLTYPE *GetComment )( 
            ISyncMgrSyncItemInfo * This,
            /* [string][out] */ __RPC__deref_out_opt_string LPWSTR *ppszComment);
        
        HRESULT ( STDMETHODCALLTYPE *GetLastSyncTime )( 
            ISyncMgrSyncItemInfo * This,
            /* [out] */ __RPC__out FILETIME *pftLastSync);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabled )( 
            ISyncMgrSyncItemInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsConnected )( 
            ISyncMgrSyncItemInfo * This);
        
        END_INTERFACE
    } ISyncMgrSyncItemInfoVtbl;

    interface ISyncMgrSyncItemInfo
    {
        CONST_VTBL struct ISyncMgrSyncItemInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrSyncItemInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrSyncItemInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrSyncItemInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrSyncItemInfo_GetTypeLabel(This,ppszTypeLabel)	\
    ( (This)->lpVtbl -> GetTypeLabel(This,ppszTypeLabel) ) 

#define ISyncMgrSyncItemInfo_GetComment(This,ppszComment)	\
    ( (This)->lpVtbl -> GetComment(This,ppszComment) ) 

#define ISyncMgrSyncItemInfo_GetLastSyncTime(This,pftLastSync)	\
    ( (This)->lpVtbl -> GetLastSyncTime(This,pftLastSync) ) 

#define ISyncMgrSyncItemInfo_IsEnabled(This)	\
    ( (This)->lpVtbl -> IsEnabled(This) ) 

#define ISyncMgrSyncItemInfo_IsConnected(This)	\
    ( (This)->lpVtbl -> IsConnected(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrSyncItemInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumSyncMgrSyncItems_INTERFACE_DEFINED__
#define __IEnumSyncMgrSyncItems_INTERFACE_DEFINED__

/* interface IEnumSyncMgrSyncItems */
/* [uuid][object] */ 


EXTERN_C const IID IID_IEnumSyncMgrSyncItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54b3abf3-f085-4181-b546-e29c403c726b")
    IEnumSyncMgrSyncItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ISyncMgrSyncItem **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrSyncItems **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSyncMgrSyncItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSyncMgrSyncItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSyncMgrSyncItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSyncMgrSyncItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSyncMgrSyncItems * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ISyncMgrSyncItem **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSyncMgrSyncItems * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSyncMgrSyncItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSyncMgrSyncItems * This,
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrSyncItems **ppenum);
        
        END_INTERFACE
    } IEnumSyncMgrSyncItemsVtbl;

    interface IEnumSyncMgrSyncItems
    {
        CONST_VTBL struct IEnumSyncMgrSyncItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSyncMgrSyncItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSyncMgrSyncItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSyncMgrSyncItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSyncMgrSyncItems_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSyncMgrSyncItems_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSyncMgrSyncItems_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSyncMgrSyncItems_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSyncMgrSyncItems_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0007 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum SYNCMGR_PROGRESS_STATUS
    {	SYNCMGR_PS_UPDATING	= 1,
	SYNCMGR_PS_UPDATING_INDETERMINATE	= 2,
	SYNCMGR_PS_SUCCEEDED	= 3,
	SYNCMGR_PS_FAILED	= 4,
	SYNCMGR_PS_CANCELED	= 5,
	SYNCMGR_PS_DISCONNECTED	= 6,
	SYNCMGR_PS_MAX	= SYNCMGR_PS_DISCONNECTED
    } 	SYNCMGR_PROGRESS_STATUS;

typedef /* [v1_enum] */ 
enum SYNCMGR_CANCEL_REQUEST
    {	SYNCMGR_CR_NONE	= 0,
	SYNCMGR_CR_CANCEL_ITEM	= 1,
	SYNCMGR_CR_CANCEL_ALL	= 2,
	SYNCMGR_CR_MAX	= SYNCMGR_CR_CANCEL_ALL
    } 	SYNCMGR_CANCEL_REQUEST;

typedef /* [v1_enum] */ 
enum SYNCMGR_EVENT_LEVEL
    {	SYNCMGR_EL_INFORMATION	= 1,
	SYNCMGR_EL_WARNING	= 2,
	SYNCMGR_EL_ERROR	= 3,
	SYNCMGR_EL_MAX	= SYNCMGR_EL_ERROR
    } 	SYNCMGR_EVENT_LEVEL;

typedef /* [v1_enum] */ 
enum SYNCMGR_EVENT_FLAGS
    {	SYNCMGR_EF_NONE	= 0,
	SYNCMGR_EF_VALID	= 0
    } 	SYNCMGR_EVENT_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0007_v0_0_s_ifspec;

#ifndef __ISyncMgrSessionCreator_INTERFACE_DEFINED__
#define __ISyncMgrSessionCreator_INTERFACE_DEFINED__

/* interface ISyncMgrSessionCreator */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrSessionCreator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17f48517-f305-4321-a08d-b25a834918fd")
    ISyncMgrSessionCreator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [size_is][string][unique][in] */ __RPC__in_ecount_full_opt(cItems) LPCWSTR *ppszItemIDs,
            /* [in] */ ULONG cItems,
            /* [out] */ __RPC__deref_out_opt ISyncMgrSyncCallback **ppCallback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrSessionCreatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrSessionCreator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrSessionCreator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrSessionCreator * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSession )( 
            ISyncMgrSessionCreator * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [size_is][string][unique][in] */ __RPC__in_ecount_full_opt(cItems) LPCWSTR *ppszItemIDs,
            /* [in] */ ULONG cItems,
            /* [out] */ __RPC__deref_out_opt ISyncMgrSyncCallback **ppCallback);
        
        END_INTERFACE
    } ISyncMgrSessionCreatorVtbl;

    interface ISyncMgrSessionCreator
    {
        CONST_VTBL struct ISyncMgrSessionCreatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrSessionCreator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrSessionCreator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrSessionCreator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrSessionCreator_CreateSession(This,pszHandlerID,ppszItemIDs,cItems,ppCallback)	\
    ( (This)->lpVtbl -> CreateSession(This,pszHandlerID,ppszItemIDs,cItems,ppCallback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrSessionCreator_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrSyncCallback_INTERFACE_DEFINED__
#define __ISyncMgrSyncCallback_INTERFACE_DEFINED__

/* interface ISyncMgrSyncCallback */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrSyncCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("884ccd87-b139-4937-a4ba-4f8e19513fbe")
    ISyncMgrSyncCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReportProgress( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszProgressText,
            /* [in] */ SYNCMGR_PROGRESS_STATUS nStatus,
            /* [in] */ ULONG uCurrentStep,
            /* [in] */ ULONG uMaxStep,
            /* [unique][out][in] */ __RPC__inout_opt SYNCMGR_CANCEL_REQUEST *pnCancelRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHandlerProgressText( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszProgressText,
            /* [unique][out][in] */ __RPC__inout_opt SYNCMGR_CANCEL_REQUEST *pnCancelRequest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportEvent( 
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [in] */ SYNCMGR_EVENT_LEVEL nLevel,
            /* [in] */ SYNCMGR_EVENT_FLAGS nFlags,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszName,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszDescription,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszLinkText,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszLinkReference,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszContext,
            /* [out] */ __RPC__out GUID *pguidEventID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanContinue( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryForAdditionalItems( 
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumItemIDs,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppenumPunks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddItemToSession( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddIUnknownToSession( 
            /* [in] */ __RPC__in_opt IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProposeItem( 
            /* [in] */ __RPC__in_opt ISyncMgrSyncItem *pNewItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitItem( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportManualSync( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrSyncCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrSyncCallback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrSyncCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrSyncCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReportProgress )( 
            ISyncMgrSyncCallback * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszProgressText,
            /* [in] */ SYNCMGR_PROGRESS_STATUS nStatus,
            /* [in] */ ULONG uCurrentStep,
            /* [in] */ ULONG uMaxStep,
            /* [unique][out][in] */ __RPC__inout_opt SYNCMGR_CANCEL_REQUEST *pnCancelRequest);
        
        HRESULT ( STDMETHODCALLTYPE *SetHandlerProgressText )( 
            ISyncMgrSyncCallback * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszProgressText,
            /* [unique][out][in] */ __RPC__inout_opt SYNCMGR_CANCEL_REQUEST *pnCancelRequest);
        
        HRESULT ( STDMETHODCALLTYPE *ReportEvent )( 
            ISyncMgrSyncCallback * This,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [in] */ SYNCMGR_EVENT_LEVEL nLevel,
            /* [in] */ SYNCMGR_EVENT_FLAGS nFlags,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszName,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszDescription,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszLinkText,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszLinkReference,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszContext,
            /* [out] */ __RPC__out GUID *pguidEventID);
        
        HRESULT ( STDMETHODCALLTYPE *CanContinue )( 
            ISyncMgrSyncCallback * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID);
        
        HRESULT ( STDMETHODCALLTYPE *QueryForAdditionalItems )( 
            ISyncMgrSyncCallback * This,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppenumItemIDs,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppenumPunks);
        
        HRESULT ( STDMETHODCALLTYPE *AddItemToSession )( 
            ISyncMgrSyncCallback * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID);
        
        HRESULT ( STDMETHODCALLTYPE *AddIUnknownToSession )( 
            ISyncMgrSyncCallback * This,
            /* [in] */ __RPC__in_opt IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *ProposeItem )( 
            ISyncMgrSyncCallback * This,
            /* [in] */ __RPC__in_opt ISyncMgrSyncItem *pNewItem);
        
        HRESULT ( STDMETHODCALLTYPE *CommitItem )( 
            ISyncMgrSyncCallback * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID);
        
        HRESULT ( STDMETHODCALLTYPE *ReportManualSync )( 
            ISyncMgrSyncCallback * This);
        
        END_INTERFACE
    } ISyncMgrSyncCallbackVtbl;

    interface ISyncMgrSyncCallback
    {
        CONST_VTBL struct ISyncMgrSyncCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrSyncCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrSyncCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrSyncCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrSyncCallback_ReportProgress(This,pszItemID,pszProgressText,nStatus,uCurrentStep,uMaxStep,pnCancelRequest)	\
    ( (This)->lpVtbl -> ReportProgress(This,pszItemID,pszProgressText,nStatus,uCurrentStep,uMaxStep,pnCancelRequest) ) 

#define ISyncMgrSyncCallback_SetHandlerProgressText(This,pszProgressText,pnCancelRequest)	\
    ( (This)->lpVtbl -> SetHandlerProgressText(This,pszProgressText,pnCancelRequest) ) 

#define ISyncMgrSyncCallback_ReportEvent(This,pszItemID,nLevel,nFlags,pszName,pszDescription,pszLinkText,pszLinkReference,pszContext,pguidEventID)	\
    ( (This)->lpVtbl -> ReportEvent(This,pszItemID,nLevel,nFlags,pszName,pszDescription,pszLinkText,pszLinkReference,pszContext,pguidEventID) ) 

#define ISyncMgrSyncCallback_CanContinue(This,pszItemID)	\
    ( (This)->lpVtbl -> CanContinue(This,pszItemID) ) 

#define ISyncMgrSyncCallback_QueryForAdditionalItems(This,ppenumItemIDs,ppenumPunks)	\
    ( (This)->lpVtbl -> QueryForAdditionalItems(This,ppenumItemIDs,ppenumPunks) ) 

#define ISyncMgrSyncCallback_AddItemToSession(This,pszItemID)	\
    ( (This)->lpVtbl -> AddItemToSession(This,pszItemID) ) 

#define ISyncMgrSyncCallback_AddIUnknownToSession(This,punk)	\
    ( (This)->lpVtbl -> AddIUnknownToSession(This,punk) ) 

#define ISyncMgrSyncCallback_ProposeItem(This,pNewItem)	\
    ( (This)->lpVtbl -> ProposeItem(This,pNewItem) ) 

#define ISyncMgrSyncCallback_CommitItem(This,pszItemID)	\
    ( (This)->lpVtbl -> CommitItem(This,pszItemID) ) 

#define ISyncMgrSyncCallback_ReportManualSync(This)	\
    ( (This)->lpVtbl -> ReportManualSync(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrSyncCallback_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrUIOperation_INTERFACE_DEFINED__
#define __ISyncMgrUIOperation_INTERFACE_DEFINED__

/* interface ISyncMgrUIOperation */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrUIOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc7cfa47-dfe1-45b5-a049-8cfd82bec271")
    ISyncMgrUIOperation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ __RPC__in HWND hwndOwner) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrUIOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrUIOperation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrUIOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrUIOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            ISyncMgrUIOperation * This,
            /* [in] */ __RPC__in HWND hwndOwner);
        
        END_INTERFACE
    } ISyncMgrUIOperationVtbl;

    interface ISyncMgrUIOperation
    {
        CONST_VTBL struct ISyncMgrUIOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrUIOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrUIOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrUIOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrUIOperation_Run(This,hwndOwner)	\
    ( (This)->lpVtbl -> Run(This,hwndOwner) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrUIOperation_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrEventLinkUIOperation_INTERFACE_DEFINED__
#define __ISyncMgrEventLinkUIOperation_INTERFACE_DEFINED__

/* interface ISyncMgrEventLinkUIOperation */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrEventLinkUIOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("64522e52-848b-4015-89ce-5a36f00b94ff")
    ISyncMgrEventLinkUIOperation : public ISyncMgrUIOperation
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ __RPC__in REFGUID rguidEventID,
            /* [in] */ __RPC__in_opt ISyncMgrEvent *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrEventLinkUIOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrEventLinkUIOperation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrEventLinkUIOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrEventLinkUIOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            ISyncMgrEventLinkUIOperation * This,
            /* [in] */ __RPC__in HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISyncMgrEventLinkUIOperation * This,
            /* [in] */ __RPC__in REFGUID rguidEventID,
            /* [in] */ __RPC__in_opt ISyncMgrEvent *pEvent);
        
        END_INTERFACE
    } ISyncMgrEventLinkUIOperationVtbl;

    interface ISyncMgrEventLinkUIOperation
    {
        CONST_VTBL struct ISyncMgrEventLinkUIOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrEventLinkUIOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrEventLinkUIOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrEventLinkUIOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrEventLinkUIOperation_Run(This,hwndOwner)	\
    ( (This)->lpVtbl -> Run(This,hwndOwner) ) 


#define ISyncMgrEventLinkUIOperation_Init(This,rguidEventID,pEvent)	\
    ( (This)->lpVtbl -> Init(This,rguidEventID,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrEventLinkUIOperation_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrScheduleWizardUIOperation_INTERFACE_DEFINED__
#define __ISyncMgrScheduleWizardUIOperation_INTERFACE_DEFINED__

/* interface ISyncMgrScheduleWizardUIOperation */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrScheduleWizardUIOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("459a6c84-21d2-4ddc-8a53-f023a46066f2")
    ISyncMgrScheduleWizardUIOperation : public ISyncMgrUIOperation
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitWizard( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrScheduleWizardUIOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrScheduleWizardUIOperation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrScheduleWizardUIOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrScheduleWizardUIOperation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            ISyncMgrScheduleWizardUIOperation * This,
            /* [in] */ __RPC__in HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE *InitWizard )( 
            ISyncMgrScheduleWizardUIOperation * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID);
        
        END_INTERFACE
    } ISyncMgrScheduleWizardUIOperationVtbl;

    interface ISyncMgrScheduleWizardUIOperation
    {
        CONST_VTBL struct ISyncMgrScheduleWizardUIOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrScheduleWizardUIOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrScheduleWizardUIOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrScheduleWizardUIOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrScheduleWizardUIOperation_Run(This,hwndOwner)	\
    ( (This)->lpVtbl -> Run(This,hwndOwner) ) 


#define ISyncMgrScheduleWizardUIOperation_InitWizard(This,pszHandlerID)	\
    ( (This)->lpVtbl -> InitWizard(This,pszHandlerID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrScheduleWizardUIOperation_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrSyncResult_INTERFACE_DEFINED__
#define __ISyncMgrSyncResult_INTERFACE_DEFINED__

/* interface ISyncMgrSyncResult */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrSyncResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2b90f17e-5a3e-4b33-bb7f-1bc48056b94d")
    ISyncMgrSyncResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Result( 
            /* [in] */ SYNCMGR_PROGRESS_STATUS nStatus,
            /* [in] */ UINT cError,
            /* [in] */ UINT cConflicts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrSyncResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrSyncResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrSyncResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrSyncResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *Result )( 
            ISyncMgrSyncResult * This,
            /* [in] */ SYNCMGR_PROGRESS_STATUS nStatus,
            /* [in] */ UINT cError,
            /* [in] */ UINT cConflicts);
        
        END_INTERFACE
    } ISyncMgrSyncResultVtbl;

    interface ISyncMgrSyncResult
    {
        CONST_VTBL struct ISyncMgrSyncResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrSyncResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrSyncResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrSyncResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrSyncResult_Result(This,nStatus,cError,cConflicts)	\
    ( (This)->lpVtbl -> Result(This,nStatus,cError,cConflicts) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrSyncResult_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0013 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum SYNCMGR_CONTROL_FLAGS
    {	SYNCMGR_CF_NONE	= 0,
	SYNCMGR_CF_NOWAIT	= 0,
	SYNCMGR_CF_WAIT	= 0x1,
	SYNCMGR_CF_NOUI	= 0x2,
	SYNCMGR_CF_VALID	= 0x3
    } 	SYNCMGR_CONTROL_FLAGS;

typedef /* [v1_enum] */ 
enum SYNCMGR_SYNC_CONTROL_FLAGS
    {	SYNCMGR_SCF_NONE	= 0,
	SYNCMGR_SCF_IGNORE_IF_ALREADY_SYNCING	= 0x1,
	SYNCMGR_SCF_VALID	= 0x1
    } 	SYNCMGR_SYNC_CONTROL_FLAGS;

typedef /* [v1_enum] */ 
enum SYNCMGR_UPDATE_REASON
    {	SYNCMGR_UR_ADDED	= 0,
	SYNCMGR_UR_CHANGED	= 1,
	SYNCMGR_UR_REMOVED	= 2,
	SYNCMGR_UR_MAX	= SYNCMGR_UR_REMOVED
    } 	SYNCMGR_UPDATE_REASON;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0013_v0_0_s_ifspec;

#ifndef __ISyncMgrControl_INTERFACE_DEFINED__
#define __ISyncMgrControl_INTERFACE_DEFINED__

/* interface ISyncMgrControl */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B63616C-36B2-46BC-959F-C1593952D19B")
    ISyncMgrControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StartHandlerSync( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [unique][in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ SYNCMGR_SYNC_CONTROL_FLAGS nSyncControlFlags,
            /* [unique][in] */ __RPC__in_opt ISyncMgrSyncResult *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartItemSync( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [size_is][string][ref][in] */ __RPC__in_ecount_full(cItems) LPCWSTR *ppszItemIDs,
            /* [in] */ ULONG cItems,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [unique][in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ SYNCMGR_SYNC_CONTROL_FLAGS nSyncControlFlags,
            /* [unique][in] */ __RPC__in_opt ISyncMgrSyncResult *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartSyncAll( 
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopHandlerSync( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopItemSync( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [size_is][string][ref][in] */ __RPC__in_ecount_full(cItems) LPCWSTR *ppszItemIDs,
            /* [in] */ ULONG cItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopSyncAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateHandlerCollection( 
            /* [in] */ __RPC__in REFCLSID rclsidCollectionID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateHandler( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateItem( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateEvents( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateConflict( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [in] */ __RPC__in_opt ISyncMgrConflict *pConflict,
            /* [in] */ SYNCMGR_UPDATE_REASON nReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateConflicts( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ActivateHandler( 
            /* [in] */ BOOL fActivate,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableHandler( 
            /* [in] */ BOOL fEnable,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableItem( 
            /* [in] */ BOOL fEnable,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartHandlerSync )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [unique][in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ SYNCMGR_SYNC_CONTROL_FLAGS nSyncControlFlags,
            /* [unique][in] */ __RPC__in_opt ISyncMgrSyncResult *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *StartItemSync )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [size_is][string][ref][in] */ __RPC__in_ecount_full(cItems) LPCWSTR *ppszItemIDs,
            /* [in] */ ULONG cItems,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [unique][in] */ __RPC__in_opt IUnknown *punk,
            /* [in] */ SYNCMGR_SYNC_CONTROL_FLAGS nSyncControlFlags,
            /* [unique][in] */ __RPC__in_opt ISyncMgrSyncResult *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *StartSyncAll )( 
            ISyncMgrControl * This,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner);
        
        HRESULT ( STDMETHODCALLTYPE *StopHandlerSync )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID);
        
        HRESULT ( STDMETHODCALLTYPE *StopItemSync )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [size_is][string][ref][in] */ __RPC__in_ecount_full(cItems) LPCWSTR *ppszItemIDs,
            /* [in] */ ULONG cItems);
        
        HRESULT ( STDMETHODCALLTYPE *StopSyncAll )( 
            ISyncMgrControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateHandlerCollection )( 
            ISyncMgrControl * This,
            /* [in] */ __RPC__in REFCLSID rclsidCollectionID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateHandler )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateItem )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateEvents )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateConflict )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [in] */ __RPC__in_opt ISyncMgrConflict *pConflict,
            /* [in] */ SYNCMGR_UPDATE_REASON nReason);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateConflicts )( 
            ISyncMgrControl * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ActivateHandler )( 
            ISyncMgrControl * This,
            /* [in] */ BOOL fActivate,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags);
        
        HRESULT ( STDMETHODCALLTYPE *EnableHandler )( 
            ISyncMgrControl * This,
            /* [in] */ BOOL fEnable,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags);
        
        HRESULT ( STDMETHODCALLTYPE *EnableItem )( 
            ISyncMgrControl * This,
            /* [in] */ BOOL fEnable,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszItemID,
            /* [unique][in] */ __RPC__in_opt HWND hwndOwner,
            /* [in] */ SYNCMGR_CONTROL_FLAGS nControlFlags);
        
        END_INTERFACE
    } ISyncMgrControlVtbl;

    interface ISyncMgrControl
    {
        CONST_VTBL struct ISyncMgrControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrControl_StartHandlerSync(This,pszHandlerID,hwndOwner,punk,nSyncControlFlags,pResult)	\
    ( (This)->lpVtbl -> StartHandlerSync(This,pszHandlerID,hwndOwner,punk,nSyncControlFlags,pResult) ) 

#define ISyncMgrControl_StartItemSync(This,pszHandlerID,ppszItemIDs,cItems,hwndOwner,punk,nSyncControlFlags,pResult)	\
    ( (This)->lpVtbl -> StartItemSync(This,pszHandlerID,ppszItemIDs,cItems,hwndOwner,punk,nSyncControlFlags,pResult) ) 

#define ISyncMgrControl_StartSyncAll(This,hwndOwner)	\
    ( (This)->lpVtbl -> StartSyncAll(This,hwndOwner) ) 

#define ISyncMgrControl_StopHandlerSync(This,pszHandlerID)	\
    ( (This)->lpVtbl -> StopHandlerSync(This,pszHandlerID) ) 

#define ISyncMgrControl_StopItemSync(This,pszHandlerID,ppszItemIDs,cItems)	\
    ( (This)->lpVtbl -> StopItemSync(This,pszHandlerID,ppszItemIDs,cItems) ) 

#define ISyncMgrControl_StopSyncAll(This)	\
    ( (This)->lpVtbl -> StopSyncAll(This) ) 

#define ISyncMgrControl_UpdateHandlerCollection(This,rclsidCollectionID,nControlFlags)	\
    ( (This)->lpVtbl -> UpdateHandlerCollection(This,rclsidCollectionID,nControlFlags) ) 

#define ISyncMgrControl_UpdateHandler(This,pszHandlerID,nControlFlags)	\
    ( (This)->lpVtbl -> UpdateHandler(This,pszHandlerID,nControlFlags) ) 

#define ISyncMgrControl_UpdateItem(This,pszHandlerID,pszItemID,nControlFlags)	\
    ( (This)->lpVtbl -> UpdateItem(This,pszHandlerID,pszItemID,nControlFlags) ) 

#define ISyncMgrControl_UpdateEvents(This,pszHandlerID,pszItemID,nControlFlags)	\
    ( (This)->lpVtbl -> UpdateEvents(This,pszHandlerID,pszItemID,nControlFlags) ) 

#define ISyncMgrControl_UpdateConflict(This,pszHandlerID,pszItemID,pConflict,nReason)	\
    ( (This)->lpVtbl -> UpdateConflict(This,pszHandlerID,pszItemID,pConflict,nReason) ) 

#define ISyncMgrControl_UpdateConflicts(This,pszHandlerID,pszItemID,nControlFlags)	\
    ( (This)->lpVtbl -> UpdateConflicts(This,pszHandlerID,pszItemID,nControlFlags) ) 

#define ISyncMgrControl_ActivateHandler(This,fActivate,pszHandlerID,hwndOwner,nControlFlags)	\
    ( (This)->lpVtbl -> ActivateHandler(This,fActivate,pszHandlerID,hwndOwner,nControlFlags) ) 

#define ISyncMgrControl_EnableHandler(This,fEnable,pszHandlerID,hwndOwner,nControlFlags)	\
    ( (This)->lpVtbl -> EnableHandler(This,fEnable,pszHandlerID,hwndOwner,nControlFlags) ) 

#define ISyncMgrControl_EnableItem(This,fEnable,pszHandlerID,pszItemID,hwndOwner,nControlFlags)	\
    ( (This)->lpVtbl -> EnableItem(This,fEnable,pszHandlerID,pszItemID,hwndOwner,nControlFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrControl_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrEventStore_INTERFACE_DEFINED__
#define __ISyncMgrEventStore_INTERFACE_DEFINED__

/* interface ISyncMgrEventStore */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrEventStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("37e412f9-016e-44c2-81ff-db3add774266")
    ISyncMgrEventStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventEnumerator( 
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrEvents **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventCount( 
            /* [out] */ __RPC__out ULONG *pcEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEvent( 
            /* [in] */ __RPC__in REFGUID rguidEventID,
            /* [out] */ __RPC__deref_out_opt ISyncMgrEvent **ppEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveEvent( 
            /* [size_is][ref][in] */ __RPC__in_ecount_full(cEvents) GUID *pguidEventIDs,
            /* [in] */ ULONG cEvents) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrEventStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrEventStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrEventStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrEventStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventEnumerator )( 
            ISyncMgrEventStore * This,
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrEvents **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventCount )( 
            ISyncMgrEventStore * This,
            /* [out] */ __RPC__out ULONG *pcEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            ISyncMgrEventStore * This,
            /* [in] */ __RPC__in REFGUID rguidEventID,
            /* [out] */ __RPC__deref_out_opt ISyncMgrEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveEvent )( 
            ISyncMgrEventStore * This,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(cEvents) GUID *pguidEventIDs,
            /* [in] */ ULONG cEvents);
        
        END_INTERFACE
    } ISyncMgrEventStoreVtbl;

    interface ISyncMgrEventStore
    {
        CONST_VTBL struct ISyncMgrEventStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrEventStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrEventStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrEventStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrEventStore_GetEventEnumerator(This,ppenum)	\
    ( (This)->lpVtbl -> GetEventEnumerator(This,ppenum) ) 

#define ISyncMgrEventStore_GetEventCount(This,pcEvents)	\
    ( (This)->lpVtbl -> GetEventCount(This,pcEvents) ) 

#define ISyncMgrEventStore_GetEvent(This,rguidEventID,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,rguidEventID,ppEvent) ) 

#define ISyncMgrEventStore_RemoveEvent(This,pguidEventIDs,cEvents)	\
    ( (This)->lpVtbl -> RemoveEvent(This,pguidEventIDs,cEvents) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrEventStore_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrEvent_INTERFACE_DEFINED__
#define __ISyncMgrEvent_INTERFACE_DEFINED__

/* interface ISyncMgrEvent */
/* [uuid][object] */ 


EXTERN_C const IID IID_ISyncMgrEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fee0ef8b-46bd-4db4-b7e6-ff2c687313bc")
    ISyncMgrEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetEventID( 
            /* [ref][out] */ __RPC__out GUID *pguidEventID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandlerID( 
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszHandlerID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemID( 
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszItemID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLevel( 
            /* [ref][out] */ __RPC__out SYNCMGR_EVENT_LEVEL *pnLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [ref][out] */ __RPC__out SYNCMGR_EVENT_FLAGS *pnFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTime( 
            /* [ref][out] */ __RPC__out FILETIME *pfCreationTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkText( 
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszLinkText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkReference( 
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszLinkReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventID )( 
            ISyncMgrEvent * This,
            /* [ref][out] */ __RPC__out GUID *pguidEventID);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandlerID )( 
            ISyncMgrEvent * This,
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszHandlerID);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemID )( 
            ISyncMgrEvent * This,
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszItemID);
        
        HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            ISyncMgrEvent * This,
            /* [ref][out] */ __RPC__out SYNCMGR_EVENT_LEVEL *pnLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            ISyncMgrEvent * This,
            /* [ref][out] */ __RPC__out SYNCMGR_EVENT_FLAGS *pnFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetTime )( 
            ISyncMgrEvent * This,
            /* [ref][out] */ __RPC__out FILETIME *pfCreationTime);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISyncMgrEvent * This,
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ISyncMgrEvent * This,
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkText )( 
            ISyncMgrEvent * This,
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszLinkText);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkReference )( 
            ISyncMgrEvent * This,
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszLinkReference);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ISyncMgrEvent * This,
            /* [string][ref][out] */ __RPC__deref_out_opt_string LPWSTR *ppszContext);
        
        END_INTERFACE
    } ISyncMgrEventVtbl;

    interface ISyncMgrEvent
    {
        CONST_VTBL struct ISyncMgrEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrEvent_GetEventID(This,pguidEventID)	\
    ( (This)->lpVtbl -> GetEventID(This,pguidEventID) ) 

#define ISyncMgrEvent_GetHandlerID(This,ppszHandlerID)	\
    ( (This)->lpVtbl -> GetHandlerID(This,ppszHandlerID) ) 

#define ISyncMgrEvent_GetItemID(This,ppszItemID)	\
    ( (This)->lpVtbl -> GetItemID(This,ppszItemID) ) 

#define ISyncMgrEvent_GetLevel(This,pnLevel)	\
    ( (This)->lpVtbl -> GetLevel(This,pnLevel) ) 

#define ISyncMgrEvent_GetFlags(This,pnFlags)	\
    ( (This)->lpVtbl -> GetFlags(This,pnFlags) ) 

#define ISyncMgrEvent_GetTime(This,pfCreationTime)	\
    ( (This)->lpVtbl -> GetTime(This,pfCreationTime) ) 

#define ISyncMgrEvent_GetName(This,ppszName)	\
    ( (This)->lpVtbl -> GetName(This,ppszName) ) 

#define ISyncMgrEvent_GetDescription(This,ppszDescription)	\
    ( (This)->lpVtbl -> GetDescription(This,ppszDescription) ) 

#define ISyncMgrEvent_GetLinkText(This,ppszLinkText)	\
    ( (This)->lpVtbl -> GetLinkText(This,ppszLinkText) ) 

#define ISyncMgrEvent_GetLinkReference(This,ppszLinkReference)	\
    ( (This)->lpVtbl -> GetLinkReference(This,ppszLinkReference) ) 

#define ISyncMgrEvent_GetContext(This,ppszContext)	\
    ( (This)->lpVtbl -> GetContext(This,ppszContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrEvent_INTERFACE_DEFINED__ */


#ifndef __IEnumSyncMgrEvents_INTERFACE_DEFINED__
#define __IEnumSyncMgrEvents_INTERFACE_DEFINED__

/* interface IEnumSyncMgrEvents */
/* [uuid][object] */ 


EXTERN_C const IID IID_IEnumSyncMgrEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c81a1d4e-8cf7-4683-80e0-bcae88d677b6")
    IEnumSyncMgrEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ISyncMgrEvent **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrEvents **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSyncMgrEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSyncMgrEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSyncMgrEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSyncMgrEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSyncMgrEvents * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ISyncMgrEvent **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSyncMgrEvents * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSyncMgrEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSyncMgrEvents * This,
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrEvents **ppenum);
        
        END_INTERFACE
    } IEnumSyncMgrEventsVtbl;

    interface IEnumSyncMgrEvents
    {
        CONST_VTBL struct IEnumSyncMgrEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSyncMgrEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSyncMgrEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSyncMgrEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSyncMgrEvents_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSyncMgrEvents_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSyncMgrEvents_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSyncMgrEvents_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSyncMgrEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0017 */
/* [local] */ 

typedef struct SYNCMGR_CONFLICT_ID_INFO
    {
    BYTE_BLOB *pblobID;
    BYTE_BLOB *pblobExtra;
    } 	SYNCMGR_CONFLICT_ID_INFO;

typedef struct SYNCMGR_CONFLICT_ID_INFO *PSYNCMGR_CONFLICT_ID_INFO;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0017_v0_0_s_ifspec;

#ifndef __ISyncMgrConflictStore_INTERFACE_DEFINED__
#define __ISyncMgrConflictStore_INTERFACE_DEFINED__

/* interface ISyncMgrConflictStore */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ISyncMgrConflictStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cf8fc579-c396-4774-85f1-d908a831156e")
    ISyncMgrConflictStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumConflicts( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrConflict **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToConflict( 
            /* [in] */ __RPC__in const SYNCMGR_CONFLICT_ID_INFO *pConflictIdInfo,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveConflicts( 
            /* [size_is][in] */ __RPC__in_ecount_full(cConflicts) const SYNCMGR_CONFLICT_ID_INFO *rgConflictIdInfo,
            /* [in] */ DWORD cConflicts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [out] */ __RPC__out DWORD *pnConflicts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrConflictStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrConflictStore * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrConflictStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrConflictStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumConflicts )( 
            ISyncMgrConflictStore * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrConflict **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *BindToConflict )( 
            ISyncMgrConflictStore * This,
            /* [in] */ __RPC__in const SYNCMGR_CONFLICT_ID_INFO *pConflictIdInfo,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveConflicts )( 
            ISyncMgrConflictStore * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cConflicts) const SYNCMGR_CONFLICT_ID_INFO *rgConflictIdInfo,
            /* [in] */ DWORD cConflicts);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ISyncMgrConflictStore * This,
            /* [string][ref][in] */ __RPC__in LPCWSTR pszHandlerID,
            /* [string][unique][in] */ __RPC__in_opt LPCWSTR pszItemID,
            /* [out] */ __RPC__out DWORD *pnConflicts);
        
        END_INTERFACE
    } ISyncMgrConflictStoreVtbl;

    interface ISyncMgrConflictStore
    {
        CONST_VTBL struct ISyncMgrConflictStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrConflictStore_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrConflictStore_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrConflictStore_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrConflictStore_EnumConflicts(This,pszHandlerID,pszItemID,ppEnum)	\
    ( (This)->lpVtbl -> EnumConflicts(This,pszHandlerID,pszItemID,ppEnum) ) 

#define ISyncMgrConflictStore_BindToConflict(This,pConflictIdInfo,riid,ppv)	\
    ( (This)->lpVtbl -> BindToConflict(This,pConflictIdInfo,riid,ppv) ) 

#define ISyncMgrConflictStore_RemoveConflicts(This,rgConflictIdInfo,cConflicts)	\
    ( (This)->lpVtbl -> RemoveConflicts(This,rgConflictIdInfo,cConflicts) ) 

#define ISyncMgrConflictStore_GetCount(This,pszHandlerID,pszItemID,pnConflicts)	\
    ( (This)->lpVtbl -> GetCount(This,pszHandlerID,pszItemID,pnConflicts) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrConflictStore_INTERFACE_DEFINED__ */


#ifndef __IEnumSyncMgrConflict_INTERFACE_DEFINED__
#define __IEnumSyncMgrConflict_INTERFACE_DEFINED__

/* interface IEnumSyncMgrConflict */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IEnumSyncMgrConflict;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("82705914-dda3-4893-ba99-49de6c8c8036")
    IEnumSyncMgrConflict : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ISyncMgrConflict **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrConflict **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSyncMgrConflictVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSyncMgrConflict * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSyncMgrConflict * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSyncMgrConflict * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSyncMgrConflict * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(celt, *pceltFetched) ISyncMgrConflict **rgelt,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSyncMgrConflict * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSyncMgrConflict * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSyncMgrConflict * This,
            /* [out] */ __RPC__deref_out_opt IEnumSyncMgrConflict **ppenum);
        
        END_INTERFACE
    } IEnumSyncMgrConflictVtbl;

    interface IEnumSyncMgrConflict
    {
        CONST_VTBL struct IEnumSyncMgrConflictVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSyncMgrConflict_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSyncMgrConflict_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSyncMgrConflict_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSyncMgrConflict_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumSyncMgrConflict_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSyncMgrConflict_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSyncMgrConflict_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSyncMgrConflict_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0019 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum SYNCMGR_CONFLICT_ITEM_TYPE
    {	SYNCMGR_CIT_UPDATED	= 0x1,
	SYNCMGR_CIT_DELETED	= 0x2
    } 	SYNCMGR_CONFLICT_ITEM_TYPE;

typedef DWORD SYNCMGR_CONFLICT_ITEM_TYPE_FLAG;





extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0019_v0_0_s_ifspec;

#ifndef __ISyncMgrConflict_INTERFACE_DEFINED__
#define __ISyncMgrConflict_INTERFACE_DEFINED__

/* interface ISyncMgrConflict */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ISyncMgrConflict;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c204249-c443-4ba4-85ed-c972681db137")
    ISyncMgrConflict : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConflictIdInfo( 
            /* [out] */ __RPC__out SYNCMGR_CONFLICT_ID_INFO *pConflictIdInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemsArray( 
            /* [out] */ __RPC__deref_out_opt ISyncMgrConflictItems **ppArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ __RPC__in_opt ISyncMgrConflictResolveInfo *pResolveInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolutionHandler( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvResolutionHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrConflictVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrConflict * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrConflict * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrConflict * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            ISyncMgrConflict * This,
            /* [in] */ __RPC__in REFPROPERTYKEY propkey,
            /* [out] */ __RPC__out PROPVARIANT *ppropvar);
        
        HRESULT ( STDMETHODCALLTYPE *GetConflictIdInfo )( 
            ISyncMgrConflict * This,
            /* [out] */ __RPC__out SYNCMGR_CONFLICT_ID_INFO *pConflictIdInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemsArray )( 
            ISyncMgrConflict * This,
            /* [out] */ __RPC__deref_out_opt ISyncMgrConflictItems **ppArray);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            ISyncMgrConflict * This,
            /* [in] */ __RPC__in_opt ISyncMgrConflictResolveInfo *pResolveInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolutionHandler )( 
            ISyncMgrConflict * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvResolutionHandler);
        
        END_INTERFACE
    } ISyncMgrConflictVtbl;

    interface ISyncMgrConflict
    {
        CONST_VTBL struct ISyncMgrConflictVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrConflict_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrConflict_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrConflict_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrConflict_GetProperty(This,propkey,ppropvar)	\
    ( (This)->lpVtbl -> GetProperty(This,propkey,ppropvar) ) 

#define ISyncMgrConflict_GetConflictIdInfo(This,pConflictIdInfo)	\
    ( (This)->lpVtbl -> GetConflictIdInfo(This,pConflictIdInfo) ) 

#define ISyncMgrConflict_GetItemsArray(This,ppArray)	\
    ( (This)->lpVtbl -> GetItemsArray(This,ppArray) ) 

#define ISyncMgrConflict_Resolve(This,pResolveInfo)	\
    ( (This)->lpVtbl -> Resolve(This,pResolveInfo) ) 

#define ISyncMgrConflict_GetResolutionHandler(This,riid,ppvResolutionHandler)	\
    ( (This)->lpVtbl -> GetResolutionHandler(This,riid,ppvResolutionHandler) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrConflict_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0020 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum SYNCMGR_RESOLUTION_ABILITIES
    {	SYNCMGR_RA_KEEPOTHER	= 0x1,
	SYNCMGR_RA_KEEPRECENT	= 0x2,
	SYNCMGR_RA_REMOVEFROMSYNCSET	= 0x4,
	SYNCMGR_RA_KEEP_SINGLE	= 0x8,
	SYNCMGR_RA_KEEP_MULTIPLE	= 0x10,
	SYNCMGR_RA_VALID	= 0x1f
    } 	SYNCMGR_RESOLUTION_ABILITIES;

typedef DWORD SYNCMGR_RESOLUTION_ABILITIES_FLAGS;

typedef /* [v1_enum] */ 
enum SYNCMGR_RESOLUTION_FEEDBACK
    {	SYNCMGR_RF_CONTINUE	= 0,
	SYNCMGR_RF_REFRESH	= ( SYNCMGR_RF_CONTINUE + 1 ) ,
	SYNCMGR_RF_CANCEL	= ( SYNCMGR_RF_REFRESH + 1 ) 
    } 	SYNCMGR_RESOLUTION_FEEDBACK;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0020_v0_0_s_ifspec;

#ifndef __ISyncMgrResolutionHandler_INTERFACE_DEFINED__
#define __ISyncMgrResolutionHandler_INTERFACE_DEFINED__

/* interface ISyncMgrResolutionHandler */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ISyncMgrResolutionHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40A3D052-8BFF-4c4b-A338-D4A395700DE9")
    ISyncMgrResolutionHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryAbilities( 
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_ABILITIES_FLAGS *pdwAbilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeepOther( 
            /* [in] */ __RPC__in_opt IShellItem *psiOther,
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_FEEDBACK *pFeedback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeepRecent( 
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_FEEDBACK *pFeedback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFromSyncSet( 
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_FEEDBACK *pFeedback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeepItems( 
            /* [in] */ __RPC__in_opt ISyncMgrConflictResolutionItems *pArray,
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_FEEDBACK *pFeedback) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrResolutionHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrResolutionHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrResolutionHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrResolutionHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAbilities )( 
            ISyncMgrResolutionHandler * This,
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_ABILITIES_FLAGS *pdwAbilities);
        
        HRESULT ( STDMETHODCALLTYPE *KeepOther )( 
            ISyncMgrResolutionHandler * This,
            /* [in] */ __RPC__in_opt IShellItem *psiOther,
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_FEEDBACK *pFeedback);
        
        HRESULT ( STDMETHODCALLTYPE *KeepRecent )( 
            ISyncMgrResolutionHandler * This,
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_FEEDBACK *pFeedback);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFromSyncSet )( 
            ISyncMgrResolutionHandler * This,
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_FEEDBACK *pFeedback);
        
        HRESULT ( STDMETHODCALLTYPE *KeepItems )( 
            ISyncMgrResolutionHandler * This,
            /* [in] */ __RPC__in_opt ISyncMgrConflictResolutionItems *pArray,
            /* [out] */ __RPC__out SYNCMGR_RESOLUTION_FEEDBACK *pFeedback);
        
        END_INTERFACE
    } ISyncMgrResolutionHandlerVtbl;

    interface ISyncMgrResolutionHandler
    {
        CONST_VTBL struct ISyncMgrResolutionHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrResolutionHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrResolutionHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrResolutionHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrResolutionHandler_QueryAbilities(This,pdwAbilities)	\
    ( (This)->lpVtbl -> QueryAbilities(This,pdwAbilities) ) 

#define ISyncMgrResolutionHandler_KeepOther(This,psiOther,pFeedback)	\
    ( (This)->lpVtbl -> KeepOther(This,psiOther,pFeedback) ) 

#define ISyncMgrResolutionHandler_KeepRecent(This,pFeedback)	\
    ( (This)->lpVtbl -> KeepRecent(This,pFeedback) ) 

#define ISyncMgrResolutionHandler_RemoveFromSyncSet(This,pFeedback)	\
    ( (This)->lpVtbl -> RemoveFromSyncSet(This,pFeedback) ) 

#define ISyncMgrResolutionHandler_KeepItems(This,pArray,pFeedback)	\
    ( (This)->lpVtbl -> KeepItems(This,pArray,pFeedback) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrResolutionHandler_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrConflictPresenter_INTERFACE_DEFINED__
#define __ISyncMgrConflictPresenter_INTERFACE_DEFINED__

/* interface ISyncMgrConflictPresenter */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ISyncMgrConflictPresenter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0b4f5353-fd2b-42cd-8763-4779f2d508a3")
    ISyncMgrConflictPresenter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PresentConflict( 
            /* [in] */ __RPC__in_opt ISyncMgrConflict *pConflict,
            /* [in] */ __RPC__in_opt ISyncMgrConflictResolveInfo *pResolveInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrConflictPresenterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrConflictPresenter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrConflictPresenter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrConflictPresenter * This);
        
        HRESULT ( STDMETHODCALLTYPE *PresentConflict )( 
            ISyncMgrConflictPresenter * This,
            /* [in] */ __RPC__in_opt ISyncMgrConflict *pConflict,
            /* [in] */ __RPC__in_opt ISyncMgrConflictResolveInfo *pResolveInfo);
        
        END_INTERFACE
    } ISyncMgrConflictPresenterVtbl;

    interface ISyncMgrConflictPresenter
    {
        CONST_VTBL struct ISyncMgrConflictPresenterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrConflictPresenter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrConflictPresenter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrConflictPresenter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrConflictPresenter_PresentConflict(This,pConflict,pResolveInfo)	\
    ( (This)->lpVtbl -> PresentConflict(This,pConflict,pResolveInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrConflictPresenter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0022 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum SYNCMGR_PRESENTER_NEXT_STEP
    {	SYNCMGR_PNS_CONTINUE	= 0,
	SYNCMGR_PNS_DEFAULT	= ( SYNCMGR_PNS_CONTINUE + 1 ) ,
	SYNCMGR_PNS_CANCEL	= ( SYNCMGR_PNS_DEFAULT + 1 ) 
    } 	SYNCMGR_PRESENTER_NEXT_STEP;

typedef /* [v1_enum] */ 
enum SYNCMGR_PRESENTER_CHOICE
    {	SYNCMGR_PC_NO_CHOICE	= 0,
	SYNCMGR_PC_KEEP_ONE	= ( SYNCMGR_PC_NO_CHOICE + 1 ) ,
	SYNCMGR_PC_KEEP_MULTIPLE	= ( SYNCMGR_PC_KEEP_ONE + 1 ) ,
	SYNCMGR_PC_KEEP_RECENT	= ( SYNCMGR_PC_KEEP_MULTIPLE + 1 ) ,
	SYNCMGR_PC_REMOVE_FROM_SYNC_SET	= ( SYNCMGR_PC_KEEP_RECENT + 1 ) ,
	SYNCMGR_PC_SKIP	= ( SYNCMGR_PC_REMOVE_FROM_SYNC_SET + 1 ) 
    } 	SYNCMGR_PRESENTER_CHOICE;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0022_v0_0_s_ifspec;

#ifndef __ISyncMgrConflictResolveInfo_INTERFACE_DEFINED__
#define __ISyncMgrConflictResolveInfo_INTERFACE_DEFINED__

/* interface ISyncMgrConflictResolveInfo */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_ISyncMgrConflictResolveInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c405a219-25a2-442e-8743-b845a2cee93f")
    ISyncMgrConflictResolveInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIterationInfo( 
            /* [out] */ UINT *pnCurrentConflict,
            /* [out] */ UINT *pcConflicts,
            /* [out] */ UINT *pcRemainingForApplyToAll) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPresenterNextStep( 
            /* [out] */ SYNCMGR_PRESENTER_NEXT_STEP *pnPresenterNextStep) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPresenterChoice( 
            /* [out] */ SYNCMGR_PRESENTER_CHOICE *pnPresenterChoice,
            /* [out] */ BOOL *pfApplyToAll) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemChoiceCount( 
            /* [out] */ UINT *pcChoices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemChoice( 
            /* [in] */ UINT iChoice,
            /* [out] */ UINT *piChoiceIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPresenterNextStep( 
            /* [in] */ SYNCMGR_PRESENTER_NEXT_STEP nPresenterNextStep) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPresenterChoice( 
            /* [in] */ SYNCMGR_PRESENTER_CHOICE nPresenterChoice,
            /* [in] */ BOOL fApplyToAll) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetItemChoices( 
            /* [size_is][ref][in] */ UINT *prgiConflictItemIndexes,
            /* [in] */ UINT cChoices) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrConflictResolveInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrConflictResolveInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrConflictResolveInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrConflictResolveInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIterationInfo )( 
            ISyncMgrConflictResolveInfo * This,
            /* [out] */ UINT *pnCurrentConflict,
            /* [out] */ UINT *pcConflicts,
            /* [out] */ UINT *pcRemainingForApplyToAll);
        
        HRESULT ( STDMETHODCALLTYPE *GetPresenterNextStep )( 
            ISyncMgrConflictResolveInfo * This,
            /* [out] */ SYNCMGR_PRESENTER_NEXT_STEP *pnPresenterNextStep);
        
        HRESULT ( STDMETHODCALLTYPE *GetPresenterChoice )( 
            ISyncMgrConflictResolveInfo * This,
            /* [out] */ SYNCMGR_PRESENTER_CHOICE *pnPresenterChoice,
            /* [out] */ BOOL *pfApplyToAll);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemChoiceCount )( 
            ISyncMgrConflictResolveInfo * This,
            /* [out] */ UINT *pcChoices);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemChoice )( 
            ISyncMgrConflictResolveInfo * This,
            /* [in] */ UINT iChoice,
            /* [out] */ UINT *piChoiceIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SetPresenterNextStep )( 
            ISyncMgrConflictResolveInfo * This,
            /* [in] */ SYNCMGR_PRESENTER_NEXT_STEP nPresenterNextStep);
        
        HRESULT ( STDMETHODCALLTYPE *SetPresenterChoice )( 
            ISyncMgrConflictResolveInfo * This,
            /* [in] */ SYNCMGR_PRESENTER_CHOICE nPresenterChoice,
            /* [in] */ BOOL fApplyToAll);
        
        HRESULT ( STDMETHODCALLTYPE *SetItemChoices )( 
            ISyncMgrConflictResolveInfo * This,
            /* [size_is][ref][in] */ UINT *prgiConflictItemIndexes,
            /* [in] */ UINT cChoices);
        
        END_INTERFACE
    } ISyncMgrConflictResolveInfoVtbl;

    interface ISyncMgrConflictResolveInfo
    {
        CONST_VTBL struct ISyncMgrConflictResolveInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrConflictResolveInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrConflictResolveInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrConflictResolveInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrConflictResolveInfo_GetIterationInfo(This,pnCurrentConflict,pcConflicts,pcRemainingForApplyToAll)	\
    ( (This)->lpVtbl -> GetIterationInfo(This,pnCurrentConflict,pcConflicts,pcRemainingForApplyToAll) ) 

#define ISyncMgrConflictResolveInfo_GetPresenterNextStep(This,pnPresenterNextStep)	\
    ( (This)->lpVtbl -> GetPresenterNextStep(This,pnPresenterNextStep) ) 

#define ISyncMgrConflictResolveInfo_GetPresenterChoice(This,pnPresenterChoice,pfApplyToAll)	\
    ( (This)->lpVtbl -> GetPresenterChoice(This,pnPresenterChoice,pfApplyToAll) ) 

#define ISyncMgrConflictResolveInfo_GetItemChoiceCount(This,pcChoices)	\
    ( (This)->lpVtbl -> GetItemChoiceCount(This,pcChoices) ) 

#define ISyncMgrConflictResolveInfo_GetItemChoice(This,iChoice,piChoiceIndex)	\
    ( (This)->lpVtbl -> GetItemChoice(This,iChoice,piChoiceIndex) ) 

#define ISyncMgrConflictResolveInfo_SetPresenterNextStep(This,nPresenterNextStep)	\
    ( (This)->lpVtbl -> SetPresenterNextStep(This,nPresenterNextStep) ) 

#define ISyncMgrConflictResolveInfo_SetPresenterChoice(This,nPresenterChoice,fApplyToAll)	\
    ( (This)->lpVtbl -> SetPresenterChoice(This,nPresenterChoice,fApplyToAll) ) 

#define ISyncMgrConflictResolveInfo_SetItemChoices(This,prgiConflictItemIndexes,cChoices)	\
    ( (This)->lpVtbl -> SetItemChoices(This,prgiConflictItemIndexes,cChoices) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrConflictResolveInfo_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrConflictFolder_INTERFACE_DEFINED__
#define __ISyncMgrConflictFolder_INTERFACE_DEFINED__

/* interface ISyncMgrConflictFolder */
/* [object][local][unique][uuid] */ 


EXTERN_C const IID IID_ISyncMgrConflictFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59287f5e-bc81-4fca-a7f1-e5a8ecdb1d69")
    ISyncMgrConflictFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConflictIDList( 
            /* [in] */ ISyncMgrConflict *pConflict,
            /* [out] */ PIDLIST_RELATIVE *ppidlConflict) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrConflictFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrConflictFolder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrConflictFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrConflictFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetConflictIDList )( 
            ISyncMgrConflictFolder * This,
            /* [in] */ ISyncMgrConflict *pConflict,
            /* [out] */ PIDLIST_RELATIVE *ppidlConflict);
        
        END_INTERFACE
    } ISyncMgrConflictFolderVtbl;

    interface ISyncMgrConflictFolder
    {
        CONST_VTBL struct ISyncMgrConflictFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrConflictFolder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrConflictFolder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrConflictFolder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrConflictFolder_GetConflictIDList(This,pConflict,ppidlConflict)	\
    ( (This)->lpVtbl -> GetConflictIDList(This,pConflict,ppidlConflict) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrConflictFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_syncmgr_0000_0024 */
/* [local] */ 

typedef struct CONFIRM_CONFLICT_ITEM
    {
    IShellItem2 *pShellItem;
    LPWSTR pszOriginalName;
    LPWSTR pszAlternateName;
    LPWSTR pszLocationShort;
    LPWSTR pszLocationFull;
    SYNCMGR_CONFLICT_ITEM_TYPE nType;
    } 	CONFIRM_CONFLICT_ITEM;

#if defined(__cplusplus)
_inline void FreeConfirmConflictItem(__inout CONFIRM_CONFLICT_ITEM *pcci)
{
    if (pcci->pShellItem)
    {
        pcci->pShellItem->Release();
    }
    ::CoTaskMemFree(pcci->pszOriginalName);
    ::CoTaskMemFree(pcci->pszAlternateName);
    ::CoTaskMemFree(pcci->pszLocationShort);
    ::CoTaskMemFree(pcci->pszLocationFull);
    ::ZeroMemory(pcci, sizeof(*pcci));
}
#endif // defined(__cplusplus)
typedef struct CONFIRM_CONFLICT_RESULT_INFO
    {
    LPWSTR pszNewName;
    UINT iItemIndex;
    } 	CONFIRM_CONFLICT_RESULT_INFO;



extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_syncmgr_0000_0024_v0_0_s_ifspec;

#ifndef __ISyncMgrConflictItems_INTERFACE_DEFINED__
#define __ISyncMgrConflictItems_INTERFACE_DEFINED__

/* interface ISyncMgrConflictItems */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ISyncMgrConflictItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C7EAD52-8023-4936-A4DB-D2A9A99E436A")
    ISyncMgrConflictItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ UINT iIndex,
            /* [out] */ __RPC__out CONFIRM_CONFLICT_ITEM *pItemInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrConflictItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrConflictItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrConflictItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrConflictItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ISyncMgrConflictItems * This,
            /* [out] */ __RPC__out UINT *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            ISyncMgrConflictItems * This,
            /* [in] */ UINT iIndex,
            /* [out] */ __RPC__out CONFIRM_CONFLICT_ITEM *pItemInfo);
        
        END_INTERFACE
    } ISyncMgrConflictItemsVtbl;

    interface ISyncMgrConflictItems
    {
        CONST_VTBL struct ISyncMgrConflictItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrConflictItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrConflictItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrConflictItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrConflictItems_GetCount(This,pCount)	\
    ( (This)->lpVtbl -> GetCount(This,pCount) ) 

#define ISyncMgrConflictItems_GetItem(This,iIndex,pItemInfo)	\
    ( (This)->lpVtbl -> GetItem(This,iIndex,pItemInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrConflictItems_INTERFACE_DEFINED__ */


#ifndef __ISyncMgrConflictResolutionItems_INTERFACE_DEFINED__
#define __ISyncMgrConflictResolutionItems_INTERFACE_DEFINED__

/* interface ISyncMgrConflictResolutionItems */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_ISyncMgrConflictResolutionItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("458725B9-129D-4135-A998-9CEAFEC27007")
    ISyncMgrConflictResolutionItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ __RPC__out UINT *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ UINT iIndex,
            /* [out] */ __RPC__out CONFIRM_CONFLICT_RESULT_INFO *pItemInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISyncMgrConflictResolutionItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISyncMgrConflictResolutionItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISyncMgrConflictResolutionItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISyncMgrConflictResolutionItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ISyncMgrConflictResolutionItems * This,
            /* [out] */ __RPC__out UINT *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            ISyncMgrConflictResolutionItems * This,
            /* [in] */ UINT iIndex,
            /* [out] */ __RPC__out CONFIRM_CONFLICT_RESULT_INFO *pItemInfo);
        
        END_INTERFACE
    } ISyncMgrConflictResolutionItemsVtbl;

    interface ISyncMgrConflictResolutionItems
    {
        CONST_VTBL struct ISyncMgrConflictResolutionItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISyncMgrConflictResolutionItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISyncMgrConflictResolutionItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISyncMgrConflictResolutionItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISyncMgrConflictResolutionItems_GetCount(This,pCount)	\
    ( (This)->lpVtbl -> GetCount(This,pCount) ) 

#define ISyncMgrConflictResolutionItems_GetItem(This,iIndex,pItemInfo)	\
    ( (This)->lpVtbl -> GetItem(This,iIndex,pItemInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISyncMgrConflictResolutionItems_INTERFACE_DEFINED__ */



#ifndef __SyncMgrObjects_LIBRARY_DEFINED__
#define __SyncMgrObjects_LIBRARY_DEFINED__

/* library SyncMgrObjects */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_SyncMgrObjects;

EXTERN_C const CLSID CLSID_SyncMgrClient;

#ifdef __cplusplus

class DECLSPEC_UUID("1202db60-1dac-42c5-aed5-1abdd432248e")
SyncMgrClient;
#endif

EXTERN_C const CLSID CLSID_SyncMgrControl;

#ifdef __cplusplus

class DECLSPEC_UUID("1a1f4206-0688-4e7f-be03-d82ec69df9a5")
SyncMgrControl;
#endif

EXTERN_C const CLSID CLSID_SyncMgrScheduleWizard;

#ifdef __cplusplus

class DECLSPEC_UUID("8d8b8e30-c451-421b-8553-d2976afa648c")
SyncMgrScheduleWizard;
#endif

EXTERN_C const CLSID CLSID_SyncMgrFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("9c73f5e5-7ae7-4e32-a8e8-8d23b85255bf")
SyncMgrFolder;
#endif

EXTERN_C const CLSID CLSID_SyncSetupFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("2e9e59c0-b437-4981-a647-9c34b9b90891")
SyncSetupFolder;
#endif

EXTERN_C const CLSID CLSID_ConflictFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("289978ac-a101-4341-a817-21eba7fd046d")
ConflictFolder;
#endif

EXTERN_C const CLSID CLSID_SyncResultsFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("71d99464-3b6b-475c-b241-e15883207529")
SyncResultsFolder;
#endif

EXTERN_C const CLSID CLSID_SimpleConflictPresenter;

#ifdef __cplusplus

class DECLSPEC_UUID("7a0f6ab7-ed84-46b6-b47e-02aa159a152b")
SimpleConflictPresenter;
#endif
#endif /* __SyncMgrObjects_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Tapi3cc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for tapi3cc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tapi3cc_h__
#define __tapi3cc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITAgent_FWD_DEFINED__
#define __ITAgent_FWD_DEFINED__
typedef interface ITAgent ITAgent;
#endif 	/* __ITAgent_FWD_DEFINED__ */


#ifndef __ITAgentSession_FWD_DEFINED__
#define __ITAgentSession_FWD_DEFINED__
typedef interface ITAgentSession ITAgentSession;
#endif 	/* __ITAgentSession_FWD_DEFINED__ */


#ifndef __ITACDGroup_FWD_DEFINED__
#define __ITACDGroup_FWD_DEFINED__
typedef interface ITACDGroup ITACDGroup;
#endif 	/* __ITACDGroup_FWD_DEFINED__ */


#ifndef __ITQueue_FWD_DEFINED__
#define __ITQueue_FWD_DEFINED__
typedef interface ITQueue ITQueue;
#endif 	/* __ITQueue_FWD_DEFINED__ */


#ifndef __ITAgentEvent_FWD_DEFINED__
#define __ITAgentEvent_FWD_DEFINED__
typedef interface ITAgentEvent ITAgentEvent;
#endif 	/* __ITAgentEvent_FWD_DEFINED__ */


#ifndef __ITAgentSessionEvent_FWD_DEFINED__
#define __ITAgentSessionEvent_FWD_DEFINED__
typedef interface ITAgentSessionEvent ITAgentSessionEvent;
#endif 	/* __ITAgentSessionEvent_FWD_DEFINED__ */


#ifndef __ITACDGroupEvent_FWD_DEFINED__
#define __ITACDGroupEvent_FWD_DEFINED__
typedef interface ITACDGroupEvent ITACDGroupEvent;
#endif 	/* __ITACDGroupEvent_FWD_DEFINED__ */


#ifndef __ITQueueEvent_FWD_DEFINED__
#define __ITQueueEvent_FWD_DEFINED__
typedef interface ITQueueEvent ITQueueEvent;
#endif 	/* __ITQueueEvent_FWD_DEFINED__ */


#ifndef __ITAgentHandlerEvent_FWD_DEFINED__
#define __ITAgentHandlerEvent_FWD_DEFINED__
typedef interface ITAgentHandlerEvent ITAgentHandlerEvent;
#endif 	/* __ITAgentHandlerEvent_FWD_DEFINED__ */


#ifndef __ITTAPICallCenter_FWD_DEFINED__
#define __ITTAPICallCenter_FWD_DEFINED__
typedef interface ITTAPICallCenter ITTAPICallCenter;
#endif 	/* __ITTAPICallCenter_FWD_DEFINED__ */


#ifndef __ITAgentHandler_FWD_DEFINED__
#define __ITAgentHandler_FWD_DEFINED__
typedef interface ITAgentHandler ITAgentHandler;
#endif 	/* __ITAgentHandler_FWD_DEFINED__ */


#ifndef __IEnumAgent_FWD_DEFINED__
#define __IEnumAgent_FWD_DEFINED__
typedef interface IEnumAgent IEnumAgent;
#endif 	/* __IEnumAgent_FWD_DEFINED__ */


#ifndef __IEnumAgentSession_FWD_DEFINED__
#define __IEnumAgentSession_FWD_DEFINED__
typedef interface IEnumAgentSession IEnumAgentSession;
#endif 	/* __IEnumAgentSession_FWD_DEFINED__ */


#ifndef __IEnumQueue_FWD_DEFINED__
#define __IEnumQueue_FWD_DEFINED__
typedef interface IEnumQueue IEnumQueue;
#endif 	/* __IEnumQueue_FWD_DEFINED__ */


#ifndef __IEnumACDGroup_FWD_DEFINED__
#define __IEnumACDGroup_FWD_DEFINED__
typedef interface IEnumACDGroup IEnumACDGroup;
#endif 	/* __IEnumACDGroup_FWD_DEFINED__ */


#ifndef __IEnumAgentHandler_FWD_DEFINED__
#define __IEnumAgentHandler_FWD_DEFINED__
typedef interface IEnumAgentHandler IEnumAgentHandler;
#endif 	/* __IEnumAgentHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "tapi3if.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_tapi3cc_0000_0000 */
/* [local] */ 

/* Copyright (c) Microsoft Corporation. All rights reserved. */
typedef 
enum AGENT_EVENT
    {	AE_NOT_READY	= 0,
	AE_READY	= ( AE_NOT_READY + 1 ) ,
	AE_BUSY_ACD	= ( AE_READY + 1 ) ,
	AE_BUSY_INCOMING	= ( AE_BUSY_ACD + 1 ) ,
	AE_BUSY_OUTGOING	= ( AE_BUSY_INCOMING + 1 ) ,
	AE_UNKNOWN	= ( AE_BUSY_OUTGOING + 1 ) 
    } 	AGENT_EVENT;

typedef 
enum AGENT_STATE
    {	AS_NOT_READY	= 0,
	AS_READY	= ( AS_NOT_READY + 1 ) ,
	AS_BUSY_ACD	= ( AS_READY + 1 ) ,
	AS_BUSY_INCOMING	= ( AS_BUSY_ACD + 1 ) ,
	AS_BUSY_OUTGOING	= ( AS_BUSY_INCOMING + 1 ) ,
	AS_UNKNOWN	= ( AS_BUSY_OUTGOING + 1 ) 
    } 	AGENT_STATE;

typedef 
enum AGENT_SESSION_EVENT
    {	ASE_NEW_SESSION	= 0,
	ASE_NOT_READY	= ( ASE_NEW_SESSION + 1 ) ,
	ASE_READY	= ( ASE_NOT_READY + 1 ) ,
	ASE_BUSY	= ( ASE_READY + 1 ) ,
	ASE_WRAPUP	= ( ASE_BUSY + 1 ) ,
	ASE_END	= ( ASE_WRAPUP + 1 ) 
    } 	AGENT_SESSION_EVENT;

typedef 
enum AGENT_SESSION_STATE
    {	ASST_NOT_READY	= 0,
	ASST_READY	= ( ASST_NOT_READY + 1 ) ,
	ASST_BUSY_ON_CALL	= ( ASST_READY + 1 ) ,
	ASST_BUSY_WRAPUP	= ( ASST_BUSY_ON_CALL + 1 ) ,
	ASST_SESSION_ENDED	= ( ASST_BUSY_WRAPUP + 1 ) 
    } 	AGENT_SESSION_STATE;

typedef 
enum AGENTHANDLER_EVENT
    {	AHE_NEW_AGENTHANDLER	= 0,
	AHE_AGENTHANDLER_REMOVED	= ( AHE_NEW_AGENTHANDLER + 1 ) 
    } 	AGENTHANDLER_EVENT;

typedef 
enum ACDGROUP_EVENT
    {	ACDGE_NEW_GROUP	= 0,
	ACDGE_GROUP_REMOVED	= ( ACDGE_NEW_GROUP + 1 ) 
    } 	ACDGROUP_EVENT;

typedef 
enum ACDQUEUE_EVENT
    {	ACDQE_NEW_QUEUE	= 0,
	ACDQE_QUEUE_REMOVED	= ( ACDQE_NEW_QUEUE + 1 ) 
    } 	ACDQUEUE_EVENT;


















extern RPC_IF_HANDLE __MIDL_itf_tapi3cc_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3cc_0000_0000_v0_0_s_ifspec;

#ifndef __ITAgent_INTERFACE_DEFINED__
#define __ITAgent_INTERFACE_DEFINED__

/* interface ITAgent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5770ECE5-4B27-11d1-BF80-00805FC147D3")
    ITAgent : public IDispatch
    {
    public:
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAgentSessions( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentSession **ppEnumAgentSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [in] */ __RPC__in_opt ITACDGroup *pACDGroup,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppAgentSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSessionWithPIN( 
            /* [in] */ __RPC__in_opt ITACDGroup *pACDGroup,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [in] */ __RPC__in BSTR pPIN,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppAgentSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUser) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ AGENT_STATE AgentState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out AGENT_STATE *pAgentState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MeasurementPeriod( 
            /* [in] */ long lPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeasurementPeriod( 
            /* [retval][out] */ __RPC__out long *plPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OverallCallRate( 
            /* [retval][out] */ __RPC__out CURRENCY *pcyCallrate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfACDCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfIncomingCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfOutgoingCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalACDTalkTime( 
            /* [retval][out] */ __RPC__out long *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalACDCallTime( 
            /* [retval][out] */ __RPC__out long *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalWrapUpTime( 
            /* [retval][out] */ __RPC__out long *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentSessions( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateAgentSessions )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentSession **ppEnumAgentSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateSession )( 
            ITAgent * This,
            /* [in] */ __RPC__in_opt ITACDGroup *pACDGroup,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppAgentSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateSessionWithPIN )( 
            ITAgent * This,
            /* [in] */ __RPC__in_opt ITACDGroup *pACDGroup,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [in] */ __RPC__in BSTR pPIN,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppAgentSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUser);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_State )( 
            ITAgent * This,
            /* [in] */ AGENT_STATE AgentState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out AGENT_STATE *pAgentState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MeasurementPeriod )( 
            ITAgent * This,
            /* [in] */ long lPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeasurementPeriod )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OverallCallRate )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out CURRENCY *pcyCallrate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfACDCalls )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfIncomingCalls )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfOutgoingCalls )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalACDTalkTime )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalACDCallTime )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalWrapUpTime )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgentSessions )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITAgentVtbl;

    interface ITAgent
    {
        CONST_VTBL struct ITAgentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgent_EnumerateAgentSessions(This,ppEnumAgentSession)	\
    ( (This)->lpVtbl -> EnumerateAgentSessions(This,ppEnumAgentSession) ) 

#define ITAgent_CreateSession(This,pACDGroup,pAddress,ppAgentSession)	\
    ( (This)->lpVtbl -> CreateSession(This,pACDGroup,pAddress,ppAgentSession) ) 

#define ITAgent_CreateSessionWithPIN(This,pACDGroup,pAddress,pPIN,ppAgentSession)	\
    ( (This)->lpVtbl -> CreateSessionWithPIN(This,pACDGroup,pAddress,pPIN,ppAgentSession) ) 

#define ITAgent_get_ID(This,ppID)	\
    ( (This)->lpVtbl -> get_ID(This,ppID) ) 

#define ITAgent_get_User(This,ppUser)	\
    ( (This)->lpVtbl -> get_User(This,ppUser) ) 

#define ITAgent_put_State(This,AgentState)	\
    ( (This)->lpVtbl -> put_State(This,AgentState) ) 

#define ITAgent_get_State(This,pAgentState)	\
    ( (This)->lpVtbl -> get_State(This,pAgentState) ) 

#define ITAgent_put_MeasurementPeriod(This,lPeriod)	\
    ( (This)->lpVtbl -> put_MeasurementPeriod(This,lPeriod) ) 

#define ITAgent_get_MeasurementPeriod(This,plPeriod)	\
    ( (This)->lpVtbl -> get_MeasurementPeriod(This,plPeriod) ) 

#define ITAgent_get_OverallCallRate(This,pcyCallrate)	\
    ( (This)->lpVtbl -> get_OverallCallRate(This,pcyCallrate) ) 

#define ITAgent_get_NumberOfACDCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumberOfACDCalls(This,plCalls) ) 

#define ITAgent_get_NumberOfIncomingCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumberOfIncomingCalls(This,plCalls) ) 

#define ITAgent_get_NumberOfOutgoingCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumberOfOutgoingCalls(This,plCalls) ) 

#define ITAgent_get_TotalACDTalkTime(This,plTalkTime)	\
    ( (This)->lpVtbl -> get_TotalACDTalkTime(This,plTalkTime) ) 

#define ITAgent_get_TotalACDCallTime(This,plCallTime)	\
    ( (This)->lpVtbl -> get_TotalACDCallTime(This,plCallTime) ) 

#define ITAgent_get_TotalWrapUpTime(This,plWrapUpTime)	\
    ( (This)->lpVtbl -> get_TotalWrapUpTime(This,plWrapUpTime) ) 

#define ITAgent_get_AgentSessions(This,pVariant)	\
    ( (This)->lpVtbl -> get_AgentSessions(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgent_INTERFACE_DEFINED__ */


#ifndef __ITAgentSession_INTERFACE_DEFINED__
#define __ITAgentSession_INTERFACE_DEFINED__

/* interface ITAgentSession */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3147-4BCC-11d1-BF80-00805FC147D3")
    ITAgentSession : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Agent( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDGroup( 
            /* [retval][out] */ __RPC__deref_out_opt ITACDGroup **ppACDGroup) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ AGENT_SESSION_STATE SessionState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out AGENT_SESSION_STATE *pSessionState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionStartTime( 
            /* [retval][out] */ __RPC__out DATE *pdateSessionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionDuration( 
            /* [retval][out] */ __RPC__out long *plDuration) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalTalkTime( 
            /* [retval][out] */ __RPC__out long *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageTalkTime( 
            /* [retval][out] */ __RPC__out long *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallTime( 
            /* [retval][out] */ __RPC__out long *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageCallTime( 
            /* [retval][out] */ __RPC__out long *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalWrapUpTime( 
            /* [retval][out] */ __RPC__out long *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageWrapUpTime( 
            /* [retval][out] */ __RPC__out long *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDCallRate( 
            /* [retval][out] */ __RPC__out CURRENCY *pcyCallrate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongestTimeToAnswer( 
            /* [retval][out] */ __RPC__out long *plAnswerTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageTimeToAnswer( 
            /* [retval][out] */ __RPC__out long *plAnswerTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentSession * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Agent )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ACDGroup )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__deref_out_opt ITACDGroup **ppACDGroup);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_State )( 
            ITAgentSession * This,
            /* [in] */ AGENT_SESSION_STATE SessionState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out AGENT_SESSION_STATE *pSessionState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionStartTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out DATE *pdateSessionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionDuration )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plDuration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfCalls )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalTalkTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageTalkTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageCallTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalWrapUpTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageWrapUpTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ACDCallRate )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out CURRENCY *pcyCallrate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LongestTimeToAnswer )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plAnswerTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageTimeToAnswer )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plAnswerTime);
        
        END_INTERFACE
    } ITAgentSessionVtbl;

    interface ITAgentSession
    {
        CONST_VTBL struct ITAgentSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentSession_get_Agent(This,ppAgent)	\
    ( (This)->lpVtbl -> get_Agent(This,ppAgent) ) 

#define ITAgentSession_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITAgentSession_get_ACDGroup(This,ppACDGroup)	\
    ( (This)->lpVtbl -> get_ACDGroup(This,ppACDGroup) ) 

#define ITAgentSession_put_State(This,SessionState)	\
    ( (This)->lpVtbl -> put_State(This,SessionState) ) 

#define ITAgentSession_get_State(This,pSessionState)	\
    ( (This)->lpVtbl -> get_State(This,pSessionState) ) 

#define ITAgentSession_get_SessionStartTime(This,pdateSessionStart)	\
    ( (This)->lpVtbl -> get_SessionStartTime(This,pdateSessionStart) ) 

#define ITAgentSession_get_SessionDuration(This,plDuration)	\
    ( (This)->lpVtbl -> get_SessionDuration(This,plDuration) ) 

#define ITAgentSession_get_NumberOfCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumberOfCalls(This,plCalls) ) 

#define ITAgentSession_get_TotalTalkTime(This,plTalkTime)	\
    ( (This)->lpVtbl -> get_TotalTalkTime(This,plTalkTime) ) 

#define ITAgentSession_get_AverageTalkTime(This,plTalkTime)	\
    ( (This)->lpVtbl -> get_AverageTalkTime(This,plTalkTime) ) 

#define ITAgentSession_get_TotalCallTime(This,plCallTime)	\
    ( (This)->lpVtbl -> get_TotalCallTime(This,plCallTime) ) 

#define ITAgentSession_get_AverageCallTime(This,plCallTime)	\
    ( (This)->lpVtbl -> get_AverageCallTime(This,plCallTime) ) 

#define ITAgentSession_get_TotalWrapUpTime(This,plWrapUpTime)	\
    ( (This)->lpVtbl -> get_TotalWrapUpTime(This,plWrapUpTime) ) 

#define ITAgentSession_get_AverageWrapUpTime(This,plWrapUpTime)	\
    ( (This)->lpVtbl -> get_AverageWrapUpTime(This,plWrapUpTime) ) 

#define ITAgentSession_get_ACDCallRate(This,pcyCallrate)	\
    ( (This)->lpVtbl -> get_ACDCallRate(This,pcyCallrate) ) 

#define ITAgentSession_get_LongestTimeToAnswer(This,plAnswerTime)	\
    ( (This)->lpVtbl -> get_LongestTimeToAnswer(This,plAnswerTime) ) 

#define ITAgentSession_get_AverageTimeToAnswer(This,plAnswerTime)	\
    ( (This)->lpVtbl -> get_AverageTimeToAnswer(This,plAnswerTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentSession_INTERFACE_DEFINED__ */


#ifndef __ITACDGroup_INTERFACE_DEFINED__
#define __ITACDGroup_INTERFACE_DEFINED__

/* interface ITACDGroup */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITACDGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3148-4BCC-11d1-BF80-00805FC147D3")
    ITACDGroup : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateQueues( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumQueue **ppEnumQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Queues( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITACDGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITACDGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITACDGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITACDGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITACDGroup * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITACDGroup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITACDGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITACDGroup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITACDGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateQueues )( 
            ITACDGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumQueue **ppEnumQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Queues )( 
            ITACDGroup * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITACDGroupVtbl;

    interface ITACDGroup
    {
        CONST_VTBL struct ITACDGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITACDGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITACDGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITACDGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITACDGroup_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITACDGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITACDGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITACDGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITACDGroup_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#define ITACDGroup_EnumerateQueues(This,ppEnumQueue)	\
    ( (This)->lpVtbl -> EnumerateQueues(This,ppEnumQueue) ) 

#define ITACDGroup_get_Queues(This,pVariant)	\
    ( (This)->lpVtbl -> get_Queues(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITACDGroup_INTERFACE_DEFINED__ */


#ifndef __ITQueue_INTERFACE_DEFINED__
#define __ITQueue_INTERFACE_DEFINED__

/* interface ITQueue */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3149-4BCC-11d1-BF80-00805FC147D3")
    ITQueue : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MeasurementPeriod( 
            /* [in] */ long lPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeasurementPeriod( 
            /* [retval][out] */ __RPC__out long *plPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsQueued( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCallsQueued( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsAbandoned( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsFlowedIn( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsFlowedOut( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongestEverWaitTime( 
            /* [retval][out] */ __RPC__out long *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentLongestWaitTime( 
            /* [retval][out] */ __RPC__out long *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageWaitTime( 
            /* [retval][out] */ __RPC__out long *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FinalDisposition( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITQueue * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITQueue * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITQueue * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITQueue * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITQueue * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MeasurementPeriod )( 
            ITQueue * This,
            /* [in] */ long lPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeasurementPeriod )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallsQueued )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCallsQueued )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallsAbandoned )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallsFlowedIn )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallsFlowedOut )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LongestEverWaitTime )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentLongestWaitTime )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageWaitTime )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FinalDisposition )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        END_INTERFACE
    } ITQueueVtbl;

    interface ITQueue
    {
        CONST_VTBL struct ITQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITQueue_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITQueue_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITQueue_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITQueue_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITQueue_put_MeasurementPeriod(This,lPeriod)	\
    ( (This)->lpVtbl -> put_MeasurementPeriod(This,lPeriod) ) 

#define ITQueue_get_MeasurementPeriod(This,plPeriod)	\
    ( (This)->lpVtbl -> get_MeasurementPeriod(This,plPeriod) ) 

#define ITQueue_get_TotalCallsQueued(This,plCalls)	\
    ( (This)->lpVtbl -> get_TotalCallsQueued(This,plCalls) ) 

#define ITQueue_get_CurrentCallsQueued(This,plCalls)	\
    ( (This)->lpVtbl -> get_CurrentCallsQueued(This,plCalls) ) 

#define ITQueue_get_TotalCallsAbandoned(This,plCalls)	\
    ( (This)->lpVtbl -> get_TotalCallsAbandoned(This,plCalls) ) 

#define ITQueue_get_TotalCallsFlowedIn(This,plCalls)	\
    ( (This)->lpVtbl -> get_TotalCallsFlowedIn(This,plCalls) ) 

#define ITQueue_get_TotalCallsFlowedOut(This,plCalls)	\
    ( (This)->lpVtbl -> get_TotalCallsFlowedOut(This,plCalls) ) 

#define ITQueue_get_LongestEverWaitTime(This,plWaitTime)	\
    ( (This)->lpVtbl -> get_LongestEverWaitTime(This,plWaitTime) ) 

#define ITQueue_get_CurrentLongestWaitTime(This,plWaitTime)	\
    ( (This)->lpVtbl -> get_CurrentLongestWaitTime(This,plWaitTime) ) 

#define ITQueue_get_AverageWaitTime(This,plWaitTime)	\
    ( (This)->lpVtbl -> get_AverageWaitTime(This,plWaitTime) ) 

#define ITQueue_get_FinalDisposition(This,plCalls)	\
    ( (This)->lpVtbl -> get_FinalDisposition(This,plCalls) ) 

#define ITQueue_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITQueue_INTERFACE_DEFINED__ */


#ifndef __ITAgentEvent_INTERFACE_DEFINED__
#define __ITAgentEvent_INTERFACE_DEFINED__

/* interface ITAgentEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314A-4BCC-11d1-BF80-00805FC147D3")
    ITAgentEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Agent( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out AGENT_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Agent )( 
            ITAgentEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITAgentEvent * This,
            /* [retval][out] */ __RPC__out AGENT_EVENT *pEvent);
        
        END_INTERFACE
    } ITAgentEventVtbl;

    interface ITAgentEvent
    {
        CONST_VTBL struct ITAgentEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentEvent_get_Agent(This,ppAgent)	\
    ( (This)->lpVtbl -> get_Agent(This,ppAgent) ) 

#define ITAgentEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentEvent_INTERFACE_DEFINED__ */


#ifndef __ITAgentSessionEvent_INTERFACE_DEFINED__
#define __ITAgentSessionEvent_INTERFACE_DEFINED__

/* interface ITAgentSessionEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentSessionEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314B-4BCC-11d1-BF80-00805FC147D3")
    ITAgentSessionEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out AGENT_SESSION_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentSessionEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentSessionEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentSessionEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentSessionEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentSessionEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentSessionEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentSessionEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentSessionEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            ITAgentSessionEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITAgentSessionEvent * This,
            /* [retval][out] */ __RPC__out AGENT_SESSION_EVENT *pEvent);
        
        END_INTERFACE
    } ITAgentSessionEventVtbl;

    interface ITAgentSessionEvent
    {
        CONST_VTBL struct ITAgentSessionEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentSessionEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentSessionEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentSessionEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentSessionEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentSessionEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentSessionEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentSessionEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentSessionEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define ITAgentSessionEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentSessionEvent_INTERFACE_DEFINED__ */


#ifndef __ITACDGroupEvent_INTERFACE_DEFINED__
#define __ITACDGroupEvent_INTERFACE_DEFINED__

/* interface ITACDGroupEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITACDGroupEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3032-BD11-11d1-A0A7-00805FC147D3")
    ITACDGroupEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [retval][out] */ __RPC__deref_out_opt ITACDGroup **ppGroup) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out ACDGROUP_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITACDGroupEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITACDGroupEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITACDGroupEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITACDGroupEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITACDGroupEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITACDGroupEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITACDGroupEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITACDGroupEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Group )( 
            ITACDGroupEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITACDGroup **ppGroup);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITACDGroupEvent * This,
            /* [retval][out] */ __RPC__out ACDGROUP_EVENT *pEvent);
        
        END_INTERFACE
    } ITACDGroupEventVtbl;

    interface ITACDGroupEvent
    {
        CONST_VTBL struct ITACDGroupEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITACDGroupEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITACDGroupEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITACDGroupEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITACDGroupEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITACDGroupEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITACDGroupEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITACDGroupEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITACDGroupEvent_get_Group(This,ppGroup)	\
    ( (This)->lpVtbl -> get_Group(This,ppGroup) ) 

#define ITACDGroupEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITACDGroupEvent_INTERFACE_DEFINED__ */


#ifndef __ITQueueEvent_INTERFACE_DEFINED__
#define __ITQueueEvent_INTERFACE_DEFINED__

/* interface ITQueueEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITQueueEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3033-BD11-11d1-A0A7-00805FC147D3")
    ITQueueEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Queue( 
            /* [retval][out] */ __RPC__deref_out_opt ITQueue **ppQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out ACDQUEUE_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITQueueEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITQueueEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITQueueEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITQueueEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITQueueEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITQueueEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITQueueEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITQueueEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Queue )( 
            ITQueueEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITQueue **ppQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITQueueEvent * This,
            /* [retval][out] */ __RPC__out ACDQUEUE_EVENT *pEvent);
        
        END_INTERFACE
    } ITQueueEventVtbl;

    interface ITQueueEvent
    {
        CONST_VTBL struct ITQueueEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITQueueEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITQueueEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITQueueEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITQueueEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITQueueEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITQueueEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITQueueEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITQueueEvent_get_Queue(This,ppQueue)	\
    ( (This)->lpVtbl -> get_Queue(This,ppQueue) ) 

#define ITQueueEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITQueueEvent_INTERFACE_DEFINED__ */


#ifndef __ITAgentHandlerEvent_INTERFACE_DEFINED__
#define __ITAgentHandlerEvent_INTERFACE_DEFINED__

/* interface ITAgentHandlerEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentHandlerEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3034-BD11-11d1-A0A7-00805FC147D3")
    ITAgentHandlerEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentHandler( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgentHandler **ppAgentHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out AGENTHANDLER_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentHandlerEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentHandlerEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentHandlerEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentHandlerEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentHandlerEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentHandlerEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentHandlerEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentHandlerEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgentHandler )( 
            ITAgentHandlerEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentHandler **ppAgentHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITAgentHandlerEvent * This,
            /* [retval][out] */ __RPC__out AGENTHANDLER_EVENT *pEvent);
        
        END_INTERFACE
    } ITAgentHandlerEventVtbl;

    interface ITAgentHandlerEvent
    {
        CONST_VTBL struct ITAgentHandlerEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentHandlerEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentHandlerEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentHandlerEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentHandlerEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentHandlerEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentHandlerEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentHandlerEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentHandlerEvent_get_AgentHandler(This,ppAgentHandler)	\
    ( (This)->lpVtbl -> get_AgentHandler(This,ppAgentHandler) ) 

#define ITAgentHandlerEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentHandlerEvent_INTERFACE_DEFINED__ */


#ifndef __ITTAPICallCenter_INTERFACE_DEFINED__
#define __ITTAPICallCenter_INTERFACE_DEFINED__

/* interface ITTAPICallCenter */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPICallCenter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3154-4BCC-11d1-BF80-00805FC147D3")
    ITTAPICallCenter : public IDispatch
    {
    public:
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAgentHandlers( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentHandler **ppEnumHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentHandlers( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPICallCenterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTAPICallCenter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTAPICallCenter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTAPICallCenter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTAPICallCenter * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTAPICallCenter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTAPICallCenter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTAPICallCenter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateAgentHandlers )( 
            ITTAPICallCenter * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentHandler **ppEnumHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgentHandlers )( 
            ITTAPICallCenter * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITTAPICallCenterVtbl;

    interface ITTAPICallCenter
    {
        CONST_VTBL struct ITTAPICallCenterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPICallCenter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTAPICallCenter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTAPICallCenter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTAPICallCenter_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTAPICallCenter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTAPICallCenter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTAPICallCenter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTAPICallCenter_EnumerateAgentHandlers(This,ppEnumHandler)	\
    ( (This)->lpVtbl -> EnumerateAgentHandlers(This,ppEnumHandler) ) 

#define ITTAPICallCenter_get_AgentHandlers(This,pVariant)	\
    ( (This)->lpVtbl -> get_AgentHandlers(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTAPICallCenter_INTERFACE_DEFINED__ */


#ifndef __ITAgentHandler_INTERFACE_DEFINED__
#define __ITAgentHandler_INTERFACE_DEFINED__

/* interface ITAgentHandler */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587E8C22-9802-11d1-A0A4-00805FC147D3")
    ITAgentHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAgent( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAgentWithID( 
            /* [in] */ __RPC__in BSTR pID,
            /* [in] */ __RPC__in BSTR pPIN,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateACDGroups( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumACDGroup **ppEnumACDGroup) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateUsableAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDGroups( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsableAddresses( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentHandler * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateAgent )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateAgentWithID )( 
            ITAgentHandler * This,
            /* [in] */ __RPC__in BSTR pID,
            /* [in] */ __RPC__in BSTR pPIN,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateACDGroups )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumACDGroup **ppEnumACDGroup);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateUsableAddresses )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ACDGroups )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsableAddresses )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITAgentHandlerVtbl;

    interface ITAgentHandler
    {
        CONST_VTBL struct ITAgentHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentHandler_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentHandler_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#define ITAgentHandler_CreateAgent(This,ppAgent)	\
    ( (This)->lpVtbl -> CreateAgent(This,ppAgent) ) 

#define ITAgentHandler_CreateAgentWithID(This,pID,pPIN,ppAgent)	\
    ( (This)->lpVtbl -> CreateAgentWithID(This,pID,pPIN,ppAgent) ) 

#define ITAgentHandler_EnumerateACDGroups(This,ppEnumACDGroup)	\
    ( (This)->lpVtbl -> EnumerateACDGroups(This,ppEnumACDGroup) ) 

#define ITAgentHandler_EnumerateUsableAddresses(This,ppEnumAddress)	\
    ( (This)->lpVtbl -> EnumerateUsableAddresses(This,ppEnumAddress) ) 

#define ITAgentHandler_get_ACDGroups(This,pVariant)	\
    ( (This)->lpVtbl -> get_ACDGroups(This,pVariant) ) 

#define ITAgentHandler_get_UsableAddresses(This,pVariant)	\
    ( (This)->lpVtbl -> get_UsableAddresses(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentHandler_INTERFACE_DEFINED__ */


#ifndef __IEnumAgent_INTERFACE_DEFINED__
#define __IEnumAgent_INTERFACE_DEFINED__

/* interface IEnumAgent */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAgent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314D-4BCC-11d1-BF80-00805FC147D3")
    IEnumAgent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgent **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgent **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAgentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAgent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAgent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAgent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAgent * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgent **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumAgent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumAgent * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumAgent * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgent **ppEnum);
        
        END_INTERFACE
    } IEnumAgentVtbl;

    interface IEnumAgent
    {
        CONST_VTBL struct IEnumAgentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAgent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumAgent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumAgent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumAgent_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumAgent_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumAgent_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumAgent_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumAgent_INTERFACE_DEFINED__ */


#ifndef __IEnumAgentSession_INTERFACE_DEFINED__
#define __IEnumAgentSession_INTERFACE_DEFINED__

/* interface IEnumAgentSession */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAgentSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314E-4BCC-11d1-BF80-00805FC147D3")
    IEnumAgentSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgentSession **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentSession **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAgentSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAgentSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAgentSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAgentSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAgentSession * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgentSession **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumAgentSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumAgentSession * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumAgentSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentSession **ppEnum);
        
        END_INTERFACE
    } IEnumAgentSessionVtbl;

    interface IEnumAgentSession
    {
        CONST_VTBL struct IEnumAgentSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAgentSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumAgentSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumAgentSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumAgentSession_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumAgentSession_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumAgentSession_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumAgentSession_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumAgentSession_INTERFACE_DEFINED__ */


#ifndef __IEnumQueue_INTERFACE_DEFINED__
#define __IEnumQueue_INTERFACE_DEFINED__

/* interface IEnumQueue */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3158-4BCC-11d1-BF80-00805FC147D3")
    IEnumQueue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITQueue **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumQueue **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumQueue * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumQueue * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITQueue **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumQueue * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumQueue * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumQueue **ppEnum);
        
        END_INTERFACE
    } IEnumQueueVtbl;

    interface IEnumQueue
    {
        CONST_VTBL struct IEnumQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumQueue_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumQueue_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumQueue_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumQueue_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumQueue_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumQueue_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumQueue_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumQueue_INTERFACE_DEFINED__ */


#ifndef __IEnumACDGroup_INTERFACE_DEFINED__
#define __IEnumACDGroup_INTERFACE_DEFINED__

/* interface IEnumACDGroup */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumACDGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3157-4BCC-11d1-BF80-00805FC147D3")
    IEnumACDGroup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITACDGroup **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumACDGroup **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumACDGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumACDGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumACDGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumACDGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumACDGroup * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITACDGroup **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumACDGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumACDGroup * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumACDGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumACDGroup **ppEnum);
        
        END_INTERFACE
    } IEnumACDGroupVtbl;

    interface IEnumACDGroup
    {
        CONST_VTBL struct IEnumACDGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumACDGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumACDGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumACDGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumACDGroup_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumACDGroup_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumACDGroup_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumACDGroup_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumACDGroup_INTERFACE_DEFINED__ */


#ifndef __IEnumAgentHandler_INTERFACE_DEFINED__
#define __IEnumAgentHandler_INTERFACE_DEFINED__

/* interface IEnumAgentHandler */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAgentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587E8C28-9802-11d1-A0A4-00805FC147D3")
    IEnumAgentHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgentHandler **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentHandler **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAgentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAgentHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAgentHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAgentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAgentHandler * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgentHandler **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumAgentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumAgentHandler * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentHandler **ppEnum);
        
        END_INTERFACE
    } IEnumAgentHandlerVtbl;

    interface IEnumAgentHandler
    {
        CONST_VTBL struct IEnumAgentHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAgentHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumAgentHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumAgentHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumAgentHandler_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumAgentHandler_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumAgentHandler_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumAgentHandler_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumAgentHandler_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\TCError.h ===
/* Copyright (c) 1997-1999, Microsoft Corporation, all rights reserved
**
** tcerror.h
** Traffic Control external API
** TC specific error codes
*/

#ifndef _TCERROR_H_
#define _TCERROR_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define TCBASE 7500


//
// Incompatible TC version number
//
#define ERROR_INCOMPATIBLE_TCI_VERSION			(TCBASE+1)

//
// Unspecified or bad intserv service type
//
#define ERROR_INVALID_SERVICE_TYPE			(TCBASE+2)

//
// Unspecified or bad TokenRate
//
#define ERROR_INVALID_TOKEN_RATE			(TCBASE+3)
	
//
// Bad PeakBandwidth
//
#define ERROR_INVALID_PEAK_RATE				(TCBASE+4)
	
//
// Invalid ShapeDiscardMode
//
#define ERROR_INVALID_SD_MODE				(TCBASE+5)
	
//
// Invalid priority value
//
#define ERROR_INVALID_QOS_PRIORITY			(TCBASE+6)
	
//
// Invalid traffic class value
//
#define ERROR_INVALID_TRAFFIC_CLASS			(TCBASE+7)
	
//
// Invalid address type
//
#define ERROR_INVALID_ADDRESS_TYPE			(TCBASE+8)
	
//
// Attempt to install identical filter on same flow
//
#define ERROR_DUPLICATE_FILTER				(TCBASE+9)
	
//
// Attempt to install conflicting filter
//
#define ERROR_FILTER_CONFLICT				(TCBASE+10)
	
//
// This address type is not supported
//
#define ERROR_ADDRESS_TYPE_NOT_SUPPORTED	(TCBASE+11)

//
// This object can not be deleted since its suporting opened objects
//
#define ERROR_TC_SUPPORTED_OBJECTS_EXIST	(TCBASE+12)

//
// Incompatable QoS parameters
//
#define ERROR_INCOMPATABLE_QOS				(TCBASE+13)

//
// Traffic Control is not supported in the system
//
#define ERROR_TC_NOT_SUPPORTED				(TCBASE+14)

//
// TcObjectsLength is inconsistent with CfInfoSize
//
#define ERROR_TC_OBJECT_LENGTH_INVALID      (TCBASE+15)

//
// Adding an Intserv flow in Diffserv mode or vice versa
//
#define ERROR_INVALID_FLOW_MODE             (TCBASE+16)

//
// Invalid Diffserv flow
//
#define ERROR_INVALID_DIFFSERV_FLOW         (TCBASE+17)

//
// DS codepoint already exists
//
#define ERROR_DS_MAPPING_EXISTS             (TCBASE+18)

//
// Invalid Shape Rate specified
//
#define ERROR_INVALID_SHAPE_RATE            (TCBASE+19)

// 
// Invalid DCLASS
// 
#define ERROR_INVALID_DS_CLASS              (TCBASE+20)

// 
// Too many GPC clients
// 
#define ERROR_TOO_MANY_CLIENTS              (TCBASE+21)

#endif // _TCERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\TCGuid.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tcguid.h

Abstract:

    This module contains QoS guid definitions for use by the
    Traffic Control users.

--*/

#pragma once

#ifdef __cplusplus
extern  "C" {
#endif

//
//	Remaining Bandwidth guid
//
DEFINE_GUID( GUID_QOS_REMAINING_BANDWIDTH, 0xc4c51720L, 0x40ec, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

//
//	Best Effort Bandwidth guid
//
DEFINE_GUID( GUID_QOS_BESTEFFORT_BANDWIDTH, 0xed885290L, 0x40ec, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

//
//	Latency guid
//
DEFINE_GUID( GUID_QOS_LATENCY, 0xfc408ef0L, 0x40ec, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

//
//	Flow Count guid
//
DEFINE_GUID( GUID_QOS_FLOW_COUNT, 0x1147f880L, 0x40ed, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

//
//	Non Best Effort Limit guid
//
DEFINE_GUID( GUID_QOS_NON_BESTEFFORT_LIMIT, 0x185c44e0L, 0x40ed, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

//
//	Maximum Outstanding Sends guid
//
DEFINE_GUID( GUID_QOS_MAX_OUTSTANDING_SENDS, 0x161ffa86L, 0x6120, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

//
// Packet scheduler statistics
//
DEFINE_GUID( GUID_QOS_STATISTICS_BUFFER, 0xbb2c0980L,0xe900,0x11d1,0xb0,0x7e,0x00,0x80,0xc7,0x13,0x82,0xbf);

//
// Packet Scheduler Flow Mode
//
DEFINE_GUID( GUID_QOS_FLOW_MODE, 0x5c82290aL,0x515a,0x11d2,0x8e,0x58,0x00,0xc0, 0x4f, 0xc9, 0xbf, 0xcb);

//
// ISSLOW Flow
//
DEFINE_GUID( GUID_QOS_ISSLOW_FLOW,0xabf273a4,0xee07,0x11d2,0xbe,0x1b,0x00,0xa0, 0xc9, 0x9e, 0xe6, 0x3b);

//
// Timer Resolution
//
DEFINE_GUID( GUID_QOS_TIMER_RESOLUTION, 0xba10cc88, 0xf13e, 0x11d2, 0xbe, 0x1b, 0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b);

//
// The conforming IP Precedence value for this flow.
//
DEFINE_GUID( GUID_QOS_FLOW_IP_CONFORMING, 0x07f99a8b, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b);

//
// The non-conforming IP Precedence value for this flow.
//
DEFINE_GUID( GUID_QOS_FLOW_IP_NONCONFORMING, 0x087a5987, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b);

//
// The conforming 802.1p value for this flow.
//
DEFINE_GUID( GUID_QOS_FLOW_8021P_CONFORMING, 0x08c1e013, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b);

//
// The non-conforming 802.1p value for this flow.
//
DEFINE_GUID( GUID_QOS_FLOW_8021P_NONCONFORMING, 0x09023f91, 0xfcd2, 0x11d2, 0xbe, 0x1e,  0x00, 0xa0, 0xc9, 0x9e, 0xe6, 0x3b);

//
// This will enable the Averaging statistics in Packet scheduler. (eg: Avg. number of packets in shaper)
//
DEFINE_GUID( GUID_QOS_ENABLE_AVG_STATS, 0xbafb6d11, 0x27c4, 0x4801, 0xa4, 0x6f, 0xef, 0x80, 0x80, 0xc1, 0x88, 0xc8);

//
// This will enable Window size adjustment for TCP connections on a slow link, running ICS
//
DEFINE_GUID( GUID_QOS_ENABLE_WINDOW_ADJUSTMENT, 0xaa966725, 0xd3e9, 0x4c55, 0xb3, 0x35, 0x2a, 0x0, 0x27, 0x9a, 0x1e, 0x64);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Tapi3ds.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for tapi3ds.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tapi3ds_h__
#define __tapi3ds_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITAMMediaFormat_FWD_DEFINED__
#define __ITAMMediaFormat_FWD_DEFINED__
typedef interface ITAMMediaFormat ITAMMediaFormat;
#endif 	/* __ITAMMediaFormat_FWD_DEFINED__ */


#ifndef __ITAllocatorProperties_FWD_DEFINED__
#define __ITAllocatorProperties_FWD_DEFINED__
typedef interface ITAllocatorProperties ITAllocatorProperties;
#endif 	/* __ITAllocatorProperties_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_tapi3ds_0000_0000 */
/* [local] */ 

/* Copyright (c) Microsoft Corporation. All rights reserved. */


extern RPC_IF_HANDLE __MIDL_itf_tapi3ds_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3ds_0000_0000_v0_0_s_ifspec;

#ifndef __ITAMMediaFormat_INTERFACE_DEFINED__
#define __ITAMMediaFormat_INTERFACE_DEFINED__

/* interface ITAMMediaFormat */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAMMediaFormat;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0364EB00-4A77-11D1-A671-006097C9A2E8")
    ITAMMediaFormat : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaFormat( 
            /* [retval][out] */ __RPC__deref_out_opt AM_MEDIA_TYPE **ppmt) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaFormat( 
            /* [in] */ __RPC__in const AM_MEDIA_TYPE *pmt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAMMediaFormatVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAMMediaFormat * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAMMediaFormat * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAMMediaFormat * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaFormat )( 
            ITAMMediaFormat * This,
            /* [retval][out] */ __RPC__deref_out_opt AM_MEDIA_TYPE **ppmt);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaFormat )( 
            ITAMMediaFormat * This,
            /* [in] */ __RPC__in const AM_MEDIA_TYPE *pmt);
        
        END_INTERFACE
    } ITAMMediaFormatVtbl;

    interface ITAMMediaFormat
    {
        CONST_VTBL struct ITAMMediaFormatVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAMMediaFormat_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAMMediaFormat_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAMMediaFormat_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAMMediaFormat_get_MediaFormat(This,ppmt)	\
    ( (This)->lpVtbl -> get_MediaFormat(This,ppmt) ) 

#define ITAMMediaFormat_put_MediaFormat(This,pmt)	\
    ( (This)->lpVtbl -> put_MediaFormat(This,pmt) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAMMediaFormat_INTERFACE_DEFINED__ */


#ifndef __ITAllocatorProperties_INTERFACE_DEFINED__
#define __ITAllocatorProperties_INTERFACE_DEFINED__

/* interface ITAllocatorProperties */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAllocatorProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C1BC3C90-BCFE-11D1-9745-00C04FD91AC0")
    ITAllocatorProperties : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAllocatorProperties( 
            /* [in] */ __RPC__in ALLOCATOR_PROPERTIES *pAllocProperties) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllocatorProperties( 
            /* [out] */ __RPC__out ALLOCATOR_PROPERTIES *pAllocProperties) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAllocateBuffers( 
            /* [in] */ BOOL bAllocBuffers) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllocateBuffers( 
            /* [out] */ __RPC__out BOOL *pbAllocBuffers) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetBufferSize( 
            /* [in] */ DWORD BufferSize) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBufferSize( 
            /* [out] */ __RPC__out DWORD *pBufferSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAllocatorPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAllocatorProperties * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAllocatorProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAllocatorProperties * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetAllocatorProperties )( 
            ITAllocatorProperties * This,
            /* [in] */ __RPC__in ALLOCATOR_PROPERTIES *pAllocProperties);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAllocatorProperties )( 
            ITAllocatorProperties * This,
            /* [out] */ __RPC__out ALLOCATOR_PROPERTIES *pAllocProperties);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetAllocateBuffers )( 
            ITAllocatorProperties * This,
            /* [in] */ BOOL bAllocBuffers);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAllocateBuffers )( 
            ITAllocatorProperties * This,
            /* [out] */ __RPC__out BOOL *pbAllocBuffers);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetBufferSize )( 
            ITAllocatorProperties * This,
            /* [in] */ DWORD BufferSize);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetBufferSize )( 
            ITAllocatorProperties * This,
            /* [out] */ __RPC__out DWORD *pBufferSize);
        
        END_INTERFACE
    } ITAllocatorPropertiesVtbl;

    interface ITAllocatorProperties
    {
        CONST_VTBL struct ITAllocatorPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAllocatorProperties_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAllocatorProperties_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAllocatorProperties_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAllocatorProperties_SetAllocatorProperties(This,pAllocProperties)	\
    ( (This)->lpVtbl -> SetAllocatorProperties(This,pAllocProperties) ) 

#define ITAllocatorProperties_GetAllocatorProperties(This,pAllocProperties)	\
    ( (This)->lpVtbl -> GetAllocatorProperties(This,pAllocProperties) ) 

#define ITAllocatorProperties_SetAllocateBuffers(This,bAllocBuffers)	\
    ( (This)->lpVtbl -> SetAllocateBuffers(This,bAllocBuffers) ) 

#define ITAllocatorProperties_GetAllocateBuffers(This,pbAllocBuffers)	\
    ( (This)->lpVtbl -> GetAllocateBuffers(This,pbAllocBuffers) ) 

#define ITAllocatorProperties_SetBufferSize(This,BufferSize)	\
    ( (This)->lpVtbl -> SetBufferSize(This,BufferSize) ) 

#define ITAllocatorProperties_GetBufferSize(This,pBufferSize)	\
    ( (This)->lpVtbl -> GetBufferSize(This,pBufferSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAllocatorProperties_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Tapi3if.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for tapi3if.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tapi3if_h__
#define __tapi3if_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITTAPI_FWD_DEFINED__
#define __ITTAPI_FWD_DEFINED__
typedef interface ITTAPI ITTAPI;
#endif 	/* __ITTAPI_FWD_DEFINED__ */


#ifndef __ITTAPI2_FWD_DEFINED__
#define __ITTAPI2_FWD_DEFINED__
typedef interface ITTAPI2 ITTAPI2;
#endif 	/* __ITTAPI2_FWD_DEFINED__ */


#ifndef __ITMediaSupport_FWD_DEFINED__
#define __ITMediaSupport_FWD_DEFINED__
typedef interface ITMediaSupport ITMediaSupport;
#endif 	/* __ITMediaSupport_FWD_DEFINED__ */


#ifndef __ITPluggableTerminalClassInfo_FWD_DEFINED__
#define __ITPluggableTerminalClassInfo_FWD_DEFINED__
typedef interface ITPluggableTerminalClassInfo ITPluggableTerminalClassInfo;
#endif 	/* __ITPluggableTerminalClassInfo_FWD_DEFINED__ */


#ifndef __ITPluggableTerminalSuperclassInfo_FWD_DEFINED__
#define __ITPluggableTerminalSuperclassInfo_FWD_DEFINED__
typedef interface ITPluggableTerminalSuperclassInfo ITPluggableTerminalSuperclassInfo;
#endif 	/* __ITPluggableTerminalSuperclassInfo_FWD_DEFINED__ */


#ifndef __ITTerminalSupport_FWD_DEFINED__
#define __ITTerminalSupport_FWD_DEFINED__
typedef interface ITTerminalSupport ITTerminalSupport;
#endif 	/* __ITTerminalSupport_FWD_DEFINED__ */


#ifndef __ITTerminalSupport2_FWD_DEFINED__
#define __ITTerminalSupport2_FWD_DEFINED__
typedef interface ITTerminalSupport2 ITTerminalSupport2;
#endif 	/* __ITTerminalSupport2_FWD_DEFINED__ */


#ifndef __ITAddress_FWD_DEFINED__
#define __ITAddress_FWD_DEFINED__
typedef interface ITAddress ITAddress;
#endif 	/* __ITAddress_FWD_DEFINED__ */


#ifndef __ITAddress2_FWD_DEFINED__
#define __ITAddress2_FWD_DEFINED__
typedef interface ITAddress2 ITAddress2;
#endif 	/* __ITAddress2_FWD_DEFINED__ */


#ifndef __ITAddressCapabilities_FWD_DEFINED__
#define __ITAddressCapabilities_FWD_DEFINED__
typedef interface ITAddressCapabilities ITAddressCapabilities;
#endif 	/* __ITAddressCapabilities_FWD_DEFINED__ */


#ifndef __ITPhone_FWD_DEFINED__
#define __ITPhone_FWD_DEFINED__
typedef interface ITPhone ITPhone;
#endif 	/* __ITPhone_FWD_DEFINED__ */


#ifndef __ITAutomatedPhoneControl_FWD_DEFINED__
#define __ITAutomatedPhoneControl_FWD_DEFINED__
typedef interface ITAutomatedPhoneControl ITAutomatedPhoneControl;
#endif 	/* __ITAutomatedPhoneControl_FWD_DEFINED__ */


#ifndef __ITBasicCallControl_FWD_DEFINED__
#define __ITBasicCallControl_FWD_DEFINED__
typedef interface ITBasicCallControl ITBasicCallControl;
#endif 	/* __ITBasicCallControl_FWD_DEFINED__ */


#ifndef __ITCallInfo_FWD_DEFINED__
#define __ITCallInfo_FWD_DEFINED__
typedef interface ITCallInfo ITCallInfo;
#endif 	/* __ITCallInfo_FWD_DEFINED__ */


#ifndef __ITCallInfo2_FWD_DEFINED__
#define __ITCallInfo2_FWD_DEFINED__
typedef interface ITCallInfo2 ITCallInfo2;
#endif 	/* __ITCallInfo2_FWD_DEFINED__ */


#ifndef __ITTerminal_FWD_DEFINED__
#define __ITTerminal_FWD_DEFINED__
typedef interface ITTerminal ITTerminal;
#endif 	/* __ITTerminal_FWD_DEFINED__ */


#ifndef __ITMultiTrackTerminal_FWD_DEFINED__
#define __ITMultiTrackTerminal_FWD_DEFINED__
typedef interface ITMultiTrackTerminal ITMultiTrackTerminal;
#endif 	/* __ITMultiTrackTerminal_FWD_DEFINED__ */


#ifndef __ITFileTrack_FWD_DEFINED__
#define __ITFileTrack_FWD_DEFINED__
typedef interface ITFileTrack ITFileTrack;
#endif 	/* __ITFileTrack_FWD_DEFINED__ */


#ifndef __ITMediaPlayback_FWD_DEFINED__
#define __ITMediaPlayback_FWD_DEFINED__
typedef interface ITMediaPlayback ITMediaPlayback;
#endif 	/* __ITMediaPlayback_FWD_DEFINED__ */


#ifndef __ITMediaRecord_FWD_DEFINED__
#define __ITMediaRecord_FWD_DEFINED__
typedef interface ITMediaRecord ITMediaRecord;
#endif 	/* __ITMediaRecord_FWD_DEFINED__ */


#ifndef __ITMediaControl_FWD_DEFINED__
#define __ITMediaControl_FWD_DEFINED__
typedef interface ITMediaControl ITMediaControl;
#endif 	/* __ITMediaControl_FWD_DEFINED__ */


#ifndef __ITBasicAudioTerminal_FWD_DEFINED__
#define __ITBasicAudioTerminal_FWD_DEFINED__
typedef interface ITBasicAudioTerminal ITBasicAudioTerminal;
#endif 	/* __ITBasicAudioTerminal_FWD_DEFINED__ */


#ifndef __ITStaticAudioTerminal_FWD_DEFINED__
#define __ITStaticAudioTerminal_FWD_DEFINED__
typedef interface ITStaticAudioTerminal ITStaticAudioTerminal;
#endif 	/* __ITStaticAudioTerminal_FWD_DEFINED__ */


#ifndef __ITCallHub_FWD_DEFINED__
#define __ITCallHub_FWD_DEFINED__
typedef interface ITCallHub ITCallHub;
#endif 	/* __ITCallHub_FWD_DEFINED__ */


#ifndef __ITLegacyAddressMediaControl_FWD_DEFINED__
#define __ITLegacyAddressMediaControl_FWD_DEFINED__
typedef interface ITLegacyAddressMediaControl ITLegacyAddressMediaControl;
#endif 	/* __ITLegacyAddressMediaControl_FWD_DEFINED__ */


#ifndef __ITPrivateEvent_FWD_DEFINED__
#define __ITPrivateEvent_FWD_DEFINED__
typedef interface ITPrivateEvent ITPrivateEvent;
#endif 	/* __ITPrivateEvent_FWD_DEFINED__ */


#ifndef __ITLegacyAddressMediaControl2_FWD_DEFINED__
#define __ITLegacyAddressMediaControl2_FWD_DEFINED__
typedef interface ITLegacyAddressMediaControl2 ITLegacyAddressMediaControl2;
#endif 	/* __ITLegacyAddressMediaControl2_FWD_DEFINED__ */


#ifndef __ITLegacyCallMediaControl_FWD_DEFINED__
#define __ITLegacyCallMediaControl_FWD_DEFINED__
typedef interface ITLegacyCallMediaControl ITLegacyCallMediaControl;
#endif 	/* __ITLegacyCallMediaControl_FWD_DEFINED__ */


#ifndef __ITLegacyCallMediaControl2_FWD_DEFINED__
#define __ITLegacyCallMediaControl2_FWD_DEFINED__
typedef interface ITLegacyCallMediaControl2 ITLegacyCallMediaControl2;
#endif 	/* __ITLegacyCallMediaControl2_FWD_DEFINED__ */


#ifndef __ITDetectTone_FWD_DEFINED__
#define __ITDetectTone_FWD_DEFINED__
typedef interface ITDetectTone ITDetectTone;
#endif 	/* __ITDetectTone_FWD_DEFINED__ */


#ifndef __ITCustomTone_FWD_DEFINED__
#define __ITCustomTone_FWD_DEFINED__
typedef interface ITCustomTone ITCustomTone;
#endif 	/* __ITCustomTone_FWD_DEFINED__ */


#ifndef __IEnumPhone_FWD_DEFINED__
#define __IEnumPhone_FWD_DEFINED__
typedef interface IEnumPhone IEnumPhone;
#endif 	/* __IEnumPhone_FWD_DEFINED__ */


#ifndef __IEnumTerminal_FWD_DEFINED__
#define __IEnumTerminal_FWD_DEFINED__
typedef interface IEnumTerminal IEnumTerminal;
#endif 	/* __IEnumTerminal_FWD_DEFINED__ */


#ifndef __IEnumTerminalClass_FWD_DEFINED__
#define __IEnumTerminalClass_FWD_DEFINED__
typedef interface IEnumTerminalClass IEnumTerminalClass;
#endif 	/* __IEnumTerminalClass_FWD_DEFINED__ */


#ifndef __IEnumCall_FWD_DEFINED__
#define __IEnumCall_FWD_DEFINED__
typedef interface IEnumCall IEnumCall;
#endif 	/* __IEnumCall_FWD_DEFINED__ */


#ifndef __IEnumAddress_FWD_DEFINED__
#define __IEnumAddress_FWD_DEFINED__
typedef interface IEnumAddress IEnumAddress;
#endif 	/* __IEnumAddress_FWD_DEFINED__ */


#ifndef __IEnumCallHub_FWD_DEFINED__
#define __IEnumCallHub_FWD_DEFINED__
typedef interface IEnumCallHub IEnumCallHub;
#endif 	/* __IEnumCallHub_FWD_DEFINED__ */


#ifndef __IEnumBstr_FWD_DEFINED__
#define __IEnumBstr_FWD_DEFINED__
typedef interface IEnumBstr IEnumBstr;
#endif 	/* __IEnumBstr_FWD_DEFINED__ */


#ifndef __IEnumPluggableTerminalClassInfo_FWD_DEFINED__
#define __IEnumPluggableTerminalClassInfo_FWD_DEFINED__
typedef interface IEnumPluggableTerminalClassInfo IEnumPluggableTerminalClassInfo;
#endif 	/* __IEnumPluggableTerminalClassInfo_FWD_DEFINED__ */


#ifndef __IEnumPluggableSuperclassInfo_FWD_DEFINED__
#define __IEnumPluggableSuperclassInfo_FWD_DEFINED__
typedef interface IEnumPluggableSuperclassInfo IEnumPluggableSuperclassInfo;
#endif 	/* __IEnumPluggableSuperclassInfo_FWD_DEFINED__ */


#ifndef __ITPhoneEvent_FWD_DEFINED__
#define __ITPhoneEvent_FWD_DEFINED__
typedef interface ITPhoneEvent ITPhoneEvent;
#endif 	/* __ITPhoneEvent_FWD_DEFINED__ */


#ifndef __ITCallStateEvent_FWD_DEFINED__
#define __ITCallStateEvent_FWD_DEFINED__
typedef interface ITCallStateEvent ITCallStateEvent;
#endif 	/* __ITCallStateEvent_FWD_DEFINED__ */


#ifndef __ITPhoneDeviceSpecificEvent_FWD_DEFINED__
#define __ITPhoneDeviceSpecificEvent_FWD_DEFINED__
typedef interface ITPhoneDeviceSpecificEvent ITPhoneDeviceSpecificEvent;
#endif 	/* __ITPhoneDeviceSpecificEvent_FWD_DEFINED__ */


#ifndef __ITCallMediaEvent_FWD_DEFINED__
#define __ITCallMediaEvent_FWD_DEFINED__
typedef interface ITCallMediaEvent ITCallMediaEvent;
#endif 	/* __ITCallMediaEvent_FWD_DEFINED__ */


#ifndef __ITDigitDetectionEvent_FWD_DEFINED__
#define __ITDigitDetectionEvent_FWD_DEFINED__
typedef interface ITDigitDetectionEvent ITDigitDetectionEvent;
#endif 	/* __ITDigitDetectionEvent_FWD_DEFINED__ */


#ifndef __ITDigitGenerationEvent_FWD_DEFINED__
#define __ITDigitGenerationEvent_FWD_DEFINED__
typedef interface ITDigitGenerationEvent ITDigitGenerationEvent;
#endif 	/* __ITDigitGenerationEvent_FWD_DEFINED__ */


#ifndef __ITDigitsGatheredEvent_FWD_DEFINED__
#define __ITDigitsGatheredEvent_FWD_DEFINED__
typedef interface ITDigitsGatheredEvent ITDigitsGatheredEvent;
#endif 	/* __ITDigitsGatheredEvent_FWD_DEFINED__ */


#ifndef __ITToneDetectionEvent_FWD_DEFINED__
#define __ITToneDetectionEvent_FWD_DEFINED__
typedef interface ITToneDetectionEvent ITToneDetectionEvent;
#endif 	/* __ITToneDetectionEvent_FWD_DEFINED__ */


#ifndef __ITTAPIObjectEvent_FWD_DEFINED__
#define __ITTAPIObjectEvent_FWD_DEFINED__
typedef interface ITTAPIObjectEvent ITTAPIObjectEvent;
#endif 	/* __ITTAPIObjectEvent_FWD_DEFINED__ */


#ifndef __ITTAPIObjectEvent2_FWD_DEFINED__
#define __ITTAPIObjectEvent2_FWD_DEFINED__
typedef interface ITTAPIObjectEvent2 ITTAPIObjectEvent2;
#endif 	/* __ITTAPIObjectEvent2_FWD_DEFINED__ */


#ifndef __ITTAPIEventNotification_FWD_DEFINED__
#define __ITTAPIEventNotification_FWD_DEFINED__
typedef interface ITTAPIEventNotification ITTAPIEventNotification;
#endif 	/* __ITTAPIEventNotification_FWD_DEFINED__ */


#ifndef __ITCallHubEvent_FWD_DEFINED__
#define __ITCallHubEvent_FWD_DEFINED__
typedef interface ITCallHubEvent ITCallHubEvent;
#endif 	/* __ITCallHubEvent_FWD_DEFINED__ */


#ifndef __ITAddressEvent_FWD_DEFINED__
#define __ITAddressEvent_FWD_DEFINED__
typedef interface ITAddressEvent ITAddressEvent;
#endif 	/* __ITAddressEvent_FWD_DEFINED__ */


#ifndef __ITAddressDeviceSpecificEvent_FWD_DEFINED__
#define __ITAddressDeviceSpecificEvent_FWD_DEFINED__
typedef interface ITAddressDeviceSpecificEvent ITAddressDeviceSpecificEvent;
#endif 	/* __ITAddressDeviceSpecificEvent_FWD_DEFINED__ */


#ifndef __ITFileTerminalEvent_FWD_DEFINED__
#define __ITFileTerminalEvent_FWD_DEFINED__
typedef interface ITFileTerminalEvent ITFileTerminalEvent;
#endif 	/* __ITFileTerminalEvent_FWD_DEFINED__ */


#ifndef __ITTTSTerminalEvent_FWD_DEFINED__
#define __ITTTSTerminalEvent_FWD_DEFINED__
typedef interface ITTTSTerminalEvent ITTTSTerminalEvent;
#endif 	/* __ITTTSTerminalEvent_FWD_DEFINED__ */


#ifndef __ITASRTerminalEvent_FWD_DEFINED__
#define __ITASRTerminalEvent_FWD_DEFINED__
typedef interface ITASRTerminalEvent ITASRTerminalEvent;
#endif 	/* __ITASRTerminalEvent_FWD_DEFINED__ */


#ifndef __ITToneTerminalEvent_FWD_DEFINED__
#define __ITToneTerminalEvent_FWD_DEFINED__
typedef interface ITToneTerminalEvent ITToneTerminalEvent;
#endif 	/* __ITToneTerminalEvent_FWD_DEFINED__ */


#ifndef __ITQOSEvent_FWD_DEFINED__
#define __ITQOSEvent_FWD_DEFINED__
typedef interface ITQOSEvent ITQOSEvent;
#endif 	/* __ITQOSEvent_FWD_DEFINED__ */


#ifndef __ITCallInfoChangeEvent_FWD_DEFINED__
#define __ITCallInfoChangeEvent_FWD_DEFINED__
typedef interface ITCallInfoChangeEvent ITCallInfoChangeEvent;
#endif 	/* __ITCallInfoChangeEvent_FWD_DEFINED__ */


#ifndef __ITRequest_FWD_DEFINED__
#define __ITRequest_FWD_DEFINED__
typedef interface ITRequest ITRequest;
#endif 	/* __ITRequest_FWD_DEFINED__ */


#ifndef __ITRequestEvent_FWD_DEFINED__
#define __ITRequestEvent_FWD_DEFINED__
typedef interface ITRequestEvent ITRequestEvent;
#endif 	/* __ITRequestEvent_FWD_DEFINED__ */


#ifndef __ITCollection_FWD_DEFINED__
#define __ITCollection_FWD_DEFINED__
typedef interface ITCollection ITCollection;
#endif 	/* __ITCollection_FWD_DEFINED__ */


#ifndef __ITCollection2_FWD_DEFINED__
#define __ITCollection2_FWD_DEFINED__
typedef interface ITCollection2 ITCollection2;
#endif 	/* __ITCollection2_FWD_DEFINED__ */


#ifndef __ITForwardInformation_FWD_DEFINED__
#define __ITForwardInformation_FWD_DEFINED__
typedef interface ITForwardInformation ITForwardInformation;
#endif 	/* __ITForwardInformation_FWD_DEFINED__ */


#ifndef __ITForwardInformation2_FWD_DEFINED__
#define __ITForwardInformation2_FWD_DEFINED__
typedef interface ITForwardInformation2 ITForwardInformation2;
#endif 	/* __ITForwardInformation2_FWD_DEFINED__ */


#ifndef __ITAddressTranslation_FWD_DEFINED__
#define __ITAddressTranslation_FWD_DEFINED__
typedef interface ITAddressTranslation ITAddressTranslation;
#endif 	/* __ITAddressTranslation_FWD_DEFINED__ */


#ifndef __ITAddressTranslationInfo_FWD_DEFINED__
#define __ITAddressTranslationInfo_FWD_DEFINED__
typedef interface ITAddressTranslationInfo ITAddressTranslationInfo;
#endif 	/* __ITAddressTranslationInfo_FWD_DEFINED__ */


#ifndef __ITLocationInfo_FWD_DEFINED__
#define __ITLocationInfo_FWD_DEFINED__
typedef interface ITLocationInfo ITLocationInfo;
#endif 	/* __ITLocationInfo_FWD_DEFINED__ */


#ifndef __IEnumLocation_FWD_DEFINED__
#define __IEnumLocation_FWD_DEFINED__
typedef interface IEnumLocation IEnumLocation;
#endif 	/* __IEnumLocation_FWD_DEFINED__ */


#ifndef __ITCallingCard_FWD_DEFINED__
#define __ITCallingCard_FWD_DEFINED__
typedef interface ITCallingCard ITCallingCard;
#endif 	/* __ITCallingCard_FWD_DEFINED__ */


#ifndef __IEnumCallingCard_FWD_DEFINED__
#define __IEnumCallingCard_FWD_DEFINED__
typedef interface IEnumCallingCard IEnumCallingCard;
#endif 	/* __IEnumCallingCard_FWD_DEFINED__ */


#ifndef __ITCallNotificationEvent_FWD_DEFINED__
#define __ITCallNotificationEvent_FWD_DEFINED__
typedef interface ITCallNotificationEvent ITCallNotificationEvent;
#endif 	/* __ITCallNotificationEvent_FWD_DEFINED__ */


#ifndef __ITDispatchMapper_FWD_DEFINED__
#define __ITDispatchMapper_FWD_DEFINED__
typedef interface ITDispatchMapper ITDispatchMapper;
#endif 	/* __ITDispatchMapper_FWD_DEFINED__ */


#ifndef __ITStreamControl_FWD_DEFINED__
#define __ITStreamControl_FWD_DEFINED__
typedef interface ITStreamControl ITStreamControl;
#endif 	/* __ITStreamControl_FWD_DEFINED__ */


#ifndef __ITStream_FWD_DEFINED__
#define __ITStream_FWD_DEFINED__
typedef interface ITStream ITStream;
#endif 	/* __ITStream_FWD_DEFINED__ */


#ifndef __IEnumStream_FWD_DEFINED__
#define __IEnumStream_FWD_DEFINED__
typedef interface IEnumStream IEnumStream;
#endif 	/* __IEnumStream_FWD_DEFINED__ */


#ifndef __ITSubStreamControl_FWD_DEFINED__
#define __ITSubStreamControl_FWD_DEFINED__
typedef interface ITSubStreamControl ITSubStreamControl;
#endif 	/* __ITSubStreamControl_FWD_DEFINED__ */


#ifndef __ITSubStream_FWD_DEFINED__
#define __ITSubStream_FWD_DEFINED__
typedef interface ITSubStream ITSubStream;
#endif 	/* __ITSubStream_FWD_DEFINED__ */


#ifndef __IEnumSubStream_FWD_DEFINED__
#define __IEnumSubStream_FWD_DEFINED__
typedef interface IEnumSubStream IEnumSubStream;
#endif 	/* __IEnumSubStream_FWD_DEFINED__ */


#ifndef __ITLegacyWaveSupport_FWD_DEFINED__
#define __ITLegacyWaveSupport_FWD_DEFINED__
typedef interface ITLegacyWaveSupport ITLegacyWaveSupport;
#endif 	/* __ITLegacyWaveSupport_FWD_DEFINED__ */


#ifndef __ITBasicCallControl2_FWD_DEFINED__
#define __ITBasicCallControl2_FWD_DEFINED__
typedef interface ITBasicCallControl2 ITBasicCallControl2;
#endif 	/* __ITBasicCallControl2_FWD_DEFINED__ */


#ifndef __ITScriptableAudioFormat_FWD_DEFINED__
#define __ITScriptableAudioFormat_FWD_DEFINED__
typedef interface ITScriptableAudioFormat ITScriptableAudioFormat;
#endif 	/* __ITScriptableAudioFormat_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_tapi3if_0000_0000 */
/* [local] */ 

/* Copyright (c) Microsoft Corporation. All rights reserved. */

#if 0
typedef long TAPIHWND;

#endif
#ifdef _X86_
typedef long TAPIHWND;
#else
typedef LONGLONG TAPIHWND;
#endif
typedef long TAPI_DIGITMODE;

typedef 
enum TAPI_TONEMODE
    {	TTM_RINGBACK	= 0x2,
	TTM_BUSY	= 0x4,
	TTM_BEEP	= 0x8,
	TTM_BILLING	= 0x10
    } 	TAPI_TONEMODE;

typedef 
enum TAPI_GATHERTERM
    {	TGT_BUFFERFULL	= 0x1,
	TGT_TERMDIGIT	= 0x2,
	TGT_FIRSTTIMEOUT	= 0x4,
	TGT_INTERTIMEOUT	= 0x8,
	TGT_CANCEL	= 0x10
    } 	TAPI_GATHERTERM;

typedef struct TAPI_CUSTOMTONE
    {
    DWORD dwFrequency;
    DWORD dwCadenceOn;
    DWORD dwCadenceOff;
    DWORD dwVolume;
    } 	TAPI_CUSTOMTONE;

typedef struct TAPI_CUSTOMTONE *LPTAPI_CUSTOMTONE;

typedef struct TAPI_DETECTTONE
    {
    DWORD dwAppSpecific;
    DWORD dwDuration;
    DWORD dwFrequency1;
    DWORD dwFrequency2;
    DWORD dwFrequency3;
    } 	TAPI_DETECTTONE;

typedef struct TAPI_DETECTTONE *LPTAPI_DETECTTONE;

typedef 
enum ADDRESS_EVENT
    {	AE_STATE	= 0,
	AE_CAPSCHANGE	= ( AE_STATE + 1 ) ,
	AE_RINGING	= ( AE_CAPSCHANGE + 1 ) ,
	AE_CONFIGCHANGE	= ( AE_RINGING + 1 ) ,
	AE_FORWARD	= ( AE_CONFIGCHANGE + 1 ) ,
	AE_NEWTERMINAL	= ( AE_FORWARD + 1 ) ,
	AE_REMOVETERMINAL	= ( AE_NEWTERMINAL + 1 ) ,
	AE_MSGWAITON	= ( AE_REMOVETERMINAL + 1 ) ,
	AE_MSGWAITOFF	= ( AE_MSGWAITON + 1 ) ,
	AE_LASTITEM	= AE_MSGWAITOFF
    } 	ADDRESS_EVENT;

typedef 
enum ADDRESS_STATE
    {	AS_INSERVICE	= 0,
	AS_OUTOFSERVICE	= ( AS_INSERVICE + 1 ) 
    } 	ADDRESS_STATE;

typedef 
enum CALL_STATE
    {	CS_IDLE	= 0,
	CS_INPROGRESS	= ( CS_IDLE + 1 ) ,
	CS_CONNECTED	= ( CS_INPROGRESS + 1 ) ,
	CS_DISCONNECTED	= ( CS_CONNECTED + 1 ) ,
	CS_OFFERING	= ( CS_DISCONNECTED + 1 ) ,
	CS_HOLD	= ( CS_OFFERING + 1 ) ,
	CS_QUEUED	= ( CS_HOLD + 1 ) ,
	CS_LASTITEM	= CS_QUEUED
    } 	CALL_STATE;

typedef 
enum CALL_STATE_EVENT_CAUSE
    {	CEC_NONE	= 0,
	CEC_DISCONNECT_NORMAL	= ( CEC_NONE + 1 ) ,
	CEC_DISCONNECT_BUSY	= ( CEC_DISCONNECT_NORMAL + 1 ) ,
	CEC_DISCONNECT_BADADDRESS	= ( CEC_DISCONNECT_BUSY + 1 ) ,
	CEC_DISCONNECT_NOANSWER	= ( CEC_DISCONNECT_BADADDRESS + 1 ) ,
	CEC_DISCONNECT_CANCELLED	= ( CEC_DISCONNECT_NOANSWER + 1 ) ,
	CEC_DISCONNECT_REJECTED	= ( CEC_DISCONNECT_CANCELLED + 1 ) ,
	CEC_DISCONNECT_FAILED	= ( CEC_DISCONNECT_REJECTED + 1 ) ,
	CEC_DISCONNECT_BLOCKED	= ( CEC_DISCONNECT_FAILED + 1 ) 
    } 	CALL_STATE_EVENT_CAUSE;

typedef 
enum CALL_MEDIA_EVENT
    {	CME_NEW_STREAM	= 0,
	CME_STREAM_FAIL	= ( CME_NEW_STREAM + 1 ) ,
	CME_TERMINAL_FAIL	= ( CME_STREAM_FAIL + 1 ) ,
	CME_STREAM_NOT_USED	= ( CME_TERMINAL_FAIL + 1 ) ,
	CME_STREAM_ACTIVE	= ( CME_STREAM_NOT_USED + 1 ) ,
	CME_STREAM_INACTIVE	= ( CME_STREAM_ACTIVE + 1 ) ,
	CME_LASTITEM	= CME_STREAM_INACTIVE
    } 	CALL_MEDIA_EVENT;

typedef 
enum CALL_MEDIA_EVENT_CAUSE
    {	CMC_UNKNOWN	= 0,
	CMC_BAD_DEVICE	= ( CMC_UNKNOWN + 1 ) ,
	CMC_CONNECT_FAIL	= ( CMC_BAD_DEVICE + 1 ) ,
	CMC_LOCAL_REQUEST	= ( CMC_CONNECT_FAIL + 1 ) ,
	CMC_REMOTE_REQUEST	= ( CMC_LOCAL_REQUEST + 1 ) ,
	CMC_MEDIA_TIMEOUT	= ( CMC_REMOTE_REQUEST + 1 ) ,
	CMC_MEDIA_RECOVERED	= ( CMC_MEDIA_TIMEOUT + 1 ) ,
	CMC_QUALITY_OF_SERVICE	= ( CMC_MEDIA_RECOVERED + 1 ) 
    } 	CALL_MEDIA_EVENT_CAUSE;

typedef 
enum DISCONNECT_CODE
    {	DC_NORMAL	= 0,
	DC_NOANSWER	= ( DC_NORMAL + 1 ) ,
	DC_REJECTED	= ( DC_NOANSWER + 1 ) 
    } 	DISCONNECT_CODE;

typedef 
enum TERMINAL_STATE
    {	TS_INUSE	= 0,
	TS_NOTINUSE	= ( TS_INUSE + 1 ) 
    } 	TERMINAL_STATE;

typedef 
enum TERMINAL_DIRECTION
    {	TD_CAPTURE	= 0,
	TD_RENDER	= ( TD_CAPTURE + 1 ) ,
	TD_BIDIRECTIONAL	= ( TD_RENDER + 1 ) ,
	TD_MULTITRACK_MIXED	= ( TD_BIDIRECTIONAL + 1 ) ,
	TD_NONE	= ( TD_MULTITRACK_MIXED + 1 ) 
    } 	TERMINAL_DIRECTION;

typedef 
enum TERMINAL_TYPE
    {	TT_STATIC	= 0,
	TT_DYNAMIC	= ( TT_STATIC + 1 ) 
    } 	TERMINAL_TYPE;

typedef 
enum CALL_PRIVILEGE
    {	CP_OWNER	= 0,
	CP_MONITOR	= ( CP_OWNER + 1 ) 
    } 	CALL_PRIVILEGE;

typedef 
enum TAPI_EVENT
    {	TE_TAPIOBJECT	= 0x1,
	TE_ADDRESS	= 0x2,
	TE_CALLNOTIFICATION	= 0x4,
	TE_CALLSTATE	= 0x8,
	TE_CALLMEDIA	= 0x10,
	TE_CALLHUB	= 0x20,
	TE_CALLINFOCHANGE	= 0x40,
	TE_PRIVATE	= 0x80,
	TE_REQUEST	= 0x100,
	TE_AGENT	= 0x200,
	TE_AGENTSESSION	= 0x400,
	TE_QOSEVENT	= 0x800,
	TE_AGENTHANDLER	= 0x1000,
	TE_ACDGROUP	= 0x2000,
	TE_QUEUE	= 0x4000,
	TE_DIGITEVENT	= 0x8000,
	TE_GENERATEEVENT	= 0x10000,
	TE_ASRTERMINAL	= 0x20000,
	TE_TTSTERMINAL	= 0x40000,
	TE_FILETERMINAL	= 0x80000,
	TE_TONETERMINAL	= 0x100000,
	TE_PHONEEVENT	= 0x200000,
	TE_TONEEVENT	= 0x400000,
	TE_GATHERDIGITS	= 0x800000,
	TE_ADDRESSDEVSPECIFIC	= 0x1000000,
	TE_PHONEDEVSPECIFIC	= 0x2000000
    } 	TAPI_EVENT;

typedef 
enum CALL_NOTIFICATION_EVENT
    {	CNE_OWNER	= 0,
	CNE_MONITOR	= ( CNE_OWNER + 1 ) ,
	CNE_LASTITEM	= CNE_MONITOR
    } 	CALL_NOTIFICATION_EVENT;

typedef 
enum CALLHUB_EVENT
    {	CHE_CALLJOIN	= 0,
	CHE_CALLLEAVE	= ( CHE_CALLJOIN + 1 ) ,
	CHE_CALLHUBNEW	= ( CHE_CALLLEAVE + 1 ) ,
	CHE_CALLHUBIDLE	= ( CHE_CALLHUBNEW + 1 ) ,
	CHE_LASTITEM	= CHE_CALLHUBIDLE
    } 	CALLHUB_EVENT;

typedef 
enum CALLHUB_STATE
    {	CHS_ACTIVE	= 0,
	CHS_IDLE	= ( CHS_ACTIVE + 1 ) 
    } 	CALLHUB_STATE;

typedef 
enum TAPIOBJECT_EVENT
    {	TE_ADDRESSCREATE	= 0,
	TE_ADDRESSREMOVE	= ( TE_ADDRESSCREATE + 1 ) ,
	TE_REINIT	= ( TE_ADDRESSREMOVE + 1 ) ,
	TE_TRANSLATECHANGE	= ( TE_REINIT + 1 ) ,
	TE_ADDRESSCLOSE	= ( TE_TRANSLATECHANGE + 1 ) ,
	TE_PHONECREATE	= ( TE_ADDRESSCLOSE + 1 ) ,
	TE_PHONEREMOVE	= ( TE_PHONECREATE + 1 ) 
    } 	TAPIOBJECT_EVENT;

typedef 
enum TAPI_OBJECT_TYPE
    {	TOT_NONE	= 0,
	TOT_TAPI	= ( TOT_NONE + 1 ) ,
	TOT_ADDRESS	= ( TOT_TAPI + 1 ) ,
	TOT_TERMINAL	= ( TOT_ADDRESS + 1 ) ,
	TOT_CALL	= ( TOT_TERMINAL + 1 ) ,
	TOT_CALLHUB	= ( TOT_CALL + 1 ) ,
	TOT_PHONE	= ( TOT_CALLHUB + 1 ) 
    } 	TAPI_OBJECT_TYPE;

typedef 
enum QOS_SERVICE_LEVEL
    {	QSL_NEEDED	= 1,
	QSL_IF_AVAILABLE	= 2,
	QSL_BEST_EFFORT	= 3
    } 	QOS_SERVICE_LEVEL;

typedef 
enum QOS_EVENT
    {	QE_NOQOS	= 1,
	QE_ADMISSIONFAILURE	= 2,
	QE_POLICYFAILURE	= 3,
	QE_GENERICERROR	= 4,
	QE_LASTITEM	= QE_GENERICERROR
    } 	QOS_EVENT;

typedef 
enum CALLINFOCHANGE_CAUSE
    {	CIC_OTHER	= 0,
	CIC_DEVSPECIFIC	= ( CIC_OTHER + 1 ) ,
	CIC_BEARERMODE	= ( CIC_DEVSPECIFIC + 1 ) ,
	CIC_RATE	= ( CIC_BEARERMODE + 1 ) ,
	CIC_APPSPECIFIC	= ( CIC_RATE + 1 ) ,
	CIC_CALLID	= ( CIC_APPSPECIFIC + 1 ) ,
	CIC_RELATEDCALLID	= ( CIC_CALLID + 1 ) ,
	CIC_ORIGIN	= ( CIC_RELATEDCALLID + 1 ) ,
	CIC_REASON	= ( CIC_ORIGIN + 1 ) ,
	CIC_COMPLETIONID	= ( CIC_REASON + 1 ) ,
	CIC_NUMOWNERINCR	= ( CIC_COMPLETIONID + 1 ) ,
	CIC_NUMOWNERDECR	= ( CIC_NUMOWNERINCR + 1 ) ,
	CIC_NUMMONITORS	= ( CIC_NUMOWNERDECR + 1 ) ,
	CIC_TRUNK	= ( CIC_NUMMONITORS + 1 ) ,
	CIC_CALLERID	= ( CIC_TRUNK + 1 ) ,
	CIC_CALLEDID	= ( CIC_CALLERID + 1 ) ,
	CIC_CONNECTEDID	= ( CIC_CALLEDID + 1 ) ,
	CIC_REDIRECTIONID	= ( CIC_CONNECTEDID + 1 ) ,
	CIC_REDIRECTINGID	= ( CIC_REDIRECTIONID + 1 ) ,
	CIC_USERUSERINFO	= ( CIC_REDIRECTINGID + 1 ) ,
	CIC_HIGHLEVELCOMP	= ( CIC_USERUSERINFO + 1 ) ,
	CIC_LOWLEVELCOMP	= ( CIC_HIGHLEVELCOMP + 1 ) ,
	CIC_CHARGINGINFO	= ( CIC_LOWLEVELCOMP + 1 ) ,
	CIC_TREATMENT	= ( CIC_CHARGINGINFO + 1 ) ,
	CIC_CALLDATA	= ( CIC_TREATMENT + 1 ) ,
	CIC_PRIVILEGE	= ( CIC_CALLDATA + 1 ) ,
	CIC_MEDIATYPE	= ( CIC_PRIVILEGE + 1 ) ,
	CIC_LASTITEM	= CIC_MEDIATYPE
    } 	CALLINFOCHANGE_CAUSE;

typedef 
enum CALLINFO_LONG
    {	CIL_MEDIATYPESAVAILABLE	= 0,
	CIL_BEARERMODE	= ( CIL_MEDIATYPESAVAILABLE + 1 ) ,
	CIL_CALLERIDADDRESSTYPE	= ( CIL_BEARERMODE + 1 ) ,
	CIL_CALLEDIDADDRESSTYPE	= ( CIL_CALLERIDADDRESSTYPE + 1 ) ,
	CIL_CONNECTEDIDADDRESSTYPE	= ( CIL_CALLEDIDADDRESSTYPE + 1 ) ,
	CIL_REDIRECTIONIDADDRESSTYPE	= ( CIL_CONNECTEDIDADDRESSTYPE + 1 ) ,
	CIL_REDIRECTINGIDADDRESSTYPE	= ( CIL_REDIRECTIONIDADDRESSTYPE + 1 ) ,
	CIL_ORIGIN	= ( CIL_REDIRECTINGIDADDRESSTYPE + 1 ) ,
	CIL_REASON	= ( CIL_ORIGIN + 1 ) ,
	CIL_APPSPECIFIC	= ( CIL_REASON + 1 ) ,
	CIL_CALLPARAMSFLAGS	= ( CIL_APPSPECIFIC + 1 ) ,
	CIL_CALLTREATMENT	= ( CIL_CALLPARAMSFLAGS + 1 ) ,
	CIL_MINRATE	= ( CIL_CALLTREATMENT + 1 ) ,
	CIL_MAXRATE	= ( CIL_MINRATE + 1 ) ,
	CIL_COUNTRYCODE	= ( CIL_MAXRATE + 1 ) ,
	CIL_CALLID	= ( CIL_COUNTRYCODE + 1 ) ,
	CIL_RELATEDCALLID	= ( CIL_CALLID + 1 ) ,
	CIL_COMPLETIONID	= ( CIL_RELATEDCALLID + 1 ) ,
	CIL_NUMBEROFOWNERS	= ( CIL_COMPLETIONID + 1 ) ,
	CIL_NUMBEROFMONITORS	= ( CIL_NUMBEROFOWNERS + 1 ) ,
	CIL_TRUNK	= ( CIL_NUMBEROFMONITORS + 1 ) ,
	CIL_RATE	= ( CIL_TRUNK + 1 ) ,
	CIL_GENERATEDIGITDURATION	= ( CIL_RATE + 1 ) ,
	CIL_MONITORDIGITMODES	= ( CIL_GENERATEDIGITDURATION + 1 ) ,
	CIL_MONITORMEDIAMODES	= ( CIL_MONITORDIGITMODES + 1 ) 
    } 	CALLINFO_LONG;

typedef 
enum CALLINFO_STRING
    {	CIS_CALLERIDNAME	= 0,
	CIS_CALLERIDNUMBER	= ( CIS_CALLERIDNAME + 1 ) ,
	CIS_CALLEDIDNAME	= ( CIS_CALLERIDNUMBER + 1 ) ,
	CIS_CALLEDIDNUMBER	= ( CIS_CALLEDIDNAME + 1 ) ,
	CIS_CONNECTEDIDNAME	= ( CIS_CALLEDIDNUMBER + 1 ) ,
	CIS_CONNECTEDIDNUMBER	= ( CIS_CONNECTEDIDNAME + 1 ) ,
	CIS_REDIRECTIONIDNAME	= ( CIS_CONNECTEDIDNUMBER + 1 ) ,
	CIS_REDIRECTIONIDNUMBER	= ( CIS_REDIRECTIONIDNAME + 1 ) ,
	CIS_REDIRECTINGIDNAME	= ( CIS_REDIRECTIONIDNUMBER + 1 ) ,
	CIS_REDIRECTINGIDNUMBER	= ( CIS_REDIRECTINGIDNAME + 1 ) ,
	CIS_CALLEDPARTYFRIENDLYNAME	= ( CIS_REDIRECTINGIDNUMBER + 1 ) ,
	CIS_COMMENT	= ( CIS_CALLEDPARTYFRIENDLYNAME + 1 ) ,
	CIS_DISPLAYABLEADDRESS	= ( CIS_COMMENT + 1 ) ,
	CIS_CALLINGPARTYID	= ( CIS_DISPLAYABLEADDRESS + 1 ) 
    } 	CALLINFO_STRING;

typedef 
enum CALLINFO_BUFFER
    {	CIB_USERUSERINFO	= 0,
	CIB_DEVSPECIFICBUFFER	= ( CIB_USERUSERINFO + 1 ) ,
	CIB_CALLDATABUFFER	= ( CIB_DEVSPECIFICBUFFER + 1 ) ,
	CIB_CHARGINGINFOBUFFER	= ( CIB_CALLDATABUFFER + 1 ) ,
	CIB_HIGHLEVELCOMPATIBILITYBUFFER	= ( CIB_CHARGINGINFOBUFFER + 1 ) ,
	CIB_LOWLEVELCOMPATIBILITYBUFFER	= ( CIB_HIGHLEVELCOMPATIBILITYBUFFER + 1 ) 
    } 	CALLINFO_BUFFER;

typedef 
enum ADDRESS_CAPABILITY
    {	AC_ADDRESSTYPES	= 0,
	AC_BEARERMODES	= ( AC_ADDRESSTYPES + 1 ) ,
	AC_MAXACTIVECALLS	= ( AC_BEARERMODES + 1 ) ,
	AC_MAXONHOLDCALLS	= ( AC_MAXACTIVECALLS + 1 ) ,
	AC_MAXONHOLDPENDINGCALLS	= ( AC_MAXONHOLDCALLS + 1 ) ,
	AC_MAXNUMCONFERENCE	= ( AC_MAXONHOLDPENDINGCALLS + 1 ) ,
	AC_MAXNUMTRANSCONF	= ( AC_MAXNUMCONFERENCE + 1 ) ,
	AC_MONITORDIGITSUPPORT	= ( AC_MAXNUMTRANSCONF + 1 ) ,
	AC_GENERATEDIGITSUPPORT	= ( AC_MONITORDIGITSUPPORT + 1 ) ,
	AC_GENERATETONEMODES	= ( AC_GENERATEDIGITSUPPORT + 1 ) ,
	AC_GENERATETONEMAXNUMFREQ	= ( AC_GENERATETONEMODES + 1 ) ,
	AC_MONITORTONEMAXNUMFREQ	= ( AC_GENERATETONEMAXNUMFREQ + 1 ) ,
	AC_MONITORTONEMAXNUMENTRIES	= ( AC_MONITORTONEMAXNUMFREQ + 1 ) ,
	AC_DEVCAPFLAGS	= ( AC_MONITORTONEMAXNUMENTRIES + 1 ) ,
	AC_ANSWERMODES	= ( AC_DEVCAPFLAGS + 1 ) ,
	AC_LINEFEATURES	= ( AC_ANSWERMODES + 1 ) ,
	AC_SETTABLEDEVSTATUS	= ( AC_LINEFEATURES + 1 ) ,
	AC_PARKSUPPORT	= ( AC_SETTABLEDEVSTATUS + 1 ) ,
	AC_CALLERIDSUPPORT	= ( AC_PARKSUPPORT + 1 ) ,
	AC_CALLEDIDSUPPORT	= ( AC_CALLERIDSUPPORT + 1 ) ,
	AC_CONNECTEDIDSUPPORT	= ( AC_CALLEDIDSUPPORT + 1 ) ,
	AC_REDIRECTIONIDSUPPORT	= ( AC_CONNECTEDIDSUPPORT + 1 ) ,
	AC_REDIRECTINGIDSUPPORT	= ( AC_REDIRECTIONIDSUPPORT + 1 ) ,
	AC_ADDRESSCAPFLAGS	= ( AC_REDIRECTINGIDSUPPORT + 1 ) ,
	AC_CALLFEATURES1	= ( AC_ADDRESSCAPFLAGS + 1 ) ,
	AC_CALLFEATURES2	= ( AC_CALLFEATURES1 + 1 ) ,
	AC_REMOVEFROMCONFCAPS	= ( AC_CALLFEATURES2 + 1 ) ,
	AC_REMOVEFROMCONFSTATE	= ( AC_REMOVEFROMCONFCAPS + 1 ) ,
	AC_TRANSFERMODES	= ( AC_REMOVEFROMCONFSTATE + 1 ) ,
	AC_ADDRESSFEATURES	= ( AC_TRANSFERMODES + 1 ) ,
	AC_PREDICTIVEAUTOTRANSFERSTATES	= ( AC_ADDRESSFEATURES + 1 ) ,
	AC_MAXCALLDATASIZE	= ( AC_PREDICTIVEAUTOTRANSFERSTATES + 1 ) ,
	AC_LINEID	= ( AC_MAXCALLDATASIZE + 1 ) ,
	AC_ADDRESSID	= ( AC_LINEID + 1 ) ,
	AC_FORWARDMODES	= ( AC_ADDRESSID + 1 ) ,
	AC_MAXFORWARDENTRIES	= ( AC_FORWARDMODES + 1 ) ,
	AC_MAXSPECIFICENTRIES	= ( AC_MAXFORWARDENTRIES + 1 ) ,
	AC_MINFWDNUMRINGS	= ( AC_MAXSPECIFICENTRIES + 1 ) ,
	AC_MAXFWDNUMRINGS	= ( AC_MINFWDNUMRINGS + 1 ) ,
	AC_MAXCALLCOMPLETIONS	= ( AC_MAXFWDNUMRINGS + 1 ) ,
	AC_CALLCOMPLETIONCONDITIONS	= ( AC_MAXCALLCOMPLETIONS + 1 ) ,
	AC_CALLCOMPLETIONMODES	= ( AC_CALLCOMPLETIONCONDITIONS + 1 ) ,
	AC_PERMANENTDEVICEID	= ( AC_CALLCOMPLETIONMODES + 1 ) ,
	AC_GATHERDIGITSMINTIMEOUT	= ( AC_PERMANENTDEVICEID + 1 ) ,
	AC_GATHERDIGITSMAXTIMEOUT	= ( AC_GATHERDIGITSMINTIMEOUT + 1 ) ,
	AC_GENERATEDIGITMINDURATION	= ( AC_GATHERDIGITSMAXTIMEOUT + 1 ) ,
	AC_GENERATEDIGITMAXDURATION	= ( AC_GENERATEDIGITMINDURATION + 1 ) ,
	AC_GENERATEDIGITDEFAULTDURATION	= ( AC_GENERATEDIGITMAXDURATION + 1 ) 
    } 	ADDRESS_CAPABILITY;

typedef 
enum ADDRESS_CAPABILITY_STRING
    {	ACS_PROTOCOL	= 0,
	ACS_ADDRESSDEVICESPECIFIC	= ( ACS_PROTOCOL + 1 ) ,
	ACS_LINEDEVICESPECIFIC	= ( ACS_ADDRESSDEVICESPECIFIC + 1 ) ,
	ACS_PROVIDERSPECIFIC	= ( ACS_LINEDEVICESPECIFIC + 1 ) ,
	ACS_SWITCHSPECIFIC	= ( ACS_PROVIDERSPECIFIC + 1 ) ,
	ACS_PERMANENTDEVICEGUID	= ( ACS_SWITCHSPECIFIC + 1 ) 
    } 	ADDRESS_CAPABILITY_STRING;

typedef 
enum FULLDUPLEX_SUPPORT
    {	FDS_SUPPORTED	= 0,
	FDS_NOTSUPPORTED	= ( FDS_SUPPORTED + 1 ) ,
	FDS_UNKNOWN	= ( FDS_NOTSUPPORTED + 1 ) 
    } 	FULLDUPLEX_SUPPORT;

typedef 
enum FINISH_MODE
    {	FM_ASTRANSFER	= 0,
	FM_ASCONFERENCE	= ( FM_ASTRANSFER + 1 ) 
    } 	FINISH_MODE;

typedef 
enum PHONE_PRIVILEGE
    {	PP_OWNER	= 0,
	PP_MONITOR	= ( PP_OWNER + 1 ) 
    } 	PHONE_PRIVILEGE;

typedef 
enum PHONE_HOOK_SWITCH_DEVICE
    {	PHSD_HANDSET	= 0x1,
	PHSD_SPEAKERPHONE	= 0x2,
	PHSD_HEADSET	= 0x4
    } 	PHONE_HOOK_SWITCH_DEVICE;

typedef 
enum PHONE_HOOK_SWITCH_STATE
    {	PHSS_ONHOOK	= 0x1,
	PHSS_OFFHOOK_MIC_ONLY	= 0x2,
	PHSS_OFFHOOK_SPEAKER_ONLY	= 0x4,
	PHSS_OFFHOOK	= 0x8
    } 	PHONE_HOOK_SWITCH_STATE;

typedef 
enum PHONE_LAMP_MODE
    {	LM_DUMMY	= 0x1,
	LM_OFF	= 0x2,
	LM_STEADY	= 0x4,
	LM_WINK	= 0x8,
	LM_FLASH	= 0x10,
	LM_FLUTTER	= 0x20,
	LM_BROKENFLUTTER	= 0x40,
	LM_UNKNOWN	= 0x80
    } 	PHONE_LAMP_MODE;

typedef 
enum PHONECAPS_LONG
    {	PCL_HOOKSWITCHES	= 0,
	PCL_HANDSETHOOKSWITCHMODES	= ( PCL_HOOKSWITCHES + 1 ) ,
	PCL_HEADSETHOOKSWITCHMODES	= ( PCL_HANDSETHOOKSWITCHMODES + 1 ) ,
	PCL_SPEAKERPHONEHOOKSWITCHMODES	= ( PCL_HEADSETHOOKSWITCHMODES + 1 ) ,
	PCL_DISPLAYNUMROWS	= ( PCL_SPEAKERPHONEHOOKSWITCHMODES + 1 ) ,
	PCL_DISPLAYNUMCOLUMNS	= ( PCL_DISPLAYNUMROWS + 1 ) ,
	PCL_NUMRINGMODES	= ( PCL_DISPLAYNUMCOLUMNS + 1 ) ,
	PCL_NUMBUTTONLAMPS	= ( PCL_NUMRINGMODES + 1 ) ,
	PCL_GENERICPHONE	= ( PCL_NUMBUTTONLAMPS + 1 ) 
    } 	PHONECAPS_LONG;

typedef 
enum PHONECAPS_STRING
    {	PCS_PHONENAME	= 0,
	PCS_PHONEINFO	= ( PCS_PHONENAME + 1 ) ,
	PCS_PROVIDERINFO	= ( PCS_PHONEINFO + 1 ) 
    } 	PHONECAPS_STRING;

typedef 
enum PHONECAPS_BUFFER
    {	PCB_DEVSPECIFICBUFFER	= 0
    } 	PHONECAPS_BUFFER;

typedef 
enum PHONE_BUTTON_STATE
    {	PBS_UP	= 0x1,
	PBS_DOWN	= 0x2,
	PBS_UNKNOWN	= 0x4,
	PBS_UNAVAIL	= 0x8
    } 	PHONE_BUTTON_STATE;

typedef 
enum PHONE_BUTTON_MODE
    {	PBM_DUMMY	= 0,
	PBM_CALL	= ( PBM_DUMMY + 1 ) ,
	PBM_FEATURE	= ( PBM_CALL + 1 ) ,
	PBM_KEYPAD	= ( PBM_FEATURE + 1 ) ,
	PBM_LOCAL	= ( PBM_KEYPAD + 1 ) ,
	PBM_DISPLAY	= ( PBM_LOCAL + 1 ) 
    } 	PHONE_BUTTON_MODE;

typedef 
enum PHONE_BUTTON_FUNCTION
    {	PBF_UNKNOWN	= 0,
	PBF_CONFERENCE	= ( PBF_UNKNOWN + 1 ) ,
	PBF_TRANSFER	= ( PBF_CONFERENCE + 1 ) ,
	PBF_DROP	= ( PBF_TRANSFER + 1 ) ,
	PBF_HOLD	= ( PBF_DROP + 1 ) ,
	PBF_RECALL	= ( PBF_HOLD + 1 ) ,
	PBF_DISCONNECT	= ( PBF_RECALL + 1 ) ,
	PBF_CONNECT	= ( PBF_DISCONNECT + 1 ) ,
	PBF_MSGWAITON	= ( PBF_CONNECT + 1 ) ,
	PBF_MSGWAITOFF	= ( PBF_MSGWAITON + 1 ) ,
	PBF_SELECTRING	= ( PBF_MSGWAITOFF + 1 ) ,
	PBF_ABBREVDIAL	= ( PBF_SELECTRING + 1 ) ,
	PBF_FORWARD	= ( PBF_ABBREVDIAL + 1 ) ,
	PBF_PICKUP	= ( PBF_FORWARD + 1 ) ,
	PBF_RINGAGAIN	= ( PBF_PICKUP + 1 ) ,
	PBF_PARK	= ( PBF_RINGAGAIN + 1 ) ,
	PBF_REJECT	= ( PBF_PARK + 1 ) ,
	PBF_REDIRECT	= ( PBF_REJECT + 1 ) ,
	PBF_MUTE	= ( PBF_REDIRECT + 1 ) ,
	PBF_VOLUMEUP	= ( PBF_MUTE + 1 ) ,
	PBF_VOLUMEDOWN	= ( PBF_VOLUMEUP + 1 ) ,
	PBF_SPEAKERON	= ( PBF_VOLUMEDOWN + 1 ) ,
	PBF_SPEAKEROFF	= ( PBF_SPEAKERON + 1 ) ,
	PBF_FLASH	= ( PBF_SPEAKEROFF + 1 ) ,
	PBF_DATAON	= ( PBF_FLASH + 1 ) ,
	PBF_DATAOFF	= ( PBF_DATAON + 1 ) ,
	PBF_DONOTDISTURB	= ( PBF_DATAOFF + 1 ) ,
	PBF_INTERCOM	= ( PBF_DONOTDISTURB + 1 ) ,
	PBF_BRIDGEDAPP	= ( PBF_INTERCOM + 1 ) ,
	PBF_BUSY	= ( PBF_BRIDGEDAPP + 1 ) ,
	PBF_CALLAPP	= ( PBF_BUSY + 1 ) ,
	PBF_DATETIME	= ( PBF_CALLAPP + 1 ) ,
	PBF_DIRECTORY	= ( PBF_DATETIME + 1 ) ,
	PBF_COVER	= ( PBF_DIRECTORY + 1 ) ,
	PBF_CALLID	= ( PBF_COVER + 1 ) ,
	PBF_LASTNUM	= ( PBF_CALLID + 1 ) ,
	PBF_NIGHTSRV	= ( PBF_LASTNUM + 1 ) ,
	PBF_SENDCALLS	= ( PBF_NIGHTSRV + 1 ) ,
	PBF_MSGINDICATOR	= ( PBF_SENDCALLS + 1 ) ,
	PBF_REPDIAL	= ( PBF_MSGINDICATOR + 1 ) ,
	PBF_SETREPDIAL	= ( PBF_REPDIAL + 1 ) ,
	PBF_SYSTEMSPEED	= ( PBF_SETREPDIAL + 1 ) ,
	PBF_STATIONSPEED	= ( PBF_SYSTEMSPEED + 1 ) ,
	PBF_CAMPON	= ( PBF_STATIONSPEED + 1 ) ,
	PBF_SAVEREPEAT	= ( PBF_CAMPON + 1 ) ,
	PBF_QUEUECALL	= ( PBF_SAVEREPEAT + 1 ) ,
	PBF_NONE	= ( PBF_QUEUECALL + 1 ) ,
	PBF_SEND	= ( PBF_NONE + 1 ) 
    } 	PHONE_BUTTON_FUNCTION;

typedef 
enum PHONE_TONE
    {	PT_KEYPADZERO	= 0,
	PT_KEYPADONE	= ( PT_KEYPADZERO + 1 ) ,
	PT_KEYPADTWO	= ( PT_KEYPADONE + 1 ) ,
	PT_KEYPADTHREE	= ( PT_KEYPADTWO + 1 ) ,
	PT_KEYPADFOUR	= ( PT_KEYPADTHREE + 1 ) ,
	PT_KEYPADFIVE	= ( PT_KEYPADFOUR + 1 ) ,
	PT_KEYPADSIX	= ( PT_KEYPADFIVE + 1 ) ,
	PT_KEYPADSEVEN	= ( PT_KEYPADSIX + 1 ) ,
	PT_KEYPADEIGHT	= ( PT_KEYPADSEVEN + 1 ) ,
	PT_KEYPADNINE	= ( PT_KEYPADEIGHT + 1 ) ,
	PT_KEYPADSTAR	= ( PT_KEYPADNINE + 1 ) ,
	PT_KEYPADPOUND	= ( PT_KEYPADSTAR + 1 ) ,
	PT_KEYPADA	= ( PT_KEYPADPOUND + 1 ) ,
	PT_KEYPADB	= ( PT_KEYPADA + 1 ) ,
	PT_KEYPADC	= ( PT_KEYPADB + 1 ) ,
	PT_KEYPADD	= ( PT_KEYPADC + 1 ) ,
	PT_NORMALDIALTONE	= ( PT_KEYPADD + 1 ) ,
	PT_EXTERNALDIALTONE	= ( PT_NORMALDIALTONE + 1 ) ,
	PT_BUSY	= ( PT_EXTERNALDIALTONE + 1 ) ,
	PT_RINGBACK	= ( PT_BUSY + 1 ) ,
	PT_ERRORTONE	= ( PT_RINGBACK + 1 ) ,
	PT_SILENCE	= ( PT_ERRORTONE + 1 ) 
    } 	PHONE_TONE;

typedef 
enum PHONE_EVENT
    {	PE_DISPLAY	= 0,
	PE_LAMPMODE	= ( PE_DISPLAY + 1 ) ,
	PE_RINGMODE	= ( PE_LAMPMODE + 1 ) ,
	PE_RINGVOLUME	= ( PE_RINGMODE + 1 ) ,
	PE_HOOKSWITCH	= ( PE_RINGVOLUME + 1 ) ,
	PE_CAPSCHANGE	= ( PE_HOOKSWITCH + 1 ) ,
	PE_BUTTON	= ( PE_CAPSCHANGE + 1 ) ,
	PE_CLOSE	= ( PE_BUTTON + 1 ) ,
	PE_NUMBERGATHERED	= ( PE_CLOSE + 1 ) ,
	PE_DIALING	= ( PE_NUMBERGATHERED + 1 ) ,
	PE_ANSWER	= ( PE_DIALING + 1 ) ,
	PE_DISCONNECT	= ( PE_ANSWER + 1 ) ,
	PE_LASTITEM	= PE_DISCONNECT
    } 	PHONE_EVENT;

#define	INTERFACEMASK	( 0xff0000 )

#define	DISPIDMASK	( 0xffff )

#define	IDISPTAPI	( 0x10000 )

#define	IDISPTAPICALLCENTER	( 0x20000 )

#define	IDISPCALLINFO	( 0x10000 )

#define	IDISPBASICCALLCONTROL	( 0x20000 )

#define	IDISPLEGACYCALLMEDIACONTROL	( 0x30000 )

#define	IDISPAGGREGATEDMSPCALLOBJ	( 0x40000 )

#define	IDISPADDRESS	( 0x10000 )

#define	IDISPADDRESSCAPABILITIES	( 0x20000 )

#define	IDISPMEDIASUPPORT	( 0x30000 )

#define	IDISPADDRESSTRANSLATION	( 0x40000 )

#define	IDISPLEGACYADDRESSMEDIACONTROL	( 0x50000 )

#define	IDISPAGGREGATEDMSPADDRESSOBJ	( 0x60000 )

#define	IDISPPHONE	( 0x10000 )

#define	IDISPAPC	( 0x20000 )

#define	IDISPMULTITRACK	( 0x10000 )

#define	IDISPMEDIACONTROL	( 0x20000 )

#define	IDISPMEDIARECORD	( 0x30000 )

#define	IDISPMEDIAPLAYBACK	( 0x40000 )

#define	IDISPFILETRACK	( 0x10000 )



















































extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0000_0000_v0_0_s_ifspec;

#ifndef __ITTAPI_INTERFACE_DEFINED__
#define __ITTAPI_INTERFACE_DEFINED__

/* interface ITTAPI */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC382-9355-11d0-835C-00AA003CCABD")
    ITTAPI : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Addresses( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterCallNotifications( 
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [in] */ VARIANT_BOOL fMonitor,
            /* [in] */ VARIANT_BOOL fOwner,
            /* [in] */ long lMediaTypes,
            /* [in] */ long lCallbackInstance,
            /* [retval][out] */ __RPC__out long *plRegister) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnregisterNotifications( 
            /* [in] */ long lRegister) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHubs( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCallHubs( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallHub **ppEnumCallHub) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetCallHubTracking( 
            /* [in] */ VARIANT pAddresses,
            /* [in] */ VARIANT_BOOL bTracking) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumeratePrivateTAPIObjects( 
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppEnumUnknown) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PrivateTAPIObjects( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RegisterRequestRecipient( 
            /* [in] */ long lRegistrationInstance,
            /* [in] */ long lRequestMode,
            /* [in] */ VARIANT_BOOL fEnable) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAssistedTelephonyPriority( 
            /* [in] */ __RPC__in BSTR pAppFilename,
            /* [in] */ VARIANT_BOOL fPriority) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetApplicationPriority( 
            /* [in] */ __RPC__in BSTR pAppFilename,
            /* [in] */ long lMediaType,
            /* [in] */ VARIANT_BOOL fPriority) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EventFilter( 
            /* [in] */ long lFilterMask) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventFilter( 
            /* [retval][out] */ __RPC__out long *plFilterMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTAPI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTAPI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTAPI * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTAPI * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTAPI * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTAPI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTAPI * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ITTAPI * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            ITTAPI * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Addresses )( 
            ITTAPI * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateAddresses )( 
            ITTAPI * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterCallNotifications )( 
            ITTAPI * This,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [in] */ VARIANT_BOOL fMonitor,
            /* [in] */ VARIANT_BOOL fOwner,
            /* [in] */ long lMediaTypes,
            /* [in] */ long lCallbackInstance,
            /* [retval][out] */ __RPC__out long *plRegister);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterNotifications )( 
            ITTAPI * This,
            /* [in] */ long lRegister);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHubs )( 
            ITTAPI * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateCallHubs )( 
            ITTAPI * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallHub **ppEnumCallHub);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetCallHubTracking )( 
            ITTAPI * This,
            /* [in] */ VARIANT pAddresses,
            /* [in] */ VARIANT_BOOL bTracking);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePrivateTAPIObjects )( 
            ITTAPI * This,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppEnumUnknown);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateTAPIObjects )( 
            ITTAPI * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterRequestRecipient )( 
            ITTAPI * This,
            /* [in] */ long lRegistrationInstance,
            /* [in] */ long lRequestMode,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetAssistedTelephonyPriority )( 
            ITTAPI * This,
            /* [in] */ __RPC__in BSTR pAppFilename,
            /* [in] */ VARIANT_BOOL fPriority);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetApplicationPriority )( 
            ITTAPI * This,
            /* [in] */ __RPC__in BSTR pAppFilename,
            /* [in] */ long lMediaType,
            /* [in] */ VARIANT_BOOL fPriority);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventFilter )( 
            ITTAPI * This,
            /* [in] */ long lFilterMask);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventFilter )( 
            ITTAPI * This,
            /* [retval][out] */ __RPC__out long *plFilterMask);
        
        END_INTERFACE
    } ITTAPIVtbl;

    interface ITTAPI
    {
        CONST_VTBL struct ITTAPIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTAPI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTAPI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTAPI_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTAPI_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTAPI_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTAPI_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTAPI_Initialize(This)	\
    ( (This)->lpVtbl -> Initialize(This) ) 

#define ITTAPI_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define ITTAPI_get_Addresses(This,pVariant)	\
    ( (This)->lpVtbl -> get_Addresses(This,pVariant) ) 

#define ITTAPI_EnumerateAddresses(This,ppEnumAddress)	\
    ( (This)->lpVtbl -> EnumerateAddresses(This,ppEnumAddress) ) 

#define ITTAPI_RegisterCallNotifications(This,pAddress,fMonitor,fOwner,lMediaTypes,lCallbackInstance,plRegister)	\
    ( (This)->lpVtbl -> RegisterCallNotifications(This,pAddress,fMonitor,fOwner,lMediaTypes,lCallbackInstance,plRegister) ) 

#define ITTAPI_UnregisterNotifications(This,lRegister)	\
    ( (This)->lpVtbl -> UnregisterNotifications(This,lRegister) ) 

#define ITTAPI_get_CallHubs(This,pVariant)	\
    ( (This)->lpVtbl -> get_CallHubs(This,pVariant) ) 

#define ITTAPI_EnumerateCallHubs(This,ppEnumCallHub)	\
    ( (This)->lpVtbl -> EnumerateCallHubs(This,ppEnumCallHub) ) 

#define ITTAPI_SetCallHubTracking(This,pAddresses,bTracking)	\
    ( (This)->lpVtbl -> SetCallHubTracking(This,pAddresses,bTracking) ) 

#define ITTAPI_EnumeratePrivateTAPIObjects(This,ppEnumUnknown)	\
    ( (This)->lpVtbl -> EnumeratePrivateTAPIObjects(This,ppEnumUnknown) ) 

#define ITTAPI_get_PrivateTAPIObjects(This,pVariant)	\
    ( (This)->lpVtbl -> get_PrivateTAPIObjects(This,pVariant) ) 

#define ITTAPI_RegisterRequestRecipient(This,lRegistrationInstance,lRequestMode,fEnable)	\
    ( (This)->lpVtbl -> RegisterRequestRecipient(This,lRegistrationInstance,lRequestMode,fEnable) ) 

#define ITTAPI_SetAssistedTelephonyPriority(This,pAppFilename,fPriority)	\
    ( (This)->lpVtbl -> SetAssistedTelephonyPriority(This,pAppFilename,fPriority) ) 

#define ITTAPI_SetApplicationPriority(This,pAppFilename,lMediaType,fPriority)	\
    ( (This)->lpVtbl -> SetApplicationPriority(This,pAppFilename,lMediaType,fPriority) ) 

#define ITTAPI_put_EventFilter(This,lFilterMask)	\
    ( (This)->lpVtbl -> put_EventFilter(This,lFilterMask) ) 

#define ITTAPI_get_EventFilter(This,plFilterMask)	\
    ( (This)->lpVtbl -> get_EventFilter(This,plFilterMask) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTAPI_INTERFACE_DEFINED__ */


#ifndef __ITTAPI2_INTERFACE_DEFINED__
#define __ITTAPI2_INTERFACE_DEFINED__

/* interface ITTAPI2 */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPI2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54FBDC8C-D90F-4dad-9695-B373097F094B")
    ITTAPI2 : public ITTAPI
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Phones( 
            /* [retval][out] */ __RPC__out VARIANT *pPhones) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumeratePhones( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumPhone **ppEnumPhone) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateEmptyCollectionObject( 
            /* [retval][out] */ __RPC__deref_out_opt ITCollection2 **ppCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPI2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTAPI2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTAPI2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTAPI2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTAPI2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTAPI2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTAPI2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTAPI2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ITTAPI2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            ITTAPI2 * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Addresses )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateAddresses )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterCallNotifications )( 
            ITTAPI2 * This,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [in] */ VARIANT_BOOL fMonitor,
            /* [in] */ VARIANT_BOOL fOwner,
            /* [in] */ long lMediaTypes,
            /* [in] */ long lCallbackInstance,
            /* [retval][out] */ __RPC__out long *plRegister);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnregisterNotifications )( 
            ITTAPI2 * This,
            /* [in] */ long lRegister);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHubs )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateCallHubs )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallHub **ppEnumCallHub);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetCallHubTracking )( 
            ITTAPI2 * This,
            /* [in] */ VARIANT pAddresses,
            /* [in] */ VARIANT_BOOL bTracking);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePrivateTAPIObjects )( 
            ITTAPI2 * This,
            /* [out] */ __RPC__deref_out_opt IEnumUnknown **ppEnumUnknown);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PrivateTAPIObjects )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RegisterRequestRecipient )( 
            ITTAPI2 * This,
            /* [in] */ long lRegistrationInstance,
            /* [in] */ long lRequestMode,
            /* [in] */ VARIANT_BOOL fEnable);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetAssistedTelephonyPriority )( 
            ITTAPI2 * This,
            /* [in] */ __RPC__in BSTR pAppFilename,
            /* [in] */ VARIANT_BOOL fPriority);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetApplicationPriority )( 
            ITTAPI2 * This,
            /* [in] */ __RPC__in BSTR pAppFilename,
            /* [in] */ long lMediaType,
            /* [in] */ VARIANT_BOOL fPriority);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventFilter )( 
            ITTAPI2 * This,
            /* [in] */ long lFilterMask);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventFilter )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__out long *plFilterMask);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Phones )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pPhones);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePhones )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPhone **ppEnumPhone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateEmptyCollectionObject )( 
            ITTAPI2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCollection2 **ppCollection);
        
        END_INTERFACE
    } ITTAPI2Vtbl;

    interface ITTAPI2
    {
        CONST_VTBL struct ITTAPI2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPI2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTAPI2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTAPI2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTAPI2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTAPI2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTAPI2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTAPI2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTAPI2_Initialize(This)	\
    ( (This)->lpVtbl -> Initialize(This) ) 

#define ITTAPI2_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define ITTAPI2_get_Addresses(This,pVariant)	\
    ( (This)->lpVtbl -> get_Addresses(This,pVariant) ) 

#define ITTAPI2_EnumerateAddresses(This,ppEnumAddress)	\
    ( (This)->lpVtbl -> EnumerateAddresses(This,ppEnumAddress) ) 

#define ITTAPI2_RegisterCallNotifications(This,pAddress,fMonitor,fOwner,lMediaTypes,lCallbackInstance,plRegister)	\
    ( (This)->lpVtbl -> RegisterCallNotifications(This,pAddress,fMonitor,fOwner,lMediaTypes,lCallbackInstance,plRegister) ) 

#define ITTAPI2_UnregisterNotifications(This,lRegister)	\
    ( (This)->lpVtbl -> UnregisterNotifications(This,lRegister) ) 

#define ITTAPI2_get_CallHubs(This,pVariant)	\
    ( (This)->lpVtbl -> get_CallHubs(This,pVariant) ) 

#define ITTAPI2_EnumerateCallHubs(This,ppEnumCallHub)	\
    ( (This)->lpVtbl -> EnumerateCallHubs(This,ppEnumCallHub) ) 

#define ITTAPI2_SetCallHubTracking(This,pAddresses,bTracking)	\
    ( (This)->lpVtbl -> SetCallHubTracking(This,pAddresses,bTracking) ) 

#define ITTAPI2_EnumeratePrivateTAPIObjects(This,ppEnumUnknown)	\
    ( (This)->lpVtbl -> EnumeratePrivateTAPIObjects(This,ppEnumUnknown) ) 

#define ITTAPI2_get_PrivateTAPIObjects(This,pVariant)	\
    ( (This)->lpVtbl -> get_PrivateTAPIObjects(This,pVariant) ) 

#define ITTAPI2_RegisterRequestRecipient(This,lRegistrationInstance,lRequestMode,fEnable)	\
    ( (This)->lpVtbl -> RegisterRequestRecipient(This,lRegistrationInstance,lRequestMode,fEnable) ) 

#define ITTAPI2_SetAssistedTelephonyPriority(This,pAppFilename,fPriority)	\
    ( (This)->lpVtbl -> SetAssistedTelephonyPriority(This,pAppFilename,fPriority) ) 

#define ITTAPI2_SetApplicationPriority(This,pAppFilename,lMediaType,fPriority)	\
    ( (This)->lpVtbl -> SetApplicationPriority(This,pAppFilename,lMediaType,fPriority) ) 

#define ITTAPI2_put_EventFilter(This,lFilterMask)	\
    ( (This)->lpVtbl -> put_EventFilter(This,lFilterMask) ) 

#define ITTAPI2_get_EventFilter(This,plFilterMask)	\
    ( (This)->lpVtbl -> get_EventFilter(This,plFilterMask) ) 


#define ITTAPI2_get_Phones(This,pPhones)	\
    ( (This)->lpVtbl -> get_Phones(This,pPhones) ) 

#define ITTAPI2_EnumeratePhones(This,ppEnumPhone)	\
    ( (This)->lpVtbl -> EnumeratePhones(This,ppEnumPhone) ) 

#define ITTAPI2_CreateEmptyCollectionObject(This,ppCollection)	\
    ( (This)->lpVtbl -> CreateEmptyCollectionObject(This,ppCollection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTAPI2_INTERFACE_DEFINED__ */


#ifndef __ITMediaSupport_INTERFACE_DEFINED__
#define __ITMediaSupport_INTERFACE_DEFINED__

/* interface ITMediaSupport */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITMediaSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC384-9355-11d0-835C-00AA003CCABD")
    ITMediaSupport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaTypes( 
            /* [retval][out] */ __RPC__out long *plMediaTypes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryMediaType( 
            /* [in] */ long lMediaType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMediaSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITMediaSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITMediaSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITMediaSupport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITMediaSupport * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITMediaSupport * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITMediaSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITMediaSupport * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTypes )( 
            ITMediaSupport * This,
            /* [retval][out] */ __RPC__out long *plMediaTypes);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryMediaType )( 
            ITMediaSupport * This,
            /* [in] */ long lMediaType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfSupport);
        
        END_INTERFACE
    } ITMediaSupportVtbl;

    interface ITMediaSupport
    {
        CONST_VTBL struct ITMediaSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMediaSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITMediaSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITMediaSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITMediaSupport_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITMediaSupport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITMediaSupport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITMediaSupport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITMediaSupport_get_MediaTypes(This,plMediaTypes)	\
    ( (This)->lpVtbl -> get_MediaTypes(This,plMediaTypes) ) 

#define ITMediaSupport_QueryMediaType(This,lMediaType,pfSupport)	\
    ( (This)->lpVtbl -> QueryMediaType(This,lMediaType,pfSupport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITMediaSupport_INTERFACE_DEFINED__ */


#ifndef __ITPluggableTerminalClassInfo_INTERFACE_DEFINED__
#define __ITPluggableTerminalClassInfo_INTERFACE_DEFINED__

/* interface ITPluggableTerminalClassInfo */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPluggableTerminalClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41757F4A-CF09-4b34-BC96-0A79D2390076")
    ITPluggableTerminalClassInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Company( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCompany) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVersion) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TerminalClass( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pTerminalClass) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CLSID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCLSID) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ __RPC__out TERMINAL_DIRECTION *pDirection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MediaTypes( 
            /* [retval][out] */ __RPC__out long *pMediaTypes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPluggableTerminalClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITPluggableTerminalClassInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITPluggableTerminalClassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITPluggableTerminalClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITPluggableTerminalClassInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITPluggableTerminalClassInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITPluggableTerminalClassInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITPluggableTerminalClassInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITPluggableTerminalClassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Company )( 
            ITPluggableTerminalClassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCompany);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Version )( 
            ITPluggableTerminalClassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVersion);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TerminalClass )( 
            ITPluggableTerminalClassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pTerminalClass);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CLSID )( 
            ITPluggableTerminalClassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCLSID);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            ITPluggableTerminalClassInfo * This,
            /* [retval][out] */ __RPC__out TERMINAL_DIRECTION *pDirection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTypes )( 
            ITPluggableTerminalClassInfo * This,
            /* [retval][out] */ __RPC__out long *pMediaTypes);
        
        END_INTERFACE
    } ITPluggableTerminalClassInfoVtbl;

    interface ITPluggableTerminalClassInfo
    {
        CONST_VTBL struct ITPluggableTerminalClassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPluggableTerminalClassInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITPluggableTerminalClassInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITPluggableTerminalClassInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITPluggableTerminalClassInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITPluggableTerminalClassInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITPluggableTerminalClassInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITPluggableTerminalClassInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITPluggableTerminalClassInfo_get_Name(This,pName)	\
    ( (This)->lpVtbl -> get_Name(This,pName) ) 

#define ITPluggableTerminalClassInfo_get_Company(This,pCompany)	\
    ( (This)->lpVtbl -> get_Company(This,pCompany) ) 

#define ITPluggableTerminalClassInfo_get_Version(This,pVersion)	\
    ( (This)->lpVtbl -> get_Version(This,pVersion) ) 

#define ITPluggableTerminalClassInfo_get_TerminalClass(This,pTerminalClass)	\
    ( (This)->lpVtbl -> get_TerminalClass(This,pTerminalClass) ) 

#define ITPluggableTerminalClassInfo_get_CLSID(This,pCLSID)	\
    ( (This)->lpVtbl -> get_CLSID(This,pCLSID) ) 

#define ITPluggableTerminalClassInfo_get_Direction(This,pDirection)	\
    ( (This)->lpVtbl -> get_Direction(This,pDirection) ) 

#define ITPluggableTerminalClassInfo_get_MediaTypes(This,pMediaTypes)	\
    ( (This)->lpVtbl -> get_MediaTypes(This,pMediaTypes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITPluggableTerminalClassInfo_INTERFACE_DEFINED__ */


#ifndef __ITPluggableTerminalSuperclassInfo_INTERFACE_DEFINED__
#define __ITPluggableTerminalSuperclassInfo_INTERFACE_DEFINED__

/* interface ITPluggableTerminalSuperclassInfo */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPluggableTerminalSuperclassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6D54E42C-4625-4359-A6F7-631999107E05")
    ITPluggableTerminalSuperclassInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CLSID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCLSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPluggableTerminalSuperclassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITPluggableTerminalSuperclassInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITPluggableTerminalSuperclassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITPluggableTerminalSuperclassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITPluggableTerminalSuperclassInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITPluggableTerminalSuperclassInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITPluggableTerminalSuperclassInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITPluggableTerminalSuperclassInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITPluggableTerminalSuperclassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CLSID )( 
            ITPluggableTerminalSuperclassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCLSID);
        
        END_INTERFACE
    } ITPluggableTerminalSuperclassInfoVtbl;

    interface ITPluggableTerminalSuperclassInfo
    {
        CONST_VTBL struct ITPluggableTerminalSuperclassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPluggableTerminalSuperclassInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITPluggableTerminalSuperclassInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITPluggableTerminalSuperclassInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITPluggableTerminalSuperclassInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITPluggableTerminalSuperclassInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITPluggableTerminalSuperclassInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITPluggableTerminalSuperclassInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITPluggableTerminalSuperclassInfo_get_Name(This,pName)	\
    ( (This)->lpVtbl -> get_Name(This,pName) ) 

#define ITPluggableTerminalSuperclassInfo_get_CLSID(This,pCLSID)	\
    ( (This)->lpVtbl -> get_CLSID(This,pCLSID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITPluggableTerminalSuperclassInfo_INTERFACE_DEFINED__ */


#ifndef __ITTerminalSupport_INTERFACE_DEFINED__
#define __ITTerminalSupport_INTERFACE_DEFINED__

/* interface ITTerminalSupport */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTerminalSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC385-9355-11d0-835C-00AA003CCABD")
    ITTerminalSupport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StaticTerminals( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateStaticTerminals( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppTerminalEnumerator) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DynamicTerminalClasses( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDynamicTerminalClasses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminalClass **ppTerminalClassEnumerator) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateTerminal( 
            /* [in] */ __RPC__in BSTR pTerminalClass,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultStaticTerminal( 
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTerminalSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTerminalSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTerminalSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTerminalSupport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTerminalSupport * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTerminalSupport * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTerminalSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTerminalSupport * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StaticTerminals )( 
            ITTerminalSupport * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateStaticTerminals )( 
            ITTerminalSupport * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppTerminalEnumerator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DynamicTerminalClasses )( 
            ITTerminalSupport * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDynamicTerminalClasses )( 
            ITTerminalSupport * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminalClass **ppTerminalClassEnumerator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTerminal )( 
            ITTerminalSupport * This,
            /* [in] */ __RPC__in BSTR pTerminalClass,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultStaticTerminal )( 
            ITTerminalSupport * This,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        END_INTERFACE
    } ITTerminalSupportVtbl;

    interface ITTerminalSupport
    {
        CONST_VTBL struct ITTerminalSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTerminalSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTerminalSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTerminalSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTerminalSupport_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTerminalSupport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTerminalSupport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTerminalSupport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTerminalSupport_get_StaticTerminals(This,pVariant)	\
    ( (This)->lpVtbl -> get_StaticTerminals(This,pVariant) ) 

#define ITTerminalSupport_EnumerateStaticTerminals(This,ppTerminalEnumerator)	\
    ( (This)->lpVtbl -> EnumerateStaticTerminals(This,ppTerminalEnumerator) ) 

#define ITTerminalSupport_get_DynamicTerminalClasses(This,pVariant)	\
    ( (This)->lpVtbl -> get_DynamicTerminalClasses(This,pVariant) ) 

#define ITTerminalSupport_EnumerateDynamicTerminalClasses(This,ppTerminalClassEnumerator)	\
    ( (This)->lpVtbl -> EnumerateDynamicTerminalClasses(This,ppTerminalClassEnumerator) ) 

#define ITTerminalSupport_CreateTerminal(This,pTerminalClass,lMediaType,Direction,ppTerminal)	\
    ( (This)->lpVtbl -> CreateTerminal(This,pTerminalClass,lMediaType,Direction,ppTerminal) ) 

#define ITTerminalSupport_GetDefaultStaticTerminal(This,lMediaType,Direction,ppTerminal)	\
    ( (This)->lpVtbl -> GetDefaultStaticTerminal(This,lMediaType,Direction,ppTerminal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTerminalSupport_INTERFACE_DEFINED__ */


#ifndef __ITTerminalSupport2_INTERFACE_DEFINED__
#define __ITTerminalSupport2_INTERFACE_DEFINED__

/* interface ITTerminalSupport2 */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTerminalSupport2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F3EB39BC-1B1F-4e99-A0C0-56305C4DD591")
    ITTerminalSupport2 : public ITTerminalSupport
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PluggableSuperclasses( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumeratePluggableSuperclasses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumPluggableSuperclassInfo **ppSuperclassEnumerator) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PluggableTerminalClasses( 
            /* [in] */ __RPC__in BSTR bstrTerminalSuperclass,
            /* [in] */ long lMediaType,
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumeratePluggableTerminalClasses( 
            /* [in] */ CLSID iidTerminalSuperclass,
            /* [in] */ long lMediaType,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPluggableTerminalClassInfo **ppClassEnumerator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTerminalSupport2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTerminalSupport2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTerminalSupport2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTerminalSupport2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTerminalSupport2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTerminalSupport2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTerminalSupport2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTerminalSupport2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StaticTerminals )( 
            ITTerminalSupport2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateStaticTerminals )( 
            ITTerminalSupport2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppTerminalEnumerator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DynamicTerminalClasses )( 
            ITTerminalSupport2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDynamicTerminalClasses )( 
            ITTerminalSupport2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminalClass **ppTerminalClassEnumerator);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTerminal )( 
            ITTerminalSupport2 * This,
            /* [in] */ __RPC__in BSTR pTerminalClass,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultStaticTerminal )( 
            ITTerminalSupport2 * This,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PluggableSuperclasses )( 
            ITTerminalSupport2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePluggableSuperclasses )( 
            ITTerminalSupport2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPluggableSuperclassInfo **ppSuperclassEnumerator);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PluggableTerminalClasses )( 
            ITTerminalSupport2 * This,
            /* [in] */ __RPC__in BSTR bstrTerminalSuperclass,
            /* [in] */ long lMediaType,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePluggableTerminalClasses )( 
            ITTerminalSupport2 * This,
            /* [in] */ CLSID iidTerminalSuperclass,
            /* [in] */ long lMediaType,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPluggableTerminalClassInfo **ppClassEnumerator);
        
        END_INTERFACE
    } ITTerminalSupport2Vtbl;

    interface ITTerminalSupport2
    {
        CONST_VTBL struct ITTerminalSupport2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTerminalSupport2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTerminalSupport2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTerminalSupport2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTerminalSupport2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTerminalSupport2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTerminalSupport2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTerminalSupport2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTerminalSupport2_get_StaticTerminals(This,pVariant)	\
    ( (This)->lpVtbl -> get_StaticTerminals(This,pVariant) ) 

#define ITTerminalSupport2_EnumerateStaticTerminals(This,ppTerminalEnumerator)	\
    ( (This)->lpVtbl -> EnumerateStaticTerminals(This,ppTerminalEnumerator) ) 

#define ITTerminalSupport2_get_DynamicTerminalClasses(This,pVariant)	\
    ( (This)->lpVtbl -> get_DynamicTerminalClasses(This,pVariant) ) 

#define ITTerminalSupport2_EnumerateDynamicTerminalClasses(This,ppTerminalClassEnumerator)	\
    ( (This)->lpVtbl -> EnumerateDynamicTerminalClasses(This,ppTerminalClassEnumerator) ) 

#define ITTerminalSupport2_CreateTerminal(This,pTerminalClass,lMediaType,Direction,ppTerminal)	\
    ( (This)->lpVtbl -> CreateTerminal(This,pTerminalClass,lMediaType,Direction,ppTerminal) ) 

#define ITTerminalSupport2_GetDefaultStaticTerminal(This,lMediaType,Direction,ppTerminal)	\
    ( (This)->lpVtbl -> GetDefaultStaticTerminal(This,lMediaType,Direction,ppTerminal) ) 


#define ITTerminalSupport2_get_PluggableSuperclasses(This,pVariant)	\
    ( (This)->lpVtbl -> get_PluggableSuperclasses(This,pVariant) ) 

#define ITTerminalSupport2_EnumeratePluggableSuperclasses(This,ppSuperclassEnumerator)	\
    ( (This)->lpVtbl -> EnumeratePluggableSuperclasses(This,ppSuperclassEnumerator) ) 

#define ITTerminalSupport2_get_PluggableTerminalClasses(This,bstrTerminalSuperclass,lMediaType,pVariant)	\
    ( (This)->lpVtbl -> get_PluggableTerminalClasses(This,bstrTerminalSuperclass,lMediaType,pVariant) ) 

#define ITTerminalSupport2_EnumeratePluggableTerminalClasses(This,iidTerminalSuperclass,lMediaType,ppClassEnumerator)	\
    ( (This)->lpVtbl -> EnumeratePluggableTerminalClasses(This,iidTerminalSuperclass,lMediaType,ppClassEnumerator) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTerminalSupport2_INTERFACE_DEFINED__ */


#ifndef __ITAddress_INTERFACE_DEFINED__
#define __ITAddress_INTERFACE_DEFINED__

/* interface ITAddress */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC386-9355-11d0-835C-00AA003CCABD")
    ITAddress : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out ADDRESS_STATE *pAddressState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceProviderName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TAPIObject( 
            /* [retval][out] */ __RPC__deref_out_opt ITTAPI **ppTapiObject) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateCall( 
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ long lAddressType,
            /* [in] */ long lMediaTypes,
            /* [retval][out] */ __RPC__deref_out_opt ITBasicCallControl **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Calls( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCalls( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppCallEnum) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialableAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pDialableAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateForwardInfoObject( 
            /* [retval][out] */ __RPC__deref_out_opt ITForwardInformation **ppForwardInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Forward( 
            /* [in] */ __RPC__in_opt ITForwardInformation *pForwardInfo,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentForwardInfo( 
            /* [retval][out] */ __RPC__deref_out_opt ITForwardInformation **ppForwardInfo) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MessageWaiting( 
            /* [in] */ VARIANT_BOOL fMessageWaiting) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MessageWaiting( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfMessageWaiting) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DoNotDisturb( 
            /* [in] */ VARIANT_BOOL fDoNotDisturb) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DoNotDisturb( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfDoNotDisturb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAddress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAddress * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAddress * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAddress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAddress * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__out ADDRESS_STATE *pAddressState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressName )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceProviderName )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TAPIObject )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTAPI **ppTapiObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateCall )( 
            ITAddress * This,
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ long lAddressType,
            /* [in] */ long lMediaTypes,
            /* [retval][out] */ __RPC__deref_out_opt ITBasicCallControl **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Calls )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateCalls )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppCallEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DialableAddress )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pDialableAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateForwardInfoObject )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__deref_out_opt ITForwardInformation **ppForwardInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Forward )( 
            ITAddress * This,
            /* [in] */ __RPC__in_opt ITForwardInformation *pForwardInfo,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentForwardInfo )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__deref_out_opt ITForwardInformation **ppForwardInfo);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageWaiting )( 
            ITAddress * This,
            /* [in] */ VARIANT_BOOL fMessageWaiting);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageWaiting )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfMessageWaiting);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DoNotDisturb )( 
            ITAddress * This,
            /* [in] */ VARIANT_BOOL fDoNotDisturb);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DoNotDisturb )( 
            ITAddress * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfDoNotDisturb);
        
        END_INTERFACE
    } ITAddressVtbl;

    interface ITAddress
    {
        CONST_VTBL struct ITAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAddress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAddress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAddress_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAddress_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAddress_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAddress_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAddress_get_State(This,pAddressState)	\
    ( (This)->lpVtbl -> get_State(This,pAddressState) ) 

#define ITAddress_get_AddressName(This,ppName)	\
    ( (This)->lpVtbl -> get_AddressName(This,ppName) ) 

#define ITAddress_get_ServiceProviderName(This,ppName)	\
    ( (This)->lpVtbl -> get_ServiceProviderName(This,ppName) ) 

#define ITAddress_get_TAPIObject(This,ppTapiObject)	\
    ( (This)->lpVtbl -> get_TAPIObject(This,ppTapiObject) ) 

#define ITAddress_CreateCall(This,pDestAddress,lAddressType,lMediaTypes,ppCall)	\
    ( (This)->lpVtbl -> CreateCall(This,pDestAddress,lAddressType,lMediaTypes,ppCall) ) 

#define ITAddress_get_Calls(This,pVariant)	\
    ( (This)->lpVtbl -> get_Calls(This,pVariant) ) 

#define ITAddress_EnumerateCalls(This,ppCallEnum)	\
    ( (This)->lpVtbl -> EnumerateCalls(This,ppCallEnum) ) 

#define ITAddress_get_DialableAddress(This,pDialableAddress)	\
    ( (This)->lpVtbl -> get_DialableAddress(This,pDialableAddress) ) 

#define ITAddress_CreateForwardInfoObject(This,ppForwardInfo)	\
    ( (This)->lpVtbl -> CreateForwardInfoObject(This,ppForwardInfo) ) 

#define ITAddress_Forward(This,pForwardInfo,pCall)	\
    ( (This)->lpVtbl -> Forward(This,pForwardInfo,pCall) ) 

#define ITAddress_get_CurrentForwardInfo(This,ppForwardInfo)	\
    ( (This)->lpVtbl -> get_CurrentForwardInfo(This,ppForwardInfo) ) 

#define ITAddress_put_MessageWaiting(This,fMessageWaiting)	\
    ( (This)->lpVtbl -> put_MessageWaiting(This,fMessageWaiting) ) 

#define ITAddress_get_MessageWaiting(This,pfMessageWaiting)	\
    ( (This)->lpVtbl -> get_MessageWaiting(This,pfMessageWaiting) ) 

#define ITAddress_put_DoNotDisturb(This,fDoNotDisturb)	\
    ( (This)->lpVtbl -> put_DoNotDisturb(This,fDoNotDisturb) ) 

#define ITAddress_get_DoNotDisturb(This,pfDoNotDisturb)	\
    ( (This)->lpVtbl -> get_DoNotDisturb(This,pfDoNotDisturb) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAddress_INTERFACE_DEFINED__ */


#ifndef __ITAddress2_INTERFACE_DEFINED__
#define __ITAddress2_INTERFACE_DEFINED__

/* interface ITAddress2 */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddress2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B0AE5D9B-BE51-46c9-B0F7-DFA8A22A8BC4")
    ITAddress2 : public ITAddress
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Phones( 
            /* [retval][out] */ __RPC__out VARIANT *pPhones) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumeratePhones( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumPhone **ppEnumPhone) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPhoneFromTerminal( 
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal,
            /* [retval][out] */ __RPC__deref_out_opt ITPhone **ppPhone) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredPhones( 
            /* [retval][out] */ __RPC__out VARIANT *pPhones) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumeratePreferredPhones( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumPhone **ppEnumPhone) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventFilter( 
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ long lSubEvent,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pEnable) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EventFilter( 
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ long lSubEvent,
            /* [in] */ VARIANT_BOOL bEnable) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE DeviceSpecific( 
            /* [in] */ __RPC__in_opt ITCallInfo *pCall,
            /* [in] */ __RPC__in BYTE *pParams,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeviceSpecificVariant( 
            /* [in] */ __RPC__in_opt ITCallInfo *pCall,
            /* [in] */ VARIANT varDevSpecificByteArray) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NegotiateExtVersion( 
            /* [in] */ long lLowVersion,
            /* [in] */ long lHighVersion,
            /* [retval][out] */ __RPC__out long *plExtVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddress2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAddress2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAddress2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAddress2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAddress2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAddress2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAddress2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAddress2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__out ADDRESS_STATE *pAddressState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressName )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceProviderName )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TAPIObject )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTAPI **ppTapiObject);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateCall )( 
            ITAddress2 * This,
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ long lAddressType,
            /* [in] */ long lMediaTypes,
            /* [retval][out] */ __RPC__deref_out_opt ITBasicCallControl **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Calls )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateCalls )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppCallEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DialableAddress )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pDialableAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateForwardInfoObject )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITForwardInformation **ppForwardInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Forward )( 
            ITAddress2 * This,
            /* [in] */ __RPC__in_opt ITForwardInformation *pForwardInfo,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentForwardInfo )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITForwardInformation **ppForwardInfo);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MessageWaiting )( 
            ITAddress2 * This,
            /* [in] */ VARIANT_BOOL fMessageWaiting);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MessageWaiting )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfMessageWaiting);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DoNotDisturb )( 
            ITAddress2 * This,
            /* [in] */ VARIANT_BOOL fDoNotDisturb);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DoNotDisturb )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfDoNotDisturb);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Phones )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pPhones);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePhones )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPhone **ppEnumPhone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPhoneFromTerminal )( 
            ITAddress2 * This,
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal,
            /* [retval][out] */ __RPC__deref_out_opt ITPhone **ppPhone);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredPhones )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__out VARIANT *pPhones);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePreferredPhones )( 
            ITAddress2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPhone **ppEnumPhone);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventFilter )( 
            ITAddress2 * This,
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ long lSubEvent,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pEnable);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventFilter )( 
            ITAddress2 * This,
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ long lSubEvent,
            /* [in] */ VARIANT_BOOL bEnable);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DeviceSpecific )( 
            ITAddress2 * This,
            /* [in] */ __RPC__in_opt ITCallInfo *pCall,
            /* [in] */ __RPC__in BYTE *pParams,
            /* [in] */ DWORD dwSize);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeviceSpecificVariant )( 
            ITAddress2 * This,
            /* [in] */ __RPC__in_opt ITCallInfo *pCall,
            /* [in] */ VARIANT varDevSpecificByteArray);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NegotiateExtVersion )( 
            ITAddress2 * This,
            /* [in] */ long lLowVersion,
            /* [in] */ long lHighVersion,
            /* [retval][out] */ __RPC__out long *plExtVersion);
        
        END_INTERFACE
    } ITAddress2Vtbl;

    interface ITAddress2
    {
        CONST_VTBL struct ITAddress2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddress2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAddress2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAddress2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAddress2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAddress2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAddress2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAddress2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAddress2_get_State(This,pAddressState)	\
    ( (This)->lpVtbl -> get_State(This,pAddressState) ) 

#define ITAddress2_get_AddressName(This,ppName)	\
    ( (This)->lpVtbl -> get_AddressName(This,ppName) ) 

#define ITAddress2_get_ServiceProviderName(This,ppName)	\
    ( (This)->lpVtbl -> get_ServiceProviderName(This,ppName) ) 

#define ITAddress2_get_TAPIObject(This,ppTapiObject)	\
    ( (This)->lpVtbl -> get_TAPIObject(This,ppTapiObject) ) 

#define ITAddress2_CreateCall(This,pDestAddress,lAddressType,lMediaTypes,ppCall)	\
    ( (This)->lpVtbl -> CreateCall(This,pDestAddress,lAddressType,lMediaTypes,ppCall) ) 

#define ITAddress2_get_Calls(This,pVariant)	\
    ( (This)->lpVtbl -> get_Calls(This,pVariant) ) 

#define ITAddress2_EnumerateCalls(This,ppCallEnum)	\
    ( (This)->lpVtbl -> EnumerateCalls(This,ppCallEnum) ) 

#define ITAddress2_get_DialableAddress(This,pDialableAddress)	\
    ( (This)->lpVtbl -> get_DialableAddress(This,pDialableAddress) ) 

#define ITAddress2_CreateForwardInfoObject(This,ppForwardInfo)	\
    ( (This)->lpVtbl -> CreateForwardInfoObject(This,ppForwardInfo) ) 

#define ITAddress2_Forward(This,pForwardInfo,pCall)	\
    ( (This)->lpVtbl -> Forward(This,pForwardInfo,pCall) ) 

#define ITAddress2_get_CurrentForwardInfo(This,ppForwardInfo)	\
    ( (This)->lpVtbl -> get_CurrentForwardInfo(This,ppForwardInfo) ) 

#define ITAddress2_put_MessageWaiting(This,fMessageWaiting)	\
    ( (This)->lpVtbl -> put_MessageWaiting(This,fMessageWaiting) ) 

#define ITAddress2_get_MessageWaiting(This,pfMessageWaiting)	\
    ( (This)->lpVtbl -> get_MessageWaiting(This,pfMessageWaiting) ) 

#define ITAddress2_put_DoNotDisturb(This,fDoNotDisturb)	\
    ( (This)->lpVtbl -> put_DoNotDisturb(This,fDoNotDisturb) ) 

#define ITAddress2_get_DoNotDisturb(This,pfDoNotDisturb)	\
    ( (This)->lpVtbl -> get_DoNotDisturb(This,pfDoNotDisturb) ) 


#define ITAddress2_get_Phones(This,pPhones)	\
    ( (This)->lpVtbl -> get_Phones(This,pPhones) ) 

#define ITAddress2_EnumeratePhones(This,ppEnumPhone)	\
    ( (This)->lpVtbl -> EnumeratePhones(This,ppEnumPhone) ) 

#define ITAddress2_GetPhoneFromTerminal(This,pTerminal,ppPhone)	\
    ( (This)->lpVtbl -> GetPhoneFromTerminal(This,pTerminal,ppPhone) ) 

#define ITAddress2_get_PreferredPhones(This,pPhones)	\
    ( (This)->lpVtbl -> get_PreferredPhones(This,pPhones) ) 

#define ITAddress2_EnumeratePreferredPhones(This,ppEnumPhone)	\
    ( (This)->lpVtbl -> EnumeratePreferredPhones(This,ppEnumPhone) ) 

#define ITAddress2_get_EventFilter(This,TapiEvent,lSubEvent,pEnable)	\
    ( (This)->lpVtbl -> get_EventFilter(This,TapiEvent,lSubEvent,pEnable) ) 

#define ITAddress2_put_EventFilter(This,TapiEvent,lSubEvent,bEnable)	\
    ( (This)->lpVtbl -> put_EventFilter(This,TapiEvent,lSubEvent,bEnable) ) 

#define ITAddress2_DeviceSpecific(This,pCall,pParams,dwSize)	\
    ( (This)->lpVtbl -> DeviceSpecific(This,pCall,pParams,dwSize) ) 

#define ITAddress2_DeviceSpecificVariant(This,pCall,varDevSpecificByteArray)	\
    ( (This)->lpVtbl -> DeviceSpecificVariant(This,pCall,varDevSpecificByteArray) ) 

#define ITAddress2_NegotiateExtVersion(This,lLowVersion,lHighVersion,plExtVersion)	\
    ( (This)->lpVtbl -> NegotiateExtVersion(This,lLowVersion,lHighVersion,plExtVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAddress2_INTERFACE_DEFINED__ */


#ifndef __ITAddressCapabilities_INTERFACE_DEFINED__
#define __ITAddressCapabilities_INTERFACE_DEFINED__

/* interface ITAddressCapabilities */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressCapabilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8DF232F5-821B-11d1-BB5C-00C04FB6809F")
    ITAddressCapabilities : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressCapability( 
            /* [in] */ ADDRESS_CAPABILITY AddressCap,
            /* [retval][out] */ __RPC__out long *plCapability) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressCapabilityString( 
            /* [in] */ ADDRESS_CAPABILITY_STRING AddressCapString,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCapabilityString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallTreatments( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCallTreatments( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumCallTreatment) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CompletionMessages( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCompletionMessages( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumCompletionMessage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceClasses( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateDeviceClasses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumDeviceClass) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressCapabilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAddressCapabilities * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAddressCapabilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAddressCapabilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAddressCapabilities * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAddressCapabilities * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAddressCapabilities * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAddressCapabilities * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressCapability )( 
            ITAddressCapabilities * This,
            /* [in] */ ADDRESS_CAPABILITY AddressCap,
            /* [retval][out] */ __RPC__out long *plCapability);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressCapabilityString )( 
            ITAddressCapabilities * This,
            /* [in] */ ADDRESS_CAPABILITY_STRING AddressCapString,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCapabilityString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallTreatments )( 
            ITAddressCapabilities * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateCallTreatments )( 
            ITAddressCapabilities * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumCallTreatment);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CompletionMessages )( 
            ITAddressCapabilities * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateCompletionMessages )( 
            ITAddressCapabilities * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumCompletionMessage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceClasses )( 
            ITAddressCapabilities * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateDeviceClasses )( 
            ITAddressCapabilities * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumDeviceClass);
        
        END_INTERFACE
    } ITAddressCapabilitiesVtbl;

    interface ITAddressCapabilities
    {
        CONST_VTBL struct ITAddressCapabilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressCapabilities_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAddressCapabilities_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAddressCapabilities_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAddressCapabilities_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAddressCapabilities_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAddressCapabilities_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAddressCapabilities_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAddressCapabilities_get_AddressCapability(This,AddressCap,plCapability)	\
    ( (This)->lpVtbl -> get_AddressCapability(This,AddressCap,plCapability) ) 

#define ITAddressCapabilities_get_AddressCapabilityString(This,AddressCapString,ppCapabilityString)	\
    ( (This)->lpVtbl -> get_AddressCapabilityString(This,AddressCapString,ppCapabilityString) ) 

#define ITAddressCapabilities_get_CallTreatments(This,pVariant)	\
    ( (This)->lpVtbl -> get_CallTreatments(This,pVariant) ) 

#define ITAddressCapabilities_EnumerateCallTreatments(This,ppEnumCallTreatment)	\
    ( (This)->lpVtbl -> EnumerateCallTreatments(This,ppEnumCallTreatment) ) 

#define ITAddressCapabilities_get_CompletionMessages(This,pVariant)	\
    ( (This)->lpVtbl -> get_CompletionMessages(This,pVariant) ) 

#define ITAddressCapabilities_EnumerateCompletionMessages(This,ppEnumCompletionMessage)	\
    ( (This)->lpVtbl -> EnumerateCompletionMessages(This,ppEnumCompletionMessage) ) 

#define ITAddressCapabilities_get_DeviceClasses(This,pVariant)	\
    ( (This)->lpVtbl -> get_DeviceClasses(This,pVariant) ) 

#define ITAddressCapabilities_EnumerateDeviceClasses(This,ppEnumDeviceClass)	\
    ( (This)->lpVtbl -> EnumerateDeviceClasses(This,ppEnumDeviceClass) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAddressCapabilities_INTERFACE_DEFINED__ */


#ifndef __ITPhone_INTERFACE_DEFINED__
#define __ITPhone_INTERFACE_DEFINED__

/* interface ITPhone */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPhone;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09D48DB4-10CC-4388-9DE7-A8465618975A")
    ITPhone : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ PHONE_PRIVILEGE Privilege) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Addresses( 
            /* [retval][out] */ __RPC__out VARIANT *pAddresses) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneCapsLong( 
            /* [in] */ PHONECAPS_LONG pclCap,
            /* [retval][out] */ __RPC__out long *plCapability) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneCapsString( 
            /* [in] */ PHONECAPS_STRING pcsCap,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCapability) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminals( 
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [retval][out] */ __RPC__out VARIANT *pTerminals) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateTerminals( 
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppEnumTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonMode( 
            /* [in] */ long lButtonID,
            /* [retval][out] */ __RPC__out PHONE_BUTTON_MODE *pButtonMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ButtonMode( 
            /* [in] */ long lButtonID,
            /* [in] */ PHONE_BUTTON_MODE ButtonMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonFunction( 
            /* [in] */ long lButtonID,
            /* [retval][out] */ __RPC__out PHONE_BUTTON_FUNCTION *pButtonFunction) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ButtonFunction( 
            /* [in] */ long lButtonID,
            /* [in] */ PHONE_BUTTON_FUNCTION ButtonFunction) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonText( 
            /* [in] */ long lButtonID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppButtonText) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ButtonText( 
            /* [in] */ long lButtonID,
            /* [in] */ __RPC__in BSTR bstrButtonText) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonState( 
            /* [in] */ long lButtonID,
            /* [retval][out] */ __RPC__out PHONE_BUTTON_STATE *pButtonState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HookSwitchState( 
            /* [in] */ PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
            /* [retval][out] */ __RPC__out PHONE_HOOK_SWITCH_STATE *pHookSwitchState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_HookSwitchState( 
            /* [in] */ PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
            /* [in] */ PHONE_HOOK_SWITCH_STATE HookSwitchState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RingMode( 
            /* [in] */ long lRingMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RingMode( 
            /* [retval][out] */ __RPC__out long *plRingMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RingVolume( 
            /* [in] */ long lRingVolume) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RingVolume( 
            /* [retval][out] */ __RPC__out long *plRingVolume) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Privilege( 
            /* [retval][out] */ __RPC__out PHONE_PRIVILEGE *pPrivilege) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE GetPhoneCapsBuffer( 
            /* [in] */ PHONECAPS_BUFFER pcbCaps,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [out] */ __RPC__deref_out_opt BYTE **ppPhoneCapsBuffer) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneCapsBuffer( 
            /* [in] */ PHONECAPS_BUFFER pcbCaps,
            /* [retval][out] */ __RPC__out VARIANT *pVarBuffer) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LampMode( 
            /* [in] */ long lLampID,
            /* [retval][out] */ __RPC__out PHONE_LAMP_MODE *pLampMode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LampMode( 
            /* [in] */ long lLampID,
            /* [in] */ PHONE_LAMP_MODE LampMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Display( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDisplay) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetDisplay( 
            /* [in] */ long lRow,
            /* [in] */ long lColumn,
            /* [in] */ __RPC__in BSTR bstrDisplay) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredAddresses( 
            /* [retval][out] */ __RPC__out VARIANT *pAddresses) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumeratePreferredAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE DeviceSpecific( 
            /* [in] */ __RPC__in BYTE *pParams,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeviceSpecificVariant( 
            /* [in] */ VARIANT varDevSpecificByteArray) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NegotiateExtVersion( 
            /* [in] */ long lLowVersion,
            /* [in] */ long lHighVersion,
            /* [retval][out] */ __RPC__out long *plExtVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPhoneVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITPhone * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITPhone * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITPhone * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITPhone * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITPhone * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITPhone * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITPhone * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            ITPhone * This,
            /* [in] */ PHONE_PRIVILEGE Privilege);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            ITPhone * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Addresses )( 
            ITPhone * This,
            /* [retval][out] */ __RPC__out VARIANT *pAddresses);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateAddresses )( 
            ITPhone * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhoneCapsLong )( 
            ITPhone * This,
            /* [in] */ PHONECAPS_LONG pclCap,
            /* [retval][out] */ __RPC__out long *plCapability);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhoneCapsString )( 
            ITPhone * This,
            /* [in] */ PHONECAPS_STRING pcsCap,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCapability);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminals )( 
            ITPhone * This,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [retval][out] */ __RPC__out VARIANT *pTerminals);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateTerminals )( 
            ITPhone * This,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppEnumTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonMode )( 
            ITPhone * This,
            /* [in] */ long lButtonID,
            /* [retval][out] */ __RPC__out PHONE_BUTTON_MODE *pButtonMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ButtonMode )( 
            ITPhone * This,
            /* [in] */ long lButtonID,
            /* [in] */ PHONE_BUTTON_MODE ButtonMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonFunction )( 
            ITPhone * This,
            /* [in] */ long lButtonID,
            /* [retval][out] */ __RPC__out PHONE_BUTTON_FUNCTION *pButtonFunction);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ButtonFunction )( 
            ITPhone * This,
            /* [in] */ long lButtonID,
            /* [in] */ PHONE_BUTTON_FUNCTION ButtonFunction);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonText )( 
            ITPhone * This,
            /* [in] */ long lButtonID,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppButtonText);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ButtonText )( 
            ITPhone * This,
            /* [in] */ long lButtonID,
            /* [in] */ __RPC__in BSTR bstrButtonText);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonState )( 
            ITPhone * This,
            /* [in] */ long lButtonID,
            /* [retval][out] */ __RPC__out PHONE_BUTTON_STATE *pButtonState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HookSwitchState )( 
            ITPhone * This,
            /* [in] */ PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
            /* [retval][out] */ __RPC__out PHONE_HOOK_SWITCH_STATE *pHookSwitchState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_HookSwitchState )( 
            ITPhone * This,
            /* [in] */ PHONE_HOOK_SWITCH_DEVICE HookSwitchDevice,
            /* [in] */ PHONE_HOOK_SWITCH_STATE HookSwitchState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RingMode )( 
            ITPhone * This,
            /* [in] */ long lRingMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RingMode )( 
            ITPhone * This,
            /* [retval][out] */ __RPC__out long *plRingMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RingVolume )( 
            ITPhone * This,
            /* [in] */ long lRingVolume);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RingVolume )( 
            ITPhone * This,
            /* [retval][out] */ __RPC__out long *plRingVolume);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Privilege )( 
            ITPhone * This,
            /* [retval][out] */ __RPC__out PHONE_PRIVILEGE *pPrivilege);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetPhoneCapsBuffer )( 
            ITPhone * This,
            /* [in] */ PHONECAPS_BUFFER pcbCaps,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [out] */ __RPC__deref_out_opt BYTE **ppPhoneCapsBuffer);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhoneCapsBuffer )( 
            ITPhone * This,
            /* [in] */ PHONECAPS_BUFFER pcbCaps,
            /* [retval][out] */ __RPC__out VARIANT *pVarBuffer);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LampMode )( 
            ITPhone * This,
            /* [in] */ long lLampID,
            /* [retval][out] */ __RPC__out PHONE_LAMP_MODE *pLampMode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LampMode )( 
            ITPhone * This,
            /* [in] */ long lLampID,
            /* [in] */ PHONE_LAMP_MODE LampMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Display )( 
            ITPhone * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrDisplay);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetDisplay )( 
            ITPhone * This,
            /* [in] */ long lRow,
            /* [in] */ long lColumn,
            /* [in] */ __RPC__in BSTR bstrDisplay);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredAddresses )( 
            ITPhone * This,
            /* [retval][out] */ __RPC__out VARIANT *pAddresses);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumeratePreferredAddresses )( 
            ITPhone * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DeviceSpecific )( 
            ITPhone * This,
            /* [in] */ __RPC__in BYTE *pParams,
            /* [in] */ DWORD dwSize);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DeviceSpecificVariant )( 
            ITPhone * This,
            /* [in] */ VARIANT varDevSpecificByteArray);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NegotiateExtVersion )( 
            ITPhone * This,
            /* [in] */ long lLowVersion,
            /* [in] */ long lHighVersion,
            /* [retval][out] */ __RPC__out long *plExtVersion);
        
        END_INTERFACE
    } ITPhoneVtbl;

    interface ITPhone
    {
        CONST_VTBL struct ITPhoneVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPhone_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITPhone_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITPhone_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITPhone_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITPhone_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITPhone_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITPhone_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITPhone_Open(This,Privilege)	\
    ( (This)->lpVtbl -> Open(This,Privilege) ) 

#define ITPhone_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define ITPhone_get_Addresses(This,pAddresses)	\
    ( (This)->lpVtbl -> get_Addresses(This,pAddresses) ) 

#define ITPhone_EnumerateAddresses(This,ppEnumAddress)	\
    ( (This)->lpVtbl -> EnumerateAddresses(This,ppEnumAddress) ) 

#define ITPhone_get_PhoneCapsLong(This,pclCap,plCapability)	\
    ( (This)->lpVtbl -> get_PhoneCapsLong(This,pclCap,plCapability) ) 

#define ITPhone_get_PhoneCapsString(This,pcsCap,ppCapability)	\
    ( (This)->lpVtbl -> get_PhoneCapsString(This,pcsCap,ppCapability) ) 

#define ITPhone_get_Terminals(This,pAddress,pTerminals)	\
    ( (This)->lpVtbl -> get_Terminals(This,pAddress,pTerminals) ) 

#define ITPhone_EnumerateTerminals(This,pAddress,ppEnumTerminal)	\
    ( (This)->lpVtbl -> EnumerateTerminals(This,pAddress,ppEnumTerminal) ) 

#define ITPhone_get_ButtonMode(This,lButtonID,pButtonMode)	\
    ( (This)->lpVtbl -> get_ButtonMode(This,lButtonID,pButtonMode) ) 

#define ITPhone_put_ButtonMode(This,lButtonID,ButtonMode)	\
    ( (This)->lpVtbl -> put_ButtonMode(This,lButtonID,ButtonMode) ) 

#define ITPhone_get_ButtonFunction(This,lButtonID,pButtonFunction)	\
    ( (This)->lpVtbl -> get_ButtonFunction(This,lButtonID,pButtonFunction) ) 

#define ITPhone_put_ButtonFunction(This,lButtonID,ButtonFunction)	\
    ( (This)->lpVtbl -> put_ButtonFunction(This,lButtonID,ButtonFunction) ) 

#define ITPhone_get_ButtonText(This,lButtonID,ppButtonText)	\
    ( (This)->lpVtbl -> get_ButtonText(This,lButtonID,ppButtonText) ) 

#define ITPhone_put_ButtonText(This,lButtonID,bstrButtonText)	\
    ( (This)->lpVtbl -> put_ButtonText(This,lButtonID,bstrButtonText) ) 

#define ITPhone_get_ButtonState(This,lButtonID,pButtonState)	\
    ( (This)->lpVtbl -> get_ButtonState(This,lButtonID,pButtonState) ) 

#define ITPhone_get_HookSwitchState(This,HookSwitchDevice,pHookSwitchState)	\
    ( (This)->lpVtbl -> get_HookSwitchState(This,HookSwitchDevice,pHookSwitchState) ) 

#define ITPhone_put_HookSwitchState(This,HookSwitchDevice,HookSwitchState)	\
    ( (This)->lpVtbl -> put_HookSwitchState(This,HookSwitchDevice,HookSwitchState) ) 

#define ITPhone_put_RingMode(This,lRingMode)	\
    ( (This)->lpVtbl -> put_RingMode(This,lRingMode) ) 

#define ITPhone_get_RingMode(This,plRingMode)	\
    ( (This)->lpVtbl -> get_RingMode(This,plRingMode) ) 

#define ITPhone_put_RingVolume(This,lRingVolume)	\
    ( (This)->lpVtbl -> put_RingVolume(This,lRingVolume) ) 

#define ITPhone_get_RingVolume(This,plRingVolume)	\
    ( (This)->lpVtbl -> get_RingVolume(This,plRingVolume) ) 

#define ITPhone_get_Privilege(This,pPrivilege)	\
    ( (This)->lpVtbl -> get_Privilege(This,pPrivilege) ) 

#define ITPhone_GetPhoneCapsBuffer(This,pcbCaps,pdwSize,ppPhoneCapsBuffer)	\
    ( (This)->lpVtbl -> GetPhoneCapsBuffer(This,pcbCaps,pdwSize,ppPhoneCapsBuffer) ) 

#define ITPhone_get_PhoneCapsBuffer(This,pcbCaps,pVarBuffer)	\
    ( (This)->lpVtbl -> get_PhoneCapsBuffer(This,pcbCaps,pVarBuffer) ) 

#define ITPhone_get_LampMode(This,lLampID,pLampMode)	\
    ( (This)->lpVtbl -> get_LampMode(This,lLampID,pLampMode) ) 

#define ITPhone_put_LampMode(This,lLampID,LampMode)	\
    ( (This)->lpVtbl -> put_LampMode(This,lLampID,LampMode) ) 

#define ITPhone_get_Display(This,pbstrDisplay)	\
    ( (This)->lpVtbl -> get_Display(This,pbstrDisplay) ) 

#define ITPhone_SetDisplay(This,lRow,lColumn,bstrDisplay)	\
    ( (This)->lpVtbl -> SetDisplay(This,lRow,lColumn,bstrDisplay) ) 

#define ITPhone_get_PreferredAddresses(This,pAddresses)	\
    ( (This)->lpVtbl -> get_PreferredAddresses(This,pAddresses) ) 

#define ITPhone_EnumeratePreferredAddresses(This,ppEnumAddress)	\
    ( (This)->lpVtbl -> EnumeratePreferredAddresses(This,ppEnumAddress) ) 

#define ITPhone_DeviceSpecific(This,pParams,dwSize)	\
    ( (This)->lpVtbl -> DeviceSpecific(This,pParams,dwSize) ) 

#define ITPhone_DeviceSpecificVariant(This,varDevSpecificByteArray)	\
    ( (This)->lpVtbl -> DeviceSpecificVariant(This,varDevSpecificByteArray) ) 

#define ITPhone_NegotiateExtVersion(This,lLowVersion,lHighVersion,plExtVersion)	\
    ( (This)->lpVtbl -> NegotiateExtVersion(This,lLowVersion,lHighVersion,plExtVersion) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITPhone_INTERFACE_DEFINED__ */


#ifndef __ITAutomatedPhoneControl_INTERFACE_DEFINED__
#define __ITAutomatedPhoneControl_INTERFACE_DEFINED__

/* interface ITAutomatedPhoneControl */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAutomatedPhoneControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1EE1AF0E-6159-4a61-B79B-6A4BA3FC9DFC")
    ITAutomatedPhoneControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartTone( 
            /* [in] */ PHONE_TONE Tone,
            /* [in] */ long lDuration) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopTone( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Tone( 
            /* [retval][out] */ __RPC__out PHONE_TONE *pTone) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartRinger( 
            /* [in] */ long lRingMode,
            /* [in] */ long lDuration) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopRinger( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Ringer( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfRinging) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PhoneHandlingEnabled( 
            /* [in] */ VARIANT_BOOL fEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PhoneHandlingEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoEndOfNumberTimeout( 
            /* [in] */ long lTimeout) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoEndOfNumberTimeout( 
            /* [retval][out] */ __RPC__out long *plTimeout) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoDialtone( 
            /* [in] */ VARIANT_BOOL fEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoDialtone( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoStopTonesOnOnHook( 
            /* [in] */ VARIANT_BOOL fEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoStopTonesOnOnHook( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoStopRingOnOffHook( 
            /* [in] */ VARIANT_BOOL fEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoStopRingOnOffHook( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoKeypadTones( 
            /* [in] */ VARIANT_BOOL fEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoKeypadTones( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoKeypadTonesMinimumDuration( 
            /* [in] */ long lDuration) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoKeypadTonesMinimumDuration( 
            /* [retval][out] */ __RPC__out long *plDuration) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoVolumeControl( 
            /* [in] */ VARIANT_BOOL fEnabled) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoVolumeControl( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *fEnabled) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoVolumeControlStep( 
            /* [in] */ long lStepSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoVolumeControlStep( 
            /* [retval][out] */ __RPC__out long *plStepSize) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoVolumeControlRepeatDelay( 
            /* [in] */ long lDelay) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoVolumeControlRepeatDelay( 
            /* [retval][out] */ __RPC__out long *plDelay) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoVolumeControlRepeatPeriod( 
            /* [in] */ long lPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoVolumeControlRepeatPeriod( 
            /* [retval][out] */ __RPC__out long *plPeriod) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectCall( 
            /* [in] */ __RPC__in_opt ITCallInfo *pCall,
            /* [in] */ VARIANT_BOOL fSelectDefaultTerminals) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnselectCall( 
            /* [in] */ __RPC__in_opt ITCallInfo *pCall) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateSelectedCalls( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppCallEnum) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SelectedCalls( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAutomatedPhoneControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAutomatedPhoneControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAutomatedPhoneControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAutomatedPhoneControl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartTone )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ PHONE_TONE Tone,
            /* [in] */ long lDuration);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopTone )( 
            ITAutomatedPhoneControl * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Tone )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out PHONE_TONE *pTone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartRinger )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ long lRingMode,
            /* [in] */ long lDuration);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopRinger )( 
            ITAutomatedPhoneControl * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Ringer )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfRinging);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PhoneHandlingEnabled )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ VARIANT_BOOL fEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PhoneHandlingEnabled )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoEndOfNumberTimeout )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ long lTimeout);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoEndOfNumberTimeout )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out long *plTimeout);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoDialtone )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ VARIANT_BOOL fEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoDialtone )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStopTonesOnOnHook )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ VARIANT_BOOL fEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStopTonesOnOnHook )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStopRingOnOffHook )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ VARIANT_BOOL fEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStopRingOnOffHook )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoKeypadTones )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ VARIANT_BOOL fEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoKeypadTones )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoKeypadTonesMinimumDuration )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ long lDuration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoKeypadTonesMinimumDuration )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out long *plDuration);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoVolumeControl )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ VARIANT_BOOL fEnabled);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoVolumeControl )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *fEnabled);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoVolumeControlStep )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ long lStepSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoVolumeControlStep )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out long *plStepSize);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoVolumeControlRepeatDelay )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ long lDelay);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoVolumeControlRepeatDelay )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out long *plDelay);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AutoVolumeControlRepeatPeriod )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ long lPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AutoVolumeControlRepeatPeriod )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out long *plPeriod);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectCall )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ __RPC__in_opt ITCallInfo *pCall,
            /* [in] */ VARIANT_BOOL fSelectDefaultTerminals);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnselectCall )( 
            ITAutomatedPhoneControl * This,
            /* [in] */ __RPC__in_opt ITCallInfo *pCall);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateSelectedCalls )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppCallEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SelectedCalls )( 
            ITAutomatedPhoneControl * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITAutomatedPhoneControlVtbl;

    interface ITAutomatedPhoneControl
    {
        CONST_VTBL struct ITAutomatedPhoneControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAutomatedPhoneControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAutomatedPhoneControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAutomatedPhoneControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAutomatedPhoneControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAutomatedPhoneControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAutomatedPhoneControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAutomatedPhoneControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAutomatedPhoneControl_StartTone(This,Tone,lDuration)	\
    ( (This)->lpVtbl -> StartTone(This,Tone,lDuration) ) 

#define ITAutomatedPhoneControl_StopTone(This)	\
    ( (This)->lpVtbl -> StopTone(This) ) 

#define ITAutomatedPhoneControl_get_Tone(This,pTone)	\
    ( (This)->lpVtbl -> get_Tone(This,pTone) ) 

#define ITAutomatedPhoneControl_StartRinger(This,lRingMode,lDuration)	\
    ( (This)->lpVtbl -> StartRinger(This,lRingMode,lDuration) ) 

#define ITAutomatedPhoneControl_StopRinger(This)	\
    ( (This)->lpVtbl -> StopRinger(This) ) 

#define ITAutomatedPhoneControl_get_Ringer(This,pfRinging)	\
    ( (This)->lpVtbl -> get_Ringer(This,pfRinging) ) 

#define ITAutomatedPhoneControl_put_PhoneHandlingEnabled(This,fEnabled)	\
    ( (This)->lpVtbl -> put_PhoneHandlingEnabled(This,fEnabled) ) 

#define ITAutomatedPhoneControl_get_PhoneHandlingEnabled(This,pfEnabled)	\
    ( (This)->lpVtbl -> get_PhoneHandlingEnabled(This,pfEnabled) ) 

#define ITAutomatedPhoneControl_put_AutoEndOfNumberTimeout(This,lTimeout)	\
    ( (This)->lpVtbl -> put_AutoEndOfNumberTimeout(This,lTimeout) ) 

#define ITAutomatedPhoneControl_get_AutoEndOfNumberTimeout(This,plTimeout)	\
    ( (This)->lpVtbl -> get_AutoEndOfNumberTimeout(This,plTimeout) ) 

#define ITAutomatedPhoneControl_put_AutoDialtone(This,fEnabled)	\
    ( (This)->lpVtbl -> put_AutoDialtone(This,fEnabled) ) 

#define ITAutomatedPhoneControl_get_AutoDialtone(This,pfEnabled)	\
    ( (This)->lpVtbl -> get_AutoDialtone(This,pfEnabled) ) 

#define ITAutomatedPhoneControl_put_AutoStopTonesOnOnHook(This,fEnabled)	\
    ( (This)->lpVtbl -> put_AutoStopTonesOnOnHook(This,fEnabled) ) 

#define ITAutomatedPhoneControl_get_AutoStopTonesOnOnHook(This,pfEnabled)	\
    ( (This)->lpVtbl -> get_AutoStopTonesOnOnHook(This,pfEnabled) ) 

#define ITAutomatedPhoneControl_put_AutoStopRingOnOffHook(This,fEnabled)	\
    ( (This)->lpVtbl -> put_AutoStopRingOnOffHook(This,fEnabled) ) 

#define ITAutomatedPhoneControl_get_AutoStopRingOnOffHook(This,pfEnabled)	\
    ( (This)->lpVtbl -> get_AutoStopRingOnOffHook(This,pfEnabled) ) 

#define ITAutomatedPhoneControl_put_AutoKeypadTones(This,fEnabled)	\
    ( (This)->lpVtbl -> put_AutoKeypadTones(This,fEnabled) ) 

#define ITAutomatedPhoneControl_get_AutoKeypadTones(This,pfEnabled)	\
    ( (This)->lpVtbl -> get_AutoKeypadTones(This,pfEnabled) ) 

#define ITAutomatedPhoneControl_put_AutoKeypadTonesMinimumDuration(This,lDuration)	\
    ( (This)->lpVtbl -> put_AutoKeypadTonesMinimumDuration(This,lDuration) ) 

#define ITAutomatedPhoneControl_get_AutoKeypadTonesMinimumDuration(This,plDuration)	\
    ( (This)->lpVtbl -> get_AutoKeypadTonesMinimumDuration(This,plDuration) ) 

#define ITAutomatedPhoneControl_put_AutoVolumeControl(This,fEnabled)	\
    ( (This)->lpVtbl -> put_AutoVolumeControl(This,fEnabled) ) 

#define ITAutomatedPhoneControl_get_AutoVolumeControl(This,fEnabled)	\
    ( (This)->lpVtbl -> get_AutoVolumeControl(This,fEnabled) ) 

#define ITAutomatedPhoneControl_put_AutoVolumeControlStep(This,lStepSize)	\
    ( (This)->lpVtbl -> put_AutoVolumeControlStep(This,lStepSize) ) 

#define ITAutomatedPhoneControl_get_AutoVolumeControlStep(This,plStepSize)	\
    ( (This)->lpVtbl -> get_AutoVolumeControlStep(This,plStepSize) ) 

#define ITAutomatedPhoneControl_put_AutoVolumeControlRepeatDelay(This,lDelay)	\
    ( (This)->lpVtbl -> put_AutoVolumeControlRepeatDelay(This,lDelay) ) 

#define ITAutomatedPhoneControl_get_AutoVolumeControlRepeatDelay(This,plDelay)	\
    ( (This)->lpVtbl -> get_AutoVolumeControlRepeatDelay(This,plDelay) ) 

#define ITAutomatedPhoneControl_put_AutoVolumeControlRepeatPeriod(This,lPeriod)	\
    ( (This)->lpVtbl -> put_AutoVolumeControlRepeatPeriod(This,lPeriod) ) 

#define ITAutomatedPhoneControl_get_AutoVolumeControlRepeatPeriod(This,plPeriod)	\
    ( (This)->lpVtbl -> get_AutoVolumeControlRepeatPeriod(This,plPeriod) ) 

#define ITAutomatedPhoneControl_SelectCall(This,pCall,fSelectDefaultTerminals)	\
    ( (This)->lpVtbl -> SelectCall(This,pCall,fSelectDefaultTerminals) ) 

#define ITAutomatedPhoneControl_UnselectCall(This,pCall)	\
    ( (This)->lpVtbl -> UnselectCall(This,pCall) ) 

#define ITAutomatedPhoneControl_EnumerateSelectedCalls(This,ppCallEnum)	\
    ( (This)->lpVtbl -> EnumerateSelectedCalls(This,ppCallEnum) ) 

#define ITAutomatedPhoneControl_get_SelectedCalls(This,pVariant)	\
    ( (This)->lpVtbl -> get_SelectedCalls(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAutomatedPhoneControl_INTERFACE_DEFINED__ */


#ifndef __ITBasicCallControl_INTERFACE_DEFINED__
#define __ITBasicCallControl_INTERFACE_DEFINED__

/* interface ITBasicCallControl */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITBasicCallControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC389-9355-11d0-835C-00AA003CCABD")
    ITBasicCallControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ VARIANT_BOOL fSync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Answer( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ DISCONNECT_CODE code) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Hold( 
            /* [in] */ VARIANT_BOOL fHold) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HandoffDirect( 
            /* [in] */ __RPC__in BSTR pApplicationName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HandoffIndirect( 
            /* [in] */ long lMediaType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Conference( 
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall,
            /* [in] */ VARIANT_BOOL fSync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Transfer( 
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall,
            /* [in] */ VARIANT_BOOL fSync) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BlindTransfer( 
            /* [in] */ __RPC__in BSTR pDestAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SwapHold( 
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParkDirect( 
            /* [in] */ __RPC__in BSTR pParkAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ParkIndirect( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppNonDirAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Unpark( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetQOS( 
            /* [in] */ long lMediaType,
            /* [in] */ QOS_SERVICE_LEVEL ServiceLevel) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pickup( 
            /* [in] */ __RPC__in BSTR pGroupID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Dial( 
            /* [in] */ __RPC__in BSTR pDestAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Finish( 
            /* [in] */ FINISH_MODE finishMode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveFromConference( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITBasicCallControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITBasicCallControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITBasicCallControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITBasicCallControl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITBasicCallControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITBasicCallControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            ITBasicCallControl * This,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Answer )( 
            ITBasicCallControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            ITBasicCallControl * This,
            /* [in] */ DISCONNECT_CODE code);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Hold )( 
            ITBasicCallControl * This,
            /* [in] */ VARIANT_BOOL fHold);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HandoffDirect )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in BSTR pApplicationName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HandoffIndirect )( 
            ITBasicCallControl * This,
            /* [in] */ long lMediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Conference )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Transfer )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BlindTransfer )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in BSTR pDestAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SwapHold )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParkDirect )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in BSTR pParkAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParkIndirect )( 
            ITBasicCallControl * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppNonDirAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Unpark )( 
            ITBasicCallControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetQOS )( 
            ITBasicCallControl * This,
            /* [in] */ long lMediaType,
            /* [in] */ QOS_SERVICE_LEVEL ServiceLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Pickup )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in BSTR pGroupID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Dial )( 
            ITBasicCallControl * This,
            /* [in] */ __RPC__in BSTR pDestAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Finish )( 
            ITBasicCallControl * This,
            /* [in] */ FINISH_MODE finishMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveFromConference )( 
            ITBasicCallControl * This);
        
        END_INTERFACE
    } ITBasicCallControlVtbl;

    interface ITBasicCallControl
    {
        CONST_VTBL struct ITBasicCallControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITBasicCallControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITBasicCallControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITBasicCallControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITBasicCallControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITBasicCallControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITBasicCallControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITBasicCallControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITBasicCallControl_Connect(This,fSync)	\
    ( (This)->lpVtbl -> Connect(This,fSync) ) 

#define ITBasicCallControl_Answer(This)	\
    ( (This)->lpVtbl -> Answer(This) ) 

#define ITBasicCallControl_Disconnect(This,code)	\
    ( (This)->lpVtbl -> Disconnect(This,code) ) 

#define ITBasicCallControl_Hold(This,fHold)	\
    ( (This)->lpVtbl -> Hold(This,fHold) ) 

#define ITBasicCallControl_HandoffDirect(This,pApplicationName)	\
    ( (This)->lpVtbl -> HandoffDirect(This,pApplicationName) ) 

#define ITBasicCallControl_HandoffIndirect(This,lMediaType)	\
    ( (This)->lpVtbl -> HandoffIndirect(This,lMediaType) ) 

#define ITBasicCallControl_Conference(This,pCall,fSync)	\
    ( (This)->lpVtbl -> Conference(This,pCall,fSync) ) 

#define ITBasicCallControl_Transfer(This,pCall,fSync)	\
    ( (This)->lpVtbl -> Transfer(This,pCall,fSync) ) 

#define ITBasicCallControl_BlindTransfer(This,pDestAddress)	\
    ( (This)->lpVtbl -> BlindTransfer(This,pDestAddress) ) 

#define ITBasicCallControl_SwapHold(This,pCall)	\
    ( (This)->lpVtbl -> SwapHold(This,pCall) ) 

#define ITBasicCallControl_ParkDirect(This,pParkAddress)	\
    ( (This)->lpVtbl -> ParkDirect(This,pParkAddress) ) 

#define ITBasicCallControl_ParkIndirect(This,ppNonDirAddress)	\
    ( (This)->lpVtbl -> ParkIndirect(This,ppNonDirAddress) ) 

#define ITBasicCallControl_Unpark(This)	\
    ( (This)->lpVtbl -> Unpark(This) ) 

#define ITBasicCallControl_SetQOS(This,lMediaType,ServiceLevel)	\
    ( (This)->lpVtbl -> SetQOS(This,lMediaType,ServiceLevel) ) 

#define ITBasicCallControl_Pickup(This,pGroupID)	\
    ( (This)->lpVtbl -> Pickup(This,pGroupID) ) 

#define ITBasicCallControl_Dial(This,pDestAddress)	\
    ( (This)->lpVtbl -> Dial(This,pDestAddress) ) 

#define ITBasicCallControl_Finish(This,finishMode)	\
    ( (This)->lpVtbl -> Finish(This,finishMode) ) 

#define ITBasicCallControl_RemoveFromConference(This)	\
    ( (This)->lpVtbl -> RemoveFromConference(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITBasicCallControl_INTERFACE_DEFINED__ */


#ifndef __ITCallInfo_INTERFACE_DEFINED__
#define __ITCallInfo_INTERFACE_DEFINED__

/* interface ITCallInfo */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("350F85D1-1227-11D3-83D4-00C04FB6809F")
    ITCallInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallState( 
            /* [retval][out] */ __RPC__out CALL_STATE *pCallState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Privilege( 
            /* [retval][out] */ __RPC__out CALL_PRIVILEGE *pPrivilege) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHub( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallHub **ppCallHub) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallInfoLong( 
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [retval][out] */ __RPC__out long *plCallInfoLongVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallInfoLong( 
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [in] */ long lCallInfoLongVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallInfoString( 
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCallInfoString) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallInfoString( 
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [in] */ __RPC__in BSTR pCallInfoString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallInfoBuffer( 
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [retval][out] */ __RPC__out VARIANT *ppCallInfoBuffer) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CallInfoBuffer( 
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ VARIANT pCallInfoBuffer) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetCallInfoBuffer( 
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppCallInfoBuffer) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE SetCallInfoBuffer( 
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSize) BYTE *pCallInfoBuffer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseUserUserInfo( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITCallInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallState )( 
            ITCallInfo * This,
            /* [retval][out] */ __RPC__out CALL_STATE *pCallState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Privilege )( 
            ITCallInfo * This,
            /* [retval][out] */ __RPC__out CALL_PRIVILEGE *pPrivilege);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHub )( 
            ITCallInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallHub **ppCallHub);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallInfoLong )( 
            ITCallInfo * This,
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [retval][out] */ __RPC__out long *plCallInfoLongVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallInfoLong )( 
            ITCallInfo * This,
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [in] */ long lCallInfoLongVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallInfoString )( 
            ITCallInfo * This,
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCallInfoString);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallInfoString )( 
            ITCallInfo * This,
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [in] */ __RPC__in BSTR pCallInfoString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallInfoBuffer )( 
            ITCallInfo * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [retval][out] */ __RPC__out VARIANT *ppCallInfoBuffer);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallInfoBuffer )( 
            ITCallInfo * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ VARIANT pCallInfoBuffer);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetCallInfoBuffer )( 
            ITCallInfo * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppCallInfoBuffer);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *SetCallInfoBuffer )( 
            ITCallInfo * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSize) BYTE *pCallInfoBuffer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseUserUserInfo )( 
            ITCallInfo * This);
        
        END_INTERFACE
    } ITCallInfoVtbl;

    interface ITCallInfo
    {
        CONST_VTBL struct ITCallInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallInfo_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITCallInfo_get_CallState(This,pCallState)	\
    ( (This)->lpVtbl -> get_CallState(This,pCallState) ) 

#define ITCallInfo_get_Privilege(This,pPrivilege)	\
    ( (This)->lpVtbl -> get_Privilege(This,pPrivilege) ) 

#define ITCallInfo_get_CallHub(This,ppCallHub)	\
    ( (This)->lpVtbl -> get_CallHub(This,ppCallHub) ) 

#define ITCallInfo_get_CallInfoLong(This,CallInfoLong,plCallInfoLongVal)	\
    ( (This)->lpVtbl -> get_CallInfoLong(This,CallInfoLong,plCallInfoLongVal) ) 

#define ITCallInfo_put_CallInfoLong(This,CallInfoLong,lCallInfoLongVal)	\
    ( (This)->lpVtbl -> put_CallInfoLong(This,CallInfoLong,lCallInfoLongVal) ) 

#define ITCallInfo_get_CallInfoString(This,CallInfoString,ppCallInfoString)	\
    ( (This)->lpVtbl -> get_CallInfoString(This,CallInfoString,ppCallInfoString) ) 

#define ITCallInfo_put_CallInfoString(This,CallInfoString,pCallInfoString)	\
    ( (This)->lpVtbl -> put_CallInfoString(This,CallInfoString,pCallInfoString) ) 

#define ITCallInfo_get_CallInfoBuffer(This,CallInfoBuffer,ppCallInfoBuffer)	\
    ( (This)->lpVtbl -> get_CallInfoBuffer(This,CallInfoBuffer,ppCallInfoBuffer) ) 

#define ITCallInfo_put_CallInfoBuffer(This,CallInfoBuffer,pCallInfoBuffer)	\
    ( (This)->lpVtbl -> put_CallInfoBuffer(This,CallInfoBuffer,pCallInfoBuffer) ) 

#define ITCallInfo_GetCallInfoBuffer(This,CallInfoBuffer,pdwSize,ppCallInfoBuffer)	\
    ( (This)->lpVtbl -> GetCallInfoBuffer(This,CallInfoBuffer,pdwSize,ppCallInfoBuffer) ) 

#define ITCallInfo_SetCallInfoBuffer(This,CallInfoBuffer,dwSize,pCallInfoBuffer)	\
    ( (This)->lpVtbl -> SetCallInfoBuffer(This,CallInfoBuffer,dwSize,pCallInfoBuffer) ) 

#define ITCallInfo_ReleaseUserUserInfo(This)	\
    ( (This)->lpVtbl -> ReleaseUserUserInfo(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallInfo_INTERFACE_DEFINED__ */


#ifndef __ITCallInfo2_INTERFACE_DEFINED__
#define __ITCallInfo2_INTERFACE_DEFINED__

/* interface ITCallInfo2 */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("94D70CA6-7AB0-4daa-81CA-B8F8643FAEC1")
    ITCallInfo2 : public ITCallInfo
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventFilter( 
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ long lSubEvent,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pEnable) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EventFilter( 
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ long lSubEvent,
            /* [in] */ VARIANT_BOOL bEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallInfo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallInfo2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallInfo2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallInfo2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallInfo2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITCallInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallState )( 
            ITCallInfo2 * This,
            /* [retval][out] */ __RPC__out CALL_STATE *pCallState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Privilege )( 
            ITCallInfo2 * This,
            /* [retval][out] */ __RPC__out CALL_PRIVILEGE *pPrivilege);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHub )( 
            ITCallInfo2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallHub **ppCallHub);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallInfoLong )( 
            ITCallInfo2 * This,
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [retval][out] */ __RPC__out long *plCallInfoLongVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallInfoLong )( 
            ITCallInfo2 * This,
            /* [in] */ CALLINFO_LONG CallInfoLong,
            /* [in] */ long lCallInfoLongVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallInfoString )( 
            ITCallInfo2 * This,
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCallInfoString);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallInfoString )( 
            ITCallInfo2 * This,
            /* [in] */ CALLINFO_STRING CallInfoString,
            /* [in] */ __RPC__in BSTR pCallInfoString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallInfoBuffer )( 
            ITCallInfo2 * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [retval][out] */ __RPC__out VARIANT *ppCallInfoBuffer);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CallInfoBuffer )( 
            ITCallInfo2 * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ VARIANT pCallInfoBuffer);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetCallInfoBuffer )( 
            ITCallInfo2 * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppCallInfoBuffer);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *SetCallInfoBuffer )( 
            ITCallInfo2 * This,
            /* [in] */ CALLINFO_BUFFER CallInfoBuffer,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSize) BYTE *pCallInfoBuffer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseUserUserInfo )( 
            ITCallInfo2 * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventFilter )( 
            ITCallInfo2 * This,
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ long lSubEvent,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pEnable);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EventFilter )( 
            ITCallInfo2 * This,
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ long lSubEvent,
            /* [in] */ VARIANT_BOOL bEnable);
        
        END_INTERFACE
    } ITCallInfo2Vtbl;

    interface ITCallInfo2
    {
        CONST_VTBL struct ITCallInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallInfo2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallInfo2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallInfo2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallInfo2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallInfo2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallInfo2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallInfo2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallInfo2_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITCallInfo2_get_CallState(This,pCallState)	\
    ( (This)->lpVtbl -> get_CallState(This,pCallState) ) 

#define ITCallInfo2_get_Privilege(This,pPrivilege)	\
    ( (This)->lpVtbl -> get_Privilege(This,pPrivilege) ) 

#define ITCallInfo2_get_CallHub(This,ppCallHub)	\
    ( (This)->lpVtbl -> get_CallHub(This,ppCallHub) ) 

#define ITCallInfo2_get_CallInfoLong(This,CallInfoLong,plCallInfoLongVal)	\
    ( (This)->lpVtbl -> get_CallInfoLong(This,CallInfoLong,plCallInfoLongVal) ) 

#define ITCallInfo2_put_CallInfoLong(This,CallInfoLong,lCallInfoLongVal)	\
    ( (This)->lpVtbl -> put_CallInfoLong(This,CallInfoLong,lCallInfoLongVal) ) 

#define ITCallInfo2_get_CallInfoString(This,CallInfoString,ppCallInfoString)	\
    ( (This)->lpVtbl -> get_CallInfoString(This,CallInfoString,ppCallInfoString) ) 

#define ITCallInfo2_put_CallInfoString(This,CallInfoString,pCallInfoString)	\
    ( (This)->lpVtbl -> put_CallInfoString(This,CallInfoString,pCallInfoString) ) 

#define ITCallInfo2_get_CallInfoBuffer(This,CallInfoBuffer,ppCallInfoBuffer)	\
    ( (This)->lpVtbl -> get_CallInfoBuffer(This,CallInfoBuffer,ppCallInfoBuffer) ) 

#define ITCallInfo2_put_CallInfoBuffer(This,CallInfoBuffer,pCallInfoBuffer)	\
    ( (This)->lpVtbl -> put_CallInfoBuffer(This,CallInfoBuffer,pCallInfoBuffer) ) 

#define ITCallInfo2_GetCallInfoBuffer(This,CallInfoBuffer,pdwSize,ppCallInfoBuffer)	\
    ( (This)->lpVtbl -> GetCallInfoBuffer(This,CallInfoBuffer,pdwSize,ppCallInfoBuffer) ) 

#define ITCallInfo2_SetCallInfoBuffer(This,CallInfoBuffer,dwSize,pCallInfoBuffer)	\
    ( (This)->lpVtbl -> SetCallInfoBuffer(This,CallInfoBuffer,dwSize,pCallInfoBuffer) ) 

#define ITCallInfo2_ReleaseUserUserInfo(This)	\
    ( (This)->lpVtbl -> ReleaseUserUserInfo(This) ) 


#define ITCallInfo2_get_EventFilter(This,TapiEvent,lSubEvent,pEnable)	\
    ( (This)->lpVtbl -> get_EventFilter(This,TapiEvent,lSubEvent,pEnable) ) 

#define ITCallInfo2_put_EventFilter(This,TapiEvent,lSubEvent,bEnable)	\
    ( (This)->lpVtbl -> put_EventFilter(This,TapiEvent,lSubEvent,bEnable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallInfo2_INTERFACE_DEFINED__ */


#ifndef __ITTerminal_INTERFACE_DEFINED__
#define __ITTerminal_INTERFACE_DEFINED__

/* interface ITTerminal */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTerminal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC38A-9355-11d0-835C-00AA003CCABD")
    ITTerminal : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out TERMINAL_STATE *pTerminalState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TerminalType( 
            /* [retval][out] */ __RPC__out TERMINAL_TYPE *pType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TerminalClass( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppTerminalClass) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ __RPC__out long *plMediaType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ __RPC__out TERMINAL_DIRECTION *pDirection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTerminalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTerminal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTerminal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTerminal * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTerminal * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTerminal * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITTerminal * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITTerminal * This,
            /* [retval][out] */ __RPC__out TERMINAL_STATE *pTerminalState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TerminalType )( 
            ITTerminal * This,
            /* [retval][out] */ __RPC__out TERMINAL_TYPE *pType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TerminalClass )( 
            ITTerminal * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppTerminalClass);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            ITTerminal * This,
            /* [retval][out] */ __RPC__out long *plMediaType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            ITTerminal * This,
            /* [retval][out] */ __RPC__out TERMINAL_DIRECTION *pDirection);
        
        END_INTERFACE
    } ITTerminalVtbl;

    interface ITTerminal
    {
        CONST_VTBL struct ITTerminalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTerminal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTerminal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTerminal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTerminal_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTerminal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTerminal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTerminal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTerminal_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#define ITTerminal_get_State(This,pTerminalState)	\
    ( (This)->lpVtbl -> get_State(This,pTerminalState) ) 

#define ITTerminal_get_TerminalType(This,pType)	\
    ( (This)->lpVtbl -> get_TerminalType(This,pType) ) 

#define ITTerminal_get_TerminalClass(This,ppTerminalClass)	\
    ( (This)->lpVtbl -> get_TerminalClass(This,ppTerminalClass) ) 

#define ITTerminal_get_MediaType(This,plMediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,plMediaType) ) 

#define ITTerminal_get_Direction(This,pDirection)	\
    ( (This)->lpVtbl -> get_Direction(This,pDirection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTerminal_INTERFACE_DEFINED__ */


#ifndef __ITMultiTrackTerminal_INTERFACE_DEFINED__
#define __ITMultiTrackTerminal_INTERFACE_DEFINED__

/* interface ITMultiTrackTerminal */
/* [helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITMultiTrackTerminal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE040091-ADE8-4072-95C9-BF7DE8C54B44")
    ITMultiTrackTerminal : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrackTerminals( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateTrackTerminals( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppEnumTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateTrackTerminal( 
            /* [in] */ long MediaType,
            /* [in] */ TERMINAL_DIRECTION TerminalDirection,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaTypesInUse( 
            /* [retval][out] */ __RPC__out long *plMediaTypesInUse) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectionsInUse( 
            /* [retval][out] */ __RPC__out TERMINAL_DIRECTION *plDirectionsInUsed) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveTrackTerminal( 
            /* [in] */ __RPC__in_opt ITTerminal *pTrackTerminalToRemove) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMultiTrackTerminalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITMultiTrackTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITMultiTrackTerminal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITMultiTrackTerminal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITMultiTrackTerminal * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITMultiTrackTerminal * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITMultiTrackTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITMultiTrackTerminal * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrackTerminals )( 
            ITMultiTrackTerminal * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateTrackTerminals )( 
            ITMultiTrackTerminal * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppEnumTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTrackTerminal )( 
            ITMultiTrackTerminal * This,
            /* [in] */ long MediaType,
            /* [in] */ TERMINAL_DIRECTION TerminalDirection,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaTypesInUse )( 
            ITMultiTrackTerminal * This,
            /* [retval][out] */ __RPC__out long *plMediaTypesInUse);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectionsInUse )( 
            ITMultiTrackTerminal * This,
            /* [retval][out] */ __RPC__out TERMINAL_DIRECTION *plDirectionsInUsed);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveTrackTerminal )( 
            ITMultiTrackTerminal * This,
            /* [in] */ __RPC__in_opt ITTerminal *pTrackTerminalToRemove);
        
        END_INTERFACE
    } ITMultiTrackTerminalVtbl;

    interface ITMultiTrackTerminal
    {
        CONST_VTBL struct ITMultiTrackTerminalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMultiTrackTerminal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITMultiTrackTerminal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITMultiTrackTerminal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITMultiTrackTerminal_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITMultiTrackTerminal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITMultiTrackTerminal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITMultiTrackTerminal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITMultiTrackTerminal_get_TrackTerminals(This,pVariant)	\
    ( (This)->lpVtbl -> get_TrackTerminals(This,pVariant) ) 

#define ITMultiTrackTerminal_EnumerateTrackTerminals(This,ppEnumTerminal)	\
    ( (This)->lpVtbl -> EnumerateTrackTerminals(This,ppEnumTerminal) ) 

#define ITMultiTrackTerminal_CreateTrackTerminal(This,MediaType,TerminalDirection,ppTerminal)	\
    ( (This)->lpVtbl -> CreateTrackTerminal(This,MediaType,TerminalDirection,ppTerminal) ) 

#define ITMultiTrackTerminal_get_MediaTypesInUse(This,plMediaTypesInUse)	\
    ( (This)->lpVtbl -> get_MediaTypesInUse(This,plMediaTypesInUse) ) 

#define ITMultiTrackTerminal_get_DirectionsInUse(This,plDirectionsInUsed)	\
    ( (This)->lpVtbl -> get_DirectionsInUse(This,plDirectionsInUsed) ) 

#define ITMultiTrackTerminal_RemoveTrackTerminal(This,pTrackTerminalToRemove)	\
    ( (This)->lpVtbl -> RemoveTrackTerminal(This,pTrackTerminalToRemove) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITMultiTrackTerminal_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tapi3if_0000_0017 */
/* [local] */ 

typedef 
enum TERMINAL_MEDIA_STATE
    {	TMS_IDLE	= 0,
	TMS_ACTIVE	= ( TMS_IDLE + 1 ) ,
	TMS_PAUSED	= ( TMS_ACTIVE + 1 ) ,
	TMS_LASTITEM	= TMS_PAUSED
    } 	TERMINAL_MEDIA_STATE;

typedef 
enum FT_STATE_EVENT_CAUSE
    {	FTEC_NORMAL	= 0,
	FTEC_END_OF_FILE	= ( FTEC_NORMAL + 1 ) ,
	FTEC_READ_ERROR	= ( FTEC_END_OF_FILE + 1 ) ,
	FTEC_WRITE_ERROR	= ( FTEC_READ_ERROR + 1 ) 
    } 	FT_STATE_EVENT_CAUSE;



extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0000_0017_v0_0_s_ifspec;

#ifndef __ITFileTrack_INTERFACE_DEFINED__
#define __ITFileTrack_INTERFACE_DEFINED__

/* interface ITFileTrack */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITFileTrack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("31CA6EA9-C08A-4bea-8811-8E9C1BA3EA3A")
    ITFileTrack : public IDispatch
    {
    public:
        virtual /* [helpstring][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_Format( 
            /* [retval][out] */ __RPC__deref_out_opt AM_MEDIA_TYPE **ppmt) = 0;
        
        virtual /* [helpstring][hidden][id][propput] */ HRESULT STDMETHODCALLTYPE put_Format( 
            /* [in] */ __RPC__in const AM_MEDIA_TYPE *pmt) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ControllingTerminal( 
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppControllingTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AudioFormatForScripting( 
            /* [retval][out] */ __RPC__deref_out_opt ITScriptableAudioFormat **ppAudioFormat) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AudioFormatForScripting( 
            /* [in] */ __RPC__in_opt ITScriptableAudioFormat *pAudioFormat) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EmptyAudioFormatForScripting( 
            /* [retval][out] */ __RPC__deref_out_opt ITScriptableAudioFormat **ppAudioFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITFileTrackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITFileTrack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITFileTrack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITFileTrack * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITFileTrack * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITFileTrack * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITFileTrack * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITFileTrack * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Format )( 
            ITFileTrack * This,
            /* [retval][out] */ __RPC__deref_out_opt AM_MEDIA_TYPE **ppmt);
        
        /* [helpstring][hidden][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Format )( 
            ITFileTrack * This,
            /* [in] */ __RPC__in const AM_MEDIA_TYPE *pmt);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ControllingTerminal )( 
            ITFileTrack * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppControllingTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioFormatForScripting )( 
            ITFileTrack * This,
            /* [retval][out] */ __RPC__deref_out_opt ITScriptableAudioFormat **ppAudioFormat);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AudioFormatForScripting )( 
            ITFileTrack * This,
            /* [in] */ __RPC__in_opt ITScriptableAudioFormat *pAudioFormat);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EmptyAudioFormatForScripting )( 
            ITFileTrack * This,
            /* [retval][out] */ __RPC__deref_out_opt ITScriptableAudioFormat **ppAudioFormat);
        
        END_INTERFACE
    } ITFileTrackVtbl;

    interface ITFileTrack
    {
        CONST_VTBL struct ITFileTrackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITFileTrack_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITFileTrack_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITFileTrack_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITFileTrack_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITFileTrack_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITFileTrack_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITFileTrack_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITFileTrack_get_Format(This,ppmt)	\
    ( (This)->lpVtbl -> get_Format(This,ppmt) ) 

#define ITFileTrack_put_Format(This,pmt)	\
    ( (This)->lpVtbl -> put_Format(This,pmt) ) 

#define ITFileTrack_get_ControllingTerminal(This,ppControllingTerminal)	\
    ( (This)->lpVtbl -> get_ControllingTerminal(This,ppControllingTerminal) ) 

#define ITFileTrack_get_AudioFormatForScripting(This,ppAudioFormat)	\
    ( (This)->lpVtbl -> get_AudioFormatForScripting(This,ppAudioFormat) ) 

#define ITFileTrack_put_AudioFormatForScripting(This,pAudioFormat)	\
    ( (This)->lpVtbl -> put_AudioFormatForScripting(This,pAudioFormat) ) 

#define ITFileTrack_get_EmptyAudioFormatForScripting(This,ppAudioFormat)	\
    ( (This)->lpVtbl -> get_EmptyAudioFormatForScripting(This,ppAudioFormat) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITFileTrack_INTERFACE_DEFINED__ */


#ifndef __ITMediaPlayback_INTERFACE_DEFINED__
#define __ITMediaPlayback_INTERFACE_DEFINED__

/* interface ITMediaPlayback */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITMediaPlayback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("627E8AE6-AE4C-4a69-BB63-2AD625404B77")
    ITMediaPlayback : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlayList( 
            /* [in] */ VARIANTARG PlayListVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlayList( 
            /* [retval][out] */ __RPC__out VARIANTARG *pPlayListVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMediaPlaybackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITMediaPlayback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITMediaPlayback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITMediaPlayback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITMediaPlayback * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITMediaPlayback * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITMediaPlayback * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITMediaPlayback * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlayList )( 
            ITMediaPlayback * This,
            /* [in] */ VARIANTARG PlayListVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlayList )( 
            ITMediaPlayback * This,
            /* [retval][out] */ __RPC__out VARIANTARG *pPlayListVariant);
        
        END_INTERFACE
    } ITMediaPlaybackVtbl;

    interface ITMediaPlayback
    {
        CONST_VTBL struct ITMediaPlaybackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMediaPlayback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITMediaPlayback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITMediaPlayback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITMediaPlayback_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITMediaPlayback_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITMediaPlayback_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITMediaPlayback_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITMediaPlayback_put_PlayList(This,PlayListVariant)	\
    ( (This)->lpVtbl -> put_PlayList(This,PlayListVariant) ) 

#define ITMediaPlayback_get_PlayList(This,pPlayListVariant)	\
    ( (This)->lpVtbl -> get_PlayList(This,pPlayListVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITMediaPlayback_INTERFACE_DEFINED__ */


#ifndef __ITMediaRecord_INTERFACE_DEFINED__
#define __ITMediaRecord_INTERFACE_DEFINED__

/* interface ITMediaRecord */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITMediaRecord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5DD4592-5476-4cc1-9D4D-FAD3EEFE7DB2")
    ITMediaRecord : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ __RPC__in BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMediaRecordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITMediaRecord * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITMediaRecord * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITMediaRecord * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITMediaRecord * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITMediaRecord * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITMediaRecord * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITMediaRecord * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            ITMediaRecord * This,
            /* [in] */ __RPC__in BSTR bstrFileName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            ITMediaRecord * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrFileName);
        
        END_INTERFACE
    } ITMediaRecordVtbl;

    interface ITMediaRecord
    {
        CONST_VTBL struct ITMediaRecordVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMediaRecord_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITMediaRecord_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITMediaRecord_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITMediaRecord_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITMediaRecord_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITMediaRecord_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITMediaRecord_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITMediaRecord_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define ITMediaRecord_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITMediaRecord_INTERFACE_DEFINED__ */


#ifndef __ITMediaControl_INTERFACE_DEFINED__
#define __ITMediaControl_INTERFACE_DEFINED__

/* interface ITMediaControl */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ITMediaControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C445DDE8-5199-4bc7-9807-5FFB92E42E09")
    ITMediaControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaState( 
            /* [retval][out] */ __RPC__out TERMINAL_MEDIA_STATE *pTerminalMediaState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITMediaControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITMediaControl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITMediaControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITMediaControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Start )( 
            ITMediaControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ITMediaControl * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            ITMediaControl * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaState )( 
            ITMediaControl * This,
            /* [retval][out] */ __RPC__out TERMINAL_MEDIA_STATE *pTerminalMediaState);
        
        END_INTERFACE
    } ITMediaControlVtbl;

    interface ITMediaControl
    {
        CONST_VTBL struct ITMediaControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITMediaControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITMediaControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITMediaControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITMediaControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITMediaControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITMediaControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITMediaControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITMediaControl_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define ITMediaControl_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define ITMediaControl_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define ITMediaControl_get_MediaState(This,pTerminalMediaState)	\
    ( (This)->lpVtbl -> get_MediaState(This,pTerminalMediaState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITMediaControl_INTERFACE_DEFINED__ */


#ifndef __ITBasicAudioTerminal_INTERFACE_DEFINED__
#define __ITBasicAudioTerminal_INTERFACE_DEFINED__

/* interface ITBasicAudioTerminal */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITBasicAudioTerminal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1EFC38D-9355-11d0-835C-00AA003CCABD")
    ITBasicAudioTerminal : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVolume) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ __RPC__out long *plVolume) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long lBalance) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ __RPC__out long *plBalance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITBasicAudioTerminalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITBasicAudioTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITBasicAudioTerminal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITBasicAudioTerminal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITBasicAudioTerminal * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITBasicAudioTerminal * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITBasicAudioTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITBasicAudioTerminal * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            ITBasicAudioTerminal * This,
            /* [in] */ long lVolume);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            ITBasicAudioTerminal * This,
            /* [retval][out] */ __RPC__out long *plVolume);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Balance )( 
            ITBasicAudioTerminal * This,
            /* [in] */ long lBalance);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Balance )( 
            ITBasicAudioTerminal * This,
            /* [retval][out] */ __RPC__out long *plBalance);
        
        END_INTERFACE
    } ITBasicAudioTerminalVtbl;

    interface ITBasicAudioTerminal
    {
        CONST_VTBL struct ITBasicAudioTerminalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITBasicAudioTerminal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITBasicAudioTerminal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITBasicAudioTerminal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITBasicAudioTerminal_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITBasicAudioTerminal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITBasicAudioTerminal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITBasicAudioTerminal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITBasicAudioTerminal_put_Volume(This,lVolume)	\
    ( (This)->lpVtbl -> put_Volume(This,lVolume) ) 

#define ITBasicAudioTerminal_get_Volume(This,plVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,plVolume) ) 

#define ITBasicAudioTerminal_put_Balance(This,lBalance)	\
    ( (This)->lpVtbl -> put_Balance(This,lBalance) ) 

#define ITBasicAudioTerminal_get_Balance(This,plBalance)	\
    ( (This)->lpVtbl -> get_Balance(This,plBalance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITBasicAudioTerminal_INTERFACE_DEFINED__ */


#ifndef __ITStaticAudioTerminal_INTERFACE_DEFINED__
#define __ITStaticAudioTerminal_INTERFACE_DEFINED__

/* interface ITStaticAudioTerminal */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITStaticAudioTerminal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A86B7871-D14C-48e6-922E-A8D15F984800")
    ITStaticAudioTerminal : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WaveId( 
            /* [retval][out] */ __RPC__out long *plWaveId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITStaticAudioTerminalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITStaticAudioTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITStaticAudioTerminal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITStaticAudioTerminal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITStaticAudioTerminal * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITStaticAudioTerminal * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITStaticAudioTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITStaticAudioTerminal * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WaveId )( 
            ITStaticAudioTerminal * This,
            /* [retval][out] */ __RPC__out long *plWaveId);
        
        END_INTERFACE
    } ITStaticAudioTerminalVtbl;

    interface ITStaticAudioTerminal
    {
        CONST_VTBL struct ITStaticAudioTerminalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITStaticAudioTerminal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITStaticAudioTerminal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITStaticAudioTerminal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITStaticAudioTerminal_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITStaticAudioTerminal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITStaticAudioTerminal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITStaticAudioTerminal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITStaticAudioTerminal_get_WaveId(This,plWaveId)	\
    ( (This)->lpVtbl -> get_WaveId(This,plWaveId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITStaticAudioTerminal_INTERFACE_DEFINED__ */


#ifndef __ITCallHub_INTERFACE_DEFINED__
#define __ITCallHub_INTERFACE_DEFINED__

/* interface ITCallHub */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallHub;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3C1544E-5B92-11d1-8F4E-00C04FB6809F")
    ITCallHub : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCalls( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppEnumCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Calls( 
            /* [retval][out] */ __RPC__out VARIANT *pCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out CALLHUB_STATE *pState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallHubVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallHub * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallHub * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallHub * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallHub * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallHub * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallHub * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallHub * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITCallHub * This);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateCalls )( 
            ITCallHub * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppEnumCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Calls )( 
            ITCallHub * This,
            /* [retval][out] */ __RPC__out VARIANT *pCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumCalls )( 
            ITCallHub * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITCallHub * This,
            /* [retval][out] */ __RPC__out CALLHUB_STATE *pState);
        
        END_INTERFACE
    } ITCallHubVtbl;

    interface ITCallHub
    {
        CONST_VTBL struct ITCallHubVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallHub_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallHub_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallHub_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallHub_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallHub_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallHub_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallHub_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallHub_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define ITCallHub_EnumerateCalls(This,ppEnumCall)	\
    ( (This)->lpVtbl -> EnumerateCalls(This,ppEnumCall) ) 

#define ITCallHub_get_Calls(This,pCalls)	\
    ( (This)->lpVtbl -> get_Calls(This,pCalls) ) 

#define ITCallHub_get_NumCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumCalls(This,plCalls) ) 

#define ITCallHub_get_State(This,pState)	\
    ( (This)->lpVtbl -> get_State(This,pState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallHub_INTERFACE_DEFINED__ */


#ifndef __ITLegacyAddressMediaControl_INTERFACE_DEFINED__
#define __ITLegacyAddressMediaControl_INTERFACE_DEFINED__

/* interface ITLegacyAddressMediaControl */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLegacyAddressMediaControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB493640-4C0B-11D2-A046-00C04FB6809F")
    ITLegacyAddressMediaControl : public IUnknown
    {
    public:
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetID( 
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceID) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetDevConfig( 
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceConfig) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE SetDevConfig( 
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSize) BYTE *pDeviceConfig) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLegacyAddressMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITLegacyAddressMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITLegacyAddressMediaControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITLegacyAddressMediaControl * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ITLegacyAddressMediaControl * This,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceID);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevConfig )( 
            ITLegacyAddressMediaControl * This,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceConfig);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *SetDevConfig )( 
            ITLegacyAddressMediaControl * This,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSize) BYTE *pDeviceConfig);
        
        END_INTERFACE
    } ITLegacyAddressMediaControlVtbl;

    interface ITLegacyAddressMediaControl
    {
        CONST_VTBL struct ITLegacyAddressMediaControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLegacyAddressMediaControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITLegacyAddressMediaControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITLegacyAddressMediaControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITLegacyAddressMediaControl_GetID(This,pDeviceClass,pdwSize,ppDeviceID)	\
    ( (This)->lpVtbl -> GetID(This,pDeviceClass,pdwSize,ppDeviceID) ) 

#define ITLegacyAddressMediaControl_GetDevConfig(This,pDeviceClass,pdwSize,ppDeviceConfig)	\
    ( (This)->lpVtbl -> GetDevConfig(This,pDeviceClass,pdwSize,ppDeviceConfig) ) 

#define ITLegacyAddressMediaControl_SetDevConfig(This,pDeviceClass,dwSize,pDeviceConfig)	\
    ( (This)->lpVtbl -> SetDevConfig(This,pDeviceClass,dwSize,pDeviceConfig) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITLegacyAddressMediaControl_INTERFACE_DEFINED__ */


#ifndef __ITPrivateEvent_INTERFACE_DEFINED__
#define __ITPrivateEvent_INTERFACE_DEFINED__

/* interface ITPrivateEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPrivateEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0e269cd0-10d4-4121-9c22-9c85d625650d")
    ITPrivateEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHub( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallHub **ppCallHub) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventCode( 
            /* [retval][out] */ __RPC__out long *plEventCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EventInterface( 
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **pEventInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPrivateEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITPrivateEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITPrivateEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITPrivateEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITPrivateEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITPrivateEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITPrivateEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITPrivateEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITPrivateEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITPrivateEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHub )( 
            ITPrivateEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallHub **ppCallHub);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventCode )( 
            ITPrivateEvent * This,
            /* [retval][out] */ __RPC__out long *plEventCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EventInterface )( 
            ITPrivateEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **pEventInterface);
        
        END_INTERFACE
    } ITPrivateEventVtbl;

    interface ITPrivateEvent
    {
        CONST_VTBL struct ITPrivateEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPrivateEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITPrivateEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITPrivateEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITPrivateEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITPrivateEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITPrivateEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITPrivateEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITPrivateEvent_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITPrivateEvent_get_Call(This,ppCallInfo)	\
    ( (This)->lpVtbl -> get_Call(This,ppCallInfo) ) 

#define ITPrivateEvent_get_CallHub(This,ppCallHub)	\
    ( (This)->lpVtbl -> get_CallHub(This,ppCallHub) ) 

#define ITPrivateEvent_get_EventCode(This,plEventCode)	\
    ( (This)->lpVtbl -> get_EventCode(This,plEventCode) ) 

#define ITPrivateEvent_get_EventInterface(This,pEventInterface)	\
    ( (This)->lpVtbl -> get_EventInterface(This,pEventInterface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITPrivateEvent_INTERFACE_DEFINED__ */


#ifndef __ITLegacyAddressMediaControl2_INTERFACE_DEFINED__
#define __ITLegacyAddressMediaControl2_INTERFACE_DEFINED__

/* interface ITLegacyAddressMediaControl2 */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLegacyAddressMediaControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B0EE512B-A531-409e-9DD9-4099FE86C738")
    ITLegacyAddressMediaControl2 : public ITLegacyAddressMediaControl
    {
    public:
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE ConfigDialog( 
            /* [in] */ __RPC__in HWND hwndOwner,
            /* [in] */ __RPC__in BSTR pDeviceClass) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE ConfigDialogEdit( 
            /* [in] */ __RPC__in HWND hwndOwner,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [in] */ DWORD dwSizeIn,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSizeIn) BYTE *pDeviceConfigIn,
            /* [out] */ __RPC__out DWORD *pdwSizeOut,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSizeOut) BYTE **ppDeviceConfigOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLegacyAddressMediaControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITLegacyAddressMediaControl2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITLegacyAddressMediaControl2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITLegacyAddressMediaControl2 * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ITLegacyAddressMediaControl2 * This,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceID);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetDevConfig )( 
            ITLegacyAddressMediaControl2 * This,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceConfig);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *SetDevConfig )( 
            ITLegacyAddressMediaControl2 * This,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [in] */ DWORD dwSize,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSize) BYTE *pDeviceConfig);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *ConfigDialog )( 
            ITLegacyAddressMediaControl2 * This,
            /* [in] */ __RPC__in HWND hwndOwner,
            /* [in] */ __RPC__in BSTR pDeviceClass);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *ConfigDialogEdit )( 
            ITLegacyAddressMediaControl2 * This,
            /* [in] */ __RPC__in HWND hwndOwner,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [in] */ DWORD dwSizeIn,
            /* [size_is][in] */ __RPC__in_ecount_full(dwSizeIn) BYTE *pDeviceConfigIn,
            /* [out] */ __RPC__out DWORD *pdwSizeOut,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSizeOut) BYTE **ppDeviceConfigOut);
        
        END_INTERFACE
    } ITLegacyAddressMediaControl2Vtbl;

    interface ITLegacyAddressMediaControl2
    {
        CONST_VTBL struct ITLegacyAddressMediaControl2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLegacyAddressMediaControl2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITLegacyAddressMediaControl2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITLegacyAddressMediaControl2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITLegacyAddressMediaControl2_GetID(This,pDeviceClass,pdwSize,ppDeviceID)	\
    ( (This)->lpVtbl -> GetID(This,pDeviceClass,pdwSize,ppDeviceID) ) 

#define ITLegacyAddressMediaControl2_GetDevConfig(This,pDeviceClass,pdwSize,ppDeviceConfig)	\
    ( (This)->lpVtbl -> GetDevConfig(This,pDeviceClass,pdwSize,ppDeviceConfig) ) 

#define ITLegacyAddressMediaControl2_SetDevConfig(This,pDeviceClass,dwSize,pDeviceConfig)	\
    ( (This)->lpVtbl -> SetDevConfig(This,pDeviceClass,dwSize,pDeviceConfig) ) 


#define ITLegacyAddressMediaControl2_ConfigDialog(This,hwndOwner,pDeviceClass)	\
    ( (This)->lpVtbl -> ConfigDialog(This,hwndOwner,pDeviceClass) ) 

#define ITLegacyAddressMediaControl2_ConfigDialogEdit(This,hwndOwner,pDeviceClass,dwSizeIn,pDeviceConfigIn,pdwSizeOut,ppDeviceConfigOut)	\
    ( (This)->lpVtbl -> ConfigDialogEdit(This,hwndOwner,pDeviceClass,dwSizeIn,pDeviceConfigIn,pdwSizeOut,ppDeviceConfigOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITLegacyAddressMediaControl2_INTERFACE_DEFINED__ */


#ifndef __ITLegacyCallMediaControl_INTERFACE_DEFINED__
#define __ITLegacyCallMediaControl_INTERFACE_DEFINED__

/* interface ITLegacyCallMediaControl */
/* [object][unique][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLegacyCallMediaControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d624582f-cc23-4436-b8a5-47c625c8045d")
    ITLegacyCallMediaControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DetectDigits( 
            /* [in] */ TAPI_DIGITMODE DigitMode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateDigits( 
            /* [in] */ __RPC__in BSTR pDigits,
            /* [in] */ TAPI_DIGITMODE DigitMode) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetID( 
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetMediaType( 
            /* [in] */ long lMediaType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MonitorMedia( 
            /* [in] */ long lMediaType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLegacyCallMediaControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITLegacyCallMediaControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITLegacyCallMediaControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITLegacyCallMediaControl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DetectDigits )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ TAPI_DIGITMODE DigitMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateDigits )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ __RPC__in BSTR pDigits,
            /* [in] */ TAPI_DIGITMODE DigitMode);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ long lMediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MonitorMedia )( 
            ITLegacyCallMediaControl * This,
            /* [in] */ long lMediaType);
        
        END_INTERFACE
    } ITLegacyCallMediaControlVtbl;

    interface ITLegacyCallMediaControl
    {
        CONST_VTBL struct ITLegacyCallMediaControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLegacyCallMediaControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITLegacyCallMediaControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITLegacyCallMediaControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITLegacyCallMediaControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITLegacyCallMediaControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITLegacyCallMediaControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITLegacyCallMediaControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITLegacyCallMediaControl_DetectDigits(This,DigitMode)	\
    ( (This)->lpVtbl -> DetectDigits(This,DigitMode) ) 

#define ITLegacyCallMediaControl_GenerateDigits(This,pDigits,DigitMode)	\
    ( (This)->lpVtbl -> GenerateDigits(This,pDigits,DigitMode) ) 

#define ITLegacyCallMediaControl_GetID(This,pDeviceClass,pdwSize,ppDeviceID)	\
    ( (This)->lpVtbl -> GetID(This,pDeviceClass,pdwSize,ppDeviceID) ) 

#define ITLegacyCallMediaControl_SetMediaType(This,lMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,lMediaType) ) 

#define ITLegacyCallMediaControl_MonitorMedia(This,lMediaType)	\
    ( (This)->lpVtbl -> MonitorMedia(This,lMediaType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITLegacyCallMediaControl_INTERFACE_DEFINED__ */


#ifndef __ITLegacyCallMediaControl2_INTERFACE_DEFINED__
#define __ITLegacyCallMediaControl2_INTERFACE_DEFINED__

/* interface ITLegacyCallMediaControl2 */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLegacyCallMediaControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57CA332D-7BC2-44f1-A60C-936FE8D7CE73")
    ITLegacyCallMediaControl2 : public ITLegacyCallMediaControl
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateDigits2( 
            /* [in] */ __RPC__in BSTR pDigits,
            /* [in] */ TAPI_DIGITMODE DigitMode,
            /* [in] */ long lDuration) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GatherDigits( 
            /* [in] */ TAPI_DIGITMODE DigitMode,
            /* [in] */ long lNumDigits,
            /* [in] */ __RPC__in BSTR pTerminationDigits,
            /* [in] */ long lFirstDigitTimeout,
            /* [in] */ long lInterDigitTimeout) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE DetectTones( 
            /* [in] */ __RPC__in TAPI_DETECTTONE *pToneList,
            /* [in] */ long lNumTones) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DetectTonesByCollection( 
            /* [in] */ __RPC__in_opt ITCollection2 *pDetectToneCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateTone( 
            /* [in] */ TAPI_TONEMODE ToneMode,
            /* [in] */ long lDuration) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE GenerateCustomTones( 
            /* [in] */ __RPC__in TAPI_CUSTOMTONE *pToneList,
            /* [in] */ long lNumTones,
            /* [in] */ long lDuration) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateCustomTonesByCollection( 
            /* [in] */ __RPC__in_opt ITCollection2 *pCustomToneCollection,
            /* [in] */ long lDuration) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDetectToneObject( 
            /* [retval][out] */ __RPC__deref_out_opt ITDetectTone **ppDetectTone) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateCustomToneObject( 
            /* [retval][out] */ __RPC__deref_out_opt ITCustomTone **ppCustomTone) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetIDAsVariant( 
            /* [in] */ __RPC__in BSTR bstrDeviceClass,
            /* [retval][out] */ __RPC__out VARIANT *pVarDeviceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLegacyCallMediaControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITLegacyCallMediaControl2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITLegacyCallMediaControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITLegacyCallMediaControl2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DetectDigits )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ TAPI_DIGITMODE DigitMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateDigits )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in BSTR pDigits,
            /* [in] */ TAPI_DIGITMODE DigitMode);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in BSTR pDeviceClass,
            /* [out] */ __RPC__out DWORD *pdwSize,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwSize) BYTE **ppDeviceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMediaType )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ long lMediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MonitorMedia )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ long lMediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateDigits2 )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in BSTR pDigits,
            /* [in] */ TAPI_DIGITMODE DigitMode,
            /* [in] */ long lDuration);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GatherDigits )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ TAPI_DIGITMODE DigitMode,
            /* [in] */ long lNumDigits,
            /* [in] */ __RPC__in BSTR pTerminationDigits,
            /* [in] */ long lFirstDigitTimeout,
            /* [in] */ long lInterDigitTimeout);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DetectTones )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in TAPI_DETECTTONE *pToneList,
            /* [in] */ long lNumTones);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DetectTonesByCollection )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in_opt ITCollection2 *pDetectToneCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateTone )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ TAPI_TONEMODE ToneMode,
            /* [in] */ long lDuration);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateCustomTones )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in TAPI_CUSTOMTONE *pToneList,
            /* [in] */ long lNumTones,
            /* [in] */ long lDuration);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateCustomTonesByCollection )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in_opt ITCollection2 *pCustomToneCollection,
            /* [in] */ long lDuration);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDetectToneObject )( 
            ITLegacyCallMediaControl2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITDetectTone **ppDetectTone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateCustomToneObject )( 
            ITLegacyCallMediaControl2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCustomTone **ppCustomTone);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetIDAsVariant )( 
            ITLegacyCallMediaControl2 * This,
            /* [in] */ __RPC__in BSTR bstrDeviceClass,
            /* [retval][out] */ __RPC__out VARIANT *pVarDeviceID);
        
        END_INTERFACE
    } ITLegacyCallMediaControl2Vtbl;

    interface ITLegacyCallMediaControl2
    {
        CONST_VTBL struct ITLegacyCallMediaControl2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLegacyCallMediaControl2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITLegacyCallMediaControl2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITLegacyCallMediaControl2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITLegacyCallMediaControl2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITLegacyCallMediaControl2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITLegacyCallMediaControl2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITLegacyCallMediaControl2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITLegacyCallMediaControl2_DetectDigits(This,DigitMode)	\
    ( (This)->lpVtbl -> DetectDigits(This,DigitMode) ) 

#define ITLegacyCallMediaControl2_GenerateDigits(This,pDigits,DigitMode)	\
    ( (This)->lpVtbl -> GenerateDigits(This,pDigits,DigitMode) ) 

#define ITLegacyCallMediaControl2_GetID(This,pDeviceClass,pdwSize,ppDeviceID)	\
    ( (This)->lpVtbl -> GetID(This,pDeviceClass,pdwSize,ppDeviceID) ) 

#define ITLegacyCallMediaControl2_SetMediaType(This,lMediaType)	\
    ( (This)->lpVtbl -> SetMediaType(This,lMediaType) ) 

#define ITLegacyCallMediaControl2_MonitorMedia(This,lMediaType)	\
    ( (This)->lpVtbl -> MonitorMedia(This,lMediaType) ) 


#define ITLegacyCallMediaControl2_GenerateDigits2(This,pDigits,DigitMode,lDuration)	\
    ( (This)->lpVtbl -> GenerateDigits2(This,pDigits,DigitMode,lDuration) ) 

#define ITLegacyCallMediaControl2_GatherDigits(This,DigitMode,lNumDigits,pTerminationDigits,lFirstDigitTimeout,lInterDigitTimeout)	\
    ( (This)->lpVtbl -> GatherDigits(This,DigitMode,lNumDigits,pTerminationDigits,lFirstDigitTimeout,lInterDigitTimeout) ) 

#define ITLegacyCallMediaControl2_DetectTones(This,pToneList,lNumTones)	\
    ( (This)->lpVtbl -> DetectTones(This,pToneList,lNumTones) ) 

#define ITLegacyCallMediaControl2_DetectTonesByCollection(This,pDetectToneCollection)	\
    ( (This)->lpVtbl -> DetectTonesByCollection(This,pDetectToneCollection) ) 

#define ITLegacyCallMediaControl2_GenerateTone(This,ToneMode,lDuration)	\
    ( (This)->lpVtbl -> GenerateTone(This,ToneMode,lDuration) ) 

#define ITLegacyCallMediaControl2_GenerateCustomTones(This,pToneList,lNumTones,lDuration)	\
    ( (This)->lpVtbl -> GenerateCustomTones(This,pToneList,lNumTones,lDuration) ) 

#define ITLegacyCallMediaControl2_GenerateCustomTonesByCollection(This,pCustomToneCollection,lDuration)	\
    ( (This)->lpVtbl -> GenerateCustomTonesByCollection(This,pCustomToneCollection,lDuration) ) 

#define ITLegacyCallMediaControl2_CreateDetectToneObject(This,ppDetectTone)	\
    ( (This)->lpVtbl -> CreateDetectToneObject(This,ppDetectTone) ) 

#define ITLegacyCallMediaControl2_CreateCustomToneObject(This,ppCustomTone)	\
    ( (This)->lpVtbl -> CreateCustomToneObject(This,ppCustomTone) ) 

#define ITLegacyCallMediaControl2_GetIDAsVariant(This,bstrDeviceClass,pVarDeviceID)	\
    ( (This)->lpVtbl -> GetIDAsVariant(This,bstrDeviceClass,pVarDeviceID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITLegacyCallMediaControl2_INTERFACE_DEFINED__ */


#ifndef __ITDetectTone_INTERFACE_DEFINED__
#define __ITDetectTone_INTERFACE_DEFINED__

/* interface ITDetectTone */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITDetectTone;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("961F79BD-3097-49df-A1D6-909B77E89CA0")
    ITDetectTone : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AppSpecific( 
            /* [retval][out] */ __RPC__out long *plAppSpecific) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AppSpecific( 
            /* [in] */ long lAppSpecific) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ __RPC__out long *plDuration) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Duration( 
            /* [in] */ long lDuration) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Frequency( 
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__out long *plFrequency) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Frequency( 
            /* [in] */ long Index,
            /* [in] */ long lFrequency) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDetectToneVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDetectTone * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDetectTone * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDetectTone * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDetectTone * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDetectTone * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDetectTone * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDetectTone * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AppSpecific )( 
            ITDetectTone * This,
            /* [retval][out] */ __RPC__out long *plAppSpecific);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AppSpecific )( 
            ITDetectTone * This,
            /* [in] */ long lAppSpecific);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            ITDetectTone * This,
            /* [retval][out] */ __RPC__out long *plDuration);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Duration )( 
            ITDetectTone * This,
            /* [in] */ long lDuration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Frequency )( 
            ITDetectTone * This,
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__out long *plFrequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Frequency )( 
            ITDetectTone * This,
            /* [in] */ long Index,
            /* [in] */ long lFrequency);
        
        END_INTERFACE
    } ITDetectToneVtbl;

    interface ITDetectTone
    {
        CONST_VTBL struct ITDetectToneVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDetectTone_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDetectTone_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDetectTone_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDetectTone_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDetectTone_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDetectTone_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDetectTone_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDetectTone_get_AppSpecific(This,plAppSpecific)	\
    ( (This)->lpVtbl -> get_AppSpecific(This,plAppSpecific) ) 

#define ITDetectTone_put_AppSpecific(This,lAppSpecific)	\
    ( (This)->lpVtbl -> put_AppSpecific(This,lAppSpecific) ) 

#define ITDetectTone_get_Duration(This,plDuration)	\
    ( (This)->lpVtbl -> get_Duration(This,plDuration) ) 

#define ITDetectTone_put_Duration(This,lDuration)	\
    ( (This)->lpVtbl -> put_Duration(This,lDuration) ) 

#define ITDetectTone_get_Frequency(This,Index,plFrequency)	\
    ( (This)->lpVtbl -> get_Frequency(This,Index,plFrequency) ) 

#define ITDetectTone_put_Frequency(This,Index,lFrequency)	\
    ( (This)->lpVtbl -> put_Frequency(This,Index,lFrequency) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDetectTone_INTERFACE_DEFINED__ */


#ifndef __ITCustomTone_INTERFACE_DEFINED__
#define __ITCustomTone_INTERFACE_DEFINED__

/* interface ITCustomTone */
/* [object][unique][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCustomTone;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("357AD764-B3C6-4b2a-8FA5-0722827A9254")
    ITCustomTone : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Frequency( 
            /* [retval][out] */ __RPC__out long *plFrequency) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Frequency( 
            /* [in] */ long lFrequency) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CadenceOn( 
            /* [retval][out] */ __RPC__out long *plCadenceOn) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CadenceOn( 
            /* [in] */ long CadenceOn) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CadenceOff( 
            /* [retval][out] */ __RPC__out long *plCadenceOff) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CadenceOff( 
            /* [in] */ long lCadenceOff) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ __RPC__out long *plVolume) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long lVolume) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCustomToneVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCustomTone * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCustomTone * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCustomTone * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCustomTone * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCustomTone * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCustomTone * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCustomTone * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Frequency )( 
            ITCustomTone * This,
            /* [retval][out] */ __RPC__out long *plFrequency);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Frequency )( 
            ITCustomTone * This,
            /* [in] */ long lFrequency);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CadenceOn )( 
            ITCustomTone * This,
            /* [retval][out] */ __RPC__out long *plCadenceOn);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CadenceOn )( 
            ITCustomTone * This,
            /* [in] */ long CadenceOn);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CadenceOff )( 
            ITCustomTone * This,
            /* [retval][out] */ __RPC__out long *plCadenceOff);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CadenceOff )( 
            ITCustomTone * This,
            /* [in] */ long lCadenceOff);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Volume )( 
            ITCustomTone * This,
            /* [retval][out] */ __RPC__out long *plVolume);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Volume )( 
            ITCustomTone * This,
            /* [in] */ long lVolume);
        
        END_INTERFACE
    } ITCustomToneVtbl;

    interface ITCustomTone
    {
        CONST_VTBL struct ITCustomToneVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCustomTone_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCustomTone_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCustomTone_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCustomTone_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCustomTone_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCustomTone_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCustomTone_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCustomTone_get_Frequency(This,plFrequency)	\
    ( (This)->lpVtbl -> get_Frequency(This,plFrequency) ) 

#define ITCustomTone_put_Frequency(This,lFrequency)	\
    ( (This)->lpVtbl -> put_Frequency(This,lFrequency) ) 

#define ITCustomTone_get_CadenceOn(This,plCadenceOn)	\
    ( (This)->lpVtbl -> get_CadenceOn(This,plCadenceOn) ) 

#define ITCustomTone_put_CadenceOn(This,CadenceOn)	\
    ( (This)->lpVtbl -> put_CadenceOn(This,CadenceOn) ) 

#define ITCustomTone_get_CadenceOff(This,plCadenceOff)	\
    ( (This)->lpVtbl -> get_CadenceOff(This,plCadenceOff) ) 

#define ITCustomTone_put_CadenceOff(This,lCadenceOff)	\
    ( (This)->lpVtbl -> put_CadenceOff(This,lCadenceOff) ) 

#define ITCustomTone_get_Volume(This,plVolume)	\
    ( (This)->lpVtbl -> get_Volume(This,plVolume) ) 

#define ITCustomTone_put_Volume(This,lVolume)	\
    ( (This)->lpVtbl -> put_Volume(This,lVolume) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCustomTone_INTERFACE_DEFINED__ */


#ifndef __IEnumPhone_INTERFACE_DEFINED__
#define __IEnumPhone_INTERFACE_DEFINED__

/* interface IEnumPhone */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumPhone;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F15B7669-4780-4595-8C89-FB369C8CF7AA")
    IEnumPhone : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITPhone **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumPhone **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPhoneVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPhone * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPhone * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPhone * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPhone * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITPhone **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPhone * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPhone * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPhone * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPhone **ppEnum);
        
        END_INTERFACE
    } IEnumPhoneVtbl;

    interface IEnumPhone
    {
        CONST_VTBL struct IEnumPhoneVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPhone_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumPhone_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumPhone_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumPhone_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumPhone_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumPhone_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumPhone_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumPhone_INTERFACE_DEFINED__ */


#ifndef __IEnumTerminal_INTERFACE_DEFINED__
#define __IEnumTerminal_INTERFACE_DEFINED__

/* interface IEnumTerminal */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumTerminal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE269CF4-935E-11d0-835C-00AA003CCABD")
    IEnumTerminal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITTerminal **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTerminalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTerminal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTerminal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTerminal * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTerminal * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITTerminal **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTerminal * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTerminal * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTerminal * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminal **ppEnum);
        
        END_INTERFACE
    } IEnumTerminalVtbl;

    interface IEnumTerminal
    {
        CONST_VTBL struct IEnumTerminalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTerminal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumTerminal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumTerminal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumTerminal_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumTerminal_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumTerminal_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumTerminal_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumTerminal_INTERFACE_DEFINED__ */


#ifndef __IEnumTerminalClass_INTERFACE_DEFINED__
#define __IEnumTerminalClass_INTERFACE_DEFINED__

/* interface IEnumTerminalClass */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumTerminalClass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE269CF5-935E-11d0-835C-00AA003CCABD")
    IEnumTerminalClass : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) GUID *pElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminalClass **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTerminalClassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTerminalClass * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTerminalClass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTerminalClass * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTerminalClass * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) GUID *pElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTerminalClass * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTerminalClass * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTerminalClass * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumTerminalClass **ppEnum);
        
        END_INTERFACE
    } IEnumTerminalClassVtbl;

    interface IEnumTerminalClass
    {
        CONST_VTBL struct IEnumTerminalClassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTerminalClass_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumTerminalClass_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumTerminalClass_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumTerminalClass_Next(This,celt,pElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,pElements,pceltFetched) ) 

#define IEnumTerminalClass_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumTerminalClass_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumTerminalClass_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumTerminalClass_INTERFACE_DEFINED__ */


#ifndef __IEnumCall_INTERFACE_DEFINED__
#define __IEnumCall_INTERFACE_DEFINED__

/* interface IEnumCall */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumCall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE269CF6-935E-11d0-835C-00AA003CCABD")
    IEnumCall : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITCallInfo **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCall * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCall * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCall * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCall * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITCallInfo **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCall * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCall * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCall * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCall **ppEnum);
        
        END_INTERFACE
    } IEnumCallVtbl;

    interface IEnumCall
    {
        CONST_VTBL struct IEnumCallVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCall_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumCall_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumCall_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumCall_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumCall_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumCall_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumCall_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumCall_INTERFACE_DEFINED__ */


#ifndef __IEnumAddress_INTERFACE_DEFINED__
#define __IEnumAddress_INTERFACE_DEFINED__

/* interface IEnumAddress */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAddress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1666FCA1-9363-11d0-835C-00AA003CCABD")
    IEnumAddress : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITAddress **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAddressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAddress * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAddress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAddress * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITAddress **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumAddress * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumAddress * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumAddress * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnum);
        
        END_INTERFACE
    } IEnumAddressVtbl;

    interface IEnumAddress
    {
        CONST_VTBL struct IEnumAddressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAddress_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumAddress_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumAddress_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumAddress_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumAddress_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumAddress_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumAddress_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumAddress_INTERFACE_DEFINED__ */


#ifndef __IEnumCallHub_INTERFACE_DEFINED__
#define __IEnumCallHub_INTERFACE_DEFINED__

/* interface IEnumCallHub */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumCallHub;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3C15450-5B92-11d1-8F4E-00C04FB6809F")
    IEnumCallHub : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITCallHub **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallHub **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCallHubVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCallHub * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCallHub * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCallHub * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCallHub * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITCallHub **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCallHub * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCallHub * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCallHub * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallHub **ppEnum);
        
        END_INTERFACE
    } IEnumCallHubVtbl;

    interface IEnumCallHub
    {
        CONST_VTBL struct IEnumCallHubVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCallHub_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumCallHub_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumCallHub_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumCallHub_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumCallHub_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumCallHub_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumCallHub_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumCallHub_INTERFACE_DEFINED__ */


#ifndef __IEnumBstr_INTERFACE_DEFINED__
#define __IEnumBstr_INTERFACE_DEFINED__

/* interface IEnumBstr */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumBstr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35372049-0BC6-11d2-A033-00C04FB6809F")
    IEnumBstr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) BSTR *ppStrings,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumBstrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumBstr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumBstr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumBstr * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumBstr * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) BSTR *ppStrings,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumBstr * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumBstr * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumBstr * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnum);
        
        END_INTERFACE
    } IEnumBstrVtbl;

    interface IEnumBstr
    {
        CONST_VTBL struct IEnumBstrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumBstr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumBstr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumBstr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumBstr_Next(This,celt,ppStrings,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppStrings,pceltFetched) ) 

#define IEnumBstr_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumBstr_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumBstr_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumBstr_INTERFACE_DEFINED__ */


#ifndef __IEnumPluggableTerminalClassInfo_INTERFACE_DEFINED__
#define __IEnumPluggableTerminalClassInfo_INTERFACE_DEFINED__

/* interface IEnumPluggableTerminalClassInfo */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumPluggableTerminalClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4567450C-DBEE-4e3f-AAF5-37BF9EBF5E29")
    IEnumPluggableTerminalClassInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITPluggableTerminalClassInfo **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumPluggableTerminalClassInfo **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPluggableTerminalClassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPluggableTerminalClassInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPluggableTerminalClassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPluggableTerminalClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPluggableTerminalClassInfo * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITPluggableTerminalClassInfo **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPluggableTerminalClassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPluggableTerminalClassInfo * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPluggableTerminalClassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPluggableTerminalClassInfo **ppEnum);
        
        END_INTERFACE
    } IEnumPluggableTerminalClassInfoVtbl;

    interface IEnumPluggableTerminalClassInfo
    {
        CONST_VTBL struct IEnumPluggableTerminalClassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPluggableTerminalClassInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumPluggableTerminalClassInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumPluggableTerminalClassInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumPluggableTerminalClassInfo_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumPluggableTerminalClassInfo_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumPluggableTerminalClassInfo_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumPluggableTerminalClassInfo_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumPluggableTerminalClassInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumPluggableSuperclassInfo_INTERFACE_DEFINED__
#define __IEnumPluggableSuperclassInfo_INTERFACE_DEFINED__

/* interface IEnumPluggableSuperclassInfo */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumPluggableSuperclassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E9586A80-89E6-4cff-931D-478D5751F4C0")
    IEnumPluggableSuperclassInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITPluggableTerminalSuperclassInfo **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumPluggableSuperclassInfo **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPluggableSuperclassInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPluggableSuperclassInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPluggableSuperclassInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPluggableSuperclassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPluggableSuperclassInfo * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ __RPC__out_ecount_full(celt) ITPluggableTerminalSuperclassInfo **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPluggableSuperclassInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPluggableSuperclassInfo * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumPluggableSuperclassInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumPluggableSuperclassInfo **ppEnum);
        
        END_INTERFACE
    } IEnumPluggableSuperclassInfoVtbl;

    interface IEnumPluggableSuperclassInfo
    {
        CONST_VTBL struct IEnumPluggableSuperclassInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPluggableSuperclassInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumPluggableSuperclassInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumPluggableSuperclassInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumPluggableSuperclassInfo_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumPluggableSuperclassInfo_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumPluggableSuperclassInfo_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumPluggableSuperclassInfo_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumPluggableSuperclassInfo_INTERFACE_DEFINED__ */


#ifndef __ITPhoneEvent_INTERFACE_DEFINED__
#define __ITPhoneEvent_INTERFACE_DEFINED__

/* interface ITPhoneEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPhoneEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8F942DD8-64ED-4aaf-A77D-B23DB0837EAD")
    ITPhoneEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Phone( 
            /* [retval][out] */ __RPC__deref_out_opt ITPhone **ppPhone) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out PHONE_EVENT *pEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonState( 
            /* [retval][out] */ __RPC__out PHONE_BUTTON_STATE *pState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HookSwitchState( 
            /* [retval][out] */ __RPC__out PHONE_HOOK_SWITCH_STATE *pState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HookSwitchDevice( 
            /* [retval][out] */ __RPC__out PHONE_HOOK_SWITCH_DEVICE *pDevice) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RingMode( 
            /* [retval][out] */ __RPC__out long *plRingMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ButtonLampId( 
            /* [retval][out] */ __RPC__out long *plButtonLampId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberGathered( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPhoneEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITPhoneEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITPhoneEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITPhoneEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITPhoneEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITPhoneEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITPhoneEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITPhoneEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Phone )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITPhone **ppPhone);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__out PHONE_EVENT *pEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonState )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__out PHONE_BUTTON_STATE *pState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HookSwitchState )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__out PHONE_HOOK_SWITCH_STATE *pState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HookSwitchDevice )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__out PHONE_HOOK_SWITCH_DEVICE *pDevice);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RingMode )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__out long *plRingMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ButtonLampId )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__out long *plButtonLampId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberGathered )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITPhoneEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo);
        
        END_INTERFACE
    } ITPhoneEventVtbl;

    interface ITPhoneEvent
    {
        CONST_VTBL struct ITPhoneEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPhoneEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITPhoneEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITPhoneEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITPhoneEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITPhoneEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITPhoneEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITPhoneEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITPhoneEvent_get_Phone(This,ppPhone)	\
    ( (This)->lpVtbl -> get_Phone(This,ppPhone) ) 

#define ITPhoneEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#define ITPhoneEvent_get_ButtonState(This,pState)	\
    ( (This)->lpVtbl -> get_ButtonState(This,pState) ) 

#define ITPhoneEvent_get_HookSwitchState(This,pState)	\
    ( (This)->lpVtbl -> get_HookSwitchState(This,pState) ) 

#define ITPhoneEvent_get_HookSwitchDevice(This,pDevice)	\
    ( (This)->lpVtbl -> get_HookSwitchDevice(This,pDevice) ) 

#define ITPhoneEvent_get_RingMode(This,plRingMode)	\
    ( (This)->lpVtbl -> get_RingMode(This,plRingMode) ) 

#define ITPhoneEvent_get_ButtonLampId(This,plButtonLampId)	\
    ( (This)->lpVtbl -> get_ButtonLampId(This,plButtonLampId) ) 

#define ITPhoneEvent_get_NumberGathered(This,ppNumber)	\
    ( (This)->lpVtbl -> get_NumberGathered(This,ppNumber) ) 

#define ITPhoneEvent_get_Call(This,ppCallInfo)	\
    ( (This)->lpVtbl -> get_Call(This,ppCallInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITPhoneEvent_INTERFACE_DEFINED__ */


#ifndef __ITCallStateEvent_INTERFACE_DEFINED__
#define __ITCallStateEvent_INTERFACE_DEFINED__

/* interface ITCallStateEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallStateEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62F47097-95C9-11d0-835D-00AA003CCABD")
    ITCallStateEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out CALL_STATE *pCallState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cause( 
            /* [retval][out] */ __RPC__out CALL_STATE_EVENT_CAUSE *pCEC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ __RPC__out long *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallStateEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallStateEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallStateEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallStateEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallStateEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallStateEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallStateEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallStateEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITCallStateEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITCallStateEvent * This,
            /* [retval][out] */ __RPC__out CALL_STATE *pCallState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cause )( 
            ITCallStateEvent * This,
            /* [retval][out] */ __RPC__out CALL_STATE_EVENT_CAUSE *pCEC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITCallStateEvent * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        END_INTERFACE
    } ITCallStateEventVtbl;

    interface ITCallStateEvent
    {
        CONST_VTBL struct ITCallStateEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallStateEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallStateEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallStateEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallStateEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallStateEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallStateEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallStateEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallStateEvent_get_Call(This,ppCallInfo)	\
    ( (This)->lpVtbl -> get_Call(This,ppCallInfo) ) 

#define ITCallStateEvent_get_State(This,pCallState)	\
    ( (This)->lpVtbl -> get_State(This,pCallState) ) 

#define ITCallStateEvent_get_Cause(This,pCEC)	\
    ( (This)->lpVtbl -> get_Cause(This,pCEC) ) 

#define ITCallStateEvent_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallStateEvent_INTERFACE_DEFINED__ */


#ifndef __ITPhoneDeviceSpecificEvent_INTERFACE_DEFINED__
#define __ITPhoneDeviceSpecificEvent_INTERFACE_DEFINED__

/* interface ITPhoneDeviceSpecificEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITPhoneDeviceSpecificEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63FFB2A6-872B-4cd3-A501-326E8FB40AF7")
    ITPhoneDeviceSpecificEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Phone( 
            /* [retval][out] */ __RPC__deref_out_opt ITPhone **ppPhone) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lParam1( 
            /* [retval][out] */ __RPC__out long *pParam1) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lParam2( 
            /* [retval][out] */ __RPC__out long *pParam2) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lParam3( 
            /* [retval][out] */ __RPC__out long *pParam3) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITPhoneDeviceSpecificEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITPhoneDeviceSpecificEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITPhoneDeviceSpecificEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Phone )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITPhone **ppPhone);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lParam1 )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__out long *pParam1);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lParam2 )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__out long *pParam2);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lParam3 )( 
            ITPhoneDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__out long *pParam3);
        
        END_INTERFACE
    } ITPhoneDeviceSpecificEventVtbl;

    interface ITPhoneDeviceSpecificEvent
    {
        CONST_VTBL struct ITPhoneDeviceSpecificEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITPhoneDeviceSpecificEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITPhoneDeviceSpecificEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITPhoneDeviceSpecificEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITPhoneDeviceSpecificEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITPhoneDeviceSpecificEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITPhoneDeviceSpecificEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITPhoneDeviceSpecificEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITPhoneDeviceSpecificEvent_get_Phone(This,ppPhone)	\
    ( (This)->lpVtbl -> get_Phone(This,ppPhone) ) 

#define ITPhoneDeviceSpecificEvent_get_lParam1(This,pParam1)	\
    ( (This)->lpVtbl -> get_lParam1(This,pParam1) ) 

#define ITPhoneDeviceSpecificEvent_get_lParam2(This,pParam2)	\
    ( (This)->lpVtbl -> get_lParam2(This,pParam2) ) 

#define ITPhoneDeviceSpecificEvent_get_lParam3(This,pParam3)	\
    ( (This)->lpVtbl -> get_lParam3(This,pParam3) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITPhoneDeviceSpecificEvent_INTERFACE_DEFINED__ */


#ifndef __ITCallMediaEvent_INTERFACE_DEFINED__
#define __ITCallMediaEvent_INTERFACE_DEFINED__

/* interface ITCallMediaEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallMediaEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FF36B87F-EC3A-11d0-8EE4-00C04FB6809F")
    ITCallMediaEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out CALL_MEDIA_EVENT *pCallMediaEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ __RPC__out HRESULT *phrError) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminal( 
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Stream( 
            /* [retval][out] */ __RPC__deref_out_opt ITStream **ppStream) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cause( 
            /* [retval][out] */ __RPC__out CALL_MEDIA_EVENT_CAUSE *pCause) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallMediaEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallMediaEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallMediaEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallMediaEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallMediaEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallMediaEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallMediaEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallMediaEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITCallMediaEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITCallMediaEvent * This,
            /* [retval][out] */ __RPC__out CALL_MEDIA_EVENT *pCallMediaEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            ITCallMediaEvent * This,
            /* [retval][out] */ __RPC__out HRESULT *phrError);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminal )( 
            ITCallMediaEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Stream )( 
            ITCallMediaEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITStream **ppStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cause )( 
            ITCallMediaEvent * This,
            /* [retval][out] */ __RPC__out CALL_MEDIA_EVENT_CAUSE *pCause);
        
        END_INTERFACE
    } ITCallMediaEventVtbl;

    interface ITCallMediaEvent
    {
        CONST_VTBL struct ITCallMediaEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallMediaEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallMediaEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallMediaEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallMediaEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallMediaEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallMediaEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallMediaEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallMediaEvent_get_Call(This,ppCallInfo)	\
    ( (This)->lpVtbl -> get_Call(This,ppCallInfo) ) 

#define ITCallMediaEvent_get_Event(This,pCallMediaEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pCallMediaEvent) ) 

#define ITCallMediaEvent_get_Error(This,phrError)	\
    ( (This)->lpVtbl -> get_Error(This,phrError) ) 

#define ITCallMediaEvent_get_Terminal(This,ppTerminal)	\
    ( (This)->lpVtbl -> get_Terminal(This,ppTerminal) ) 

#define ITCallMediaEvent_get_Stream(This,ppStream)	\
    ( (This)->lpVtbl -> get_Stream(This,ppStream) ) 

#define ITCallMediaEvent_get_Cause(This,pCause)	\
    ( (This)->lpVtbl -> get_Cause(This,pCause) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallMediaEvent_INTERFACE_DEFINED__ */


#ifndef __ITDigitDetectionEvent_INTERFACE_DEFINED__
#define __ITDigitDetectionEvent_INTERFACE_DEFINED__

/* interface ITDigitDetectionEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITDigitDetectionEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80D3BFAC-57D9-11d2-A04A-00C04FB6809F")
    ITDigitDetectionEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Digit( 
            /* [retval][out] */ __RPC__out unsigned char *pucDigit) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DigitMode( 
            /* [retval][out] */ __RPC__out TAPI_DIGITMODE *pDigitMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TickCount( 
            /* [retval][out] */ __RPC__out long *plTickCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ __RPC__out long *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDigitDetectionEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDigitDetectionEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDigitDetectionEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDigitDetectionEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDigitDetectionEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDigitDetectionEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDigitDetectionEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDigitDetectionEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITDigitDetectionEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Digit )( 
            ITDigitDetectionEvent * This,
            /* [retval][out] */ __RPC__out unsigned char *pucDigit);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DigitMode )( 
            ITDigitDetectionEvent * This,
            /* [retval][out] */ __RPC__out TAPI_DIGITMODE *pDigitMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TickCount )( 
            ITDigitDetectionEvent * This,
            /* [retval][out] */ __RPC__out long *plTickCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITDigitDetectionEvent * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        END_INTERFACE
    } ITDigitDetectionEventVtbl;

    interface ITDigitDetectionEvent
    {
        CONST_VTBL struct ITDigitDetectionEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDigitDetectionEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDigitDetectionEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDigitDetectionEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDigitDetectionEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDigitDetectionEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDigitDetectionEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDigitDetectionEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDigitDetectionEvent_get_Call(This,ppCallInfo)	\
    ( (This)->lpVtbl -> get_Call(This,ppCallInfo) ) 

#define ITDigitDetectionEvent_get_Digit(This,pucDigit)	\
    ( (This)->lpVtbl -> get_Digit(This,pucDigit) ) 

#define ITDigitDetectionEvent_get_DigitMode(This,pDigitMode)	\
    ( (This)->lpVtbl -> get_DigitMode(This,pDigitMode) ) 

#define ITDigitDetectionEvent_get_TickCount(This,plTickCount)	\
    ( (This)->lpVtbl -> get_TickCount(This,plTickCount) ) 

#define ITDigitDetectionEvent_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDigitDetectionEvent_INTERFACE_DEFINED__ */


#ifndef __ITDigitGenerationEvent_INTERFACE_DEFINED__
#define __ITDigitGenerationEvent_INTERFACE_DEFINED__

/* interface ITDigitGenerationEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITDigitGenerationEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80D3BFAD-57D9-11d2-A04A-00C04FB6809F")
    ITDigitGenerationEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GenerationTermination( 
            /* [retval][out] */ __RPC__out long *plGenerationTermination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TickCount( 
            /* [retval][out] */ __RPC__out long *plTickCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ __RPC__out long *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDigitGenerationEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDigitGenerationEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDigitGenerationEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDigitGenerationEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDigitGenerationEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDigitGenerationEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDigitGenerationEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDigitGenerationEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITDigitGenerationEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GenerationTermination )( 
            ITDigitGenerationEvent * This,
            /* [retval][out] */ __RPC__out long *plGenerationTermination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TickCount )( 
            ITDigitGenerationEvent * This,
            /* [retval][out] */ __RPC__out long *plTickCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITDigitGenerationEvent * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        END_INTERFACE
    } ITDigitGenerationEventVtbl;

    interface ITDigitGenerationEvent
    {
        CONST_VTBL struct ITDigitGenerationEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDigitGenerationEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDigitGenerationEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDigitGenerationEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDigitGenerationEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDigitGenerationEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDigitGenerationEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDigitGenerationEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDigitGenerationEvent_get_Call(This,ppCallInfo)	\
    ( (This)->lpVtbl -> get_Call(This,ppCallInfo) ) 

#define ITDigitGenerationEvent_get_GenerationTermination(This,plGenerationTermination)	\
    ( (This)->lpVtbl -> get_GenerationTermination(This,plGenerationTermination) ) 

#define ITDigitGenerationEvent_get_TickCount(This,plTickCount)	\
    ( (This)->lpVtbl -> get_TickCount(This,plTickCount) ) 

#define ITDigitGenerationEvent_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDigitGenerationEvent_INTERFACE_DEFINED__ */


#ifndef __ITDigitsGatheredEvent_INTERFACE_DEFINED__
#define __ITDigitsGatheredEvent_INTERFACE_DEFINED__

/* interface ITDigitsGatheredEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITDigitsGatheredEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E52EC4C1-CBA3-441a-9E6A-93CB909E9724")
    ITDigitsGatheredEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Digits( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDigits) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GatherTermination( 
            /* [retval][out] */ __RPC__out TAPI_GATHERTERM *pGatherTermination) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TickCount( 
            /* [retval][out] */ __RPC__out long *plTickCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ __RPC__out long *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDigitsGatheredEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDigitsGatheredEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDigitsGatheredEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDigitsGatheredEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDigitsGatheredEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDigitsGatheredEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDigitsGatheredEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDigitsGatheredEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITDigitsGatheredEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Digits )( 
            ITDigitsGatheredEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDigits);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GatherTermination )( 
            ITDigitsGatheredEvent * This,
            /* [retval][out] */ __RPC__out TAPI_GATHERTERM *pGatherTermination);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TickCount )( 
            ITDigitsGatheredEvent * This,
            /* [retval][out] */ __RPC__out long *plTickCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITDigitsGatheredEvent * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        END_INTERFACE
    } ITDigitsGatheredEventVtbl;

    interface ITDigitsGatheredEvent
    {
        CONST_VTBL struct ITDigitsGatheredEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDigitsGatheredEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDigitsGatheredEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDigitsGatheredEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDigitsGatheredEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDigitsGatheredEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDigitsGatheredEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDigitsGatheredEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDigitsGatheredEvent_get_Call(This,ppCallInfo)	\
    ( (This)->lpVtbl -> get_Call(This,ppCallInfo) ) 

#define ITDigitsGatheredEvent_get_Digits(This,ppDigits)	\
    ( (This)->lpVtbl -> get_Digits(This,ppDigits) ) 

#define ITDigitsGatheredEvent_get_GatherTermination(This,pGatherTermination)	\
    ( (This)->lpVtbl -> get_GatherTermination(This,pGatherTermination) ) 

#define ITDigitsGatheredEvent_get_TickCount(This,plTickCount)	\
    ( (This)->lpVtbl -> get_TickCount(This,plTickCount) ) 

#define ITDigitsGatheredEvent_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDigitsGatheredEvent_INTERFACE_DEFINED__ */


#ifndef __ITToneDetectionEvent_INTERFACE_DEFINED__
#define __ITToneDetectionEvent_INTERFACE_DEFINED__

/* interface ITToneDetectionEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITToneDetectionEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("407E0FAF-D047-4753-B0C6-8E060373FECD")
    ITToneDetectionEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AppSpecific( 
            /* [retval][out] */ __RPC__out long *plAppSpecific) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TickCount( 
            /* [retval][out] */ __RPC__out long *plTickCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ __RPC__out long *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITToneDetectionEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITToneDetectionEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITToneDetectionEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITToneDetectionEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITToneDetectionEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITToneDetectionEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITToneDetectionEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITToneDetectionEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITToneDetectionEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCallInfo);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AppSpecific )( 
            ITToneDetectionEvent * This,
            /* [retval][out] */ __RPC__out long *plAppSpecific);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TickCount )( 
            ITToneDetectionEvent * This,
            /* [retval][out] */ __RPC__out long *plTickCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITToneDetectionEvent * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        END_INTERFACE
    } ITToneDetectionEventVtbl;

    interface ITToneDetectionEvent
    {
        CONST_VTBL struct ITToneDetectionEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITToneDetectionEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITToneDetectionEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITToneDetectionEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITToneDetectionEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITToneDetectionEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITToneDetectionEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITToneDetectionEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITToneDetectionEvent_get_Call(This,ppCallInfo)	\
    ( (This)->lpVtbl -> get_Call(This,ppCallInfo) ) 

#define ITToneDetectionEvent_get_AppSpecific(This,plAppSpecific)	\
    ( (This)->lpVtbl -> get_AppSpecific(This,plAppSpecific) ) 

#define ITToneDetectionEvent_get_TickCount(This,plTickCount)	\
    ( (This)->lpVtbl -> get_TickCount(This,plTickCount) ) 

#define ITToneDetectionEvent_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITToneDetectionEvent_INTERFACE_DEFINED__ */


#ifndef __ITTAPIObjectEvent_INTERFACE_DEFINED__
#define __ITTAPIObjectEvent_INTERFACE_DEFINED__

/* interface ITTAPIObjectEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPIObjectEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4854D48-937A-11d1-BB58-00C04FB6809F")
    ITTAPIObjectEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TAPIObject( 
            /* [retval][out] */ __RPC__deref_out_opt ITTAPI **ppTAPIObject) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out TAPIOBJECT_EVENT *pEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ __RPC__out long *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPIObjectEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTAPIObjectEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTAPIObjectEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTAPIObjectEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTAPIObjectEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTAPIObjectEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTAPIObjectEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTAPIObjectEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TAPIObject )( 
            ITTAPIObjectEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTAPI **ppTAPIObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITTAPIObjectEvent * This,
            /* [retval][out] */ __RPC__out TAPIOBJECT_EVENT *pEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITTAPIObjectEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITTAPIObjectEvent * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        END_INTERFACE
    } ITTAPIObjectEventVtbl;

    interface ITTAPIObjectEvent
    {
        CONST_VTBL struct ITTAPIObjectEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPIObjectEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTAPIObjectEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTAPIObjectEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTAPIObjectEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTAPIObjectEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTAPIObjectEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTAPIObjectEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTAPIObjectEvent_get_TAPIObject(This,ppTAPIObject)	\
    ( (This)->lpVtbl -> get_TAPIObject(This,ppTAPIObject) ) 

#define ITTAPIObjectEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#define ITTAPIObjectEvent_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITTAPIObjectEvent_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTAPIObjectEvent_INTERFACE_DEFINED__ */


#ifndef __ITTAPIObjectEvent2_INTERFACE_DEFINED__
#define __ITTAPIObjectEvent2_INTERFACE_DEFINED__

/* interface ITTAPIObjectEvent2 */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPIObjectEvent2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("359DDA6E-68CE-4383-BF0B-169133C41B46")
    ITTAPIObjectEvent2 : public ITTAPIObjectEvent
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Phone( 
            /* [retval][out] */ __RPC__deref_out_opt ITPhone **ppPhone) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPIObjectEvent2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTAPIObjectEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTAPIObjectEvent2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTAPIObjectEvent2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTAPIObjectEvent2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTAPIObjectEvent2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTAPIObjectEvent2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTAPIObjectEvent2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TAPIObject )( 
            ITTAPIObjectEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTAPI **ppTAPIObject);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITTAPIObjectEvent2 * This,
            /* [retval][out] */ __RPC__out TAPIOBJECT_EVENT *pEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITTAPIObjectEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITTAPIObjectEvent2 * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Phone )( 
            ITTAPIObjectEvent2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ITPhone **ppPhone);
        
        END_INTERFACE
    } ITTAPIObjectEvent2Vtbl;

    interface ITTAPIObjectEvent2
    {
        CONST_VTBL struct ITTAPIObjectEvent2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPIObjectEvent2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTAPIObjectEvent2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTAPIObjectEvent2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTAPIObjectEvent2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTAPIObjectEvent2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTAPIObjectEvent2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTAPIObjectEvent2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTAPIObjectEvent2_get_TAPIObject(This,ppTAPIObject)	\
    ( (This)->lpVtbl -> get_TAPIObject(This,ppTAPIObject) ) 

#define ITTAPIObjectEvent2_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#define ITTAPIObjectEvent2_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITTAPIObjectEvent2_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 


#define ITTAPIObjectEvent2_get_Phone(This,ppPhone)	\
    ( (This)->lpVtbl -> get_Phone(This,ppPhone) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTAPIObjectEvent2_INTERFACE_DEFINED__ */


#ifndef __ITTAPIEventNotification_INTERFACE_DEFINED__
#define __ITTAPIEventNotification_INTERFACE_DEFINED__

/* interface ITTAPIEventNotification */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPIEventNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EDDB9426-3B91-11d1-8F30-00C04FB6809F")
    ITTAPIEventNotification : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Event( 
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ __RPC__in_opt IDispatch *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPIEventNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTAPIEventNotification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTAPIEventNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTAPIEventNotification * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Event )( 
            ITTAPIEventNotification * This,
            /* [in] */ TAPI_EVENT TapiEvent,
            /* [in] */ __RPC__in_opt IDispatch *pEvent);
        
        END_INTERFACE
    } ITTAPIEventNotificationVtbl;

    interface ITTAPIEventNotification
    {
        CONST_VTBL struct ITTAPIEventNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPIEventNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTAPIEventNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTAPIEventNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTAPIEventNotification_Event(This,TapiEvent,pEvent)	\
    ( (This)->lpVtbl -> Event(This,TapiEvent,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTAPIEventNotification_INTERFACE_DEFINED__ */


#ifndef __ITCallHubEvent_INTERFACE_DEFINED__
#define __ITCallHubEvent_INTERFACE_DEFINED__

/* interface ITCallHubEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallHubEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A3C15451-5B92-11d1-8F4E-00C04FB6809F")
    ITCallHubEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out CALLHUB_EVENT *pEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallHub( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallHub **ppCallHub) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallHubEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallHubEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallHubEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallHubEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallHubEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallHubEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallHubEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallHubEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITCallHubEvent * This,
            /* [retval][out] */ __RPC__out CALLHUB_EVENT *pEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallHub )( 
            ITCallHubEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallHub **ppCallHub);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITCallHubEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        END_INTERFACE
    } ITCallHubEventVtbl;

    interface ITCallHubEvent
    {
        CONST_VTBL struct ITCallHubEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallHubEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallHubEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallHubEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallHubEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallHubEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallHubEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallHubEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallHubEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#define ITCallHubEvent_get_CallHub(This,ppCallHub)	\
    ( (This)->lpVtbl -> get_CallHub(This,ppCallHub) ) 

#define ITCallHubEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallHubEvent_INTERFACE_DEFINED__ */


#ifndef __ITAddressEvent_INTERFACE_DEFINED__
#define __ITAddressEvent_INTERFACE_DEFINED__

/* interface ITAddressEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("831CE2D1-83B5-11d1-BB5C-00C04FB6809F")
    ITAddressEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out ADDRESS_EVENT *pEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminal( 
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAddressEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAddressEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAddressEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAddressEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAddressEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAddressEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAddressEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITAddressEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITAddressEvent * This,
            /* [retval][out] */ __RPC__out ADDRESS_EVENT *pEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminal )( 
            ITAddressEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        END_INTERFACE
    } ITAddressEventVtbl;

    interface ITAddressEvent
    {
        CONST_VTBL struct ITAddressEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAddressEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAddressEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAddressEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAddressEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAddressEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAddressEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAddressEvent_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITAddressEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#define ITAddressEvent_get_Terminal(This,ppTerminal)	\
    ( (This)->lpVtbl -> get_Terminal(This,ppTerminal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAddressEvent_INTERFACE_DEFINED__ */


#ifndef __ITAddressDeviceSpecificEvent_INTERFACE_DEFINED__
#define __ITAddressDeviceSpecificEvent_INTERFACE_DEFINED__

/* interface ITAddressDeviceSpecificEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressDeviceSpecificEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3ACB216B-40BD-487a-8672-5CE77BD7E3A3")
    ITAddressDeviceSpecificEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lParam1( 
            /* [retval][out] */ __RPC__out long *pParam1) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lParam2( 
            /* [retval][out] */ __RPC__out long *pParam2) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_lParam3( 
            /* [retval][out] */ __RPC__out long *pParam3) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressDeviceSpecificEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAddressDeviceSpecificEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAddressDeviceSpecificEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAddressDeviceSpecificEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAddressDeviceSpecificEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAddressDeviceSpecificEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAddressDeviceSpecificEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAddressDeviceSpecificEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITAddressDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITAddressDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lParam1 )( 
            ITAddressDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__out long *pParam1);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lParam2 )( 
            ITAddressDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__out long *pParam2);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_lParam3 )( 
            ITAddressDeviceSpecificEvent * This,
            /* [retval][out] */ __RPC__out long *pParam3);
        
        END_INTERFACE
    } ITAddressDeviceSpecificEventVtbl;

    interface ITAddressDeviceSpecificEvent
    {
        CONST_VTBL struct ITAddressDeviceSpecificEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressDeviceSpecificEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAddressDeviceSpecificEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAddressDeviceSpecificEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAddressDeviceSpecificEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAddressDeviceSpecificEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAddressDeviceSpecificEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAddressDeviceSpecificEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAddressDeviceSpecificEvent_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITAddressDeviceSpecificEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#define ITAddressDeviceSpecificEvent_get_lParam1(This,pParam1)	\
    ( (This)->lpVtbl -> get_lParam1(This,pParam1) ) 

#define ITAddressDeviceSpecificEvent_get_lParam2(This,pParam2)	\
    ( (This)->lpVtbl -> get_lParam2(This,pParam2) ) 

#define ITAddressDeviceSpecificEvent_get_lParam3(This,pParam3)	\
    ( (This)->lpVtbl -> get_lParam3(This,pParam3) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAddressDeviceSpecificEvent_INTERFACE_DEFINED__ */


#ifndef __ITFileTerminalEvent_INTERFACE_DEFINED__
#define __ITFileTerminalEvent_INTERFACE_DEFINED__

/* interface ITFileTerminalEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITFileTerminalEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4A7FBAC-8C17-4427-9F55-9F589AC8AF00")
    ITFileTerminalEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminal( 
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Track( 
            /* [retval][out] */ __RPC__deref_out_opt ITFileTrack **ppTrackTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out TERMINAL_MEDIA_STATE *pState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cause( 
            /* [retval][out] */ __RPC__out FT_STATE_EVENT_CAUSE *pCause) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ __RPC__out HRESULT *phrErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITFileTerminalEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITFileTerminalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITFileTerminalEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITFileTerminalEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITFileTerminalEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITFileTerminalEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITFileTerminalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITFileTerminalEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminal )( 
            ITFileTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Track )( 
            ITFileTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITFileTrack **ppTrackTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITFileTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITFileTerminalEvent * This,
            /* [retval][out] */ __RPC__out TERMINAL_MEDIA_STATE *pState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cause )( 
            ITFileTerminalEvent * This,
            /* [retval][out] */ __RPC__out FT_STATE_EVENT_CAUSE *pCause);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            ITFileTerminalEvent * This,
            /* [retval][out] */ __RPC__out HRESULT *phrErrorCode);
        
        END_INTERFACE
    } ITFileTerminalEventVtbl;

    interface ITFileTerminalEvent
    {
        CONST_VTBL struct ITFileTerminalEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITFileTerminalEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITFileTerminalEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITFileTerminalEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITFileTerminalEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITFileTerminalEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITFileTerminalEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITFileTerminalEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITFileTerminalEvent_get_Terminal(This,ppTerminal)	\
    ( (This)->lpVtbl -> get_Terminal(This,ppTerminal) ) 

#define ITFileTerminalEvent_get_Track(This,ppTrackTerminal)	\
    ( (This)->lpVtbl -> get_Track(This,ppTrackTerminal) ) 

#define ITFileTerminalEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#define ITFileTerminalEvent_get_State(This,pState)	\
    ( (This)->lpVtbl -> get_State(This,pState) ) 

#define ITFileTerminalEvent_get_Cause(This,pCause)	\
    ( (This)->lpVtbl -> get_Cause(This,pCause) ) 

#define ITFileTerminalEvent_get_Error(This,phrErrorCode)	\
    ( (This)->lpVtbl -> get_Error(This,phrErrorCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITFileTerminalEvent_INTERFACE_DEFINED__ */


#ifndef __ITTTSTerminalEvent_INTERFACE_DEFINED__
#define __ITTTSTerminalEvent_INTERFACE_DEFINED__

/* interface ITTTSTerminalEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTTSTerminalEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D964788F-95A5-461d-AB0C-B9900A6C2713")
    ITTTSTerminalEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminal( 
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ __RPC__out HRESULT *phrErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTTSTerminalEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTTSTerminalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTTSTerminalEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTTSTerminalEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTTSTerminalEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTTSTerminalEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTTSTerminalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTTSTerminalEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminal )( 
            ITTTSTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITTTSTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            ITTTSTerminalEvent * This,
            /* [retval][out] */ __RPC__out HRESULT *phrErrorCode);
        
        END_INTERFACE
    } ITTTSTerminalEventVtbl;

    interface ITTTSTerminalEvent
    {
        CONST_VTBL struct ITTTSTerminalEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTTSTerminalEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTTSTerminalEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTTSTerminalEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTTSTerminalEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTTSTerminalEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTTSTerminalEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTTSTerminalEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTTSTerminalEvent_get_Terminal(This,ppTerminal)	\
    ( (This)->lpVtbl -> get_Terminal(This,ppTerminal) ) 

#define ITTTSTerminalEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#define ITTTSTerminalEvent_get_Error(This,phrErrorCode)	\
    ( (This)->lpVtbl -> get_Error(This,phrErrorCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTTSTerminalEvent_INTERFACE_DEFINED__ */


#ifndef __ITASRTerminalEvent_INTERFACE_DEFINED__
#define __ITASRTerminalEvent_INTERFACE_DEFINED__

/* interface ITASRTerminalEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITASRTerminalEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE016A02-4FA9-467c-933F-5A15B12377D7")
    ITASRTerminalEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminal( 
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ __RPC__out HRESULT *phrErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITASRTerminalEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITASRTerminalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITASRTerminalEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITASRTerminalEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITASRTerminalEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITASRTerminalEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITASRTerminalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITASRTerminalEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminal )( 
            ITASRTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITASRTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            ITASRTerminalEvent * This,
            /* [retval][out] */ __RPC__out HRESULT *phrErrorCode);
        
        END_INTERFACE
    } ITASRTerminalEventVtbl;

    interface ITASRTerminalEvent
    {
        CONST_VTBL struct ITASRTerminalEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITASRTerminalEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITASRTerminalEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITASRTerminalEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITASRTerminalEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITASRTerminalEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITASRTerminalEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITASRTerminalEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITASRTerminalEvent_get_Terminal(This,ppTerminal)	\
    ( (This)->lpVtbl -> get_Terminal(This,ppTerminal) ) 

#define ITASRTerminalEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#define ITASRTerminalEvent_get_Error(This,phrErrorCode)	\
    ( (This)->lpVtbl -> get_Error(This,phrErrorCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITASRTerminalEvent_INTERFACE_DEFINED__ */


#ifndef __ITToneTerminalEvent_INTERFACE_DEFINED__
#define __ITToneTerminalEvent_INTERFACE_DEFINED__

/* interface ITToneTerminalEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITToneTerminalEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E6F56009-611F-4945-BBD2-2D0CE5612056")
    ITToneTerminalEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminal( 
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ __RPC__out HRESULT *phrErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITToneTerminalEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITToneTerminalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITToneTerminalEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITToneTerminalEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITToneTerminalEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITToneTerminalEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITToneTerminalEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITToneTerminalEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminal )( 
            ITToneTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITToneTerminalEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            ITToneTerminalEvent * This,
            /* [retval][out] */ __RPC__out HRESULT *phrErrorCode);
        
        END_INTERFACE
    } ITToneTerminalEventVtbl;

    interface ITToneTerminalEvent
    {
        CONST_VTBL struct ITToneTerminalEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITToneTerminalEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITToneTerminalEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITToneTerminalEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITToneTerminalEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITToneTerminalEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITToneTerminalEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITToneTerminalEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITToneTerminalEvent_get_Terminal(This,ppTerminal)	\
    ( (This)->lpVtbl -> get_Terminal(This,ppTerminal) ) 

#define ITToneTerminalEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#define ITToneTerminalEvent_get_Error(This,phrErrorCode)	\
    ( (This)->lpVtbl -> get_Error(This,phrErrorCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITToneTerminalEvent_INTERFACE_DEFINED__ */


#ifndef __ITQOSEvent_INTERFACE_DEFINED__
#define __ITQOSEvent_INTERFACE_DEFINED__

/* interface ITQOSEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITQOSEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CFA3357C-AD77-11d1-BB68-00C04FB6809F")
    ITQOSEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out QOS_EVENT *pQosEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ __RPC__out long *plMediaType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITQOSEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITQOSEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITQOSEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITQOSEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITQOSEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITQOSEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITQOSEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITQOSEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITQOSEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITQOSEvent * This,
            /* [retval][out] */ __RPC__out QOS_EVENT *pQosEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            ITQOSEvent * This,
            /* [retval][out] */ __RPC__out long *plMediaType);
        
        END_INTERFACE
    } ITQOSEventVtbl;

    interface ITQOSEvent
    {
        CONST_VTBL struct ITQOSEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITQOSEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITQOSEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITQOSEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITQOSEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITQOSEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITQOSEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITQOSEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITQOSEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#define ITQOSEvent_get_Event(This,pQosEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pQosEvent) ) 

#define ITQOSEvent_get_MediaType(This,plMediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,plMediaType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITQOSEvent_INTERFACE_DEFINED__ */


#ifndef __ITCallInfoChangeEvent_INTERFACE_DEFINED__
#define __ITCallInfoChangeEvent_INTERFACE_DEFINED__

/* interface ITCallInfoChangeEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallInfoChangeEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5D4B65F9-E51C-11d1-A02F-00C04FB6809F")
    ITCallInfoChangeEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Cause( 
            /* [retval][out] */ __RPC__out CALLINFOCHANGE_CAUSE *pCIC) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ __RPC__out long *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallInfoChangeEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallInfoChangeEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallInfoChangeEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallInfoChangeEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallInfoChangeEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallInfoChangeEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallInfoChangeEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallInfoChangeEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITCallInfoChangeEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Cause )( 
            ITCallInfoChangeEvent * This,
            /* [retval][out] */ __RPC__out CALLINFOCHANGE_CAUSE *pCIC);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITCallInfoChangeEvent * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        END_INTERFACE
    } ITCallInfoChangeEventVtbl;

    interface ITCallInfoChangeEvent
    {
        CONST_VTBL struct ITCallInfoChangeEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallInfoChangeEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallInfoChangeEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallInfoChangeEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallInfoChangeEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallInfoChangeEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallInfoChangeEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallInfoChangeEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallInfoChangeEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#define ITCallInfoChangeEvent_get_Cause(This,pCIC)	\
    ( (This)->lpVtbl -> get_Cause(This,pCIC) ) 

#define ITCallInfoChangeEvent_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallInfoChangeEvent_INTERFACE_DEFINED__ */


#ifndef __ITRequest_INTERFACE_DEFINED__
#define __ITRequest_INTERFACE_DEFINED__

/* interface ITRequest */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC48FFDF-F8C4-11d1-A030-00C04FB6809F")
    ITRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MakeCall( 
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ __RPC__in BSTR pAppName,
            /* [in] */ __RPC__in BSTR pCalledParty,
            /* [in] */ __RPC__in BSTR pComment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITRequest * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITRequest * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *MakeCall )( 
            ITRequest * This,
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ __RPC__in BSTR pAppName,
            /* [in] */ __RPC__in BSTR pCalledParty,
            /* [in] */ __RPC__in BSTR pComment);
        
        END_INTERFACE
    } ITRequestVtbl;

    interface ITRequest
    {
        CONST_VTBL struct ITRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRequest_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITRequest_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITRequest_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITRequest_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITRequest_MakeCall(This,pDestAddress,pAppName,pCalledParty,pComment)	\
    ( (This)->lpVtbl -> MakeCall(This,pDestAddress,pAppName,pCalledParty,pComment) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITRequest_INTERFACE_DEFINED__ */


#ifndef __ITRequestEvent_INTERFACE_DEFINED__
#define __ITRequestEvent_INTERFACE_DEFINED__

/* interface ITRequestEvent */
/* [object][oleautomation][helpstring][uuid] */ 


EXTERN_C const IID IID_ITRequestEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC48FFDE-F8C4-11d1-A030-00C04FB6809F")
    ITRequestEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RegistrationInstance( 
            /* [retval][out] */ __RPC__out long *plRegistrationInstance) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestMode( 
            /* [retval][out] */ __RPC__out long *plRequestMode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDestAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AppName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppAppName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CalledParty( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCalledParty) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Comment( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppComment) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITRequestEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITRequestEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITRequestEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITRequestEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITRequestEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITRequestEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITRequestEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITRequestEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RegistrationInstance )( 
            ITRequestEvent * This,
            /* [retval][out] */ __RPC__out long *plRegistrationInstance);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestMode )( 
            ITRequestEvent * This,
            /* [retval][out] */ __RPC__out long *plRequestMode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestAddress )( 
            ITRequestEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDestAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AppName )( 
            ITRequestEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppAppName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CalledParty )( 
            ITRequestEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCalledParty);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Comment )( 
            ITRequestEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppComment);
        
        END_INTERFACE
    } ITRequestEventVtbl;

    interface ITRequestEvent
    {
        CONST_VTBL struct ITRequestEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITRequestEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITRequestEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITRequestEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITRequestEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITRequestEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITRequestEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITRequestEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITRequestEvent_get_RegistrationInstance(This,plRegistrationInstance)	\
    ( (This)->lpVtbl -> get_RegistrationInstance(This,plRegistrationInstance) ) 

#define ITRequestEvent_get_RequestMode(This,plRequestMode)	\
    ( (This)->lpVtbl -> get_RequestMode(This,plRequestMode) ) 

#define ITRequestEvent_get_DestAddress(This,ppDestAddress)	\
    ( (This)->lpVtbl -> get_DestAddress(This,ppDestAddress) ) 

#define ITRequestEvent_get_AppName(This,ppAppName)	\
    ( (This)->lpVtbl -> get_AppName(This,ppAppName) ) 

#define ITRequestEvent_get_CalledParty(This,ppCalledParty)	\
    ( (This)->lpVtbl -> get_CalledParty(This,ppCalledParty) ) 

#define ITRequestEvent_get_Comment(This,ppComment)	\
    ( (This)->lpVtbl -> get_Comment(This,ppComment) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITRequestEvent_INTERFACE_DEFINED__ */


#ifndef __ITCollection_INTERFACE_DEFINED__
#define __ITCollection_INTERFACE_DEFINED__

/* interface ITCollection */
/* [dual][helpstring][uuid][public][object] */ 


EXTERN_C const IID IID_ITCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5EC5ACF2-9C02-11d0-8362-00AA003CCABD")
    ITCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *lCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppNewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCollection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITCollection * This,
            /* [retval][out] */ __RPC__out long *lCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITCollection * This,
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ITCollection * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppNewEnum);
        
        END_INTERFACE
    } ITCollectionVtbl;

    interface ITCollection
    {
        CONST_VTBL struct ITCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCollection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCollection_get_Count(This,lCount)	\
    ( (This)->lpVtbl -> get_Count(This,lCount) ) 

#define ITCollection_get_Item(This,Index,pVariant)	\
    ( (This)->lpVtbl -> get_Item(This,Index,pVariant) ) 

#define ITCollection_get__NewEnum(This,ppNewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppNewEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCollection_INTERFACE_DEFINED__ */


#ifndef __ITCollection2_INTERFACE_DEFINED__
#define __ITCollection2_INTERFACE_DEFINED__

/* interface ITCollection2 */
/* [dual][helpstring][uuid][public][object] */ 


EXTERN_C const IID IID_ITCollection2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E6DDDDA5-A6D3-48ff-8737-D32FC4D95477")
    ITCollection2 : public ITCollection
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ long Index,
            /* [in] */ __RPC__in VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long Index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCollection2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCollection2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCollection2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCollection2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCollection2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCollection2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCollection2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCollection2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ITCollection2 * This,
            /* [retval][out] */ __RPC__out long *lCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ITCollection2 * This,
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ITCollection2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppNewEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            ITCollection2 * This,
            /* [in] */ long Index,
            /* [in] */ __RPC__in VARIANT *pVariant);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            ITCollection2 * This,
            /* [in] */ long Index);
        
        END_INTERFACE
    } ITCollection2Vtbl;

    interface ITCollection2
    {
        CONST_VTBL struct ITCollection2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCollection2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCollection2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCollection2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCollection2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCollection2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCollection2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCollection2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCollection2_get_Count(This,lCount)	\
    ( (This)->lpVtbl -> get_Count(This,lCount) ) 

#define ITCollection2_get_Item(This,Index,pVariant)	\
    ( (This)->lpVtbl -> get_Item(This,Index,pVariant) ) 

#define ITCollection2_get__NewEnum(This,ppNewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppNewEnum) ) 


#define ITCollection2_Add(This,Index,pVariant)	\
    ( (This)->lpVtbl -> Add(This,Index,pVariant) ) 

#define ITCollection2_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCollection2_INTERFACE_DEFINED__ */


#ifndef __ITForwardInformation_INTERFACE_DEFINED__
#define __ITForwardInformation_INTERFACE_DEFINED__

/* interface ITForwardInformation */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITForwardInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("449F659E-88A3-11d1-BB5D-00C04FB6809F")
    ITForwardInformation : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_NumRingsNoAnswer( 
            /* [in] */ long lNumRings) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumRingsNoAnswer( 
            /* [retval][out] */ __RPC__out long *plNumRings) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetForwardType( 
            /* [in] */ long ForwardType,
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ __RPC__in BSTR pCallerAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ForwardTypeDestination( 
            /* [in] */ long ForwardType,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDestAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ForwardTypeCaller( 
            /* [in] */ long Forwardtype,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCallerAddress) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetForwardType( 
            /* [in] */ long ForwardType,
            /* [out] */ __RPC__deref_out_opt BSTR *ppDestinationAddress,
            /* [out] */ __RPC__deref_out_opt BSTR *ppCallerAddress) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITForwardInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITForwardInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITForwardInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITForwardInformation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITForwardInformation * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITForwardInformation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITForwardInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITForwardInformation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NumRingsNoAnswer )( 
            ITForwardInformation * This,
            /* [in] */ long lNumRings);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumRingsNoAnswer )( 
            ITForwardInformation * This,
            /* [retval][out] */ __RPC__out long *plNumRings);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetForwardType )( 
            ITForwardInformation * This,
            /* [in] */ long ForwardType,
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ __RPC__in BSTR pCallerAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForwardTypeDestination )( 
            ITForwardInformation * This,
            /* [in] */ long ForwardType,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDestAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForwardTypeCaller )( 
            ITForwardInformation * This,
            /* [in] */ long Forwardtype,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCallerAddress);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetForwardType )( 
            ITForwardInformation * This,
            /* [in] */ long ForwardType,
            /* [out] */ __RPC__deref_out_opt BSTR *ppDestinationAddress,
            /* [out] */ __RPC__deref_out_opt BSTR *ppCallerAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITForwardInformation * This);
        
        END_INTERFACE
    } ITForwardInformationVtbl;

    interface ITForwardInformation
    {
        CONST_VTBL struct ITForwardInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITForwardInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITForwardInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITForwardInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITForwardInformation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITForwardInformation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITForwardInformation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITForwardInformation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITForwardInformation_put_NumRingsNoAnswer(This,lNumRings)	\
    ( (This)->lpVtbl -> put_NumRingsNoAnswer(This,lNumRings) ) 

#define ITForwardInformation_get_NumRingsNoAnswer(This,plNumRings)	\
    ( (This)->lpVtbl -> get_NumRingsNoAnswer(This,plNumRings) ) 

#define ITForwardInformation_SetForwardType(This,ForwardType,pDestAddress,pCallerAddress)	\
    ( (This)->lpVtbl -> SetForwardType(This,ForwardType,pDestAddress,pCallerAddress) ) 

#define ITForwardInformation_get_ForwardTypeDestination(This,ForwardType,ppDestAddress)	\
    ( (This)->lpVtbl -> get_ForwardTypeDestination(This,ForwardType,ppDestAddress) ) 

#define ITForwardInformation_get_ForwardTypeCaller(This,Forwardtype,ppCallerAddress)	\
    ( (This)->lpVtbl -> get_ForwardTypeCaller(This,Forwardtype,ppCallerAddress) ) 

#define ITForwardInformation_GetForwardType(This,ForwardType,ppDestinationAddress,ppCallerAddress)	\
    ( (This)->lpVtbl -> GetForwardType(This,ForwardType,ppDestinationAddress,ppCallerAddress) ) 

#define ITForwardInformation_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITForwardInformation_INTERFACE_DEFINED__ */


#ifndef __ITForwardInformation2_INTERFACE_DEFINED__
#define __ITForwardInformation2_INTERFACE_DEFINED__

/* interface ITForwardInformation2 */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITForwardInformation2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5229B4ED-B260-4382-8E1A-5DF3A8A4CCC0")
    ITForwardInformation2 : public ITForwardInformation
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetForwardType2( 
            /* [in] */ long ForwardType,
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ long DestAddressType,
            /* [in] */ __RPC__in BSTR pCallerAddress,
            /* [in] */ long CallerAddressType) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE GetForwardType2( 
            /* [in] */ long ForwardType,
            /* [out] */ __RPC__deref_out_opt BSTR *ppDestinationAddress,
            /* [out] */ __RPC__out long *pDestAddressType,
            /* [out] */ __RPC__deref_out_opt BSTR *ppCallerAddress,
            /* [out] */ __RPC__out long *pCallerAddressType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ForwardTypeDestinationAddressType( 
            /* [in] */ long ForwardType,
            /* [retval][out] */ __RPC__out long *pDestAddressType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ForwardTypeCallerAddressType( 
            /* [in] */ long Forwardtype,
            /* [retval][out] */ __RPC__out long *pCallerAddressType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITForwardInformation2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITForwardInformation2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITForwardInformation2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITForwardInformation2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITForwardInformation2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITForwardInformation2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITForwardInformation2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITForwardInformation2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_NumRingsNoAnswer )( 
            ITForwardInformation2 * This,
            /* [in] */ long lNumRings);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumRingsNoAnswer )( 
            ITForwardInformation2 * This,
            /* [retval][out] */ __RPC__out long *plNumRings);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetForwardType )( 
            ITForwardInformation2 * This,
            /* [in] */ long ForwardType,
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ __RPC__in BSTR pCallerAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForwardTypeDestination )( 
            ITForwardInformation2 * This,
            /* [in] */ long ForwardType,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDestAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForwardTypeCaller )( 
            ITForwardInformation2 * This,
            /* [in] */ long Forwardtype,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCallerAddress);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetForwardType )( 
            ITForwardInformation2 * This,
            /* [in] */ long ForwardType,
            /* [out] */ __RPC__deref_out_opt BSTR *ppDestinationAddress,
            /* [out] */ __RPC__deref_out_opt BSTR *ppCallerAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITForwardInformation2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetForwardType2 )( 
            ITForwardInformation2 * This,
            /* [in] */ long ForwardType,
            /* [in] */ __RPC__in BSTR pDestAddress,
            /* [in] */ long DestAddressType,
            /* [in] */ __RPC__in BSTR pCallerAddress,
            /* [in] */ long CallerAddressType);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *GetForwardType2 )( 
            ITForwardInformation2 * This,
            /* [in] */ long ForwardType,
            /* [out] */ __RPC__deref_out_opt BSTR *ppDestinationAddress,
            /* [out] */ __RPC__out long *pDestAddressType,
            /* [out] */ __RPC__deref_out_opt BSTR *ppCallerAddress,
            /* [out] */ __RPC__out long *pCallerAddressType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForwardTypeDestinationAddressType )( 
            ITForwardInformation2 * This,
            /* [in] */ long ForwardType,
            /* [retval][out] */ __RPC__out long *pDestAddressType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForwardTypeCallerAddressType )( 
            ITForwardInformation2 * This,
            /* [in] */ long Forwardtype,
            /* [retval][out] */ __RPC__out long *pCallerAddressType);
        
        END_INTERFACE
    } ITForwardInformation2Vtbl;

    interface ITForwardInformation2
    {
        CONST_VTBL struct ITForwardInformation2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITForwardInformation2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITForwardInformation2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITForwardInformation2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITForwardInformation2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITForwardInformation2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITForwardInformation2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITForwardInformation2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITForwardInformation2_put_NumRingsNoAnswer(This,lNumRings)	\
    ( (This)->lpVtbl -> put_NumRingsNoAnswer(This,lNumRings) ) 

#define ITForwardInformation2_get_NumRingsNoAnswer(This,plNumRings)	\
    ( (This)->lpVtbl -> get_NumRingsNoAnswer(This,plNumRings) ) 

#define ITForwardInformation2_SetForwardType(This,ForwardType,pDestAddress,pCallerAddress)	\
    ( (This)->lpVtbl -> SetForwardType(This,ForwardType,pDestAddress,pCallerAddress) ) 

#define ITForwardInformation2_get_ForwardTypeDestination(This,ForwardType,ppDestAddress)	\
    ( (This)->lpVtbl -> get_ForwardTypeDestination(This,ForwardType,ppDestAddress) ) 

#define ITForwardInformation2_get_ForwardTypeCaller(This,Forwardtype,ppCallerAddress)	\
    ( (This)->lpVtbl -> get_ForwardTypeCaller(This,Forwardtype,ppCallerAddress) ) 

#define ITForwardInformation2_GetForwardType(This,ForwardType,ppDestinationAddress,ppCallerAddress)	\
    ( (This)->lpVtbl -> GetForwardType(This,ForwardType,ppDestinationAddress,ppCallerAddress) ) 

#define ITForwardInformation2_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 


#define ITForwardInformation2_SetForwardType2(This,ForwardType,pDestAddress,DestAddressType,pCallerAddress,CallerAddressType)	\
    ( (This)->lpVtbl -> SetForwardType2(This,ForwardType,pDestAddress,DestAddressType,pCallerAddress,CallerAddressType) ) 

#define ITForwardInformation2_GetForwardType2(This,ForwardType,ppDestinationAddress,pDestAddressType,ppCallerAddress,pCallerAddressType)	\
    ( (This)->lpVtbl -> GetForwardType2(This,ForwardType,ppDestinationAddress,pDestAddressType,ppCallerAddress,pCallerAddressType) ) 

#define ITForwardInformation2_get_ForwardTypeDestinationAddressType(This,ForwardType,pDestAddressType)	\
    ( (This)->lpVtbl -> get_ForwardTypeDestinationAddressType(This,ForwardType,pDestAddressType) ) 

#define ITForwardInformation2_get_ForwardTypeCallerAddressType(This,Forwardtype,pCallerAddressType)	\
    ( (This)->lpVtbl -> get_ForwardTypeCallerAddressType(This,Forwardtype,pCallerAddressType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITForwardInformation2_INTERFACE_DEFINED__ */


#ifndef __ITAddressTranslation_INTERFACE_DEFINED__
#define __ITAddressTranslation_INTERFACE_DEFINED__

/* interface ITAddressTranslation */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressTranslation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8F03-8DDB-11d1-A09E-00805FC147D3")
    ITAddressTranslation : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TranslateAddress( 
            /* [in] */ __RPC__in BSTR pAddressToTranslate,
            /* [in] */ long lCard,
            /* [in] */ long lTranslateOptions,
            /* [retval][out] */ __RPC__deref_out_opt ITAddressTranslationInfo **ppTranslated) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TranslateDialog( 
            /* [in] */ TAPIHWND hwndOwner,
            /* [in] */ __RPC__in BSTR pAddressIn) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateLocations( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumLocation **ppEnumLocation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Locations( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateCallingCards( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallingCard **ppEnumCallingCard) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallingCards( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressTranslationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAddressTranslation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAddressTranslation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAddressTranslation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAddressTranslation * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAddressTranslation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAddressTranslation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAddressTranslation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *TranslateAddress )( 
            ITAddressTranslation * This,
            /* [in] */ __RPC__in BSTR pAddressToTranslate,
            /* [in] */ long lCard,
            /* [in] */ long lTranslateOptions,
            /* [retval][out] */ __RPC__deref_out_opt ITAddressTranslationInfo **ppTranslated);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *TranslateDialog )( 
            ITAddressTranslation * This,
            /* [in] */ TAPIHWND hwndOwner,
            /* [in] */ __RPC__in BSTR pAddressIn);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateLocations )( 
            ITAddressTranslation * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumLocation **ppEnumLocation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Locations )( 
            ITAddressTranslation * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateCallingCards )( 
            ITAddressTranslation * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallingCard **ppEnumCallingCard);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallingCards )( 
            ITAddressTranslation * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITAddressTranslationVtbl;

    interface ITAddressTranslation
    {
        CONST_VTBL struct ITAddressTranslationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressTranslation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAddressTranslation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAddressTranslation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAddressTranslation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAddressTranslation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAddressTranslation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAddressTranslation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAddressTranslation_TranslateAddress(This,pAddressToTranslate,lCard,lTranslateOptions,ppTranslated)	\
    ( (This)->lpVtbl -> TranslateAddress(This,pAddressToTranslate,lCard,lTranslateOptions,ppTranslated) ) 

#define ITAddressTranslation_TranslateDialog(This,hwndOwner,pAddressIn)	\
    ( (This)->lpVtbl -> TranslateDialog(This,hwndOwner,pAddressIn) ) 

#define ITAddressTranslation_EnumerateLocations(This,ppEnumLocation)	\
    ( (This)->lpVtbl -> EnumerateLocations(This,ppEnumLocation) ) 

#define ITAddressTranslation_get_Locations(This,pVariant)	\
    ( (This)->lpVtbl -> get_Locations(This,pVariant) ) 

#define ITAddressTranslation_EnumerateCallingCards(This,ppEnumCallingCard)	\
    ( (This)->lpVtbl -> EnumerateCallingCards(This,ppEnumCallingCard) ) 

#define ITAddressTranslation_get_CallingCards(This,pVariant)	\
    ( (This)->lpVtbl -> get_CallingCards(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAddressTranslation_INTERFACE_DEFINED__ */


#ifndef __ITAddressTranslationInfo_INTERFACE_DEFINED__
#define __ITAddressTranslationInfo_INTERFACE_DEFINED__

/* interface ITAddressTranslationInfo */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAddressTranslationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AFC15945-8D40-11d1-A09E-00805FC147D3")
    ITAddressTranslationInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DialableString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDialableString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayableString( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDisplayableString) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCountryCode( 
            /* [retval][out] */ __RPC__out long *CountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DestinationCountryCode( 
            /* [retval][out] */ __RPC__out long *CountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TranslationResults( 
            /* [retval][out] */ __RPC__out long *plResults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAddressTranslationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAddressTranslationInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAddressTranslationInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAddressTranslationInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAddressTranslationInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAddressTranslationInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAddressTranslationInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAddressTranslationInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DialableString )( 
            ITAddressTranslationInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDialableString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayableString )( 
            ITAddressTranslationInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDisplayableString);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCountryCode )( 
            ITAddressTranslationInfo * This,
            /* [retval][out] */ __RPC__out long *CountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DestinationCountryCode )( 
            ITAddressTranslationInfo * This,
            /* [retval][out] */ __RPC__out long *CountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TranslationResults )( 
            ITAddressTranslationInfo * This,
            /* [retval][out] */ __RPC__out long *plResults);
        
        END_INTERFACE
    } ITAddressTranslationInfoVtbl;

    interface ITAddressTranslationInfo
    {
        CONST_VTBL struct ITAddressTranslationInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAddressTranslationInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAddressTranslationInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAddressTranslationInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAddressTranslationInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAddressTranslationInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAddressTranslationInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAddressTranslationInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAddressTranslationInfo_get_DialableString(This,ppDialableString)	\
    ( (This)->lpVtbl -> get_DialableString(This,ppDialableString) ) 

#define ITAddressTranslationInfo_get_DisplayableString(This,ppDisplayableString)	\
    ( (This)->lpVtbl -> get_DisplayableString(This,ppDisplayableString) ) 

#define ITAddressTranslationInfo_get_CurrentCountryCode(This,CountryCode)	\
    ( (This)->lpVtbl -> get_CurrentCountryCode(This,CountryCode) ) 

#define ITAddressTranslationInfo_get_DestinationCountryCode(This,CountryCode)	\
    ( (This)->lpVtbl -> get_DestinationCountryCode(This,CountryCode) ) 

#define ITAddressTranslationInfo_get_TranslationResults(This,plResults)	\
    ( (This)->lpVtbl -> get_TranslationResults(This,plResults) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAddressTranslationInfo_INTERFACE_DEFINED__ */


#ifndef __ITLocationInfo_INTERFACE_DEFINED__
#define __ITLocationInfo_INTERFACE_DEFINED__

/* interface ITLocationInfo */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLocationInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8EFF-8DDB-11d1-A09E-00805FC147D3")
    ITLocationInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermanentLocationID( 
            /* [retval][out] */ __RPC__out long *plLocationID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryCode( 
            /* [retval][out] */ __RPC__out long *plCountryCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryID( 
            /* [retval][out] */ __RPC__out long *plCountryID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Options( 
            /* [retval][out] */ __RPC__out long *plOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PreferredCardID( 
            /* [retval][out] */ __RPC__out long *plCardID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocationName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppLocationName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CityCode( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LocalAccessCode( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongDistanceAccessCode( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TollPrefixList( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppTollList) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CancelCallWaitingCode( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLocationInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITLocationInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITLocationInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITLocationInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITLocationInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITLocationInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITLocationInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITLocationInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermanentLocationID )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__out long *plLocationID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryCode )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__out long *plCountryCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryID )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__out long *plCountryID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Options )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__out long *plOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PreferredCardID )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__out long *plCardID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocationName )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppLocationName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CityCode )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LocalAccessCode )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LongDistanceAccessCode )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TollPrefixList )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppTollList);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CancelCallWaitingCode )( 
            ITLocationInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCode);
        
        END_INTERFACE
    } ITLocationInfoVtbl;

    interface ITLocationInfo
    {
        CONST_VTBL struct ITLocationInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLocationInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITLocationInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITLocationInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITLocationInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITLocationInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITLocationInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITLocationInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITLocationInfo_get_PermanentLocationID(This,plLocationID)	\
    ( (This)->lpVtbl -> get_PermanentLocationID(This,plLocationID) ) 

#define ITLocationInfo_get_CountryCode(This,plCountryCode)	\
    ( (This)->lpVtbl -> get_CountryCode(This,plCountryCode) ) 

#define ITLocationInfo_get_CountryID(This,plCountryID)	\
    ( (This)->lpVtbl -> get_CountryID(This,plCountryID) ) 

#define ITLocationInfo_get_Options(This,plOptions)	\
    ( (This)->lpVtbl -> get_Options(This,plOptions) ) 

#define ITLocationInfo_get_PreferredCardID(This,plCardID)	\
    ( (This)->lpVtbl -> get_PreferredCardID(This,plCardID) ) 

#define ITLocationInfo_get_LocationName(This,ppLocationName)	\
    ( (This)->lpVtbl -> get_LocationName(This,ppLocationName) ) 

#define ITLocationInfo_get_CityCode(This,ppCode)	\
    ( (This)->lpVtbl -> get_CityCode(This,ppCode) ) 

#define ITLocationInfo_get_LocalAccessCode(This,ppCode)	\
    ( (This)->lpVtbl -> get_LocalAccessCode(This,ppCode) ) 

#define ITLocationInfo_get_LongDistanceAccessCode(This,ppCode)	\
    ( (This)->lpVtbl -> get_LongDistanceAccessCode(This,ppCode) ) 

#define ITLocationInfo_get_TollPrefixList(This,ppTollList)	\
    ( (This)->lpVtbl -> get_TollPrefixList(This,ppTollList) ) 

#define ITLocationInfo_get_CancelCallWaitingCode(This,ppCode)	\
    ( (This)->lpVtbl -> get_CancelCallWaitingCode(This,ppCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITLocationInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumLocation_INTERFACE_DEFINED__
#define __IEnumLocation_INTERFACE_DEFINED__

/* interface IEnumLocation */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumLocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8F01-8DDB-11d1-A09E-00805FC147D3")
    IEnumLocation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITLocationInfo **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumLocation **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumLocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumLocation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumLocation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumLocation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumLocation * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITLocationInfo **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumLocation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumLocation * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumLocation * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumLocation **ppEnum);
        
        END_INTERFACE
    } IEnumLocationVtbl;

    interface IEnumLocation
    {
        CONST_VTBL struct IEnumLocationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumLocation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumLocation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumLocation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumLocation_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumLocation_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumLocation_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumLocation_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumLocation_INTERFACE_DEFINED__ */


#ifndef __ITCallingCard_INTERFACE_DEFINED__
#define __ITCallingCard_INTERFACE_DEFINED__

/* interface ITCallingCard */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallingCard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8F00-8DDB-11d1-A09E-00805FC147D3")
    ITCallingCard : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermanentCardID( 
            /* [retval][out] */ __RPC__out long *plCardID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfDigits( 
            /* [retval][out] */ __RPC__out long *plDigits) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Options( 
            /* [retval][out] */ __RPC__out long *plOptions) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CardName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCardName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SameAreaDialingRule( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRule) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongDistanceDialingRule( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRule) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InternationalDialingRule( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallingCardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallingCard * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallingCard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallingCard * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallingCard * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallingCard * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallingCard * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallingCard * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermanentCardID )( 
            ITCallingCard * This,
            /* [retval][out] */ __RPC__out long *plCardID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfDigits )( 
            ITCallingCard * This,
            /* [retval][out] */ __RPC__out long *plDigits);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Options )( 
            ITCallingCard * This,
            /* [retval][out] */ __RPC__out long *plOptions);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CardName )( 
            ITCallingCard * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppCardName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SameAreaDialingRule )( 
            ITCallingCard * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRule);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LongDistanceDialingRule )( 
            ITCallingCard * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRule);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InternationalDialingRule )( 
            ITCallingCard * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRule);
        
        END_INTERFACE
    } ITCallingCardVtbl;

    interface ITCallingCard
    {
        CONST_VTBL struct ITCallingCardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallingCard_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallingCard_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallingCard_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallingCard_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallingCard_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallingCard_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallingCard_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallingCard_get_PermanentCardID(This,plCardID)	\
    ( (This)->lpVtbl -> get_PermanentCardID(This,plCardID) ) 

#define ITCallingCard_get_NumberOfDigits(This,plDigits)	\
    ( (This)->lpVtbl -> get_NumberOfDigits(This,plDigits) ) 

#define ITCallingCard_get_Options(This,plOptions)	\
    ( (This)->lpVtbl -> get_Options(This,plOptions) ) 

#define ITCallingCard_get_CardName(This,ppCardName)	\
    ( (This)->lpVtbl -> get_CardName(This,ppCardName) ) 

#define ITCallingCard_get_SameAreaDialingRule(This,ppRule)	\
    ( (This)->lpVtbl -> get_SameAreaDialingRule(This,ppRule) ) 

#define ITCallingCard_get_LongDistanceDialingRule(This,ppRule)	\
    ( (This)->lpVtbl -> get_LongDistanceDialingRule(This,ppRule) ) 

#define ITCallingCard_get_InternationalDialingRule(This,ppRule)	\
    ( (This)->lpVtbl -> get_InternationalDialingRule(This,ppRule) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallingCard_INTERFACE_DEFINED__ */


#ifndef __IEnumCallingCard_INTERFACE_DEFINED__
#define __IEnumCallingCard_INTERFACE_DEFINED__

/* interface IEnumCallingCard */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumCallingCard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C4D8F02-8DDB-11d1-A09E-00805FC147D3")
    IEnumCallingCard : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITCallingCard **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallingCard **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCallingCardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumCallingCard * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumCallingCard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumCallingCard * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumCallingCard * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITCallingCard **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumCallingCard * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumCallingCard * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumCallingCard * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumCallingCard **ppEnum);
        
        END_INTERFACE
    } IEnumCallingCardVtbl;

    interface IEnumCallingCard
    {
        CONST_VTBL struct IEnumCallingCardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCallingCard_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumCallingCard_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumCallingCard_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumCallingCard_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumCallingCard_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumCallingCard_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumCallingCard_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumCallingCard_INTERFACE_DEFINED__ */


#ifndef __ITCallNotificationEvent_INTERFACE_DEFINED__
#define __ITCallNotificationEvent_INTERFACE_DEFINED__

/* interface ITCallNotificationEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITCallNotificationEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("895801DF-3DD6-11d1-8F30-00C04FB6809F")
    ITCallNotificationEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Call( 
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out CALL_NOTIFICATION_EVENT *pCallNotificationEvent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CallbackInstance( 
            /* [retval][out] */ __RPC__out long *plCallbackInstance) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITCallNotificationEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITCallNotificationEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITCallNotificationEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITCallNotificationEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITCallNotificationEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITCallNotificationEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITCallNotificationEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITCallNotificationEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Call )( 
            ITCallNotificationEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITCallInfo **ppCall);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITCallNotificationEvent * This,
            /* [retval][out] */ __RPC__out CALL_NOTIFICATION_EVENT *pCallNotificationEvent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CallbackInstance )( 
            ITCallNotificationEvent * This,
            /* [retval][out] */ __RPC__out long *plCallbackInstance);
        
        END_INTERFACE
    } ITCallNotificationEventVtbl;

    interface ITCallNotificationEvent
    {
        CONST_VTBL struct ITCallNotificationEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITCallNotificationEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITCallNotificationEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITCallNotificationEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITCallNotificationEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITCallNotificationEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITCallNotificationEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITCallNotificationEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITCallNotificationEvent_get_Call(This,ppCall)	\
    ( (This)->lpVtbl -> get_Call(This,ppCall) ) 

#define ITCallNotificationEvent_get_Event(This,pCallNotificationEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pCallNotificationEvent) ) 

#define ITCallNotificationEvent_get_CallbackInstance(This,plCallbackInstance)	\
    ( (This)->lpVtbl -> get_CallbackInstance(This,plCallbackInstance) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITCallNotificationEvent_INTERFACE_DEFINED__ */


#ifndef __ITDispatchMapper_INTERFACE_DEFINED__
#define __ITDispatchMapper_INTERFACE_DEFINED__

/* interface ITDispatchMapper */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ITDispatchMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E9225295-C759-11d1-A02B-00C04FB6809F")
    ITDispatchMapper : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE QueryDispatchInterface( 
            /* [in] */ __RPC__in BSTR pIID,
            /* [in] */ __RPC__in_opt IDispatch *pInterfaceToMap,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppReturnedInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITDispatchMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITDispatchMapper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITDispatchMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITDispatchMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITDispatchMapper * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITDispatchMapper * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITDispatchMapper * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITDispatchMapper * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *QueryDispatchInterface )( 
            ITDispatchMapper * This,
            /* [in] */ __RPC__in BSTR pIID,
            /* [in] */ __RPC__in_opt IDispatch *pInterfaceToMap,
            /* [retval][out] */ __RPC__deref_out_opt IDispatch **ppReturnedInterface);
        
        END_INTERFACE
    } ITDispatchMapperVtbl;

    interface ITDispatchMapper
    {
        CONST_VTBL struct ITDispatchMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITDispatchMapper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITDispatchMapper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITDispatchMapper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITDispatchMapper_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITDispatchMapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITDispatchMapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITDispatchMapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITDispatchMapper_QueryDispatchInterface(This,pIID,pInterfaceToMap,ppReturnedInterface)	\
    ( (This)->lpVtbl -> QueryDispatchInterface(This,pIID,pInterfaceToMap,ppReturnedInterface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITDispatchMapper_INTERFACE_DEFINED__ */


#ifndef __ITStreamControl_INTERFACE_DEFINED__
#define __ITStreamControl_INTERFACE_DEFINED__

/* interface ITStreamControl */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD604-3868-11D2-A045-00C04FB6809F")
    ITStreamControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION td,
            /* [retval][out] */ __RPC__deref_out_opt ITStream **ppStream) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ __RPC__in_opt ITStream *pStream) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateStreams( 
            /* [out] */ __RPC__deref_out_opt IEnumStream **ppEnumStream) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Streams( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITStreamControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITStreamControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITStreamControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITStreamControl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITStreamControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITStreamControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITStreamControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            ITStreamControl * This,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION td,
            /* [retval][out] */ __RPC__deref_out_opt ITStream **ppStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            ITStreamControl * This,
            /* [in] */ __RPC__in_opt ITStream *pStream);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateStreams )( 
            ITStreamControl * This,
            /* [out] */ __RPC__deref_out_opt IEnumStream **ppEnumStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Streams )( 
            ITStreamControl * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITStreamControlVtbl;

    interface ITStreamControl
    {
        CONST_VTBL struct ITStreamControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITStreamControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITStreamControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITStreamControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITStreamControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITStreamControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITStreamControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITStreamControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITStreamControl_CreateStream(This,lMediaType,td,ppStream)	\
    ( (This)->lpVtbl -> CreateStream(This,lMediaType,td,ppStream) ) 

#define ITStreamControl_RemoveStream(This,pStream)	\
    ( (This)->lpVtbl -> RemoveStream(This,pStream) ) 

#define ITStreamControl_EnumerateStreams(This,ppEnumStream)	\
    ( (This)->lpVtbl -> EnumerateStreams(This,ppEnumStream) ) 

#define ITStreamControl_get_Streams(This,pVariant)	\
    ( (This)->lpVtbl -> get_Streams(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITStreamControl_INTERFACE_DEFINED__ */


#ifndef __ITStream_INTERFACE_DEFINED__
#define __ITStream_INTERFACE_DEFINED__

/* interface ITStream */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD605-3868-11D2-A045-00C04FB6809F")
    ITStream : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][out] */ __RPC__out long *plMediaType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ __RPC__out TERMINAL_DIRECTION *pTD) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectTerminal( 
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnselectTerminal( 
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateTerminals( 
            /* [out] */ __RPC__deref_out_opt IEnumTerminal **ppEnumTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminals( 
            /* [retval][out] */ __RPC__out VARIANT *pTerminals) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITStream * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITStream * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITStream * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            ITStream * This,
            /* [retval][out] */ __RPC__out long *plMediaType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            ITStream * This,
            /* [retval][out] */ __RPC__out TERMINAL_DIRECTION *pTD);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITStream * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartStream )( 
            ITStream * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PauseStream )( 
            ITStream * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopStream )( 
            ITStream * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectTerminal )( 
            ITStream * This,
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnselectTerminal )( 
            ITStream * This,
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateTerminals )( 
            ITStream * This,
            /* [out] */ __RPC__deref_out_opt IEnumTerminal **ppEnumTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminals )( 
            ITStream * This,
            /* [retval][out] */ __RPC__out VARIANT *pTerminals);
        
        END_INTERFACE
    } ITStreamVtbl;

    interface ITStream
    {
        CONST_VTBL struct ITStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITStream_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITStream_get_MediaType(This,plMediaType)	\
    ( (This)->lpVtbl -> get_MediaType(This,plMediaType) ) 

#define ITStream_get_Direction(This,pTD)	\
    ( (This)->lpVtbl -> get_Direction(This,pTD) ) 

#define ITStream_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#define ITStream_StartStream(This)	\
    ( (This)->lpVtbl -> StartStream(This) ) 

#define ITStream_PauseStream(This)	\
    ( (This)->lpVtbl -> PauseStream(This) ) 

#define ITStream_StopStream(This)	\
    ( (This)->lpVtbl -> StopStream(This) ) 

#define ITStream_SelectTerminal(This,pTerminal)	\
    ( (This)->lpVtbl -> SelectTerminal(This,pTerminal) ) 

#define ITStream_UnselectTerminal(This,pTerminal)	\
    ( (This)->lpVtbl -> UnselectTerminal(This,pTerminal) ) 

#define ITStream_EnumerateTerminals(This,ppEnumTerminal)	\
    ( (This)->lpVtbl -> EnumerateTerminals(This,ppEnumTerminal) ) 

#define ITStream_get_Terminals(This,pTerminals)	\
    ( (This)->lpVtbl -> get_Terminals(This,pTerminals) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITStream_INTERFACE_DEFINED__ */


#ifndef __IEnumStream_INTERFACE_DEFINED__
#define __IEnumStream_INTERFACE_DEFINED__

/* interface IEnumStream */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD606-3868-11d2-A045-00C04FB6809F")
    IEnumStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITStream **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumStream **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumStream * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITStream **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumStream * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumStream * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumStream **ppEnum);
        
        END_INTERFACE
    } IEnumStreamVtbl;

    interface IEnumStream
    {
        CONST_VTBL struct IEnumStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumStream_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumStream_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumStream_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumStream_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumStream_INTERFACE_DEFINED__ */


#ifndef __ITSubStreamControl_INTERFACE_DEFINED__
#define __ITSubStreamControl_INTERFACE_DEFINED__

/* interface ITSubStreamControl */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITSubStreamControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD607-3868-11D2-A045-00C04FB6809F")
    ITSubStreamControl : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSubStream( 
            /* [retval][out] */ __RPC__deref_out_opt ITSubStream **ppSubStream) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveSubStream( 
            /* [in] */ __RPC__in_opt ITSubStream *pSubStream) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateSubStreams( 
            /* [out] */ __RPC__deref_out_opt IEnumSubStream **ppEnumSubStream) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubStreams( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITSubStreamControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITSubStreamControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITSubStreamControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITSubStreamControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITSubStreamControl * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITSubStreamControl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITSubStreamControl * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITSubStreamControl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateSubStream )( 
            ITSubStreamControl * This,
            /* [retval][out] */ __RPC__deref_out_opt ITSubStream **ppSubStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveSubStream )( 
            ITSubStreamControl * This,
            /* [in] */ __RPC__in_opt ITSubStream *pSubStream);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateSubStreams )( 
            ITSubStreamControl * This,
            /* [out] */ __RPC__deref_out_opt IEnumSubStream **ppEnumSubStream);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubStreams )( 
            ITSubStreamControl * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITSubStreamControlVtbl;

    interface ITSubStreamControl
    {
        CONST_VTBL struct ITSubStreamControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITSubStreamControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITSubStreamControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITSubStreamControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITSubStreamControl_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITSubStreamControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITSubStreamControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITSubStreamControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITSubStreamControl_CreateSubStream(This,ppSubStream)	\
    ( (This)->lpVtbl -> CreateSubStream(This,ppSubStream) ) 

#define ITSubStreamControl_RemoveSubStream(This,pSubStream)	\
    ( (This)->lpVtbl -> RemoveSubStream(This,pSubStream) ) 

#define ITSubStreamControl_EnumerateSubStreams(This,ppEnumSubStream)	\
    ( (This)->lpVtbl -> EnumerateSubStreams(This,ppEnumSubStream) ) 

#define ITSubStreamControl_get_SubStreams(This,pVariant)	\
    ( (This)->lpVtbl -> get_SubStreams(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITSubStreamControl_INTERFACE_DEFINED__ */


#ifndef __ITSubStream_INTERFACE_DEFINED__
#define __ITSubStream_INTERFACE_DEFINED__

/* interface ITSubStream */
/* [object][dual][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ITSubStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD608-3868-11D2-A045-00C04FB6809F")
    ITSubStream : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StartSubStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PauseSubStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopSubStream( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectTerminal( 
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnselectTerminal( 
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateTerminals( 
            /* [out] */ __RPC__deref_out_opt IEnumTerminal **ppEnumTerminal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Terminals( 
            /* [retval][out] */ __RPC__out VARIANT *pTerminals) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Stream( 
            /* [retval][out] */ __RPC__deref_out_opt ITStream **ppITStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITSubStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITSubStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITSubStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITSubStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITSubStream * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITSubStream * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITSubStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITSubStream * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StartSubStream )( 
            ITSubStream * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PauseSubStream )( 
            ITSubStream * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopSubStream )( 
            ITSubStream * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectTerminal )( 
            ITSubStream * This,
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnselectTerminal )( 
            ITSubStream * This,
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateTerminals )( 
            ITSubStream * This,
            /* [out] */ __RPC__deref_out_opt IEnumTerminal **ppEnumTerminal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Terminals )( 
            ITSubStream * This,
            /* [retval][out] */ __RPC__out VARIANT *pTerminals);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Stream )( 
            ITSubStream * This,
            /* [retval][out] */ __RPC__deref_out_opt ITStream **ppITStream);
        
        END_INTERFACE
    } ITSubStreamVtbl;

    interface ITSubStream
    {
        CONST_VTBL struct ITSubStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITSubStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITSubStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITSubStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITSubStream_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITSubStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITSubStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITSubStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITSubStream_StartSubStream(This)	\
    ( (This)->lpVtbl -> StartSubStream(This) ) 

#define ITSubStream_PauseSubStream(This)	\
    ( (This)->lpVtbl -> PauseSubStream(This) ) 

#define ITSubStream_StopSubStream(This)	\
    ( (This)->lpVtbl -> StopSubStream(This) ) 

#define ITSubStream_SelectTerminal(This,pTerminal)	\
    ( (This)->lpVtbl -> SelectTerminal(This,pTerminal) ) 

#define ITSubStream_UnselectTerminal(This,pTerminal)	\
    ( (This)->lpVtbl -> UnselectTerminal(This,pTerminal) ) 

#define ITSubStream_EnumerateTerminals(This,ppEnumTerminal)	\
    ( (This)->lpVtbl -> EnumerateTerminals(This,ppEnumTerminal) ) 

#define ITSubStream_get_Terminals(This,pTerminals)	\
    ( (This)->lpVtbl -> get_Terminals(This,pTerminals) ) 

#define ITSubStream_get_Stream(This,ppITStream)	\
    ( (This)->lpVtbl -> get_Stream(This,ppITStream) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITSubStream_INTERFACE_DEFINED__ */


#ifndef __IEnumSubStream_INTERFACE_DEFINED__
#define __IEnumSubStream_INTERFACE_DEFINED__

/* interface IEnumSubStream */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumSubStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE3BD609-3868-11d2-A045-00C04FB6809F")
    IEnumSubStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITSubStream **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumSubStream **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSubStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumSubStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumSubStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumSubStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumSubStream * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITSubStream **ppElements,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumSubStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumSubStream * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumSubStream * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumSubStream **ppEnum);
        
        END_INTERFACE
    } IEnumSubStreamVtbl;

    interface IEnumSubStream
    {
        CONST_VTBL struct IEnumSubStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSubStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumSubStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumSubStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumSubStream_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumSubStream_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumSubStream_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumSubStream_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumSubStream_INTERFACE_DEFINED__ */


#ifndef __ITLegacyWaveSupport_INTERFACE_DEFINED__
#define __ITLegacyWaveSupport_INTERFACE_DEFINED__

/* interface ITLegacyWaveSupport */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITLegacyWaveSupport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("207823EA-E252-11d2-B77E-0080C7135381")
    ITLegacyWaveSupport : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsFullDuplex( 
            /* [out] */ __RPC__out FULLDUPLEX_SUPPORT *pSupport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITLegacyWaveSupportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITLegacyWaveSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITLegacyWaveSupport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITLegacyWaveSupport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITLegacyWaveSupport * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITLegacyWaveSupport * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITLegacyWaveSupport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITLegacyWaveSupport * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *IsFullDuplex )( 
            ITLegacyWaveSupport * This,
            /* [out] */ __RPC__out FULLDUPLEX_SUPPORT *pSupport);
        
        END_INTERFACE
    } ITLegacyWaveSupportVtbl;

    interface ITLegacyWaveSupport
    {
        CONST_VTBL struct ITLegacyWaveSupportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITLegacyWaveSupport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITLegacyWaveSupport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITLegacyWaveSupport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITLegacyWaveSupport_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITLegacyWaveSupport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITLegacyWaveSupport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITLegacyWaveSupport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITLegacyWaveSupport_IsFullDuplex(This,pSupport)	\
    ( (This)->lpVtbl -> IsFullDuplex(This,pSupport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITLegacyWaveSupport_INTERFACE_DEFINED__ */


#ifndef __ITBasicCallControl2_INTERFACE_DEFINED__
#define __ITBasicCallControl2_INTERFACE_DEFINED__

/* interface ITBasicCallControl2 */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITBasicCallControl2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("161A4A56-1E99-4b3f-A46A-168F38A5EE4C")
    ITBasicCallControl2 : public ITBasicCallControl
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestTerminal( 
            /* [in] */ __RPC__in BSTR bstrTerminalClassGUID,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SelectTerminalOnCall( 
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnselectTerminalOnCall( 
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITBasicCallControl2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITBasicCallControl2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITBasicCallControl2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITBasicCallControl2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITBasicCallControl2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITBasicCallControl2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            ITBasicCallControl2 * This,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Answer )( 
            ITBasicCallControl2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            ITBasicCallControl2 * This,
            /* [in] */ DISCONNECT_CODE code);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Hold )( 
            ITBasicCallControl2 * This,
            /* [in] */ VARIANT_BOOL fHold);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HandoffDirect )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in BSTR pApplicationName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HandoffIndirect )( 
            ITBasicCallControl2 * This,
            /* [in] */ long lMediaType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Conference )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Transfer )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall,
            /* [in] */ VARIANT_BOOL fSync);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BlindTransfer )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in BSTR pDestAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SwapHold )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in_opt ITBasicCallControl *pCall);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParkDirect )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in BSTR pParkAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ParkIndirect )( 
            ITBasicCallControl2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppNonDirAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Unpark )( 
            ITBasicCallControl2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetQOS )( 
            ITBasicCallControl2 * This,
            /* [in] */ long lMediaType,
            /* [in] */ QOS_SERVICE_LEVEL ServiceLevel);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Pickup )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in BSTR pGroupID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Dial )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in BSTR pDestAddress);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Finish )( 
            ITBasicCallControl2 * This,
            /* [in] */ FINISH_MODE finishMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveFromConference )( 
            ITBasicCallControl2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestTerminal )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in BSTR bstrTerminalClassGUID,
            /* [in] */ long lMediaType,
            /* [in] */ TERMINAL_DIRECTION Direction,
            /* [retval][out] */ __RPC__deref_out_opt ITTerminal **ppTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SelectTerminalOnCall )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnselectTerminalOnCall )( 
            ITBasicCallControl2 * This,
            /* [in] */ __RPC__in_opt ITTerminal *pTerminal);
        
        END_INTERFACE
    } ITBasicCallControl2Vtbl;

    interface ITBasicCallControl2
    {
        CONST_VTBL struct ITBasicCallControl2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITBasicCallControl2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITBasicCallControl2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITBasicCallControl2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITBasicCallControl2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITBasicCallControl2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITBasicCallControl2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITBasicCallControl2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITBasicCallControl2_Connect(This,fSync)	\
    ( (This)->lpVtbl -> Connect(This,fSync) ) 

#define ITBasicCallControl2_Answer(This)	\
    ( (This)->lpVtbl -> Answer(This) ) 

#define ITBasicCallControl2_Disconnect(This,code)	\
    ( (This)->lpVtbl -> Disconnect(This,code) ) 

#define ITBasicCallControl2_Hold(This,fHold)	\
    ( (This)->lpVtbl -> Hold(This,fHold) ) 

#define ITBasicCallControl2_HandoffDirect(This,pApplicationName)	\
    ( (This)->lpVtbl -> HandoffDirect(This,pApplicationName) ) 

#define ITBasicCallControl2_HandoffIndirect(This,lMediaType)	\
    ( (This)->lpVtbl -> HandoffIndirect(This,lMediaType) ) 

#define ITBasicCallControl2_Conference(This,pCall,fSync)	\
    ( (This)->lpVtbl -> Conference(This,pCall,fSync) ) 

#define ITBasicCallControl2_Transfer(This,pCall,fSync)	\
    ( (This)->lpVtbl -> Transfer(This,pCall,fSync) ) 

#define ITBasicCallControl2_BlindTransfer(This,pDestAddress)	\
    ( (This)->lpVtbl -> BlindTransfer(This,pDestAddress) ) 

#define ITBasicCallControl2_SwapHold(This,pCall)	\
    ( (This)->lpVtbl -> SwapHold(This,pCall) ) 

#define ITBasicCallControl2_ParkDirect(This,pParkAddress)	\
    ( (This)->lpVtbl -> ParkDirect(This,pParkAddress) ) 

#define ITBasicCallControl2_ParkIndirect(This,ppNonDirAddress)	\
    ( (This)->lpVtbl -> ParkIndirect(This,ppNonDirAddress) ) 

#define ITBasicCallControl2_Unpark(This)	\
    ( (This)->lpVtbl -> Unpark(This) ) 

#define ITBasicCallControl2_SetQOS(This,lMediaType,ServiceLevel)	\
    ( (This)->lpVtbl -> SetQOS(This,lMediaType,ServiceLevel) ) 

#define ITBasicCallControl2_Pickup(This,pGroupID)	\
    ( (This)->lpVtbl -> Pickup(This,pGroupID) ) 

#define ITBasicCallControl2_Dial(This,pDestAddress)	\
    ( (This)->lpVtbl -> Dial(This,pDestAddress) ) 

#define ITBasicCallControl2_Finish(This,finishMode)	\
    ( (This)->lpVtbl -> Finish(This,finishMode) ) 

#define ITBasicCallControl2_RemoveFromConference(This)	\
    ( (This)->lpVtbl -> RemoveFromConference(This) ) 


#define ITBasicCallControl2_RequestTerminal(This,bstrTerminalClassGUID,lMediaType,Direction,ppTerminal)	\
    ( (This)->lpVtbl -> RequestTerminal(This,bstrTerminalClassGUID,lMediaType,Direction,ppTerminal) ) 

#define ITBasicCallControl2_SelectTerminalOnCall(This,pTerminal)	\
    ( (This)->lpVtbl -> SelectTerminalOnCall(This,pTerminal) ) 

#define ITBasicCallControl2_UnselectTerminalOnCall(This,pTerminal)	\
    ( (This)->lpVtbl -> UnselectTerminalOnCall(This,pTerminal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITBasicCallControl2_INTERFACE_DEFINED__ */


#ifndef __ITScriptableAudioFormat_INTERFACE_DEFINED__
#define __ITScriptableAudioFormat_INTERFACE_DEFINED__

/* interface ITScriptableAudioFormat */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITScriptableAudioFormat;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B87658BD-3C59-4f64-BE74-AEDE3E86A81E")
    ITScriptableAudioFormat : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Channels( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Channels( 
            /* [in] */ const long nNewVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SamplesPerSec( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SamplesPerSec( 
            /* [in] */ const long nNewVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AvgBytesPerSec( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AvgBytesPerSec( 
            /* [in] */ const long nNewVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockAlign( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BlockAlign( 
            /* [in] */ const long nNewVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BitsPerSample( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BitsPerSample( 
            /* [in] */ const long nNewVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FormatTag( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FormatTag( 
            /* [in] */ const long nNewVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITScriptableAudioFormatVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITScriptableAudioFormat * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITScriptableAudioFormat * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITScriptableAudioFormat * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITScriptableAudioFormat * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITScriptableAudioFormat * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITScriptableAudioFormat * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITScriptableAudioFormat * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Channels )( 
            ITScriptableAudioFormat * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Channels )( 
            ITScriptableAudioFormat * This,
            /* [in] */ const long nNewVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SamplesPerSec )( 
            ITScriptableAudioFormat * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SamplesPerSec )( 
            ITScriptableAudioFormat * This,
            /* [in] */ const long nNewVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AvgBytesPerSec )( 
            ITScriptableAudioFormat * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AvgBytesPerSec )( 
            ITScriptableAudioFormat * This,
            /* [in] */ const long nNewVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockAlign )( 
            ITScriptableAudioFormat * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BlockAlign )( 
            ITScriptableAudioFormat * This,
            /* [in] */ const long nNewVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BitsPerSample )( 
            ITScriptableAudioFormat * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BitsPerSample )( 
            ITScriptableAudioFormat * This,
            /* [in] */ const long nNewVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FormatTag )( 
            ITScriptableAudioFormat * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FormatTag )( 
            ITScriptableAudioFormat * This,
            /* [in] */ const long nNewVal);
        
        END_INTERFACE
    } ITScriptableAudioFormatVtbl;

    interface ITScriptableAudioFormat
    {
        CONST_VTBL struct ITScriptableAudioFormatVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITScriptableAudioFormat_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITScriptableAudioFormat_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITScriptableAudioFormat_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITScriptableAudioFormat_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITScriptableAudioFormat_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITScriptableAudioFormat_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITScriptableAudioFormat_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITScriptableAudioFormat_get_Channels(This,pVal)	\
    ( (This)->lpVtbl -> get_Channels(This,pVal) ) 

#define ITScriptableAudioFormat_put_Channels(This,nNewVal)	\
    ( (This)->lpVtbl -> put_Channels(This,nNewVal) ) 

#define ITScriptableAudioFormat_get_SamplesPerSec(This,pVal)	\
    ( (This)->lpVtbl -> get_SamplesPerSec(This,pVal) ) 

#define ITScriptableAudioFormat_put_SamplesPerSec(This,nNewVal)	\
    ( (This)->lpVtbl -> put_SamplesPerSec(This,nNewVal) ) 

#define ITScriptableAudioFormat_get_AvgBytesPerSec(This,pVal)	\
    ( (This)->lpVtbl -> get_AvgBytesPerSec(This,pVal) ) 

#define ITScriptableAudioFormat_put_AvgBytesPerSec(This,nNewVal)	\
    ( (This)->lpVtbl -> put_AvgBytesPerSec(This,nNewVal) ) 

#define ITScriptableAudioFormat_get_BlockAlign(This,pVal)	\
    ( (This)->lpVtbl -> get_BlockAlign(This,pVal) ) 

#define ITScriptableAudioFormat_put_BlockAlign(This,nNewVal)	\
    ( (This)->lpVtbl -> put_BlockAlign(This,nNewVal) ) 

#define ITScriptableAudioFormat_get_BitsPerSample(This,pVal)	\
    ( (This)->lpVtbl -> get_BitsPerSample(This,pVal) ) 

#define ITScriptableAudioFormat_put_BitsPerSample(This,nNewVal)	\
    ( (This)->lpVtbl -> put_BitsPerSample(This,nNewVal) ) 

#define ITScriptableAudioFormat_get_FormatTag(This,pVal)	\
    ( (This)->lpVtbl -> get_FormatTag(This,pVal) ) 

#define ITScriptableAudioFormat_put_FormatTag(This,nNewVal)	\
    ( (This)->lpVtbl -> put_FormatTag(This,nNewVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITScriptableAudioFormat_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_tapi3if_0000_0083 */
/* [local] */ 

/****************************************
 * Terminal Classes
 ****************************************/

// Video Windows - {F7438990-D6EB-11d0-82A6-00AA00B5CA1B}
EXTERN_C const CLSID CLSID_VideoWindowTerm;

// Video input (camera) {AAF578EC-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_VideoInputTerminal;

// Handset device {AAF578EB-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_HandsetTerminal;

// Headset device {AAF578ED-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_HeadsetTerminal;

// Speakerphone device {AAF578EE-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_SpeakerphoneTerminal;

// Microphone (sound card) {AAF578EF-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_MicrophoneTerminal;

// Speakers (sound card) {AAF578F0-DC70-11d0-8ED3-00C04FB6809F}
EXTERN_C const CLSID CLSID_SpeakersTerminal;

// Media stream terminal {E2F7AEF7-4971-11D1-A671-006097C9A2E8}
EXTERN_C const CLSID CLSID_MediaStreamTerminal;

// File Recording terminal {521F3D06-C3D0-4511-8617-86B9A783DA77}
EXTERN_C const CLSID CLSID_FileRecordingTerminal;

// File Recording Track {BF14A2E4-E88B-4ef5-9740-5AC5D022F8C9}
EXTERN_C const CLSID CLSID_FileRecordingTrack;

// File Playback Terminal {0CB9914C-79CD-47dc-ADB0-327F47CEFB20}
EXTERN_C const CLSID CLSID_FilePlaybackTerminal;

// define the media modes
#define TAPIMEDIATYPE_AUDIO                     0x8
#define TAPIMEDIATYPE_VIDEO                     0x8000
#define TAPIMEDIATYPE_DATAMODEM                 0x10
#define TAPIMEDIATYPE_G3FAX                     0x20
#define TAPIMEDIATYPE_MULTITRACK                0x10000

// {831CE2D6-83B5-11d1-BB5C-00C04FB6809F}
EXTERN_C const CLSID TAPIPROTOCOL_PSTN;

// {831CE2D7-83B5-11d1-BB5C-00C04FB6809F}
EXTERN_C const CLSID TAPIPROTOCOL_H323;

// {831CE2D8-83B5-11d1-BB5C-00C04FB6809F}
EXTERN_C const CLSID TAPIPROTOCOL_Multicast;

#define __TapiConstants_MODULE_DEFINED__


extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0000_0083_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3if_0000_0083_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs9sp1\sdk\include\Tapi3.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for tapi3.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tapi3_h__
#define __tapi3_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITAgent_FWD_DEFINED__
#define __ITAgent_FWD_DEFINED__
typedef interface ITAgent ITAgent;
#endif 	/* __ITAgent_FWD_DEFINED__ */


#ifndef __ITAgentSession_FWD_DEFINED__
#define __ITAgentSession_FWD_DEFINED__
typedef interface ITAgentSession ITAgentSession;
#endif 	/* __ITAgentSession_FWD_DEFINED__ */


#ifndef __ITACDGroup_FWD_DEFINED__
#define __ITACDGroup_FWD_DEFINED__
typedef interface ITACDGroup ITACDGroup;
#endif 	/* __ITACDGroup_FWD_DEFINED__ */


#ifndef __ITQueue_FWD_DEFINED__
#define __ITQueue_FWD_DEFINED__
typedef interface ITQueue ITQueue;
#endif 	/* __ITQueue_FWD_DEFINED__ */


#ifndef __ITAgentEvent_FWD_DEFINED__
#define __ITAgentEvent_FWD_DEFINED__
typedef interface ITAgentEvent ITAgentEvent;
#endif 	/* __ITAgentEvent_FWD_DEFINED__ */


#ifndef __ITAgentSessionEvent_FWD_DEFINED__
#define __ITAgentSessionEvent_FWD_DEFINED__
typedef interface ITAgentSessionEvent ITAgentSessionEvent;
#endif 	/* __ITAgentSessionEvent_FWD_DEFINED__ */


#ifndef __ITACDGroupEvent_FWD_DEFINED__
#define __ITACDGroupEvent_FWD_DEFINED__
typedef interface ITACDGroupEvent ITACDGroupEvent;
#endif 	/* __ITACDGroupEvent_FWD_DEFINED__ */


#ifndef __ITQueueEvent_FWD_DEFINED__
#define __ITQueueEvent_FWD_DEFINED__
typedef interface ITQueueEvent ITQueueEvent;
#endif 	/* __ITQueueEvent_FWD_DEFINED__ */


#ifndef __ITAgentHandlerEvent_FWD_DEFINED__
#define __ITAgentHandlerEvent_FWD_DEFINED__
typedef interface ITAgentHandlerEvent ITAgentHandlerEvent;
#endif 	/* __ITAgentHandlerEvent_FWD_DEFINED__ */


#ifndef __ITTAPICallCenter_FWD_DEFINED__
#define __ITTAPICallCenter_FWD_DEFINED__
typedef interface ITTAPICallCenter ITTAPICallCenter;
#endif 	/* __ITTAPICallCenter_FWD_DEFINED__ */


#ifndef __ITAgentHandler_FWD_DEFINED__
#define __ITAgentHandler_FWD_DEFINED__
typedef interface ITAgentHandler ITAgentHandler;
#endif 	/* __ITAgentHandler_FWD_DEFINED__ */


#ifndef __IEnumAgent_FWD_DEFINED__
#define __IEnumAgent_FWD_DEFINED__
typedef interface IEnumAgent IEnumAgent;
#endif 	/* __IEnumAgent_FWD_DEFINED__ */


#ifndef __IEnumAgentSession_FWD_DEFINED__
#define __IEnumAgentSession_FWD_DEFINED__
typedef interface IEnumAgentSession IEnumAgentSession;
#endif 	/* __IEnumAgentSession_FWD_DEFINED__ */


#ifndef __IEnumQueue_FWD_DEFINED__
#define __IEnumQueue_FWD_DEFINED__
typedef interface IEnumQueue IEnumQueue;
#endif 	/* __IEnumQueue_FWD_DEFINED__ */


#ifndef __IEnumACDGroup_FWD_DEFINED__
#define __IEnumACDGroup_FWD_DEFINED__
typedef interface IEnumACDGroup IEnumACDGroup;
#endif 	/* __IEnumACDGroup_FWD_DEFINED__ */


#ifndef __IEnumAgentHandler_FWD_DEFINED__
#define __IEnumAgentHandler_FWD_DEFINED__
typedef interface IEnumAgentHandler IEnumAgentHandler;
#endif 	/* __IEnumAgentHandler_FWD_DEFINED__ */


#ifndef __ITAMMediaFormat_FWD_DEFINED__
#define __ITAMMediaFormat_FWD_DEFINED__
typedef interface ITAMMediaFormat ITAMMediaFormat;
#endif 	/* __ITAMMediaFormat_FWD_DEFINED__ */


#ifndef __ITAllocatorProperties_FWD_DEFINED__
#define __ITAllocatorProperties_FWD_DEFINED__
typedef interface ITAllocatorProperties ITAllocatorProperties;
#endif 	/* __ITAllocatorProperties_FWD_DEFINED__ */


#ifndef __ITPluggableTerminalEventSink_FWD_DEFINED__
#define __ITPluggableTerminalEventSink_FWD_DEFINED__
typedef interface ITPluggableTerminalEventSink ITPluggableTerminalEventSink;
#endif 	/* __ITPluggableTerminalEventSink_FWD_DEFINED__ */


#ifndef __ITPluggableTerminalEventSinkRegistration_FWD_DEFINED__
#define __ITPluggableTerminalEventSinkRegistration_FWD_DEFINED__
typedef interface ITPluggableTerminalEventSinkRegistration ITPluggableTerminalEventSinkRegistration;
#endif 	/* __ITPluggableTerminalEventSinkRegistration_FWD_DEFINED__ */


#ifndef __ITMSPAddress_FWD_DEFINED__
#define __ITMSPAddress_FWD_DEFINED__
typedef interface ITMSPAddress ITMSPAddress;
#endif 	/* __ITMSPAddress_FWD_DEFINED__ */


#ifndef __ITAgent_FWD_DEFINED__
#define __ITAgent_FWD_DEFINED__
typedef interface ITAgent ITAgent;
#endif 	/* __ITAgent_FWD_DEFINED__ */


#ifndef __ITAgentEvent_FWD_DEFINED__
#define __ITAgentEvent_FWD_DEFINED__
typedef interface ITAgentEvent ITAgentEvent;
#endif 	/* __ITAgentEvent_FWD_DEFINED__ */


#ifndef __ITAgentSession_FWD_DEFINED__
#define __ITAgentSession_FWD_DEFINED__
typedef interface ITAgentSession ITAgentSession;
#endif 	/* __ITAgentSession_FWD_DEFINED__ */


#ifndef __ITAgentSessionEvent_FWD_DEFINED__
#define __ITAgentSessionEvent_FWD_DEFINED__
typedef interface ITAgentSessionEvent ITAgentSessionEvent;
#endif 	/* __ITAgentSessionEvent_FWD_DEFINED__ */


#ifndef __ITACDGroup_FWD_DEFINED__
#define __ITACDGroup_FWD_DEFINED__
typedef interface ITACDGroup ITACDGroup;
#endif 	/* __ITACDGroup_FWD_DEFINED__ */


#ifndef __ITACDGroupEvent_FWD_DEFINED__
#define __ITACDGroupEvent_FWD_DEFINED__
typedef interface ITACDGroupEvent ITACDGroupEvent;
#endif 	/* __ITACDGroupEvent_FWD_DEFINED__ */


#ifndef __ITQueue_FWD_DEFINED__
#define __ITQueue_FWD_DEFINED__
typedef interface ITQueue ITQueue;
#endif 	/* __ITQueue_FWD_DEFINED__ */


#ifndef __ITQueueEvent_FWD_DEFINED__
#define __ITQueueEvent_FWD_DEFINED__
typedef interface ITQueueEvent ITQueueEvent;
#endif 	/* __ITQueueEvent_FWD_DEFINED__ */


#ifndef __ITTAPICallCenter_FWD_DEFINED__
#define __ITTAPICallCenter_FWD_DEFINED__
typedef interface ITTAPICallCenter ITTAPICallCenter;
#endif 	/* __ITTAPICallCenter_FWD_DEFINED__ */


#ifndef __ITAgentHandler_FWD_DEFINED__
#define __ITAgentHandler_FWD_DEFINED__
typedef interface ITAgentHandler ITAgentHandler;
#endif 	/* __ITAgentHandler_FWD_DEFINED__ */


#ifndef __ITAgentHandlerEvent_FWD_DEFINED__
#define __ITAgentHandlerEvent_FWD_DEFINED__
typedef interface ITAgentHandlerEvent ITAgentHandlerEvent;
#endif 	/* __ITAgentHandlerEvent_FWD_DEFINED__ */


#ifndef __ITTAPIDispatchEventNotification_FWD_DEFINED__
#define __ITTAPIDispatchEventNotification_FWD_DEFINED__
typedef interface ITTAPIDispatchEventNotification ITTAPIDispatchEventNotification;
#endif 	/* __ITTAPIDispatchEventNotification_FWD_DEFINED__ */


#ifndef __TAPI_FWD_DEFINED__
#define __TAPI_FWD_DEFINED__

#ifdef __cplusplus
typedef class TAPI TAPI;
#else
typedef struct TAPI TAPI;
#endif /* __cplusplus */

#endif 	/* __TAPI_FWD_DEFINED__ */


#ifndef __DispatchMapper_FWD_DEFINED__
#define __DispatchMapper_FWD_DEFINED__

#ifdef __cplusplus
typedef class DispatchMapper DispatchMapper;
#else
typedef struct DispatchMapper DispatchMapper;
#endif /* __cplusplus */

#endif 	/* __DispatchMapper_FWD_DEFINED__ */


#ifndef __RequestMakeCall_FWD_DEFINED__
#define __RequestMakeCall_FWD_DEFINED__

#ifdef __cplusplus
typedef class RequestMakeCall RequestMakeCall;
#else
typedef struct RequestMakeCall RequestMakeCall;
#endif /* __cplusplus */

#endif 	/* __RequestMakeCall_FWD_DEFINED__ */


#ifndef __ITTAPIDispatchEventNotification_FWD_DEFINED__
#define __ITTAPIDispatchEventNotification_FWD_DEFINED__
typedef interface ITTAPIDispatchEventNotification ITTAPIDispatchEventNotification;
#endif 	/* __ITTAPIDispatchEventNotification_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "tapi3if.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_tapi3_0000_0000 */
/* [local] */ 

/* Copyright (c) Microsoft Corporation. All rights reserved. */
/* Copyright (c) Microsoft Corporation. All rights reserved. */
typedef 
enum AGENT_EVENT
    {	AE_NOT_READY	= 0,
	AE_READY	= ( AE_NOT_READY + 1 ) ,
	AE_BUSY_ACD	= ( AE_READY + 1 ) ,
	AE_BUSY_INCOMING	= ( AE_BUSY_ACD + 1 ) ,
	AE_BUSY_OUTGOING	= ( AE_BUSY_INCOMING + 1 ) ,
	AE_UNKNOWN	= ( AE_BUSY_OUTGOING + 1 ) 
    } 	AGENT_EVENT;

typedef 
enum AGENT_STATE
    {	AS_NOT_READY	= 0,
	AS_READY	= ( AS_NOT_READY + 1 ) ,
	AS_BUSY_ACD	= ( AS_READY + 1 ) ,
	AS_BUSY_INCOMING	= ( AS_BUSY_ACD + 1 ) ,
	AS_BUSY_OUTGOING	= ( AS_BUSY_INCOMING + 1 ) ,
	AS_UNKNOWN	= ( AS_BUSY_OUTGOING + 1 ) 
    } 	AGENT_STATE;

typedef 
enum AGENT_SESSION_EVENT
    {	ASE_NEW_SESSION	= 0,
	ASE_NOT_READY	= ( ASE_NEW_SESSION + 1 ) ,
	ASE_READY	= ( ASE_NOT_READY + 1 ) ,
	ASE_BUSY	= ( ASE_READY + 1 ) ,
	ASE_WRAPUP	= ( ASE_BUSY + 1 ) ,
	ASE_END	= ( ASE_WRAPUP + 1 ) 
    } 	AGENT_SESSION_EVENT;

typedef 
enum AGENT_SESSION_STATE
    {	ASST_NOT_READY	= 0,
	ASST_READY	= ( ASST_NOT_READY + 1 ) ,
	ASST_BUSY_ON_CALL	= ( ASST_READY + 1 ) ,
	ASST_BUSY_WRAPUP	= ( ASST_BUSY_ON_CALL + 1 ) ,
	ASST_SESSION_ENDED	= ( ASST_BUSY_WRAPUP + 1 ) 
    } 	AGENT_SESSION_STATE;

typedef 
enum AGENTHANDLER_EVENT
    {	AHE_NEW_AGENTHANDLER	= 0,
	AHE_AGENTHANDLER_REMOVED	= ( AHE_NEW_AGENTHANDLER + 1 ) 
    } 	AGENTHANDLER_EVENT;

typedef 
enum ACDGROUP_EVENT
    {	ACDGE_NEW_GROUP	= 0,
	ACDGE_GROUP_REMOVED	= ( ACDGE_NEW_GROUP + 1 ) 
    } 	ACDGROUP_EVENT;

typedef 
enum ACDQUEUE_EVENT
    {	ACDQE_NEW_QUEUE	= 0,
	ACDQE_QUEUE_REMOVED	= ( ACDQE_NEW_QUEUE + 1 ) 
    } 	ACDQUEUE_EVENT;


















extern RPC_IF_HANDLE __MIDL_itf_tapi3_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tapi3_0000_0000_v0_0_s_ifspec;

#ifndef __ITAgent_INTERFACE_DEFINED__
#define __ITAgent_INTERFACE_DEFINED__

/* interface ITAgent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5770ECE5-4B27-11d1-BF80-00805FC147D3")
    ITAgent : public IDispatch
    {
    public:
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAgentSessions( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentSession **ppEnumAgentSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [in] */ __RPC__in_opt ITACDGroup *pACDGroup,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppAgentSession) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSessionWithPIN( 
            /* [in] */ __RPC__in_opt ITACDGroup *pACDGroup,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [in] */ __RPC__in BSTR pPIN,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppAgentSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_User( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUser) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ AGENT_STATE AgentState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out AGENT_STATE *pAgentState) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MeasurementPeriod( 
            /* [in] */ long lPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeasurementPeriod( 
            /* [retval][out] */ __RPC__out long *plPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_OverallCallRate( 
            /* [retval][out] */ __RPC__out CURRENCY *pcyCallrate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfACDCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfIncomingCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfOutgoingCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalACDTalkTime( 
            /* [retval][out] */ __RPC__out long *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalACDCallTime( 
            /* [retval][out] */ __RPC__out long *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalWrapUpTime( 
            /* [retval][out] */ __RPC__out long *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentSessions( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateAgentSessions )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentSession **ppEnumAgentSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateSession )( 
            ITAgent * This,
            /* [in] */ __RPC__in_opt ITACDGroup *pACDGroup,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppAgentSession);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateSessionWithPIN )( 
            ITAgent * This,
            /* [in] */ __RPC__in_opt ITACDGroup *pACDGroup,
            /* [in] */ __RPC__in_opt ITAddress *pAddress,
            /* [in] */ __RPC__in BSTR pPIN,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppAgentSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_User )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppUser);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_State )( 
            ITAgent * This,
            /* [in] */ AGENT_STATE AgentState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out AGENT_STATE *pAgentState);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MeasurementPeriod )( 
            ITAgent * This,
            /* [in] */ long lPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeasurementPeriod )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OverallCallRate )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out CURRENCY *pcyCallrate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfACDCalls )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfIncomingCalls )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfOutgoingCalls )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalACDTalkTime )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalACDCallTime )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalWrapUpTime )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out long *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgentSessions )( 
            ITAgent * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITAgentVtbl;

    interface ITAgent
    {
        CONST_VTBL struct ITAgentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgent_EnumerateAgentSessions(This,ppEnumAgentSession)	\
    ( (This)->lpVtbl -> EnumerateAgentSessions(This,ppEnumAgentSession) ) 

#define ITAgent_CreateSession(This,pACDGroup,pAddress,ppAgentSession)	\
    ( (This)->lpVtbl -> CreateSession(This,pACDGroup,pAddress,ppAgentSession) ) 

#define ITAgent_CreateSessionWithPIN(This,pACDGroup,pAddress,pPIN,ppAgentSession)	\
    ( (This)->lpVtbl -> CreateSessionWithPIN(This,pACDGroup,pAddress,pPIN,ppAgentSession) ) 

#define ITAgent_get_ID(This,ppID)	\
    ( (This)->lpVtbl -> get_ID(This,ppID) ) 

#define ITAgent_get_User(This,ppUser)	\
    ( (This)->lpVtbl -> get_User(This,ppUser) ) 

#define ITAgent_put_State(This,AgentState)	\
    ( (This)->lpVtbl -> put_State(This,AgentState) ) 

#define ITAgent_get_State(This,pAgentState)	\
    ( (This)->lpVtbl -> get_State(This,pAgentState) ) 

#define ITAgent_put_MeasurementPeriod(This,lPeriod)	\
    ( (This)->lpVtbl -> put_MeasurementPeriod(This,lPeriod) ) 

#define ITAgent_get_MeasurementPeriod(This,plPeriod)	\
    ( (This)->lpVtbl -> get_MeasurementPeriod(This,plPeriod) ) 

#define ITAgent_get_OverallCallRate(This,pcyCallrate)	\
    ( (This)->lpVtbl -> get_OverallCallRate(This,pcyCallrate) ) 

#define ITAgent_get_NumberOfACDCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumberOfACDCalls(This,plCalls) ) 

#define ITAgent_get_NumberOfIncomingCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumberOfIncomingCalls(This,plCalls) ) 

#define ITAgent_get_NumberOfOutgoingCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumberOfOutgoingCalls(This,plCalls) ) 

#define ITAgent_get_TotalACDTalkTime(This,plTalkTime)	\
    ( (This)->lpVtbl -> get_TotalACDTalkTime(This,plTalkTime) ) 

#define ITAgent_get_TotalACDCallTime(This,plCallTime)	\
    ( (This)->lpVtbl -> get_TotalACDCallTime(This,plCallTime) ) 

#define ITAgent_get_TotalWrapUpTime(This,plWrapUpTime)	\
    ( (This)->lpVtbl -> get_TotalWrapUpTime(This,plWrapUpTime) ) 

#define ITAgent_get_AgentSessions(This,pVariant)	\
    ( (This)->lpVtbl -> get_AgentSessions(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgent_INTERFACE_DEFINED__ */


#ifndef __ITAgentSession_INTERFACE_DEFINED__
#define __ITAgentSession_INTERFACE_DEFINED__

/* interface ITAgentSession */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3147-4BCC-11d1-BF80-00805FC147D3")
    ITAgentSession : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Agent( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDGroup( 
            /* [retval][out] */ __RPC__deref_out_opt ITACDGroup **ppACDGroup) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_State( 
            /* [in] */ AGENT_SESSION_STATE SessionState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_State( 
            /* [retval][out] */ __RPC__out AGENT_SESSION_STATE *pSessionState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionStartTime( 
            /* [retval][out] */ __RPC__out DATE *pdateSessionStart) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionDuration( 
            /* [retval][out] */ __RPC__out long *plDuration) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfCalls( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalTalkTime( 
            /* [retval][out] */ __RPC__out long *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageTalkTime( 
            /* [retval][out] */ __RPC__out long *plTalkTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallTime( 
            /* [retval][out] */ __RPC__out long *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageCallTime( 
            /* [retval][out] */ __RPC__out long *plCallTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalWrapUpTime( 
            /* [retval][out] */ __RPC__out long *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageWrapUpTime( 
            /* [retval][out] */ __RPC__out long *plWrapUpTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDCallRate( 
            /* [retval][out] */ __RPC__out CURRENCY *pcyCallrate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongestTimeToAnswer( 
            /* [retval][out] */ __RPC__out long *plAnswerTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageTimeToAnswer( 
            /* [retval][out] */ __RPC__out long *plAnswerTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentSession * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentSession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentSession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Agent )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAddress **ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ACDGroup )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__deref_out_opt ITACDGroup **ppACDGroup);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_State )( 
            ITAgentSession * This,
            /* [in] */ AGENT_SESSION_STATE SessionState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_State )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out AGENT_SESSION_STATE *pSessionState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionStartTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out DATE *pdateSessionStart);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionDuration )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plDuration);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfCalls )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalTalkTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageTalkTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plTalkTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageCallTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plCallTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalWrapUpTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageWrapUpTime )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plWrapUpTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ACDCallRate )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out CURRENCY *pcyCallrate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LongestTimeToAnswer )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plAnswerTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageTimeToAnswer )( 
            ITAgentSession * This,
            /* [retval][out] */ __RPC__out long *plAnswerTime);
        
        END_INTERFACE
    } ITAgentSessionVtbl;

    interface ITAgentSession
    {
        CONST_VTBL struct ITAgentSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentSession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentSession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentSession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentSession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentSession_get_Agent(This,ppAgent)	\
    ( (This)->lpVtbl -> get_Agent(This,ppAgent) ) 

#define ITAgentSession_get_Address(This,ppAddress)	\
    ( (This)->lpVtbl -> get_Address(This,ppAddress) ) 

#define ITAgentSession_get_ACDGroup(This,ppACDGroup)	\
    ( (This)->lpVtbl -> get_ACDGroup(This,ppACDGroup) ) 

#define ITAgentSession_put_State(This,SessionState)	\
    ( (This)->lpVtbl -> put_State(This,SessionState) ) 

#define ITAgentSession_get_State(This,pSessionState)	\
    ( (This)->lpVtbl -> get_State(This,pSessionState) ) 

#define ITAgentSession_get_SessionStartTime(This,pdateSessionStart)	\
    ( (This)->lpVtbl -> get_SessionStartTime(This,pdateSessionStart) ) 

#define ITAgentSession_get_SessionDuration(This,plDuration)	\
    ( (This)->lpVtbl -> get_SessionDuration(This,plDuration) ) 

#define ITAgentSession_get_NumberOfCalls(This,plCalls)	\
    ( (This)->lpVtbl -> get_NumberOfCalls(This,plCalls) ) 

#define ITAgentSession_get_TotalTalkTime(This,plTalkTime)	\
    ( (This)->lpVtbl -> get_TotalTalkTime(This,plTalkTime) ) 

#define ITAgentSession_get_AverageTalkTime(This,plTalkTime)	\
    ( (This)->lpVtbl -> get_AverageTalkTime(This,plTalkTime) ) 

#define ITAgentSession_get_TotalCallTime(This,plCallTime)	\
    ( (This)->lpVtbl -> get_TotalCallTime(This,plCallTime) ) 

#define ITAgentSession_get_AverageCallTime(This,plCallTime)	\
    ( (This)->lpVtbl -> get_AverageCallTime(This,plCallTime) ) 

#define ITAgentSession_get_TotalWrapUpTime(This,plWrapUpTime)	\
    ( (This)->lpVtbl -> get_TotalWrapUpTime(This,plWrapUpTime) ) 

#define ITAgentSession_get_AverageWrapUpTime(This,plWrapUpTime)	\
    ( (This)->lpVtbl -> get_AverageWrapUpTime(This,plWrapUpTime) ) 

#define ITAgentSession_get_ACDCallRate(This,pcyCallrate)	\
    ( (This)->lpVtbl -> get_ACDCallRate(This,pcyCallrate) ) 

#define ITAgentSession_get_LongestTimeToAnswer(This,plAnswerTime)	\
    ( (This)->lpVtbl -> get_LongestTimeToAnswer(This,plAnswerTime) ) 

#define ITAgentSession_get_AverageTimeToAnswer(This,plAnswerTime)	\
    ( (This)->lpVtbl -> get_AverageTimeToAnswer(This,plAnswerTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentSession_INTERFACE_DEFINED__ */


#ifndef __ITACDGroup_INTERFACE_DEFINED__
#define __ITACDGroup_INTERFACE_DEFINED__

/* interface ITACDGroup */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITACDGroup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3148-4BCC-11d1-BF80-00805FC147D3")
    ITACDGroup : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateQueues( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumQueue **ppEnumQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Queues( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITACDGroupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITACDGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITACDGroup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITACDGroup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITACDGroup * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITACDGroup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITACDGroup * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITACDGroup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITACDGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateQueues )( 
            ITACDGroup * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumQueue **ppEnumQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Queues )( 
            ITACDGroup * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITACDGroupVtbl;

    interface ITACDGroup
    {
        CONST_VTBL struct ITACDGroupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITACDGroup_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITACDGroup_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITACDGroup_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITACDGroup_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITACDGroup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITACDGroup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITACDGroup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITACDGroup_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#define ITACDGroup_EnumerateQueues(This,ppEnumQueue)	\
    ( (This)->lpVtbl -> EnumerateQueues(This,ppEnumQueue) ) 

#define ITACDGroup_get_Queues(This,pVariant)	\
    ( (This)->lpVtbl -> get_Queues(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITACDGroup_INTERFACE_DEFINED__ */


#ifndef __ITQueue_INTERFACE_DEFINED__
#define __ITQueue_INTERFACE_DEFINED__

/* interface ITQueue */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3149-4BCC-11d1-BF80-00805FC147D3")
    ITQueue : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MeasurementPeriod( 
            /* [in] */ long lPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MeasurementPeriod( 
            /* [retval][out] */ __RPC__out long *plPeriod) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsQueued( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentCallsQueued( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsAbandoned( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsFlowedIn( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalCallsFlowedOut( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LongestEverWaitTime( 
            /* [retval][out] */ __RPC__out long *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentLongestWaitTime( 
            /* [retval][out] */ __RPC__out long *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AverageWaitTime( 
            /* [retval][out] */ __RPC__out long *plWaitTime) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FinalDisposition( 
            /* [retval][out] */ __RPC__out long *plCalls) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITQueueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITQueue * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITQueue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITQueue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITQueue * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITQueue * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITQueue * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITQueue * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MeasurementPeriod )( 
            ITQueue * This,
            /* [in] */ long lPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MeasurementPeriod )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plPeriod);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallsQueued )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentCallsQueued )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallsAbandoned )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallsFlowedIn )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalCallsFlowedOut )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LongestEverWaitTime )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentLongestWaitTime )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AverageWaitTime )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plWaitTime);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FinalDisposition )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__out long *plCalls);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITQueue * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        END_INTERFACE
    } ITQueueVtbl;

    interface ITQueue
    {
        CONST_VTBL struct ITQueueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITQueue_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITQueue_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITQueue_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITQueue_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITQueue_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITQueue_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITQueue_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITQueue_put_MeasurementPeriod(This,lPeriod)	\
    ( (This)->lpVtbl -> put_MeasurementPeriod(This,lPeriod) ) 

#define ITQueue_get_MeasurementPeriod(This,plPeriod)	\
    ( (This)->lpVtbl -> get_MeasurementPeriod(This,plPeriod) ) 

#define ITQueue_get_TotalCallsQueued(This,plCalls)	\
    ( (This)->lpVtbl -> get_TotalCallsQueued(This,plCalls) ) 

#define ITQueue_get_CurrentCallsQueued(This,plCalls)	\
    ( (This)->lpVtbl -> get_CurrentCallsQueued(This,plCalls) ) 

#define ITQueue_get_TotalCallsAbandoned(This,plCalls)	\
    ( (This)->lpVtbl -> get_TotalCallsAbandoned(This,plCalls) ) 

#define ITQueue_get_TotalCallsFlowedIn(This,plCalls)	\
    ( (This)->lpVtbl -> get_TotalCallsFlowedIn(This,plCalls) ) 

#define ITQueue_get_TotalCallsFlowedOut(This,plCalls)	\
    ( (This)->lpVtbl -> get_TotalCallsFlowedOut(This,plCalls) ) 

#define ITQueue_get_LongestEverWaitTime(This,plWaitTime)	\
    ( (This)->lpVtbl -> get_LongestEverWaitTime(This,plWaitTime) ) 

#define ITQueue_get_CurrentLongestWaitTime(This,plWaitTime)	\
    ( (This)->lpVtbl -> get_CurrentLongestWaitTime(This,plWaitTime) ) 

#define ITQueue_get_AverageWaitTime(This,plWaitTime)	\
    ( (This)->lpVtbl -> get_AverageWaitTime(This,plWaitTime) ) 

#define ITQueue_get_FinalDisposition(This,plCalls)	\
    ( (This)->lpVtbl -> get_FinalDisposition(This,plCalls) ) 

#define ITQueue_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITQueue_INTERFACE_DEFINED__ */


#ifndef __ITAgentEvent_INTERFACE_DEFINED__
#define __ITAgentEvent_INTERFACE_DEFINED__

/* interface ITAgentEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314A-4BCC-11d1-BF80-00805FC147D3")
    ITAgentEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Agent( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out AGENT_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Agent )( 
            ITAgentEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITAgentEvent * This,
            /* [retval][out] */ __RPC__out AGENT_EVENT *pEvent);
        
        END_INTERFACE
    } ITAgentEventVtbl;

    interface ITAgentEvent
    {
        CONST_VTBL struct ITAgentEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentEvent_get_Agent(This,ppAgent)	\
    ( (This)->lpVtbl -> get_Agent(This,ppAgent) ) 

#define ITAgentEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentEvent_INTERFACE_DEFINED__ */


#ifndef __ITAgentSessionEvent_INTERFACE_DEFINED__
#define __ITAgentSessionEvent_INTERFACE_DEFINED__

/* interface ITAgentSessionEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentSessionEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314B-4BCC-11d1-BF80-00805FC147D3")
    ITAgentSessionEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppSession) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out AGENT_SESSION_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentSessionEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentSessionEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentSessionEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentSessionEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentSessionEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentSessionEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentSessionEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentSessionEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Session )( 
            ITAgentSessionEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentSession **ppSession);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITAgentSessionEvent * This,
            /* [retval][out] */ __RPC__out AGENT_SESSION_EVENT *pEvent);
        
        END_INTERFACE
    } ITAgentSessionEventVtbl;

    interface ITAgentSessionEvent
    {
        CONST_VTBL struct ITAgentSessionEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentSessionEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentSessionEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentSessionEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentSessionEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentSessionEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentSessionEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentSessionEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentSessionEvent_get_Session(This,ppSession)	\
    ( (This)->lpVtbl -> get_Session(This,ppSession) ) 

#define ITAgentSessionEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentSessionEvent_INTERFACE_DEFINED__ */


#ifndef __ITACDGroupEvent_INTERFACE_DEFINED__
#define __ITACDGroupEvent_INTERFACE_DEFINED__

/* interface ITACDGroupEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITACDGroupEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3032-BD11-11d1-A0A7-00805FC147D3")
    ITACDGroupEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Group( 
            /* [retval][out] */ __RPC__deref_out_opt ITACDGroup **ppGroup) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out ACDGROUP_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITACDGroupEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITACDGroupEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITACDGroupEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITACDGroupEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITACDGroupEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITACDGroupEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITACDGroupEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITACDGroupEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Group )( 
            ITACDGroupEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITACDGroup **ppGroup);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITACDGroupEvent * This,
            /* [retval][out] */ __RPC__out ACDGROUP_EVENT *pEvent);
        
        END_INTERFACE
    } ITACDGroupEventVtbl;

    interface ITACDGroupEvent
    {
        CONST_VTBL struct ITACDGroupEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITACDGroupEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITACDGroupEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITACDGroupEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITACDGroupEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITACDGroupEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITACDGroupEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITACDGroupEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITACDGroupEvent_get_Group(This,ppGroup)	\
    ( (This)->lpVtbl -> get_Group(This,ppGroup) ) 

#define ITACDGroupEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITACDGroupEvent_INTERFACE_DEFINED__ */


#ifndef __ITQueueEvent_INTERFACE_DEFINED__
#define __ITQueueEvent_INTERFACE_DEFINED__

/* interface ITQueueEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITQueueEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3033-BD11-11d1-A0A7-00805FC147D3")
    ITQueueEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Queue( 
            /* [retval][out] */ __RPC__deref_out_opt ITQueue **ppQueue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out ACDQUEUE_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITQueueEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITQueueEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITQueueEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITQueueEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITQueueEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITQueueEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITQueueEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITQueueEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Queue )( 
            ITQueueEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITQueue **ppQueue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITQueueEvent * This,
            /* [retval][out] */ __RPC__out ACDQUEUE_EVENT *pEvent);
        
        END_INTERFACE
    } ITQueueEventVtbl;

    interface ITQueueEvent
    {
        CONST_VTBL struct ITQueueEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITQueueEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITQueueEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITQueueEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITQueueEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITQueueEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITQueueEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITQueueEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITQueueEvent_get_Queue(This,ppQueue)	\
    ( (This)->lpVtbl -> get_Queue(This,ppQueue) ) 

#define ITQueueEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITQueueEvent_INTERFACE_DEFINED__ */


#ifndef __ITAgentHandlerEvent_INTERFACE_DEFINED__
#define __ITAgentHandlerEvent_INTERFACE_DEFINED__

/* interface ITAgentHandlerEvent */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentHandlerEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("297F3034-BD11-11d1-A0A7-00805FC147D3")
    ITAgentHandlerEvent : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentHandler( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgentHandler **ppAgentHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Event( 
            /* [retval][out] */ __RPC__out AGENTHANDLER_EVENT *pEvent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentHandlerEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentHandlerEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentHandlerEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentHandlerEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentHandlerEvent * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentHandlerEvent * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentHandlerEvent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentHandlerEvent * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgentHandler )( 
            ITAgentHandlerEvent * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgentHandler **ppAgentHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Event )( 
            ITAgentHandlerEvent * This,
            /* [retval][out] */ __RPC__out AGENTHANDLER_EVENT *pEvent);
        
        END_INTERFACE
    } ITAgentHandlerEventVtbl;

    interface ITAgentHandlerEvent
    {
        CONST_VTBL struct ITAgentHandlerEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentHandlerEvent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentHandlerEvent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentHandlerEvent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentHandlerEvent_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentHandlerEvent_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentHandlerEvent_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentHandlerEvent_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentHandlerEvent_get_AgentHandler(This,ppAgentHandler)	\
    ( (This)->lpVtbl -> get_AgentHandler(This,ppAgentHandler) ) 

#define ITAgentHandlerEvent_get_Event(This,pEvent)	\
    ( (This)->lpVtbl -> get_Event(This,pEvent) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentHandlerEvent_INTERFACE_DEFINED__ */


#ifndef __ITTAPICallCenter_INTERFACE_DEFINED__
#define __ITTAPICallCenter_INTERFACE_DEFINED__

/* interface ITTAPICallCenter */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITTAPICallCenter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3154-4BCC-11d1-BF80-00805FC147D3")
    ITTAPICallCenter : public IDispatch
    {
    public:
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAgentHandlers( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentHandler **ppEnumHandler) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AgentHandlers( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITTAPICallCenterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITTAPICallCenter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITTAPICallCenter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITTAPICallCenter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITTAPICallCenter * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITTAPICallCenter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITTAPICallCenter * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITTAPICallCenter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateAgentHandlers )( 
            ITTAPICallCenter * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentHandler **ppEnumHandler);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AgentHandlers )( 
            ITTAPICallCenter * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITTAPICallCenterVtbl;

    interface ITTAPICallCenter
    {
        CONST_VTBL struct ITTAPICallCenterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITTAPICallCenter_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITTAPICallCenter_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITTAPICallCenter_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITTAPICallCenter_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITTAPICallCenter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITTAPICallCenter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITTAPICallCenter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITTAPICallCenter_EnumerateAgentHandlers(This,ppEnumHandler)	\
    ( (This)->lpVtbl -> EnumerateAgentHandlers(This,ppEnumHandler) ) 

#define ITTAPICallCenter_get_AgentHandlers(This,pVariant)	\
    ( (This)->lpVtbl -> get_AgentHandlers(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITTAPICallCenter_INTERFACE_DEFINED__ */


#ifndef __ITAgentHandler_INTERFACE_DEFINED__
#define __ITAgentHandler_INTERFACE_DEFINED__

/* interface ITAgentHandler */
/* [object][dual][helpstring][uuid] */ 


EXTERN_C const IID IID_ITAgentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587E8C22-9802-11d1-A0A4-00805FC147D3")
    ITAgentHandler : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAgent( 
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateAgentWithID( 
            /* [in] */ __RPC__in BSTR pID,
            /* [in] */ __RPC__in BSTR pPIN,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateACDGroups( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumACDGroup **ppEnumACDGroup) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateUsableAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ACDGroups( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsableAddresses( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITAgentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITAgentHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITAgentHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITAgentHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ITAgentHandler * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ITAgentHandler * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ITAgentHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITAgentHandler * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateAgent )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateAgentWithID )( 
            ITAgentHandler * This,
            /* [in] */ __RPC__in BSTR pID,
            /* [in] */ __RPC__in BSTR pPIN,
            /* [retval][out] */ __RPC__deref_out_opt ITAgent **ppAgent);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateACDGroups )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumACDGroup **ppEnumACDGroup);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateUsableAddresses )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAddress **ppEnumAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ACDGroups )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsableAddresses )( 
            ITAgentHandler * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ITAgentHandlerVtbl;

    interface ITAgentHandler
    {
        CONST_VTBL struct ITAgentHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITAgentHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITAgentHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITAgentHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITAgentHandler_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ITAgentHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ITAgentHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ITAgentHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ITAgentHandler_get_Name(This,ppName)	\
    ( (This)->lpVtbl -> get_Name(This,ppName) ) 

#define ITAgentHandler_CreateAgent(This,ppAgent)	\
    ( (This)->lpVtbl -> CreateAgent(This,ppAgent) ) 

#define ITAgentHandler_CreateAgentWithID(This,pID,pPIN,ppAgent)	\
    ( (This)->lpVtbl -> CreateAgentWithID(This,pID,pPIN,ppAgent) ) 

#define ITAgentHandler_EnumerateACDGroups(This,ppEnumACDGroup)	\
    ( (This)->lpVtbl -> EnumerateACDGroups(This,ppEnumACDGroup) ) 

#define ITAgentHandler_EnumerateUsableAddresses(This,ppEnumAddress)	\
    ( (This)->lpVtbl -> EnumerateUsableAddresses(This,ppEnumAddress) ) 

#define ITAgentHandler_get_ACDGroups(This,pVariant)	\
    ( (This)->lpVtbl -> get_ACDGroups(This,pVariant) ) 

#define ITAgentHandler_get_UsableAddresses(This,pVariant)	\
    ( (This)->lpVtbl -> get_UsableAddresses(This,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITAgentHandler_INTERFACE_DEFINED__ */


#ifndef __IEnumAgent_INTERFACE_DEFINED__
#define __IEnumAgent_INTERFACE_DEFINED__

/* interface IEnumAgent */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAgent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314D-4BCC-11d1-BF80-00805FC147D3")
    IEnumAgent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgent **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgent **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAgentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAgent * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAgent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAgent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAgent * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgent **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumAgent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumAgent * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumAgent * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgent **ppEnum);
        
        END_INTERFACE
    } IEnumAgentVtbl;

    interface IEnumAgent
    {
        CONST_VTBL struct IEnumAgentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAgent_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumAgent_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumAgent_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumAgent_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumAgent_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumAgent_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumAgent_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumAgent_INTERFACE_DEFINED__ */


#ifndef __IEnumAgentSession_INTERFACE_DEFINED__
#define __IEnumAgentSession_INTERFACE_DEFINED__

/* interface IEnumAgentSession */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumAgentSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC314E-4BCC-11d1-BF80-00805FC147D3")
    IEnumAgentSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgentSession **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentSession **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAgentSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAgentSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAgentSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAgentSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAgentSession * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITAgentSession **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumAgentSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumAgentSession * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumAgentSession * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumAgentSession **ppEnum);
        
        END_INTERFACE
    } IEnumAgentSessionVtbl;

    interface IEnumAgentSession
    {
        CONST_VTBL struct IEnumAgentSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAgentSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumAgentSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumAgentSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumAgentSession_Next(This,celt,ppElements,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppElements,pceltFetched) ) 

#define IEnumAgentSession_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumAgentSession_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumAgentSession_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumAgentSession_INTERFACE_DEFINED__ */


#ifndef __IEnumQueue_INTERFACE_DEFINED__
#define __IEnumQueue_INTERFACE_DEFINED__

/* interface IEnumQueue */
/* [object][unique][hidden][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumQueue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AFC3158-4BCC-11d1-BF80-00805FC147D3")
    IEnumQueue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt ITQueue **ppElements,
            /* [out] */ __RPC__out ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IE